#pragma once

/*
* SDK generated by Dumper-7
*
* https://github.com/Encryqed/Dumper-7
*/

// Package: FunctionLibrary_Mission

#include "Basic.hpp"

#include "Engine_classes.hpp"
#include "BFGCore_structs.hpp"
#include "EMissionProgressionTags_structs.hpp"


namespace SDK
{

// BlueprintGeneratedClass FunctionLibrary_Mission.FunctionLibrary_Mission_C
// 0x0000 (0x0028 - 0x0028)
class UFunctionLibrary_Mission_C final : public UBlueprintFunctionLibrary
{
public:
	static void ShowPausedTutorial(TSoftObjectPtr<class UBFGDataAsset_PausedTutorial> InAsset, class UObject* __WorldContext);
	static void RefillPlayerAmmo(class UObject* __WorldContext);
	static void OverrideConstraintAlert(const struct FFConstrainAlert& InConstraintAlert, class UObject* __WorldContext);
	static void OpenWorldLevelLoading(TArray<TSoftObjectPtr<class UWorld>>& OpenWorldLevels, const class UObject* WorldContextObject, class UObject* __WorldContext);
	static void OverrideCrowdFlows(const struct FGameplayTagQuery& CrowdFlowTagQuery, const struct FGameplayTagQuery& OverrideTagQuery, EBFGCrowdflowOverride Override, class UObject* __WorldContext);
	static void OverrideBuildingSaveSystemTags(const struct FGameplayTagQuery& Gameplay_Tag_Query_Tag_Query, const struct FGameplayTagContainer& SaveTagToApply, class UObject* __WorldContext);
	static void ToggleMentalInteraction(const struct FGameplayTagQuery& Gameplay_Tag_Query, const TSoftObjectPtr<class AActor> ActorQuery, bool Enabled_, float HoldTime_, EBFGAnimation_MentalAbilityPosture Posture_, const struct FGameplayTagContainer& CompetentAbitlitiesTags, class UObject* __WorldContext);
	static void GetChainReactionActorsByGameplayTagQuery(const struct FGameplayTagQuery& Chain_Reaction_Query, class UObject* __WorldContext, TArray<class UBP_Component_ChainReaction_C*>* Chain_Reaction_Actors);
	static void LandingSiteCallUFO(const struct FGameplayTagQuery& GameplayTagQuery, class UObject* __WorldContext);
	static void DeactivateOpportunityTargets(const struct FGameplayTagQuery& GameplayTagQuerry, const TSoftObjectPtr<class AActor> ActorQuery, class UObject* __WorldContext);
	static void LandingSitesUnlock(struct FGameplayTagQuery& Gameplay_Tag_Query, bool Unlocked_, class UObject* __WorldContext);
	static void ActivateOpportunityTargets(const struct FGameplayTagQuery& GameplayTagQuery, bool ActivateArrow, bool ActivateIcon, bool ActivateText, bool ActivateRadarMarker, const struct FSlateBrush& OverrideBrush, const class FText& InteractDisplayText, const class FString& InteractDecoratorString, bool IsEnemyMarker_, bool IsDeathPersistant_, bool IsPKPersistant_, bool IsPlayer_, float DisplayRange, TSoftObjectPtr<class AActor> ActorQuery, bool LinkToMentallyInteractable, bool UseWeaponTargetInsteadOfPsiMarker, class UObject* __WorldContext);
	static void PlayerUnlockGearLevel(EMissionProgressionTags MissionProgression, bool _bIsPermanent, class UObject* __WorldContext);
	static void PlayerRestrictSaucer(bool RestrcitCall_, bool RestrictEnter_, bool RestrictLand_, class UObject* __WorldContext);
	static void PlayerOverrideGameplayTags(const struct FGameplayTagContainer& _tags, bool Unlock, class UObject* __WorldContext);
	static void PlayerAutoEquipWeapon(bool FirstAvailableWeapon_, const class UClass* _rWeaponClass, bool UnequipAllWeapon_, class UObject* __WorldContext);
	static void OverrideAlertSystem(int32 AlertLevel, bool CapAlertLevel_, bool OverrideAlertLevel_, bool Locked_, bool SpawningEnabled_, class UObject* __WorldContext);
	static void DismissAllTutorialPanel(class UObject* __WorldContext);
	static void RemoveTutorialPanel(class UBFGDataAsset_TutorialPage* Tutorial_Page, class UObject* __WorldContext);
	static void PushTutorialPanel(class UBFGDataAsset_TutorialPage* Tutorial_Page, bool ClearStack_, class UObject* __WorldContext);

public:
	static class UClass* StaticClass()
	{
		return StaticBPGeneratedClassImpl<"FunctionLibrary_Mission_C">();
	}
	static class UFunctionLibrary_Mission_C* GetDefaultObj()
	{
		return GetDefaultObjImpl<UFunctionLibrary_Mission_C>();
	}
};
static_assert(alignof(UFunctionLibrary_Mission_C) == 0x000008, "Wrong alignment on UFunctionLibrary_Mission_C");
static_assert(sizeof(UFunctionLibrary_Mission_C) == 0x000028, "Wrong size on UFunctionLibrary_Mission_C");

}

