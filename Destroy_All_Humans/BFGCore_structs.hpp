#pragma once

/*
* SDK generated by Dumper-7
*
* https://github.com/Encryqed/Dumper-7
*/

// Package: BFGCore

#include "Basic.hpp"

#include "BFGVisualEffects_structs.hpp"
#include "CoreUObject_structs.hpp"
#include "MovieScene_structs.hpp"
#include "GameplayTags_structs.hpp"
#include "SlateCore_structs.hpp"
#include "AIModule_structs.hpp"
#include "Engine_structs.hpp"
#include "InputCore_structs.hpp"


namespace SDK
{

// Enum BFGCore.EBFGWidgetAnimationSubState
// NumValues: 0x0005
enum class EBFGWidgetAnimationSubState : uint8
{
	OFF                                      = 0,
	TURNING_ON                               = 1,
	ON                                       = 2,
	TURNING_OFF                              = 3,
	EBFGWidgetAnimationSubState_MAX          = 4,
};

// Enum BFGCore.EBFGInteractAnimation_AnimSelector
// NumValues: 0x0006
enum class EBFGInteractAnimation_AnimSelector : uint8
{
	IAA_DefaultAsset                         = 0,
	IAA_Start                                = 1,
	IAA_End                                  = 2,
	IAA_PanicEnd                             = 3,
	IAA_Variation                            = 4,
	IAA_MAX                                  = 5,
};

// Enum BFGCore.EBFGAnimation_Interact
// NumValues: 0x00F0
enum class EBFGAnimation_Interact : uint8
{
	None                                     = 0,
	Interact_AlreadySet                      = 1,
	SitBench_Start                           = 2,
	SitBench_Loop                            = 3,
	SitBench_End                             = 4,
	SitBench_End_Panic                       = 5,
	Drink_straw_03                           = 6,
	PaintWall_Loop                           = 7,
	Lean_on_wall_smoke                       = 8,
	Lean_on_wall                             = 9,
	Interact_BBQ_Start                       = 10,
	Interact_BBQ_Loop                        = 11,
	Interact_BBQ_End                         = 12,
	Interact_BBQ_EndPanic                    = 13,
	Beach_Lie_On_Ground_01_Start             = 14,
	Beach_Lie_On_Ground_01_Loop              = 15,
	Beach_Lie_On_Ground_01_End               = 16,
	Beach_Lie_On_Ground_01_End_Panic         = 17,
	Beach_Lie_On_Ground_02_Start             = 18,
	Beach_Lie_On_Ground_02_Loop              = 19,
	Beach_Lie_On_Ground_02_End               = 20,
	Beach_Lie_On_Ground_02_End_Panic         = 21,
	SitBench_B_Start                         = 22,
	SitBench_B_Loop                          = 23,
	SitBench_B_End                           = 24,
	SitBench_B_End_Panic                     = 25,
	SitBench_Newspaper_Start                 = 26,
	SitBench_Newspaper_Loop                  = 27,
	SitBench_Newspaper_End                   = 28,
	SitBench_Newspaper_End_Panic             = 29,
	Try_open_garage                          = 30,
	PaintFence_Loop                          = 31,
	Stand_guard                              = 32,
	Sit_on_pool_edge                         = 33,
	Check_self_01                            = 34,
	LeanWall_01_Loop                         = 35,
	Check_self_03                            = 36,
	Flirt_01                                 = 37,
	Flirt_02                                 = 38,
	LeanWall_02L_Loop                        = 39,
	Shovel_dirt                              = 40,
	Eat_food_02                              = 41,
	LeanWall_02R_Loop                        = 42,
	Drink_bottle_02                          = 43,
	Drink_bottle_03                          = 44,
	Drink_can_01                             = 45,
	LeanWall_03_Loop                         = 46,
	Drink_can_03                             = 47,
	Drink_straw_01                           = 48,
	Drink_straw_02                           = 49,
	PeeOnWall_Start                          = 50,
	PeeOnWall_Loop                           = 51,
	PeeOnWall_End                            = 52,
	PeeOnWall_End_Panic                      = 53,
	Use_hoe                                  = 54,
	Picnic01_Loop                            = 55,
	Eat_popcorn                              = 56,
	Eat_cotton_candy                         = 57,
	Check_self_02                            = 58,
	Picnic02_Loop                            = 59,
	Military_salute_01                       = 60,
	Flirt_03                                 = 61,
	ShovelHay_Start                          = 62,
	ShovelHay_Loop                           = 63,
	ShovelHay_End                            = 64,
	ShovelHay_End_Panic                      = 65,
	ReadNewspaper_Start                      = 66,
	ReadNewspaper_Loop                       = 67,
	ReadNewspaper_End                        = 68,
	ReadNewspaper_End_Panic                  = 69,
	Look_Start                               = 70,
	Look_Loop                                = 71,
	Look_End                                 = 72,
	Look_End_Panic                           = 73,
	Solo_Wait_Start                          = 74,
	Solo_Wait_Loop                           = 75,
	Solo_Wait_End                            = 76,
	Solo_Wait_End_Panic                      = 77,
	Sleep_Start                              = 78,
	Sleep_Loop                               = 79,
	Sleep_End                                = 80,
	Sleep_End_Panic                          = 81,
	SitAny_Start                             = 82,
	SitAny_Loop                              = 83,
	SitAny_End                               = 84,
	SitAny_End_Panic                         = 85,
	RifleShootingFunFair_Start               = 86,
	RifleShootingFunFair_Loop                = 87,
	RifleShootingFunFair_End                 = 88,
	RifleShootingFunFair_End_Panic           = 89,
	CarEnter                                 = 90,
	CarEnterFast                             = 91,
	CarDrive                                 = 92,
	CarExit                                  = 93,
	CarExitPanic                             = 94,
	SitChairTable_Left_Start                 = 95,
	SitChairTable_Left_Loop                  = 96,
	SitChairTable_Left_End                   = 97,
	SitChairTable_Left_Panic                 = 98,
	SitChairTable_Right_Start                = 99,
	SitChairTable_Right_Loop                 = 100,
	SitChairTable_Right_End                  = 101,
	SitChairTable_Right_Panic                = 102,
	CarPassengerIdle                         = 103,
	CarEnter_Right                           = 104,
	CarEnter_RightFast                       = 105,
	CarExit_Right                            = 106,
	CarExitPanic_Right                       = 107,
	GenericTalk_ArmsCrossed_Stand            = 108,
	GenericTalk_HandsOnHips_Stand            = 109,
	GenericTalk_Neutral_01                   = 110,
	TransportExit01                          = 111,
	TransportExit02                          = 112,
	TransportExit03                          = 113,
	TruckEnter                               = 114,
	TruckEnterFast                           = 115,
	TruckDrive                               = 116,
	TruckExit                                = 117,
	TruckExitPanic                           = 118,
	Truck_AggressiveExit                     = 119,
	MilkTruckEnter                           = 120,
	MilkTruckEnterFast                       = 121,
	MilkTruckDrive                           = 122,
	MilkTruckExit                            = 123,
	MilkTruckExitPanic                       = 124,
	MilkTruck_AggressiveExit                 = 125,
	TruckPassengerIdle                       = 126,
	TruckEnter_Right                         = 127,
	TruckEnter_RightFast                     = 128,
	TruckExit_Right                          = 129,
	TruckExitPanic_Right                     = 130,
	Truck_AggressiveExit_Right               = 131,
	Car_PanicLoop_01                         = 132,
	Car_PanicLoop_02                         = 133,
	Car_PanicLoop_03                         = 134,
	Car_AggressiveExit                       = 135,
	Car_AggressiveExit_Right                 = 136,
	Move_along                               = 137,
	Disarm_nuke                              = 138,
	Fix_electric_fence                       = 139,
	Mayor_briefing                           = 140,
	Lean_on_fence_smoke                      = 141,
	Use_watering_can                         = 142,
	Polish_car                               = 143,
	Do_pushups                               = 144,
	Police_write_note                        = 145,
	Puke                                     = 146,
	Need_to_go                               = 147,
	Search_trash                             = 148,
	Use_binoculars                           = 149,
	Use_metal_detector                       = 150,
	Drill_seargeant                          = 151,
	Talk_on_walkie_talkie                    = 152,
	Talk_on_walkie_talkie_angry              = 153,
	Type_on_keypad                           = 154,
	Put_letter_in_mailbox_small              = 155,
	Put_letter_in_mailbox_large              = 156,
	Rake_ground                              = 157,
	Use_detector                             = 158,
	Eat_food                                 = 159,
	Work_on_machine                          = 160,
	Clean_window                             = 161,
	Miss_Rockwell_stand                      = 162,
	Trim_hedge                               = 163,
	Stand_smoke                              = 164,
	Stand_arms_crossed_01                    = 165,
	Stand_arms_crossed_02                    = 166,
	Stand_arms_crossed_03                    = 167,
	Stand_arms_crossed_04                    = 168,
	Stand_hands_behind_back_01               = 169,
	Stand_hands_behind_back_02               = 170,
	Stand_hands_behind_back_03               = 171,
	Stand_hands_behind_back_04               = 172,
	Stand_var_01                             = 173,
	Stand_var_02                             = 174,
	Stand_var_03                             = 175,
	Stand_var_04                             = 176,
	Look_at_stuff_ground_01                  = 177,
	Look_at_stuff_ground_02                  = 178,
	Look_at_stuff_ground_03                  = 179,
	Look_at_stuff_mid_01                     = 180,
	Look_at_stuff_mid_02                     = 181,
	Look_at_stuff_mid_03                     = 182,
	Look_at_stuff_mid_04                     = 183,
	Look_at_stuff_front_01                   = 184,
	Look_at_stuff_front_02                   = 185,
	Look_at_stuff_front_03                   = 186,
	Look_at_stuff_front_04                   = 187,
	Stand_think_01                           = 188,
	Stand_think_02                           = 189,
	Stand_think_03                           = 190,
	Fair_vendor_01                           = 191,
	Fair_vendor_02                           = 192,
	Fair_vendor_03                           = 193,
	Military_exercise_01                     = 194,
	Military_exercise_02                     = 195,
	Military_exercise_03                     = 196,
	Whistle_01                               = 197,
	Whistle_02                               = 198,
	Whistle_03                               = 199,
	Cheer_01                                 = 200,
	Cheer_02                                 = 201,
	Cheer_03                                 = 202,
	Demo_Cheer_01                            = 203,
	Demo_Cheer_02                            = 204,
	Demo_Cheer_03                            = 205,
	Crazy_Guy                                = 206,
	Fishing                                  = 207,
	Jealous_01                               = 208,
	Jealous_02                               = 209,
	Jealous_03                               = 210,
	Scientist_Work                           = 211,
	Scientist_Look                           = 212,
	Waitress                                 = 213,
	Sit_Garden_Chair                         = 214,
	Scan_Me                                  = 215,
	Demo_Protest_01                          = 216,
	Demo_Protest_02                          = 217,
	Demo_Protest_03                          = 218,
	Dance_01                                 = 219,
	Dance_02                                 = 220,
	Dance_03                                 = 221,
	PlaceHolder_01                           = 222,
	PlaceHolder_02                           = 223,
	PlaceHolder_03                           = 224,
	PlaceHolder_04                           = 225,
	PlaceHolder_05                           = 226,
	PlaceHolder_06                           = 227,
	PlaceHolder_07                           = 228,
	PlaceHolder_08                           = 229,
	Drink_can_02                             = 230,
	Drink_bottle_01                          = 231,
	Polish_rifle                             = 232,
	Truck_PanicLoop_01                       = 233,
	Truck_PanicLoop_02                       = 234,
	Truck_PanicLoop_03                       = 235,
	MilkTruck_PanicLoop_01                   = 236,
	MilkTruck_PanicLoop_02                   = 237,
	MilkTruck_PanicLoop_03                   = 238,
	EBFGAnimation_MAX                        = 239,
};

// Enum BFGCore.EBFGFaction
// NumValues: 0x0007
enum class EBFGFaction : uint8
{
	None                                     = 0,
	Player                                   = 1,
	Enemy                                    = 2,
	Civilian                                 = 3,
	AnimalChicken                            = 4,
	AnimalCow                                = 5,
	EBFGFaction_MAX                          = 6,
};

// Enum BFGCore.EBFGCuriosityReason_NPC
// NumValues: 0x0007
enum class EBFGCuriosityReason_NPC : uint8
{
	None                                     = 0,
	SawCrypto                                = 1,
	HeardCrypto                              = 2,
	SawAnotherAlertedNPC                     = 3,
	InvestigativeStateTimedOut               = 4,
	Undefined                                = 5,
	EBFGCuriosityReason_MAX                  = 6,
};

// Enum BFGCore.EBFGMissionTargetAction_NPC
// NumValues: 0x000A
enum class EBFGMissionTargetAction_NPC : uint8
{
	Defend                                   = 0,
	Attack_spawn_alert                       = 1,
	Attack_prio_missiontarget                = 2,
	Attack_prio_crypto                       = 3,
	Interact                                 = 4,
	Force_Coward                             = 5,
	Force_AllyNonActiveToCrypto              = 6,
	MoveToInteract                           = 7,
	None                                     = 8,
	EBFGMissionTargetAction_MAX              = 9,
};

// Enum BFGCore.EBFGAlertSystemSeenState
// NumValues: 0x0004
enum class EBFGAlertSystemSeenState : uint8
{
	NotSeen                                  = 0,
	SeenTrueForm                             = 1,
	SeenHolobobbed                           = 2,
	EBFGAlertSystemSeenState_MAX             = 3,
};

// Enum BFGCore.EBFGAnimation_MentalAbilityPosture
// NumValues: 0x0008
enum class EBFGAnimation_MentalAbilityPosture : uint8
{
	None                                     = 0,
	MentalAbilityPosture_CortexScan          = 1,
	MentalAbilityPosture_ExtractBrain        = 2,
	MentalAbilityPosture_Holobob             = 3,
	MentalAbilityPosture_Hypnotize           = 4,
	MentalAbilityPosture_Psychokinesis       = 5,
	MentalAbilityPosture_Transmogrify        = 6,
	EBFGAnimation_MAX                        = 7,
};

// Enum BFGCore.EAbilityState
// NumValues: 0x0005
enum class EAbilityState : uint8
{
	EAbilityStateInactive                    = 0,
	EAbilityStateMentalLinking               = 1,
	EAbilityStateRunning                     = 2,
	EAbilityStateFading                      = 3,
	EAbilityState_MAX                        = 4,
};

// Enum BFGCore.EAbilityActivationResult
// NumValues: 0x0007
enum class EAbilityActivationResult : uint8
{
	EAbilityActivationSuccess                = 0,
	EAbilityActivationOutOfRange             = 1,
	EAbilityActivationInvalidTarget          = 2,
	EAbilityActivationOnCooldown             = 3,
	EAbilityActivationLocked                 = 4,
	EAbilityActivationAlreadyActiveOnSameTarget = 5,
	EAbilityActivationResult_MAX             = 6,
};

// Enum BFGCore.EBFGEvadeDirection
// NumValues: 0x0005
enum class EBFGEvadeDirection : uint8
{
	Left                                     = 0,
	Right                                    = 1,
	Back                                     = 2,
	Forward                                  = 3,
	EBFGEvadeDirection_MAX                   = 4,
};

// Enum BFGCore.EBFGAttackQuadrant
// NumValues: 0x0006
enum class EBFGAttackQuadrant : uint8
{
	None                                     = 0,
	Front                                    = 1,
	Back                                     = 2,
	Left                                     = 3,
	Right                                    = 4,
	EBFGAttackQuadrant_MAX                   = 5,
};

// Enum BFGCore.EBFGRocketSocket
// NumValues: 0x000E
enum class EBFGRocketSocket : uint8
{
	None                                     = 0,
	L_Top_1                                  = 1,
	L_Top_2                                  = 2,
	L_Top_3                                  = 3,
	L_Bottom_1                               = 4,
	L_Bottom_2                               = 5,
	L_Bottom_3                               = 6,
	R_Top_1                                  = 7,
	R_Top_2                                  = 8,
	R_Top_3                                  = 9,
	R_Bottom_1                               = 10,
	R_Bottom_2                               = 11,
	R_Bottom_3                               = 12,
	EBFGRocketSocket_MAX                     = 13,
};

// Enum BFGCore.EBFGBehaviourState_NPC
// NumValues: 0x000B
enum class EBFGBehaviourState_NPC : uint8
{
	Oblivious                                = 0,
	Curious                                  = 1,
	Investigative                            = 2,
	Alert                                    = 3,
	Hypnotized                               = 4,
	Distracted                               = 5,
	Transition                               = 6,
	Coward                                   = 7,
	Ally_NonActive                           = 8,
	Dead                                     = 9,
	EBFGBehaviourState_MAX                   = 10,
};

// Enum BFGCore.EBFGHypnotizeState_NPC
// NumValues: 0x0006
enum class EBFGHypnotizeState_NPC : uint8
{
	None                                     = 0,
	Distracted                               = 1,
	Distracting                              = 2,
	Forget                                   = 3,
	Follow                                   = 4,
	EBFGHypnotizeState_MAX                   = 5,
};

// Enum BFGCore.EBFGNetworkPathAgentComponent_AgentChangeReason
// NumValues: 0x0006
enum class EBFGNetworkPathAgentComponent_AgentChangeReason : uint8
{
	EndPlay                                  = 0,
	DespawnAgent                             = 1,
	CreatedNewAgent                          = 2,
	RegisteredAgent                          = 3,
	SpawnedByAgent                           = 4,
	EBFGNetworkPathAgentComponent_MAX        = 5,
};

// Enum BFGCore.UBFGNarrativeSequence_Assessment
// NumValues: 0x0003
enum class EUBFGNarrativeSequence_Assessment : uint8
{
	BAD                                      = 0,
	GOOD                                     = 1,
	UBFGNarrativeSequence_MAX                = 2,
};

// Enum BFGCore.EBFGEventContext_ScoreValueHint
// NumValues: 0x0003
enum class EBFGEventContext_ScoreValueHint : uint8
{
	None                                     = 0,
	MonetaryValue                            = 1,
	EBFGEventContext_MAX                     = 2,
};

// Enum BFGCore.EBFGTutorialPageDisplayStyle
// NumValues: 0x0007
enum class EBFGTutorialPageDisplayStyle : uint8
{
	NONE                                     = 0,
	COLLAPSED                                = 1,
	HINTED                                   = 2,
	COMPACT                                  = 3,
	NORMAL                                   = 4,
	DETAILED                                 = 5,
	EBFGTutorialPageDisplayStyle_MAX         = 6,
};

// Enum BFGCore.EBFGInputActionWidgetType
// NumValues: 0x0007
enum class EBFGInputActionWidgetType : uint8
{
	Default                                  = 0,
	Press                                    = 1,
	Hold                                     = 2,
	Release                                  = 3,
	Tap                                      = 4,
	Mash                                     = 5,
	EBFGInputActionWidgetType_MAX            = 6,
};

// Enum BFGCore.EBFGTutorialPageFadingState
// NumValues: 0x0004
enum class EBFGTutorialPageFadingState : uint8
{
	IDLE                                     = 0,
	FADING                                   = 1,
	DONE                                     = 2,
	EBFGTutorialPageFadingState_MAX          = 3,
};

// Enum BFGCore.EBFGHUDVisibilityState
// NumValues: 0x0008
enum class EBFGHUDVisibilityState : uint8
{
	COMPLETELY_OFF                           = 0,
	TRANSITION_CUTSCENE                      = 1,
	CUTSCENE                                 = 2,
	DEFAULT_GAMEPLAY                         = 3,
	DEFAULT_MENU                             = 4,
	WEAPON_SELECTION_WHEEL                   = 5,
	COMPLETELY_ON                            = 6,
	EBFGHUDVisibilityState_MAX               = 7,
};

// Enum BFGCore.EBFGTutorialIndicatorAnimationState
// NumValues: 0x0006
enum class EBFGTutorialIndicatorAnimationState : uint8
{
	INITIAL                                  = 0,
	POP_UP                                   = 1,
	INTERPOLATE                              = 2,
	VANISH                                   = 3,
	FINISHED                                 = 4,
	EBFGTutorialIndicatorAnimationState_MAX  = 5,
};

// Enum BFGCore.EBFGDialogMessage
// NumValues: 0x0006
enum class EBFGDialogMessage : uint8
{
	DEFAULT                                  = 0,
	SUCCESS                                  = 1,
	FAIL                                     = 2,
	SUCCESS_RETURN                           = 3,
	FAIL_RETURN                              = 4,
	EBFGDialogMessage_MAX                    = 5,
};

// Enum BFGCore.EBFGGenericDialogFlowSubState
// NumValues: 0x0006
enum class EBFGGenericDialogFlowSubState : uint8
{
	None                                     = 0,
	Init                                     = 1,
	Waiting                                  = 2,
	Finalized                                = 3,
	Finished                                 = 4,
	EBFGGenericDialogFlowSubState_MAX        = 5,
};

// Enum BFGCore.EMentalAbility_EventState
// NumValues: 0x0006
enum class EMentalAbility_EventState : uint8
{
	None                                     = 0,
	Channeling                               = 1,
	Started                                  = 2,
	Ended                                    = 3,
	Aborted                                  = 4,
	EMentalAbility_MAX                       = 5,
};

// Enum BFGCore.ItemValueTypeEnum
// NumValues: 0x000D
enum class EItemValueTypeEnum : uint8
{
	Health                                   = 0,
	DisintegratorRayAmmo                     = 1,
	IonDetonatorAmmo                         = 2,
	AnalProbeAmmo                            = 3,
	SaucerHealthArmor                        = 4,
	SaucerSonicBoomAmmo                      = 5,
	SaucerQuantumDeconstructorAmmo           = 6,
	DNABrain                                 = 7,
	DNAProbe                                 = 8,
	DNA_QuestReward                          = 9,
	DroneData                                = 10,
	None                                     = 11,
	ItemValueTypeEnum_MAX                    = 12,
};

// Enum BFGCore.EBFGQuest_BossObjective
// NumValues: 0x0005
enum class EBFGQuest_BossObjective : uint8
{
	None                                     = 0,
	BossArmquist_AirMine_Knockdown           = 1,
	BossRoboprez_HitOnWeakspot               = 2,
	BossSilhouette_CancelAttack_NasalProbe   = 3,
	EBFGQuest_MAX                            = 4,
};

// Enum BFGCore.EBFGDialogOptionHandler_SavegameSlotMode
// NumValues: 0x0004
enum class EBFGDialogOptionHandler_SavegameSlotMode : uint8
{
	NEW_GAME                                 = 0,
	LOAD_GAME                                = 1,
	SAVE_GAME                                = 2,
	EBFGDialogOptionHandler_MAX              = 3,
};

// Enum BFGCore.EBFGMothershipTransitionMethod
// NumValues: 0x0005
enum class EBFGMothershipTransitionMethod : uint8
{
	Smooth                                   = 0,
	ParabolicExtrapolated                    = 1,
	SmoothExtrapolated                       = 2,
	CustomCurve                              = 3,
	EBFGMothershipTransitionMethod_MAX       = 4,
};

// Enum BFGCore.EBFGObjectiveMarkerType
// NumValues: 0x0007
enum class EBFGObjectiveMarkerType : uint8
{
	None                                     = 0,
	LightBeam                                = 1,
	MapIcon                                  = 2,
	ScreenEdgeIcon                           = 3,
	OverheadIcon                             = 4,
	MaxNumTypes                              = 5,
	EBFGObjectiveMarkerType_MAX              = 6,
};

// Enum BFGCore.EBFGQuest_UI_BarType
// NumValues: 0x0006
enum class EBFGQuest_UI_BarType : uint8
{
	None                                     = 0,
	Segmented                                = 1,
	Continuous                               = 2,
	Auto                                     = 3,
	Numeric                                  = 4,
	EBFGQuest_UI_MAX                         = 5,
};

// Enum BFGCore.EBFGSaveSystem_ActionResult
// NumValues: 0x0004
enum class EBFGSaveSystem_ActionResult : uint8
{
	InProgress                               = 0,
	Success                                  = 1,
	Failed                                   = 2,
	EBFGSaveSystem_MAX                       = 3,
};

// Enum BFGCore.EBFGGameStatistic
// NumValues: 0x001A
enum class EBFGGameStatistic : uint8
{
	GameStat_INVALID                         = 0,
	GameStat_CowsAbducted                    = 1,
	GameStat_DNAColected                     = 2,
	GameStat_FuronProbesRecovered            = 3,
	GameStat_HoursPlayed                     = 4,
	GameStat_HumansDestroyed                 = 5,
	KilledCivilians                          = 6,
	KilledFarmers                            = 7,
	KilledCops                               = 8,
	KilledSheriffs                           = 9,
	KilledSoldiers                           = 10,
	KilledSergeants                          = 11,
	KilledAgents                             = 12,
	KilledMutants                            = 13,
	KilledTanks                              = 14,
	KilledPowersuits                         = 15,
	KilledWithZapomatic                      = 16,
	KilledWithDisintegrator                  = 17,
	KilledWithAnalProbe                      = 18,
	KilledWithIonDetonator                   = 19,
	KilledWithDeathray                       = 20,
	KilledWithSonicBoom                      = 21,
	KilledWithQuantumDeconstructor           = 22,
	KilledWithPKorAbductobeam                = 23,
	KilledWithBrainExtract                   = 24,
	EBFGGameStatistic_MAX                    = 25,
};

// Enum BFGCore.EBFGDialogOptionSelectionState
// NumValues: 0x0005
enum class EBFGDialogOptionSelectionState : uint8
{
	DISABLED                                 = 0,
	UNSELECTED                               = 1,
	SELECTED                                 = 2,
	ACTIVATED                                = 3,
	EBFGDialogOptionSelectionState_MAX       = 4,
};

// Enum BFGCore.EBFGKeyAssignmentState
// NumValues: 0x0005
enum class EBFGKeyAssignmentState : uint8
{
	WaitForKeyInput                          = 0,
	ShowOverridePrompt                       = 1,
	WaitForOverridePrompt                    = 2,
	Cleanup                                  = 3,
	EBFGKeyAssignmentState_MAX               = 4,
};

// Enum BFGCore.EBFGGameFlowState_MainMenu_State
// NumValues: 0x0008
enum class EBFGGameFlowState_MainMenu_State : uint8
{
	IntroDrone                               = 0,
	IntroDroneFinished                       = 1,
	IntroGifts                               = 2,
	IntroGiftsFinished                       = 3,
	IntroGiftsFebruary                       = 4,
	IntroGiftsFebruaryFinished               = 5,
	MainMenu                                 = 6,
	EBFGGameFlowState_MainMenu_MAX           = 7,
};

// Enum BFGCore.EBFGMotherShipPoxLabType
// NumValues: 0x0004
enum class EBFGMotherShipPoxLabType : uint8
{
	ENTRYPOINT                               = 0,
	CRYPTOUPGRADE                            = 1,
	SAUCERUPGRADE                            = 2,
	EBFGMotherShipPoxLabType_MAX             = 3,
};

// Enum BFGCore.EBFGPoxLabSubmenu
// NumValues: 0x0003
enum class EBFGPoxLabSubmenu : uint8
{
	UPPERUPGRADEPANEL                        = 0,
	LOWERUPGRADEPANEL                        = 1,
	EBFGPoxLabSubmenu_MAX                    = 2,
};

// Enum BFGCore.EBFGSelectionStatePoxLab
// NumValues: 0x0003
enum class EBFGSelectionStatePoxLab : uint8
{
	SPINNINGPANEL                            = 0,
	UPGRADEPANEL                             = 1,
	EBFGSelectionStatePoxLab_MAX             = 2,
};

// Enum BFGCore.EBFGPlaybackComponentState
// NumValues: 0x0006
enum class EBFGPlaybackComponentState : uint8
{
	Waiting                                  = 0,
	Playing                                  = 1,
	Canceling                                = 2,
	CancelingToSync                          = 3,
	Stopped                                  = 4,
	EBFGPlaybackComponentState_MAX           = 5,
};

// Enum BFGCore.EBFGVehiclePassenger_AnimationSetupID
// NumValues: 0x0005
enum class EBFGVehiclePassenger_AnimationSetupID : uint8
{
	VPA_None                                 = 0,
	VPA_Car                                  = 1,
	VPA_Truck                                = 2,
	VPA_MilkTruck                            = 3,
	VPA_MAX                                  = 4,
};

// Enum BFGCore.EBFGCortexScan_EntryPoint_SelectionMode
// NumValues: 0x0003
enum class EBFGCortexScan_EntryPoint_SelectionMode : uint8
{
	Random                                   = 0,
	TopToBottom                              = 1,
	EBFGCortexScan_EntryPoint_MAX            = 2,
};

// Enum BFGCore.EBFGActorAliveState
// NumValues: 0x0004
enum class EBFGActorAliveState : uint8
{
	STATE_DEAD                               = 0,
	STATE_ALIVE                              = 1,
	STATE_IGNORE                             = 2,
	STATE_MAX                                = 3,
};

// Enum BFGCore.EBFGBaseArmorType
// NumValues: 0x0011
enum class EBFGBaseArmorType : uint8
{
	None                                     = 0,
	Default                                  = 1,
	Human                                    = 2,
	HumanArmor                               = 3,
	Vehicle                                  = 4,
	VehicleArmor                             = 5,
	Building                                 = 6,
	BuildingArmor                            = 7,
	Alien                                    = 8,
	AlienSaucer                              = 9,
	PowersuitArmor                           = 10,
	RoboprezArmor                            = 11,
	Animal                                   = 12,
	Prop                                     = 13,
	Prop_AlienImmune                         = 14,
	EndOfArmorTypes                          = 15,
	EBFGBaseArmorType_MAX                    = 16,
};

// Enum BFGCore.EBFGCameraTimeCurveFunction
// NumValues: 0x0003
enum class EBFGCameraTimeCurveFunction : uint8
{
	ARM_ORIGIN_SPEED                         = 0,
	FOV_MODIFIER                             = 1,
	EBFGCameraTimeCurveFunction_MAX          = 2,
};

// Enum BFGCore.EBFGAIEquipCommandResult
// NumValues: 0x0004
enum class EBFGAIEquipCommandResult : uint8
{
	ECR_Failed                               = 0,
	ECR_InProgress                           = 1,
	ECR_Successed                            = 2,
	ECR_MAX                                  = 3,
};

// Enum BFGCore.EBFGInputDisableState
// NumValues: 0x0005
enum class EBFGInputDisableState : uint8
{
	ENABLED                                  = 0,
	FLUSH_STAGE1                             = 1,
	FLUSH_STAGE2                             = 2,
	FULL_DISABLED                            = 3,
	EBFGInputDisableState_MAX                = 4,
};

// Enum BFGCore.EBFGLevitationState
// NumValues: 0x0007
enum class EBFGLevitationState : uint8
{
	None                                     = 0,
	Start                                    = 1,
	MoveUp                                   = 2,
	Hover                                    = 3,
	MoveDown                                 = 4,
	Land                                     = 5,
	EBFGLevitationState_MAX                  = 6,
};

// Enum BFGCore.EBFGNPCCharacter_MoveSpeed
// NumValues: 0x000A
enum class EBFGNPCCharacter_MoveSpeed : uint8
{
	None                                     = 0,
	Walk                                     = 1,
	Run                                      = 2,
	Stalk                                    = 3,
	Trot                                     = 4,
	Galop                                    = 5,
	Walk_Alert                               = 6,
	Run_Alert                                = 7,
	Run_Hypno                                = 8,
	EBFGNPCCharacter_MAX                     = 9,
};

// Enum BFGCore.EBFGObjectiveStatus
// NumValues: 0x0005
enum class EBFGObjectiveStatus : uint8
{
	None                                     = 0,
	AddObjective                             = 1,
	Registered                               = 2,
	RemoveObjective                          = 3,
	EBFGObjectiveStatus_MAX                  = 4,
};

// Enum BFGCore.EBFGOverheatGlow
// NumValues: 0x0004
enum class EBFGOverheatGlow : uint8
{
	None                                     = 0,
	Mild                                     = 1,
	Bright                                   = 2,
	EBFGOverheatGlow_MAX                     = 3,
};

// Enum BFGCore.EBFGWidgetComponentEnableMode
// NumValues: 0x0005
enum class EBFGWidgetComponentEnableMode : uint8
{
	AlwaysDisabled                           = 0,
	EnabledOnDemand                          = 1,
	AlwaysEnabled                            = 2,
	Destroyed                                = 3,
	EBFGWidgetComponentEnableMode_MAX        = 4,
};

// Enum BFGCore.EBFGActorData_Instance_DataSource
// NumValues: 0x0004
enum class EBFGActorData_Instance_DataSource : uint8
{
	Actor                                    = 0,
	Agent                                    = 1,
	Proxy                                    = 2,
	EBFGActorData_Instance_MAX               = 3,
};

// Enum BFGCore.EBFGGameplayScaling
// NumValues: 0x0003
enum class EBFGGameplayScaling : uint8
{
	GameplayScaling_Crypto                   = 0,
	GameplayScaling_UFO                      = 1,
	GameplayScaling_MAX                      = 2,
};

// Enum BFGCore.EBFGNetworkPathAgentComponentInitialAI
// NumValues: 0x0006
enum class EBFGNetworkPathAgentComponentInitialAI : uint8
{
	Default                                  = 0,
	Standby                                  = 1,
	JoinCrowdLife                            = 2,
	Patrol                                   = 3,
	Off                                      = 4,
	EBFGNetworkPathAgentComponentInitialAI_MAX = 5,
};

// Enum BFGCore.EBFGAIControllerState
// NumValues: 0x0004
enum class EBFGAIControllerState : uint8
{
	DEFAULT                                  = 0,
	ACTORLESS                                = 1,
	HIBERNATED                               = 2,
	EBFGAIControllerState_MAX                = 3,
};

// Enum BFGCore.EBFGSensorGameplayOverrideBehavior
// NumValues: 0x0004
enum class EBFGSensorGameplayOverrideBehavior : uint8
{
	Default                                  = 0,
	DespawnNPCIfNotOblivious                 = 1,
	SetNPCToOblivious                        = 2,
	EBFGSensorGameplayOverrideBehavior_MAX   = 3,
};

// Enum BFGCore.EBFGAlertLevelIconType
// NumValues: 0x0008
enum class EBFGAlertLevelIconType : uint8
{
	None                                     = 0,
	L1_Uncritical                            = 1,
	L2_Police                                = 2,
	L2_Military                              = 3,
	L3_Military                              = 4,
	L3_HeavyMilitary                         = 5,
	L4_Agent                                 = 6,
	EBFGAlertLevelIconType_MAX               = 7,
};

// Enum BFGCore.EBFGTargetType
// NumValues: 0x0005
enum class EBFGTargetType : uint8
{
	Crypto                                   = 0,
	Ufo                                      = 1,
	None                                     = 2,
	Npc                                      = 3,
	EBFGTargetType_MAX                       = 4,
};

// Enum BFGCore.EBFGCombatMovementMode_Humanoid
// NumValues: 0x0003
enum class EBFGCombatMovementMode_Humanoid : uint8
{
	Relocating                               = 0,
	InPosition                               = 1,
	EBFGCombatMovementMode_MAX               = 2,
};

// Enum BFGCore.EBFGDefendState_NPC
// NumValues: 0x0007
enum class EBFGDefendState_NPC : uint8
{
	Reset                                    = 0,
	Follow                                   = 1,
	Combat_Follow                            = 2,
	Combat_Attack                            = 3,
	Combat_Defend                            = 4,
	Combat_Support                           = 5,
	EBFGDefendState_MAX                      = 6,
};

// Enum BFGCore.EBFGAttackState_NPC
// NumValues: 0x0005
enum class EBFGAttackState_NPC : uint8
{
	None                                     = 0,
	NoLineOfSiLght                           = 1,
	Reload                                   = 2,
	Attack                                   = 3,
	EBFGAttackState_MAX                      = 4,
};

// Enum BFGCore.EBFGCombatState_NPC
// NumValues: 0x000D
enum class EBFGCombatState_NPC : uint8
{
	None                                     = 0,
	RelocateFar                              = 1,
	RelocateClose                            = 2,
	InPosition                               = 3,
	Driving                                  = 4,
	SwitchTarget                             = 5,
	TargetLost                               = 6,
	Fleeing                                  = 7,
	Chasing                                  = 8,
	Abandoned                                = 9,
	ExitVehicle                              = 10,
	Locked                                   = 11,
	EBFGCombatState_MAX                      = 12,
};

// Enum BFGCore.EBFGGlobalCooldown
// NumValues: 0x0007
enum class EBFGGlobalCooldown : uint8
{
	None                                     = 0,
	Attack                                   = 1,
	ProtectiveBubble                         = 2,
	PowersuitSoldier                         = 3,
	RocketSoldier                            = 4,
	JumpableAOEAttack                        = 5,
	EBFGGlobalCooldown_MAX                   = 6,
};

// Enum BFGCore.EBFGCombatLock
// NumValues: 0x0003
enum class EBFGCombatLock : uint8
{
	UNLOCKED                                 = 0,
	DEFAULT                                  = 1,
	EBFGCombatLock_MAX                       = 2,
};

// Enum BFGCore.EBFGChaseSiteArrivalWishType
// NumValues: 0x0004
enum class EBFGChaseSiteArrivalWishType : uint8
{
	CSAW_WheneverAvailable                   = 0,
	CSAW_HasOverheadLimit                    = 1,
	CSAW_PickLowestCost                      = 2,
	CSAW_MAX                                 = 3,
};

// Enum BFGCore.EBFGChaseParticipantStatus
// NumValues: 0x0004
enum class EBFGChaseParticipantStatus : uint8
{
	CPS_Idle                                 = 0,
	CPS_MovingToSite                         = 1,
	CPS_OnSite                               = 2,
	CPS_MAX                                  = 3,
};

// Enum BFGCore.EBFGAIStatVariableName
// NumValues: 0x000B
enum class EBFGAIStatVariableName : uint8
{
	Invalid                                  = 0,
	HearingRadius                            = 1,
	SightRadius                              = 2,
	LoseSightRadius                          = 3,
	FieldOfViewAngle                         = 4,
	ResponseValueIncreaseNPCAlertTimer       = 5,
	NPCTriggerDistanceForResponseValueIncrease = 6,
	SightAutoSuccessRangeFromLastSeenLocation = 7,
	SightMaxZDistance                        = 8,
	VerticalFOVAngle                         = 9,
	EBFGAIStatVariableName_MAX               = 10,
};

// Enum BFGCore.EBFGAlertType
// NumValues: 0x0016
enum class EBFGAlertType : uint8
{
	None                                     = 0,
	MentalAbility_CortexScan                 = 1,
	MentalAbility_ExtractBrain               = 2,
	MentalAbility_Psychokinesis              = 3,
	MentalAbility_Holobob                    = 4,
	MentalAbility_Hypnotize                  = 5,
	MentalAbility_Transmogrify               = 6,
	MentalAbility_MentalInteract             = 7,
	CryptoDash_KnockDown                     = 8,
	Weapon_Crypto_Generic                    = 9,
	Weapon_AnalProbe                         = 10,
	Weapon_DisintegratorRay                  = 11,
	Weapon_IonDetonator                      = 12,
	Weapon_ZapOMatic                         = 13,
	Weapon_DeathRay                          = 14,
	Weapon_SonicBoom                         = 15,
	Weapon_QuantumDeconstructor              = 16,
	Health_Full                              = 17,
	Health_Changed                           = 18,
	Health_Dead                              = 19,
	Crypto_Spotted                           = 20,
	EBFGAlertType_MAX                        = 21,
};

// Enum BFGCore.EBFGAlertSystemState
// NumValues: 0x0007
enum class EBFGAlertSystemState : uint8
{
	NORESPONE                                = 0,
	POLICE                                   = 1,
	MILITARY                                 = 2,
	AGENT                                    = 3,
	CRYPTO_DETECTED                          = 100,
	CRYPTO_REPORTED                          = 101,
	EBFGAlertSystemState_MAX                 = 102,
};

// Enum BFGCore.EBFGNPCSpawnModeType
// NumValues: 0x0004
enum class EBFGNPCSpawnModeType : uint8
{
	FootOnly                                 = 0,
	VehicleOrFoot                            = 1,
	VehicleOnly                              = 2,
	EBFGNPCSpawnModeType_MAX                 = 3,
};

// Enum BFGCore.EBFGAlertTriggerMode
// NumValues: 0x0004
enum class EBFGAlertTriggerMode : uint8
{
	PerInstancePerWitness                    = 0,
	OnlyOncePerWitness                       = 1,
	OnlyOnce                                 = 2,
	EBFGAlertTriggerMode_MAX                 = 3,
};

// Enum BFGCore.EBFGAnimation_Sequence
// NumValues: 0x000D
enum class EBFGAnimation_Sequence : uint8
{
	None                                     = 0,
	AnalProbeStart                           = 1,
	CuriousEnd                               = 2,
	Distraction                              = 3,
	Hypnotize                                = 4,
	UnarmedIdle                              = 5,
	PistolIdle                               = 6,
	RifleIdle                                = 7,
	OnFire                                   = 8,
	AlertIdle                                = 9,
	AlertEnd                                 = 10,
	AlertCower                               = 11,
	EBFGAnimation_MAX                        = 12,
};

// Enum BFGCore.EBFGAnimation_WeaponPosture
// NumValues: 0x0012
enum class EBFGAnimation_WeaponPosture : uint8
{
	None                                     = 0,
	WeaponPosture_Handgun                    = 1,
	WeaponPosture_Shotgun                    = 2,
	WeaponPosture_DoubleBarrelShotgun        = 3,
	WeaponPosture_SemiAutomatic              = 4,
	WeaponPosture_Rifle                      = 5,
	WeaponPosture_Bazooka                    = 6,
	WeaponPosture_Grenade                    = 7,
	WeaponPosture_ZapOMatic                  = 8,
	WeaponPosture_DisintegratorRay           = 9,
	WeaponPosture_IonDetonator               = 10,
	WeaponPosture_AnalProbe                  = 11,
	WeaponPosture_PsiPulse                   = 12,
	WeaponPosture_PsiShield                  = 13,
	WeaponPosture_AgentPistol                = 14,
	WeaponPosture_AgentEnergyPistol          = 15,
	WeaponPosture_AgentEnergyRifle           = 16,
	EBFGAnimation_MAX                        = 17,
};

// Enum BFGCore.EReinforcementType
// NumValues: 0x0005
enum class EReinforcementType : uint8
{
	None                                     = 0,
	Single                                   = 1,
	Multiple                                 = 2,
	Child                                    = 3,
	EReinforcementType_MAX                   = 4,
};

// Enum BFGCore.EBFGBossSupport
// NumValues: 0x0003
enum class EBFGBossSupport : uint8
{
	Navy                                     = 0,
	Airforce                                 = 1,
	EBFGBossSupport_MAX                      = 2,
};

// Enum BFGCore.EBFGEQSWithFallbackType
// NumValues: 0x0004
enum class EBFGEQSWithFallbackType : uint8
{
	CURRENT_DIRECTION                        = 0,
	TOWARDS_TARGET                           = 1,
	AWAY_FROM_TARGET                         = 2,
	EBFGEQSWithFallbackType_MAX              = 3,
};

// Enum BFGCore.EBFGProtectiveBubbleState
// NumValues: 0x0006
enum class EBFGProtectiveBubbleState : uint8
{
	None                                     = 0,
	FailSafe                                 = 1,
	GetProtectTargetInRange                  = 2,
	ProtectTarget                            = 3,
	SustainLink                              = 4,
	EBFGProtectiveBubbleState_MAX            = 5,
};

// Enum BFGCore.EBFGBuilding_FloorCategory
// NumValues: 0x0004
enum class EBFGBuilding_FloorCategory : uint8
{
	Ground_Floor                             = 0,
	Middle_Floor                             = 1,
	Roof                                     = 2,
	EBFGBuilding_MAX                         = 3,
};

// Enum BFGCore.EBFGBuilding_DestructionState
// NumValues: 0x000B
enum class EBFGBuilding_DestructionState : uint8
{
	None                                     = 0,
	ExplosionStart                           = 1,
	ExplosionEffectsSimulate                 = 2,
	ExplosionSimulate                        = 3,
	ImplosionStart                           = 4,
	ImplosionSimulate                        = 5,
	Wait                                     = 6,
	RemoveRubble                             = 7,
	Ruins                                    = 8,
	RecordingPlayback                        = 9,
	EBFGBuilding_MAX                         = 10,
};

// Enum BFGCore.EBFGBuilding_DestructionBehavior
// NumValues: 0x0005
enum class EBFGBuilding_DestructionBehavior : uint8
{
	Destructible                             = 0,
	Disolve                                  = 1,
	JustTurnPhysically                       = 2,
	JustDisappear                            = 3,
	EBFGBuilding_MAX                         = 4,
};

// Enum BFGCore.EBFGBuilding_DestructionPhase
// NumValues: 0x0003
enum class EBFGBuilding_DestructionPhase : uint8
{
	Destruction_Explosion                    = 0,
	Destruction_Implosion                    = 1,
	Destruction_MAX                          = 2,
};

// Enum BFGCore.EBFGChallengeStartingPoint_Visibility
// NumValues: 0x0004
enum class EBFGChallengeStartingPoint_Visibility : uint8
{
	HIDDEN                                   = 0,
	PEEK                                     = 1,
	VISIBLE                                  = 2,
	EBFGChallengeStartingPoint_MAX           = 3,
};

// Enum BFGCore.EBFGCheatParamType
// NumValues: 0x0009
enum class EBFGCheatParamType : uint8
{
	TypeNone                                 = 0,
	TypeCommand                              = 1,
	TypeBool                                 = 2,
	TypeString                               = 3,
	TypeFollowerClass                        = 4,
	TypeObject                               = 5,
	TypeEnum                                 = 6,
	TypeCustomWidget                         = 7,
	EBFGCheatParamType_MAX                   = 8,
};

// Enum BFGCore.EBFGCollisionChannel
// NumValues: 0x0023
enum class EBFGCollisionChannel : uint8
{
	ECC_WorldStatic                          = 0,
	ECC_WorldDynamic                         = 1,
	ECC_Pawn                                 = 2,
	ECC_Visibility                           = 3,
	ECC_Camera                               = 4,
	ECC_PhysicsBody                          = 5,
	ECC_Vehicle                              = 6,
	ECC_Destructible                         = 7,
	ECC_EngineTraceChannel1                  = 8,
	ECC_EngineTraceChannel2                  = 9,
	ECC_EngineTraceChannel3                  = 10,
	ECC_EngineTraceChannel4                  = 11,
	ECC_EngineTraceChannel5                  = 12,
	ECC_EngineTraceChannel6                  = 13,
	Interactable                             = 14,
	Projectile                               = 15,
	PKSpringArm                              = 16,
	PCP_VehicleDeformer                      = 17,
	PCP_RoadSystemProbe                      = 18,
	Weapon_Bullet_Trace                      = 19,
	Auto_Target_Trace                        = 20,
	Weapon_Aim_Trace                         = 21,
	UFO                                      = 22,
	PCP_Burnable                             = 23,
	BuildingChunk                            = 24,
	CrowdLifeMesh                            = 25,
	DeadRagdoll                              = 26,
	FootIKTrace                              = 27,
	SkeletalPushBar                          = 28,
	VehicleObstacleTrace                     = 29,
	Boss                                     = 30,
	ECC_GameTraceChannel18                   = 31,
	ECC_OverlapAll_Deprecated                = 32,
	ECC_MAX                                  = 33,
	EBFGCollisionChannel_MAX                 = 34,
};

// Enum BFGCore.EBFGCrowdStation_AnimationSetType
// NumValues: 0x0006
enum class EBFGCrowdStation_AnimationSetType : uint8
{
	None                                     = 0,
	Single                                   = 1,
	Sequence                                 = 2,
	Random                                   = 3,
	Dialog                                   = 4,
	EBFGCrowdStation_MAX                     = 5,
};

// Enum BFGCore.EBFGCrowdScriptConAsset_Participant
// NumValues: 0x0006
enum class EBFGCrowdScriptConAsset_Participant : uint8
{
	None                                     = 0,
	Participant_A                            = 1,
	Participant_B                            = 2,
	Participant_C                            = 3,
	Participant_D                            = 4,
	EBFGCrowdScriptConAsset_MAX              = 5,
};

// Enum BFGCore.eBFG_CrowdScriptConPhase
// NumValues: 0x0008
enum class EBFG_CrowdScriptConPhase : uint8
{
	CSC_ScriptConPhase_None                  = 0,
	CSC_ScriptConPhase_Disabled              = 1,
	CSC_ScriptConPhase_Idle                  = 2,
	CSC_ScriptConPhase_Waiting_Participants  = 3,
	CSC_ScriptConPhase_Playing               = 4,
	CSC_ScriptConPhase_WaitingCooldown       = 5,
	CSC_ScriptConPhase_Exhausted             = 6,
	CSC_ScriptConPhase_MAX                   = 7,
};

// Enum BFGCore.eBFG_CrowdScriptConTriggeringBehaviour
// NumValues: 0x0004
enum class EBFG_CrowdScriptConTriggeringBehaviour : uint8
{
	CSC_TriggeringBehaviour_None             = 0,
	CSC_TriggeringBehaviour_One_Time_Playback = 1,
	CSC_TriggeringBehaviour_Multi_Playback   = 2,
	CSC_TriggeringBehaviour_MAX              = 3,
};

// Enum BFGCore.EBFGDamageTypeFromFeature
// NumValues: 0x0005
enum class EBFGDamageTypeFromFeature : uint8
{
	None                                     = 0,
	Weapon                                   = 1,
	Ability                                  = 2,
	Fall                                     = 3,
	EBFGDamageTypeFromFeature_MAX            = 4,
};

// Enum BFGCore.EBFGDamageTypeProperty
// NumValues: 0x0008
enum class EBFGDamageTypeProperty : uint8
{
	None                                     = 0,
	Electrocute                              = 1,
	ProbeAnal                                = 2,
	Disintegrate                             = 3,
	Explosion                                = 4,
	ExtractBrain                             = 5,
	Water                                    = 6,
	EBFGDamageTypeProperty_MAX               = 7,
};

// Enum BFGCore.EBFGDataAsset_ChallengeFailureMethod
// NumValues: 0x0003
enum class EBFGDataAsset_ChallengeFailureMethod : uint8
{
	MinimumValue                             = 0,
	QuestCompletion                          = 1,
	EBFGDataAsset_MAX                        = 2,
};

// Enum BFGCore.EBFGChallengeType
// NumValues: 0x0006
enum class EBFGChallengeType : uint8
{
	DELIVER                                  = 0,
	RACE                                     = 1,
	RAMPAGE                                  = 2,
	TRANSMOG                                 = 3,
	VANDALIZE                                = 4,
	EBFGChallengeType_MAX                    = 5,
};

// Enum BFGCore.EBFGQuestRewardsType
// NumValues: 0x0007
enum class EBFGQuestRewardsType : uint8
{
	None                                     = 0,
	Reward_UnlockUpgradeLabItem              = 1,
	Reward_GiveWeaponOrAbility               = 2,
	Reward_DNA                               = 3,
	Reward_ConceptArt                        = 4,
	Reward_Skin                              = 5,
	EBFGQuestRewardsType_MAX                 = 6,
};

// Enum BFGCore.EBFGDataAssetPoxLabUpgradeType
// NumValues: 0x0003
enum class EBFGDataAssetPoxLabUpgradeType : uint8
{
	CRYPTOUPGRADE                            = 0,
	SAUCERUPGRADE                            = 1,
	EBFGDataAssetPoxLabUpgradeType_MAX       = 2,
};

// Enum BFGCore.EBFGNarrativeSequenceID_Pox
// NumValues: 0x0007
enum class EBFGNarrativeSequenceID_Pox : uint8
{
	PoxSequence_None                         = 0,
	PoxSequence_Intro                        = 1,
	PoxSequence_Variation1                   = 2,
	PoxSequence_Variation2                   = 3,
	PoxSequence_Variation3                   = 4,
	PoxSequence_Variation4                   = 5,
	PoxSequence_MAX                          = 6,
};

// Enum BFGCore.EBFGDebugStartMenu_Mode
// NumValues: 0x0005
enum class EBFGDebugStartMenu_Mode : uint8
{
	Menu_Worlds                              = 0,
	Menu_Missions_Main                       = 1,
	Menu_Missions_Challenges                 = 2,
	Menu_MissionLocation                     = 3,
	Menu_MAX                                 = 4,
};

// Enum BFGCore.EBFGDLCItem
// NumValues: 0x0003
enum class EBFGDLCItem : uint8
{
	PREORDER                                 = 0,
	NONE                                     = 1,
	EBFGDLCItem_MAX                          = 2,
};

// Enum BFGCore.EBFGEffect_Identifier
// NumValues: 0x005C
enum class EBFGEffect_Identifier : uint8
{
	EffectIdentifier_Invalid                 = 0,
	EffectIdentifier_Quest_Objective_Slot_1  = 1,
	EffectIdentifier_Quest_Objective_Slot_2  = 2,
	EffectIdentifier_Quest_Objective_Slot_3  = 3,
	EffectIdentifier_Quest_Objective_Slot_4  = 4,
	EffectIdentifier_Quest_Objective_Slot_5  = 5,
	EffectIdentifier_Quest_Objective_Slot_6  = 6,
	EffectIdentifier_Quest_Objective_Slot_7  = 7,
	EffectIdentifier_Quest_Objective_Slot_8  = 8,
	EffectIdentifier_Quest_Objective_Slot_9  = 9,
	EffectIdentifier_Quest_Objective_Slot_10 = 10,
	EffectIdentifier_Bounce                  = 11,
	EffectIdentifier_Burn                    = 12,
	EffectIdentifier_Death                   = 13,
	EffectIdentifier_Dirt                    = 14,
	EffectIdentifier_Explode                 = 15,
	EffectIdentifier_FootStep                = 16,
	EffectIdentifier_Glow                    = 17,
	EffectIdentifier_Pickup                  = 18,
	EffectIdentifier_Pulse                   = 19,
	EffectIdentifier_Splash                  = 20,
	EffectIdentifier_Telegraphing            = 21,
	EffectIdentifier_Fireing                 = 22,
	EffectIdentifier_Honk                    = 23,
	EffectIdentifier_Siren                   = 24,
	EffectIdentifier_ExplodeHead             = 25,
	EffectIdentifier_LazerBeam               = 26,
	EffectIdentifier_Trigger                 = 27,
	EffectIdentifier_Failed                  = 28,
	EffectIdentifier_Reload                  = 29,
	EffectIdentifier_Damage                  = 30,
	EffectIdentifier_OutOfRange              = 31,
	EffectIdentifier_OnCooldown              = 32,
	EffectIdentifier_InvalidTarget           = 33,
	EffectIdentifier_Player_Enter            = 34,
	EffectIdentifier_Dash                    = 35,
	EffectIdentifier_Dash_Shockwave          = 36,
	EffectIdentifier_Dash_Shockwave2         = 37,
	EffectIdentifier_Dash_Shield             = 38,
	EffectIdentifier_Skate                   = 39,
	EffectIdentifier_SkateTrail              = 40,
	EffectIdentifier_Shield_Impact           = 41,
	EffectIdentifier_Jetpack_Deploy          = 42,
	EffectIdentifier_Jetpack_OutOfFuel       = 43,
	EffectIdentifier_Jetpack_Throttle        = 44,
	EffectIdentifier_MentalAbility           = 45,
	EffectIdentifier_MentalAbility_Overall   = 46,
	EffectIdentifier_MentalAbility_Link      = 47,
	EffectIdentifier_MentalAbility_Run       = 48,
	EffectIdentifier_MentalAbility_Target    = 49,
	EffectIdentifier_MentalAbility_Target_Link = 50,
	EffectIdentifier_MentalAbility_Target_Run = 51,
	EffectIdentifier_MentalAbility_HypnotizeFollowLinkSource = 52,
	EffectIdentifier_MentalAbility_HypnotizeFollowLinkTarget = 53,
	EffectIdentifier_MentalAbility_HypnotizeDistact = 54,
	EffectIdentifier_MentalAbility_HypnotizeDistactLinkSource = 55,
	EffectIdentifier_MentalAbility_HypnotizeDistactLinkTarget = 56,
	EffectIdentifier_MentalAbility_HypnotizeForget = 57,
	EffectIdentifier_MentalAbility_HypnotizeForgetLinkSource = 58,
	EffectIdentifier_MentalAbility_HypnotizeForgetLinkTarget = 59,
	EffectIdentifier_MentalAbility_PK        = 60,
	EffectIdentifier_MentalAbility_Holobob   = 61,
	EffectIdentifier_MentalAbility_Holobob_End = 62,
	EffectIdentifier_MentalAbility_CortexScan = 63,
	EffectIdentifier_MentalAbility_BrainExtract = 64,
	EffectIdentifier_MentalAbility_BrainExtract_ButtonSmash = 65,
	EffectIdentifier_MentalAbility_BrainExtract_Infected = 66,
	EffectIdentifier_MentalAbility_Transmogrify = 67,
	EffectIdentifier_MentalAbility_HypnotizeFollow = 68,
	EffectIdentifier_MentalAbility_TransmogrifyLink = 69,
	EffectIdentifier_UFOAbility_Link         = 70,
	EffectIdentifier_UFOAbility_AbductoBeam  = 71,
	EffectIdentifier_UFOAbility_Drain        = 72,
	EffectIdentifier_UFOAbility_DrainVehicle = 73,
	EffectIdentifier_Disintegration_IonDetonator_Slot1 = 74,
	EffectIdentifier_Disintegration_IonDetonator_Slot2 = 75,
	EffectIdentifier_Disintegration_Disintegrator_Slot1 = 76,
	EffectIdentifier_Disintegration_Disintegrator_Slot2 = 77,
	EffectIdentifier_Zapomatic_Beam          = 78,
	EffectIdentifier_Projectile_Impact       = 79,
	EffectIdentifier_Projectile_ImpactMissed = 80,
	EffectIdentifier_Projectile_DamagingOverTime = 81,
	EffectIdentifier_TestSlot1               = 82,
	EffectIdentifier_TestSlot2               = 83,
	EffectIdentifier_TestSlot3               = 84,
	EffectIdentifier_TestSlot4               = 85,
	EffectIdentifier_TestSlot5               = 86,
	EffectIdentifier_TestSlot6               = 87,
	EffectIdentifier_TestSlot7               = 88,
	EffectIdentifier_TestSlot8               = 89,
	EffectIdentifier_TestSlot9               = 90,
	EffectIdentifier_MAX                     = 91,
};

// Enum BFGCore.EBFGCompletionRatingOperation
// NumValues: 0x0006
enum class EBFGCompletionRatingOperation : uint8
{
	None                                     = 0,
	UpdateRating                             = 1,
	ResetRating                              = 2,
	UpdateBestRating                         = 3,
	GiveRewards                              = 4,
	EBFGCompletionRatingOperation_MAX        = 5,
};

// Enum BFGCore.EBFGEventAction_MenuFactory_Action
// NumValues: 0x0003
enum class EBFGEventAction_MenuFactory_Action : uint8
{
	None                                     = 0,
	OpenMenu                                 = 1,
	EBFGEventAction_MenuFactory_MAX          = 2,
};

// Enum BFGCore.EUBFGEventAction_StreamingFunction
// NumValues: 0x0006
enum class EUBFGEventAction_StreamingFunction : uint8
{
	None                                     = 0,
	Streaming_Suspend                        = 1,
	Streaming_Resume                         = 2,
	Streaming_GameFlowState_Add              = 3,
	Streaming_GameFlowState_Remove           = 4,
	EUBFGEventAction_MAX                     = 5,
};

// Enum BFGCore.EBFGEventTest_Operation_Operator
// NumValues: 0x0004
enum class EBFGEventTest_Operation_Operator : uint8
{
	None                                     = 0,
	And                                      = 1,
	Or                                       = 2,
	EBFGEventTest_Operation_MAX              = 3,
};

// Enum BFGCore.EBFGEventTest_VariableValue_Operator
// NumValues: 0x0003
enum class EBFGEventTest_VariableValue_Operator : uint8
{
	In                                       = 0,
	NotIn                                    = 1,
	EBFGEventTest_VariableValue_MAX          = 2,
};

// Enum BFGCore.EBFGFadeSystem_ThrobberState
// NumValues: 0x0005
enum class EBFGFadeSystem_ThrobberState : uint8
{
	Hidden                                   = 0,
	FadeIn                                   = 1,
	FullyOpaque                              = 2,
	FadeOut                                  = 3,
	EBFGFadeSystem_MAX                       = 4,
};

// Enum BFGCore.EBFGGameFlowState_Cutscene
// NumValues: 0x0008
enum class EBFGGameFlowState_Cutscene : uint8
{
	None                                     = 0,
	FadeToBlack_BeforePlay                   = 1,
	FadeToBlack_DuringPlay                   = 2,
	StartPlayback                            = 3,
	Playing                                  = 4,
	StopPlayback                             = 5,
	SuspendPaused                            = 6,
	EBFGGameFlowState_MAX                    = 7,
};

// Enum BFGCore.EBFGGameFlowState_DebugStartMenu_Actions
// NumValues: 0x0007
enum class EBFGGameFlowState_DebugStartMenu_Actions : uint8
{
	None                                     = 0,
	Select_RequestStartAt                    = 1,
	Select_StartNewGame                      = 2,
	Select_MainMenu                          = 3,
	Select_Mothership                        = 4,
	Select_GateMap                           = 5,
	EBFGGameFlowState_DebugStartMenu_MAX     = 6,
};

// Enum BFGCore.EBFGGameFlowState_EndScreen
// NumValues: 0x0004
enum class EBFGGameFlowState_EndScreen : uint8
{
	None                                     = 0,
	FadeToBlack                              = 1,
	FadeIn                                   = 2,
	EBFGGameFlowState_MAX                    = 3,
};

// Enum BFGCore.EBFGGameFlowState_EndScreen_Actions
// NumValues: 0x0007
enum class EBFGGameFlowState_EndScreen_Actions : uint8
{
	None                                     = 0,
	Select_RequestStartAt                    = 1,
	Select_StartNewGame                      = 2,
	Select_MainMenu                          = 3,
	Select_Mothership                        = 4,
	Select_MainMenu_PublicDemo               = 5,
	EBFGGameFlowState_EndScreen_MAX          = 6,
};

// Enum BFGCore.EBFGGameplayEndSequence_StartGameplayAction
// NumValues: 0x0006
enum class EBFGGameplayEndSequence_StartGameplayAction : uint8
{
	None                                     = 0,
	RespawnAtCheckpoint                      = 1,
	GoToMothership                           = 2,
	ReplayQuest                              = 3,
	CancelChallenge                          = 4,
	EBFGGameplayEndSequence_MAX              = 5,
};

// Enum BFGCore.EBFGGameplayEndSequence_State
// NumValues: 0x000E
enum class EBFGGameplayEndSequence_State : uint8
{
	None                                     = 0,
	AbortMission                             = 1,
	StartEndEffects                          = 2,
	WaitEndEffects                           = 3,
	LoadNarrativeSequence                    = 4,
	WaitNarrativeSequence                    = 5,
	LoadBackground                           = 6,
	LoadMissionResults                       = 7,
	WaitMissionResults                       = 8,
	LoadNewspaper                            = 9,
	WaitNewspaper                            = 10,
	DoStartGameplayAction                    = 11,
	RequestRemoval                           = 12,
	EBFGGameplayEndSequence_MAX              = 13,
};

// Enum BFGCore.EBFGGamestartSequenceStep
// NumValues: 0x0006
enum class EBFGGamestartSequenceStep : uint8
{
	Init                                     = 0,
	IIS                                      = 1,
	IISClosed                                = 2,
	WaitForLoadProfile                       = 3,
	MainMenu                                 = 4,
	EBFGGamestartSequenceStep_MAX            = 5,
};

// Enum BFGCore.EBFGGameFlowState_IngameMainMenu_Actions
// NumValues: 0x000A
enum class EBFGGameFlowState_IngameMainMenu_Actions : uint8
{
	None                                     = 0,
	Select_Continue                          = 1,
	Select_RestartMission                    = 2,
	Select_FuronHandbook                     = 3,
	Select_ShowOptions                       = 4,
	Select_ReturnToMotherShip                = 5,
	Select_ReturnToMainMenu                  = 6,
	Select_ShowDebugMenu                     = 7,
	Select_CancelChallenge                   = 8,
	EBFGGameFlowState_IngameMainMenu_MAX     = 9,
};

// Enum BFGCore.EBFGGameFlowState_LoadingScreenBase
// NumValues: 0x000C
enum class EBFGGameFlowState_LoadingScreenBase : uint8
{
	None                                     = 0,
	WaitingFade                              = 1,
	FadeToBlack                              = 2,
	RequestLoad                              = 3,
	WaitingLoad                              = 4,
	FadeMoviePlayerToBlack                   = 5,
	PostLoad                                 = 6,
	BeforeFadeFromBlack                      = 7,
	FadeFromBlack                            = 8,
	RequestExit                              = 9,
	Custom                                   = 10,
	EBFGGameFlowState_MAX                    = 11,
};

// Enum BFGCore.EBFGGameFlowState_MainMenu_Action
// NumValues: 0x000D
enum class EBFGGameFlowState_MainMenu_Action : uint8
{
	None                                     = 0,
	Selected_ContinueSaveGame                = 1,
	Selected_LoadGame                        = 2,
	Selected_NewGame                         = 3,
	Selected_LoadGateMap                     = 4,
	Selected_DebugStartMenu                  = 5,
	Selected_Options                         = 6,
	Selected_Credits                         = 7,
	Selected_Quit                            = 8,
	NewGame_CreateEmptyOnSlot                = 9,
	NewGame_StartMap                         = 10,
	Quiting                                  = 11,
	EBFGGameFlowState_MainMenu_MAX           = 12,
};

// Enum BFGCore.EBFGGameFlowState_MainMenu_SaveSlotModes
// NumValues: 0x0003
enum class EBFGGameFlowState_MainMenu_SaveSlotModes : uint8
{
	NewGame                                  = 0,
	LoadGame                                 = 1,
	EBFGGameFlowState_MainMenu_MAX           = 2,
};

// Enum BFGCore.EBFGMenuGameOptions
// NumValues: 0x002A
enum class EBFGMenuGameOptions : uint8
{
	OPTION_TITLE_CONTROLLER                  = 0,
	OPTION_NAME_CAMERA_SENSITIVITY_CONTROLLER = 1,
	OPTION_NAME_CAMERA_Y_AXIS_CONTROLLER     = 2,
	OPTION_NAME_SAUCER_SENSITIVITY_CONTROLLER = 3,
	OPTION_NAME_LOCK_ON_TARGETS              = 4,
	OPTION_NAME_LOCK_ON_SWITCH               = 5,
	OPTION_TITLE_MOUSE                       = 6,
	OPTION_NAME_CAMERA_SENSITIVITY_MOUSE     = 7,
	OPTION_NAME_SAUCER_SENSITIVITY_MOUSE     = 8,
	OPTION_NAME_CAMERA_Y_AXIS_MOUSE          = 9,
	OPTION_NAME_VOLUME_MASTER                = 10,
	OPTION_NAME_VOLUME_MUSIC                 = 11,
	OPTION_NAME_VOLUME_SFX                   = 12,
	OPTION_NAME_VOLUME_VOICES                = 13,
	OPTION_NAME_VOLUME_UI                    = 14,
	OPTION_NAME_SUBTITLES                    = 15,
	OPTION_NAME_MUTE_GAME_IN_BACKGROUND      = 16,
	OPTION_NAME_LANGUAGE                     = 17,
	OPTION_NAME_SPEAKERS                     = 18,
	OPTION_NAME_GAMMA                        = 19,
	OPTION_NAME_RESOLUTION                   = 20,
	OPTION_NAME_FULLSCREEN_MODE              = 21,
	OPTION_NAME_DEVICE                       = 22,
	OPTION_NAME_PRIMARY_MONITOR              = 23,
	OPTION_NAME_VSYNC                        = 24,
	OPTION_NAME_VIEWDISTANCE                 = 25,
	OPTION_NAME_AA                           = 26,
	OPTION_NAME_POSTPROCESSING               = 27,
	OPTION_NAME_SHADOWS                      = 28,
	OPTION_NAME_TEXTURES                     = 29,
	OPTION_NAME_VFX                          = 30,
	OPTION_NAME_FOLIAGE                      = 31,
	OPTION_NAME_MATERIAL                     = 32,
	OPTION_NAME_LANDSCAPE_PC                 = 33,
	OPTION_NAME_LANDSCAPE_DURANGO            = 34,
	OPTION_NAME_LANDSCAPE_ORBIS              = 35,
	OPTION_TITLE_GENERAL                     = 36,
	OPTION_NAME_VIBRATION_CONTROLLER         = 37,
	OPTION_NAME_ENABLE_TUTORIALS             = 38,
	OPTION_NAME_FPS_LIMIT                    = 39,
	OPTION_NAME_GRAPHICS_QUALITY             = 40,
	OPTION_MAX                               = 41,
};

// Enum BFGCore.EBFGMenuGameOptionCategory
// NumValues: 0x0006
enum class EBFGMenuGameOptionCategory : uint8
{
	OPTION_CATEGORY_GAMEPLAY                 = 0,
	OPTION_CATEGORY_KEYBINDING               = 1,
	OPTION_CATEGORY_CONTROLLER               = 2,
	OPTION_CATEGORY_AUDIO                    = 3,
	OPTION_CATEGORY_VIDEO                    = 4,
	OPTION_CATEGORY_MAX                      = 5,
};

// Enum BFGCore.EBFGMenuGameOptionType
// NumValues: 0x0006
enum class EBFGMenuGameOptionType : uint8
{
	Title                                    = 0,
	Int                                      = 1,
	Float                                    = 2,
	Resolution                               = 3,
	Language                                 = 4,
	EBFGMenuGameOptionType_MAX               = 5,
};

// Enum BFGCore.EBFGMenuGameOptionsState
// NumValues: 0x0005
enum class EBFGMenuGameOptionsState : uint8
{
	Init                                     = 0,
	SelectCategory                           = 1,
	BrowseOptions                            = 2,
	Exit                                     = 3,
	EBFGMenuGameOptionsState_MAX             = 4,
};

// Enum BFGCore.EBFGGameplayEndReason
// NumValues: 0x0007
enum class EBFGGameplayEndReason : uint8
{
	None                                     = 0,
	Death_OnFoot                             = 1,
	Death_InSaucer                           = 2,
	Death_Water                              = 3,
	Quest                                    = 4,
	BoundariesLeft                           = 5,
	EBFGGameplayEndReason_MAX                = 6,
};

// Enum BFGCore.EBFGMothershipCutscene
// NumValues: 0x0005
enum class EBFGMothershipCutscene : uint8
{
	None                                     = 0,
	MM01Backstory                            = 1,
	MM22Outro                                = 2,
	DEMOTrailer                              = 3,
	EBFGMothershipCutscene_MAX               = 4,
};

// Enum BFGCore.EBFGMothershipSubstate
// NumValues: 0x0007
enum class EBFGMothershipSubstate : uint8
{
	UNDEFINED                                = 0,
	DECK                                     = 1,
	MISSION_SELECTION                        = 2,
	POX_LAB                                  = 3,
	ARCHIVES                                 = 4,
	INVASION_REPORT                          = 5,
	EBFGMothershipSubstate_MAX               = 6,
};

// Enum BFGCore.EBFGMothershipCutsceneState
// NumValues: 0x0006
enum class EBFGMothershipCutsceneState : uint8
{
	Init                                     = 0,
	CheckingCutscene                         = 1,
	PlayingCutscene                          = 2,
	FadeInMenu                               = 3,
	End                                      = 4,
	EBFGMothershipCutsceneState_MAX          = 5,
};

// Enum BFGCore.EBFGMothershipSubLevels
// NumValues: 0x0008
enum class EBFGMothershipSubLevels : uint8
{
	MotherShip_Root                          = 0,
	PoxLab_Crypto                            = 1,
	PoxLab_Saucer                            = 2,
	HoloPoxDeck                              = 3,
	SkinSelection                            = 4,
	Furonigami                               = 5,
	FuronHandBook                            = 6,
	EBFGMothershipSubLevels_MAX              = 7,
};

// Enum BFGCore.EBFGMothershipTransitionState
// NumValues: 0x0004
enum class EBFGMothershipTransitionState : uint8
{
	Initial                                  = 0,
	Transitional                             = 1,
	Final                                    = 2,
	EBFGMothershipTransitionState_MAX        = 3,
};

// Enum BFGCore.EBFGGameFlowState_Mothership_MainMenu_Action
// NumValues: 0x0003
enum class EBFGGameFlowState_Mothership_MainMenu_Action : uint8
{
	None                                     = 0,
	Open_DebugStartMenu                      = 1,
	EBFGGameFlowState_Mothership_MainMenu_MAX = 2,
};

// Enum BFGCore.EBFGGameFlowState_Mothership_MissionSelection_Actions
// NumValues: 0x0004
enum class EBFGGameFlowState_Mothership_MissionSelection_Actions : uint8
{
	None                                     = 0,
	Back                                     = 1,
	Invade                                   = 2,
	EBFGGameFlowState_Mothership_MissionSelection_MAX = 3,
};

// Enum BFGCore.EBFGGameMode_PlayerType
// NumValues: 0x0004
enum class EBFGGameMode_PlayerType : uint8
{
	Default                                  = 0,
	Crypto                                   = 1,
	UFO                                      = 2,
	EBFGGameMode_MAX                         = 3,
};

// Enum BFGCore.EBFGGameMode_Startup
// NumValues: 0x0003
enum class EBFGGameMode_Startup : uint8
{
	GameMode_StartPIESpawn                   = 0,
	GameMode_StartNormalSpawn                = 1,
	GameMode_MAX                             = 2,
};

// Enum BFGCore.EBFGGameplayEndEffects_State
// NumValues: 0x0007
enum class EBFGGameplayEndEffects_State : uint8
{
	None                                     = 0,
	WaitForData                              = 1,
	WaitForVOPlaybackEnd                     = 2,
	WaitForFadeEffectRequest                 = 3,
	WaitForFadeEffectsEnd                    = 4,
	Done                                     = 5,
	EBFGGameplayEndEffects_MAX               = 6,
};

// Enum BFGCore.EBFGGameSession_QuestDirective
// NumValues: 0x0006
enum class EBFGGameSession_QuestDirective : uint8
{
	None                                     = 0,
	StartIntroduction                        = 1,
	AllowQuestStart                          = 2,
	ReplayQuest                              = 3,
	OpenWorld                                = 4,
	EBFGGameSession_MAX                      = 5,
};

// Enum BFGCore.EBFGUFODisplayMode
// NumValues: 0x0006
enum class EBFGUFODisplayMode : uint8
{
	None                                     = 0,
	CanLand                                  = 1,
	Call_UFO                                 = 2,
	Enter_UFO                                = 3,
	Take_Off                                 = 4,
	EBFGUFODisplayMode_MAX                   = 5,
};

// Enum BFGCore.EBFGInputLockGroups
// NumValues: 0x0007
enum class EBFGInputLockGroups : uint8
{
	MOVEMENT                                 = 0,
	WEAPONS                                  = 1,
	ABILITIES                                = 2,
	CAMERA                                   = 3,
	OTHER                                    = 4,
	LAST                                     = 5,
	EBFGInputLockGroups_MAX                  = 6,
};

// Enum BFGCore.EInputSchemeIdentifier
// NumValues: 0x0005
enum class EInputSchemeIdentifier : uint8
{
	SCHEME_CRYPTO                            = 0,
	SCHEME_UFO                               = 1,
	SCHEME_HOLOBOB                           = 2,
	SCHEME_UI                                = 3,
	SCHEME_MAX                               = 4,
};

// Enum BFGCore.EBFGInputRebindGroup
// NumValues: 0x0006
enum class EBFGInputRebindGroup : uint8
{
	NONE                                     = 0,
	DEFAULT                                  = 1,
	CRYPTO                                   = 2,
	UFO                                      = 3,
	MENU                                     = 4,
	EBFGInputRebindGroup_MAX                 = 5,
};

// Enum BFGCore.EBFGInputRebindIdentifier
// NumValues: 0x001F
enum class EBFGInputRebindIdentifier : uint8
{
	NONE                                     = 0,
	MOVE_FORWARD                             = 1,
	MOVE_BACK                                = 2,
	MOVE_RIGHT                               = 3,
	MOVE_LEFT                                = 4,
	FIRE_WEAPON                              = 5,
	EXTRACT_INTERACT                         = 6,
	JUMP_JETPACK                             = 7,
	DASH_SKATE                               = 8,
	PSYCHOKINESIS                            = 9,
	CORTEX_SCAN                              = 10,
	HOLOBOB                                  = 11,
	CANCEL_HOLOBOB                           = 12,
	CANCEL_ABILITIES                         = 13,
	HYPNO_FOLLOW                             = 14,
	HYPNO_FORGET                             = 15,
	HYPNO_DISTRACT                           = 16,
	EQUIP_ZAPOMATIC                          = 17,
	EQUIP_DISINTEGRATOR_RAY                  = 18,
	EQUIP_ANAL_PROBE                         = 19,
	EQUIP_ION_DETONATOR                      = 20,
	ABDUCTO_BEAM                             = 21,
	DRAIN                                    = 22,
	EQUIP_DEATH_RAY                          = 23,
	EQUIP_SONIC_BOOM                         = 24,
	EQUIP_QUANTUM_DECONSTRUCTOR              = 25,
	ELECTRONIC_COUNTER_MESURE                = 26,
	BIRDS_EYE_VIEW                           = 27,
	UI_TAB_LEFT                              = 28,
	UI_TAB_RIGHT                             = 29,
	EBFGInputRebindIdentifier_MAX            = 30,
};

// Enum BFGCore.EBFGInputPatternElementState
// NumValues: 0x0004
enum class EBFGInputPatternElementState : uint8
{
	DOWN                                     = 0,
	UP                                       = 1,
	DOWN_AND_UP                              = 2,
	EBFGInputPatternElementState_MAX         = 3,
};

// Enum BFGCore.EBFGCheckInputActionResult
// NumValues: 0x0005
enum class EBFGCheckInputActionResult : uint8
{
	FAILED                                   = 0,
	AWAITING_MIN_TIME                        = 1,
	PASSED_MAX_TIME                          = 2,
	SUCCESS                                  = 3,
	EBFGCheckInputActionResult_MAX           = 4,
};

// Enum BFGCore.EBFGLoadingScreenInfoType
// NumValues: 0x0005
enum class EBFGLoadingScreenInfoType : uint8
{
	None                                     = 0,
	Map                                      = 1,
	Mission                                  = 2,
	Challenge                                = 3,
	EBFGLoadingScreenInfoType_MAX            = 4,
};

// Enum BFGCore.EBFGAlertLevel
// NumValues: 0x0006
enum class EBFGAlertLevel : uint8
{
	None                                     = 0,
	Civilian                                 = 1,
	Police                                   = 2,
	Military                                 = 3,
	Majestic                                 = 4,
	EBFGAlertLevel_MAX                       = 5,
};

// Enum BFGCore.EBFGMissionConsequence_AlertOperation
// NumValues: 0x0005
enum class EBFGMissionConsequence_AlertOperation : uint8
{
	None                                     = 0,
	Increase                                 = 1,
	Decrease                                 = 2,
	Set                                      = 3,
	EBFGMissionConsequence_MAX               = 4,
};

// Enum BFGCore.eTriggerState
// NumValues: 0x0004
enum class ETriggerState : uint8
{
	EINSIDEINNERBOUNDS                       = 0,
	EINSIDEOUTERBOUNDS                       = 1,
	EOUTOFBOUNDS                             = 2,
	ETriggerState_MAX                        = 3,
};

// Enum BFGCore.EBFGCrowdflowOverride
// NumValues: 0x0009
enum class EBFGCrowdflowOverride : uint8
{
	AllVehicles                              = 0,
	EnemyVehicles                            = 1,
	CivilianVehicles                         = 2,
	AllNPCs                                  = 3,
	EnemyNPC                                 = 4,
	CivilianNPC                              = 5,
	ProvidedTagOnly                          = 6,
	ResetOverride                            = 7,
	EBFGCrowdflowOverride_MAX                = 8,
};

// Enum BFGCore.EBFGMissionGroupType
// NumValues: 0x0005
enum class EBFGMissionGroupType : uint8
{
	None                                     = 0,
	MainGroup                                = 1,
	ChallengeGroup                           = 2,
	SystemicGroup                            = 3,
	EBFGMissionGroupType_MAX                 = 4,
};

// Enum BFGCore.EBFGMissionLayout_WorldType
// NumValues: 0x0008
enum class EBFGMissionLayout_WorldType : uint8
{
	BumperVideo                              = 0,
	GameMap                                  = 1,
	Menu_Main                                = 2,
	Menu_Main_PublicDemo                     = 3,
	Menu_Mothership                          = 4,
	Debug_GateMap                            = 5,
	Invalid                                  = 6,
	EBFGMissionLayout_MAX                    = 7,
};

// Enum BFGCore.EBFGMissionOrbitalTransporterTargetState
// NumValues: 0x0005
enum class EBFGMissionOrbitalTransporterTargetState : uint8
{
	INITIAL_SLOW_DOWN                        = 0,
	HANG                                     = 1,
	ABDUCT                                   = 2,
	DONE                                     = 3,
	EBFGMissionOrbitalTransporterTargetState_MAX = 4,
};

// Enum BFGCore.EBFGTriggerShape
// NumValues: 0x0004
enum class EBFGTriggerShape : uint8
{
	MISSIONTRIGGER_BOX                       = 0,
	MISSIONTRIGGER_SPHERE                    = 1,
	MISSIONTRIGGER_CAPSULE                   = 2,
	MISSIONTRIGGER_MAX                       = 3,
};

// Enum BFGCore.EBFGNarrativeSequenceNode_FadeState
// NumValues: 0x0008
enum class EBFGNarrativeSequenceNode_FadeState : uint8
{
	None                                     = 0,
	StartFade                                = 1,
	WaitFade                                 = 2,
	StartStreaming                           = 3,
	WaitStreaming                            = 4,
	WaitEndEffects                           = 5,
	Done                                     = 6,
	EBFGNarrativeSequenceNode_MAX            = 7,
};

// Enum BFGCore.EBFGNarrativeSequenceNode_PlayCutsceneState
// NumValues: 0x0007
enum class EBFGNarrativeSequenceNode_PlayCutsceneState : uint8
{
	None                                     = 0,
	LoadData                                 = 1,
	WaitData                                 = 2,
	StartPlayback                            = 3,
	WaitPlayback                             = 4,
	Done                                     = 5,
	EBFGNarrativeSequenceNode_MAX            = 6,
};

// Enum BFGCore.EBFGNetworkPathEventReportType
// NumValues: 0x0003
enum class EBFGNetworkPathEventReportType : uint8
{
	Obstacle_NonBlocking                     = 0,
	Obstacle_Blocking                        = 1,
	Obstacle_MAX                             = 2,
};

// Enum BFGCore.EBFGNetworkPath_RelativeDistanceCalculatorType
// NumValues: 0x0005
enum class EBFGNetworkPath_RelativeDistanceCalculatorType : uint8
{
	None                                     = 0,
	Transition                               = 1,
	StartSegment                             = 2,
	EndSegment                               = 3,
	EBFGNetworkPath_MAX                      = 4,
};

// Enum BFGCore.EBFGNetworkPath_SearchPathMoveType
// NumValues: 0x0005
enum class EBFGNetworkPath_SearchPathMoveType : uint8
{
	Along_Path                               = 0,
	Extremity_To_Extremity                   = 1,
	Direct_Navigation                        = 2,
	MoveToDistanceOnSpline                   = 3,
	EBFGNetworkPath_MAX                      = 4,
};

// Enum BFGCore.EBFGAICrowdLifeLeaveResponse
// NumValues: 0x0005
enum class EBFGAICrowdLifeLeaveResponse : uint8
{
	InProgress_Panic                         = 0,
	InProgress_Normal                        = 1,
	Completed                                = 2,
	Aborted                                  = 3,
	EBFGAICrowdLifeLeaveResponse_MAX         = 4,
};

// Enum BFGCore.EBFGAICrowdLifeState
// NumValues: 0x0006
enum class EBFGAICrowdLifeState : uint8
{
	None                                     = 0,
	Joining                                  = 1,
	AtStation                                = 2,
	WaitWeaponEquip                          = 3,
	Leaving                                  = 4,
	EBFGAICrowdLifeState_MAX                 = 5,
};

// Enum BFGCore.EBFGAgentAIPassengerEnterPhase
// NumValues: 0x0006
enum class EBFGAgentAIPassengerEnterPhase : uint8
{
	None                                     = 0,
	MovingToVehicle                          = 1,
	Positioning                              = 2,
	Entering                                 = 3,
	Inside                                   = 4,
	EBFGAgentAIPassengerEnterPhase_MAX       = 5,
};

// Enum BFGCore.EBFGAgentAIPassengerExitPhase
// NumValues: 0x0008
enum class EBFGAgentAIPassengerExitPhase : uint8
{
	None                                     = 0,
	WaitingBeforeExit                        = 1,
	MovingToExit                             = 2,
	Exiting                                  = 3,
	MayhemExit                               = 4,
	MoveOut                                  = 5,
	Out                                      = 6,
	EBFGAgentAIPassengerExitPhase_MAX        = 7,
};

// Enum BFGCore.EBFGAIPatrolState
// NumValues: 0x0006
enum class EBFGAIPatrolState : uint8
{
	None                                     = 0,
	Joining                                  = 1,
	Moving                                   = 2,
	GoingToInterestPoint                     = 3,
	AtInterestPoint                          = 4,
	EBFGAIPatrolState_MAX                    = 5,
};

// Enum BFGCore.EBFGAIPlayInteractAtLocationState
// NumValues: 0x0006
enum class EBFGAIPlayInteractAtLocationState : uint8
{
	None                                     = 0,
	GoingToLocation                          = 1,
	Positionning                             = 2,
	PlayingInteract                          = 3,
	Done                                     = 4,
	EBFGAIPlayInteractAtLocationState_MAX    = 5,
};

// Enum BFGCore.EBFGAIVehicleReleasePassengersPhase
// NumValues: 0x0005
enum class EBFGAIVehicleReleasePassengersPhase : uint8
{
	None                                     = 0,
	Stopping                                 = 1,
	Releasing                                = 2,
	Finished                                 = 3,
	EBFGAIVehicleReleasePassengersPhase_MAX  = 4,
};

// Enum BFGCore.EBFGAIStateStandBy_Phase
// NumValues: 0x0005
enum class EBFGAIStateStandBy_Phase : uint8
{
	ASB_None                                 = 0,
	ASB_GoingToLocation                      = 1,
	ASB_Stopping                             = 2,
	ASB_Waiting                              = 3,
	ASB_MAX                                  = 4,
};

// Enum BFGCore.EBFGAIVehicleTakePassengersPhase
// NumValues: 0x0004
enum class EBFGAIVehicleTakePassengersPhase : uint8
{
	None                                     = 0,
	WaitingAllIn                             = 1,
	Finished                                 = 2,
	EBFGAIVehicleTakePassengersPhase_MAX     = 3,
};

// Enum BFGCore.EBFGAIVehicleVehicleChaseTargetPhase
// NumValues: 0x0009
enum class EBFGAIVehicleVehicleChaseTargetPhase : uint8
{
	None                                     = 0,
	Chasing                                  = 1,
	WaitingStop                              = 2,
	Releasing                                = 3,
	ReleaseCoolDown                          = 4,
	WaitPassengers                           = 5,
	WaitForRelocate                          = 6,
	Finished                                 = 7,
	EBFGAIVehicleVehicleChaseTargetPhase_MAX = 8,
};

// Enum BFGCore.EBFGAIVehicleVehicleChaseTargetPathDecision
// NumValues: 0x0006
enum class EBFGAIVehicleVehicleChaseTargetPathDecision : uint8
{
	None                                     = 0,
	FollowingScriptedPath                    = 1,
	StickOnPreviousPath                      = 2,
	SwitchToNewComputedPath                  = 3,
	NoPathAvailable                          = 4,
	EBFGAIVehicleVehicleChaseTargetPathDecision_MAX = 5,
};

// Enum BFGCore.EBFGAIVehicleVehicleFleePhase
// NumValues: 0x0008
enum class EBFGAIVehicleVehicleFleePhase : uint8
{
	None                                     = 0,
	Fleeing                                  = 1,
	WaitingStop                              = 2,
	Releasing                                = 3,
	ReleaseCoolDown                          = 4,
	WaitPassengers                           = 5,
	Finished                                 = 6,
	EBFGAIVehicleVehicleFleePhase_MAX        = 7,
};

// Enum BFGCore.EBFGAIVehicleVehicleGotoLocation
// NumValues: 0x0007
enum class EBFGAIVehicleVehicleGotoLocation : uint8
{
	None                                     = 0,
	MovingToLocation                         = 1,
	ReleasingPassengers                      = 2,
	WaitingPassengers                        = 3,
	Standby                                  = 4,
	Finished                                 = 5,
	EBFGAIVehicleVehicleGotoLocation_MAX     = 6,
};

// Enum BFGCore.EBFGAIVehicleWaitPassengersPhase
// NumValues: 0x0004
enum class EBFGAIVehicleWaitPassengersPhase : uint8
{
	None                                     = 0,
	Waiting                                  = 1,
	Finished                                 = 2,
	EBFGAIVehicleWaitPassengersPhase_MAX     = 3,
};

// Enum BFGCore.EBFGNetworkPathAgent_AIControllerState
// NumValues: 0x0006
enum class EBFGNetworkPathAgent_AIControllerState : uint8
{
	None                                     = 0,
	Normal                                   = 1,
	Hibernating                              = 2,
	Sleeping                                 = 3,
	SpecificInteraction                      = 4,
	EBFGNetworkPathAgent_MAX                 = 5,
};

// Enum BFGCore.EBFGNetworkPathAgent_HumanMode
// NumValues: 0x0006
enum class EBFGNetworkPathAgent_HumanMode : uint8
{
	None                                     = 0,
	Default                                  = 1,
	ExternallyControlled                     = 2,
	MovingToVehicle                          = 3,
	InVehicle                                = 4,
	EBFGNetworkPathAgent_MAX                 = 5,
};

// Enum BFGCore.EBFGAgentStopMode
// NumValues: 0x0003
enum class EBFGAgentStopMode : uint8
{
	OnSide                                   = 0,
	OnPath                                   = 1,
	EBFGAgentStopMode_MAX                    = 2,
};

// Enum BFGCore.EBFGNetworkAgentPathCenterMode
// NumValues: 0x0005
enum class EBFGNetworkAgentPathCenterMode : uint8
{
	Center                                   = 0,
	Right                                    = 1,
	Left                                     = 2,
	RequestedOffset                          = 3,
	EBFGNetworkAgentPathCenterMode_MAX       = 4,
};

// Enum BFGCore.EBFGDriverNPCState
// NumValues: 0x0006
enum class EBFGDriverNPCState : uint8
{
	Driving                                  = 0,
	GoingOut                                 = 1,
	Out                                      = 2,
	MovingToVehicle                          = 3,
	GoingIn                                  = 4,
	EBFGDriverNPCState_MAX                   = 5,
};

// Enum BFGCore.EBFGVehicleStop_PassengerRelease
// NumValues: 0x0007
enum class EBFGVehicleStop_PassengerRelease : uint8
{
	No_Release                               = 0,
	Driver                                   = 1,
	Front_Passenger                          = 2,
	Back_Passengers                          = 3,
	Transport                                = 4,
	All_Passengers                           = 5,
	EBFGVehicleStop_MAX                      = 6,
};

// Enum BFGCore.EBFGVehicleStopAggressivity
// NumValues: 0x0006
enum class EBFGVehicleStopAggressivity : uint8
{
	Default                                  = 0,
	Normal                                   = 1,
	Aggressive                               = 2,
	Urgent_Stop                              = 3,
	Urgent_Stop_With_Drifting                = 4,
	EBFGVehicleStopAggressivity_MAX          = 5,
};

// Enum BFGCore.EBFGVehicleStopState
// NumValues: 0x0006
enum class EBFGVehicleStopState : uint8
{
	None                                     = 0,
	NeedsLocation                            = 1,
	LocationDirty                            = 2,
	Stopping                                 = 3,
	Stopped                                  = 4,
	EBFGVehicleStopState_MAX                 = 5,
};

// Enum BFGCore.EBFGVehicleDrivingMode
// NumValues: 0x000B
enum class EBFGVehicleDrivingMode : uint8
{
	RandomPathSelection                      = 0,
	FollowPath                               = 1,
	Park                                     = 2,
	Fleeing                                  = 3,
	Chasing                                  = 4,
	ReleasingPassengers                      = 5,
	WaitingPassengers                        = 6,
	TakingPassengers                         = 7,
	ReadyToGo                                = 8,
	Parked                                   = 9,
	EBFGVehicleDrivingMode_MAX               = 10,
};

// Enum BFGCore.EBFGVehicleTurnLightMode
// NumValues: 0x0005
enum class EBFGVehicleTurnLightMode : uint8
{
	None                                     = 0,
	Left                                     = 1,
	Right                                    = 2,
	Warnings                                 = 3,
	EBFGVehicleTurnLightMode_MAX             = 4,
};

// Enum BFGCore.EBFGNetworkPathAgentPriorityLevel
// NumValues: 0x0006
enum class EBFGNetworkPathAgentPriorityLevel : uint8
{
	NoPriority                               = 0,
	DiscretEasePath                          = 1,
	EasePath                                 = 2,
	LetPass                                  = 3,
	BlockTraffic                             = 4,
	EBFGNetworkPathAgentPriorityLevel_MAX    = 5,
};

// Enum BFGCore.EBFGNetworkPathAgentEnterExitRule
// NumValues: 0x0005
enum class EBFGNetworkPathAgentEnterExitRule : uint8
{
	None                                     = 0,
	Blackboard                               = 1,
	Enter                                    = 2,
	Exit                                     = 3,
	EBFGNetworkPathAgentEnterExitRule_MAX    = 4,
};

// Enum BFGCore.EBFGNetworkPathAgentDespawnRequest
// NumValues: 0x0006
enum class EBFGNetworkPathAgentDespawnRequest : uint8
{
	None                                     = 0,
	Immediate                                = 1,
	Forgotten                                = 2,
	NextTick                                 = 3,
	ForceDespawnAfterDelay                   = 4,
	EBFGNetworkPathAgentDespawnRequest_MAX   = 5,
};

// Enum BFGCore.EBFGNetworkPathAgentMode
// NumValues: 0x0003
enum class EBFGNetworkPathAgentMode : uint8
{
	Simulated                                = 0,
	Navigation                               = 1,
	EBFGNetworkPathAgentMode_MAX             = 2,
};

// Enum BFGCore.EBFGNetworkPathExtremity
// NumValues: 0x0003
enum class EBFGNetworkPathExtremity : uint8
{
	Head                                     = 0,
	Tail                                     = 1,
	EBFGNetworkPathExtremity_MAX             = 2,
};

// Enum BFGCore.EBFGCrossWalkState
// NumValues: 0x0005
enum class EBFGCrossWalkState : uint8
{
	Closed                                   = 0,
	OpenRequested                            = 1,
	OpenPending                              = 2,
	Opened                                   = 3,
	EBFGCrossWalkState_MAX                   = 4,
};

// Enum BFGCore.EBFGIntersectionGranting
// NumValues: 0x0004
enum class EBFGIntersectionGranting : uint8
{
	None                                     = 0,
	Pending                                  = 1,
	Granted                                  = 2,
	EBFGIntersectionGranting_MAX             = 3,
};

// Enum BFGCore.EBFGNetworkPathAgentSpawnTransformOptions
// NumValues: 0x0004
enum class EBFGNetworkPathAgentSpawnTransformOptions : uint8
{
	SpawnOnNetworkAtRandomLocation           = 0,
	SpawnAtSpecifiedLocationOrientation      = 1,
	SpawnAroundPlayer                        = 2,
	EBFGNetworkPathAgentSpawnTransformOptions_MAX = 3,
};

// Enum BFGCore.EBFGBeamAttackPhase
// NumValues: 0x0005
enum class EBFGBeamAttackPhase : uint8
{
	None                                     = 0,
	BeamChargeUp                             = 1,
	BeamLoop                                 = 2,
	BeamEnd                                  = 3,
	EBFGBeamAttackPhase_MAX                  = 4,
};

// Enum BFGCore.EBFG360AttackPhase
// NumValues: 0x0005
enum class EBFG360AttackPhase : uint8
{
	None                                     = 0,
	Start                                    = 1,
	Loop                                     = 2,
	End                                      = 3,
	EBFG360AttackPhase_MAX                   = 4,
};

// Enum BFGCore.EBFGSilhouetteWeaponState
// NumValues: 0x0006
enum class EBFGSilhouetteWeaponState : uint8
{
	None                                     = 0,
	Atomizer                                 = 1,
	Nasal                                    = 2,
	Shockomator                              = 3,
	SpinAttack                               = 4,
	EBFGSilhouetteWeaponState_MAX            = 5,
};

// Enum BFGCore.EBFGShieldState
// NumValues: 0x0004
enum class EBFGShieldState : uint8
{
	Intact                                   = 0,
	Critical                                 = 1,
	Vulnerable                               = 2,
	EBFGShieldState_MAX                      = 3,
};

// Enum BFGCore.EBFGMetaPatternRoboprez
// NumValues: 0x0003
enum class EBFGMetaPatternRoboprez : uint8
{
	OutBeamRange                             = 0,
	NearSaucer                               = 2,
	EBFGMetaPatternRoboprez_MAX              = 3,
};

// Enum BFGCore.EBFGMetaPatternCategory
// NumValues: 0x0005
enum class EBFGMetaPatternCategory : uint8
{
	Step                                     = 0,
	TooFar                                   = 1,
	RearQuadrant                             = 2,
	TooClose                                 = 3,
	EBFGMetaPatternCategory_MAX              = 4,
};

// Enum BFGCore.EBFGAnimation_HumanNPCLowRes
// NumValues: 0x0034
enum class EBFGAnimation_HumanNPCLowRes : uint8
{
	None                                     = 0,
	Idle                                     = 1,
	Walk                                     = 2,
	Run                                      = 3,
	Sit                                      = 4,
	Drive                                    = 5,
	Sleep                                    = 6,
	Sit_On_Ground                            = 7,
	Sit_Start                                = 8,
	Sit_End                                  = 9,
	Sit_B                                    = 10,
	Sit_B_Start                              = 11,
	CarEnter                                 = 12,
	CarExit                                  = 13,
	CarExitPanic                             = 14,
	CarPassengerIdle                         = 15,
	CarEnter_Right                           = 16,
	CarExit_Right                            = 17,
	CarExitPanic_Right                       = 18,
	TransportExit01                          = 19,
	TransportExit02                          = 20,
	TransportExit03                          = 21,
	TruckEnter                               = 22,
	TruckEnterFast                           = 23,
	TruckDrive                               = 24,
	TruckExit                                = 25,
	TruckExitPanic                           = 26,
	Truck_AggressiveExit                     = 27,
	TruckPassengerIdle                       = 28,
	TruckEnter_Right                         = 29,
	TruckEnter_RightFast                     = 30,
	TruckExit_Right                          = 31,
	TruckExitPanic_Right                     = 32,
	Truck_AggressiveExit_Right               = 33,
	Car_PanicLoop_01                         = 34,
	Car_PanicLoop_02                         = 35,
	Car_PanicLoop_03                         = 36,
	Car_AggressiveExit                       = 37,
	Car_AggressiveExit_Right                 = 38,
	Truck_PanicLoop_01                       = 39,
	Truck_PanicLoop_02                       = 40,
	Truck_PanicLoop_03                       = 41,
	MilkTruckEnter                           = 42,
	MilkTruckEnterFast                       = 43,
	MilkTruckDrive                           = 44,
	MilkTruckExit                            = 45,
	MilkTruckExitPanic                       = 46,
	MilkTruck_AggressiveExit                 = 47,
	MilkTruck_PanicLoop_01                   = 48,
	MilkTruck_PanicLoop_02                   = 49,
	MilkTruck_PanicLoop_03                   = 50,
	EBFGAnimation_MAX                        = 51,
};

// Enum BFGCore.EBFGObjectRespawnType
// NumValues: 0x0005
enum class EBFGObjectRespawnType : uint8
{
	RESPAWNTYPE_VEHICLE                      = 0,
	RESPAWNTYPE_STATICMESH                   = 1,
	RESPAWNTYPE_STATICMESH_JUSTDELETE        = 2,
	RESPAWNTYPE_NONE                         = 3,
	RESPAWNTYPE_MAX                          = 4,
};

// Enum BFGCore.EBFGPatrolPathEnum
// NumValues: 0x0003
enum class EBFGPatrolPathEnum : uint8
{
	Enum1                                    = 0,
	Enum2                                    = 1,
	EBFGPatrolPathEnum_MAX                   = 2,
};

// Enum BFGCore.EBFGPatternRotationMode
// NumValues: 0x0004
enum class EBFGPatternRotationMode : uint8
{
	Once                                     = 0,
	Loop                                     = 1,
	PingPong                                 = 2,
	EBFGPatternRotationMode_MAX              = 3,
};

// Enum BFGCore.EPatternTargetingMode
// NumValues: 0x0003
enum class EPatternTargetingMode : uint8
{
	Player                                   = 0,
	Quadrant                                 = 1,
	EPatternTargetingMode_MAX                = 2,
};

// Enum BFGCore.EBFGPauseType
// NumValues: 0x0002
enum class EBFGPauseType : uint8
{
	EVERYTHING                               = 0,
	EBFGPauseType_MAX                        = 1,
};

// Enum BFGCore.EBFGPlayerControllerMode
// NumValues: 0x0005
enum class EBFGPlayerControllerMode : uint8
{
	None                                     = 0,
	Unknown                                  = 1,
	Character                                = 2,
	UFO                                      = 3,
	EBFGPlayerControllerMode_MAX             = 4,
};

// Enum BFGCore.EBFGUFO_InteractState
// NumValues: 0x0008
enum class EBFGUFO_InteractState : uint8
{
	None                                     = 0,
	GroundMode                               = 1,
	GroundMode_CanCall_UFO                   = 2,
	GroundMode_CanEnter_UFO                  = 3,
	UFOMode_CanTake_Off_Or_Exit              = 4,
	UFOMode_Flying                           = 5,
	UFOMode_CanLand                          = 6,
	EBFGUFO_MAX                              = 7,
};

// Enum BFGCore.ItemMissionTypeEnum
// NumValues: 0x000B
enum class EItemMissionTypeEnum : uint8
{
	MissionBriefcase                         = 0,
	MissionDataTape                          = 1,
	MissionFuronFilm                         = 2,
	MissionFuronTechnology                   = 3,
	MissionDisintegratorRay                  = 4,
	MissionPowerCell                         = 5,
	MissionJetPack                           = 6,
	MissionWeaponPart                        = 7,
	MissionBrain                             = 8,
	MissionSaucerPowerCell                   = 9,
	ItemMissionTypeEnum_MAX                  = 10,
};

// Enum BFGCore.EBFGPerformancePools
// NumValues: 0x0008
enum class EBFGPerformancePools : uint8
{
	PERFPOOL_DEFAULT                         = 0,
	PERFPOOL_GAME_SYSTEM                     = 1,
	PERFPOOL_CROWDMANAGER                    = 2,
	PERFPOOL_ALERTSYSTEM                     = 3,
	PERFPOOL_PLAYER                          = 4,
	PERFPOOL_PK_OBJECTS                      = 5,
	PERFPOOL_LD_ACTORS                       = 6,
	PERFPOOL_MAX                             = 7,
};

// Enum BFGCore.EBFGAnalProbeProjectileHitType
// NumValues: 0x0005
enum class EBFGAnalProbeProjectileHitType : uint8
{
	Missed                                   = 0,
	Partial                                  = 1,
	Full                                     = 2,
	Bounce                                   = 3,
	EBFGAnalProbeProjectileHitType_MAX       = 4,
};

// Enum BFGCore.EBFGAnalProbeProjectileState
// NumValues: 0x0005
enum class EBFGAnalProbeProjectileState : uint8
{
	AP_TravelTo                              = 0,
	AP_Probing                               = 1,
	AP_TravelBack                            = 2,
	AP_Done                                  = 3,
	AP_MAX                                   = 4,
};

// Enum BFGCore.EBFGActorProxyState
// NumValues: 0x0003
enum class EBFGActorProxyState : uint8
{
	Default                                  = 0,
	Destroyed                                = 1,
	EBFGActorProxyState_MAX                  = 2,
};

// Enum BFGCore.EBFGQuest_ElementDefend_Type
// NumValues: 0x0003
enum class EBFGQuest_ElementDefend_Type : uint8
{
	Timed                                    = 0,
	Waves                                    = 1,
	EBFGQuest_ElementDefend_MAX              = 2,
};

// Enum BFGCore.EBFGElementFadeType
// NumValues: 0x0004
enum class EBFGElementFadeType : uint8
{
	FADE_IN                                  = 0,
	FADE_OUT                                 = 1,
	NONE                                     = 2,
	EBFGElementFadeType_MAX                  = 3,
};

// Enum BFGCore.EBFGQuest_ElementLocateHint_Mode
// NumValues: 0x0003
enum class EBFGQuest_ElementLocateHint_Mode : uint8
{
	AlwaysActive                             = 0,
	ActivateSequentially                     = 1,
	EBFGQuest_ElementLocateHint_MAX          = 2,
};

// Enum BFGCore.EBFGLocateLayer_Operation
// NumValues: 0x0003
enum class EBFGLocateLayer_Operation : uint8
{
	None                                     = 0,
	SharedLayerObjectiveDone                 = 1,
	EBFGLocateLayer_MAX                      = 2,
};

// Enum BFGCore.EBFGQuest_TimerMode
// NumValues: 0x0003
enum class EBFGQuest_TimerMode : uint8
{
	Default                                  = 0,
	Extended                                 = 1,
	EBFGQuest_MAX                            = 2,
};

// Enum BFGCore.EBFGQuestElement_AdditionalType
// NumValues: 0x0005
enum class EBFGQuestElement_AdditionalType : uint8
{
	None                                     = 0,
	Objective                                = 1,
	Condition                                = 2,
	OptionalConstraint                       = 3,
	EBFGQuestElement_MAX                     = 4,
};

// Enum BFGCore.FBFGQuest_Element_ProcessingMode
// NumValues: 0x0003
enum class EFBFGQuest_Element_ProcessingMode : uint8
{
	Objectives_Parallel                      = 0,
	Objectives_Sequential                    = 1,
	Objectives_MAX                           = 2,
};

// Enum BFGCore.FBFGQuest_Element_ExecutionTime
// NumValues: 0x0005
enum class EFBFGQuest_Element_ExecutionTime : uint8
{
	Execute_InElement                        = 0,
	Execute_QuestInProgress                  = 1,
	Execute_MainQuestInProgress              = 2,
	Execute_AnyTime                          = 3,
	Execute_MAX                              = 4,
};

// Enum BFGCore.EBFGQuest_EdgeType
// NumValues: 0x0005
enum class EBFGQuest_EdgeType : uint8
{
	Default                                  = 0,
	StartsAt                                 = 1,
	EndsAt                                   = 2,
	StartsAsObjective                        = 3,
	EBFGQuest_MAX                            = 4,
};

// Enum BFGCore.EBFGQuest_DebugCompletionMode
// NumValues: 0x0004
enum class EBFGQuest_DebugCompletionMode : uint8
{
	None                                     = 0,
	Complete_Element                         = 1,
	Complete_Quest                           = 2,
	EBFGQuest_MAX                            = 3,
};

// Enum BFGCore.FBFGQuest_ProximityMonitorSettings_Goal
// NumValues: 0x0003
enum class EFBFGQuest_ProximityMonitorSettings_Goal : uint8
{
	REACH                                    = 0,
	ESCAPE                                   = 1,
	FBFGQuest_ProximityMonitorSettings_MAX   = 2,
};

// Enum BFGCore.EBFGSaveContext
// NumValues: 0x0004
enum class EBFGSaveContext : uint8
{
	MetaData                                 = 0,
	Minimal                                  = 1,
	Detailed                                 = 2,
	EBFGSaveContext_MAX                      = 3,
};

// Enum BFGCore.EBFGSaveSystem_SaveGameAction_UseCase
// NumValues: 0x000A
enum class EBFGSaveSystem_SaveGameAction_UseCase : uint8
{
	None                                     = 0,
	CheckpointWithTeleport                   = 1,
	Checkpoint                               = 2,
	MainMissionFinished                      = 3,
	ChallengeFinished                        = 4,
	CancelChallenge                          = 5,
	AutoSave                                 = 6,
	NewGame                                  = 7,
	LevelSwitch                              = 8,
	EBFGSaveSystem_SaveGameAction_MAX        = 9,
};

// Enum BFGCore.EBFGSaveSystem_UIThrobber
// NumValues: 0x0005
enum class EBFGSaveSystem_UIThrobber : uint8
{
	None                                     = 0,
	InitOptionsThrobber                      = 1,
	LoadThrobber                             = 2,
	SaveThrobber                             = 3,
	EBFGSaveSystem_MAX                       = 4,
};

// Enum BFGCore.EBFGSaveData_RestoreContext
// NumValues: 0x0004
enum class EBFGSaveData_RestoreContext : uint8
{
	Default                                  = 0,
	Checkpoint                               = 1,
	Checkpoint_ChallengeExit                 = 2,
	EBFGSaveData_MAX                         = 3,
};

// Enum BFGCore.EBFGHighlightableClippingStyle
// NumValues: 0x0006
enum class EBFGHighlightableClippingStyle : uint8
{
	None                                     = 0,
	ClampOffscreenToViewport                 = 1,
	ClipOffscreen                            = 2,
	ClampSmooth                              = 3,
	ClampToTarget                            = 4,
	EBFGHighlightableClippingStyle_MAX       = 5,
};

// Enum BFGCore.EBFGScriptedSequence_ActivationAction
// NumValues: 0x0003
enum class EBFGScriptedSequence_ActivationAction : uint8
{
	None                                     = 0,
	AbortOtherSequencesForAgent              = 1,
	EBFGScriptedSequence_MAX                 = 2,
};

// Enum BFGCore.EBFGScriptedSequence_TaskResult
// NumValues: 0x0004
enum class EBFGScriptedSequence_TaskResult : uint8
{
	TaskCompleted                            = 0,
	TaskFailed                               = 1,
	TaskAborted                              = 2,
	EBFGScriptedSequence_MAX                 = 3,
};

// Enum BFGCore.EBFGScriptedSequenceTask_State
// NumValues: 0x0008
enum class EBFGScriptedSequenceTask_State : uint8
{
	IDLE                                     = 0,
	PAUSED                                   = 1,
	WAITING_FOR_RESTART                      = 2,
	RUNNING                                  = 3,
	FINISHED                                 = 4,
	ABORTED                                  = 5,
	DONE                                     = 6,
	EBFGScriptedSequenceTask_MAX             = 7,
};

// Enum BFGCore.EBFGScriptedSequence_TransientState
// NumValues: 0x0005
enum class EBFGScriptedSequence_TransientState : uint8
{
	None                                     = 0,
	AutoStart                                = 1,
	Start                                    = 2,
	Abort                                    = 3,
	EBFGScriptedSequence_MAX                 = 4,
};

// Enum BFGCore.EBFGSequenceState
// NumValues: 0x0005
enum class EBFGSequenceState : uint8
{
	Stop                                     = 0,
	Play                                     = 1,
	Pause                                    = 2,
	Suspended                                = 3,
	EBFGSequenceState_MAX                    = 4,
};

// Enum BFGCore.EBFGSpinningWidgetState
// NumValues: 0x0004
enum class EBFGSpinningWidgetState : uint8
{
	IDLE                                     = 0,
	SPINNING                                 = 1,
	DONE                                     = 2,
	EBFGSpinningWidgetState_MAX              = 3,
};

// Enum BFGCore.EBFGNetworkPathLocalization
// NumValues: 0x0004
enum class EBFGNetworkPathLocalization : uint8
{
	AtStart                                  = 0,
	OnPath                                   = 1,
	AtEnd                                    = 2,
	EBFGNetworkPathLocalization_MAX          = 3,
};

// Enum BFGCore.EBFGEvadeDirectionMode
// NumValues: 0x0006
enum class EBFGEvadeDirectionMode : uint8
{
	LeftRightBack                            = 0,
	LeftRight                                = 1,
	Left                                     = 2,
	Right                                    = 3,
	Back                                     = 4,
	EBFGEvadeDirectionMode_MAX               = 5,
};

// Enum BFGCore.EBFGLoadingScreenState
// NumValues: 0x0004
enum class EBFGLoadingScreenState : uint8
{
	SHOWN                                    = 0,
	HIDDEN                                   = 1,
	INIT                                     = 2,
	EBFGLoadingScreenState_MAX               = 3,
};

// Enum BFGCore.EBFGFadeToBlackState
// NumValues: 0x0004
enum class EBFGFadeToBlackState : uint8
{
	FADE_TO_BLACK                            = 0,
	FADE_FROM_BLACK                          = 1,
	NONE                                     = 2,
	EBFGFadeToBlackState_MAX                 = 3,
};

// Enum BFGCore.EBFGLoadingScreenType
// NumValues: 0x0005
enum class EBFGLoadingScreenType : uint8
{
	LOADING                                  = 0,
	CONNECTING                               = 1,
	NO_PICTURE_JUSTBLACK                     = 2,
	NONE                                     = 3,
	EBFGLoadingScreenType_MAX                = 4,
};

// Enum BFGCore.EBFGDoorRotationAxis
// NumValues: 0x0004
enum class EBFGDoorRotationAxis : uint8
{
	DRA_PITCH                                = 0,
	DRA_YAW                                  = 1,
	DRA_ROLL                                 = 2,
	DRA_MAX                                  = 3,
};

// Enum BFGCore.EBFGVehiclePluginType
// NumValues: 0x0003
enum class EBFGVehiclePluginType : uint8
{
	Undefinied                               = 0,
	Siren                                    = 1,
	EBFGVehiclePluginType_MAX                = 2,
};

// Enum BFGCore.EBFGDoorState
// NumValues: 0x0006
enum class EBFGDoorState : uint8
{
	Closed                                   = 0,
	Opening                                  = 1,
	Opened                                   = 2,
	Closing                                  = 3,
	Destroyed                                = 4,
	EBFGDoorState_MAX                        = 5,
};

// Enum BFGCore.EBFGNetworkAgentAvoidanceStatus
// NumValues: 0x0005
enum class EBFGNetworkAgentAvoidanceStatus : uint8
{
	None                                     = 0,
	Handling                                 = 1,
	AvoidingPending                          = 2,
	Blocked                                  = 3,
	EBFGNetworkAgentAvoidanceStatus_MAX      = 4,
};

// Enum BFGCore.EBFGVehiclePassenger_PassengerInVehicleAnimation
// NumValues: 0x0003
enum class EBFGVehiclePassenger_PassengerInVehicleAnimation : uint8
{
	Default                                  = 0,
	Panic                                    = 1,
	EBFGVehiclePassenger_MAX                 = 2,
};

// Enum BFGCore.EBFGVehiclePassenger_PassengerState
// NumValues: 0x0006
enum class EBFGVehiclePassenger_PassengerState : uint8
{
	None                                     = 0,
	InCar                                    = 1,
	Exiting                                  = 2,
	Out                                      = 3,
	Entering                                 = 4,
	EBFGVehiclePassenger_MAX                 = 5,
};

// Enum BFGCore.EBFGVehiclePassenger_Spot
// NumValues: 0x0006
enum class EBFGVehiclePassenger_Spot : uint8
{
	None                                     = 0,
	Driver                                   = 1,
	FrontRight                               = 2,
	Passenger                                = 3,
	Transport                                = 4,
	EBFGVehiclePassenger_MAX                 = 5,
};

// Enum BFGCore.EBFGVoiceoverGroupCancelPolicy
// NumValues: 0x0006
enum class EBFGVoiceoverGroupCancelPolicy : uint8
{
	Queued                                   = 0,
	Interrupt                                = 1,
	Blocked                                  = 2,
	DuckPlaying                              = 3,
	DuckSelf                                 = 4,
	EBFGVoiceoverGroupCancelPolicy_MAX       = 5,
};

// Enum BFGCore.EBFGVoiceoverQueuedRequestState
// NumValues: 0x0005
enum class EBFGVoiceoverQueuedRequestState : uint8
{
	Enqueued                                 = 0,
	Playing                                  = 1,
	Canceling                                = 2,
	Done                                     = 3,
	EBFGVoiceoverQueuedRequestState_MAX      = 4,
};

// Enum BFGCore.EBFGVoiceoverResultType
// NumValues: 0x0003
enum class EBFGVoiceoverResultType : uint8
{
	Completed                                = 0,
	Aborted                                  = 1,
	EBFGVoiceoverResultType_MAX              = 2,
};

// Enum BFGCore.EBFGVoiceoverItemEventType
// NumValues: 0x0006
enum class EBFGVoiceoverItemEventType : uint8
{
	PlayStarted                              = 0,
	PlayCanceled                             = 1,
	PlayCompleted                            = 2,
	Enqueued                                 = 3,
	Cleared                                  = 4,
	EBFGVoiceoverItemEventType_MAX           = 5,
};

// Enum BFGCore.EBFGVoiceoverPlaybackState
// NumValues: 0x0004
enum class EBFGVoiceoverPlaybackState : uint8
{
	Enqueued                                 = 0,
	Playing                                  = 1,
	NotFound                                 = 2,
	EBFGVoiceoverPlaybackState_MAX           = 3,
};

// Enum BFGCore.EWeaponFireAttemptResult
// NumValues: 0x0005
enum class EWeaponFireAttemptResult : uint8
{
	Success                                  = 0,
	OutOfAmmo                                = 1,
	Jammed                                   = 2,
	Other                                    = 3,
	EWeaponFireAttemptResult_MAX             = 4,
};

// Enum BFGCore.EBFGDualWieldRedirect
// NumValues: 0x0004
enum class EBFGDualWieldRedirect : uint8
{
	None                                     = 0,
	RedirectLeft                             = 1,
	RedirectRight                            = 2,
	EBFGDualWieldRedirect_MAX                = 3,
};

// Enum BFGCore.EBFGTargetVelocityDampingMethod
// NumValues: 0x0005
enum class EBFGTargetVelocityDampingMethod : uint8
{
	Constant                                 = 0,
	SmoothDamp                               = 1,
	VInterpTo                                = 2,
	CriticallyDamped                         = 3,
	EBFGTargetVelocityDampingMethod_MAX      = 4,
};

// Enum BFGCore.EBFGWeaponAimingMode
// NumValues: 0x0006
enum class EBFGWeaponAimingMode : uint8
{
	None                                     = 0,
	Idle                                     = 1,
	KeepRelative                             = 2,
	KeepWorld                                = 3,
	LockOnTarget                             = 4,
	EBFGWeaponAimingMode_MAX                 = 5,
};

// Enum BFGCore.EBFGFuronigamiUIState
// NumValues: 0x0005
enum class EBFGFuronigamiUIState : uint8
{
	Init                                     = 0,
	SelectMedia                              = 1,
	WaitForMediaWidget                       = 2,
	ViewMedia                                = 3,
	EBFGFuronigamiUIState_MAX                = 4,
};

// Enum BFGCore.EContextualHintMode
// NumValues: 0x0003
enum class EContextualHintMode : uint8
{
	PlayerInteraction                        = 0,
	InputAction                              = 1,
	EContextualHintMode_MAX                  = 2,
};

// Enum BFGCore.EButtonState
// NumValues: 0x0004
enum class EButtonState : uint8
{
	ACCEPTBUTTON                             = 0,
	BACKBUTTON                               = 1,
	DEFAULT                                  = 2,
	EButtonState_MAX                         = 3,
};

// Enum BFGCore.EBFGWidget_GenericHold_Button
// NumValues: 0x0005
enum class EBFGWidget_GenericHold_Button : uint8
{
	Advance                                  = 0,
	Back                                     = 1,
	ModeForward                              = 2,
	ModeBack                                 = 3,
	EBFGWidget_GenericHold_MAX               = 4,
};

// Enum BFGCore.EBFGBossPhaseWidget
// NumValues: 0x0005
enum class EBFGBossPhaseWidget : uint8
{
	PHASE0                                   = 0,
	PHASE1                                   = 1,
	PHASE2                                   = 2,
	PHASE3                                   = 3,
	EBFGBossPhaseWidget_MAX                  = 4,
};

// Enum BFGCore.EBFGSceneObjectHighlighterType
// NumValues: 0x0004
enum class EBFGSceneObjectHighlighterType : uint8
{
	OffScreen                                = 0,
	OnScreen                                 = 1,
	Both                                     = 2,
	EBFGSceneObjectHighlighterType_MAX       = 3,
};

// Enum BFGCore.EBFGTextNotification_Severity
// NumValues: 0x0003
enum class EBFGTextNotification_Severity : uint8
{
	INFO                                     = 0,
	WARNING                                  = 1,
	EBFGTextNotification_MAX                 = 2,
};

// Enum BFGCore.EBFGWeaponSlotSet
// NumValues: 0x0004
enum class EBFGWeaponSlotSet : uint8
{
	None                                     = 0,
	Player                                   = 1,
	UFO                                      = 2,
	EBFGWeaponSlotSet_MAX                    = 3,
};

// Enum BFGCore.EBFGIISState
// NumValues: 0x0005
enum class EBFGIISState : uint8
{
	WaitForInput                             = 0,
	WaitForLoginScreen                       = 1,
	WaitForRemove                            = 2,
	Exit                                     = 3,
	EBFGIISState_MAX                         = 4,
};

// Enum BFGCore.EBFGMessageBoxType
// NumValues: 0x0005
enum class EBFGMessageBoxType : uint8
{
	OK                                       = 0,
	Cancel                                   = 1,
	OkCancel                                 = 2,
	YesNo                                    = 3,
	EBFGMessageBoxType_MAX                   = 4,
};

// Enum BFGCore.EBFGMissionResultType
// NumValues: 0x0005
enum class EBFGMissionResultType : uint8
{
	Mission_None                             = 0,
	Mission_Successful                       = 1,
	Mission_Failed                           = 2,
	Mission_Restart                          = 3,
	Mission_MAX                              = 4,
};

// Enum BFGCore.EBFGMissionSelectionInputState
// NumValues: 0x0004
enum class EBFGMissionSelectionInputState : uint8
{
	UNINITIALIZED                            = 0,
	PROCESSINPUT                             = 1,
	FINISHED                                 = 2,
	EBFGMissionSelectionInputState_MAX       = 3,
};

// Enum BFGCore.EBFGMissionSelectionAvailabilityState
// NumValues: 0x0005
enum class EBFGMissionSelectionAvailabilityState : uint8
{
	UNAVAILABLE                              = 0,
	UNVISITED                                = 1,
	VISITED                                  = 2,
	FINISHED                                 = 3,
	EBFGMissionSelectionAvailabilityState_MAX = 4,
};

// Enum BFGCore.EBFGUpgradeItemStatus
// NumValues: 0x0004
enum class EBFGUpgradeItemStatus : uint8
{
	LOCKED                                   = 0,
	PURCHASED                                = 1,
	UNLOCKED                                 = 2,
	EBFGUpgradeItemStatus_MAX                = 3,
};

// Enum BFGCore.EBFGMothershipSubmenuAnimationState
// NumValues: 0x0005
enum class EBFGMothershipSubmenuAnimationState : uint8
{
	Hidden                                   = 0,
	Showing                                  = 1,
	Shown                                    = 2,
	Hiding                                   = 3,
	EBFGMothershipSubmenuAnimationState_MAX  = 4,
};

// Enum BFGCore.EPoxLabUpgradeGraphNodeState
// NumValues: 0x0008
enum class EPoxLabUpgradeGraphNodeState : uint8
{
	Locked                                   = 0,
	Disabled                                 = 1,
	NoDNA                                    = 2,
	Unselected                               = 3,
	Selected                                 = 4,
	Activated                                = 5,
	ActivatedAndSelected                     = 6,
	EPoxLabUpgradeGraphNodeState_MAX         = 7,
};

// Enum BFGCore.EBossMarkerType
// NumValues: 0x0006
enum class EBossMarkerType : uint8
{
	ANCHOR                                   = 0,
	REINFORCEMENT                            = 1,
	RELOCATE                                 = 2,
	AIRMINESPAWN                             = 3,
	BEAM                                     = 4,
	EBossMarkerType_MAX                      = 5,
};

// ScriptStruct BFGCore.BFGCharacterMovement_PivotDetectionData
// 0x0010 (0x0010 - 0x0000)
struct alignas(0x04) FBFGCharacterMovement_PivotDetectionData final
{
public:
	uint8                                         Pad_0[0x10];                                       // 0x0000(0x0010)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FBFGCharacterMovement_PivotDetectionData) == 0x000004, "Wrong alignment on FBFGCharacterMovement_PivotDetectionData");
static_assert(sizeof(FBFGCharacterMovement_PivotDetectionData) == 0x000010, "Wrong size on FBFGCharacterMovement_PivotDetectionData");

// ScriptStruct BFGCore.BFGPlayerSkill_Tags
// 0x0018 (0x0018 - 0x0000)
struct FBFGPlayerSkill_Tags final
{
public:
	struct FGameplayTag                           M_skillTag;                                        // 0x0000(0x0008)(Edit, DisableEditOnInstance, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TArray<struct FGameplayTag>                   M_aUpgradeTags;                                    // 0x0008(0x0010)(Edit, ZeroConstructor, DisableEditOnInstance, NativeAccessSpecifierPublic)
};
static_assert(alignof(FBFGPlayerSkill_Tags) == 0x000008, "Wrong alignment on FBFGPlayerSkill_Tags");
static_assert(sizeof(FBFGPlayerSkill_Tags) == 0x000018, "Wrong size on FBFGPlayerSkill_Tags");
static_assert(offsetof(FBFGPlayerSkill_Tags, M_skillTag) == 0x000000, "Member 'FBFGPlayerSkill_Tags::M_skillTag' has a wrong offset!");
static_assert(offsetof(FBFGPlayerSkill_Tags, M_aUpgradeTags) == 0x000008, "Member 'FBFGPlayerSkill_Tags::M_aUpgradeTags' has a wrong offset!");

// ScriptStruct BFGCore.BFGPlayerSettingsMentalAbilityInfo
// 0x0048 (0x0048 - 0x0000)
struct FBFGPlayerSettingsMentalAbilityInfo final
{
public:
	struct FSoftClassPath                         MentalAbilityClass;                                // 0x0000(0x0018)(Edit, BlueprintVisible, ZeroConstructor, NativeAccessSpecifierPublic)
	struct FSoftClassPath                         M_pOptionIcon;                                     // 0x0018(0x0018)(Edit, BlueprintVisible, ZeroConstructor, NativeAccessSpecifierPublic)
	struct FBFGPlayerSkill_Tags                   M_UnlockTags;                                      // 0x0030(0x0018)(Edit, BlueprintVisible, NativeAccessSpecifierPublic)
};
static_assert(alignof(FBFGPlayerSettingsMentalAbilityInfo) == 0x000008, "Wrong alignment on FBFGPlayerSettingsMentalAbilityInfo");
static_assert(sizeof(FBFGPlayerSettingsMentalAbilityInfo) == 0x000048, "Wrong size on FBFGPlayerSettingsMentalAbilityInfo");
static_assert(offsetof(FBFGPlayerSettingsMentalAbilityInfo, MentalAbilityClass) == 0x000000, "Member 'FBFGPlayerSettingsMentalAbilityInfo::MentalAbilityClass' has a wrong offset!");
static_assert(offsetof(FBFGPlayerSettingsMentalAbilityInfo, M_pOptionIcon) == 0x000018, "Member 'FBFGPlayerSettingsMentalAbilityInfo::M_pOptionIcon' has a wrong offset!");
static_assert(offsetof(FBFGPlayerSettingsMentalAbilityInfo, M_UnlockTags) == 0x000030, "Member 'FBFGPlayerSettingsMentalAbilityInfo::M_UnlockTags' has a wrong offset!");

// ScriptStruct BFGCore.BFGBehaviorStateChangeRequest
// 0x0028 (0x0028 - 0x0000)
struct FBFGBehaviorStateChangeRequest final
{
public:
	EBFGBehaviourState_NPC                        M_eRequestedState;                                 // 0x0000(0x0001)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1[0x7];                                        // 0x0001(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	class AActor*                                 M_pTargetActor;                                    // 0x0008(0x0008)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                M_vSuspiciousLocation;                             // 0x0010(0x000C)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          M_bSuspiciousLocationSure;                         // 0x001C(0x0001)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1D[0x3];                                       // 0x001D(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	class UObject*                                M_pLockOwner;                                      // 0x0020(0x0008)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FBFGBehaviorStateChangeRequest) == 0x000008, "Wrong alignment on FBFGBehaviorStateChangeRequest");
static_assert(sizeof(FBFGBehaviorStateChangeRequest) == 0x000028, "Wrong size on FBFGBehaviorStateChangeRequest");
static_assert(offsetof(FBFGBehaviorStateChangeRequest, M_eRequestedState) == 0x000000, "Member 'FBFGBehaviorStateChangeRequest::M_eRequestedState' has a wrong offset!");
static_assert(offsetof(FBFGBehaviorStateChangeRequest, M_pTargetActor) == 0x000008, "Member 'FBFGBehaviorStateChangeRequest::M_pTargetActor' has a wrong offset!");
static_assert(offsetof(FBFGBehaviorStateChangeRequest, M_vSuspiciousLocation) == 0x000010, "Member 'FBFGBehaviorStateChangeRequest::M_vSuspiciousLocation' has a wrong offset!");
static_assert(offsetof(FBFGBehaviorStateChangeRequest, M_bSuspiciousLocationSure) == 0x00001C, "Member 'FBFGBehaviorStateChangeRequest::M_bSuspiciousLocationSure' has a wrong offset!");
static_assert(offsetof(FBFGBehaviorStateChangeRequest, M_pLockOwner) == 0x000020, "Member 'FBFGBehaviorStateChangeRequest::M_pLockOwner' has a wrong offset!");

// ScriptStruct BFGCore.BFGInteractAnimationData
// 0x0060 (0x0060 - 0x0000)
struct FBFGInteractAnimationData final
{
public:
	struct FGuid                                  M_guid;                                            // 0x0000(0x0010)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EBFGAnimation_Interact                        M_eAnimationId;                                    // 0x0010(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_11[0x7];                                       // 0x0011(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	class UAnimationAsset*                        M_pAnimationAsset;                                 // 0x0018(0x0008)(BlueprintVisible, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          M_bAllowAbortByPlayerBump;                         // 0x0020(0x0001)(BlueprintVisible, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          M_bIsInfiniteLoop;                                 // 0x0021(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_22[0x2];                                       // 0x0022(0x0002)(Fixing Size After Last Property [ Dumper-7 ])
	int32                                         M_iNumRemaingLoops;                                // 0x0024(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EBFGAnimation_Interact                        M_eInSynchWithAnimationId;                         // 0x0028(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          M_bBlendWithRootMotion;                            // 0x0029(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2A[0x2];                                       // 0x002A(0x0002)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         M_fBlendDuration;                                  // 0x002C(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                M_vTargetLocation;                                 // 0x0030(0x000C)(BlueprintVisible, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FRotator                               M_vTargetOrientation;                              // 0x003C(0x000C)(BlueprintVisible, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
	class UBFGInteractAnimationObject*            M_pAnimationObject;                                // 0x0048(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UAnimationAsset*                        M_pPreviousAnimationAsset;                         // 0x0050(0x0008)(BlueprintVisible, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          M_bAssetRequired;                                  // 0x0058(0x0001)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EBFGInteractAnimation_AnimSelector            M_eSelector;                                       // 0x0059(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_5A[0x2];                                       // 0x005A(0x0002)(Fixing Size After Last Property [ Dumper-7 ])
	int32                                         M_iVariation;                                      // 0x005C(0x0004)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FBFGInteractAnimationData) == 0x000008, "Wrong alignment on FBFGInteractAnimationData");
static_assert(sizeof(FBFGInteractAnimationData) == 0x000060, "Wrong size on FBFGInteractAnimationData");
static_assert(offsetof(FBFGInteractAnimationData, M_guid) == 0x000000, "Member 'FBFGInteractAnimationData::M_guid' has a wrong offset!");
static_assert(offsetof(FBFGInteractAnimationData, M_eAnimationId) == 0x000010, "Member 'FBFGInteractAnimationData::M_eAnimationId' has a wrong offset!");
static_assert(offsetof(FBFGInteractAnimationData, M_pAnimationAsset) == 0x000018, "Member 'FBFGInteractAnimationData::M_pAnimationAsset' has a wrong offset!");
static_assert(offsetof(FBFGInteractAnimationData, M_bAllowAbortByPlayerBump) == 0x000020, "Member 'FBFGInteractAnimationData::M_bAllowAbortByPlayerBump' has a wrong offset!");
static_assert(offsetof(FBFGInteractAnimationData, M_bIsInfiniteLoop) == 0x000021, "Member 'FBFGInteractAnimationData::M_bIsInfiniteLoop' has a wrong offset!");
static_assert(offsetof(FBFGInteractAnimationData, M_iNumRemaingLoops) == 0x000024, "Member 'FBFGInteractAnimationData::M_iNumRemaingLoops' has a wrong offset!");
static_assert(offsetof(FBFGInteractAnimationData, M_eInSynchWithAnimationId) == 0x000028, "Member 'FBFGInteractAnimationData::M_eInSynchWithAnimationId' has a wrong offset!");
static_assert(offsetof(FBFGInteractAnimationData, M_bBlendWithRootMotion) == 0x000029, "Member 'FBFGInteractAnimationData::M_bBlendWithRootMotion' has a wrong offset!");
static_assert(offsetof(FBFGInteractAnimationData, M_fBlendDuration) == 0x00002C, "Member 'FBFGInteractAnimationData::M_fBlendDuration' has a wrong offset!");
static_assert(offsetof(FBFGInteractAnimationData, M_vTargetLocation) == 0x000030, "Member 'FBFGInteractAnimationData::M_vTargetLocation' has a wrong offset!");
static_assert(offsetof(FBFGInteractAnimationData, M_vTargetOrientation) == 0x00003C, "Member 'FBFGInteractAnimationData::M_vTargetOrientation' has a wrong offset!");
static_assert(offsetof(FBFGInteractAnimationData, M_pAnimationObject) == 0x000048, "Member 'FBFGInteractAnimationData::M_pAnimationObject' has a wrong offset!");
static_assert(offsetof(FBFGInteractAnimationData, M_pPreviousAnimationAsset) == 0x000050, "Member 'FBFGInteractAnimationData::M_pPreviousAnimationAsset' has a wrong offset!");
static_assert(offsetof(FBFGInteractAnimationData, M_bAssetRequired) == 0x000058, "Member 'FBFGInteractAnimationData::M_bAssetRequired' has a wrong offset!");
static_assert(offsetof(FBFGInteractAnimationData, M_eSelector) == 0x000059, "Member 'FBFGInteractAnimationData::M_eSelector' has a wrong offset!");
static_assert(offsetof(FBFGInteractAnimationData, M_iVariation) == 0x00005C, "Member 'FBFGInteractAnimationData::M_iVariation' has a wrong offset!");

// ScriptStruct BFGCore.BFGInteractAnimationSequence
// 0x0018 (0x0018 - 0x0000)
struct FBFGInteractAnimationSequence final
{
public:
	TArray<struct FBFGInteractAnimationData>      M_aAnimationSequence;                              // 0x0000(0x0010)(Edit, BlueprintVisible, ZeroConstructor, NativeAccessSpecifierPublic)
	EBFGAnimation_Interact                        M_eInterruptAnimation;                             // 0x0010(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_11[0x7];                                       // 0x0011(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FBFGInteractAnimationSequence) == 0x000008, "Wrong alignment on FBFGInteractAnimationSequence");
static_assert(sizeof(FBFGInteractAnimationSequence) == 0x000018, "Wrong size on FBFGInteractAnimationSequence");
static_assert(offsetof(FBFGInteractAnimationSequence, M_aAnimationSequence) == 0x000000, "Member 'FBFGInteractAnimationSequence::M_aAnimationSequence' has a wrong offset!");
static_assert(offsetof(FBFGInteractAnimationSequence, M_eInterruptAnimation) == 0x000010, "Member 'FBFGInteractAnimationSequence::M_eInterruptAnimation' has a wrong offset!");

// ScriptStruct BFGCore.BFGAgentAIData
// 0x00B0 (0x00B0 - 0x0000)
struct FBFGAgentAIData final
{
public:
	bool                                          M_bAutoJoinNetwork;                                // 0x0000(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EBFGNetworkPathAgentComponentInitialAI        M_eInitialAI;                                      // 0x0001(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          M_bRememberInitialAI;                              // 0x0002(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_3[0x5];                                        // 0x0003(0x0005)(Fixing Size After Last Property [ Dumper-7 ])
	class AActor*                                 M_pCurrentTarget;                                  // 0x0008(0x0008)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FBFGBehaviorStateChangeRequest         M_eInitialBehaviorStateRequest;                    // 0x0010(0x0028)(Transient, NoDestructor, NativeAccessSpecifierPublic)
	TSoftObjectPtr<class AActor>                  M_pCurrentMissionTarget;                           // 0x0038(0x0028)(Edit, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EBFGMissionTargetAction_NPC                   M_eCurrentMissionTargetAction;                     // 0x0060(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          M_bForceTargetEvenIfNotInPerceptionRange;          // 0x0061(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          M_bForceTargetEvenIfDisguised;                     // 0x0062(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EBFGNPCCharacter_MoveSpeed                    M_moveSpeedOverride;                               // 0x0063(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_64[0x4];                                       // 0x0064(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	struct FBFGInteractAnimationSequence          M_animationSequence;                               // 0x0068(0x0018)(Edit, NativeAccessSpecifierPublic)
	class UBFGCrowdLifeStationComponent*          M_pRequestedStation;                               // 0x0080(0x0008)(ExportObject, ZeroConstructor, Transient, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         M_fMinimalRangeWhenTargetted;                      // 0x0088(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         M_fOptimalRangeWhenTargetted;                      // 0x008C(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         M_fMaximumRangeWhenTargetted;                      // 0x0090(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         M_bAllowRelocate : 1;                              // 0x0094(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (Edit, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         M_bAllowFlee : 1;                                  // 0x0094(0x0001)(BitIndex: 0x01, PropSize: 0x0001 (Edit, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         M_bCombatExitVehicle : 1;                          // 0x0094(0x0001)(BitIndex: 0x02, PropSize: 0x0001 (Edit, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         M_bAlwaysWeaponEquipped : 1;                       // 0x0094(0x0001)(BitIndex: 0x03, PropSize: 0x0001 (Edit, BlueprintVisible, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         M_bIsDetectable : 1;                               // 0x0094(0x0001)(BitIndex: 0x04, PropSize: 0x0001 (Edit, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         M_bIsTargetable : 1;                               // 0x0094(0x0001)(BitIndex: 0x05, PropSize: 0x0001 (Edit, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         M_bAllowsTargetSwitch : 1;                         // 0x0094(0x0001)(BitIndex: 0x06, PropSize: 0x0001 (Edit, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         Pad_95[0x3];                                       // 0x0095(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	bool                                          M_bBehaviourStateLocked;                           // 0x0098(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_99[0x7];                                       // 0x0099(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	class UObject*                                M_pBehaviourStateLockOwner;                        // 0x00A0(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          M_bIsOff;                                          // 0x00A8(0x0001)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_A9[0x7];                                       // 0x00A9(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FBFGAgentAIData) == 0x000008, "Wrong alignment on FBFGAgentAIData");
static_assert(sizeof(FBFGAgentAIData) == 0x0000B0, "Wrong size on FBFGAgentAIData");
static_assert(offsetof(FBFGAgentAIData, M_bAutoJoinNetwork) == 0x000000, "Member 'FBFGAgentAIData::M_bAutoJoinNetwork' has a wrong offset!");
static_assert(offsetof(FBFGAgentAIData, M_eInitialAI) == 0x000001, "Member 'FBFGAgentAIData::M_eInitialAI' has a wrong offset!");
static_assert(offsetof(FBFGAgentAIData, M_bRememberInitialAI) == 0x000002, "Member 'FBFGAgentAIData::M_bRememberInitialAI' has a wrong offset!");
static_assert(offsetof(FBFGAgentAIData, M_pCurrentTarget) == 0x000008, "Member 'FBFGAgentAIData::M_pCurrentTarget' has a wrong offset!");
static_assert(offsetof(FBFGAgentAIData, M_eInitialBehaviorStateRequest) == 0x000010, "Member 'FBFGAgentAIData::M_eInitialBehaviorStateRequest' has a wrong offset!");
static_assert(offsetof(FBFGAgentAIData, M_pCurrentMissionTarget) == 0x000038, "Member 'FBFGAgentAIData::M_pCurrentMissionTarget' has a wrong offset!");
static_assert(offsetof(FBFGAgentAIData, M_eCurrentMissionTargetAction) == 0x000060, "Member 'FBFGAgentAIData::M_eCurrentMissionTargetAction' has a wrong offset!");
static_assert(offsetof(FBFGAgentAIData, M_bForceTargetEvenIfNotInPerceptionRange) == 0x000061, "Member 'FBFGAgentAIData::M_bForceTargetEvenIfNotInPerceptionRange' has a wrong offset!");
static_assert(offsetof(FBFGAgentAIData, M_bForceTargetEvenIfDisguised) == 0x000062, "Member 'FBFGAgentAIData::M_bForceTargetEvenIfDisguised' has a wrong offset!");
static_assert(offsetof(FBFGAgentAIData, M_moveSpeedOverride) == 0x000063, "Member 'FBFGAgentAIData::M_moveSpeedOverride' has a wrong offset!");
static_assert(offsetof(FBFGAgentAIData, M_animationSequence) == 0x000068, "Member 'FBFGAgentAIData::M_animationSequence' has a wrong offset!");
static_assert(offsetof(FBFGAgentAIData, M_pRequestedStation) == 0x000080, "Member 'FBFGAgentAIData::M_pRequestedStation' has a wrong offset!");
static_assert(offsetof(FBFGAgentAIData, M_fMinimalRangeWhenTargetted) == 0x000088, "Member 'FBFGAgentAIData::M_fMinimalRangeWhenTargetted' has a wrong offset!");
static_assert(offsetof(FBFGAgentAIData, M_fOptimalRangeWhenTargetted) == 0x00008C, "Member 'FBFGAgentAIData::M_fOptimalRangeWhenTargetted' has a wrong offset!");
static_assert(offsetof(FBFGAgentAIData, M_fMaximumRangeWhenTargetted) == 0x000090, "Member 'FBFGAgentAIData::M_fMaximumRangeWhenTargetted' has a wrong offset!");
static_assert(offsetof(FBFGAgentAIData, M_bBehaviourStateLocked) == 0x000098, "Member 'FBFGAgentAIData::M_bBehaviourStateLocked' has a wrong offset!");
static_assert(offsetof(FBFGAgentAIData, M_pBehaviourStateLockOwner) == 0x0000A0, "Member 'FBFGAgentAIData::M_pBehaviourStateLockOwner' has a wrong offset!");
static_assert(offsetof(FBFGAgentAIData, M_bIsOff) == 0x0000A8, "Member 'FBFGAgentAIData::M_bIsOff' has a wrong offset!");

// ScriptStruct BFGCore.BFGActorBinding
// 0x0090 (0x0090 - 0x0000)
struct FBFGActorBinding final
{
public:
	TSubclassOf<class AActor>                     M_pActorClass;                                     // 0x0000(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FGameplayTagQuery                      M_gamplayTagQuery;                                 // 0x0008(0x0048)(Edit, BlueprintVisible, BlueprintReadOnly, NativeAccessSpecifierPublic)
	TSoftObjectPtr<class AActor>                  M_softActorInstance;                               // 0x0050(0x0028)(Edit, BlueprintVisible, BlueprintReadOnly, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EBFGActorAliveState                           M_eAliveState;                                     // 0x0078(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          M_bIsPlayerCharacter;                              // 0x0079(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          M_bIsPlayerUFO;                                    // 0x007A(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_7B[0x15];                                      // 0x007B(0x0015)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FBFGActorBinding) == 0x000008, "Wrong alignment on FBFGActorBinding");
static_assert(sizeof(FBFGActorBinding) == 0x000090, "Wrong size on FBFGActorBinding");
static_assert(offsetof(FBFGActorBinding, M_pActorClass) == 0x000000, "Member 'FBFGActorBinding::M_pActorClass' has a wrong offset!");
static_assert(offsetof(FBFGActorBinding, M_gamplayTagQuery) == 0x000008, "Member 'FBFGActorBinding::M_gamplayTagQuery' has a wrong offset!");
static_assert(offsetof(FBFGActorBinding, M_softActorInstance) == 0x000050, "Member 'FBFGActorBinding::M_softActorInstance' has a wrong offset!");
static_assert(offsetof(FBFGActorBinding, M_eAliveState) == 0x000078, "Member 'FBFGActorBinding::M_eAliveState' has a wrong offset!");
static_assert(offsetof(FBFGActorBinding, M_bIsPlayerCharacter) == 0x000079, "Member 'FBFGActorBinding::M_bIsPlayerCharacter' has a wrong offset!");
static_assert(offsetof(FBFGActorBinding, M_bIsPlayerUFO) == 0x00007A, "Member 'FBFGActorBinding::M_bIsPlayerUFO' has a wrong offset!");

// ScriptStruct BFGCore.BFGQuest_UIProvider
// 0x0050 (0x0050 - 0x0000)
struct FBFGQuest_UIProvider final
{
public:
	bool                                          M_bShowInUI;                                       // 0x0000(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1[0x7];                                        // 0x0001(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	TSoftObjectPtr<class UPaperSprite>            M_spSprite;                                        // 0x0008(0x0028)(Edit, BlueprintVisible, BlueprintReadOnly, DisableEditOnInstance, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FText                                   M_strText;                                         // 0x0030(0x0018)(Edit, BlueprintVisible, BlueprintReadOnly, DisableEditOnInstance, NativeAccessSpecifierPublic)
	EBFGQuest_UI_BarType                          M_eBarType;                                        // 0x0048(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_49[0x7];                                       // 0x0049(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FBFGQuest_UIProvider) == 0x000008, "Wrong alignment on FBFGQuest_UIProvider");
static_assert(sizeof(FBFGQuest_UIProvider) == 0x000050, "Wrong size on FBFGQuest_UIProvider");
static_assert(offsetof(FBFGQuest_UIProvider, M_bShowInUI) == 0x000000, "Member 'FBFGQuest_UIProvider::M_bShowInUI' has a wrong offset!");
static_assert(offsetof(FBFGQuest_UIProvider, M_spSprite) == 0x000008, "Member 'FBFGQuest_UIProvider::M_spSprite' has a wrong offset!");
static_assert(offsetof(FBFGQuest_UIProvider, M_strText) == 0x000030, "Member 'FBFGQuest_UIProvider::M_strText' has a wrong offset!");
static_assert(offsetof(FBFGQuest_UIProvider, M_eBarType) == 0x000048, "Member 'FBFGQuest_UIProvider::M_eBarType' has a wrong offset!");

// ScriptStruct BFGCore.BFGObjectiveMarkerInfoEntry
// 0x0040 (0x0040 - 0x0000)
struct FBFGObjectiveMarkerInfoEntry final
{
public:
	bool                                          M_bActivateMarker;                                 // 0x0000(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EBFGObjectiveMarkerType                       M_type;                                            // 0x0001(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2[0x6];                                        // 0x0002(0x0006)(Fixing Size After Last Property [ Dumper-7 ])
	TSoftClassPtr<class UClass>                   M_actorClass;                                      // 0x0008(0x0028)(Edit, BlueprintVisible, BlueprintReadOnly, Config, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class USceneComponent*                        M_pAttachTo;                                       // 0x0030(0x0008)(Edit, BlueprintVisible, ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   M_strSocket;                                       // 0x0038(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FBFGObjectiveMarkerInfoEntry) == 0x000008, "Wrong alignment on FBFGObjectiveMarkerInfoEntry");
static_assert(sizeof(FBFGObjectiveMarkerInfoEntry) == 0x000040, "Wrong size on FBFGObjectiveMarkerInfoEntry");
static_assert(offsetof(FBFGObjectiveMarkerInfoEntry, M_bActivateMarker) == 0x000000, "Member 'FBFGObjectiveMarkerInfoEntry::M_bActivateMarker' has a wrong offset!");
static_assert(offsetof(FBFGObjectiveMarkerInfoEntry, M_type) == 0x000001, "Member 'FBFGObjectiveMarkerInfoEntry::M_type' has a wrong offset!");
static_assert(offsetof(FBFGObjectiveMarkerInfoEntry, M_actorClass) == 0x000008, "Member 'FBFGObjectiveMarkerInfoEntry::M_actorClass' has a wrong offset!");
static_assert(offsetof(FBFGObjectiveMarkerInfoEntry, M_pAttachTo) == 0x000030, "Member 'FBFGObjectiveMarkerInfoEntry::M_pAttachTo' has a wrong offset!");
static_assert(offsetof(FBFGObjectiveMarkerInfoEntry, M_strSocket) == 0x000038, "Member 'FBFGObjectiveMarkerInfoEntry::M_strSocket' has a wrong offset!");

// ScriptStruct BFGCore.BFGObjectiveMarkerInfo
// 0x0028 (0x0028 - 0x0000)
struct FBFGObjectiveMarkerInfo final
{
public:
	bool                                          M_bShowMarkers;                                    // 0x0000(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1[0x7];                                        // 0x0001(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	class UBFGObjectiveMarkerTemplate*            M_pMarkers;                                        // 0x0008(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TArray<struct FBFGObjectiveMarkerInfoEntry>   M_aOverrides;                                      // 0x0010(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, ContainsInstancedReference, NativeAccessSpecifierPublic)
	bool                                          M_bMarkersOnDeadTargets;                           // 0x0020(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_21[0x7];                                       // 0x0021(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FBFGObjectiveMarkerInfo) == 0x000008, "Wrong alignment on FBFGObjectiveMarkerInfo");
static_assert(sizeof(FBFGObjectiveMarkerInfo) == 0x000028, "Wrong size on FBFGObjectiveMarkerInfo");
static_assert(offsetof(FBFGObjectiveMarkerInfo, M_bShowMarkers) == 0x000000, "Member 'FBFGObjectiveMarkerInfo::M_bShowMarkers' has a wrong offset!");
static_assert(offsetof(FBFGObjectiveMarkerInfo, M_pMarkers) == 0x000008, "Member 'FBFGObjectiveMarkerInfo::M_pMarkers' has a wrong offset!");
static_assert(offsetof(FBFGObjectiveMarkerInfo, M_aOverrides) == 0x000010, "Member 'FBFGObjectiveMarkerInfo::M_aOverrides' has a wrong offset!");
static_assert(offsetof(FBFGObjectiveMarkerInfo, M_bMarkersOnDeadTargets) == 0x000020, "Member 'FBFGObjectiveMarkerInfo::M_bMarkersOnDeadTargets' has a wrong offset!");

// ScriptStruct BFGCore.BFGQuest_ElementCollect_Item
// 0x0128 (0x0128 - 0x0000)
struct FBFGQuest_ElementCollect_Item final
{
public:
	struct FBFGActorBinding                       M_actorBinding;                                    // 0x0000(0x0090)(Edit, BlueprintVisible, BlueprintReadOnly, DisableEditOnInstance, NativeAccessSpecifierPublic)
	int32                                         M_iQuantity;                                       // 0x0090(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_94[0x4];                                       // 0x0094(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	struct FBFGQuest_UIProvider                   M_descriptionProvider;                             // 0x0098(0x0050)(Edit, BlueprintVisible, BlueprintReadOnly, DisableEditOnInstance, NativeAccessSpecifierPublic)
	struct FBFGObjectiveMarkerInfo                M_markerInfo;                                      // 0x00E8(0x0028)(Edit, BlueprintVisible, BlueprintReadOnly, DisableEditOnInstance, ContainsInstancedReference, NativeAccessSpecifierPublic)
	TArray<class UBFGEffectBank*>                 M_apEnableEffectBanks;                             // 0x0110(0x0010)(Edit, ZeroConstructor, DisableEditOnInstance, NativeAccessSpecifierPublic)
	EBFGEffect_Identifier                         M_activateEffect;                                  // 0x0120(0x0001)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_121[0x7];                                      // 0x0121(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FBFGQuest_ElementCollect_Item) == 0x000008, "Wrong alignment on FBFGQuest_ElementCollect_Item");
static_assert(sizeof(FBFGQuest_ElementCollect_Item) == 0x000128, "Wrong size on FBFGQuest_ElementCollect_Item");
static_assert(offsetof(FBFGQuest_ElementCollect_Item, M_actorBinding) == 0x000000, "Member 'FBFGQuest_ElementCollect_Item::M_actorBinding' has a wrong offset!");
static_assert(offsetof(FBFGQuest_ElementCollect_Item, M_iQuantity) == 0x000090, "Member 'FBFGQuest_ElementCollect_Item::M_iQuantity' has a wrong offset!");
static_assert(offsetof(FBFGQuest_ElementCollect_Item, M_descriptionProvider) == 0x000098, "Member 'FBFGQuest_ElementCollect_Item::M_descriptionProvider' has a wrong offset!");
static_assert(offsetof(FBFGQuest_ElementCollect_Item, M_markerInfo) == 0x0000E8, "Member 'FBFGQuest_ElementCollect_Item::M_markerInfo' has a wrong offset!");
static_assert(offsetof(FBFGQuest_ElementCollect_Item, M_apEnableEffectBanks) == 0x000110, "Member 'FBFGQuest_ElementCollect_Item::M_apEnableEffectBanks' has a wrong offset!");
static_assert(offsetof(FBFGQuest_ElementCollect_Item, M_activateEffect) == 0x000120, "Member 'FBFGQuest_ElementCollect_Item::M_activateEffect' has a wrong offset!");

// ScriptStruct BFGCore.BFGDataTableRowString
// 0x0018 (0x0020 - 0x0008)
struct FBFGDataTableRowString final : public FTableRowBase
{
public:
	class FText                                   M_strString;                                       // 0x0008(0x0018)(Edit, BlueprintVisible, BlueprintReadOnly, NativeAccessSpecifierPublic)
};
static_assert(alignof(FBFGDataTableRowString) == 0x000008, "Wrong alignment on FBFGDataTableRowString");
static_assert(sizeof(FBFGDataTableRowString) == 0x000020, "Wrong size on FBFGDataTableRowString");
static_assert(offsetof(FBFGDataTableRowString, M_strString) == 0x000008, "Member 'FBFGDataTableRowString::M_strString' has a wrong offset!");

// ScriptStruct BFGCore.BFGPlayerCharacterMovementSettings
// 0x001C (0x001C - 0x0000)
struct FBFGPlayerCharacterMovementSettings final
{
public:
	uint8                                         Pad_0[0x10];                                       // 0x0000(0x0010)(Fixing Size After Last Property [ Dumper-7 ])
	int32                                         M_iPriority;                                       // 0x0010(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          M_bUseDashRotationOverride;                        // 0x0014(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          M_bUseOrientToInput;                               // 0x0015(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          M_bUseOrientToMovement;                            // 0x0016(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_17[0x1];                                       // 0x0017(0x0001)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         M_fYawRotationRateOverride;                        // 0x0018(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FBFGPlayerCharacterMovementSettings) == 0x000004, "Wrong alignment on FBFGPlayerCharacterMovementSettings");
static_assert(sizeof(FBFGPlayerCharacterMovementSettings) == 0x00001C, "Wrong size on FBFGPlayerCharacterMovementSettings");
static_assert(offsetof(FBFGPlayerCharacterMovementSettings, M_iPriority) == 0x000010, "Member 'FBFGPlayerCharacterMovementSettings::M_iPriority' has a wrong offset!");
static_assert(offsetof(FBFGPlayerCharacterMovementSettings, M_bUseDashRotationOverride) == 0x000014, "Member 'FBFGPlayerCharacterMovementSettings::M_bUseDashRotationOverride' has a wrong offset!");
static_assert(offsetof(FBFGPlayerCharacterMovementSettings, M_bUseOrientToInput) == 0x000015, "Member 'FBFGPlayerCharacterMovementSettings::M_bUseOrientToInput' has a wrong offset!");
static_assert(offsetof(FBFGPlayerCharacterMovementSettings, M_bUseOrientToMovement) == 0x000016, "Member 'FBFGPlayerCharacterMovementSettings::M_bUseOrientToMovement' has a wrong offset!");
static_assert(offsetof(FBFGPlayerCharacterMovementSettings, M_fYawRotationRateOverride) == 0x000018, "Member 'FBFGPlayerCharacterMovementSettings::M_fYawRotationRateOverride' has a wrong offset!");

// ScriptStruct BFGCore.BFGPassengerSpotData
// 0x0058 (0x0058 - 0x0000)
struct FBFGPassengerSpotData final
{
public:
	EBFGVehiclePassenger_Spot                     M_spotType;                                        // 0x0000(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1[0x7];                                        // 0x0001(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	struct FGameplayTagQuery                      M_passengerTags;                                   // 0x0008(0x0048)(Edit, BlueprintVisible, BlueprintReadOnly, DisableEditOnInstance, NativeAccessSpecifierPublic)
	int32                                         M_count;                                           // 0x0050(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_54[0x4];                                       // 0x0054(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FBFGPassengerSpotData) == 0x000008, "Wrong alignment on FBFGPassengerSpotData");
static_assert(sizeof(FBFGPassengerSpotData) == 0x000058, "Wrong size on FBFGPassengerSpotData");
static_assert(offsetof(FBFGPassengerSpotData, M_spotType) == 0x000000, "Member 'FBFGPassengerSpotData::M_spotType' has a wrong offset!");
static_assert(offsetof(FBFGPassengerSpotData, M_passengerTags) == 0x000008, "Member 'FBFGPassengerSpotData::M_passengerTags' has a wrong offset!");
static_assert(offsetof(FBFGPassengerSpotData, M_count) == 0x000050, "Member 'FBFGPassengerSpotData::M_count' has a wrong offset!");

// ScriptStruct BFGCore.BFGPassengersData
// 0x0038 (0x0038 - 0x0000)
struct FBFGPassengersData final
{
public:
	TSoftObjectPtr<class UBFGSpawningComposition> M_spawningComposition;                             // 0x0000(0x0028)(Edit, BlueprintVisible, BlueprintReadOnly, DisableEditOnInstance, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TArray<struct FBFGPassengerSpotData>          M_aPassengers;                                     // 0x0028(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, NativeAccessSpecifierPublic)
};
static_assert(alignof(FBFGPassengersData) == 0x000008, "Wrong alignment on FBFGPassengersData");
static_assert(sizeof(FBFGPassengersData) == 0x000038, "Wrong size on FBFGPassengersData");
static_assert(offsetof(FBFGPassengersData, M_spawningComposition) == 0x000000, "Member 'FBFGPassengersData::M_spawningComposition' has a wrong offset!");
static_assert(offsetof(FBFGPassengersData, M_aPassengers) == 0x000028, "Member 'FBFGPassengersData::M_aPassengers' has a wrong offset!");

// ScriptStruct BFGCore.BFGPassengerCountForTagQuery
// 0x0050 (0x0050 - 0x0000)
struct FBFGPassengerCountForTagQuery final
{
public:
	struct FGameplayTagQuery                      M_tagQuery;                                        // 0x0000(0x0048)(Transient, NativeAccessSpecifierPublic)
	int32                                         M_iNumToSpawn;                                     // 0x0048(0x0004)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_4C[0x4];                                       // 0x004C(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FBFGPassengerCountForTagQuery) == 0x000008, "Wrong alignment on FBFGPassengerCountForTagQuery");
static_assert(sizeof(FBFGPassengerCountForTagQuery) == 0x000050, "Wrong size on FBFGPassengerCountForTagQuery");
static_assert(offsetof(FBFGPassengerCountForTagQuery, M_tagQuery) == 0x000000, "Member 'FBFGPassengerCountForTagQuery::M_tagQuery' has a wrong offset!");
static_assert(offsetof(FBFGPassengerCountForTagQuery, M_iNumToSpawn) == 0x000048, "Member 'FBFGPassengerCountForTagQuery::M_iNumToSpawn' has a wrong offset!");

// ScriptStruct BFGCore.BFGVehicleFleet_VehicleItemData
// 0x0050 (0x0050 - 0x0000)
struct FBFGVehicleFleet_VehicleItemData final
{
public:
	struct FBFGPassengersData                     M_passengersData;                                  // 0x0000(0x0038)(Transient, NativeAccessSpecifierPublic)
	TArray<struct FBFGPassengerCountForTagQuery>  M_aPassengersCountByQuery;                         // 0x0038(0x0010)(ZeroConstructor, Transient, NativeAccessSpecifierPublic)
	EBFGBehaviourState_NPC                        M_eBehaviourState;                                 // 0x0048(0x0001)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_49[0x7];                                       // 0x0049(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FBFGVehicleFleet_VehicleItemData) == 0x000008, "Wrong alignment on FBFGVehicleFleet_VehicleItemData");
static_assert(sizeof(FBFGVehicleFleet_VehicleItemData) == 0x000050, "Wrong size on FBFGVehicleFleet_VehicleItemData");
static_assert(offsetof(FBFGVehicleFleet_VehicleItemData, M_passengersData) == 0x000000, "Member 'FBFGVehicleFleet_VehicleItemData::M_passengersData' has a wrong offset!");
static_assert(offsetof(FBFGVehicleFleet_VehicleItemData, M_aPassengersCountByQuery) == 0x000038, "Member 'FBFGVehicleFleet_VehicleItemData::M_aPassengersCountByQuery' has a wrong offset!");
static_assert(offsetof(FBFGVehicleFleet_VehicleItemData, M_eBehaviourState) == 0x000048, "Member 'FBFGVehicleFleet_VehicleItemData::M_eBehaviourState' has a wrong offset!");

// ScriptStruct BFGCore.BFGSpawnRequestVehicleData
// 0x0058 (0x0058 - 0x0000)
struct FBFGSpawnRequestVehicleData final
{
public:
	struct FBFGVehicleFleet_VehicleItemData       M_vehicleData;                                     // 0x0000(0x0050)(Transient, NativeAccessSpecifierPublic)
	class UBFGNetworkPathAgent_Vehicle*           M_pAgent;                                          // 0x0050(0x0008)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FBFGSpawnRequestVehicleData) == 0x000008, "Wrong alignment on FBFGSpawnRequestVehicleData");
static_assert(sizeof(FBFGSpawnRequestVehicleData) == 0x000058, "Wrong size on FBFGSpawnRequestVehicleData");
static_assert(offsetof(FBFGSpawnRequestVehicleData, M_vehicleData) == 0x000000, "Member 'FBFGSpawnRequestVehicleData::M_vehicleData' has a wrong offset!");
static_assert(offsetof(FBFGSpawnRequestVehicleData, M_pAgent) == 0x000050, "Member 'FBFGSpawnRequestVehicleData::M_pAgent' has a wrong offset!");

// ScriptStruct BFGCore.AIAgressiveEvent
// 0x0030 (0x0030 - 0x0000)
struct FAIAgressiveEvent final
{
public:
	float                                         Age;                                               // 0x0000(0x0004)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                EventLocation;                                     // 0x0004(0x000C)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class AActor*                                 Instigator;                                        // 0x0010(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class AActor*                                 Victim;                                            // 0x0018(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   Tag;                                               // 0x0020(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FGenericTeamId                         TeamIdentifier;                                    // 0x0028(0x0001)(Transient, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_29[0x7];                                       // 0x0029(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FAIAgressiveEvent) == 0x000008, "Wrong alignment on FAIAgressiveEvent");
static_assert(sizeof(FAIAgressiveEvent) == 0x000030, "Wrong size on FAIAgressiveEvent");
static_assert(offsetof(FAIAgressiveEvent, Age) == 0x000000, "Member 'FAIAgressiveEvent::Age' has a wrong offset!");
static_assert(offsetof(FAIAgressiveEvent, EventLocation) == 0x000004, "Member 'FAIAgressiveEvent::EventLocation' has a wrong offset!");
static_assert(offsetof(FAIAgressiveEvent, Instigator) == 0x000010, "Member 'FAIAgressiveEvent::Instigator' has a wrong offset!");
static_assert(offsetof(FAIAgressiveEvent, Victim) == 0x000018, "Member 'FAIAgressiveEvent::Victim' has a wrong offset!");
static_assert(offsetof(FAIAgressiveEvent, Tag) == 0x000020, "Member 'FAIAgressiveEvent::Tag' has a wrong offset!");
static_assert(offsetof(FAIAgressiveEvent, TeamIdentifier) == 0x000028, "Member 'FAIAgressiveEvent::TeamIdentifier' has a wrong offset!");

// ScriptStruct BFGCore.BFGCrowdLifeStationAcquisitionSphere
// 0x0010 (0x0010 - 0x0000)
struct FBFGCrowdLifeStationAcquisitionSphere final
{
public:
	struct FVector                                Location;                                          // 0x0000(0x000C)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         Radius;                                            // 0x000C(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FBFGCrowdLifeStationAcquisitionSphere) == 0x000004, "Wrong alignment on FBFGCrowdLifeStationAcquisitionSphere");
static_assert(sizeof(FBFGCrowdLifeStationAcquisitionSphere) == 0x000010, "Wrong size on FBFGCrowdLifeStationAcquisitionSphere");
static_assert(offsetof(FBFGCrowdLifeStationAcquisitionSphere, Location) == 0x000000, "Member 'FBFGCrowdLifeStationAcquisitionSphere::Location' has a wrong offset!");
static_assert(offsetof(FBFGCrowdLifeStationAcquisitionSphere, Radius) == 0x00000C, "Member 'FBFGCrowdLifeStationAcquisitionSphere::Radius' has a wrong offset!");

// ScriptStruct BFGCore.BFGEventContext
// 0x0050 (0x0050 - 0x0000)
struct FBFGEventContext final
{
public:
	class UBFGEvent*                              M_pEvent;                                          // 0x0000(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UBFGEventTrigger*                       M_pTrigger;                                        // 0x0008(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TSoftObjectPtr<class AActor>                  M_softActor;                                       // 0x0010(0x0028)(BlueprintVisible, BlueprintReadOnly, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         M_fScoreValue;                                     // 0x0038(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EBFGEventContext_ScoreValueHint               M_eScoreValueHint;                                 // 0x003C(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_3D[0x13];                                      // 0x003D(0x0013)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FBFGEventContext) == 0x000008, "Wrong alignment on FBFGEventContext");
static_assert(sizeof(FBFGEventContext) == 0x000050, "Wrong size on FBFGEventContext");
static_assert(offsetof(FBFGEventContext, M_pEvent) == 0x000000, "Member 'FBFGEventContext::M_pEvent' has a wrong offset!");
static_assert(offsetof(FBFGEventContext, M_pTrigger) == 0x000008, "Member 'FBFGEventContext::M_pTrigger' has a wrong offset!");
static_assert(offsetof(FBFGEventContext, M_softActor) == 0x000010, "Member 'FBFGEventContext::M_softActor' has a wrong offset!");
static_assert(offsetof(FBFGEventContext, M_fScoreValue) == 0x000038, "Member 'FBFGEventContext::M_fScoreValue' has a wrong offset!");
static_assert(offsetof(FBFGEventContext, M_eScoreValueHint) == 0x00003C, "Member 'FBFGEventContext::M_eScoreValueHint' has a wrong offset!");

// ScriptStruct BFGCore.BFGUpgradeItem
// 0x0010 (0x0010 - 0x0000)
struct FBFGUpgradeItem final
{
public:
	int32                                         M_iUpgradeCosts;                                   // 0x0000(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_4[0x4];                                        // 0x0004(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class UBFGDataAssetPoxLabUpgrade*             M_pUpgradAssets;                                   // 0x0008(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FBFGUpgradeItem) == 0x000008, "Wrong alignment on FBFGUpgradeItem");
static_assert(sizeof(FBFGUpgradeItem) == 0x000010, "Wrong size on FBFGUpgradeItem");
static_assert(offsetof(FBFGUpgradeItem, M_iUpgradeCosts) == 0x000000, "Member 'FBFGUpgradeItem::M_iUpgradeCosts' has a wrong offset!");
static_assert(offsetof(FBFGUpgradeItem, M_pUpgradAssets) == 0x000008, "Member 'FBFGUpgradeItem::M_pUpgradAssets' has a wrong offset!");

// ScriptStruct BFGCore.BFGMissionSpawner_SpawnedParameters
// 0x0018 (0x0018 - 0x0000)
struct FBFGMissionSpawner_SpawnedParameters final
{
public:
	class ABFGMissionSpawnerGroup*                M_pGroup;                                          // 0x0000(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         M_iWaveIndex;                                      // 0x0008(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   M_strEnemyIdentifier;                              // 0x000C(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_14[0x4];                                       // 0x0014(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FBFGMissionSpawner_SpawnedParameters) == 0x000008, "Wrong alignment on FBFGMissionSpawner_SpawnedParameters");
static_assert(sizeof(FBFGMissionSpawner_SpawnedParameters) == 0x000018, "Wrong size on FBFGMissionSpawner_SpawnedParameters");
static_assert(offsetof(FBFGMissionSpawner_SpawnedParameters, M_pGroup) == 0x000000, "Member 'FBFGMissionSpawner_SpawnedParameters::M_pGroup' has a wrong offset!");
static_assert(offsetof(FBFGMissionSpawner_SpawnedParameters, M_iWaveIndex) == 0x000008, "Member 'FBFGMissionSpawner_SpawnedParameters::M_iWaveIndex' has a wrong offset!");
static_assert(offsetof(FBFGMissionSpawner_SpawnedParameters, M_strEnemyIdentifier) == 0x00000C, "Member 'FBFGMissionSpawner_SpawnedParameters::M_strEnemyIdentifier' has a wrong offset!");

// ScriptStruct BFGCore.BFGMissionSpawnRequest
// 0x0148 (0x0148 - 0x0000)
struct FBFGMissionSpawnRequest final
{
public:
	class UClass*                                 M_pClass;                                          // 0x0000(0x0008)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FGameplayTagContainer                  M_Tags;                                            // 0x0008(0x0020)(Transient, NativeAccessSpecifierPublic)
	struct FBFGAgentAIData                        M_agentAIData;                                     // 0x0028(0x00B0)(Transient, ContainsInstancedReference, NativeAccessSpecifierPublic)
	uint8                                         Pad_D8[0x8];                                       // 0x00D8(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	struct FBFGPassengersData                     M_passengersData;                                  // 0x00E0(0x0038)(Transient, NativeAccessSpecifierPublic)
	struct FBFGMissionSpawner_SpawnedParameters   M_spawnParams;                                     // 0x0118(0x0018)(NoDestructor, NativeAccessSpecifierPublic)
	uint8                                         Pad_130[0x18];                                     // 0x0130(0x0018)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FBFGMissionSpawnRequest) == 0x000008, "Wrong alignment on FBFGMissionSpawnRequest");
static_assert(sizeof(FBFGMissionSpawnRequest) == 0x000148, "Wrong size on FBFGMissionSpawnRequest");
static_assert(offsetof(FBFGMissionSpawnRequest, M_pClass) == 0x000000, "Member 'FBFGMissionSpawnRequest::M_pClass' has a wrong offset!");
static_assert(offsetof(FBFGMissionSpawnRequest, M_Tags) == 0x000008, "Member 'FBFGMissionSpawnRequest::M_Tags' has a wrong offset!");
static_assert(offsetof(FBFGMissionSpawnRequest, M_agentAIData) == 0x000028, "Member 'FBFGMissionSpawnRequest::M_agentAIData' has a wrong offset!");
static_assert(offsetof(FBFGMissionSpawnRequest, M_passengersData) == 0x0000E0, "Member 'FBFGMissionSpawnRequest::M_passengersData' has a wrong offset!");
static_assert(offsetof(FBFGMissionSpawnRequest, M_spawnParams) == 0x000118, "Member 'FBFGMissionSpawnRequest::M_spawnParams' has a wrong offset!");

// ScriptStruct BFGCore.BFGTargetTracker_CachedLocation
// 0x0068 (0x0068 - 0x0000)
struct FBFGTargetTracker_CachedLocation final
{
public:
	uint8                                         Pad_0[0x40];                                       // 0x0000(0x0040)(Fixing Size After Last Property [ Dumper-7 ])
	TScriptInterface<class IBFGAICombatParticipant> M_pClosestParticipant;                             // 0x0040(0x0010)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, UObjectWrapper, NativeAccessSpecifierPublic)
	TScriptInterface<class IBFGAICombatParticipant> M_pClosestFirelineParticipant;                     // 0x0050(0x0010)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, UObjectWrapper, NativeAccessSpecifierPublic)
	uint8                                         Pad_60[0x8];                                       // 0x0060(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FBFGTargetTracker_CachedLocation) == 0x000008, "Wrong alignment on FBFGTargetTracker_CachedLocation");
static_assert(sizeof(FBFGTargetTracker_CachedLocation) == 0x000068, "Wrong size on FBFGTargetTracker_CachedLocation");
static_assert(offsetof(FBFGTargetTracker_CachedLocation, M_pClosestParticipant) == 0x000040, "Member 'FBFGTargetTracker_CachedLocation::M_pClosestParticipant' has a wrong offset!");
static_assert(offsetof(FBFGTargetTracker_CachedLocation, M_pClosestFirelineParticipant) == 0x000050, "Member 'FBFGTargetTracker_CachedLocation::M_pClosestFirelineParticipant' has a wrong offset!");

// ScriptStruct BFGCore.BFGTargetTracker_CachedLocations
// 0x0010 (0x0010 - 0x0000)
struct FBFGTargetTracker_CachedLocations final
{
public:
	TArray<struct FBFGTargetTracker_CachedLocation> M_aLocations;                                      // 0x0000(0x0010)(ZeroConstructor, Transient, NativeAccessSpecifierPublic)
};
static_assert(alignof(FBFGTargetTracker_CachedLocations) == 0x000008, "Wrong alignment on FBFGTargetTracker_CachedLocations");
static_assert(sizeof(FBFGTargetTracker_CachedLocations) == 0x000010, "Wrong size on FBFGTargetTracker_CachedLocations");
static_assert(offsetof(FBFGTargetTracker_CachedLocations, M_aLocations) == 0x000000, "Member 'FBFGTargetTracker_CachedLocations::M_aLocations' has a wrong offset!");

// ScriptStruct BFGCore.BFGWaterPlaneInfo
// 0x000C (0x000C - 0x0000)
struct FBFGWaterPlaneInfo final
{
public:
	float                                         M_fWaterHeight;                                    // 0x0000(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         M_fWaterDepth;                                     // 0x0004(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          M_bIsInWater;                                      // 0x0008(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          M_bIsOcean;                                        // 0x0009(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_A[0x2];                                        // 0x000A(0x0002)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FBFGWaterPlaneInfo) == 0x000004, "Wrong alignment on FBFGWaterPlaneInfo");
static_assert(sizeof(FBFGWaterPlaneInfo) == 0x00000C, "Wrong size on FBFGWaterPlaneInfo");
static_assert(offsetof(FBFGWaterPlaneInfo, M_fWaterHeight) == 0x000000, "Member 'FBFGWaterPlaneInfo::M_fWaterHeight' has a wrong offset!");
static_assert(offsetof(FBFGWaterPlaneInfo, M_fWaterDepth) == 0x000004, "Member 'FBFGWaterPlaneInfo::M_fWaterDepth' has a wrong offset!");
static_assert(offsetof(FBFGWaterPlaneInfo, M_bIsInWater) == 0x000008, "Member 'FBFGWaterPlaneInfo::M_bIsInWater' has a wrong offset!");
static_assert(offsetof(FBFGWaterPlaneInfo, M_bIsOcean) == 0x000009, "Member 'FBFGWaterPlaneInfo::M_bIsOcean' has a wrong offset!");

// ScriptStruct BFGCore.GameplayEffectTagsTimer
// 0x0028 (0x0028 - 0x0000)
struct FGameplayEffectTagsTimer final
{
public:
	struct FGameplayTagContainer                  M_oTags;                                           // 0x0000(0x0020)(Edit, BlueprintVisible, BlueprintReadOnly, NativeAccessSpecifierPublic)
	float                                         M_fDuration;                                       // 0x0020(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         M_fTimeLeft;                                       // 0x0024(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FGameplayEffectTagsTimer) == 0x000008, "Wrong alignment on FGameplayEffectTagsTimer");
static_assert(sizeof(FGameplayEffectTagsTimer) == 0x000028, "Wrong size on FGameplayEffectTagsTimer");
static_assert(offsetof(FGameplayEffectTagsTimer, M_oTags) == 0x000000, "Member 'FGameplayEffectTagsTimer::M_oTags' has a wrong offset!");
static_assert(offsetof(FGameplayEffectTagsTimer, M_fDuration) == 0x000020, "Member 'FGameplayEffectTagsTimer::M_fDuration' has a wrong offset!");
static_assert(offsetof(FGameplayEffectTagsTimer, M_fTimeLeft) == 0x000024, "Member 'FGameplayEffectTagsTimer::M_fTimeLeft' has a wrong offset!");

// ScriptStruct BFGCore.BFGMenuGameOptionHandler
// 0x0030 (0x0030 - 0x0000)
struct alignas(0x08) FBFGMenuGameOptionHandler final
{
public:
	uint8                                         Pad_0[0x30];                                       // 0x0000(0x0030)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FBFGMenuGameOptionHandler) == 0x000008, "Wrong alignment on FBFGMenuGameOptionHandler");
static_assert(sizeof(FBFGMenuGameOptionHandler) == 0x000030, "Wrong size on FBFGMenuGameOptionHandler");

// ScriptStruct BFGCore.BFGEffectBankEntry_ForceFeedback
// 0x0018 (0x0018 - 0x0000)
struct FBFGEffectBankEntry_ForceFeedback final
{
public:
	class UForceFeedbackEffect*                   M_pFeedbackEffect;                                 // 0x0000(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          M_bIs2D;                                           // 0x0008(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          M_bLooping;                                        // 0x0009(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_A[0x6];                                        // 0x000A(0x0006)(Fixing Size After Last Property [ Dumper-7 ])
	class UForceFeedbackAttenuation*              M_pFeedbackAttenuation;                            // 0x0010(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FBFGEffectBankEntry_ForceFeedback) == 0x000008, "Wrong alignment on FBFGEffectBankEntry_ForceFeedback");
static_assert(sizeof(FBFGEffectBankEntry_ForceFeedback) == 0x000018, "Wrong size on FBFGEffectBankEntry_ForceFeedback");
static_assert(offsetof(FBFGEffectBankEntry_ForceFeedback, M_pFeedbackEffect) == 0x000000, "Member 'FBFGEffectBankEntry_ForceFeedback::M_pFeedbackEffect' has a wrong offset!");
static_assert(offsetof(FBFGEffectBankEntry_ForceFeedback, M_bIs2D) == 0x000008, "Member 'FBFGEffectBankEntry_ForceFeedback::M_bIs2D' has a wrong offset!");
static_assert(offsetof(FBFGEffectBankEntry_ForceFeedback, M_bLooping) == 0x000009, "Member 'FBFGEffectBankEntry_ForceFeedback::M_bLooping' has a wrong offset!");
static_assert(offsetof(FBFGEffectBankEntry_ForceFeedback, M_pFeedbackAttenuation) == 0x000010, "Member 'FBFGEffectBankEntry_ForceFeedback::M_pFeedbackAttenuation' has a wrong offset!");

// ScriptStruct BFGCore.BFGEffectBankEntry_CameraShake
// 0x0018 (0x0018 - 0x0000)
struct FBFGEffectBankEntry_CameraShake final
{
public:
	TSubclassOf<class UCameraShake>               M_pCameraShake;                                    // 0x0000(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         M_fInnerRadius;                                    // 0x0008(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         M_fOuterRadius;                                    // 0x000C(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         M_fFalloff;                                        // 0x0010(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          M_bOrientShakeTowardsEpicenter;                    // 0x0014(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_15[0x3];                                       // 0x0015(0x0003)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FBFGEffectBankEntry_CameraShake) == 0x000008, "Wrong alignment on FBFGEffectBankEntry_CameraShake");
static_assert(sizeof(FBFGEffectBankEntry_CameraShake) == 0x000018, "Wrong size on FBFGEffectBankEntry_CameraShake");
static_assert(offsetof(FBFGEffectBankEntry_CameraShake, M_pCameraShake) == 0x000000, "Member 'FBFGEffectBankEntry_CameraShake::M_pCameraShake' has a wrong offset!");
static_assert(offsetof(FBFGEffectBankEntry_CameraShake, M_fInnerRadius) == 0x000008, "Member 'FBFGEffectBankEntry_CameraShake::M_fInnerRadius' has a wrong offset!");
static_assert(offsetof(FBFGEffectBankEntry_CameraShake, M_fOuterRadius) == 0x00000C, "Member 'FBFGEffectBankEntry_CameraShake::M_fOuterRadius' has a wrong offset!");
static_assert(offsetof(FBFGEffectBankEntry_CameraShake, M_fFalloff) == 0x000010, "Member 'FBFGEffectBankEntry_CameraShake::M_fFalloff' has a wrong offset!");
static_assert(offsetof(FBFGEffectBankEntry_CameraShake, M_bOrientShakeTowardsEpicenter) == 0x000014, "Member 'FBFGEffectBankEntry_CameraShake::M_bOrientShakeTowardsEpicenter' has a wrong offset!");

// ScriptStruct BFGCore.BFGEffectBankEntry_SustainData
// 0x0048 (0x0048 - 0x0000)
struct FBFGEffectBankEntry_SustainData final
{
public:
	int32                                         M_iIterationLimit;                                 // 0x0000(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_4[0x4];                                        // 0x0004(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class UParticleSystem*                        M_pEffectTemplate;                                 // 0x0008(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class USoundCue*                              M_pAudioEffect;                                    // 0x0010(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FBFGEffectBankEntry_ForceFeedback      M_oForceFeedback;                                  // 0x0018(0x0018)(Edit, BlueprintVisible, BlueprintReadOnly, NoDestructor, NativeAccessSpecifierPublic)
	struct FBFGEffectBankEntry_CameraShake        M_oCameraShake;                                    // 0x0030(0x0018)(Edit, BlueprintVisible, BlueprintReadOnly, NoDestructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(FBFGEffectBankEntry_SustainData) == 0x000008, "Wrong alignment on FBFGEffectBankEntry_SustainData");
static_assert(sizeof(FBFGEffectBankEntry_SustainData) == 0x000048, "Wrong size on FBFGEffectBankEntry_SustainData");
static_assert(offsetof(FBFGEffectBankEntry_SustainData, M_iIterationLimit) == 0x000000, "Member 'FBFGEffectBankEntry_SustainData::M_iIterationLimit' has a wrong offset!");
static_assert(offsetof(FBFGEffectBankEntry_SustainData, M_pEffectTemplate) == 0x000008, "Member 'FBFGEffectBankEntry_SustainData::M_pEffectTemplate' has a wrong offset!");
static_assert(offsetof(FBFGEffectBankEntry_SustainData, M_pAudioEffect) == 0x000010, "Member 'FBFGEffectBankEntry_SustainData::M_pAudioEffect' has a wrong offset!");
static_assert(offsetof(FBFGEffectBankEntry_SustainData, M_oForceFeedback) == 0x000018, "Member 'FBFGEffectBankEntry_SustainData::M_oForceFeedback' has a wrong offset!");
static_assert(offsetof(FBFGEffectBankEntry_SustainData, M_oCameraShake) == 0x000030, "Member 'FBFGEffectBankEntry_SustainData::M_oCameraShake' has a wrong offset!");

// ScriptStruct BFGCore.BFGDamageHistoryEntry
// 0x0018 (0x0018 - 0x0000)
struct FBFGDamageHistoryEntry final
{
public:
	float                                         M_fTimestamp;                                      // 0x0000(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         M_fDamageAmount;                                   // 0x0004(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class AActor*                                 M_pDamageSource;                                   // 0x0008(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TSubclassOf<class UDamageType>                M_pDamageType;                                     // 0x0010(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FBFGDamageHistoryEntry) == 0x000008, "Wrong alignment on FBFGDamageHistoryEntry");
static_assert(sizeof(FBFGDamageHistoryEntry) == 0x000018, "Wrong size on FBFGDamageHistoryEntry");
static_assert(offsetof(FBFGDamageHistoryEntry, M_fTimestamp) == 0x000000, "Member 'FBFGDamageHistoryEntry::M_fTimestamp' has a wrong offset!");
static_assert(offsetof(FBFGDamageHistoryEntry, M_fDamageAmount) == 0x000004, "Member 'FBFGDamageHistoryEntry::M_fDamageAmount' has a wrong offset!");
static_assert(offsetof(FBFGDamageHistoryEntry, M_pDamageSource) == 0x000008, "Member 'FBFGDamageHistoryEntry::M_pDamageSource' has a wrong offset!");
static_assert(offsetof(FBFGDamageHistoryEntry, M_pDamageType) == 0x000010, "Member 'FBFGDamageHistoryEntry::M_pDamageType' has a wrong offset!");

// ScriptStruct BFGCore.BFGNarrativeSequence_AssessmentArg
// 0x0050 (0x0050 - 0x0000)
struct FBFGNarrativeSequence_AssessmentArg final
{
public:
	TMap<class FName, EUBFGNarrativeSequence_Assessment> M_aData;                                           // 0x0000(0x0050)(BlueprintVisible, ZeroConstructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(FBFGNarrativeSequence_AssessmentArg) == 0x000008, "Wrong alignment on FBFGNarrativeSequence_AssessmentArg");
static_assert(sizeof(FBFGNarrativeSequence_AssessmentArg) == 0x000050, "Wrong size on FBFGNarrativeSequence_AssessmentArg");
static_assert(offsetof(FBFGNarrativeSequence_AssessmentArg, M_aData) == 0x000000, "Member 'FBFGNarrativeSequence_AssessmentArg::M_aData' has a wrong offset!");

// ScriptStruct BFGCore.BFGAIEquipCommand
// 0x0038 (0x0038 - 0x0000)
struct FBFGAIEquipCommand final
{
public:
	TSoftClassPtr<class UClass>                   M_pWeaponClass;                                    // 0x0000(0x0028)(Transient, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          M_bEquipDefaultWeaponsInOrder;                     // 0x0028(0x0001)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          M_bSetEquipped;                                    // 0x0029(0x0001)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          M_bSetAiming;                                      // 0x002A(0x0001)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2B[0x5];                                       // 0x002B(0x0005)(Fixing Size After Last Property [ Dumper-7 ])
	class AActor*                                 M_pAimTarget;                                      // 0x0030(0x0008)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FBFGAIEquipCommand) == 0x000008, "Wrong alignment on FBFGAIEquipCommand");
static_assert(sizeof(FBFGAIEquipCommand) == 0x000038, "Wrong size on FBFGAIEquipCommand");
static_assert(offsetof(FBFGAIEquipCommand, M_pWeaponClass) == 0x000000, "Member 'FBFGAIEquipCommand::M_pWeaponClass' has a wrong offset!");
static_assert(offsetof(FBFGAIEquipCommand, M_bEquipDefaultWeaponsInOrder) == 0x000028, "Member 'FBFGAIEquipCommand::M_bEquipDefaultWeaponsInOrder' has a wrong offset!");
static_assert(offsetof(FBFGAIEquipCommand, M_bSetEquipped) == 0x000029, "Member 'FBFGAIEquipCommand::M_bSetEquipped' has a wrong offset!");
static_assert(offsetof(FBFGAIEquipCommand, M_bSetAiming) == 0x00002A, "Member 'FBFGAIEquipCommand::M_bSetAiming' has a wrong offset!");
static_assert(offsetof(FBFGAIEquipCommand, M_pAimTarget) == 0x000030, "Member 'FBFGAIEquipCommand::M_pAimTarget' has a wrong offset!");

// ScriptStruct BFGCore.BFGGameStatisticData
// 0x0020 (0x0020 - 0x0000)
struct FBFGGameStatisticData final
{
public:
	class FText                                   M_strDescription;                                  // 0x0000(0x0018)(Edit, BlueprintVisible, BlueprintReadOnly, NativeAccessSpecifierPublic)
	float                                         M_fValue;                                          // 0x0018(0x0004)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1C[0x4];                                       // 0x001C(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FBFGGameStatisticData) == 0x000008, "Wrong alignment on FBFGGameStatisticData");
static_assert(sizeof(FBFGGameStatisticData) == 0x000020, "Wrong size on FBFGGameStatisticData");
static_assert(offsetof(FBFGGameStatisticData, M_strDescription) == 0x000000, "Member 'FBFGGameStatisticData::M_strDescription' has a wrong offset!");
static_assert(offsetof(FBFGGameStatisticData, M_fValue) == 0x000018, "Member 'FBFGGameStatisticData::M_fValue' has a wrong offset!");

// ScriptStruct BFGCore.BFGUpgradeTableEntry
// 0x0048 (0x0050 - 0x0008)
struct FBFGUpgradeTableEntry final : public FTableRowBase
{
public:
	struct FGameplayTag                           M_oUpgradeTag;                                     // 0x0008(0x0008)(Edit, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FGameplayTagContainer                  M_oPrerequisiteTags;                               // 0x0010(0x0020)(Edit, NativeAccessSpecifierPublic)
	int32                                         M_iCost;                                           // 0x0030(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_34[0x4];                                       // 0x0034(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class UBFGDataAssetPoxLabUpgrade*             M_pDataAssets;                                     // 0x0038(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FGameplayTag                           M_oUnlockTag;                                      // 0x0040(0x0008)(Edit, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FGameplayTag                           M_oUpgradeShopTag;                                 // 0x0048(0x0008)(Edit, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FBFGUpgradeTableEntry) == 0x000008, "Wrong alignment on FBFGUpgradeTableEntry");
static_assert(sizeof(FBFGUpgradeTableEntry) == 0x000050, "Wrong size on FBFGUpgradeTableEntry");
static_assert(offsetof(FBFGUpgradeTableEntry, M_oUpgradeTag) == 0x000008, "Member 'FBFGUpgradeTableEntry::M_oUpgradeTag' has a wrong offset!");
static_assert(offsetof(FBFGUpgradeTableEntry, M_oPrerequisiteTags) == 0x000010, "Member 'FBFGUpgradeTableEntry::M_oPrerequisiteTags' has a wrong offset!");
static_assert(offsetof(FBFGUpgradeTableEntry, M_iCost) == 0x000030, "Member 'FBFGUpgradeTableEntry::M_iCost' has a wrong offset!");
static_assert(offsetof(FBFGUpgradeTableEntry, M_pDataAssets) == 0x000038, "Member 'FBFGUpgradeTableEntry::M_pDataAssets' has a wrong offset!");
static_assert(offsetof(FBFGUpgradeTableEntry, M_oUnlockTag) == 0x000040, "Member 'FBFGUpgradeTableEntry::M_oUnlockTag' has a wrong offset!");
static_assert(offsetof(FBFGUpgradeTableEntry, M_oUpgradeShopTag) == 0x000048, "Member 'FBFGUpgradeTableEntry::M_oUpgradeShopTag' has a wrong offset!");

// ScriptStruct BFGCore.BFGInputPatternElement
// 0x0048 (0x0048 - 0x0000)
struct FBFGInputPatternElement final
{
public:
	struct FKey                                   M_oKey;                                            // 0x0000(0x0018)(Edit, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FKey                                   M_oKeySecondary;                                   // 0x0018(0x0018)(Edit, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EBFGInputRebindIdentifier                     M_eRebindIdentifier;                               // 0x0030(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EBFGInputPatternElementState                  M_oState;                                          // 0x0031(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_32[0x2];                                       // 0x0032(0x0002)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         M_fMinTime;                                        // 0x0034(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         M_fMaxTime;                                        // 0x0038(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          M_bConsumeInput;                                   // 0x003C(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          M_bOnlyConsumeIfActive;                            // 0x003D(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          M_bConsumeWhileActionIsValid;                      // 0x003E(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          M_bFlushWhenActionValidates;                       // 0x003F(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          M_bFlushWhenActionCancels;                         // 0x0040(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_41[0x7];                                       // 0x0041(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FBFGInputPatternElement) == 0x000008, "Wrong alignment on FBFGInputPatternElement");
static_assert(sizeof(FBFGInputPatternElement) == 0x000048, "Wrong size on FBFGInputPatternElement");
static_assert(offsetof(FBFGInputPatternElement, M_oKey) == 0x000000, "Member 'FBFGInputPatternElement::M_oKey' has a wrong offset!");
static_assert(offsetof(FBFGInputPatternElement, M_oKeySecondary) == 0x000018, "Member 'FBFGInputPatternElement::M_oKeySecondary' has a wrong offset!");
static_assert(offsetof(FBFGInputPatternElement, M_eRebindIdentifier) == 0x000030, "Member 'FBFGInputPatternElement::M_eRebindIdentifier' has a wrong offset!");
static_assert(offsetof(FBFGInputPatternElement, M_oState) == 0x000031, "Member 'FBFGInputPatternElement::M_oState' has a wrong offset!");
static_assert(offsetof(FBFGInputPatternElement, M_fMinTime) == 0x000034, "Member 'FBFGInputPatternElement::M_fMinTime' has a wrong offset!");
static_assert(offsetof(FBFGInputPatternElement, M_fMaxTime) == 0x000038, "Member 'FBFGInputPatternElement::M_fMaxTime' has a wrong offset!");
static_assert(offsetof(FBFGInputPatternElement, M_bConsumeInput) == 0x00003C, "Member 'FBFGInputPatternElement::M_bConsumeInput' has a wrong offset!");
static_assert(offsetof(FBFGInputPatternElement, M_bOnlyConsumeIfActive) == 0x00003D, "Member 'FBFGInputPatternElement::M_bOnlyConsumeIfActive' has a wrong offset!");
static_assert(offsetof(FBFGInputPatternElement, M_bConsumeWhileActionIsValid) == 0x00003E, "Member 'FBFGInputPatternElement::M_bConsumeWhileActionIsValid' has a wrong offset!");
static_assert(offsetof(FBFGInputPatternElement, M_bFlushWhenActionValidates) == 0x00003F, "Member 'FBFGInputPatternElement::M_bFlushWhenActionValidates' has a wrong offset!");
static_assert(offsetof(FBFGInputPatternElement, M_bFlushWhenActionCancels) == 0x000040, "Member 'FBFGInputPatternElement::M_bFlushWhenActionCancels' has a wrong offset!");

// ScriptStruct BFGCore.BFGDialogNotificationINode
// 0x0028 (0x0028 - 0x0000)
struct alignas(0x08) FBFGDialogNotificationINode final
{
public:
	uint8                                         Pad_0[0x28];                                       // 0x0000(0x0028)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FBFGDialogNotificationINode) == 0x000008, "Wrong alignment on FBFGDialogNotificationINode");
static_assert(sizeof(FBFGDialogNotificationINode) == 0x000028, "Wrong size on FBFGDialogNotificationINode");

// ScriptStruct BFGCore.BFGQuest_UIData_Description
// 0x0088 (0x0088 - 0x0000)
struct alignas(0x08) FBFGQuest_UIData_Description final
{
public:
	uint8                                         Pad_0[0x88];                                       // 0x0000(0x0088)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FBFGQuest_UIData_Description) == 0x000008, "Wrong alignment on FBFGQuest_UIData_Description");
static_assert(sizeof(FBFGQuest_UIData_Description) == 0x000088, "Wrong size on FBFGQuest_UIData_Description");

// ScriptStruct BFGCore.BFGEquipableWeaponInfo
// 0x0030 (0x0030 - 0x0000)
struct FBFGEquipableWeaponInfo final
{
public:
	struct FSoftClassPath                         M_oWeaponClass;                                    // 0x0000(0x0018)(Edit, BlueprintVisible, ZeroConstructor, NativeAccessSpecifierPublic)
	class FName                                   M_oParentSocket;                                   // 0x0018(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class USceneComponent*                        M_pWeaponParentComponent;                          // 0x0020(0x0008)(Edit, BlueprintVisible, ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class ABFGWeapon*                             M_pWeaponInstance;                                 // 0x0028(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FBFGEquipableWeaponInfo) == 0x000008, "Wrong alignment on FBFGEquipableWeaponInfo");
static_assert(sizeof(FBFGEquipableWeaponInfo) == 0x000030, "Wrong size on FBFGEquipableWeaponInfo");
static_assert(offsetof(FBFGEquipableWeaponInfo, M_oWeaponClass) == 0x000000, "Member 'FBFGEquipableWeaponInfo::M_oWeaponClass' has a wrong offset!");
static_assert(offsetof(FBFGEquipableWeaponInfo, M_oParentSocket) == 0x000018, "Member 'FBFGEquipableWeaponInfo::M_oParentSocket' has a wrong offset!");
static_assert(offsetof(FBFGEquipableWeaponInfo, M_pWeaponParentComponent) == 0x000020, "Member 'FBFGEquipableWeaponInfo::M_pWeaponParentComponent' has a wrong offset!");
static_assert(offsetof(FBFGEquipableWeaponInfo, M_pWeaponInstance) == 0x000028, "Member 'FBFGEquipableWeaponInfo::M_pWeaponInstance' has a wrong offset!");

// ScriptStruct BFGCore.BFGOverheadWidgetTemplate
// 0x0028 (0x0028 - 0x0000)
struct FBFGOverheadWidgetTemplate final
{
public:
	class UTextureRenderTarget2D*                 M_pRenderTarget;                                   // 0x0000(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_8[0x20];                                       // 0x0008(0x0020)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FBFGOverheadWidgetTemplate) == 0x000008, "Wrong alignment on FBFGOverheadWidgetTemplate");
static_assert(sizeof(FBFGOverheadWidgetTemplate) == 0x000028, "Wrong size on FBFGOverheadWidgetTemplate");
static_assert(offsetof(FBFGOverheadWidgetTemplate, M_pRenderTarget) == 0x000000, "Member 'FBFGOverheadWidgetTemplate::M_pRenderTarget' has a wrong offset!");

// ScriptStruct BFGCore.BFGUserWidgetPool
// 0x0028 (0x0028 - 0x0000)
struct FBFGUserWidgetPool final
{
public:
	TArray<class UUserWidget*>                    M_apWidgetStack;                                   // 0x0000(0x0010)(ExportObject, ZeroConstructor, ContainsInstancedReference, NativeAccessSpecifierPublic)
	TArray<class UUserWidget*>                    M_apWidgetsUsed;                                   // 0x0010(0x0010)(ExportObject, ZeroConstructor, ContainsInstancedReference, NativeAccessSpecifierPublic)
	class UClass*                                 M_pWidgetClass;                                    // 0x0020(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FBFGUserWidgetPool) == 0x000008, "Wrong alignment on FBFGUserWidgetPool");
static_assert(sizeof(FBFGUserWidgetPool) == 0x000028, "Wrong size on FBFGUserWidgetPool");
static_assert(offsetof(FBFGUserWidgetPool, M_apWidgetStack) == 0x000000, "Member 'FBFGUserWidgetPool::M_apWidgetStack' has a wrong offset!");
static_assert(offsetof(FBFGUserWidgetPool, M_apWidgetsUsed) == 0x000010, "Member 'FBFGUserWidgetPool::M_apWidgetsUsed' has a wrong offset!");
static_assert(offsetof(FBFGUserWidgetPool, M_pWidgetClass) == 0x000020, "Member 'FBFGUserWidgetPool::M_pWidgetClass' has a wrong offset!");

// ScriptStruct BFGCore.BFGNotifications
// 0x0010 (0x0010 - 0x0000)
struct alignas(0x08) FBFGNotifications final
{
public:
	uint8                                         Pad_0[0x10];                                       // 0x0000(0x0010)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FBFGNotifications) == 0x000008, "Wrong alignment on FBFGNotifications");
static_assert(sizeof(FBFGNotifications) == 0x000010, "Wrong size on FBFGNotifications");

// ScriptStruct BFGCore.BFGPatrolPathInterestPoint
// 0x0070 (0x0070 - 0x0000)
struct FBFGPatrolPathInterestPoint final
{
public:
	struct FTransform                             M_Transform;                                       // 0x0000(0x0030)(Transient, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
	struct FVector                                M_vLocation;                                       // 0x0030(0x000C)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                M_vDirection;                                      // 0x003C(0x000C)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FBFGInteractAnimationSequence          M_animationSequence;                               // 0x0048(0x0018)(Edit, BlueprintVisible, NativeAccessSpecifierPublic)
	float                                         M_fProbability;                                    // 0x0060(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         M_fDuration;                                       // 0x0064(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_68[0x8];                                       // 0x0068(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FBFGPatrolPathInterestPoint) == 0x000010, "Wrong alignment on FBFGPatrolPathInterestPoint");
static_assert(sizeof(FBFGPatrolPathInterestPoint) == 0x000070, "Wrong size on FBFGPatrolPathInterestPoint");
static_assert(offsetof(FBFGPatrolPathInterestPoint, M_Transform) == 0x000000, "Member 'FBFGPatrolPathInterestPoint::M_Transform' has a wrong offset!");
static_assert(offsetof(FBFGPatrolPathInterestPoint, M_vLocation) == 0x000030, "Member 'FBFGPatrolPathInterestPoint::M_vLocation' has a wrong offset!");
static_assert(offsetof(FBFGPatrolPathInterestPoint, M_vDirection) == 0x00003C, "Member 'FBFGPatrolPathInterestPoint::M_vDirection' has a wrong offset!");
static_assert(offsetof(FBFGPatrolPathInterestPoint, M_animationSequence) == 0x000048, "Member 'FBFGPatrolPathInterestPoint::M_animationSequence' has a wrong offset!");
static_assert(offsetof(FBFGPatrolPathInterestPoint, M_fProbability) == 0x000060, "Member 'FBFGPatrolPathInterestPoint::M_fProbability' has a wrong offset!");
static_assert(offsetof(FBFGPatrolPathInterestPoint, M_fDuration) == 0x000064, "Member 'FBFGPatrolPathInterestPoint::M_fDuration' has a wrong offset!");

// ScriptStruct BFGCore.BFGEffectBlackboardParameterSlots_Color
// 0x0058 (0x0058 - 0x0000)
struct FBFGEffectBlackboardParameterSlots_Color final
{
public:
	struct FColor                                 M_oNoSlotValue;                                    // 0x0000(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_4[0x4];                                        // 0x0004(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	TMap<int32, struct FColor>                    M_aSlotValues;                                     // 0x0008(0x0050)(ZeroConstructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(FBFGEffectBlackboardParameterSlots_Color) == 0x000008, "Wrong alignment on FBFGEffectBlackboardParameterSlots_Color");
static_assert(sizeof(FBFGEffectBlackboardParameterSlots_Color) == 0x000058, "Wrong size on FBFGEffectBlackboardParameterSlots_Color");
static_assert(offsetof(FBFGEffectBlackboardParameterSlots_Color, M_oNoSlotValue) == 0x000000, "Member 'FBFGEffectBlackboardParameterSlots_Color::M_oNoSlotValue' has a wrong offset!");
static_assert(offsetof(FBFGEffectBlackboardParameterSlots_Color, M_aSlotValues) == 0x000008, "Member 'FBFGEffectBlackboardParameterSlots_Color::M_aSlotValues' has a wrong offset!");

// ScriptStruct BFGCore.BFGQuest_UIData_Main
// 0x0038 (0x0038 - 0x0000)
struct FBFGQuest_UIData_Main final
{
public:
	uint8                                         Pad_0[0x8];                                        // 0x0000(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	class FText                                   M_titleQuest;                                      // 0x0008(0x0018)(NativeAccessSpecifierPublic)
	uint8                                         Pad_20[0x8];                                       // 0x0020(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<struct FBFGQuest_UIData_Description>   M_aDescriptions;                                   // 0x0028(0x0010)(ZeroConstructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(FBFGQuest_UIData_Main) == 0x000008, "Wrong alignment on FBFGQuest_UIData_Main");
static_assert(sizeof(FBFGQuest_UIData_Main) == 0x000038, "Wrong size on FBFGQuest_UIData_Main");
static_assert(offsetof(FBFGQuest_UIData_Main, M_titleQuest) == 0x000008, "Member 'FBFGQuest_UIData_Main::M_titleQuest' has a wrong offset!");
static_assert(offsetof(FBFGQuest_UIData_Main, M_aDescriptions) == 0x000028, "Member 'FBFGQuest_UIData_Main::M_aDescriptions' has a wrong offset!");

// ScriptStruct BFGCore.BFGPolyLine2
// 0x0018 (0x0018 - 0x0000)
struct alignas(0x08) FBFGPolyLine2
{
public:
	uint8                                         Pad_0[0x18];                                       // 0x0000(0x0018)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FBFGPolyLine2) == 0x000008, "Wrong alignment on FBFGPolyLine2");
static_assert(sizeof(FBFGPolyLine2) == 0x000018, "Wrong size on FBFGPolyLine2");

// ScriptStruct BFGCore.BFGPolygon2
// 0x0010 (0x0028 - 0x0018)
struct FBFGPolygon2 final : public FBFGPolyLine2
{
public:
	uint8                                         Pad_18[0x10];                                      // 0x0018(0x0010)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FBFGPolygon2) == 0x000008, "Wrong alignment on FBFGPolygon2");
static_assert(sizeof(FBFGPolygon2) == 0x000028, "Wrong size on FBFGPolygon2");

// ScriptStruct BFGCore.BFGEffectBlackboardParameterSlots_DataTable
// 0x0058 (0x0058 - 0x0000)
struct FBFGEffectBlackboardParameterSlots_DataTable final
{
public:
	class UDataTable*                             M_pNoSlotValue;                                    // 0x0000(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TMap<int32, class UDataTable*>                M_apSlotValues;                                    // 0x0008(0x0050)(ZeroConstructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(FBFGEffectBlackboardParameterSlots_DataTable) == 0x000008, "Wrong alignment on FBFGEffectBlackboardParameterSlots_DataTable");
static_assert(sizeof(FBFGEffectBlackboardParameterSlots_DataTable) == 0x000058, "Wrong size on FBFGEffectBlackboardParameterSlots_DataTable");
static_assert(offsetof(FBFGEffectBlackboardParameterSlots_DataTable, M_pNoSlotValue) == 0x000000, "Member 'FBFGEffectBlackboardParameterSlots_DataTable::M_pNoSlotValue' has a wrong offset!");
static_assert(offsetof(FBFGEffectBlackboardParameterSlots_DataTable, M_apSlotValues) == 0x000008, "Member 'FBFGEffectBlackboardParameterSlots_DataTable::M_apSlotValues' has a wrong offset!");

// ScriptStruct BFGCore.BFGSystemData_QuestManager_CompletionRatingData
// 0x0058 (0x0058 - 0x0000)
struct FBFGSystemData_QuestManager_CompletionRatingData final
{
public:
	bool                                          M_bIsCompleted;                                    // 0x0000(0x0001)(ZeroConstructor, SaveGame, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          M_bIsFullyComplete;                                // 0x0001(0x0001)(ZeroConstructor, SaveGame, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2[0x6];                                        // 0x0002(0x0006)(Fixing Size After Last Property [ Dumper-7 ])
	TMap<class FName, bool>                       M_aObjectives;                                     // 0x0008(0x0050)(ZeroConstructor, SaveGame, NativeAccessSpecifierPublic)
};
static_assert(alignof(FBFGSystemData_QuestManager_CompletionRatingData) == 0x000008, "Wrong alignment on FBFGSystemData_QuestManager_CompletionRatingData");
static_assert(sizeof(FBFGSystemData_QuestManager_CompletionRatingData) == 0x000058, "Wrong size on FBFGSystemData_QuestManager_CompletionRatingData");
static_assert(offsetof(FBFGSystemData_QuestManager_CompletionRatingData, M_bIsCompleted) == 0x000000, "Member 'FBFGSystemData_QuestManager_CompletionRatingData::M_bIsCompleted' has a wrong offset!");
static_assert(offsetof(FBFGSystemData_QuestManager_CompletionRatingData, M_bIsFullyComplete) == 0x000001, "Member 'FBFGSystemData_QuestManager_CompletionRatingData::M_bIsFullyComplete' has a wrong offset!");
static_assert(offsetof(FBFGSystemData_QuestManager_CompletionRatingData, M_aObjectives) == 0x000008, "Member 'FBFGSystemData_QuestManager_CompletionRatingData::M_aObjectives' has a wrong offset!");

// ScriptStruct BFGCore.BFGQuestCompletionRating_ObjectiveData
// 0x0048 (0x0048 - 0x0000)
struct FBFGQuestCompletionRating_ObjectiveData final
{
public:
	uint8                                         Pad_0[0x28];                                       // 0x0000(0x0028)(Fixing Size After Last Property [ Dumper-7 ])
	struct FGameplayTagContainer                  M_rewardTags;                                      // 0x0028(0x0020)(NativeAccessSpecifierPublic)
};
static_assert(alignof(FBFGQuestCompletionRating_ObjectiveData) == 0x000008, "Wrong alignment on FBFGQuestCompletionRating_ObjectiveData");
static_assert(sizeof(FBFGQuestCompletionRating_ObjectiveData) == 0x000048, "Wrong size on FBFGQuestCompletionRating_ObjectiveData");
static_assert(offsetof(FBFGQuestCompletionRating_ObjectiveData, M_rewardTags) == 0x000028, "Member 'FBFGQuestCompletionRating_ObjectiveData::M_rewardTags' has a wrong offset!");

// ScriptStruct BFGCore.BFGSystemData_QuestManager_CompletionRating
// 0x00F8 (0x00F8 - 0x0000)
struct FBFGSystemData_QuestManager_CompletionRating final
{
public:
	struct FBFGSystemData_QuestManager_CompletionRatingData M_inProgressRating;                                // 0x0000(0x0058)(SaveGame, NativeAccessSpecifierPublic)
	struct FBFGSystemData_QuestManager_CompletionRatingData M_bestRating;                                      // 0x0058(0x0058)(SaveGame, NativeAccessSpecifierPublic)
	class UBFGQuest*                              M_pQuest;                                          // 0x00B0(0x0008)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TSubclassOf<class UBFGQuest>                  M_pQuestClass;                                     // 0x00B8(0x0008)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         M_fCompletionRatingBase;                           // 0x00C0(0x0004)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_C4[0x4];                                       // 0x00C4(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<struct FBFGQuestCompletionRating_ObjectiveData> M_aObjectiveData;                                  // 0x00C8(0x0010)(ZeroConstructor, Transient, NativeAccessSpecifierPublic)
	struct FGameplayTagContainer                  M_aJustGivenRewards;                               // 0x00D8(0x0020)(Transient, NativeAccessSpecifierPublic)
};
static_assert(alignof(FBFGSystemData_QuestManager_CompletionRating) == 0x000008, "Wrong alignment on FBFGSystemData_QuestManager_CompletionRating");
static_assert(sizeof(FBFGSystemData_QuestManager_CompletionRating) == 0x0000F8, "Wrong size on FBFGSystemData_QuestManager_CompletionRating");
static_assert(offsetof(FBFGSystemData_QuestManager_CompletionRating, M_inProgressRating) == 0x000000, "Member 'FBFGSystemData_QuestManager_CompletionRating::M_inProgressRating' has a wrong offset!");
static_assert(offsetof(FBFGSystemData_QuestManager_CompletionRating, M_bestRating) == 0x000058, "Member 'FBFGSystemData_QuestManager_CompletionRating::M_bestRating' has a wrong offset!");
static_assert(offsetof(FBFGSystemData_QuestManager_CompletionRating, M_pQuest) == 0x0000B0, "Member 'FBFGSystemData_QuestManager_CompletionRating::M_pQuest' has a wrong offset!");
static_assert(offsetof(FBFGSystemData_QuestManager_CompletionRating, M_pQuestClass) == 0x0000B8, "Member 'FBFGSystemData_QuestManager_CompletionRating::M_pQuestClass' has a wrong offset!");
static_assert(offsetof(FBFGSystemData_QuestManager_CompletionRating, M_fCompletionRatingBase) == 0x0000C0, "Member 'FBFGSystemData_QuestManager_CompletionRating::M_fCompletionRatingBase' has a wrong offset!");
static_assert(offsetof(FBFGSystemData_QuestManager_CompletionRating, M_aObjectiveData) == 0x0000C8, "Member 'FBFGSystemData_QuestManager_CompletionRating::M_aObjectiveData' has a wrong offset!");
static_assert(offsetof(FBFGSystemData_QuestManager_CompletionRating, M_aJustGivenRewards) == 0x0000D8, "Member 'FBFGSystemData_QuestManager_CompletionRating::M_aJustGivenRewards' has a wrong offset!");

// ScriptStruct BFGCore.BFGAlertTriggerDef
// 0x0020 (0x0020 - 0x0000)
struct FBFGAlertTriggerDef final
{
public:
	class FName                                   TriggerName;                                       // 0x0000(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         Value;                                             // 0x0008(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EBFGAlertTriggerMode                          TriggerMode;                                       // 0x000C(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_D[0x3];                                        // 0x000D(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         ResponseLevelCap;                                  // 0x0010(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          IsImmediate;                                       // 0x0014(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_15[0x3];                                       // 0x0015(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         CoolDown;                                          // 0x0018(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         MaxWitnesses;                                      // 0x001C(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FBFGAlertTriggerDef) == 0x000004, "Wrong alignment on FBFGAlertTriggerDef");
static_assert(sizeof(FBFGAlertTriggerDef) == 0x000020, "Wrong size on FBFGAlertTriggerDef");
static_assert(offsetof(FBFGAlertTriggerDef, TriggerName) == 0x000000, "Member 'FBFGAlertTriggerDef::TriggerName' has a wrong offset!");
static_assert(offsetof(FBFGAlertTriggerDef, Value) == 0x000008, "Member 'FBFGAlertTriggerDef::Value' has a wrong offset!");
static_assert(offsetof(FBFGAlertTriggerDef, TriggerMode) == 0x00000C, "Member 'FBFGAlertTriggerDef::TriggerMode' has a wrong offset!");
static_assert(offsetof(FBFGAlertTriggerDef, ResponseLevelCap) == 0x000010, "Member 'FBFGAlertTriggerDef::ResponseLevelCap' has a wrong offset!");
static_assert(offsetof(FBFGAlertTriggerDef, IsImmediate) == 0x000014, "Member 'FBFGAlertTriggerDef::IsImmediate' has a wrong offset!");
static_assert(offsetof(FBFGAlertTriggerDef, CoolDown) == 0x000018, "Member 'FBFGAlertTriggerDef::CoolDown' has a wrong offset!");
static_assert(offsetof(FBFGAlertTriggerDef, MaxWitnesses) == 0x00001C, "Member 'FBFGAlertTriggerDef::MaxWitnesses' has a wrong offset!");

// ScriptStruct BFGCore.BFGQueuedAlertEventInstance
// 0x0048 (0x0048 - 0x0000)
struct FBFGQueuedAlertEventInstance final
{
public:
	float                                         M_fTimestamp;                                      // 0x0000(0x0004)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FBFGAlertTriggerDef                    M_triggerDef;                                      // 0x0004(0x0020)(Transient, NoDestructor, NativeAccessSpecifierPublic)
	struct FVector                                M_vLastKnownPosition;                              // 0x0024(0x000C)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class AActor*                                 M_pWitness;                                        // 0x0030(0x0008)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class AActor*                                 M_pVictim;                                         // 0x0038(0x0008)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class ABFGPlayerBase*                         M_pAggressor;                                      // 0x0040(0x0008)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FBFGQueuedAlertEventInstance) == 0x000008, "Wrong alignment on FBFGQueuedAlertEventInstance");
static_assert(sizeof(FBFGQueuedAlertEventInstance) == 0x000048, "Wrong size on FBFGQueuedAlertEventInstance");
static_assert(offsetof(FBFGQueuedAlertEventInstance, M_fTimestamp) == 0x000000, "Member 'FBFGQueuedAlertEventInstance::M_fTimestamp' has a wrong offset!");
static_assert(offsetof(FBFGQueuedAlertEventInstance, M_triggerDef) == 0x000004, "Member 'FBFGQueuedAlertEventInstance::M_triggerDef' has a wrong offset!");
static_assert(offsetof(FBFGQueuedAlertEventInstance, M_vLastKnownPosition) == 0x000024, "Member 'FBFGQueuedAlertEventInstance::M_vLastKnownPosition' has a wrong offset!");
static_assert(offsetof(FBFGQueuedAlertEventInstance, M_pWitness) == 0x000030, "Member 'FBFGQueuedAlertEventInstance::M_pWitness' has a wrong offset!");
static_assert(offsetof(FBFGQueuedAlertEventInstance, M_pVictim) == 0x000038, "Member 'FBFGQueuedAlertEventInstance::M_pVictim' has a wrong offset!");
static_assert(offsetof(FBFGQueuedAlertEventInstance, M_pAggressor) == 0x000040, "Member 'FBFGQueuedAlertEventInstance::M_pAggressor' has a wrong offset!");

// ScriptStruct BFGCore.BFGBTVariant_StaticConditions
// 0x0048 (0x0048 - 0x0000)
struct FBFGBTVariant_StaticConditions final
{
public:
	struct FGameplayTagQuery                      M_gameplayTagQuery;                                // 0x0000(0x0048)(Edit, NativeAccessSpecifierPublic)
};
static_assert(alignof(FBFGBTVariant_StaticConditions) == 0x000008, "Wrong alignment on FBFGBTVariant_StaticConditions");
static_assert(sizeof(FBFGBTVariant_StaticConditions) == 0x000048, "Wrong size on FBFGBTVariant_StaticConditions");
static_assert(offsetof(FBFGBTVariant_StaticConditions, M_gameplayTagQuery) == 0x000000, "Member 'FBFGBTVariant_StaticConditions::M_gameplayTagQuery' has a wrong offset!");

// ScriptStruct BFGCore.BFG_AISettings_GlobalCooldown
// 0x0008 (0x0008 - 0x0000)
struct FBFG_AISettings_GlobalCooldown final
{
public:
	float                                         M_fMin;                                            // 0x0000(0x0004)(Edit, BlueprintVisible, ZeroConstructor, Config, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         M_fMax;                                            // 0x0004(0x0004)(Edit, BlueprintVisible, ZeroConstructor, Config, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FBFG_AISettings_GlobalCooldown) == 0x000004, "Wrong alignment on FBFG_AISettings_GlobalCooldown");
static_assert(sizeof(FBFG_AISettings_GlobalCooldown) == 0x000008, "Wrong size on FBFG_AISettings_GlobalCooldown");
static_assert(offsetof(FBFG_AISettings_GlobalCooldown, M_fMin) == 0x000000, "Member 'FBFG_AISettings_GlobalCooldown::M_fMin' has a wrong offset!");
static_assert(offsetof(FBFG_AISettings_GlobalCooldown, M_fMax) == 0x000004, "Member 'FBFG_AISettings_GlobalCooldown::M_fMax' has a wrong offset!");

// ScriptStruct BFGCore.BFGInputRebinding
// 0x0038 (0x0038 - 0x0000)
struct FBFGInputRebinding final
{
public:
	EBFGInputRebindIdentifier                     M_eIdentifier;                                     // 0x0000(0x0001)(Edit, ZeroConstructor, SaveGame, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EBFGInputRebindGroup                          M_eGroup;                                          // 0x0001(0x0001)(Edit, ZeroConstructor, SaveGame, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2[0x6];                                        // 0x0002(0x0006)(Fixing Size After Last Property [ Dumper-7 ])
	struct FKey                                   M_oKey1;                                           // 0x0008(0x0018)(Edit, SaveGame, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FKey                                   M_oKey2;                                           // 0x0020(0x0018)(Edit, SaveGame, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FBFGInputRebinding) == 0x000008, "Wrong alignment on FBFGInputRebinding");
static_assert(sizeof(FBFGInputRebinding) == 0x000038, "Wrong size on FBFGInputRebinding");
static_assert(offsetof(FBFGInputRebinding, M_eIdentifier) == 0x000000, "Member 'FBFGInputRebinding::M_eIdentifier' has a wrong offset!");
static_assert(offsetof(FBFGInputRebinding, M_eGroup) == 0x000001, "Member 'FBFGInputRebinding::M_eGroup' has a wrong offset!");
static_assert(offsetof(FBFGInputRebinding, M_oKey1) == 0x000008, "Member 'FBFGInputRebinding::M_oKey1' has a wrong offset!");
static_assert(offsetof(FBFGInputRebinding, M_oKey2) == 0x000020, "Member 'FBFGInputRebinding::M_oKey2' has a wrong offset!");

// ScriptStruct BFGCore.BFGMoveAlongCurve
// 0x0590 (0x0590 - 0x0000)
struct FBFGMoveAlongCurve final
{
public:
	bool                                          M_bIsActive;                                       // 0x0000(0x0001)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1[0x7];                                        // 0x0001(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	struct FTransformCurve                        M_curve;                                           // 0x0008(0x04E0)(Transient, NativeAccessSpecifierPublic)
	uint8                                         Pad_4E8[0x8];                                      // 0x04E8(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	struct FTransform                             M_initialTransform;                                // 0x04F0(0x0030)(Transient, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
	float                                         M_fTimeLength;                                     // 0x0520(0x0004)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         M_fCurrentTime;                                    // 0x0524(0x0004)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_528[0x8];                                      // 0x0528(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	struct FTransform                             M_relativeTransform;                               // 0x0530(0x0030)(Transient, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
	struct FTransform                             M_resultTransform;                                 // 0x0560(0x0030)(Transient, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(FBFGMoveAlongCurve) == 0x000010, "Wrong alignment on FBFGMoveAlongCurve");
static_assert(sizeof(FBFGMoveAlongCurve) == 0x000590, "Wrong size on FBFGMoveAlongCurve");
static_assert(offsetof(FBFGMoveAlongCurve, M_bIsActive) == 0x000000, "Member 'FBFGMoveAlongCurve::M_bIsActive' has a wrong offset!");
static_assert(offsetof(FBFGMoveAlongCurve, M_curve) == 0x000008, "Member 'FBFGMoveAlongCurve::M_curve' has a wrong offset!");
static_assert(offsetof(FBFGMoveAlongCurve, M_initialTransform) == 0x0004F0, "Member 'FBFGMoveAlongCurve::M_initialTransform' has a wrong offset!");
static_assert(offsetof(FBFGMoveAlongCurve, M_fTimeLength) == 0x000520, "Member 'FBFGMoveAlongCurve::M_fTimeLength' has a wrong offset!");
static_assert(offsetof(FBFGMoveAlongCurve, M_fCurrentTime) == 0x000524, "Member 'FBFGMoveAlongCurve::M_fCurrentTime' has a wrong offset!");
static_assert(offsetof(FBFGMoveAlongCurve, M_relativeTransform) == 0x000530, "Member 'FBFGMoveAlongCurve::M_relativeTransform' has a wrong offset!");
static_assert(offsetof(FBFGMoveAlongCurve, M_resultTransform) == 0x000560, "Member 'FBFGMoveAlongCurve::M_resultTransform' has a wrong offset!");

// ScriptStruct BFGCore.BFGActorData_ComponentData
// 0x0078 (0x0078 - 0x0000)
struct FBFGActorData_ComponentData final
{
public:
	TSoftClassPtr<class UClass>                   M_softComponentClass;                              // 0x0000(0x0028)(SaveGame, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TMap<class FName, float>                      M_aDataValues;                                     // 0x0028(0x0050)(ZeroConstructor, SaveGame, NativeAccessSpecifierPublic)
};
static_assert(alignof(FBFGActorData_ComponentData) == 0x000008, "Wrong alignment on FBFGActorData_ComponentData");
static_assert(sizeof(FBFGActorData_ComponentData) == 0x000078, "Wrong size on FBFGActorData_ComponentData");
static_assert(offsetof(FBFGActorData_ComponentData, M_softComponentClass) == 0x000000, "Member 'FBFGActorData_ComponentData::M_softComponentClass' has a wrong offset!");
static_assert(offsetof(FBFGActorData_ComponentData, M_aDataValues) == 0x000028, "Member 'FBFGActorData_ComponentData::M_aDataValues' has a wrong offset!");

// ScriptStruct BFGCore.BFGActorData_InstanceCustomData
// 0x0060 (0x0060 - 0x0000)
struct FBFGActorData_InstanceCustomData final
{
public:
	TMap<class FName, float>                      M_aActorDataValues;                                // 0x0000(0x0050)(ZeroConstructor, SaveGame, NativeAccessSpecifierPublic)
	TArray<struct FBFGActorData_ComponentData>    M_aComponentData;                                  // 0x0050(0x0010)(ZeroConstructor, SaveGame, NativeAccessSpecifierPublic)
};
static_assert(alignof(FBFGActorData_InstanceCustomData) == 0x000008, "Wrong alignment on FBFGActorData_InstanceCustomData");
static_assert(sizeof(FBFGActorData_InstanceCustomData) == 0x000060, "Wrong size on FBFGActorData_InstanceCustomData");
static_assert(offsetof(FBFGActorData_InstanceCustomData, M_aActorDataValues) == 0x000000, "Member 'FBFGActorData_InstanceCustomData::M_aActorDataValues' has a wrong offset!");
static_assert(offsetof(FBFGActorData_InstanceCustomData, M_aComponentData) == 0x000050, "Member 'FBFGActorData_InstanceCustomData::M_aComponentData' has a wrong offset!");

// ScriptStruct BFGCore.BFGPlayerData_Collectables_WorldEntry
// 0x0018 (0x0018 - 0x0000)
struct FBFGPlayerData_Collectables_WorldEntry final
{
public:
	class FName                                   M_strWorldIdentifier;                              // 0x0000(0x0008)(ZeroConstructor, SaveGame, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TArray<TSoftObjectPtr<class AActor>>          M_aCollected;                                      // 0x0008(0x0010)(ZeroConstructor, SaveGame, UObjectWrapper, NativeAccessSpecifierPublic)
};
static_assert(alignof(FBFGPlayerData_Collectables_WorldEntry) == 0x000008, "Wrong alignment on FBFGPlayerData_Collectables_WorldEntry");
static_assert(sizeof(FBFGPlayerData_Collectables_WorldEntry) == 0x000018, "Wrong size on FBFGPlayerData_Collectables_WorldEntry");
static_assert(offsetof(FBFGPlayerData_Collectables_WorldEntry, M_strWorldIdentifier) == 0x000000, "Member 'FBFGPlayerData_Collectables_WorldEntry::M_strWorldIdentifier' has a wrong offset!");
static_assert(offsetof(FBFGPlayerData_Collectables_WorldEntry, M_aCollected) == 0x000008, "Member 'FBFGPlayerData_Collectables_WorldEntry::M_aCollected' has a wrong offset!");

// ScriptStruct BFGCore.BFGGameFlowState_CutsceneParameters
// 0x0060 (0x0060 - 0x0000)
struct FBFGGameFlowState_CutsceneParameters final
{
public:
	bool                                          M_bShouldFadeOutToBlack;                           // 0x0000(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          M_bCleanupFadeStack;                               // 0x0001(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          M_bCancelVoiceOvers;                               // 0x0002(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_3[0x5];                                        // 0x0003(0x0005)(Fixing Size After Last Property [ Dumper-7 ])
	class FText                                   M_oVoiceover;                                      // 0x0008(0x0018)(Edit, BlueprintVisible, BlueprintReadOnly, NativeAccessSpecifierPublic)
	TArray<class FText>                           M_aAdditionalVoiceover;                            // 0x0020(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, NativeAccessSpecifierPublic)
	TSoftObjectPtr<class UBFGVoiceoverGroup>      M_pVoiceoverOverrideGroup;                         // 0x0030(0x0028)(Edit, BlueprintVisible, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          M_bHideCrypto;                                     // 0x0058(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          M_bHideUFO;                                        // 0x0059(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          M_bRefreshHolobob;                                 // 0x005A(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          M_bDropHolobob;                                    // 0x005B(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_5C[0x4];                                       // 0x005C(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FBFGGameFlowState_CutsceneParameters) == 0x000008, "Wrong alignment on FBFGGameFlowState_CutsceneParameters");
static_assert(sizeof(FBFGGameFlowState_CutsceneParameters) == 0x000060, "Wrong size on FBFGGameFlowState_CutsceneParameters");
static_assert(offsetof(FBFGGameFlowState_CutsceneParameters, M_bShouldFadeOutToBlack) == 0x000000, "Member 'FBFGGameFlowState_CutsceneParameters::M_bShouldFadeOutToBlack' has a wrong offset!");
static_assert(offsetof(FBFGGameFlowState_CutsceneParameters, M_bCleanupFadeStack) == 0x000001, "Member 'FBFGGameFlowState_CutsceneParameters::M_bCleanupFadeStack' has a wrong offset!");
static_assert(offsetof(FBFGGameFlowState_CutsceneParameters, M_bCancelVoiceOvers) == 0x000002, "Member 'FBFGGameFlowState_CutsceneParameters::M_bCancelVoiceOvers' has a wrong offset!");
static_assert(offsetof(FBFGGameFlowState_CutsceneParameters, M_oVoiceover) == 0x000008, "Member 'FBFGGameFlowState_CutsceneParameters::M_oVoiceover' has a wrong offset!");
static_assert(offsetof(FBFGGameFlowState_CutsceneParameters, M_aAdditionalVoiceover) == 0x000020, "Member 'FBFGGameFlowState_CutsceneParameters::M_aAdditionalVoiceover' has a wrong offset!");
static_assert(offsetof(FBFGGameFlowState_CutsceneParameters, M_pVoiceoverOverrideGroup) == 0x000030, "Member 'FBFGGameFlowState_CutsceneParameters::M_pVoiceoverOverrideGroup' has a wrong offset!");
static_assert(offsetof(FBFGGameFlowState_CutsceneParameters, M_bHideCrypto) == 0x000058, "Member 'FBFGGameFlowState_CutsceneParameters::M_bHideCrypto' has a wrong offset!");
static_assert(offsetof(FBFGGameFlowState_CutsceneParameters, M_bHideUFO) == 0x000059, "Member 'FBFGGameFlowState_CutsceneParameters::M_bHideUFO' has a wrong offset!");
static_assert(offsetof(FBFGGameFlowState_CutsceneParameters, M_bRefreshHolobob) == 0x00005A, "Member 'FBFGGameFlowState_CutsceneParameters::M_bRefreshHolobob' has a wrong offset!");
static_assert(offsetof(FBFGGameFlowState_CutsceneParameters, M_bDropHolobob) == 0x00005B, "Member 'FBFGGameFlowState_CutsceneParameters::M_bDropHolobob' has a wrong offset!");

// ScriptStruct BFGCore.BFGQuest_ElementDeliver_Objective
// 0x01E0 (0x01E0 - 0x0000)
struct FBFGQuest_ElementDeliver_Objective final
{
public:
	struct FBFGActorBinding                       M_targetBinding;                                   // 0x0000(0x0090)(Edit, DisableEditOnInstance, NativeAccessSpecifierPublic)
	struct FBFGActorBinding                       M_transporterBinding;                              // 0x0090(0x0090)(Edit, DisableEditOnInstance, NativeAccessSpecifierPublic)
	int32                                         M_iQuantity;                                       // 0x0120(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_124[0x4];                                      // 0x0124(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	struct FBFGQuest_UIProvider                   M_descriptionProvider;                             // 0x0128(0x0050)(Edit, DisableEditOnInstance, NativeAccessSpecifierPublic)
	struct FBFGObjectiveMarkerInfo                M_targetMarkerInfo;                                // 0x0178(0x0028)(Edit, DisableEditOnInstance, ContainsInstancedReference, NativeAccessSpecifierPublic)
	struct FBFGObjectiveMarkerInfo                M_transporterMarkerInfo;                           // 0x01A0(0x0028)(Edit, DisableEditOnInstance, ContainsInstancedReference, NativeAccessSpecifierPublic)
	TArray<class UBFGEffectBank*>                 M_apEnableEffectBanks;                             // 0x01C8(0x0010)(Edit, ZeroConstructor, DisableEditOnInstance, NativeAccessSpecifierPublic)
	EBFGEffect_Identifier                         M_activateEffect;                                  // 0x01D8(0x0001)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1D9[0x7];                                      // 0x01D9(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FBFGQuest_ElementDeliver_Objective) == 0x000008, "Wrong alignment on FBFGQuest_ElementDeliver_Objective");
static_assert(sizeof(FBFGQuest_ElementDeliver_Objective) == 0x0001E0, "Wrong size on FBFGQuest_ElementDeliver_Objective");
static_assert(offsetof(FBFGQuest_ElementDeliver_Objective, M_targetBinding) == 0x000000, "Member 'FBFGQuest_ElementDeliver_Objective::M_targetBinding' has a wrong offset!");
static_assert(offsetof(FBFGQuest_ElementDeliver_Objective, M_transporterBinding) == 0x000090, "Member 'FBFGQuest_ElementDeliver_Objective::M_transporterBinding' has a wrong offset!");
static_assert(offsetof(FBFGQuest_ElementDeliver_Objective, M_iQuantity) == 0x000120, "Member 'FBFGQuest_ElementDeliver_Objective::M_iQuantity' has a wrong offset!");
static_assert(offsetof(FBFGQuest_ElementDeliver_Objective, M_descriptionProvider) == 0x000128, "Member 'FBFGQuest_ElementDeliver_Objective::M_descriptionProvider' has a wrong offset!");
static_assert(offsetof(FBFGQuest_ElementDeliver_Objective, M_targetMarkerInfo) == 0x000178, "Member 'FBFGQuest_ElementDeliver_Objective::M_targetMarkerInfo' has a wrong offset!");
static_assert(offsetof(FBFGQuest_ElementDeliver_Objective, M_transporterMarkerInfo) == 0x0001A0, "Member 'FBFGQuest_ElementDeliver_Objective::M_transporterMarkerInfo' has a wrong offset!");
static_assert(offsetof(FBFGQuest_ElementDeliver_Objective, M_apEnableEffectBanks) == 0x0001C8, "Member 'FBFGQuest_ElementDeliver_Objective::M_apEnableEffectBanks' has a wrong offset!");
static_assert(offsetof(FBFGQuest_ElementDeliver_Objective, M_activateEffect) == 0x0001D8, "Member 'FBFGQuest_ElementDeliver_Objective::M_activateEffect' has a wrong offset!");

// ScriptStruct BFGCore.BFGVehicleSpeed_Settings
// 0x0008 (0x0008 - 0x0000)
struct FBFGVehicleSpeed_Settings final
{
public:
	float                                         M_fAverageTargetSpeed;                             // 0x0000(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         M_fAlertTargetSpeed;                               // 0x0004(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FBFGVehicleSpeed_Settings) == 0x000004, "Wrong alignment on FBFGVehicleSpeed_Settings");
static_assert(sizeof(FBFGVehicleSpeed_Settings) == 0x000008, "Wrong size on FBFGVehicleSpeed_Settings");
static_assert(offsetof(FBFGVehicleSpeed_Settings, M_fAverageTargetSpeed) == 0x000000, "Member 'FBFGVehicleSpeed_Settings::M_fAverageTargetSpeed' has a wrong offset!");
static_assert(offsetof(FBFGVehicleSpeed_Settings, M_fAlertTargetSpeed) == 0x000004, "Member 'FBFGVehicleSpeed_Settings::M_fAlertTargetSpeed' has a wrong offset!");

// ScriptStruct BFGCore.BFGTimeCurveTracker
// 0x0020 (0x0020 - 0x0000)
struct FBFGTimeCurveTracker final
{
public:
	uint8                                         Pad_0[0x8];                                        // 0x0000(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	class UCurveBase*                             M_pCurve;                                          // 0x0008(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_10[0x10];                                      // 0x0010(0x0010)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FBFGTimeCurveTracker) == 0x000008, "Wrong alignment on FBFGTimeCurveTracker");
static_assert(sizeof(FBFGTimeCurveTracker) == 0x000020, "Wrong size on FBFGTimeCurveTracker");
static_assert(offsetof(FBFGTimeCurveTracker, M_pCurve) == 0x000008, "Member 'FBFGTimeCurveTracker::M_pCurve' has a wrong offset!");

// ScriptStruct BFGCore.BFGCortexScanResponse
// 0x0038 (0x0038 - 0x0000)
struct FBFGCortexScanResponse final
{
public:
	uint8                                         Pad_0[0x10];                                       // 0x0000(0x0010)(Fixing Size After Last Property [ Dumper-7 ])
	class FText                                   M_strVOLine;                                       // 0x0010(0x0018)(BlueprintVisible, BlueprintReadOnly, NativeAccessSpecifierPublic)
	uint8                                         Pad_28[0x10];                                      // 0x0028(0x0010)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FBFGCortexScanResponse) == 0x000008, "Wrong alignment on FBFGCortexScanResponse");
static_assert(sizeof(FBFGCortexScanResponse) == 0x000038, "Wrong size on FBFGCortexScanResponse");
static_assert(offsetof(FBFGCortexScanResponse, M_strVOLine) == 0x000010, "Member 'FBFGCortexScanResponse::M_strVOLine' has a wrong offset!");

// ScriptStruct BFGCore.BFGFadeEditorInfo
// 0x000C (0x000C - 0x0000)
struct FBFGFadeEditorInfo final
{
public:
	float                                         M_fFadeTime;                                       // 0x0000(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   M_strIdentifier;                                   // 0x0004(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FBFGFadeEditorInfo) == 0x000004, "Wrong alignment on FBFGFadeEditorInfo");
static_assert(sizeof(FBFGFadeEditorInfo) == 0x00000C, "Wrong size on FBFGFadeEditorInfo");
static_assert(offsetof(FBFGFadeEditorInfo, M_fFadeTime) == 0x000000, "Member 'FBFGFadeEditorInfo::M_fFadeTime' has a wrong offset!");
static_assert(offsetof(FBFGFadeEditorInfo, M_strIdentifier) == 0x000004, "Member 'FBFGFadeEditorInfo::M_strIdentifier' has a wrong offset!");

// ScriptStruct BFGCore.BFGDataTableRow_LocalizedActionName
// 0x0018 (0x0020 - 0x0008)
struct FBFGDataTableRow_LocalizedActionName final : public FTableRowBase
{
public:
	class FText                                   M_strLocalizedActionName;                          // 0x0008(0x0018)(Edit, BlueprintVisible, BlueprintReadOnly, NativeAccessSpecifierPublic)
};
static_assert(alignof(FBFGDataTableRow_LocalizedActionName) == 0x000008, "Wrong alignment on FBFGDataTableRow_LocalizedActionName");
static_assert(sizeof(FBFGDataTableRow_LocalizedActionName) == 0x000020, "Wrong size on FBFGDataTableRow_LocalizedActionName");
static_assert(offsetof(FBFGDataTableRow_LocalizedActionName, M_strLocalizedActionName) == 0x000008, "Member 'FBFGDataTableRow_LocalizedActionName::M_strLocalizedActionName' has a wrong offset!");

// ScriptStruct BFGCore.BFGQuest_ElementScriptedSequence_Objective
// 0x00C0 (0x00C0 - 0x0000)
struct FBFGQuest_ElementScriptedSequence_Objective final
{
public:
	struct FGameplayTagQuery                      M_pawnGameplayTagQuery;                            // 0x0000(0x0048)(Edit, BlueprintVisible, BlueprintReadOnly, DisableEditOnInstance, NativeAccessSpecifierPublic)
	struct FBFGObjectiveMarkerInfo                M_markerInfo;                                      // 0x0048(0x0028)(Edit, BlueprintVisible, BlueprintReadOnly, DisableEditOnInstance, ContainsInstancedReference, NativeAccessSpecifierPublic)
	struct FBFGQuest_UIProvider                   M_descriptionProvider;                             // 0x0070(0x0050)(Edit, BlueprintVisible, BlueprintReadOnly, DisableEditOnInstance, NativeAccessSpecifierPublic)
};
static_assert(alignof(FBFGQuest_ElementScriptedSequence_Objective) == 0x000008, "Wrong alignment on FBFGQuest_ElementScriptedSequence_Objective");
static_assert(sizeof(FBFGQuest_ElementScriptedSequence_Objective) == 0x0000C0, "Wrong size on FBFGQuest_ElementScriptedSequence_Objective");
static_assert(offsetof(FBFGQuest_ElementScriptedSequence_Objective, M_pawnGameplayTagQuery) == 0x000000, "Member 'FBFGQuest_ElementScriptedSequence_Objective::M_pawnGameplayTagQuery' has a wrong offset!");
static_assert(offsetof(FBFGQuest_ElementScriptedSequence_Objective, M_markerInfo) == 0x000048, "Member 'FBFGQuest_ElementScriptedSequence_Objective::M_markerInfo' has a wrong offset!");
static_assert(offsetof(FBFGQuest_ElementScriptedSequence_Objective, M_descriptionProvider) == 0x000070, "Member 'FBFGQuest_ElementScriptedSequence_Objective::M_descriptionProvider' has a wrong offset!");

// ScriptStruct BFGCore.BFG_AITaskConfig
// 0x0030 (0x0030 - 0x0000)
struct FBFG_AITaskConfig final
{
public:
	TSoftObjectPtr<class UBehaviorTree>           M_spBehaviourTree;                                 // 0x0000(0x0028)(Edit, BlueprintVisible, BlueprintReadOnly, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FGameplayTag                           M_defaultBTTag;                                    // 0x0028(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FBFG_AITaskConfig) == 0x000008, "Wrong alignment on FBFG_AITaskConfig");
static_assert(sizeof(FBFG_AITaskConfig) == 0x000030, "Wrong size on FBFG_AITaskConfig");
static_assert(offsetof(FBFG_AITaskConfig, M_spBehaviourTree) == 0x000000, "Member 'FBFG_AITaskConfig::M_spBehaviourTree' has a wrong offset!");
static_assert(offsetof(FBFG_AITaskConfig, M_defaultBTTag) == 0x000028, "Member 'FBFG_AITaskConfig::M_defaultBTTag' has a wrong offset!");

// ScriptStruct BFGCore.BFGResponseLevelSpawnWave_SpawnAroundPlayer
// 0x000C (0x000C - 0x0000)
struct FBFGResponseLevelSpawnWave_SpawnAroundPlayer final
{
public:
	float                                         M_fMinRange;                                       // 0x0000(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         M_fMaxRange;                                       // 0x0004(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          M_bSpawnOutOfCamera;                               // 0x0008(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_9[0x3];                                        // 0x0009(0x0003)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FBFGResponseLevelSpawnWave_SpawnAroundPlayer) == 0x000004, "Wrong alignment on FBFGResponseLevelSpawnWave_SpawnAroundPlayer");
static_assert(sizeof(FBFGResponseLevelSpawnWave_SpawnAroundPlayer) == 0x00000C, "Wrong size on FBFGResponseLevelSpawnWave_SpawnAroundPlayer");
static_assert(offsetof(FBFGResponseLevelSpawnWave_SpawnAroundPlayer, M_fMinRange) == 0x000000, "Member 'FBFGResponseLevelSpawnWave_SpawnAroundPlayer::M_fMinRange' has a wrong offset!");
static_assert(offsetof(FBFGResponseLevelSpawnWave_SpawnAroundPlayer, M_fMaxRange) == 0x000004, "Member 'FBFGResponseLevelSpawnWave_SpawnAroundPlayer::M_fMaxRange' has a wrong offset!");
static_assert(offsetof(FBFGResponseLevelSpawnWave_SpawnAroundPlayer, M_bSpawnOutOfCamera) == 0x000008, "Member 'FBFGResponseLevelSpawnWave_SpawnAroundPlayer::M_bSpawnOutOfCamera' has a wrong offset!");

// ScriptStruct BFGCore.BFGAlertSpawnPositionRequest
// 0x00A0 (0x00A0 - 0x0000)
struct FBFGAlertSpawnPositionRequest final
{
public:
	struct FBFGResponseLevelSpawnWave_SpawnAroundPlayer M_info;                                            // 0x0000(0x000C)(NoDestructor, NativeAccessSpecifierPublic)
	struct FVector                                M_vPlayerLocation;                                 // 0x000C(0x000C)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                M_vPlayerVelocityNorm;                             // 0x0018(0x000C)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         M_queryRequestId;                                  // 0x0024(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FEQSParametrizedQueryExecutionRequest  M_request;                                         // 0x0028(0x0048)(NativeAccessSpecifierPublic)
	TArray<struct FVector>                        M_aLocations;                                      // 0x0070(0x0010)(ZeroConstructor, NativeAccessSpecifierPublic)
	int32                                         M_iLocationIndex;                                  // 0x0080(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         M_fTimeWhenAssignedVisibilityCheckers;             // 0x0084(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         M_iVisibilityCheckedIndex;                         // 0x0088(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_8C[0x4];                                       // 0x008C(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<class ABFGVisibilityChecker_Box*>      M_aVisibilityCheckers;                             // 0x0090(0x0010)(ZeroConstructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(FBFGAlertSpawnPositionRequest) == 0x000008, "Wrong alignment on FBFGAlertSpawnPositionRequest");
static_assert(sizeof(FBFGAlertSpawnPositionRequest) == 0x0000A0, "Wrong size on FBFGAlertSpawnPositionRequest");
static_assert(offsetof(FBFGAlertSpawnPositionRequest, M_info) == 0x000000, "Member 'FBFGAlertSpawnPositionRequest::M_info' has a wrong offset!");
static_assert(offsetof(FBFGAlertSpawnPositionRequest, M_vPlayerLocation) == 0x00000C, "Member 'FBFGAlertSpawnPositionRequest::M_vPlayerLocation' has a wrong offset!");
static_assert(offsetof(FBFGAlertSpawnPositionRequest, M_vPlayerVelocityNorm) == 0x000018, "Member 'FBFGAlertSpawnPositionRequest::M_vPlayerVelocityNorm' has a wrong offset!");
static_assert(offsetof(FBFGAlertSpawnPositionRequest, M_queryRequestId) == 0x000024, "Member 'FBFGAlertSpawnPositionRequest::M_queryRequestId' has a wrong offset!");
static_assert(offsetof(FBFGAlertSpawnPositionRequest, M_request) == 0x000028, "Member 'FBFGAlertSpawnPositionRequest::M_request' has a wrong offset!");
static_assert(offsetof(FBFGAlertSpawnPositionRequest, M_aLocations) == 0x000070, "Member 'FBFGAlertSpawnPositionRequest::M_aLocations' has a wrong offset!");
static_assert(offsetof(FBFGAlertSpawnPositionRequest, M_iLocationIndex) == 0x000080, "Member 'FBFGAlertSpawnPositionRequest::M_iLocationIndex' has a wrong offset!");
static_assert(offsetof(FBFGAlertSpawnPositionRequest, M_fTimeWhenAssignedVisibilityCheckers) == 0x000084, "Member 'FBFGAlertSpawnPositionRequest::M_fTimeWhenAssignedVisibilityCheckers' has a wrong offset!");
static_assert(offsetof(FBFGAlertSpawnPositionRequest, M_iVisibilityCheckedIndex) == 0x000088, "Member 'FBFGAlertSpawnPositionRequest::M_iVisibilityCheckedIndex' has a wrong offset!");
static_assert(offsetof(FBFGAlertSpawnPositionRequest, M_aVisibilityCheckers) == 0x000090, "Member 'FBFGAlertSpawnPositionRequest::M_aVisibilityCheckers' has a wrong offset!");

// ScriptStruct BFGCore.TimeDilationModifier
// 0x001C (0x001C - 0x0000)
struct FTimeDilationModifier final
{
public:
	struct FGuid                                  M_oGuid;                                           // 0x0000(0x0010)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         M_fModifier;                                       // 0x0010(0x0004)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         M_fDuration;                                       // 0x0014(0x0004)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_18[0x4];                                       // 0x0018(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FTimeDilationModifier) == 0x000004, "Wrong alignment on FTimeDilationModifier");
static_assert(sizeof(FTimeDilationModifier) == 0x00001C, "Wrong size on FTimeDilationModifier");
static_assert(offsetof(FTimeDilationModifier, M_oGuid) == 0x000000, "Member 'FTimeDilationModifier::M_oGuid' has a wrong offset!");
static_assert(offsetof(FTimeDilationModifier, M_fModifier) == 0x000010, "Member 'FTimeDilationModifier::M_fModifier' has a wrong offset!");
static_assert(offsetof(FTimeDilationModifier, M_fDuration) == 0x000014, "Member 'FTimeDilationModifier::M_fDuration' has a wrong offset!");

// ScriptStruct BFGCore.BFGAgentAttachedEntityDamage
// 0x0018 (0x0018 - 0x0000)
struct FBFGAgentAttachedEntityDamage final
{
public:
	float                                         M_fTimestamp;                                      // 0x0000(0x0004)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_4[0x4];                                        // 0x0004(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class AActor*                                 M_pDamageSource;                                   // 0x0008(0x0008)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TSubclassOf<class UDamageType>                M_pDamageType;                                     // 0x0010(0x0008)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FBFGAgentAttachedEntityDamage) == 0x000008, "Wrong alignment on FBFGAgentAttachedEntityDamage");
static_assert(sizeof(FBFGAgentAttachedEntityDamage) == 0x000018, "Wrong size on FBFGAgentAttachedEntityDamage");
static_assert(offsetof(FBFGAgentAttachedEntityDamage, M_fTimestamp) == 0x000000, "Member 'FBFGAgentAttachedEntityDamage::M_fTimestamp' has a wrong offset!");
static_assert(offsetof(FBFGAgentAttachedEntityDamage, M_pDamageSource) == 0x000008, "Member 'FBFGAgentAttachedEntityDamage::M_pDamageSource' has a wrong offset!");
static_assert(offsetof(FBFGAgentAttachedEntityDamage, M_pDamageType) == 0x000010, "Member 'FBFGAgentAttachedEntityDamage::M_pDamageType' has a wrong offset!");

// ScriptStruct BFGCore.BFGRadarManagerLayer
// 0x0018 (0x0018 - 0x0000)
struct FBFGRadarManagerLayer final
{
public:
	TArray<TScriptInterface<class IBFGRadarObjectInterface>> M_apObjects;                                       // 0x0000(0x0010)(ZeroConstructor, UObjectWrapper, NativeAccessSpecifierPublic)
	class UBFGDataAsset_RadarObjectStaticInfo*    M_pStaticInfo;                                     // 0x0010(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FBFGRadarManagerLayer) == 0x000008, "Wrong alignment on FBFGRadarManagerLayer");
static_assert(sizeof(FBFGRadarManagerLayer) == 0x000018, "Wrong size on FBFGRadarManagerLayer");
static_assert(offsetof(FBFGRadarManagerLayer, M_apObjects) == 0x000000, "Member 'FBFGRadarManagerLayer::M_apObjects' has a wrong offset!");
static_assert(offsetof(FBFGRadarManagerLayer, M_pStaticInfo) == 0x000010, "Member 'FBFGRadarManagerLayer::M_pStaticInfo' has a wrong offset!");

// ScriptStruct BFGCore.BFGQuest_ProximityMonitorSettings
// 0x0088 (0x0088 - 0x0000)
struct FBFGQuest_ProximityMonitorSettings final
{
public:
	class FName                                   M_strIdentifier;                                   // 0x0000(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EFBFGQuest_ProximityMonitorSettings_Goal      M_eGoal;                                           // 0x0008(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          M_bHasSourceActor;                                 // 0x0009(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_A[0x6];                                        // 0x000A(0x0006)(Fixing Size After Last Property [ Dumper-7 ])
	TSoftObjectPtr<class AActor>                  M_softSourceActor;                                 // 0x0010(0x0028)(Edit, BlueprintVisible, BlueprintReadOnly, DisableEditOnInstance, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TSoftObjectPtr<class AActor>                  M_softTargetActor;                                 // 0x0038(0x0028)(Edit, BlueprintVisible, BlueprintReadOnly, DisableEditOnInstance, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         M_fTargetDistance;                                 // 0x0060(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_64[0x4];                                       // 0x0064(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<int32>                                 M_aSubgoalLimits;                                  // 0x0068(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, NativeAccessSpecifierPublic)
	bool                                          M_bRepeatLastSubgoal;                              // 0x0078(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_79[0x3];                                       // 0x0079(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         M_fRepetitionDelay;                                // 0x007C(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_80[0x4];                                       // 0x0080(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	bool                                          M_bIgnoreHeight;                                   // 0x0084(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          M_bIsHudVisible;                                   // 0x0085(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          M_bUseWarningZone;                                 // 0x0086(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_87[0x1];                                       // 0x0087(0x0001)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FBFGQuest_ProximityMonitorSettings) == 0x000008, "Wrong alignment on FBFGQuest_ProximityMonitorSettings");
static_assert(sizeof(FBFGQuest_ProximityMonitorSettings) == 0x000088, "Wrong size on FBFGQuest_ProximityMonitorSettings");
static_assert(offsetof(FBFGQuest_ProximityMonitorSettings, M_strIdentifier) == 0x000000, "Member 'FBFGQuest_ProximityMonitorSettings::M_strIdentifier' has a wrong offset!");
static_assert(offsetof(FBFGQuest_ProximityMonitorSettings, M_eGoal) == 0x000008, "Member 'FBFGQuest_ProximityMonitorSettings::M_eGoal' has a wrong offset!");
static_assert(offsetof(FBFGQuest_ProximityMonitorSettings, M_bHasSourceActor) == 0x000009, "Member 'FBFGQuest_ProximityMonitorSettings::M_bHasSourceActor' has a wrong offset!");
static_assert(offsetof(FBFGQuest_ProximityMonitorSettings, M_softSourceActor) == 0x000010, "Member 'FBFGQuest_ProximityMonitorSettings::M_softSourceActor' has a wrong offset!");
static_assert(offsetof(FBFGQuest_ProximityMonitorSettings, M_softTargetActor) == 0x000038, "Member 'FBFGQuest_ProximityMonitorSettings::M_softTargetActor' has a wrong offset!");
static_assert(offsetof(FBFGQuest_ProximityMonitorSettings, M_fTargetDistance) == 0x000060, "Member 'FBFGQuest_ProximityMonitorSettings::M_fTargetDistance' has a wrong offset!");
static_assert(offsetof(FBFGQuest_ProximityMonitorSettings, M_aSubgoalLimits) == 0x000068, "Member 'FBFGQuest_ProximityMonitorSettings::M_aSubgoalLimits' has a wrong offset!");
static_assert(offsetof(FBFGQuest_ProximityMonitorSettings, M_bRepeatLastSubgoal) == 0x000078, "Member 'FBFGQuest_ProximityMonitorSettings::M_bRepeatLastSubgoal' has a wrong offset!");
static_assert(offsetof(FBFGQuest_ProximityMonitorSettings, M_fRepetitionDelay) == 0x00007C, "Member 'FBFGQuest_ProximityMonitorSettings::M_fRepetitionDelay' has a wrong offset!");
static_assert(offsetof(FBFGQuest_ProximityMonitorSettings, M_bIgnoreHeight) == 0x000084, "Member 'FBFGQuest_ProximityMonitorSettings::M_bIgnoreHeight' has a wrong offset!");
static_assert(offsetof(FBFGQuest_ProximityMonitorSettings, M_bIsHudVisible) == 0x000085, "Member 'FBFGQuest_ProximityMonitorSettings::M_bIsHudVisible' has a wrong offset!");
static_assert(offsetof(FBFGQuest_ProximityMonitorSettings, M_bUseWarningZone) == 0x000086, "Member 'FBFGQuest_ProximityMonitorSettings::M_bUseWarningZone' has a wrong offset!");

// ScriptStruct BFGCore.BossImmunities
// 0x0001 (0x0001 - 0x0000)
struct FBossImmunities final
{
public:
	bool                                          M_bPsykinesis;                                     // 0x0000(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FBossImmunities) == 0x000001, "Wrong alignment on FBossImmunities");
static_assert(sizeof(FBossImmunities) == 0x000001, "Wrong size on FBossImmunities");
static_assert(offsetof(FBossImmunities, M_bPsykinesis) == 0x000000, "Member 'FBossImmunities::M_bPsykinesis' has a wrong offset!");

// ScriptStruct BFGCore.BFGEffectBankEntry_ReleaseData
// 0x0040 (0x0040 - 0x0000)
struct FBFGEffectBankEntry_ReleaseData final
{
public:
	class UParticleSystem*                        M_pEffectTemplate;                                 // 0x0000(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class USoundCue*                              M_pAudioEffect;                                    // 0x0008(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FBFGEffectBankEntry_ForceFeedback      M_oForceFeedback;                                  // 0x0010(0x0018)(Edit, BlueprintVisible, BlueprintReadOnly, NoDestructor, NativeAccessSpecifierPublic)
	struct FBFGEffectBankEntry_CameraShake        M_oCameraShake;                                    // 0x0028(0x0018)(Edit, BlueprintVisible, BlueprintReadOnly, NoDestructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(FBFGEffectBankEntry_ReleaseData) == 0x000008, "Wrong alignment on FBFGEffectBankEntry_ReleaseData");
static_assert(sizeof(FBFGEffectBankEntry_ReleaseData) == 0x000040, "Wrong size on FBFGEffectBankEntry_ReleaseData");
static_assert(offsetof(FBFGEffectBankEntry_ReleaseData, M_pEffectTemplate) == 0x000000, "Member 'FBFGEffectBankEntry_ReleaseData::M_pEffectTemplate' has a wrong offset!");
static_assert(offsetof(FBFGEffectBankEntry_ReleaseData, M_pAudioEffect) == 0x000008, "Member 'FBFGEffectBankEntry_ReleaseData::M_pAudioEffect' has a wrong offset!");
static_assert(offsetof(FBFGEffectBankEntry_ReleaseData, M_oForceFeedback) == 0x000010, "Member 'FBFGEffectBankEntry_ReleaseData::M_oForceFeedback' has a wrong offset!");
static_assert(offsetof(FBFGEffectBankEntry_ReleaseData, M_oCameraShake) == 0x000028, "Member 'FBFGEffectBankEntry_ReleaseData::M_oCameraShake' has a wrong offset!");

// ScriptStruct BFGCore.BFGVehiclePassenger_AnimationSetup
// 0x0030 (0x0030 - 0x0000)
struct FBFGVehiclePassenger_AnimationSetup final
{
public:
	EBFGAnimation_Interact                        M_eDriverEnter;                                    // 0x0000(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EBFGAnimation_Interact                        M_eDriverEnterFast;                                // 0x0001(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EBFGAnimation_Interact                        M_eDriverLoop;                                     // 0x0002(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EBFGAnimation_Interact                        M_eDriverExit;                                     // 0x0003(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EBFGAnimation_Interact                        M_eDriverExitPanic;                                // 0x0004(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EBFGAnimation_Interact                        M_eDriverExitAggressive;                           // 0x0005(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EBFGAnimation_Interact                        M_ePassengerEnter;                                 // 0x0006(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EBFGAnimation_Interact                        M_ePassengerEnterFastRight;                        // 0x0007(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EBFGAnimation_Interact                        M_ePassengerLoop;                                  // 0x0008(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EBFGAnimation_Interact                        M_ePassengerExitRight;                             // 0x0009(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EBFGAnimation_Interact                        M_ePassengerExitPanicRight;                        // 0x000A(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EBFGAnimation_Interact                        M_ePassengerExitAggressiveRight;                   // 0x000B(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_C[0x4];                                        // 0x000C(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<EBFGAnimation_Interact>                M_panicLoopVariations;                             // 0x0010(0x0010)(Edit, BlueprintVisible, ZeroConstructor, NativeAccessSpecifierPublic)
	TArray<EBFGAnimation_Interact>                M_rearExitVariations;                              // 0x0020(0x0010)(Edit, BlueprintVisible, ZeroConstructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(FBFGVehiclePassenger_AnimationSetup) == 0x000008, "Wrong alignment on FBFGVehiclePassenger_AnimationSetup");
static_assert(sizeof(FBFGVehiclePassenger_AnimationSetup) == 0x000030, "Wrong size on FBFGVehiclePassenger_AnimationSetup");
static_assert(offsetof(FBFGVehiclePassenger_AnimationSetup, M_eDriverEnter) == 0x000000, "Member 'FBFGVehiclePassenger_AnimationSetup::M_eDriverEnter' has a wrong offset!");
static_assert(offsetof(FBFGVehiclePassenger_AnimationSetup, M_eDriverEnterFast) == 0x000001, "Member 'FBFGVehiclePassenger_AnimationSetup::M_eDriverEnterFast' has a wrong offset!");
static_assert(offsetof(FBFGVehiclePassenger_AnimationSetup, M_eDriverLoop) == 0x000002, "Member 'FBFGVehiclePassenger_AnimationSetup::M_eDriverLoop' has a wrong offset!");
static_assert(offsetof(FBFGVehiclePassenger_AnimationSetup, M_eDriverExit) == 0x000003, "Member 'FBFGVehiclePassenger_AnimationSetup::M_eDriverExit' has a wrong offset!");
static_assert(offsetof(FBFGVehiclePassenger_AnimationSetup, M_eDriverExitPanic) == 0x000004, "Member 'FBFGVehiclePassenger_AnimationSetup::M_eDriverExitPanic' has a wrong offset!");
static_assert(offsetof(FBFGVehiclePassenger_AnimationSetup, M_eDriverExitAggressive) == 0x000005, "Member 'FBFGVehiclePassenger_AnimationSetup::M_eDriverExitAggressive' has a wrong offset!");
static_assert(offsetof(FBFGVehiclePassenger_AnimationSetup, M_ePassengerEnter) == 0x000006, "Member 'FBFGVehiclePassenger_AnimationSetup::M_ePassengerEnter' has a wrong offset!");
static_assert(offsetof(FBFGVehiclePassenger_AnimationSetup, M_ePassengerEnterFastRight) == 0x000007, "Member 'FBFGVehiclePassenger_AnimationSetup::M_ePassengerEnterFastRight' has a wrong offset!");
static_assert(offsetof(FBFGVehiclePassenger_AnimationSetup, M_ePassengerLoop) == 0x000008, "Member 'FBFGVehiclePassenger_AnimationSetup::M_ePassengerLoop' has a wrong offset!");
static_assert(offsetof(FBFGVehiclePassenger_AnimationSetup, M_ePassengerExitRight) == 0x000009, "Member 'FBFGVehiclePassenger_AnimationSetup::M_ePassengerExitRight' has a wrong offset!");
static_assert(offsetof(FBFGVehiclePassenger_AnimationSetup, M_ePassengerExitPanicRight) == 0x00000A, "Member 'FBFGVehiclePassenger_AnimationSetup::M_ePassengerExitPanicRight' has a wrong offset!");
static_assert(offsetof(FBFGVehiclePassenger_AnimationSetup, M_ePassengerExitAggressiveRight) == 0x00000B, "Member 'FBFGVehiclePassenger_AnimationSetup::M_ePassengerExitAggressiveRight' has a wrong offset!");
static_assert(offsetof(FBFGVehiclePassenger_AnimationSetup, M_panicLoopVariations) == 0x000010, "Member 'FBFGVehiclePassenger_AnimationSetup::M_panicLoopVariations' has a wrong offset!");
static_assert(offsetof(FBFGVehiclePassenger_AnimationSetup, M_rearExitVariations) == 0x000020, "Member 'FBFGVehiclePassenger_AnimationSetup::M_rearExitVariations' has a wrong offset!");

// ScriptStruct BFGCore.BFGTreeMenuContext
// 0x0070 (0x0070 - 0x0000)
struct FBFGTreeMenuContext final
{
public:
	uint8                                         Pad_0[0x48];                                       // 0x0000(0x0048)(Fixing Size After Last Property [ Dumper-7 ])
	class FText                                   M_strMenuTopic;                                    // 0x0048(0x0018)(BlueprintVisible, BlueprintReadOnly, NativeAccessSpecifierPublic)
	class FName                                   M_oInternalName;                                   // 0x0060(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_68[0x8];                                       // 0x0068(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FBFGTreeMenuContext) == 0x000008, "Wrong alignment on FBFGTreeMenuContext");
static_assert(sizeof(FBFGTreeMenuContext) == 0x000070, "Wrong size on FBFGTreeMenuContext");
static_assert(offsetof(FBFGTreeMenuContext, M_strMenuTopic) == 0x000048, "Member 'FBFGTreeMenuContext::M_strMenuTopic' has a wrong offset!");
static_assert(offsetof(FBFGTreeMenuContext, M_oInternalName) == 0x000060, "Member 'FBFGTreeMenuContext::M_oInternalName' has a wrong offset!");

// ScriptStruct BFGCore.BFGBTVariant_DynamicConditions
// 0x0060 (0x0060 - 0x0000)
struct FBFGBTVariant_DynamicConditions final
{
public:
	int32                                         M_eTargetType;                                     // 0x0000(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_4[0x4];                                        // 0x0004(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<struct FBlackboardKeySelector>         M_aBBBooleanConditions;                            // 0x0008(0x0010)(Edit, ZeroConstructor, NativeAccessSpecifierPublic)
	float                                         M_fSimpleProbability;                              // 0x0018(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         M_fSimpleWeight;                                   // 0x001C(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         M_fProbabilityByRange_WeightUnderThreshold;        // 0x0020(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         M_fProbabilityByRange_WeightOverThreshold;         // 0x0024(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         M_fProbabilityByRange_Threshold;                   // 0x0028(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2C[0x4];                                       // 0x002C(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	TSoftClassPtr<class UClass>                   M_pThresholdFromWeaponMaximumRange;                // 0x0030(0x0028)(Edit, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         M_fProbabilityByRange_Divisor;                     // 0x0058(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_5C[0x4];                                       // 0x005C(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FBFGBTVariant_DynamicConditions) == 0x000008, "Wrong alignment on FBFGBTVariant_DynamicConditions");
static_assert(sizeof(FBFGBTVariant_DynamicConditions) == 0x000060, "Wrong size on FBFGBTVariant_DynamicConditions");
static_assert(offsetof(FBFGBTVariant_DynamicConditions, M_eTargetType) == 0x000000, "Member 'FBFGBTVariant_DynamicConditions::M_eTargetType' has a wrong offset!");
static_assert(offsetof(FBFGBTVariant_DynamicConditions, M_aBBBooleanConditions) == 0x000008, "Member 'FBFGBTVariant_DynamicConditions::M_aBBBooleanConditions' has a wrong offset!");
static_assert(offsetof(FBFGBTVariant_DynamicConditions, M_fSimpleProbability) == 0x000018, "Member 'FBFGBTVariant_DynamicConditions::M_fSimpleProbability' has a wrong offset!");
static_assert(offsetof(FBFGBTVariant_DynamicConditions, M_fSimpleWeight) == 0x00001C, "Member 'FBFGBTVariant_DynamicConditions::M_fSimpleWeight' has a wrong offset!");
static_assert(offsetof(FBFGBTVariant_DynamicConditions, M_fProbabilityByRange_WeightUnderThreshold) == 0x000020, "Member 'FBFGBTVariant_DynamicConditions::M_fProbabilityByRange_WeightUnderThreshold' has a wrong offset!");
static_assert(offsetof(FBFGBTVariant_DynamicConditions, M_fProbabilityByRange_WeightOverThreshold) == 0x000024, "Member 'FBFGBTVariant_DynamicConditions::M_fProbabilityByRange_WeightOverThreshold' has a wrong offset!");
static_assert(offsetof(FBFGBTVariant_DynamicConditions, M_fProbabilityByRange_Threshold) == 0x000028, "Member 'FBFGBTVariant_DynamicConditions::M_fProbabilityByRange_Threshold' has a wrong offset!");
static_assert(offsetof(FBFGBTVariant_DynamicConditions, M_pThresholdFromWeaponMaximumRange) == 0x000030, "Member 'FBFGBTVariant_DynamicConditions::M_pThresholdFromWeaponMaximumRange' has a wrong offset!");
static_assert(offsetof(FBFGBTVariant_DynamicConditions, M_fProbabilityByRange_Divisor) == 0x000058, "Member 'FBFGBTVariant_DynamicConditions::M_fProbabilityByRange_Divisor' has a wrong offset!");

// ScriptStruct BFGCore.BFGVoiceoverItem
// 0x00A8 (0x00A8 - 0x0000)
struct FBFGVoiceoverItem final
{
public:
	class FText                                   M_subtitleText;                                    // 0x0000(0x0018)(BlueprintVisible, NativeAccessSpecifierPublic)
	class FName                                   M_speakerVoice;                                    // 0x0018(0x0008)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FString                                 M_strSoundFilename;                                // 0x0020(0x0010)(BlueprintVisible, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   M_groupName;                                       // 0x0030(0x0008)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   M_stringTableFilename;                             // 0x0038(0x0008)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FString                                 M_strStringTableKey;                               // 0x0040(0x0010)(BlueprintVisible, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class AActor*                                 M_pSpeakerCharacter;                               // 0x0050(0x0008)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TSoftObjectPtr<class USoundBase>              M_pSoundWave;                                      // 0x0058(0x0028)(BlueprintVisible, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TSoftObjectPtr<class UBFGVoiceoverGroup>      M_pGroup;                                          // 0x0080(0x0028)(BlueprintVisible, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FBFGVoiceoverItem) == 0x000008, "Wrong alignment on FBFGVoiceoverItem");
static_assert(sizeof(FBFGVoiceoverItem) == 0x0000A8, "Wrong size on FBFGVoiceoverItem");
static_assert(offsetof(FBFGVoiceoverItem, M_subtitleText) == 0x000000, "Member 'FBFGVoiceoverItem::M_subtitleText' has a wrong offset!");
static_assert(offsetof(FBFGVoiceoverItem, M_speakerVoice) == 0x000018, "Member 'FBFGVoiceoverItem::M_speakerVoice' has a wrong offset!");
static_assert(offsetof(FBFGVoiceoverItem, M_strSoundFilename) == 0x000020, "Member 'FBFGVoiceoverItem::M_strSoundFilename' has a wrong offset!");
static_assert(offsetof(FBFGVoiceoverItem, M_groupName) == 0x000030, "Member 'FBFGVoiceoverItem::M_groupName' has a wrong offset!");
static_assert(offsetof(FBFGVoiceoverItem, M_stringTableFilename) == 0x000038, "Member 'FBFGVoiceoverItem::M_stringTableFilename' has a wrong offset!");
static_assert(offsetof(FBFGVoiceoverItem, M_strStringTableKey) == 0x000040, "Member 'FBFGVoiceoverItem::M_strStringTableKey' has a wrong offset!");
static_assert(offsetof(FBFGVoiceoverItem, M_pSpeakerCharacter) == 0x000050, "Member 'FBFGVoiceoverItem::M_pSpeakerCharacter' has a wrong offset!");
static_assert(offsetof(FBFGVoiceoverItem, M_pSoundWave) == 0x000058, "Member 'FBFGVoiceoverItem::M_pSoundWave' has a wrong offset!");
static_assert(offsetof(FBFGVoiceoverItem, M_pGroup) == 0x000080, "Member 'FBFGVoiceoverItem::M_pGroup' has a wrong offset!");

// ScriptStruct BFGCore.BFGVoiceoverPlaybackRequest
// 0x0130 (0x0130 - 0x0000)
struct FBFGVoiceoverPlaybackRequest final
{
public:
	struct FBFGVoiceoverItem                      M_itemToPlay;                                      // 0x0000(0x00A8)(NativeAccessSpecifierPublic)
	TSoftObjectPtr<class AActor>                  M_pOverrideSpeaker;                                // 0x00A8(0x0028)(Edit, BlueprintVisible, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         M_fDelayBefore;                                    // 0x00D0(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         M_fDelayAfter;                                     // 0x00D4(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TSoftObjectPtr<class UBFGVoiceoverGroup>      M_pOverrideGroup;                                  // 0x00D8(0x0028)(Edit, BlueprintVisible, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TSoftClassPtr<class UClass>                   M_pOverridePlaybackComponent;                      // 0x0100(0x0028)(Edit, BlueprintVisible, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class APlayerController*                      M_pLimitToPlayer;                                  // 0x0128(0x0008)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FBFGVoiceoverPlaybackRequest) == 0x000008, "Wrong alignment on FBFGVoiceoverPlaybackRequest");
static_assert(sizeof(FBFGVoiceoverPlaybackRequest) == 0x000130, "Wrong size on FBFGVoiceoverPlaybackRequest");
static_assert(offsetof(FBFGVoiceoverPlaybackRequest, M_itemToPlay) == 0x000000, "Member 'FBFGVoiceoverPlaybackRequest::M_itemToPlay' has a wrong offset!");
static_assert(offsetof(FBFGVoiceoverPlaybackRequest, M_pOverrideSpeaker) == 0x0000A8, "Member 'FBFGVoiceoverPlaybackRequest::M_pOverrideSpeaker' has a wrong offset!");
static_assert(offsetof(FBFGVoiceoverPlaybackRequest, M_fDelayBefore) == 0x0000D0, "Member 'FBFGVoiceoverPlaybackRequest::M_fDelayBefore' has a wrong offset!");
static_assert(offsetof(FBFGVoiceoverPlaybackRequest, M_fDelayAfter) == 0x0000D4, "Member 'FBFGVoiceoverPlaybackRequest::M_fDelayAfter' has a wrong offset!");
static_assert(offsetof(FBFGVoiceoverPlaybackRequest, M_pOverrideGroup) == 0x0000D8, "Member 'FBFGVoiceoverPlaybackRequest::M_pOverrideGroup' has a wrong offset!");
static_assert(offsetof(FBFGVoiceoverPlaybackRequest, M_pOverridePlaybackComponent) == 0x000100, "Member 'FBFGVoiceoverPlaybackRequest::M_pOverridePlaybackComponent' has a wrong offset!");
static_assert(offsetof(FBFGVoiceoverPlaybackRequest, M_pLimitToPlayer) == 0x000128, "Member 'FBFGVoiceoverPlaybackRequest::M_pLimitToPlayer' has a wrong offset!");

// ScriptStruct BFGCore.BFGQuestOverrides
// 0x0028 (0x0028 - 0x0000)
struct FBFGQuestOverrides final
{
public:
	uint8                                         Pad_0[0x10];                                       // 0x0000(0x0010)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<class UBFGCortexScanResponseSet*>      M_apOverride_CortexScan;                           // 0x0010(0x0010)(ZeroConstructor, NativeAccessSpecifierPublic)
	uint8                                         Pad_20[0x8];                                       // 0x0020(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FBFGQuestOverrides) == 0x000008, "Wrong alignment on FBFGQuestOverrides");
static_assert(sizeof(FBFGQuestOverrides) == 0x000028, "Wrong size on FBFGQuestOverrides");
static_assert(offsetof(FBFGQuestOverrides, M_apOverride_CortexScan) == 0x000010, "Member 'FBFGQuestOverrides::M_apOverride_CortexScan' has a wrong offset!");

// ScriptStruct BFGCore.BFGQuest_Objective
// 0x0068 (0x0068 - 0x0000)
struct FBFGQuest_Objective final
{
public:
	uint8                                         Pad_0[0x10];                                       // 0x0000(0x0010)(Fixing Size After Last Property [ Dumper-7 ])
	class UBFGVariable*                           M_pVariable;                                       // 0x0010(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TArray<class UBFGObjectiveMarkerGroup*>       M_apObjectiveGroup;                                // 0x0018(0x0010)(ZeroConstructor, NativeAccessSpecifierPublic)
	uint8                                         Pad_28[0x8];                                       // 0x0028(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	class UBFGEffectBank_DataProvider*            M_pEffectDataProvider;                             // 0x0030(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UBFGQuest_Trigger*                      M_pTrigger;                                        // 0x0038(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FBFGQuestOverrides                     M_runtimeOverrides;                                // 0x0040(0x0028)(NativeAccessSpecifierPublic)
};
static_assert(alignof(FBFGQuest_Objective) == 0x000008, "Wrong alignment on FBFGQuest_Objective");
static_assert(sizeof(FBFGQuest_Objective) == 0x000068, "Wrong size on FBFGQuest_Objective");
static_assert(offsetof(FBFGQuest_Objective, M_pVariable) == 0x000010, "Member 'FBFGQuest_Objective::M_pVariable' has a wrong offset!");
static_assert(offsetof(FBFGQuest_Objective, M_apObjectiveGroup) == 0x000018, "Member 'FBFGQuest_Objective::M_apObjectiveGroup' has a wrong offset!");
static_assert(offsetof(FBFGQuest_Objective, M_pEffectDataProvider) == 0x000030, "Member 'FBFGQuest_Objective::M_pEffectDataProvider' has a wrong offset!");
static_assert(offsetof(FBFGQuest_Objective, M_pTrigger) == 0x000038, "Member 'FBFGQuest_Objective::M_pTrigger' has a wrong offset!");
static_assert(offsetof(FBFGQuest_Objective, M_runtimeOverrides) == 0x000040, "Member 'FBFGQuest_Objective::M_runtimeOverrides' has a wrong offset!");

// ScriptStruct BFGCore.BFGQuest_Objectives
// 0x0040 (0x0040 - 0x0000)
struct FBFGQuest_Objectives final
{
public:
	uint8                                         Pad_0[0x18];                                       // 0x0000(0x0018)(Fixing Size After Last Property [ Dumper-7 ])
	class UBFGQuest*                              M_pQuest;                                          // 0x0018(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UBFGQuest_Element*                      M_pElement;                                        // 0x0020(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TArray<struct FBFGQuest_Objective>            M_aObjectives;                                     // 0x0028(0x0010)(ZeroConstructor, NativeAccessSpecifierPublic)
	class UBFGVariable*                           M_pSequentialObjective;                            // 0x0038(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FBFGQuest_Objectives) == 0x000008, "Wrong alignment on FBFGQuest_Objectives");
static_assert(sizeof(FBFGQuest_Objectives) == 0x000040, "Wrong size on FBFGQuest_Objectives");
static_assert(offsetof(FBFGQuest_Objectives, M_pQuest) == 0x000018, "Member 'FBFGQuest_Objectives::M_pQuest' has a wrong offset!");
static_assert(offsetof(FBFGQuest_Objectives, M_pElement) == 0x000020, "Member 'FBFGQuest_Objectives::M_pElement' has a wrong offset!");
static_assert(offsetof(FBFGQuest_Objectives, M_aObjectives) == 0x000028, "Member 'FBFGQuest_Objectives::M_aObjectives' has a wrong offset!");
static_assert(offsetof(FBFGQuest_Objectives, M_pSequentialObjective) == 0x000038, "Member 'FBFGQuest_Objectives::M_pSequentialObjective' has a wrong offset!");

// ScriptStruct BFGCore.BFGMissionSelectionInfo
// 0x0130 (0x0130 - 0x0000)
struct FBFGMissionSelectionInfo final
{
public:
	uint8                                         Pad_0[0x38];                                       // 0x0000(0x0038)(Fixing Size After Last Property [ Dumper-7 ])
	TSoftClassPtr<class UClass>                   M_softMissionClass;                                // 0x0038(0x0028)(UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FSlateBrush                            M_oMissionImage;                                   // 0x0060(0x0088)(NativeAccessSpecifierPublic)
	uint8                                         Pad_E8[0x48];                                      // 0x00E8(0x0048)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FBFGMissionSelectionInfo) == 0x000008, "Wrong alignment on FBFGMissionSelectionInfo");
static_assert(sizeof(FBFGMissionSelectionInfo) == 0x000130, "Wrong size on FBFGMissionSelectionInfo");
static_assert(offsetof(FBFGMissionSelectionInfo, M_softMissionClass) == 0x000038, "Member 'FBFGMissionSelectionInfo::M_softMissionClass' has a wrong offset!");
static_assert(offsetof(FBFGMissionSelectionInfo, M_oMissionImage) == 0x000060, "Member 'FBFGMissionSelectionInfo::M_oMissionImage' has a wrong offset!");

// ScriptStruct BFGCore.BFGWheeledVehicleWheelConfig
// 0x0018 (0x0018 - 0x0000)
struct FBFGWheeledVehicleWheelConfig final
{
public:
	class UStaticMesh*                            Mesh;                                              // 0x0000(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TArray<class FName>                           BoneNames;                                         // 0x0008(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(FBFGWheeledVehicleWheelConfig) == 0x000008, "Wrong alignment on FBFGWheeledVehicleWheelConfig");
static_assert(sizeof(FBFGWheeledVehicleWheelConfig) == 0x000018, "Wrong size on FBFGWheeledVehicleWheelConfig");
static_assert(offsetof(FBFGWheeledVehicleWheelConfig, Mesh) == 0x000000, "Member 'FBFGWheeledVehicleWheelConfig::Mesh' has a wrong offset!");
static_assert(offsetof(FBFGWheeledVehicleWheelConfig, BoneNames) == 0x000008, "Member 'FBFGWheeledVehicleWheelConfig::BoneNames' has a wrong offset!");

// ScriptStruct BFGCore.BFGVehiclePluginConfig
// 0x0040 (0x0040 - 0x0000)
struct FBFGVehiclePluginConfig final
{
public:
	class FName                                   AttachementBoneName;                               // 0x0000(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   ConstraintBoneName;                                // 0x0008(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          HighResOnly;                                       // 0x0010(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_11[0x7];                                       // 0x0011(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	class UStaticMesh*                            Mesh;                                              // 0x0018(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                RelativeLocation;                                  // 0x0020(0x000C)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FRotator                               RelativeRotation;                                  // 0x002C(0x000C)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
	EBFGVehiclePluginType                         M_ePluginType;                                     // 0x0038(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_39[0x7];                                       // 0x0039(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FBFGVehiclePluginConfig) == 0x000008, "Wrong alignment on FBFGVehiclePluginConfig");
static_assert(sizeof(FBFGVehiclePluginConfig) == 0x000040, "Wrong size on FBFGVehiclePluginConfig");
static_assert(offsetof(FBFGVehiclePluginConfig, AttachementBoneName) == 0x000000, "Member 'FBFGVehiclePluginConfig::AttachementBoneName' has a wrong offset!");
static_assert(offsetof(FBFGVehiclePluginConfig, ConstraintBoneName) == 0x000008, "Member 'FBFGVehiclePluginConfig::ConstraintBoneName' has a wrong offset!");
static_assert(offsetof(FBFGVehiclePluginConfig, HighResOnly) == 0x000010, "Member 'FBFGVehiclePluginConfig::HighResOnly' has a wrong offset!");
static_assert(offsetof(FBFGVehiclePluginConfig, Mesh) == 0x000018, "Member 'FBFGVehiclePluginConfig::Mesh' has a wrong offset!");
static_assert(offsetof(FBFGVehiclePluginConfig, RelativeLocation) == 0x000020, "Member 'FBFGVehiclePluginConfig::RelativeLocation' has a wrong offset!");
static_assert(offsetof(FBFGVehiclePluginConfig, RelativeRotation) == 0x00002C, "Member 'FBFGVehiclePluginConfig::RelativeRotation' has a wrong offset!");
static_assert(offsetof(FBFGVehiclePluginConfig, M_ePluginType) == 0x000038, "Member 'FBFGVehiclePluginConfig::M_ePluginType' has a wrong offset!");

// ScriptStruct BFGCore.BFGVehicleColorPalette
// 0x0040 (0x0040 - 0x0000)
struct FBFGVehicleColorPalette final
{
public:
	struct FLinearColor                           OverlayColorRed;                                   // 0x0000(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FLinearColor                           OverlayColorGreen;                                 // 0x0010(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FLinearColor                           OverlayColorBlue;                                  // 0x0020(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FLinearColor                           OverlayColorAlpha;                                 // 0x0030(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FBFGVehicleColorPalette) == 0x000004, "Wrong alignment on FBFGVehicleColorPalette");
static_assert(sizeof(FBFGVehicleColorPalette) == 0x000040, "Wrong size on FBFGVehicleColorPalette");
static_assert(offsetof(FBFGVehicleColorPalette, OverlayColorRed) == 0x000000, "Member 'FBFGVehicleColorPalette::OverlayColorRed' has a wrong offset!");
static_assert(offsetof(FBFGVehicleColorPalette, OverlayColorGreen) == 0x000010, "Member 'FBFGVehicleColorPalette::OverlayColorGreen' has a wrong offset!");
static_assert(offsetof(FBFGVehicleColorPalette, OverlayColorBlue) == 0x000020, "Member 'FBFGVehicleColorPalette::OverlayColorBlue' has a wrong offset!");
static_assert(offsetof(FBFGVehicleColorPalette, OverlayColorAlpha) == 0x000030, "Member 'FBFGVehicleColorPalette::OverlayColorAlpha' has a wrong offset!");

// ScriptStruct BFGCore.BFGVehicleColorConfig
// 0x0068 (0x0068 - 0x0000)
struct FBFGVehicleColorConfig final
{
public:
	bool                                          bEnableColorRed;                                   // 0x0000(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1[0x3];                                        // 0x0001(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	struct FLinearColor                           OverlayColorRed;                                   // 0x0004(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bEnableColorGreen;                                 // 0x0014(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_15[0x3];                                       // 0x0015(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	struct FLinearColor                           OverlayColorGreen;                                 // 0x0018(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bEnableColorBlue;                                  // 0x0028(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_29[0x3];                                       // 0x0029(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	struct FLinearColor                           OverlayColorBlue;                                  // 0x002C(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bEnableColorAlpha;                                 // 0x003C(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_3D[0x3];                                       // 0x003D(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	struct FLinearColor                           OverlayColorAlpha;                                 // 0x0040(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TArray<struct FBFGVehicleColorPalette>        Palettes;                                          // 0x0050(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, NativeAccessSpecifierPublic)
	int32                                         M_iSelectedPaletteIndex;                           // 0x0060(0x0004)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_64[0x4];                                       // 0x0064(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FBFGVehicleColorConfig) == 0x000008, "Wrong alignment on FBFGVehicleColorConfig");
static_assert(sizeof(FBFGVehicleColorConfig) == 0x000068, "Wrong size on FBFGVehicleColorConfig");
static_assert(offsetof(FBFGVehicleColorConfig, bEnableColorRed) == 0x000000, "Member 'FBFGVehicleColorConfig::bEnableColorRed' has a wrong offset!");
static_assert(offsetof(FBFGVehicleColorConfig, OverlayColorRed) == 0x000004, "Member 'FBFGVehicleColorConfig::OverlayColorRed' has a wrong offset!");
static_assert(offsetof(FBFGVehicleColorConfig, bEnableColorGreen) == 0x000014, "Member 'FBFGVehicleColorConfig::bEnableColorGreen' has a wrong offset!");
static_assert(offsetof(FBFGVehicleColorConfig, OverlayColorGreen) == 0x000018, "Member 'FBFGVehicleColorConfig::OverlayColorGreen' has a wrong offset!");
static_assert(offsetof(FBFGVehicleColorConfig, bEnableColorBlue) == 0x000028, "Member 'FBFGVehicleColorConfig::bEnableColorBlue' has a wrong offset!");
static_assert(offsetof(FBFGVehicleColorConfig, OverlayColorBlue) == 0x00002C, "Member 'FBFGVehicleColorConfig::OverlayColorBlue' has a wrong offset!");
static_assert(offsetof(FBFGVehicleColorConfig, bEnableColorAlpha) == 0x00003C, "Member 'FBFGVehicleColorConfig::bEnableColorAlpha' has a wrong offset!");
static_assert(offsetof(FBFGVehicleColorConfig, OverlayColorAlpha) == 0x000040, "Member 'FBFGVehicleColorConfig::OverlayColorAlpha' has a wrong offset!");
static_assert(offsetof(FBFGVehicleColorConfig, Palettes) == 0x000050, "Member 'FBFGVehicleColorConfig::Palettes' has a wrong offset!");
static_assert(offsetof(FBFGVehicleColorConfig, M_iSelectedPaletteIndex) == 0x000060, "Member 'FBFGVehicleColorConfig::M_iSelectedPaletteIndex' has a wrong offset!");

// ScriptStruct BFGCore.BFGWheeledVehicleDrivingConfig
// 0x0038 (0x0038 - 0x0000)
struct FBFGWheeledVehicleDrivingConfig final
{
public:
	float                                         IdleThrottleAccelerationFactor;                    // 0x0000(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         AccelerationToBrakeFactor;                         // 0x0004(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         LowDecelerationThreshold;                          // 0x0008(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         ThrottleFuncScale;                                 // 0x000C(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         ThrottleFuncXOffset;                               // 0x0010(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         ThrottleFuncYOffset;                               // 0x0014(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         ThrottleDeltaForDeltaSpeedFactor;                  // 0x0018(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         ThrottleDeltaForPitchFuncFactor;                   // 0x001C(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         ThrottleDeltaForPitchFuncYOffset;                  // 0x0020(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         DefaultForwardThrottle;                            // 0x0024(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         DefaultReverseThrottle;                            // 0x0028(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          UseshandBreak;                                     // 0x002C(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2D[0x3];                                       // 0x002D(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         StuckMinSpeedThreshold;                            // 0x0030(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         StuckThrottleThreshold;                            // 0x0034(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FBFGWheeledVehicleDrivingConfig) == 0x000004, "Wrong alignment on FBFGWheeledVehicleDrivingConfig");
static_assert(sizeof(FBFGWheeledVehicleDrivingConfig) == 0x000038, "Wrong size on FBFGWheeledVehicleDrivingConfig");
static_assert(offsetof(FBFGWheeledVehicleDrivingConfig, IdleThrottleAccelerationFactor) == 0x000000, "Member 'FBFGWheeledVehicleDrivingConfig::IdleThrottleAccelerationFactor' has a wrong offset!");
static_assert(offsetof(FBFGWheeledVehicleDrivingConfig, AccelerationToBrakeFactor) == 0x000004, "Member 'FBFGWheeledVehicleDrivingConfig::AccelerationToBrakeFactor' has a wrong offset!");
static_assert(offsetof(FBFGWheeledVehicleDrivingConfig, LowDecelerationThreshold) == 0x000008, "Member 'FBFGWheeledVehicleDrivingConfig::LowDecelerationThreshold' has a wrong offset!");
static_assert(offsetof(FBFGWheeledVehicleDrivingConfig, ThrottleFuncScale) == 0x00000C, "Member 'FBFGWheeledVehicleDrivingConfig::ThrottleFuncScale' has a wrong offset!");
static_assert(offsetof(FBFGWheeledVehicleDrivingConfig, ThrottleFuncXOffset) == 0x000010, "Member 'FBFGWheeledVehicleDrivingConfig::ThrottleFuncXOffset' has a wrong offset!");
static_assert(offsetof(FBFGWheeledVehicleDrivingConfig, ThrottleFuncYOffset) == 0x000014, "Member 'FBFGWheeledVehicleDrivingConfig::ThrottleFuncYOffset' has a wrong offset!");
static_assert(offsetof(FBFGWheeledVehicleDrivingConfig, ThrottleDeltaForDeltaSpeedFactor) == 0x000018, "Member 'FBFGWheeledVehicleDrivingConfig::ThrottleDeltaForDeltaSpeedFactor' has a wrong offset!");
static_assert(offsetof(FBFGWheeledVehicleDrivingConfig, ThrottleDeltaForPitchFuncFactor) == 0x00001C, "Member 'FBFGWheeledVehicleDrivingConfig::ThrottleDeltaForPitchFuncFactor' has a wrong offset!");
static_assert(offsetof(FBFGWheeledVehicleDrivingConfig, ThrottleDeltaForPitchFuncYOffset) == 0x000020, "Member 'FBFGWheeledVehicleDrivingConfig::ThrottleDeltaForPitchFuncYOffset' has a wrong offset!");
static_assert(offsetof(FBFGWheeledVehicleDrivingConfig, DefaultForwardThrottle) == 0x000024, "Member 'FBFGWheeledVehicleDrivingConfig::DefaultForwardThrottle' has a wrong offset!");
static_assert(offsetof(FBFGWheeledVehicleDrivingConfig, DefaultReverseThrottle) == 0x000028, "Member 'FBFGWheeledVehicleDrivingConfig::DefaultReverseThrottle' has a wrong offset!");
static_assert(offsetof(FBFGWheeledVehicleDrivingConfig, UseshandBreak) == 0x00002C, "Member 'FBFGWheeledVehicleDrivingConfig::UseshandBreak' has a wrong offset!");
static_assert(offsetof(FBFGWheeledVehicleDrivingConfig, StuckMinSpeedThreshold) == 0x000030, "Member 'FBFGWheeledVehicleDrivingConfig::StuckMinSpeedThreshold' has a wrong offset!");
static_assert(offsetof(FBFGWheeledVehicleDrivingConfig, StuckThrottleThreshold) == 0x000034, "Member 'FBFGWheeledVehicleDrivingConfig::StuckThrottleThreshold' has a wrong offset!");

// ScriptStruct BFGCore.BFGWheeledVehicleWheelConfigDefinitionItem
// 0x0020 (0x0020 - 0x0000)
struct FBFGWheeledVehicleWheelConfigDefinitionItem final
{
public:
	class UStaticMesh*                            Mesh;                                              // 0x0000(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   BoneName;                                          // 0x0008(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   DetachedConstraintName;                            // 0x0010(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TSubclassOf<class UVehicleWheel>              WheelClass;                                        // 0x0018(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FBFGWheeledVehicleWheelConfigDefinitionItem) == 0x000008, "Wrong alignment on FBFGWheeledVehicleWheelConfigDefinitionItem");
static_assert(sizeof(FBFGWheeledVehicleWheelConfigDefinitionItem) == 0x000020, "Wrong size on FBFGWheeledVehicleWheelConfigDefinitionItem");
static_assert(offsetof(FBFGWheeledVehicleWheelConfigDefinitionItem, Mesh) == 0x000000, "Member 'FBFGWheeledVehicleWheelConfigDefinitionItem::Mesh' has a wrong offset!");
static_assert(offsetof(FBFGWheeledVehicleWheelConfigDefinitionItem, BoneName) == 0x000008, "Member 'FBFGWheeledVehicleWheelConfigDefinitionItem::BoneName' has a wrong offset!");
static_assert(offsetof(FBFGWheeledVehicleWheelConfigDefinitionItem, DetachedConstraintName) == 0x000010, "Member 'FBFGWheeledVehicleWheelConfigDefinitionItem::DetachedConstraintName' has a wrong offset!");
static_assert(offsetof(FBFGWheeledVehicleWheelConfigDefinitionItem, WheelClass) == 0x000018, "Member 'FBFGWheeledVehicleWheelConfigDefinitionItem::WheelClass' has a wrong offset!");

// ScriptStruct BFGCore.BFGWheeledVehicleWheelConfigDefinition
// 0x0018 (0x0018 - 0x0000)
struct FBFGWheeledVehicleWheelConfigDefinition final
{
public:
	class UStaticMesh*                            Mesh;                                              // 0x0000(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TArray<struct FBFGWheeledVehicleWheelConfigDefinitionItem> WheelDefintions;                                   // 0x0008(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(FBFGWheeledVehicleWheelConfigDefinition) == 0x000008, "Wrong alignment on FBFGWheeledVehicleWheelConfigDefinition");
static_assert(sizeof(FBFGWheeledVehicleWheelConfigDefinition) == 0x000018, "Wrong size on FBFGWheeledVehicleWheelConfigDefinition");
static_assert(offsetof(FBFGWheeledVehicleWheelConfigDefinition, Mesh) == 0x000000, "Member 'FBFGWheeledVehicleWheelConfigDefinition::Mesh' has a wrong offset!");
static_assert(offsetof(FBFGWheeledVehicleWheelConfigDefinition, WheelDefintions) == 0x000008, "Member 'FBFGWheeledVehicleWheelConfigDefinition::WheelDefintions' has a wrong offset!");

// ScriptStruct BFGCore.BFGVehicleDoorConfig
// 0x0040 (0x0040 - 0x0000)
struct FBFGVehicleDoorConfig final
{
public:
	class FName                                   AttachementBoneName;                               // 0x0000(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   ConstraintBoneName;                                // 0x0008(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bExists;                                           // 0x0010(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_11[0x7];                                       // 0x0011(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	class UStaticMesh*                            DoorMesh;                                          // 0x0018(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UStaticMesh*                            GlassMesh;                                         // 0x0020(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UDestructibleMesh*                      BorkenGlassMesh;                                   // 0x0028(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          Openable;                                          // 0x0030(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_31[0x3];                                       // 0x0031(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         OpenAngle;                                         // 0x0034(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EBFGDoorRotationAxis                          M_eRotationAxis;                                   // 0x0038(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_39[0x7];                                       // 0x0039(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FBFGVehicleDoorConfig) == 0x000008, "Wrong alignment on FBFGVehicleDoorConfig");
static_assert(sizeof(FBFGVehicleDoorConfig) == 0x000040, "Wrong size on FBFGVehicleDoorConfig");
static_assert(offsetof(FBFGVehicleDoorConfig, AttachementBoneName) == 0x000000, "Member 'FBFGVehicleDoorConfig::AttachementBoneName' has a wrong offset!");
static_assert(offsetof(FBFGVehicleDoorConfig, ConstraintBoneName) == 0x000008, "Member 'FBFGVehicleDoorConfig::ConstraintBoneName' has a wrong offset!");
static_assert(offsetof(FBFGVehicleDoorConfig, bExists) == 0x000010, "Member 'FBFGVehicleDoorConfig::bExists' has a wrong offset!");
static_assert(offsetof(FBFGVehicleDoorConfig, DoorMesh) == 0x000018, "Member 'FBFGVehicleDoorConfig::DoorMesh' has a wrong offset!");
static_assert(offsetof(FBFGVehicleDoorConfig, GlassMesh) == 0x000020, "Member 'FBFGVehicleDoorConfig::GlassMesh' has a wrong offset!");
static_assert(offsetof(FBFGVehicleDoorConfig, BorkenGlassMesh) == 0x000028, "Member 'FBFGVehicleDoorConfig::BorkenGlassMesh' has a wrong offset!");
static_assert(offsetof(FBFGVehicleDoorConfig, Openable) == 0x000030, "Member 'FBFGVehicleDoorConfig::Openable' has a wrong offset!");
static_assert(offsetof(FBFGVehicleDoorConfig, OpenAngle) == 0x000034, "Member 'FBFGVehicleDoorConfig::OpenAngle' has a wrong offset!");
static_assert(offsetof(FBFGVehicleDoorConfig, M_eRotationAxis) == 0x000038, "Member 'FBFGVehicleDoorConfig::M_eRotationAxis' has a wrong offset!");

// ScriptStruct BFGCore.BFGVehicleLightBulbConfig
// 0x0058 (0x0058 - 0x0000)
struct FBFGVehicleLightBulbConfig final
{
public:
	class UMaterial*                              LightBulbMaterial;                                 // 0x0000(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   FrontRightBulbBoneName;                            // 0x0008(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   FrontLeftBulbBoneName;                             // 0x0010(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bFrontRight;                                       // 0x0018(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bFrontLeft;                                        // 0x0019(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1A[0x2];                                       // 0x001A(0x0002)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         SpotLightIntensity;                                // 0x001C(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FColor                                 SpotLightColor;                                    // 0x0020(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         SpotLightInnerConeAngle;                           // 0x0024(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         SpotLightOuterConeAngle;                           // 0x0028(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         SpotLightAttenuationRadius;                        // 0x002C(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         SpotLightSourceRadius;                             // 0x0030(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         SoftSourceRadius;                                  // 0x0034(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         SourceLength;                                      // 0x0038(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bSpotLightCastShadows;                             // 0x003C(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bSpotLightCastStaticShadows;                       // 0x003D(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bSpotLightCastDynamicShadows;                      // 0x003E(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bSpotLightCastTranslucentShadows;                  // 0x003F(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         Temperature;                                       // 0x0040(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bUseTemperature;                                   // 0x0044(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_45[0x3];                                       // 0x0045(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         MaxDrawDistance;                                   // 0x0048(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         MaxDistanceFadeRange;                              // 0x004C(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bUseInverseSquaredFalloff;                         // 0x0050(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_51[0x3];                                       // 0x0051(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         LightFalloffExponent;                              // 0x0054(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, Interp, NoDestructor, AdvancedDisplay, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FBFGVehicleLightBulbConfig) == 0x000008, "Wrong alignment on FBFGVehicleLightBulbConfig");
static_assert(sizeof(FBFGVehicleLightBulbConfig) == 0x000058, "Wrong size on FBFGVehicleLightBulbConfig");
static_assert(offsetof(FBFGVehicleLightBulbConfig, LightBulbMaterial) == 0x000000, "Member 'FBFGVehicleLightBulbConfig::LightBulbMaterial' has a wrong offset!");
static_assert(offsetof(FBFGVehicleLightBulbConfig, FrontRightBulbBoneName) == 0x000008, "Member 'FBFGVehicleLightBulbConfig::FrontRightBulbBoneName' has a wrong offset!");
static_assert(offsetof(FBFGVehicleLightBulbConfig, FrontLeftBulbBoneName) == 0x000010, "Member 'FBFGVehicleLightBulbConfig::FrontLeftBulbBoneName' has a wrong offset!");
static_assert(offsetof(FBFGVehicleLightBulbConfig, bFrontRight) == 0x000018, "Member 'FBFGVehicleLightBulbConfig::bFrontRight' has a wrong offset!");
static_assert(offsetof(FBFGVehicleLightBulbConfig, bFrontLeft) == 0x000019, "Member 'FBFGVehicleLightBulbConfig::bFrontLeft' has a wrong offset!");
static_assert(offsetof(FBFGVehicleLightBulbConfig, SpotLightIntensity) == 0x00001C, "Member 'FBFGVehicleLightBulbConfig::SpotLightIntensity' has a wrong offset!");
static_assert(offsetof(FBFGVehicleLightBulbConfig, SpotLightColor) == 0x000020, "Member 'FBFGVehicleLightBulbConfig::SpotLightColor' has a wrong offset!");
static_assert(offsetof(FBFGVehicleLightBulbConfig, SpotLightInnerConeAngle) == 0x000024, "Member 'FBFGVehicleLightBulbConfig::SpotLightInnerConeAngle' has a wrong offset!");
static_assert(offsetof(FBFGVehicleLightBulbConfig, SpotLightOuterConeAngle) == 0x000028, "Member 'FBFGVehicleLightBulbConfig::SpotLightOuterConeAngle' has a wrong offset!");
static_assert(offsetof(FBFGVehicleLightBulbConfig, SpotLightAttenuationRadius) == 0x00002C, "Member 'FBFGVehicleLightBulbConfig::SpotLightAttenuationRadius' has a wrong offset!");
static_assert(offsetof(FBFGVehicleLightBulbConfig, SpotLightSourceRadius) == 0x000030, "Member 'FBFGVehicleLightBulbConfig::SpotLightSourceRadius' has a wrong offset!");
static_assert(offsetof(FBFGVehicleLightBulbConfig, SoftSourceRadius) == 0x000034, "Member 'FBFGVehicleLightBulbConfig::SoftSourceRadius' has a wrong offset!");
static_assert(offsetof(FBFGVehicleLightBulbConfig, SourceLength) == 0x000038, "Member 'FBFGVehicleLightBulbConfig::SourceLength' has a wrong offset!");
static_assert(offsetof(FBFGVehicleLightBulbConfig, bSpotLightCastShadows) == 0x00003C, "Member 'FBFGVehicleLightBulbConfig::bSpotLightCastShadows' has a wrong offset!");
static_assert(offsetof(FBFGVehicleLightBulbConfig, bSpotLightCastStaticShadows) == 0x00003D, "Member 'FBFGVehicleLightBulbConfig::bSpotLightCastStaticShadows' has a wrong offset!");
static_assert(offsetof(FBFGVehicleLightBulbConfig, bSpotLightCastDynamicShadows) == 0x00003E, "Member 'FBFGVehicleLightBulbConfig::bSpotLightCastDynamicShadows' has a wrong offset!");
static_assert(offsetof(FBFGVehicleLightBulbConfig, bSpotLightCastTranslucentShadows) == 0x00003F, "Member 'FBFGVehicleLightBulbConfig::bSpotLightCastTranslucentShadows' has a wrong offset!");
static_assert(offsetof(FBFGVehicleLightBulbConfig, Temperature) == 0x000040, "Member 'FBFGVehicleLightBulbConfig::Temperature' has a wrong offset!");
static_assert(offsetof(FBFGVehicleLightBulbConfig, bUseTemperature) == 0x000044, "Member 'FBFGVehicleLightBulbConfig::bUseTemperature' has a wrong offset!");
static_assert(offsetof(FBFGVehicleLightBulbConfig, MaxDrawDistance) == 0x000048, "Member 'FBFGVehicleLightBulbConfig::MaxDrawDistance' has a wrong offset!");
static_assert(offsetof(FBFGVehicleLightBulbConfig, MaxDistanceFadeRange) == 0x00004C, "Member 'FBFGVehicleLightBulbConfig::MaxDistanceFadeRange' has a wrong offset!");
static_assert(offsetof(FBFGVehicleLightBulbConfig, bUseInverseSquaredFalloff) == 0x000050, "Member 'FBFGVehicleLightBulbConfig::bUseInverseSquaredFalloff' has a wrong offset!");
static_assert(offsetof(FBFGVehicleLightBulbConfig, LightFalloffExponent) == 0x000054, "Member 'FBFGVehicleLightBulbConfig::LightFalloffExponent' has a wrong offset!");

// ScriptStruct BFGCore.BFGVehicleLicensePlateConfig
// 0x0070 (0x0070 - 0x0000)
struct FBFGVehicleLicensePlateConfig final
{
public:
	class UStaticMesh*                            PlateMesh;                                         // 0x0000(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UMaterial*                              PlateMaterial;                                     // 0x0008(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UFont*                                  PrimaryFont;                                       // 0x0010(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UFont*                                  SecondaryFont;                                     // 0x0018(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FString                                 LicencePlateNumber;                                // 0x0020(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FText                                   TopText;                                           // 0x0030(0x0018)(Transient, NativeAccessSpecifierPublic)
	class FText                                   BottomText;                                        // 0x0048(0x0018)(Transient, NativeAccessSpecifierPublic)
	struct FColor                                 TextColorTop;                                      // 0x0060(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FColor                                 TextColorCenterFront;                              // 0x0064(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FColor                                 TextColorBottom;                                   // 0x0068(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_6C[0x4];                                       // 0x006C(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FBFGVehicleLicensePlateConfig) == 0x000008, "Wrong alignment on FBFGVehicleLicensePlateConfig");
static_assert(sizeof(FBFGVehicleLicensePlateConfig) == 0x000070, "Wrong size on FBFGVehicleLicensePlateConfig");
static_assert(offsetof(FBFGVehicleLicensePlateConfig, PlateMesh) == 0x000000, "Member 'FBFGVehicleLicensePlateConfig::PlateMesh' has a wrong offset!");
static_assert(offsetof(FBFGVehicleLicensePlateConfig, PlateMaterial) == 0x000008, "Member 'FBFGVehicleLicensePlateConfig::PlateMaterial' has a wrong offset!");
static_assert(offsetof(FBFGVehicleLicensePlateConfig, PrimaryFont) == 0x000010, "Member 'FBFGVehicleLicensePlateConfig::PrimaryFont' has a wrong offset!");
static_assert(offsetof(FBFGVehicleLicensePlateConfig, SecondaryFont) == 0x000018, "Member 'FBFGVehicleLicensePlateConfig::SecondaryFont' has a wrong offset!");
static_assert(offsetof(FBFGVehicleLicensePlateConfig, LicencePlateNumber) == 0x000020, "Member 'FBFGVehicleLicensePlateConfig::LicencePlateNumber' has a wrong offset!");
static_assert(offsetof(FBFGVehicleLicensePlateConfig, TopText) == 0x000030, "Member 'FBFGVehicleLicensePlateConfig::TopText' has a wrong offset!");
static_assert(offsetof(FBFGVehicleLicensePlateConfig, BottomText) == 0x000048, "Member 'FBFGVehicleLicensePlateConfig::BottomText' has a wrong offset!");
static_assert(offsetof(FBFGVehicleLicensePlateConfig, TextColorTop) == 0x000060, "Member 'FBFGVehicleLicensePlateConfig::TextColorTop' has a wrong offset!");
static_assert(offsetof(FBFGVehicleLicensePlateConfig, TextColorCenterFront) == 0x000064, "Member 'FBFGVehicleLicensePlateConfig::TextColorCenterFront' has a wrong offset!");
static_assert(offsetof(FBFGVehicleLicensePlateConfig, TextColorBottom) == 0x000068, "Member 'FBFGVehicleLicensePlateConfig::TextColorBottom' has a wrong offset!");

// ScriptStruct BFGCore.BFGVehiclePassengerSeat
// 0x00D8 (0x00D8 - 0x0000)
struct FBFGVehiclePassengerSeat final
{
public:
	struct FGameplayTagContainer                  M_passengerTags;                                   // 0x0000(0x0020)(Edit, BlueprintVisible, BlueprintReadOnly, NativeAccessSpecifierPublic)
	struct FGameplayTagQuery                      M_passengerTagQuery;                               // 0x0020(0x0048)(Transient, NativeAccessSpecifierPublic)
	bool                                          M_bHasTagQueryOverride;                            // 0x0068(0x0001)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_69[0x3];                                       // 0x0069(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	class FName                                   M_SeatBoneName;                                    // 0x006C(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                M_vOffsetFromStandardAnim;                         // 0x0074(0x000C)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   M_DoorBoneName;                                    // 0x0080(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          M_bIsRightSeat;                                    // 0x0088(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_89[0x3];                                       // 0x0089(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         M_fSpawnProbability;                               // 0x008C(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          M_bIsTransport;                                    // 0x0090(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_91[0x7];                                       // 0x0091(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	struct FGameplayTagContainer                  M_tagsToAdd;                                       // 0x0098(0x0020)(Edit, BlueprintVisible, BlueprintReadOnly, NativeAccessSpecifierPublic)
	struct FGameplayTagContainer                  M_tagsToAddGameplayEffects;                        // 0x00B8(0x0020)(Edit, BlueprintVisible, BlueprintReadOnly, NativeAccessSpecifierPublic)
};
static_assert(alignof(FBFGVehiclePassengerSeat) == 0x000008, "Wrong alignment on FBFGVehiclePassengerSeat");
static_assert(sizeof(FBFGVehiclePassengerSeat) == 0x0000D8, "Wrong size on FBFGVehiclePassengerSeat");
static_assert(offsetof(FBFGVehiclePassengerSeat, M_passengerTags) == 0x000000, "Member 'FBFGVehiclePassengerSeat::M_passengerTags' has a wrong offset!");
static_assert(offsetof(FBFGVehiclePassengerSeat, M_passengerTagQuery) == 0x000020, "Member 'FBFGVehiclePassengerSeat::M_passengerTagQuery' has a wrong offset!");
static_assert(offsetof(FBFGVehiclePassengerSeat, M_bHasTagQueryOverride) == 0x000068, "Member 'FBFGVehiclePassengerSeat::M_bHasTagQueryOverride' has a wrong offset!");
static_assert(offsetof(FBFGVehiclePassengerSeat, M_SeatBoneName) == 0x00006C, "Member 'FBFGVehiclePassengerSeat::M_SeatBoneName' has a wrong offset!");
static_assert(offsetof(FBFGVehiclePassengerSeat, M_vOffsetFromStandardAnim) == 0x000074, "Member 'FBFGVehiclePassengerSeat::M_vOffsetFromStandardAnim' has a wrong offset!");
static_assert(offsetof(FBFGVehiclePassengerSeat, M_DoorBoneName) == 0x000080, "Member 'FBFGVehiclePassengerSeat::M_DoorBoneName' has a wrong offset!");
static_assert(offsetof(FBFGVehiclePassengerSeat, M_bIsRightSeat) == 0x000088, "Member 'FBFGVehiclePassengerSeat::M_bIsRightSeat' has a wrong offset!");
static_assert(offsetof(FBFGVehiclePassengerSeat, M_fSpawnProbability) == 0x00008C, "Member 'FBFGVehiclePassengerSeat::M_fSpawnProbability' has a wrong offset!");
static_assert(offsetof(FBFGVehiclePassengerSeat, M_bIsTransport) == 0x000090, "Member 'FBFGVehiclePassengerSeat::M_bIsTransport' has a wrong offset!");
static_assert(offsetof(FBFGVehiclePassengerSeat, M_tagsToAdd) == 0x000098, "Member 'FBFGVehiclePassengerSeat::M_tagsToAdd' has a wrong offset!");
static_assert(offsetof(FBFGVehiclePassengerSeat, M_tagsToAddGameplayEffects) == 0x0000B8, "Member 'FBFGVehiclePassengerSeat::M_tagsToAddGameplayEffects' has a wrong offset!");

// ScriptStruct BFGCore.BFGVehiclePassengersConfig
// 0x0130 (0x0130 - 0x0000)
struct FBFGVehiclePassengersConfig final
{
public:
	bool                                          M_bEnablePassengerSpawning;                        // 0x0000(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1[0x7];                                        // 0x0001(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	struct FBFGVehiclePassengerSeat               M_driverSeat;                                      // 0x0008(0x00D8)(Edit, BlueprintVisible, BlueprintReadOnly, NativeAccessSpecifierPublic)
	TArray<struct FBFGVehiclePassengerSeat>       M_passengerSeats;                                  // 0x00E0(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, NativeAccessSpecifierPublic)
	EBFGVehiclePassenger_AnimationSetupID         M_animationSetup;                                  // 0x00F0(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_F1[0x3];                                       // 0x00F1(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	class FName                                   M_BackDoorBoneName;                                // 0x00F4(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   M_transportExitSocketName;                         // 0x00FC(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_104[0x4];                                      // 0x0104(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	TSoftObjectPtr<class UBFGSpawningComposition> M_pNPCSpawningComposition;                         // 0x0108(0x0028)(Edit, BlueprintVisible, BlueprintReadOnly, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FBFGVehiclePassengersConfig) == 0x000008, "Wrong alignment on FBFGVehiclePassengersConfig");
static_assert(sizeof(FBFGVehiclePassengersConfig) == 0x000130, "Wrong size on FBFGVehiclePassengersConfig");
static_assert(offsetof(FBFGVehiclePassengersConfig, M_bEnablePassengerSpawning) == 0x000000, "Member 'FBFGVehiclePassengersConfig::M_bEnablePassengerSpawning' has a wrong offset!");
static_assert(offsetof(FBFGVehiclePassengersConfig, M_driverSeat) == 0x000008, "Member 'FBFGVehiclePassengersConfig::M_driverSeat' has a wrong offset!");
static_assert(offsetof(FBFGVehiclePassengersConfig, M_passengerSeats) == 0x0000E0, "Member 'FBFGVehiclePassengersConfig::M_passengerSeats' has a wrong offset!");
static_assert(offsetof(FBFGVehiclePassengersConfig, M_animationSetup) == 0x0000F0, "Member 'FBFGVehiclePassengersConfig::M_animationSetup' has a wrong offset!");
static_assert(offsetof(FBFGVehiclePassengersConfig, M_BackDoorBoneName) == 0x0000F4, "Member 'FBFGVehiclePassengersConfig::M_BackDoorBoneName' has a wrong offset!");
static_assert(offsetof(FBFGVehiclePassengersConfig, M_transportExitSocketName) == 0x0000FC, "Member 'FBFGVehiclePassengersConfig::M_transportExitSocketName' has a wrong offset!");
static_assert(offsetof(FBFGVehiclePassengersConfig, M_pNPCSpawningComposition) == 0x000108, "Member 'FBFGVehiclePassengersConfig::M_pNPCSpawningComposition' has a wrong offset!");

// ScriptStruct BFGCore.BFGVehicleEffectsConfig
// 0x0010 (0x0010 - 0x0000)
struct FBFGVehicleEffectsConfig final
{
public:
	TArray<class UBFGEffectBank*>                 M_apEffectBanks;                                   // 0x0000(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(FBFGVehicleEffectsConfig) == 0x000008, "Wrong alignment on FBFGVehicleEffectsConfig");
static_assert(sizeof(FBFGVehicleEffectsConfig) == 0x000010, "Wrong size on FBFGVehicleEffectsConfig");
static_assert(offsetof(FBFGVehicleEffectsConfig, M_apEffectBanks) == 0x000000, "Member 'FBFGVehicleEffectsConfig::M_apEffectBanks' has a wrong offset!");

// ScriptStruct BFGCore.BFGVehicleEngineMeshConfig
// 0x0020 (0x0020 - 0x0000)
struct FBFGVehicleEngineMeshConfig final
{
public:
	class UStaticMesh*                            M_pEngineMesh;                                     // 0x0000(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TArray<class FName>                           M_aSocketNames;                                    // 0x0008(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, NativeAccessSpecifierPublic)
	bool                                          M_bHiddenInGame;                                   // 0x0018(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_19[0x7];                                       // 0x0019(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FBFGVehicleEngineMeshConfig) == 0x000008, "Wrong alignment on FBFGVehicleEngineMeshConfig");
static_assert(sizeof(FBFGVehicleEngineMeshConfig) == 0x000020, "Wrong size on FBFGVehicleEngineMeshConfig");
static_assert(offsetof(FBFGVehicleEngineMeshConfig, M_pEngineMesh) == 0x000000, "Member 'FBFGVehicleEngineMeshConfig::M_pEngineMesh' has a wrong offset!");
static_assert(offsetof(FBFGVehicleEngineMeshConfig, M_aSocketNames) == 0x000008, "Member 'FBFGVehicleEngineMeshConfig::M_aSocketNames' has a wrong offset!");
static_assert(offsetof(FBFGVehicleEngineMeshConfig, M_bHiddenInGame) == 0x000018, "Member 'FBFGVehicleEngineMeshConfig::M_bHiddenInGame' has a wrong offset!");

// ScriptStruct BFGCore.BFGVehicleHolobobSuppressionAuraConfig
// 0x0030 (0x0030 - 0x0000)
struct FBFGVehicleHolobobSuppressionAuraConfig final
{
public:
	float                                         M_fAuraRadius;                                     // 0x0000(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_4[0x4];                                        // 0x0004(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	struct FGameplayTagContainer                  M_forbiddenTags;                                   // 0x0008(0x0020)(Edit, BlueprintVisible, BlueprintReadOnly, NativeAccessSpecifierPublic)
	class UBFGDataAsset_RadarObjectStaticInfo*    M_pStaticRadarInfo;                                // 0x0028(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FBFGVehicleHolobobSuppressionAuraConfig) == 0x000008, "Wrong alignment on FBFGVehicleHolobobSuppressionAuraConfig");
static_assert(sizeof(FBFGVehicleHolobobSuppressionAuraConfig) == 0x000030, "Wrong size on FBFGVehicleHolobobSuppressionAuraConfig");
static_assert(offsetof(FBFGVehicleHolobobSuppressionAuraConfig, M_fAuraRadius) == 0x000000, "Member 'FBFGVehicleHolobobSuppressionAuraConfig::M_fAuraRadius' has a wrong offset!");
static_assert(offsetof(FBFGVehicleHolobobSuppressionAuraConfig, M_forbiddenTags) == 0x000008, "Member 'FBFGVehicleHolobobSuppressionAuraConfig::M_forbiddenTags' has a wrong offset!");
static_assert(offsetof(FBFGVehicleHolobobSuppressionAuraConfig, M_pStaticRadarInfo) == 0x000028, "Member 'FBFGVehicleHolobobSuppressionAuraConfig::M_pStaticRadarInfo' has a wrong offset!");

// ScriptStruct BFGCore.BFGWheeledVehicleConfig
// 0x03B8 (0x03B8 - 0x0000)
struct FBFGWheeledVehicleConfig final
{
public:
	class FName                                   RootBoneName;                                      // 0x0000(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   UnderCarriageBoneName;                             // 0x0008(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   InteriorBoneName;                                  // 0x0010(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   SteeringWheelBoneName;                             // 0x0018(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TArray<struct FBFGWheeledVehicleWheelConfig>  Wheels;                                            // 0x0020(0x0010)(ZeroConstructor, Deprecated, NativeAccessSpecifierPublic)
	struct FBFGWheeledVehicleWheelConfigDefinition WheelsDefinition;                                  // 0x0030(0x0018)(Edit, BlueprintVisible, BlueprintReadOnly, NativeAccessSpecifierPublic)
	class USkeletalMesh*                          VehicleChassee;                                    // 0x0048(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UPhysicsAsset*                          M_pWheeledPhysicsAsset;                            // 0x0050(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UPhysicsAsset*                          M_pNormalPhysicsAsset;                             // 0x0058(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UStaticMesh*                            UnderCarriage;                                     // 0x0060(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UStaticMesh*                            Interior;                                          // 0x0068(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UStaticMesh*                            SteeringWheel;                                     // 0x0070(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TArray<struct FBFGVehicleDoorConfig>          Doors;                                             // 0x0078(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, NativeAccessSpecifierPublic)
	TArray<struct FBFGVehiclePluginConfig>        Plugins;                                           // 0x0088(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, NativeAccessSpecifierPublic)
	struct FBFGVehicleLightBulbConfig             LightBulbs;                                        // 0x0098(0x0058)(Edit, BlueprintVisible, BlueprintReadOnly, NoDestructor, NativeAccessSpecifierPublic)
	struct FBFGVehicleLicensePlateConfig          LicensePlates;                                     // 0x00F0(0x0070)(Edit, BlueprintVisible, BlueprintReadOnly, NativeAccessSpecifierPublic)
	struct FBFGVehicleColorConfig                 ColorConfig;                                       // 0x0160(0x0068)(Edit, BlueprintVisible, BlueprintReadOnly, NativeAccessSpecifierPublic)
	struct FBFGWheeledVehicleDrivingConfig        DriveConfig;                                       // 0x01C8(0x0038)(Edit, BlueprintVisible, BlueprintReadOnly, NoDestructor, NativeAccessSpecifierPublic)
	TSubclassOf<class UAnimInstance>              AnimationClass;                                    // 0x0200(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FBFGVehiclePassengersConfig            PassengersConfig;                                  // 0x0208(0x0130)(Edit, BlueprintVisible, BlueprintReadOnly, NativeAccessSpecifierPublic)
	struct FBFGVehicleEffectsConfig               EffectsConfig;                                     // 0x0338(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, NativeAccessSpecifierPublic)
	TArray<struct FBFGVehicleEngineMeshConfig>    M_aEngineMeshConfigs;                              // 0x0348(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, NativeAccessSpecifierPublic)
	float                                         M_fLODStart;                                       // 0x0358(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         M_fLODEnd;                                         // 0x035C(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         M_fLODEnd_UFO;                                     // 0x0360(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         M_fDestroyedVehicleDeSpawnDistance_PlayerCharacter; // 0x0364(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         M_fDestroyedVehicleDeSpawnDistance_UFO;            // 0x0368(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         M_fTurnFactor;                                     // 0x036C(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         M_fCarLength;                                      // 0x0370(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         M_fMonetaryValue;                                  // 0x0374(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         M_fhealthValue;                                    // 0x0378(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EBFGBaseArmorType                             M_eArmorType;                                      // 0x037C(0x0001)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FLightingChannels                      M_LightingChannels;                                // 0x037D(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, NoDestructor, NativeAccessSpecifierPublic)
	bool                                          M_bHasSiren;                                       // 0x037E(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          M_bIsEnemyVehicle;                                 // 0x037F(0x0001)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FBFGVehicleHolobobSuppressionAuraConfig M_holobobAuraConfig;                               // 0x0380(0x0030)(Edit, BlueprintVisible, NativeAccessSpecifierPublic)
	uint8                                         Pad_3B0[0x8];                                      // 0x03B0(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FBFGWheeledVehicleConfig) == 0x000008, "Wrong alignment on FBFGWheeledVehicleConfig");
static_assert(sizeof(FBFGWheeledVehicleConfig) == 0x0003B8, "Wrong size on FBFGWheeledVehicleConfig");
static_assert(offsetof(FBFGWheeledVehicleConfig, RootBoneName) == 0x000000, "Member 'FBFGWheeledVehicleConfig::RootBoneName' has a wrong offset!");
static_assert(offsetof(FBFGWheeledVehicleConfig, UnderCarriageBoneName) == 0x000008, "Member 'FBFGWheeledVehicleConfig::UnderCarriageBoneName' has a wrong offset!");
static_assert(offsetof(FBFGWheeledVehicleConfig, InteriorBoneName) == 0x000010, "Member 'FBFGWheeledVehicleConfig::InteriorBoneName' has a wrong offset!");
static_assert(offsetof(FBFGWheeledVehicleConfig, SteeringWheelBoneName) == 0x000018, "Member 'FBFGWheeledVehicleConfig::SteeringWheelBoneName' has a wrong offset!");
static_assert(offsetof(FBFGWheeledVehicleConfig, Wheels) == 0x000020, "Member 'FBFGWheeledVehicleConfig::Wheels' has a wrong offset!");
static_assert(offsetof(FBFGWheeledVehicleConfig, WheelsDefinition) == 0x000030, "Member 'FBFGWheeledVehicleConfig::WheelsDefinition' has a wrong offset!");
static_assert(offsetof(FBFGWheeledVehicleConfig, VehicleChassee) == 0x000048, "Member 'FBFGWheeledVehicleConfig::VehicleChassee' has a wrong offset!");
static_assert(offsetof(FBFGWheeledVehicleConfig, M_pWheeledPhysicsAsset) == 0x000050, "Member 'FBFGWheeledVehicleConfig::M_pWheeledPhysicsAsset' has a wrong offset!");
static_assert(offsetof(FBFGWheeledVehicleConfig, M_pNormalPhysicsAsset) == 0x000058, "Member 'FBFGWheeledVehicleConfig::M_pNormalPhysicsAsset' has a wrong offset!");
static_assert(offsetof(FBFGWheeledVehicleConfig, UnderCarriage) == 0x000060, "Member 'FBFGWheeledVehicleConfig::UnderCarriage' has a wrong offset!");
static_assert(offsetof(FBFGWheeledVehicleConfig, Interior) == 0x000068, "Member 'FBFGWheeledVehicleConfig::Interior' has a wrong offset!");
static_assert(offsetof(FBFGWheeledVehicleConfig, SteeringWheel) == 0x000070, "Member 'FBFGWheeledVehicleConfig::SteeringWheel' has a wrong offset!");
static_assert(offsetof(FBFGWheeledVehicleConfig, Doors) == 0x000078, "Member 'FBFGWheeledVehicleConfig::Doors' has a wrong offset!");
static_assert(offsetof(FBFGWheeledVehicleConfig, Plugins) == 0x000088, "Member 'FBFGWheeledVehicleConfig::Plugins' has a wrong offset!");
static_assert(offsetof(FBFGWheeledVehicleConfig, LightBulbs) == 0x000098, "Member 'FBFGWheeledVehicleConfig::LightBulbs' has a wrong offset!");
static_assert(offsetof(FBFGWheeledVehicleConfig, LicensePlates) == 0x0000F0, "Member 'FBFGWheeledVehicleConfig::LicensePlates' has a wrong offset!");
static_assert(offsetof(FBFGWheeledVehicleConfig, ColorConfig) == 0x000160, "Member 'FBFGWheeledVehicleConfig::ColorConfig' has a wrong offset!");
static_assert(offsetof(FBFGWheeledVehicleConfig, DriveConfig) == 0x0001C8, "Member 'FBFGWheeledVehicleConfig::DriveConfig' has a wrong offset!");
static_assert(offsetof(FBFGWheeledVehicleConfig, AnimationClass) == 0x000200, "Member 'FBFGWheeledVehicleConfig::AnimationClass' has a wrong offset!");
static_assert(offsetof(FBFGWheeledVehicleConfig, PassengersConfig) == 0x000208, "Member 'FBFGWheeledVehicleConfig::PassengersConfig' has a wrong offset!");
static_assert(offsetof(FBFGWheeledVehicleConfig, EffectsConfig) == 0x000338, "Member 'FBFGWheeledVehicleConfig::EffectsConfig' has a wrong offset!");
static_assert(offsetof(FBFGWheeledVehicleConfig, M_aEngineMeshConfigs) == 0x000348, "Member 'FBFGWheeledVehicleConfig::M_aEngineMeshConfigs' has a wrong offset!");
static_assert(offsetof(FBFGWheeledVehicleConfig, M_fLODStart) == 0x000358, "Member 'FBFGWheeledVehicleConfig::M_fLODStart' has a wrong offset!");
static_assert(offsetof(FBFGWheeledVehicleConfig, M_fLODEnd) == 0x00035C, "Member 'FBFGWheeledVehicleConfig::M_fLODEnd' has a wrong offset!");
static_assert(offsetof(FBFGWheeledVehicleConfig, M_fLODEnd_UFO) == 0x000360, "Member 'FBFGWheeledVehicleConfig::M_fLODEnd_UFO' has a wrong offset!");
static_assert(offsetof(FBFGWheeledVehicleConfig, M_fDestroyedVehicleDeSpawnDistance_PlayerCharacter) == 0x000364, "Member 'FBFGWheeledVehicleConfig::M_fDestroyedVehicleDeSpawnDistance_PlayerCharacter' has a wrong offset!");
static_assert(offsetof(FBFGWheeledVehicleConfig, M_fDestroyedVehicleDeSpawnDistance_UFO) == 0x000368, "Member 'FBFGWheeledVehicleConfig::M_fDestroyedVehicleDeSpawnDistance_UFO' has a wrong offset!");
static_assert(offsetof(FBFGWheeledVehicleConfig, M_fTurnFactor) == 0x00036C, "Member 'FBFGWheeledVehicleConfig::M_fTurnFactor' has a wrong offset!");
static_assert(offsetof(FBFGWheeledVehicleConfig, M_fCarLength) == 0x000370, "Member 'FBFGWheeledVehicleConfig::M_fCarLength' has a wrong offset!");
static_assert(offsetof(FBFGWheeledVehicleConfig, M_fMonetaryValue) == 0x000374, "Member 'FBFGWheeledVehicleConfig::M_fMonetaryValue' has a wrong offset!");
static_assert(offsetof(FBFGWheeledVehicleConfig, M_fhealthValue) == 0x000378, "Member 'FBFGWheeledVehicleConfig::M_fhealthValue' has a wrong offset!");
static_assert(offsetof(FBFGWheeledVehicleConfig, M_eArmorType) == 0x00037C, "Member 'FBFGWheeledVehicleConfig::M_eArmorType' has a wrong offset!");
static_assert(offsetof(FBFGWheeledVehicleConfig, M_LightingChannels) == 0x00037D, "Member 'FBFGWheeledVehicleConfig::M_LightingChannels' has a wrong offset!");
static_assert(offsetof(FBFGWheeledVehicleConfig, M_bHasSiren) == 0x00037E, "Member 'FBFGWheeledVehicleConfig::M_bHasSiren' has a wrong offset!");
static_assert(offsetof(FBFGWheeledVehicleConfig, M_bIsEnemyVehicle) == 0x00037F, "Member 'FBFGWheeledVehicleConfig::M_bIsEnemyVehicle' has a wrong offset!");
static_assert(offsetof(FBFGWheeledVehicleConfig, M_holobobAuraConfig) == 0x000380, "Member 'FBFGWheeledVehicleConfig::M_holobobAuraConfig' has a wrong offset!");

// ScriptStruct BFGCore.BFGNetworkPathAgentLODItem
// 0x0010 (0x0010 - 0x0000)
struct FBFGNetworkPathAgentLODItem final
{
public:
	float                                         DistanceToCamera;                                  // 0x0000(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         Threshold;                                         // 0x0004(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TSubclassOf<class AActor>                     Actortype;                                         // 0x0008(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FBFGNetworkPathAgentLODItem) == 0x000008, "Wrong alignment on FBFGNetworkPathAgentLODItem");
static_assert(sizeof(FBFGNetworkPathAgentLODItem) == 0x000010, "Wrong size on FBFGNetworkPathAgentLODItem");
static_assert(offsetof(FBFGNetworkPathAgentLODItem, DistanceToCamera) == 0x000000, "Member 'FBFGNetworkPathAgentLODItem::DistanceToCamera' has a wrong offset!");
static_assert(offsetof(FBFGNetworkPathAgentLODItem, Threshold) == 0x000004, "Member 'FBFGNetworkPathAgentLODItem::Threshold' has a wrong offset!");
static_assert(offsetof(FBFGNetworkPathAgentLODItem, Actortype) == 0x000008, "Member 'FBFGNetworkPathAgentLODItem::Actortype' has a wrong offset!");

// ScriptStruct BFGCore.BFGNetworkPathAgentLODInfo
// 0x0010 (0x0010 - 0x0000)
struct FBFGNetworkPathAgentLODInfo final
{
public:
	TArray<struct FBFGNetworkPathAgentLODItem>    LevelsOfDetail;                                    // 0x0000(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(FBFGNetworkPathAgentLODInfo) == 0x000008, "Wrong alignment on FBFGNetworkPathAgentLODInfo");
static_assert(sizeof(FBFGNetworkPathAgentLODInfo) == 0x000010, "Wrong size on FBFGNetworkPathAgentLODInfo");
static_assert(offsetof(FBFGNetworkPathAgentLODInfo, LevelsOfDetail) == 0x000000, "Member 'FBFGNetworkPathAgentLODInfo::LevelsOfDetail' has a wrong offset!");

// ScriptStruct BFGCore.BFGNetworkPathAgent_ActorlessSpawnData
// 0x03F8 (0x03F8 - 0x0000)
struct FBFGNetworkPathAgent_ActorlessSpawnData final
{
public:
	class FName                                   M_TableRowName;                                    // 0x0000(0x0008)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UBFGSpawningComposition*                M_pSpawningComposition;                            // 0x0008(0x0008)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TSubclassOf<class AActor>                     M_actorClass;                                      // 0x0010(0x0008)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_18[0x8];                                       // 0x0018(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	bool                                          M_bIsVehicle;                                      // 0x0020(0x0001)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_21[0x7];                                       // 0x0021(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	struct FBFGWheeledVehicleConfig               M_vehicleDefinitionRow_config;                     // 0x0028(0x03B8)(Transient, NativeAccessSpecifierPublic)
	struct FBFGNetworkPathAgentLODInfo            M_vehicleDefinitionRow_LODInfo;                    // 0x03E0(0x0010)(Transient, NativeAccessSpecifierPublic)
	bool                                          M_bVehicleDefinitionRow_IsEnemy;                   // 0x03F0(0x0001)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          M_bShouldBeHiddenByCinematics;                     // 0x03F1(0x0001)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_3F2[0x6];                                      // 0x03F2(0x0006)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FBFGNetworkPathAgent_ActorlessSpawnData) == 0x000008, "Wrong alignment on FBFGNetworkPathAgent_ActorlessSpawnData");
static_assert(sizeof(FBFGNetworkPathAgent_ActorlessSpawnData) == 0x0003F8, "Wrong size on FBFGNetworkPathAgent_ActorlessSpawnData");
static_assert(offsetof(FBFGNetworkPathAgent_ActorlessSpawnData, M_TableRowName) == 0x000000, "Member 'FBFGNetworkPathAgent_ActorlessSpawnData::M_TableRowName' has a wrong offset!");
static_assert(offsetof(FBFGNetworkPathAgent_ActorlessSpawnData, M_pSpawningComposition) == 0x000008, "Member 'FBFGNetworkPathAgent_ActorlessSpawnData::M_pSpawningComposition' has a wrong offset!");
static_assert(offsetof(FBFGNetworkPathAgent_ActorlessSpawnData, M_actorClass) == 0x000010, "Member 'FBFGNetworkPathAgent_ActorlessSpawnData::M_actorClass' has a wrong offset!");
static_assert(offsetof(FBFGNetworkPathAgent_ActorlessSpawnData, M_bIsVehicle) == 0x000020, "Member 'FBFGNetworkPathAgent_ActorlessSpawnData::M_bIsVehicle' has a wrong offset!");
static_assert(offsetof(FBFGNetworkPathAgent_ActorlessSpawnData, M_vehicleDefinitionRow_config) == 0x000028, "Member 'FBFGNetworkPathAgent_ActorlessSpawnData::M_vehicleDefinitionRow_config' has a wrong offset!");
static_assert(offsetof(FBFGNetworkPathAgent_ActorlessSpawnData, M_vehicleDefinitionRow_LODInfo) == 0x0003E0, "Member 'FBFGNetworkPathAgent_ActorlessSpawnData::M_vehicleDefinitionRow_LODInfo' has a wrong offset!");
static_assert(offsetof(FBFGNetworkPathAgent_ActorlessSpawnData, M_bVehicleDefinitionRow_IsEnemy) == 0x0003F0, "Member 'FBFGNetworkPathAgent_ActorlessSpawnData::M_bVehicleDefinitionRow_IsEnemy' has a wrong offset!");
static_assert(offsetof(FBFGNetworkPathAgent_ActorlessSpawnData, M_bShouldBeHiddenByCinematics) == 0x0003F1, "Member 'FBFGNetworkPathAgent_ActorlessSpawnData::M_bShouldBeHiddenByCinematics' has a wrong offset!");

// ScriptStruct BFGCore.BFGTimer
// 0x0010 (0x0010 - 0x0000)
struct FBFGTimer final
{
public:
	float                                         M_fTickRate;                                       // 0x0000(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_4[0xC];                                        // 0x0004(0x000C)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FBFGTimer) == 0x000004, "Wrong alignment on FBFGTimer");
static_assert(sizeof(FBFGTimer) == 0x000010, "Wrong size on FBFGTimer");
static_assert(offsetof(FBFGTimer, M_fTickRate) == 0x000000, "Member 'FBFGTimer::M_fTickRate' has a wrong offset!");

// ScriptStruct BFGCore.BFGSoftObjectPath
// 0x0018 (0x0018 - 0x0000)
struct FBFGSoftObjectPath final
{
public:
	class FName                                   M_strAssetPathName;                                // 0x0000(0x0008)(ZeroConstructor, SaveGame, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class FString                                 M_strSubPathString;                                // 0x0008(0x0010)(ZeroConstructor, SaveGame, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
};
static_assert(alignof(FBFGSoftObjectPath) == 0x000008, "Wrong alignment on FBFGSoftObjectPath");
static_assert(sizeof(FBFGSoftObjectPath) == 0x000018, "Wrong size on FBFGSoftObjectPath");
static_assert(offsetof(FBFGSoftObjectPath, M_strAssetPathName) == 0x000000, "Member 'FBFGSoftObjectPath::M_strAssetPathName' has a wrong offset!");
static_assert(offsetof(FBFGSoftObjectPath, M_strSubPathString) == 0x000008, "Member 'FBFGSoftObjectPath::M_strSubPathString' has a wrong offset!");

// ScriptStruct BFGCore.BFGActorData_Proxy
// 0x0058 (0x0058 - 0x0000)
struct FBFGActorData_Proxy final
{
public:
	struct FBFGSoftObjectPath                     M_proxyInstance;                                   // 0x0000(0x0018)(SaveGame, NativeAccessSpecifierPublic)
	EBFGActorProxyState                           M_state;                                           // 0x0018(0x0001)(ZeroConstructor, SaveGame, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_19[0x7];                                       // 0x0019(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	struct FBFGSoftObjectPath                     M_childInstancePath;                               // 0x0020(0x0018)(SaveGame, NativeAccessSpecifierPublic)
	struct FGameplayTagContainer                  M_gameplayTags;                                    // 0x0038(0x0020)(SaveGame, NativeAccessSpecifierPublic)
};
static_assert(alignof(FBFGActorData_Proxy) == 0x000008, "Wrong alignment on FBFGActorData_Proxy");
static_assert(sizeof(FBFGActorData_Proxy) == 0x000058, "Wrong size on FBFGActorData_Proxy");
static_assert(offsetof(FBFGActorData_Proxy, M_proxyInstance) == 0x000000, "Member 'FBFGActorData_Proxy::M_proxyInstance' has a wrong offset!");
static_assert(offsetof(FBFGActorData_Proxy, M_state) == 0x000018, "Member 'FBFGActorData_Proxy::M_state' has a wrong offset!");
static_assert(offsetof(FBFGActorData_Proxy, M_childInstancePath) == 0x000020, "Member 'FBFGActorData_Proxy::M_childInstancePath' has a wrong offset!");
static_assert(offsetof(FBFGActorData_Proxy, M_gameplayTags) == 0x000038, "Member 'FBFGActorData_Proxy::M_gameplayTags' has a wrong offset!");

// ScriptStruct BFGCore.BFGActorData_Instance
// 0x0110 (0x0110 - 0x0000)
struct FBFGActorData_Instance final
{
public:
	EBFGActorData_Instance_DataSource             M_dataSource;                                      // 0x0000(0x0001)(ZeroConstructor, SaveGame, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          M_bIsSpawn;                                        // 0x0001(0x0001)(ZeroConstructor, SaveGame, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2[0x6];                                        // 0x0002(0x0006)(Fixing Size After Last Property [ Dumper-7 ])
	struct FBFGSoftObjectPath                     M_actorInstance;                                   // 0x0008(0x0018)(SaveGame, NativeAccessSpecifierPublic)
	struct FBFGSoftObjectPath                     M_actorClass;                                      // 0x0020(0x0018)(SaveGame, NativeAccessSpecifierPublic)
	uint8                                         Pad_38[0x8];                                       // 0x0038(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	struct FTransform                             M_Transform;                                       // 0x0040(0x0030)(SaveGame, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
	struct FGameplayTagContainer                  M_gameplayTags;                                    // 0x0070(0x0020)(SaveGame, NativeAccessSpecifierPublic)
	EBFGFaction                                   M_eFaction;                                        // 0x0090(0x0001)(ZeroConstructor, SaveGame, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_91[0x7];                                       // 0x0091(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<class FName>                           M_aTags;                                           // 0x0098(0x0010)(ZeroConstructor, SaveGame, NativeAccessSpecifierPublic)
	struct FBFGActorData_InstanceCustomData       M_customData;                                      // 0x00A8(0x0060)(SaveGame, NativeAccessSpecifierPublic)
	uint8                                         Pad_108[0x8];                                      // 0x0108(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FBFGActorData_Instance) == 0x000010, "Wrong alignment on FBFGActorData_Instance");
static_assert(sizeof(FBFGActorData_Instance) == 0x000110, "Wrong size on FBFGActorData_Instance");
static_assert(offsetof(FBFGActorData_Instance, M_dataSource) == 0x000000, "Member 'FBFGActorData_Instance::M_dataSource' has a wrong offset!");
static_assert(offsetof(FBFGActorData_Instance, M_bIsSpawn) == 0x000001, "Member 'FBFGActorData_Instance::M_bIsSpawn' has a wrong offset!");
static_assert(offsetof(FBFGActorData_Instance, M_actorInstance) == 0x000008, "Member 'FBFGActorData_Instance::M_actorInstance' has a wrong offset!");
static_assert(offsetof(FBFGActorData_Instance, M_actorClass) == 0x000020, "Member 'FBFGActorData_Instance::M_actorClass' has a wrong offset!");
static_assert(offsetof(FBFGActorData_Instance, M_Transform) == 0x000040, "Member 'FBFGActorData_Instance::M_Transform' has a wrong offset!");
static_assert(offsetof(FBFGActorData_Instance, M_gameplayTags) == 0x000070, "Member 'FBFGActorData_Instance::M_gameplayTags' has a wrong offset!");
static_assert(offsetof(FBFGActorData_Instance, M_eFaction) == 0x000090, "Member 'FBFGActorData_Instance::M_eFaction' has a wrong offset!");
static_assert(offsetof(FBFGActorData_Instance, M_aTags) == 0x000098, "Member 'FBFGActorData_Instance::M_aTags' has a wrong offset!");
static_assert(offsetof(FBFGActorData_Instance, M_customData) == 0x0000A8, "Member 'FBFGActorData_Instance::M_customData' has a wrong offset!");

// ScriptStruct BFGCore.BFGActorData_CinematicVolume
// 0x0040 (0x0040 - 0x0000)
struct FBFGActorData_CinematicVolume final
{
public:
	struct FBFGSoftObjectPath                     M_cinematicVolumeInstance;                         // 0x0000(0x0018)(SaveGame, NativeAccessSpecifierPublic)
	bool                                          M_bIsEnabled;                                      // 0x0018(0x0001)(ZeroConstructor, SaveGame, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_19[0x7];                                       // 0x0019(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	struct FGameplayTagContainer                  M_gameplayTags;                                    // 0x0020(0x0020)(SaveGame, NativeAccessSpecifierPublic)
};
static_assert(alignof(FBFGActorData_CinematicVolume) == 0x000008, "Wrong alignment on FBFGActorData_CinematicVolume");
static_assert(sizeof(FBFGActorData_CinematicVolume) == 0x000040, "Wrong size on FBFGActorData_CinematicVolume");
static_assert(offsetof(FBFGActorData_CinematicVolume, M_cinematicVolumeInstance) == 0x000000, "Member 'FBFGActorData_CinematicVolume::M_cinematicVolumeInstance' has a wrong offset!");
static_assert(offsetof(FBFGActorData_CinematicVolume, M_bIsEnabled) == 0x000018, "Member 'FBFGActorData_CinematicVolume::M_bIsEnabled' has a wrong offset!");
static_assert(offsetof(FBFGActorData_CinematicVolume, M_gameplayTags) == 0x000020, "Member 'FBFGActorData_CinematicVolume::M_gameplayTags' has a wrong offset!");

// ScriptStruct BFGCore.BFGActorDataSet
// 0x0128 (0x0128 - 0x0000)
struct FBFGActorDataSet final
{
public:
	TArray<struct FBFGActorData_Proxy>            M_aProxies;                                        // 0x0000(0x0010)(ZeroConstructor, SaveGame, NativeAccessSpecifierPublic)
	TArray<struct FBFGActorData_CinematicVolume>  M_aCinematicVolumes;                               // 0x0010(0x0010)(ZeroConstructor, SaveGame, NativeAccessSpecifierPublic)
	TArray<struct FBFGActorData_Instance>         M_aInstances;                                      // 0x0020(0x0010)(ZeroConstructor, SaveGame, NativeAccessSpecifierPublic)
	class UBFGGameSettings*                       M_pSettings;                                       // 0x0030(0x0008)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_38[0xF0];                                      // 0x0038(0x00F0)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FBFGActorDataSet) == 0x000008, "Wrong alignment on FBFGActorDataSet");
static_assert(sizeof(FBFGActorDataSet) == 0x000128, "Wrong size on FBFGActorDataSet");
static_assert(offsetof(FBFGActorDataSet, M_aProxies) == 0x000000, "Member 'FBFGActorDataSet::M_aProxies' has a wrong offset!");
static_assert(offsetof(FBFGActorDataSet, M_aCinematicVolumes) == 0x000010, "Member 'FBFGActorDataSet::M_aCinematicVolumes' has a wrong offset!");
static_assert(offsetof(FBFGActorDataSet, M_aInstances) == 0x000020, "Member 'FBFGActorDataSet::M_aInstances' has a wrong offset!");
static_assert(offsetof(FBFGActorDataSet, M_pSettings) == 0x000030, "Member 'FBFGActorDataSet::M_pSettings' has a wrong offset!");

// ScriptStruct BFGCore.BFGSaveGame_ActorData
// 0x0258 (0x0258 - 0x0000)
struct FBFGSaveGame_ActorData final
{
public:
	struct FBFGActorDataSet                       M_minimalDataSet;                                  // 0x0000(0x0128)(SaveGame, Protected, NativeAccessSpecifierProtected)
	struct FBFGActorDataSet                       M_detailedDataSet;                                 // 0x0128(0x0128)(SaveGame, Protected, NativeAccessSpecifierProtected)
	class UBFGGameSettings*                       M_pSettings;                                       // 0x0250(0x0008)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
};
static_assert(alignof(FBFGSaveGame_ActorData) == 0x000008, "Wrong alignment on FBFGSaveGame_ActorData");
static_assert(sizeof(FBFGSaveGame_ActorData) == 0x000258, "Wrong size on FBFGSaveGame_ActorData");
static_assert(offsetof(FBFGSaveGame_ActorData, M_minimalDataSet) == 0x000000, "Member 'FBFGSaveGame_ActorData::M_minimalDataSet' has a wrong offset!");
static_assert(offsetof(FBFGSaveGame_ActorData, M_detailedDataSet) == 0x000128, "Member 'FBFGSaveGame_ActorData::M_detailedDataSet' has a wrong offset!");
static_assert(offsetof(FBFGSaveGame_ActorData, M_pSettings) == 0x000250, "Member 'FBFGSaveGame_ActorData::M_pSettings' has a wrong offset!");

// ScriptStruct BFGCore.BFGDataTableRow_LocalizedKeyName
// 0x0018 (0x0020 - 0x0008)
struct FBFGDataTableRow_LocalizedKeyName final : public FTableRowBase
{
public:
	class FText                                   M_strLocalizedKeyName;                             // 0x0008(0x0018)(Edit, BlueprintVisible, BlueprintReadOnly, NativeAccessSpecifierPublic)
};
static_assert(alignof(FBFGDataTableRow_LocalizedKeyName) == 0x000008, "Wrong alignment on FBFGDataTableRow_LocalizedKeyName");
static_assert(sizeof(FBFGDataTableRow_LocalizedKeyName) == 0x000020, "Wrong size on FBFGDataTableRow_LocalizedKeyName");
static_assert(offsetof(FBFGDataTableRow_LocalizedKeyName, M_strLocalizedKeyName) == 0x000008, "Member 'FBFGDataTableRow_LocalizedKeyName::M_strLocalizedKeyName' has a wrong offset!");

// ScriptStruct BFGCore.BFGResponseLevelSpawnWaveItem
// 0x0078 (0x0078 - 0x0000)
struct FBFGResponseLevelSpawnWaveItem final
{
public:
	struct FGameplayTagContainer                  GameplayTags;                                      // 0x0000(0x0020)(Edit, BlueprintVisible, BlueprintReadOnly, DisableEditOnInstance, NativeAccessSpecifierPublic)
	struct FGameplayTagQuery                      GameplayTagsQuery;                                 // 0x0020(0x0048)(Edit, BlueprintVisible, BlueprintReadOnly, DisableEditOnInstance, NativeAccessSpecifierPublic)
	int32                                         MinCount;                                          // 0x0068(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         MaxCount;                                          // 0x006C(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         ResponseValueVariance;                             // 0x0070(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EBFGBehaviourState_NPC                        BehaviorState;                                     // 0x0074(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_75[0x3];                                       // 0x0075(0x0003)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FBFGResponseLevelSpawnWaveItem) == 0x000008, "Wrong alignment on FBFGResponseLevelSpawnWaveItem");
static_assert(sizeof(FBFGResponseLevelSpawnWaveItem) == 0x000078, "Wrong size on FBFGResponseLevelSpawnWaveItem");
static_assert(offsetof(FBFGResponseLevelSpawnWaveItem, GameplayTags) == 0x000000, "Member 'FBFGResponseLevelSpawnWaveItem::GameplayTags' has a wrong offset!");
static_assert(offsetof(FBFGResponseLevelSpawnWaveItem, GameplayTagsQuery) == 0x000020, "Member 'FBFGResponseLevelSpawnWaveItem::GameplayTagsQuery' has a wrong offset!");
static_assert(offsetof(FBFGResponseLevelSpawnWaveItem, MinCount) == 0x000068, "Member 'FBFGResponseLevelSpawnWaveItem::MinCount' has a wrong offset!");
static_assert(offsetof(FBFGResponseLevelSpawnWaveItem, MaxCount) == 0x00006C, "Member 'FBFGResponseLevelSpawnWaveItem::MaxCount' has a wrong offset!");
static_assert(offsetof(FBFGResponseLevelSpawnWaveItem, ResponseValueVariance) == 0x000070, "Member 'FBFGResponseLevelSpawnWaveItem::ResponseValueVariance' has a wrong offset!");
static_assert(offsetof(FBFGResponseLevelSpawnWaveItem, BehaviorState) == 0x000074, "Member 'FBFGResponseLevelSpawnWaveItem::BehaviorState' has a wrong offset!");

// ScriptStruct BFGCore.BFGResponseLevelSpawnWave
// 0x00E0 (0x00E0 - 0x0000)
struct FBFGResponseLevelSpawnWave final
{
public:
	TArray<struct FBFGResponseLevelSpawnWaveItem> Items;                                             // 0x0000(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, NativeAccessSpecifierPublic)
	float                                         ResponseLevelMinValue;                             // 0x0010(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         ResponseLevelMaxValue;                             // 0x0014(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TSoftObjectPtr<class UBFGSpawningComposition> SpawningCompositionTable;                          // 0x0018(0x0028)(Edit, BlueprintVisible, BlueprintReadOnly, DisableEditOnInstance, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FBFGResponseLevelSpawnWave_SpawnAroundPlayer M_spawnAroundPlayerInfo;                           // 0x0040(0x000C)(Edit, BlueprintVisible, BlueprintReadOnly, DisableEditOnInstance, NoDestructor, NativeAccessSpecifierPublic)
	EBFGNPCSpawnModeType                          M_spawnType;                                       // 0x004C(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_4D[0x3];                                       // 0x004D(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	struct FGameplayTagContainer                  M_vehicleForNPCs;                                  // 0x0050(0x0020)(Edit, BlueprintVisible, BlueprintReadOnly, DisableEditOnInstance, NativeAccessSpecifierPublic)
	TSoftObjectPtr<class UBFGSpawningComposition> M_vehicleSpawningCompositionTable;                 // 0x0070(0x0028)(Edit, BlueprintVisible, BlueprintReadOnly, DisableEditOnInstance, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FBFGPassengersData                     M_passengerData;                                   // 0x0098(0x0038)(Edit, BlueprintVisible, BlueprintReadOnly, DisableEditOnInstance, NativeAccessSpecifierPublic)
	struct FBFGResponseLevelSpawnWave_SpawnAroundPlayer M_vehicleSpawnAroundPlayerInfo;                    // 0x00D0(0x000C)(Edit, BlueprintVisible, BlueprintReadOnly, DisableEditOnInstance, NoDestructor, NativeAccessSpecifierPublic)
	uint8                                         Pad_DC[0x4];                                       // 0x00DC(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FBFGResponseLevelSpawnWave) == 0x000008, "Wrong alignment on FBFGResponseLevelSpawnWave");
static_assert(sizeof(FBFGResponseLevelSpawnWave) == 0x0000E0, "Wrong size on FBFGResponseLevelSpawnWave");
static_assert(offsetof(FBFGResponseLevelSpawnWave, Items) == 0x000000, "Member 'FBFGResponseLevelSpawnWave::Items' has a wrong offset!");
static_assert(offsetof(FBFGResponseLevelSpawnWave, ResponseLevelMinValue) == 0x000010, "Member 'FBFGResponseLevelSpawnWave::ResponseLevelMinValue' has a wrong offset!");
static_assert(offsetof(FBFGResponseLevelSpawnWave, ResponseLevelMaxValue) == 0x000014, "Member 'FBFGResponseLevelSpawnWave::ResponseLevelMaxValue' has a wrong offset!");
static_assert(offsetof(FBFGResponseLevelSpawnWave, SpawningCompositionTable) == 0x000018, "Member 'FBFGResponseLevelSpawnWave::SpawningCompositionTable' has a wrong offset!");
static_assert(offsetof(FBFGResponseLevelSpawnWave, M_spawnAroundPlayerInfo) == 0x000040, "Member 'FBFGResponseLevelSpawnWave::M_spawnAroundPlayerInfo' has a wrong offset!");
static_assert(offsetof(FBFGResponseLevelSpawnWave, M_spawnType) == 0x00004C, "Member 'FBFGResponseLevelSpawnWave::M_spawnType' has a wrong offset!");
static_assert(offsetof(FBFGResponseLevelSpawnWave, M_vehicleForNPCs) == 0x000050, "Member 'FBFGResponseLevelSpawnWave::M_vehicleForNPCs' has a wrong offset!");
static_assert(offsetof(FBFGResponseLevelSpawnWave, M_vehicleSpawningCompositionTable) == 0x000070, "Member 'FBFGResponseLevelSpawnWave::M_vehicleSpawningCompositionTable' has a wrong offset!");
static_assert(offsetof(FBFGResponseLevelSpawnWave, M_passengerData) == 0x000098, "Member 'FBFGResponseLevelSpawnWave::M_passengerData' has a wrong offset!");
static_assert(offsetof(FBFGResponseLevelSpawnWave, M_vehicleSpawnAroundPlayerInfo) == 0x0000D0, "Member 'FBFGResponseLevelSpawnWave::M_vehicleSpawnAroundPlayerInfo' has a wrong offset!");

// ScriptStruct BFGCore.BFGDeathrayZoneData
// 0x0018 (0x0018 - 0x0000)
struct FBFGDeathrayZoneData final
{
public:
	struct FVector                                M_vPosition;                                       // 0x0000(0x000C)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         M_fCurrentRadius;                                  // 0x000C(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         M_fDurationTimer;                                  // 0x0010(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         M_fTickTimer;                                      // 0x0014(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FBFGDeathrayZoneData) == 0x000004, "Wrong alignment on FBFGDeathrayZoneData");
static_assert(sizeof(FBFGDeathrayZoneData) == 0x000018, "Wrong size on FBFGDeathrayZoneData");
static_assert(offsetof(FBFGDeathrayZoneData, M_vPosition) == 0x000000, "Member 'FBFGDeathrayZoneData::M_vPosition' has a wrong offset!");
static_assert(offsetof(FBFGDeathrayZoneData, M_fCurrentRadius) == 0x00000C, "Member 'FBFGDeathrayZoneData::M_fCurrentRadius' has a wrong offset!");
static_assert(offsetof(FBFGDeathrayZoneData, M_fDurationTimer) == 0x000010, "Member 'FBFGDeathrayZoneData::M_fDurationTimer' has a wrong offset!");
static_assert(offsetof(FBFGDeathrayZoneData, M_fTickTimer) == 0x000014, "Member 'FBFGDeathrayZoneData::M_fTickTimer' has a wrong offset!");

// ScriptStruct BFGCore.BFGOverheadWidgetEntry
// 0x0028 (0x0028 - 0x0000)
struct FBFGOverheadWidgetEntry final
{
public:
	class AActor*                                 M_pActor;                                          // 0x0000(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_8[0x20];                                       // 0x0008(0x0020)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FBFGOverheadWidgetEntry) == 0x000008, "Wrong alignment on FBFGOverheadWidgetEntry");
static_assert(sizeof(FBFGOverheadWidgetEntry) == 0x000028, "Wrong size on FBFGOverheadWidgetEntry");
static_assert(offsetof(FBFGOverheadWidgetEntry, M_pActor) == 0x000000, "Member 'FBFGOverheadWidgetEntry::M_pActor' has a wrong offset!");

// ScriptStruct BFGCore.BFGNetworkPathConnection
// 0x0028 (0x0028 - 0x0000)
struct FBFGNetworkPathConnection final
{
public:
	EBFGNetworkPathExtremity                      Source;                                            // 0x0000(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1[0x3];                                        // 0x0001(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	struct FGuid                                  SourceId;                                          // 0x0004(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EBFGNetworkPathExtremity                      Target;                                            // 0x0014(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_15[0x3];                                       // 0x0015(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	struct FGuid                                  TargetId;                                          // 0x0018(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FBFGNetworkPathConnection) == 0x000004, "Wrong alignment on FBFGNetworkPathConnection");
static_assert(sizeof(FBFGNetworkPathConnection) == 0x000028, "Wrong size on FBFGNetworkPathConnection");
static_assert(offsetof(FBFGNetworkPathConnection, Source) == 0x000000, "Member 'FBFGNetworkPathConnection::Source' has a wrong offset!");
static_assert(offsetof(FBFGNetworkPathConnection, SourceId) == 0x000004, "Member 'FBFGNetworkPathConnection::SourceId' has a wrong offset!");
static_assert(offsetof(FBFGNetworkPathConnection, Target) == 0x000014, "Member 'FBFGNetworkPathConnection::Target' has a wrong offset!");
static_assert(offsetof(FBFGNetworkPathConnection, TargetId) == 0x000018, "Member 'FBFGNetworkPathConnection::TargetId' has a wrong offset!");

// ScriptStruct BFGCore.BFGVisitedPathNodeStackItem
// 0x0070 (0x0070 - 0x0000)
struct FBFGVisitedPathNodeStackItem final
{
public:
	class UBFGNetworkPath*                        M_pPath;                                           // 0x0000(0x0008)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EBFGNetworkPathExtremity                      M_eExtremity;                                      // 0x0008(0x0001)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_9[0x7];                                        // 0x0009(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	class FString                                 M_strNodeKey;                                      // 0x0010(0x0010)(ZeroConstructor, Transient, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TArray<struct FBFGNetworkPathConnection>      M_aPathConnections;                                // 0x0020(0x0010)(ZeroConstructor, Transient, NativeAccessSpecifierPublic)
	int32                                         M_iNextConnectionToVisit;                          // 0x0030(0x0004)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          M_bFinished;                                       // 0x0034(0x0001)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_35[0x3];                                       // 0x0035(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	class FString                                 M_strPreviousNodeKey;                              // 0x0038(0x0010)(ZeroConstructor, Transient, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UBFGTrafficCrowdManager*                M_pManager;                                        // 0x0048(0x0008)(ExportObject, ZeroConstructor, Transient, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FGameplayTagContainer                  M_aTags;                                           // 0x0050(0x0020)(Transient, NativeAccessSpecifierPublic)
};
static_assert(alignof(FBFGVisitedPathNodeStackItem) == 0x000008, "Wrong alignment on FBFGVisitedPathNodeStackItem");
static_assert(sizeof(FBFGVisitedPathNodeStackItem) == 0x000070, "Wrong size on FBFGVisitedPathNodeStackItem");
static_assert(offsetof(FBFGVisitedPathNodeStackItem, M_pPath) == 0x000000, "Member 'FBFGVisitedPathNodeStackItem::M_pPath' has a wrong offset!");
static_assert(offsetof(FBFGVisitedPathNodeStackItem, M_eExtremity) == 0x000008, "Member 'FBFGVisitedPathNodeStackItem::M_eExtremity' has a wrong offset!");
static_assert(offsetof(FBFGVisitedPathNodeStackItem, M_strNodeKey) == 0x000010, "Member 'FBFGVisitedPathNodeStackItem::M_strNodeKey' has a wrong offset!");
static_assert(offsetof(FBFGVisitedPathNodeStackItem, M_aPathConnections) == 0x000020, "Member 'FBFGVisitedPathNodeStackItem::M_aPathConnections' has a wrong offset!");
static_assert(offsetof(FBFGVisitedPathNodeStackItem, M_iNextConnectionToVisit) == 0x000030, "Member 'FBFGVisitedPathNodeStackItem::M_iNextConnectionToVisit' has a wrong offset!");
static_assert(offsetof(FBFGVisitedPathNodeStackItem, M_bFinished) == 0x000034, "Member 'FBFGVisitedPathNodeStackItem::M_bFinished' has a wrong offset!");
static_assert(offsetof(FBFGVisitedPathNodeStackItem, M_strPreviousNodeKey) == 0x000038, "Member 'FBFGVisitedPathNodeStackItem::M_strPreviousNodeKey' has a wrong offset!");
static_assert(offsetof(FBFGVisitedPathNodeStackItem, M_pManager) == 0x000048, "Member 'FBFGVisitedPathNodeStackItem::M_pManager' has a wrong offset!");
static_assert(offsetof(FBFGVisitedPathNodeStackItem, M_aTags) == 0x000050, "Member 'FBFGVisitedPathNodeStackItem::M_aTags' has a wrong offset!");

// ScriptStruct BFGCore.BFGNetworkPath_SearchPathResultWayPoint
// 0x0028 (0x0028 - 0x0000)
struct FBFGNetworkPath_SearchPathResultWayPoint final
{
public:
	class UBFGNetworkPath*                        M_pPath;                                           // 0x0000(0x0008)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EBFGNetworkPathExtremity                      M_eExtremity;                                      // 0x0008(0x0001)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EBFGNetworkPath_SearchPathMoveType            M_eMoveType;                                       // 0x0009(0x0001)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_A[0x2];                                        // 0x000A(0x0002)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         M_fDistance;                                       // 0x000C(0x0004)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                M_vLocation;                                       // 0x0010(0x000C)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          M_bHasDistance;                                    // 0x001C(0x0001)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1D[0x3];                                       // 0x001D(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         M_fDistanceFromStart;                              // 0x0020(0x0004)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_24[0x4];                                       // 0x0024(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FBFGNetworkPath_SearchPathResultWayPoint) == 0x000008, "Wrong alignment on FBFGNetworkPath_SearchPathResultWayPoint");
static_assert(sizeof(FBFGNetworkPath_SearchPathResultWayPoint) == 0x000028, "Wrong size on FBFGNetworkPath_SearchPathResultWayPoint");
static_assert(offsetof(FBFGNetworkPath_SearchPathResultWayPoint, M_pPath) == 0x000000, "Member 'FBFGNetworkPath_SearchPathResultWayPoint::M_pPath' has a wrong offset!");
static_assert(offsetof(FBFGNetworkPath_SearchPathResultWayPoint, M_eExtremity) == 0x000008, "Member 'FBFGNetworkPath_SearchPathResultWayPoint::M_eExtremity' has a wrong offset!");
static_assert(offsetof(FBFGNetworkPath_SearchPathResultWayPoint, M_eMoveType) == 0x000009, "Member 'FBFGNetworkPath_SearchPathResultWayPoint::M_eMoveType' has a wrong offset!");
static_assert(offsetof(FBFGNetworkPath_SearchPathResultWayPoint, M_fDistance) == 0x00000C, "Member 'FBFGNetworkPath_SearchPathResultWayPoint::M_fDistance' has a wrong offset!");
static_assert(offsetof(FBFGNetworkPath_SearchPathResultWayPoint, M_vLocation) == 0x000010, "Member 'FBFGNetworkPath_SearchPathResultWayPoint::M_vLocation' has a wrong offset!");
static_assert(offsetof(FBFGNetworkPath_SearchPathResultWayPoint, M_bHasDistance) == 0x00001C, "Member 'FBFGNetworkPath_SearchPathResultWayPoint::M_bHasDistance' has a wrong offset!");
static_assert(offsetof(FBFGNetworkPath_SearchPathResultWayPoint, M_fDistanceFromStart) == 0x000020, "Member 'FBFGNetworkPath_SearchPathResultWayPoint::M_fDistanceFromStart' has a wrong offset!");

// ScriptStruct BFGCore.BFGVisitedPath
// 0x0070 (0x0070 - 0x0000)
struct FBFGVisitedPath final
{
public:
	class UBFGNetworkPath*                        M_pPath;                                           // 0x0000(0x0008)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EBFGNetworkPathExtremity                      M_eExtremity;                                      // 0x0008(0x0001)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_9[0x3];                                        // 0x0009(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	struct FVector                                M_vLocation;                                       // 0x000C(0x000C)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FGuid                                  M_pathId;                                          // 0x0018(0x0010)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         M_fCost;                                           // 0x0028(0x0004)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         M_fPathLength;                                     // 0x002C(0x0004)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FString                                 M_strPathKey;                                      // 0x0030(0x0010)(ZeroConstructor, Transient, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UBFGNetworkPath*                        M_pPreviousPath;                                   // 0x0040(0x0008)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EBFGNetworkPathExtremity                      M_ePreviousPathExtremity;                          // 0x0048(0x0001)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_49[0x7];                                       // 0x0049(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	class FString                                 M_strPreviousPathKey;                              // 0x0050(0x0010)(ZeroConstructor, Transient, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EBFGNetworkPath_SearchPathMoveType            M_eMoveType;                                       // 0x0060(0x0001)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_61[0x3];                                       // 0x0061(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         M_fDistance;                                       // 0x0064(0x0004)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          M_bVisited;                                        // 0x0068(0x0001)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_69[0x7];                                       // 0x0069(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FBFGVisitedPath) == 0x000008, "Wrong alignment on FBFGVisitedPath");
static_assert(sizeof(FBFGVisitedPath) == 0x000070, "Wrong size on FBFGVisitedPath");
static_assert(offsetof(FBFGVisitedPath, M_pPath) == 0x000000, "Member 'FBFGVisitedPath::M_pPath' has a wrong offset!");
static_assert(offsetof(FBFGVisitedPath, M_eExtremity) == 0x000008, "Member 'FBFGVisitedPath::M_eExtremity' has a wrong offset!");
static_assert(offsetof(FBFGVisitedPath, M_vLocation) == 0x00000C, "Member 'FBFGVisitedPath::M_vLocation' has a wrong offset!");
static_assert(offsetof(FBFGVisitedPath, M_pathId) == 0x000018, "Member 'FBFGVisitedPath::M_pathId' has a wrong offset!");
static_assert(offsetof(FBFGVisitedPath, M_fCost) == 0x000028, "Member 'FBFGVisitedPath::M_fCost' has a wrong offset!");
static_assert(offsetof(FBFGVisitedPath, M_fPathLength) == 0x00002C, "Member 'FBFGVisitedPath::M_fPathLength' has a wrong offset!");
static_assert(offsetof(FBFGVisitedPath, M_strPathKey) == 0x000030, "Member 'FBFGVisitedPath::M_strPathKey' has a wrong offset!");
static_assert(offsetof(FBFGVisitedPath, M_pPreviousPath) == 0x000040, "Member 'FBFGVisitedPath::M_pPreviousPath' has a wrong offset!");
static_assert(offsetof(FBFGVisitedPath, M_ePreviousPathExtremity) == 0x000048, "Member 'FBFGVisitedPath::M_ePreviousPathExtremity' has a wrong offset!");
static_assert(offsetof(FBFGVisitedPath, M_strPreviousPathKey) == 0x000050, "Member 'FBFGVisitedPath::M_strPreviousPathKey' has a wrong offset!");
static_assert(offsetof(FBFGVisitedPath, M_eMoveType) == 0x000060, "Member 'FBFGVisitedPath::M_eMoveType' has a wrong offset!");
static_assert(offsetof(FBFGVisitedPath, M_fDistance) == 0x000064, "Member 'FBFGVisitedPath::M_fDistance' has a wrong offset!");
static_assert(offsetof(FBFGVisitedPath, M_bVisited) == 0x000068, "Member 'FBFGVisitedPath::M_bVisited' has a wrong offset!");

// ScriptStruct BFGCore.BFGNetworkPath_SearchPathHelper
// 0x00A8 (0x00A8 - 0x0000)
struct FBFGNetworkPath_SearchPathHelper final
{
public:
	class UBFGTrafficCrowdManager*                M_pManager;                                        // 0x0000(0x0008)(ExportObject, ZeroConstructor, Transient, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                M_vCurrentLocation;                                // 0x0008(0x000C)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         M_initialDirection;                                // 0x0014(0x0004)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          M_bUseInitialDirection;                            // 0x0018(0x0001)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_19[0x3];                                       // 0x0019(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	int32                                         M_finalDirection;                                  // 0x001C(0x0004)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          M_bUseFinalDirection;                              // 0x0020(0x0001)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_21[0x3];                                       // 0x0021(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         M_fDistanceAtStart;                                // 0x0024(0x0004)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                M_vTargetLocation;                                 // 0x0028(0x000C)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         M_fDistanceAtDestination;                          // 0x0034(0x0004)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TArray<struct FBFGVisitedPathNodeStackItem>   M_aVisitStack;                                     // 0x0038(0x0010)(ZeroConstructor, Transient, ContainsInstancedReference, NativeAccessSpecifierPublic)
	TMap<class FString, struct FBFGVisitedPath>   M_aVisitedPathMap;                                 // 0x0048(0x0050)(ZeroConstructor, Transient, NativeAccessSpecifierPublic)
	TArray<struct FBFGNetworkPath_SearchPathResultWayPoint> M_aSearchResult;                                   // 0x0098(0x0010)(ZeroConstructor, Transient, NativeAccessSpecifierPublic)
};
static_assert(alignof(FBFGNetworkPath_SearchPathHelper) == 0x000008, "Wrong alignment on FBFGNetworkPath_SearchPathHelper");
static_assert(sizeof(FBFGNetworkPath_SearchPathHelper) == 0x0000A8, "Wrong size on FBFGNetworkPath_SearchPathHelper");
static_assert(offsetof(FBFGNetworkPath_SearchPathHelper, M_pManager) == 0x000000, "Member 'FBFGNetworkPath_SearchPathHelper::M_pManager' has a wrong offset!");
static_assert(offsetof(FBFGNetworkPath_SearchPathHelper, M_vCurrentLocation) == 0x000008, "Member 'FBFGNetworkPath_SearchPathHelper::M_vCurrentLocation' has a wrong offset!");
static_assert(offsetof(FBFGNetworkPath_SearchPathHelper, M_initialDirection) == 0x000014, "Member 'FBFGNetworkPath_SearchPathHelper::M_initialDirection' has a wrong offset!");
static_assert(offsetof(FBFGNetworkPath_SearchPathHelper, M_bUseInitialDirection) == 0x000018, "Member 'FBFGNetworkPath_SearchPathHelper::M_bUseInitialDirection' has a wrong offset!");
static_assert(offsetof(FBFGNetworkPath_SearchPathHelper, M_finalDirection) == 0x00001C, "Member 'FBFGNetworkPath_SearchPathHelper::M_finalDirection' has a wrong offset!");
static_assert(offsetof(FBFGNetworkPath_SearchPathHelper, M_bUseFinalDirection) == 0x000020, "Member 'FBFGNetworkPath_SearchPathHelper::M_bUseFinalDirection' has a wrong offset!");
static_assert(offsetof(FBFGNetworkPath_SearchPathHelper, M_fDistanceAtStart) == 0x000024, "Member 'FBFGNetworkPath_SearchPathHelper::M_fDistanceAtStart' has a wrong offset!");
static_assert(offsetof(FBFGNetworkPath_SearchPathHelper, M_vTargetLocation) == 0x000028, "Member 'FBFGNetworkPath_SearchPathHelper::M_vTargetLocation' has a wrong offset!");
static_assert(offsetof(FBFGNetworkPath_SearchPathHelper, M_fDistanceAtDestination) == 0x000034, "Member 'FBFGNetworkPath_SearchPathHelper::M_fDistanceAtDestination' has a wrong offset!");
static_assert(offsetof(FBFGNetworkPath_SearchPathHelper, M_aVisitStack) == 0x000038, "Member 'FBFGNetworkPath_SearchPathHelper::M_aVisitStack' has a wrong offset!");
static_assert(offsetof(FBFGNetworkPath_SearchPathHelper, M_aVisitedPathMap) == 0x000048, "Member 'FBFGNetworkPath_SearchPathHelper::M_aVisitedPathMap' has a wrong offset!");
static_assert(offsetof(FBFGNetworkPath_SearchPathHelper, M_aSearchResult) == 0x000098, "Member 'FBFGNetworkPath_SearchPathHelper::M_aSearchResult' has a wrong offset!");

// ScriptStruct BFGCore.BFGMagnetData
// 0x0008 (0x0008 - 0x0000)
struct FBFGMagnetData final
{
public:
	float                                         M_fRange;                                          // 0x0000(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         M_fSpeed;                                          // 0x0004(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FBFGMagnetData) == 0x000004, "Wrong alignment on FBFGMagnetData");
static_assert(sizeof(FBFGMagnetData) == 0x000008, "Wrong size on FBFGMagnetData");
static_assert(offsetof(FBFGMagnetData, M_fRange) == 0x000000, "Member 'FBFGMagnetData::M_fRange' has a wrong offset!");
static_assert(offsetof(FBFGMagnetData, M_fSpeed) == 0x000004, "Member 'FBFGMagnetData::M_fSpeed' has a wrong offset!");

// ScriptStruct BFGCore.BFGPlayerState_UpgradesSet
// 0x0010 (0x0010 - 0x0000)
struct alignas(0x08) FBFGPlayerState_UpgradesSet final
{
public:
	uint8                                         Pad_0[0x10];                                       // 0x0000(0x0010)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FBFGPlayerState_UpgradesSet) == 0x000008, "Wrong alignment on FBFGPlayerState_UpgradesSet");
static_assert(sizeof(FBFGPlayerState_UpgradesSet) == 0x000010, "Wrong size on FBFGPlayerState_UpgradesSet");

// ScriptStruct BFGCore.BFGPlayerState_UpgradesQueryResponse
// 0x0018 (0x0018 - 0x0000)
struct FBFGPlayerState_UpgradesQueryResponse final
{
public:
	struct FGameplayTag                           M_oUpgradesQueryTag;                               // 0x0000(0x0008)(BlueprintVisible, BlueprintReadOnly, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TArray<struct FBFGPlayerState_UpgradesSet>    M_aUpgradeSets;                                    // 0x0008(0x0010)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(FBFGPlayerState_UpgradesQueryResponse) == 0x000008, "Wrong alignment on FBFGPlayerState_UpgradesQueryResponse");
static_assert(sizeof(FBFGPlayerState_UpgradesQueryResponse) == 0x000018, "Wrong size on FBFGPlayerState_UpgradesQueryResponse");
static_assert(offsetof(FBFGPlayerState_UpgradesQueryResponse, M_oUpgradesQueryTag) == 0x000000, "Member 'FBFGPlayerState_UpgradesQueryResponse::M_oUpgradesQueryTag' has a wrong offset!");
static_assert(offsetof(FBFGPlayerState_UpgradesQueryResponse, M_aUpgradeSets) == 0x000008, "Member 'FBFGPlayerState_UpgradesQueryResponse::M_aUpgradeSets' has a wrong offset!");

// ScriptStruct BFGCore.BFGMenuGameOptionEntryInfo
// 0x0020 (0x0020 - 0x0000)
struct FBFGMenuGameOptionEntryInfo final
{
public:
	EBFGMenuGameOptions                           M_eOptionID;                                       // 0x0000(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EBFGMenuGameOptionType                        M_eOptionType;                                     // 0x0001(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EBFGMenuGameOptionCategory                    M_eCategory;                                       // 0x0002(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_3[0x5];                                        // 0x0003(0x0005)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<class FText>                           M_astrParamsText;                                  // 0x0008(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, NativeAccessSpecifierPublic)
	bool                                          M_bDisableInOptionsMenu;                           // 0x0018(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          M_bEnableForPC;                                    // 0x0019(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          M_bEnableForOrbis;                                 // 0x001A(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          M_bEnableForDurango;                               // 0x001B(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          M_bEnableOnlyForEnhancedConsoles;                  // 0x001C(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1D[0x3];                                       // 0x001D(0x0003)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FBFGMenuGameOptionEntryInfo) == 0x000008, "Wrong alignment on FBFGMenuGameOptionEntryInfo");
static_assert(sizeof(FBFGMenuGameOptionEntryInfo) == 0x000020, "Wrong size on FBFGMenuGameOptionEntryInfo");
static_assert(offsetof(FBFGMenuGameOptionEntryInfo, M_eOptionID) == 0x000000, "Member 'FBFGMenuGameOptionEntryInfo::M_eOptionID' has a wrong offset!");
static_assert(offsetof(FBFGMenuGameOptionEntryInfo, M_eOptionType) == 0x000001, "Member 'FBFGMenuGameOptionEntryInfo::M_eOptionType' has a wrong offset!");
static_assert(offsetof(FBFGMenuGameOptionEntryInfo, M_eCategory) == 0x000002, "Member 'FBFGMenuGameOptionEntryInfo::M_eCategory' has a wrong offset!");
static_assert(offsetof(FBFGMenuGameOptionEntryInfo, M_astrParamsText) == 0x000008, "Member 'FBFGMenuGameOptionEntryInfo::M_astrParamsText' has a wrong offset!");
static_assert(offsetof(FBFGMenuGameOptionEntryInfo, M_bDisableInOptionsMenu) == 0x000018, "Member 'FBFGMenuGameOptionEntryInfo::M_bDisableInOptionsMenu' has a wrong offset!");
static_assert(offsetof(FBFGMenuGameOptionEntryInfo, M_bEnableForPC) == 0x000019, "Member 'FBFGMenuGameOptionEntryInfo::M_bEnableForPC' has a wrong offset!");
static_assert(offsetof(FBFGMenuGameOptionEntryInfo, M_bEnableForOrbis) == 0x00001A, "Member 'FBFGMenuGameOptionEntryInfo::M_bEnableForOrbis' has a wrong offset!");
static_assert(offsetof(FBFGMenuGameOptionEntryInfo, M_bEnableForDurango) == 0x00001B, "Member 'FBFGMenuGameOptionEntryInfo::M_bEnableForDurango' has a wrong offset!");
static_assert(offsetof(FBFGMenuGameOptionEntryInfo, M_bEnableOnlyForEnhancedConsoles) == 0x00001C, "Member 'FBFGMenuGameOptionEntryInfo::M_bEnableOnlyForEnhancedConsoles' has a wrong offset!");

// ScriptStruct BFGCore.BFGAchievementsCache
// 0x0010 (0x0010 - 0x0000)
struct FBFGAchievementsCache final
{
public:
	class FName                                   M_strIdentifier;                                   // 0x0000(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         M_fProgress;                                       // 0x0008(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         M_fTimer;                                          // 0x000C(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FBFGAchievementsCache) == 0x000004, "Wrong alignment on FBFGAchievementsCache");
static_assert(sizeof(FBFGAchievementsCache) == 0x000010, "Wrong size on FBFGAchievementsCache");
static_assert(offsetof(FBFGAchievementsCache, M_strIdentifier) == 0x000000, "Member 'FBFGAchievementsCache::M_strIdentifier' has a wrong offset!");
static_assert(offsetof(FBFGAchievementsCache, M_fProgress) == 0x000008, "Member 'FBFGAchievementsCache::M_fProgress' has a wrong offset!");
static_assert(offsetof(FBFGAchievementsCache, M_fTimer) == 0x00000C, "Member 'FBFGAchievementsCache::M_fTimer' has a wrong offset!");

// ScriptStruct BFGCore.BFGActivationEntry
// 0x00D0 (0x00D0 - 0x0000)
struct FBFGActivationEntry final
{
public:
	uint8                                         Pad_0[0x8];                                        // 0x0000(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	class AActor*                                 M_pActor;                                          // 0x0008(0x0008)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UBFGActorComponent_MentallyInteractable* M_pMentalComponent;                                // 0x0010(0x0008)(ExportObject, ZeroConstructor, Transient, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UBFGActorComponent_CharacterPhysics*    M_pPhysicsComponent;                               // 0x0018(0x0008)(ExportObject, ZeroConstructor, Transient, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_20[0xB0];                                      // 0x0020(0x00B0)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FBFGActivationEntry) == 0x000008, "Wrong alignment on FBFGActivationEntry");
static_assert(sizeof(FBFGActivationEntry) == 0x0000D0, "Wrong size on FBFGActivationEntry");
static_assert(offsetof(FBFGActivationEntry, M_pActor) == 0x000008, "Member 'FBFGActivationEntry::M_pActor' has a wrong offset!");
static_assert(offsetof(FBFGActivationEntry, M_pMentalComponent) == 0x000010, "Member 'FBFGActivationEntry::M_pMentalComponent' has a wrong offset!");
static_assert(offsetof(FBFGActivationEntry, M_pPhysicsComponent) == 0x000018, "Member 'FBFGActivationEntry::M_pPhysicsComponent' has a wrong offset!");

// ScriptStruct BFGCore.BFGWitnessedAlertEventInstance
// 0x000C (0x000C - 0x0000)
struct FBFGWitnessedAlertEventInstance final
{
public:
	float                                         M_fTimer;                                          // 0x0000(0x0004)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TWeakObjectPtr<class AActor>                  M_pInstigator;                                     // 0x0004(0x0008)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FBFGWitnessedAlertEventInstance) == 0x000004, "Wrong alignment on FBFGWitnessedAlertEventInstance");
static_assert(sizeof(FBFGWitnessedAlertEventInstance) == 0x00000C, "Wrong size on FBFGWitnessedAlertEventInstance");
static_assert(offsetof(FBFGWitnessedAlertEventInstance, M_fTimer) == 0x000000, "Member 'FBFGWitnessedAlertEventInstance::M_fTimer' has a wrong offset!");
static_assert(offsetof(FBFGWitnessedAlertEventInstance, M_pInstigator) == 0x000004, "Member 'FBFGWitnessedAlertEventInstance::M_pInstigator' has a wrong offset!");

// ScriptStruct BFGCore.BFGWitnessedAlertEventSet
// 0x0028 (0x0028 - 0x0000)
struct FBFGWitnessedAlertEventSet final
{
public:
	float                                         M_fCooldDown;                                      // 0x0000(0x0004)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_4[0x4];                                        // 0x0004(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class FString                                 M_strAlertTriggerName;                             // 0x0008(0x0010)(ZeroConstructor, Transient, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TArray<struct FBFGWitnessedAlertEventInstance> Instances;                                         // 0x0018(0x0010)(ZeroConstructor, Transient, NativeAccessSpecifierPublic)
};
static_assert(alignof(FBFGWitnessedAlertEventSet) == 0x000008, "Wrong alignment on FBFGWitnessedAlertEventSet");
static_assert(sizeof(FBFGWitnessedAlertEventSet) == 0x000028, "Wrong size on FBFGWitnessedAlertEventSet");
static_assert(offsetof(FBFGWitnessedAlertEventSet, M_fCooldDown) == 0x000000, "Member 'FBFGWitnessedAlertEventSet::M_fCooldDown' has a wrong offset!");
static_assert(offsetof(FBFGWitnessedAlertEventSet, M_strAlertTriggerName) == 0x000008, "Member 'FBFGWitnessedAlertEventSet::M_strAlertTriggerName' has a wrong offset!");
static_assert(offsetof(FBFGWitnessedAlertEventSet, Instances) == 0x000018, "Member 'FBFGWitnessedAlertEventSet::Instances' has a wrong offset!");

// ScriptStruct BFGCore.BFGCameraHandleModeData
// 0x0034 (0x0034 - 0x0000)
struct FBFGCameraHandleModeData final
{
public:
	struct FVector                                M_vDefaultLocation;                                // 0x0000(0x000C)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FRotator                               M_oDefaultRotation;                                // 0x000C(0x000C)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
	float                                         M_fViewPitchMin;                                   // 0x0018(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         M_fViewPitchMax;                                   // 0x001C(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         M_fViewYawMin;                                     // 0x0020(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         M_fViewYawMax;                                     // 0x0024(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         M_fViewRollMin;                                    // 0x0028(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         M_fViewRollMax;                                    // 0x002C(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          M_bCameraLocationLagEnabled;                       // 0x0030(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_31[0x3];                                       // 0x0031(0x0003)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FBFGCameraHandleModeData) == 0x000004, "Wrong alignment on FBFGCameraHandleModeData");
static_assert(sizeof(FBFGCameraHandleModeData) == 0x000034, "Wrong size on FBFGCameraHandleModeData");
static_assert(offsetof(FBFGCameraHandleModeData, M_vDefaultLocation) == 0x000000, "Member 'FBFGCameraHandleModeData::M_vDefaultLocation' has a wrong offset!");
static_assert(offsetof(FBFGCameraHandleModeData, M_oDefaultRotation) == 0x00000C, "Member 'FBFGCameraHandleModeData::M_oDefaultRotation' has a wrong offset!");
static_assert(offsetof(FBFGCameraHandleModeData, M_fViewPitchMin) == 0x000018, "Member 'FBFGCameraHandleModeData::M_fViewPitchMin' has a wrong offset!");
static_assert(offsetof(FBFGCameraHandleModeData, M_fViewPitchMax) == 0x00001C, "Member 'FBFGCameraHandleModeData::M_fViewPitchMax' has a wrong offset!");
static_assert(offsetof(FBFGCameraHandleModeData, M_fViewYawMin) == 0x000020, "Member 'FBFGCameraHandleModeData::M_fViewYawMin' has a wrong offset!");
static_assert(offsetof(FBFGCameraHandleModeData, M_fViewYawMax) == 0x000024, "Member 'FBFGCameraHandleModeData::M_fViewYawMax' has a wrong offset!");
static_assert(offsetof(FBFGCameraHandleModeData, M_fViewRollMin) == 0x000028, "Member 'FBFGCameraHandleModeData::M_fViewRollMin' has a wrong offset!");
static_assert(offsetof(FBFGCameraHandleModeData, M_fViewRollMax) == 0x00002C, "Member 'FBFGCameraHandleModeData::M_fViewRollMax' has a wrong offset!");
static_assert(offsetof(FBFGCameraHandleModeData, M_bCameraLocationLagEnabled) == 0x000030, "Member 'FBFGCameraHandleModeData::M_bCameraLocationLagEnabled' has a wrong offset!");

// ScriptStruct BFGCore.BFGNetworkPath_RelativeDistanceCalculatorNavigationProxy
// 0x0030 (0x0030 - 0x0000)
struct FBFGNetworkPath_RelativeDistanceCalculatorNavigationProxy final
{
public:
	class UBFGNetworkPath*                        M_pCurrentPath;                                    // 0x0000(0x0008)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EBFGNetworkPathExtremity                      M_eCurrentExtremity;                               // 0x0008(0x0001)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_9[0x7];                                        // 0x0009(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	class UBFGNetworkPath*                        M_pNextPath;                                       // 0x0010(0x0008)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EBFGNetworkPathExtremity                      M_eNextTargetExtremity;                            // 0x0018(0x0001)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_19[0xF];                                       // 0x0019(0x000F)(Fixing Size After Last Property [ Dumper-7 ])
	class UBFGNetworkPathAgent_Navigation*        M_pNavigation;                                     // 0x0028(0x0008)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FBFGNetworkPath_RelativeDistanceCalculatorNavigationProxy) == 0x000008, "Wrong alignment on FBFGNetworkPath_RelativeDistanceCalculatorNavigationProxy");
static_assert(sizeof(FBFGNetworkPath_RelativeDistanceCalculatorNavigationProxy) == 0x000030, "Wrong size on FBFGNetworkPath_RelativeDistanceCalculatorNavigationProxy");
static_assert(offsetof(FBFGNetworkPath_RelativeDistanceCalculatorNavigationProxy, M_pCurrentPath) == 0x000000, "Member 'FBFGNetworkPath_RelativeDistanceCalculatorNavigationProxy::M_pCurrentPath' has a wrong offset!");
static_assert(offsetof(FBFGNetworkPath_RelativeDistanceCalculatorNavigationProxy, M_eCurrentExtremity) == 0x000008, "Member 'FBFGNetworkPath_RelativeDistanceCalculatorNavigationProxy::M_eCurrentExtremity' has a wrong offset!");
static_assert(offsetof(FBFGNetworkPath_RelativeDistanceCalculatorNavigationProxy, M_pNextPath) == 0x000010, "Member 'FBFGNetworkPath_RelativeDistanceCalculatorNavigationProxy::M_pNextPath' has a wrong offset!");
static_assert(offsetof(FBFGNetworkPath_RelativeDistanceCalculatorNavigationProxy, M_eNextTargetExtremity) == 0x000018, "Member 'FBFGNetworkPath_RelativeDistanceCalculatorNavigationProxy::M_eNextTargetExtremity' has a wrong offset!");
static_assert(offsetof(FBFGNetworkPath_RelativeDistanceCalculatorNavigationProxy, M_pNavigation) == 0x000028, "Member 'FBFGNetworkPath_RelativeDistanceCalculatorNavigationProxy::M_pNavigation' has a wrong offset!");

// ScriptStruct BFGCore.BFGCameraData
// 0x0048 (0x0048 - 0x0000)
struct alignas(0x04) FBFGCameraData final
{
public:
	uint8                                         Pad_0[0x48];                                       // 0x0000(0x0048)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FBFGCameraData) == 0x000004, "Wrong alignment on FBFGCameraData");
static_assert(sizeof(FBFGCameraData) == 0x000048, "Wrong size on FBFGCameraData");

// ScriptStruct BFGCore.BFGLatentEquipData
// 0x0010 (0x0010 - 0x0000)
struct alignas(0x08) FBFGLatentEquipData final
{
public:
	uint8                                         Pad_0[0x10];                                       // 0x0000(0x0010)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FBFGLatentEquipData) == 0x000008, "Wrong alignment on FBFGLatentEquipData");
static_assert(sizeof(FBFGLatentEquipData) == 0x000010, "Wrong size on FBFGLatentEquipData");

// ScriptStruct BFGCore.WaveParameter
// 0x000C (0x000C - 0x0000)
struct FWaveParameter final
{
public:
	float                                         M_fNumOfWaves;                                     // 0x0000(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         M_fSteepness;                                      // 0x0004(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         M_fHorizontalShift;                                // 0x0008(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FWaveParameter) == 0x000004, "Wrong alignment on FWaveParameter");
static_assert(sizeof(FWaveParameter) == 0x00000C, "Wrong size on FWaveParameter");
static_assert(offsetof(FWaveParameter, M_fNumOfWaves) == 0x000000, "Member 'FWaveParameter::M_fNumOfWaves' has a wrong offset!");
static_assert(offsetof(FWaveParameter, M_fSteepness) == 0x000004, "Member 'FWaveParameter::M_fSteepness' has a wrong offset!");
static_assert(offsetof(FWaveParameter, M_fHorizontalShift) == 0x000008, "Member 'FWaveParameter::M_fHorizontalShift' has a wrong offset!");

// ScriptStruct BFGCore.GameplayEffectTagsTriggerData
// 0x0038 (0x0038 - 0x0000)
struct FGameplayEffectTagsTriggerData final
{
public:
	struct FGameplayTagContainer                  M_oGameplayEffectTags;                             // 0x0000(0x0020)(Edit, NativeAccessSpecifierPublic)
	TArray<EBFGEffect_Identifier>                 M_aEffectIdentifiers;                              // 0x0020(0x0010)(Edit, ZeroConstructor, NativeAccessSpecifierPublic)
	class FName                                   M_oAttachSocketName;                               // 0x0030(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FGameplayEffectTagsTriggerData) == 0x000008, "Wrong alignment on FGameplayEffectTagsTriggerData");
static_assert(sizeof(FGameplayEffectTagsTriggerData) == 0x000038, "Wrong size on FGameplayEffectTagsTriggerData");
static_assert(offsetof(FGameplayEffectTagsTriggerData, M_oGameplayEffectTags) == 0x000000, "Member 'FGameplayEffectTagsTriggerData::M_oGameplayEffectTags' has a wrong offset!");
static_assert(offsetof(FGameplayEffectTagsTriggerData, M_aEffectIdentifiers) == 0x000020, "Member 'FGameplayEffectTagsTriggerData::M_aEffectIdentifiers' has a wrong offset!");
static_assert(offsetof(FGameplayEffectTagsTriggerData, M_oAttachSocketName) == 0x000030, "Member 'FGameplayEffectTagsTriggerData::M_oAttachSocketName' has a wrong offset!");

// ScriptStruct BFGCore.DashPhaseParameters
// 0x0038 (0x0038 - 0x0000)
struct FDashPhaseParameters final
{
public:
	float                                         M_fMaxAcceleration;                                // 0x0000(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         M_fMaxSpeed;                                       // 0x0004(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         M_fDuration;                                       // 0x0008(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         M_fGravityScale;                                   // 0x000C(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          M_bSkipPhaseOnDamage;                              // 0x0010(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_11[0x7];                                       // 0x0011(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	struct FGameplayTagContainer                  M_oAppliedGameplayEffects;                         // 0x0018(0x0020)(Edit, NativeAccessSpecifierPublic)
};
static_assert(alignof(FDashPhaseParameters) == 0x000008, "Wrong alignment on FDashPhaseParameters");
static_assert(sizeof(FDashPhaseParameters) == 0x000038, "Wrong size on FDashPhaseParameters");
static_assert(offsetof(FDashPhaseParameters, M_fMaxAcceleration) == 0x000000, "Member 'FDashPhaseParameters::M_fMaxAcceleration' has a wrong offset!");
static_assert(offsetof(FDashPhaseParameters, M_fMaxSpeed) == 0x000004, "Member 'FDashPhaseParameters::M_fMaxSpeed' has a wrong offset!");
static_assert(offsetof(FDashPhaseParameters, M_fDuration) == 0x000008, "Member 'FDashPhaseParameters::M_fDuration' has a wrong offset!");
static_assert(offsetof(FDashPhaseParameters, M_fGravityScale) == 0x00000C, "Member 'FDashPhaseParameters::M_fGravityScale' has a wrong offset!");
static_assert(offsetof(FDashPhaseParameters, M_bSkipPhaseOnDamage) == 0x000010, "Member 'FDashPhaseParameters::M_bSkipPhaseOnDamage' has a wrong offset!");
static_assert(offsetof(FDashPhaseParameters, M_oAppliedGameplayEffects) == 0x000018, "Member 'FDashPhaseParameters::M_oAppliedGameplayEffects' has a wrong offset!");

// ScriptStruct BFGCore.BFGQuest_Failure
// 0x0088 (0x0088 - 0x0000)
struct FBFGQuest_Failure final
{
public:
	TArray<class FText>                           M_aFailVOEntries;                                  // 0x0000(0x0010)(Edit, ZeroConstructor, DisableEditOnInstance, NativeAccessSpecifierPublic)
	bool                                          M_bFailVOBlocks;                                   // 0x0010(0x0001)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_11[0x7];                                       // 0x0011(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	TSoftClassPtr<class UClass>                   M_softFailNarrativeSequence;                       // 0x0018(0x0028)(Edit, DisableEditOnInstance, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FText                                   M_strFailReason;                                   // 0x0040(0x0018)(Edit, DisableEditOnInstance, NativeAccessSpecifierPublic)
	bool                                          M_bShowFailReasonOnHUD;                            // 0x0058(0x0001)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_59[0x7];                                       // 0x0059(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	TSoftObjectPtr<class UBFGDataAsset_NewspaperInfo> M_softFailNewspaper;                               // 0x0060(0x0028)(Edit, DisableEditOnInstance, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FBFGQuest_Failure) == 0x000008, "Wrong alignment on FBFGQuest_Failure");
static_assert(sizeof(FBFGQuest_Failure) == 0x000088, "Wrong size on FBFGQuest_Failure");
static_assert(offsetof(FBFGQuest_Failure, M_aFailVOEntries) == 0x000000, "Member 'FBFGQuest_Failure::M_aFailVOEntries' has a wrong offset!");
static_assert(offsetof(FBFGQuest_Failure, M_bFailVOBlocks) == 0x000010, "Member 'FBFGQuest_Failure::M_bFailVOBlocks' has a wrong offset!");
static_assert(offsetof(FBFGQuest_Failure, M_softFailNarrativeSequence) == 0x000018, "Member 'FBFGQuest_Failure::M_softFailNarrativeSequence' has a wrong offset!");
static_assert(offsetof(FBFGQuest_Failure, M_strFailReason) == 0x000040, "Member 'FBFGQuest_Failure::M_strFailReason' has a wrong offset!");
static_assert(offsetof(FBFGQuest_Failure, M_bShowFailReasonOnHUD) == 0x000058, "Member 'FBFGQuest_Failure::M_bShowFailReasonOnHUD' has a wrong offset!");
static_assert(offsetof(FBFGQuest_Failure, M_softFailNewspaper) == 0x000060, "Member 'FBFGQuest_Failure::M_softFailNewspaper' has a wrong offset!");

// ScriptStruct BFGCore.BFGChaseTargetSite
// 0x0008 (0x0008 - 0x0000)
struct FBFGChaseTargetSite final
{
public:
	class UBFGNetworkPath*                        M_pNetworkPath;                                    // 0x0000(0x0008)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FBFGChaseTargetSite) == 0x000008, "Wrong alignment on FBFGChaseTargetSite");
static_assert(sizeof(FBFGChaseTargetSite) == 0x000008, "Wrong size on FBFGChaseTargetSite");
static_assert(offsetof(FBFGChaseTargetSite, M_pNetworkPath) == 0x000000, "Member 'FBFGChaseTargetSite::M_pNetworkPath' has a wrong offset!");

// ScriptStruct BFGCore.BFGAgentInstanceOpportunityData
// 0x00C8 (0x00C8 - 0x0000)
struct FBFGAgentInstanceOpportunityData final
{
public:
	bool                                          M_bEnabled;                                        // 0x0000(0x0001)(Edit, BlueprintVisible, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          M_bActivateArrow;                                  // 0x0001(0x0001)(Edit, BlueprintVisible, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          M_bIsEnemyMarker;                                  // 0x0002(0x0001)(Edit, BlueprintVisible, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          M_bActivateIcon;                                   // 0x0003(0x0001)(Edit, BlueprintVisible, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          M_bActivateText;                                   // 0x0004(0x0001)(Edit, BlueprintVisible, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          M_bActivateRadarMarker;                            // 0x0005(0x0001)(Edit, BlueprintVisible, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_6[0x2];                                        // 0x0006(0x0002)(Fixing Size After Last Property [ Dumper-7 ])
	struct FSlateBrush                            M_OverrideBrush;                                   // 0x0008(0x0088)(Edit, BlueprintVisible, EditConst, NativeAccessSpecifierPublic)
	class FText                                   M_InteractDisplayText;                             // 0x0090(0x0018)(Edit, BlueprintVisible, EditConst, NativeAccessSpecifierPublic)
	class FString                                 M_strInteractDecoratorString;                      // 0x00A8(0x0010)(Edit, BlueprintVisible, ZeroConstructor, EditConst, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          M_bIsDeathPersistant;                              // 0x00B8(0x0001)(Edit, BlueprintVisible, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          M_bIsPKPersistant;                                 // 0x00B9(0x0001)(Edit, BlueprintVisible, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          M_bIsPlayer;                                       // 0x00BA(0x0001)(Edit, BlueprintVisible, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_BB[0x1];                                       // 0x00BB(0x0001)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         M_fDisplayRange;                                   // 0x00BC(0x0004)(Edit, BlueprintVisible, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          M_bLinkToMentallyInteractable;                     // 0x00C0(0x0001)(Edit, BlueprintVisible, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          M_bLightweight;                                    // 0x00C1(0x0001)(Edit, BlueprintVisible, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          M_bUseWeaponTargetInsteadOfPsiMarker;              // 0x00C2(0x0001)(Edit, BlueprintVisible, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_C3[0x5];                                       // 0x00C3(0x0005)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FBFGAgentInstanceOpportunityData) == 0x000008, "Wrong alignment on FBFGAgentInstanceOpportunityData");
static_assert(sizeof(FBFGAgentInstanceOpportunityData) == 0x0000C8, "Wrong size on FBFGAgentInstanceOpportunityData");
static_assert(offsetof(FBFGAgentInstanceOpportunityData, M_bEnabled) == 0x000000, "Member 'FBFGAgentInstanceOpportunityData::M_bEnabled' has a wrong offset!");
static_assert(offsetof(FBFGAgentInstanceOpportunityData, M_bActivateArrow) == 0x000001, "Member 'FBFGAgentInstanceOpportunityData::M_bActivateArrow' has a wrong offset!");
static_assert(offsetof(FBFGAgentInstanceOpportunityData, M_bIsEnemyMarker) == 0x000002, "Member 'FBFGAgentInstanceOpportunityData::M_bIsEnemyMarker' has a wrong offset!");
static_assert(offsetof(FBFGAgentInstanceOpportunityData, M_bActivateIcon) == 0x000003, "Member 'FBFGAgentInstanceOpportunityData::M_bActivateIcon' has a wrong offset!");
static_assert(offsetof(FBFGAgentInstanceOpportunityData, M_bActivateText) == 0x000004, "Member 'FBFGAgentInstanceOpportunityData::M_bActivateText' has a wrong offset!");
static_assert(offsetof(FBFGAgentInstanceOpportunityData, M_bActivateRadarMarker) == 0x000005, "Member 'FBFGAgentInstanceOpportunityData::M_bActivateRadarMarker' has a wrong offset!");
static_assert(offsetof(FBFGAgentInstanceOpportunityData, M_OverrideBrush) == 0x000008, "Member 'FBFGAgentInstanceOpportunityData::M_OverrideBrush' has a wrong offset!");
static_assert(offsetof(FBFGAgentInstanceOpportunityData, M_InteractDisplayText) == 0x000090, "Member 'FBFGAgentInstanceOpportunityData::M_InteractDisplayText' has a wrong offset!");
static_assert(offsetof(FBFGAgentInstanceOpportunityData, M_strInteractDecoratorString) == 0x0000A8, "Member 'FBFGAgentInstanceOpportunityData::M_strInteractDecoratorString' has a wrong offset!");
static_assert(offsetof(FBFGAgentInstanceOpportunityData, M_bIsDeathPersistant) == 0x0000B8, "Member 'FBFGAgentInstanceOpportunityData::M_bIsDeathPersistant' has a wrong offset!");
static_assert(offsetof(FBFGAgentInstanceOpportunityData, M_bIsPKPersistant) == 0x0000B9, "Member 'FBFGAgentInstanceOpportunityData::M_bIsPKPersistant' has a wrong offset!");
static_assert(offsetof(FBFGAgentInstanceOpportunityData, M_bIsPlayer) == 0x0000BA, "Member 'FBFGAgentInstanceOpportunityData::M_bIsPlayer' has a wrong offset!");
static_assert(offsetof(FBFGAgentInstanceOpportunityData, M_fDisplayRange) == 0x0000BC, "Member 'FBFGAgentInstanceOpportunityData::M_fDisplayRange' has a wrong offset!");
static_assert(offsetof(FBFGAgentInstanceOpportunityData, M_bLinkToMentallyInteractable) == 0x0000C0, "Member 'FBFGAgentInstanceOpportunityData::M_bLinkToMentallyInteractable' has a wrong offset!");
static_assert(offsetof(FBFGAgentInstanceOpportunityData, M_bLightweight) == 0x0000C1, "Member 'FBFGAgentInstanceOpportunityData::M_bLightweight' has a wrong offset!");
static_assert(offsetof(FBFGAgentInstanceOpportunityData, M_bUseWeaponTargetInsteadOfPsiMarker) == 0x0000C2, "Member 'FBFGAgentInstanceOpportunityData::M_bUseWeaponTargetInsteadOfPsiMarker' has a wrong offset!");

// ScriptStruct BFGCore.BFGDataTableRowReference
// 0x0008 (0x0008 - 0x0000)
struct FBFGDataTableRowReference final
{
public:
	class FName                                   M_RowName;                                         // 0x0000(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FBFGDataTableRowReference) == 0x000004, "Wrong alignment on FBFGDataTableRowReference");
static_assert(sizeof(FBFGDataTableRowReference) == 0x000008, "Wrong size on FBFGDataTableRowReference");
static_assert(offsetof(FBFGDataTableRowReference, M_RowName) == 0x000000, "Member 'FBFGDataTableRowReference::M_RowName' has a wrong offset!");

// ScriptStruct BFGCore.BFGAgentInstanceSaveRestoreData
// 0x0240 (0x0240 - 0x0000)
struct FBFGAgentInstanceSaveRestoreData final
{
public:
	struct FBFGAgentInstanceOpportunityData       M_OpportunityData;                                 // 0x0000(0x00C8)(Protected, NativeAccessSpecifierProtected)
	bool                                          M_bHasSavedData;                                   // 0x00C8(0x0001)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_C9[0x7];                                       // 0x00C9(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	class UBFGNetworkPathAgent*                   M_pAgent;                                          // 0x00D0(0x0008)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          M_bLODEnabled;                                     // 0x00D8(0x0001)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          M_bCanBeTargetedByMentalAbilities;                 // 0x00D9(0x0001)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          M_bCanBeTargetedByWeapons;                         // 0x00DA(0x0001)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          M_bUsesCharacterPhysics;                           // 0x00DB(0x0001)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_DC[0x4];                                       // 0x00DC(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	struct FGameplayTagContainer                  M_pExcludedFromAbilitiesTags;                      // 0x00E0(0x0020)(Transient, Protected, NativeAccessSpecifierProtected)
	TArray<class FName>                           M_aTags;                                           // 0x0100(0x0010)(ZeroConstructor, Transient, Protected, NativeAccessSpecifierProtected)
	struct FGameplayTagContainer                  M_gameplayTags;                                    // 0x0110(0x0020)(Transient, Protected, NativeAccessSpecifierProtected)
	struct FGameplayTagContainer                  M_gameplayTagsEffect;                              // 0x0130(0x0020)(Transient, Protected, NativeAccessSpecifierProtected)
	struct FBFGActorData_InstanceCustomData       M_customData;                                      // 0x0150(0x0060)(Transient, Protected, NativeAccessSpecifierProtected)
	EBFGFaction                                   M_eFaction;                                        // 0x01B0(0x0001)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_1B1[0x3];                                      // 0x01B1(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         M_fMonetaryValue;                                  // 0x01B4(0x0004)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          M_bEnabled;                                        // 0x01B8(0x0001)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_1B9[0x3];                                      // 0x01B9(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         M_fHoldTime;                                       // 0x01BC(0x0004)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	EBFGAnimation_MentalAbilityPosture            M_eAnimationPosture;                               // 0x01C0(0x0001)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_1C1[0x7];                                      // 0x01C1(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	struct FGameplayTagContainer                  M_oCompetentAbilities;                             // 0x01C8(0x0020)(Transient, Protected, NativeAccessSpecifierProtected)
	class UDataTable*                             M_pDataTable;                                      // 0x01E8(0x0008)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TArray<struct FBFGDataTableRowReference>      M_aVariationPool;                                  // 0x01F0(0x0010)(ZeroConstructor, Transient, Protected, NativeAccessSpecifierProtected)
	class FName                                   M_ActiveVariation;                                 // 0x0200(0x0008)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TArray<struct FBFGAIEquipCommand>             M_aPendingEquipCommand;                            // 0x0208(0x0010)(ZeroConstructor, Transient, Protected, NativeAccessSpecifierProtected)
	bool                                          M_bIsMissionTriggerZoneActivator;                  // 0x0218(0x0001)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          M_bRadarEnabled;                                   // 0x0219(0x0001)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_21A[0x6];                                      // 0x021A(0x0006)(Fixing Size After Last Property [ Dumper-7 ])
	class UBFGDataAsset_RadarObjectStaticInfo*    M_pStaticInfo;                                     // 0x0220(0x0008)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UBFGDataAsset_RadarObjectStaticInfo*    M_pStaticInfo_Override;                            // 0x0228(0x0008)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         M_fLocationUpdateDistance;                         // 0x0230(0x0004)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_234[0x4];                                      // 0x0234(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class USlateVectorArtData*                    M_pCachedPolygonData;                              // 0x0238(0x0008)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
};
static_assert(alignof(FBFGAgentInstanceSaveRestoreData) == 0x000008, "Wrong alignment on FBFGAgentInstanceSaveRestoreData");
static_assert(sizeof(FBFGAgentInstanceSaveRestoreData) == 0x000240, "Wrong size on FBFGAgentInstanceSaveRestoreData");
static_assert(offsetof(FBFGAgentInstanceSaveRestoreData, M_OpportunityData) == 0x000000, "Member 'FBFGAgentInstanceSaveRestoreData::M_OpportunityData' has a wrong offset!");
static_assert(offsetof(FBFGAgentInstanceSaveRestoreData, M_bHasSavedData) == 0x0000C8, "Member 'FBFGAgentInstanceSaveRestoreData::M_bHasSavedData' has a wrong offset!");
static_assert(offsetof(FBFGAgentInstanceSaveRestoreData, M_pAgent) == 0x0000D0, "Member 'FBFGAgentInstanceSaveRestoreData::M_pAgent' has a wrong offset!");
static_assert(offsetof(FBFGAgentInstanceSaveRestoreData, M_bLODEnabled) == 0x0000D8, "Member 'FBFGAgentInstanceSaveRestoreData::M_bLODEnabled' has a wrong offset!");
static_assert(offsetof(FBFGAgentInstanceSaveRestoreData, M_bCanBeTargetedByMentalAbilities) == 0x0000D9, "Member 'FBFGAgentInstanceSaveRestoreData::M_bCanBeTargetedByMentalAbilities' has a wrong offset!");
static_assert(offsetof(FBFGAgentInstanceSaveRestoreData, M_bCanBeTargetedByWeapons) == 0x0000DA, "Member 'FBFGAgentInstanceSaveRestoreData::M_bCanBeTargetedByWeapons' has a wrong offset!");
static_assert(offsetof(FBFGAgentInstanceSaveRestoreData, M_bUsesCharacterPhysics) == 0x0000DB, "Member 'FBFGAgentInstanceSaveRestoreData::M_bUsesCharacterPhysics' has a wrong offset!");
static_assert(offsetof(FBFGAgentInstanceSaveRestoreData, M_pExcludedFromAbilitiesTags) == 0x0000E0, "Member 'FBFGAgentInstanceSaveRestoreData::M_pExcludedFromAbilitiesTags' has a wrong offset!");
static_assert(offsetof(FBFGAgentInstanceSaveRestoreData, M_aTags) == 0x000100, "Member 'FBFGAgentInstanceSaveRestoreData::M_aTags' has a wrong offset!");
static_assert(offsetof(FBFGAgentInstanceSaveRestoreData, M_gameplayTags) == 0x000110, "Member 'FBFGAgentInstanceSaveRestoreData::M_gameplayTags' has a wrong offset!");
static_assert(offsetof(FBFGAgentInstanceSaveRestoreData, M_gameplayTagsEffect) == 0x000130, "Member 'FBFGAgentInstanceSaveRestoreData::M_gameplayTagsEffect' has a wrong offset!");
static_assert(offsetof(FBFGAgentInstanceSaveRestoreData, M_customData) == 0x000150, "Member 'FBFGAgentInstanceSaveRestoreData::M_customData' has a wrong offset!");
static_assert(offsetof(FBFGAgentInstanceSaveRestoreData, M_eFaction) == 0x0001B0, "Member 'FBFGAgentInstanceSaveRestoreData::M_eFaction' has a wrong offset!");
static_assert(offsetof(FBFGAgentInstanceSaveRestoreData, M_fMonetaryValue) == 0x0001B4, "Member 'FBFGAgentInstanceSaveRestoreData::M_fMonetaryValue' has a wrong offset!");
static_assert(offsetof(FBFGAgentInstanceSaveRestoreData, M_bEnabled) == 0x0001B8, "Member 'FBFGAgentInstanceSaveRestoreData::M_bEnabled' has a wrong offset!");
static_assert(offsetof(FBFGAgentInstanceSaveRestoreData, M_fHoldTime) == 0x0001BC, "Member 'FBFGAgentInstanceSaveRestoreData::M_fHoldTime' has a wrong offset!");
static_assert(offsetof(FBFGAgentInstanceSaveRestoreData, M_eAnimationPosture) == 0x0001C0, "Member 'FBFGAgentInstanceSaveRestoreData::M_eAnimationPosture' has a wrong offset!");
static_assert(offsetof(FBFGAgentInstanceSaveRestoreData, M_oCompetentAbilities) == 0x0001C8, "Member 'FBFGAgentInstanceSaveRestoreData::M_oCompetentAbilities' has a wrong offset!");
static_assert(offsetof(FBFGAgentInstanceSaveRestoreData, M_pDataTable) == 0x0001E8, "Member 'FBFGAgentInstanceSaveRestoreData::M_pDataTable' has a wrong offset!");
static_assert(offsetof(FBFGAgentInstanceSaveRestoreData, M_aVariationPool) == 0x0001F0, "Member 'FBFGAgentInstanceSaveRestoreData::M_aVariationPool' has a wrong offset!");
static_assert(offsetof(FBFGAgentInstanceSaveRestoreData, M_ActiveVariation) == 0x000200, "Member 'FBFGAgentInstanceSaveRestoreData::M_ActiveVariation' has a wrong offset!");
static_assert(offsetof(FBFGAgentInstanceSaveRestoreData, M_aPendingEquipCommand) == 0x000208, "Member 'FBFGAgentInstanceSaveRestoreData::M_aPendingEquipCommand' has a wrong offset!");
static_assert(offsetof(FBFGAgentInstanceSaveRestoreData, M_bIsMissionTriggerZoneActivator) == 0x000218, "Member 'FBFGAgentInstanceSaveRestoreData::M_bIsMissionTriggerZoneActivator' has a wrong offset!");
static_assert(offsetof(FBFGAgentInstanceSaveRestoreData, M_bRadarEnabled) == 0x000219, "Member 'FBFGAgentInstanceSaveRestoreData::M_bRadarEnabled' has a wrong offset!");
static_assert(offsetof(FBFGAgentInstanceSaveRestoreData, M_pStaticInfo) == 0x000220, "Member 'FBFGAgentInstanceSaveRestoreData::M_pStaticInfo' has a wrong offset!");
static_assert(offsetof(FBFGAgentInstanceSaveRestoreData, M_pStaticInfo_Override) == 0x000228, "Member 'FBFGAgentInstanceSaveRestoreData::M_pStaticInfo_Override' has a wrong offset!");
static_assert(offsetof(FBFGAgentInstanceSaveRestoreData, M_fLocationUpdateDistance) == 0x000230, "Member 'FBFGAgentInstanceSaveRestoreData::M_fLocationUpdateDistance' has a wrong offset!");
static_assert(offsetof(FBFGAgentInstanceSaveRestoreData, M_pCachedPolygonData) == 0x000238, "Member 'FBFGAgentInstanceSaveRestoreData::M_pCachedPolygonData' has a wrong offset!");

// ScriptStruct BFGCore.BFGVehiclePassengersOverride
// 0x0048 (0x0048 - 0x0000)
struct FBFGVehiclePassengersOverride final
{
public:
	struct FBFGPassengersData                     M_passengerData;                                   // 0x0000(0x0038)(Transient, Protected, NativeAccessSpecifierProtected)
	TArray<struct FBFGPassengerCountForTagQuery>  M_aPassengerCountByTagQuery;                       // 0x0038(0x0010)(ZeroConstructor, Transient, Protected, NativeAccessSpecifierProtected)
};
static_assert(alignof(FBFGVehiclePassengersOverride) == 0x000008, "Wrong alignment on FBFGVehiclePassengersOverride");
static_assert(sizeof(FBFGVehiclePassengersOverride) == 0x000048, "Wrong size on FBFGVehiclePassengersOverride");
static_assert(offsetof(FBFGVehiclePassengersOverride, M_passengerData) == 0x000000, "Member 'FBFGVehiclePassengersOverride::M_passengerData' has a wrong offset!");
static_assert(offsetof(FBFGVehiclePassengersOverride, M_aPassengerCountByTagQuery) == 0x000038, "Member 'FBFGVehiclePassengersOverride::M_aPassengerCountByTagQuery' has a wrong offset!");

// ScriptStruct BFGCore.BFGStatSaveData
// 0x0008 (0x0008 - 0x0000)
struct FBFGStatSaveData final
{
public:
	EBFGGameStatistic                             M_eStat;                                           // 0x0000(0x0001)(ZeroConstructor, SaveGame, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1[0x3];                                        // 0x0001(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         M_fValue;                                          // 0x0004(0x0004)(ZeroConstructor, SaveGame, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FBFGStatSaveData) == 0x000004, "Wrong alignment on FBFGStatSaveData");
static_assert(sizeof(FBFGStatSaveData) == 0x000008, "Wrong size on FBFGStatSaveData");
static_assert(offsetof(FBFGStatSaveData, M_eStat) == 0x000000, "Member 'FBFGStatSaveData::M_eStat' has a wrong offset!");
static_assert(offsetof(FBFGStatSaveData, M_fValue) == 0x000004, "Member 'FBFGStatSaveData::M_fValue' has a wrong offset!");

// ScriptStruct BFGCore.BFGQuest_ElementWaitFor_Objective
// 0x0018 (0x0018 - 0x0000)
struct FBFGQuest_ElementWaitFor_Objective final
{
public:
	uint8                                         Pad_0[0x10];                                       // 0x0000(0x0010)(Fixing Size After Last Property [ Dumper-7 ])
	class UBFGVariable*                           M_pVariable;                                       // 0x0010(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FBFGQuest_ElementWaitFor_Objective) == 0x000008, "Wrong alignment on FBFGQuest_ElementWaitFor_Objective");
static_assert(sizeof(FBFGQuest_ElementWaitFor_Objective) == 0x000018, "Wrong size on FBFGQuest_ElementWaitFor_Objective");
static_assert(offsetof(FBFGQuest_ElementWaitFor_Objective, M_pVariable) == 0x000010, "Member 'FBFGQuest_ElementWaitFor_Objective::M_pVariable' has a wrong offset!");

// ScriptStruct BFGCore.BFGQuest_ElementReach_Objective
// 0x0128 (0x0128 - 0x0000)
struct FBFGQuest_ElementReach_Objective final
{
public:
	struct FBFGActorBinding                       M_actorBinding;                                    // 0x0000(0x0090)(Edit, BlueprintVisible, BlueprintReadOnly, DisableEditOnInstance, NativeAccessSpecifierPublic)
	bool                                          M_bReachOnEnter;                                   // 0x0090(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          M_bReachOnExit;                                    // 0x0091(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_92[0x6];                                       // 0x0092(0x0006)(Fixing Size After Last Property [ Dumper-7 ])
	struct FBFGQuest_UIProvider                   M_descriptionProvider;                             // 0x0098(0x0050)(Edit, BlueprintVisible, BlueprintReadOnly, DisableEditOnInstance, NativeAccessSpecifierPublic)
	struct FBFGObjectiveMarkerInfo                M_markerInfo;                                      // 0x00E8(0x0028)(Edit, BlueprintVisible, BlueprintReadOnly, DisableEditOnInstance, ContainsInstancedReference, NativeAccessSpecifierPublic)
	TArray<class UBFGEffectBank*>                 M_apEnableEffectBanks;                             // 0x0110(0x0010)(Edit, ZeroConstructor, DisableEditOnInstance, NativeAccessSpecifierPublic)
	EBFGEffect_Identifier                         M_activateEffect;                                  // 0x0120(0x0001)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_121[0x7];                                      // 0x0121(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FBFGQuest_ElementReach_Objective) == 0x000008, "Wrong alignment on FBFGQuest_ElementReach_Objective");
static_assert(sizeof(FBFGQuest_ElementReach_Objective) == 0x000128, "Wrong size on FBFGQuest_ElementReach_Objective");
static_assert(offsetof(FBFGQuest_ElementReach_Objective, M_actorBinding) == 0x000000, "Member 'FBFGQuest_ElementReach_Objective::M_actorBinding' has a wrong offset!");
static_assert(offsetof(FBFGQuest_ElementReach_Objective, M_bReachOnEnter) == 0x000090, "Member 'FBFGQuest_ElementReach_Objective::M_bReachOnEnter' has a wrong offset!");
static_assert(offsetof(FBFGQuest_ElementReach_Objective, M_bReachOnExit) == 0x000091, "Member 'FBFGQuest_ElementReach_Objective::M_bReachOnExit' has a wrong offset!");
static_assert(offsetof(FBFGQuest_ElementReach_Objective, M_descriptionProvider) == 0x000098, "Member 'FBFGQuest_ElementReach_Objective::M_descriptionProvider' has a wrong offset!");
static_assert(offsetof(FBFGQuest_ElementReach_Objective, M_markerInfo) == 0x0000E8, "Member 'FBFGQuest_ElementReach_Objective::M_markerInfo' has a wrong offset!");
static_assert(offsetof(FBFGQuest_ElementReach_Objective, M_apEnableEffectBanks) == 0x000110, "Member 'FBFGQuest_ElementReach_Objective::M_apEnableEffectBanks' has a wrong offset!");
static_assert(offsetof(FBFGQuest_ElementReach_Objective, M_activateEffect) == 0x000120, "Member 'FBFGQuest_ElementReach_Objective::M_activateEffect' has a wrong offset!");

// ScriptStruct BFGCore.BFGMissionCondition
// 0x0020 (0x0020 - 0x0000)
struct FBFGMissionCondition final
{
public:
	TArray<TSoftClassPtr<class UClass>>           M_aQuests;                                         // 0x0000(0x0010)(Edit, ZeroConstructor, DisableEditOnInstance, Protected, UObjectWrapper, NativeAccessSpecifierProtected)
	TArray<class UBFGMissionGroup*>               M_aMissionGroups;                                  // 0x0010(0x0010)(Edit, ZeroConstructor, DisableEditOnInstance, Protected, NativeAccessSpecifierProtected)
};
static_assert(alignof(FBFGMissionCondition) == 0x000008, "Wrong alignment on FBFGMissionCondition");
static_assert(sizeof(FBFGMissionCondition) == 0x000020, "Wrong size on FBFGMissionCondition");
static_assert(offsetof(FBFGMissionCondition, M_aQuests) == 0x000000, "Member 'FBFGMissionCondition::M_aQuests' has a wrong offset!");
static_assert(offsetof(FBFGMissionCondition, M_aMissionGroups) == 0x000010, "Member 'FBFGMissionCondition::M_aMissionGroups' has a wrong offset!");

// ScriptStruct BFGCore.BFGAIGlobalCooldown
// 0x0038 (0x0038 - 0x0000)
struct FBFGAIGlobalCooldown final
{
public:
	float                                         M_fRemainingTime;                                  // 0x0000(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         M_iCount;                                          // 0x0004(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TScriptInterface<class IBFGAICombatParticipant> M_pParticipant;                                    // 0x0008(0x0010)(ZeroConstructor, IsPlainOldData, NoDestructor, UObjectWrapper, NativeAccessSpecifierPublic)
	TArray<TScriptInterface<class IBFGAICombatParticipant>> M_apWaitingNPCs;                                   // 0x0018(0x0010)(ZeroConstructor, UObjectWrapper, NativeAccessSpecifierPublic)
	EBFGGlobalCooldown                            M_cooldown;                                        // 0x0028(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_29[0x7];                                       // 0x0029(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	class AActor*                                 M_pTargetActor;                                    // 0x0030(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FBFGAIGlobalCooldown) == 0x000008, "Wrong alignment on FBFGAIGlobalCooldown");
static_assert(sizeof(FBFGAIGlobalCooldown) == 0x000038, "Wrong size on FBFGAIGlobalCooldown");
static_assert(offsetof(FBFGAIGlobalCooldown, M_fRemainingTime) == 0x000000, "Member 'FBFGAIGlobalCooldown::M_fRemainingTime' has a wrong offset!");
static_assert(offsetof(FBFGAIGlobalCooldown, M_iCount) == 0x000004, "Member 'FBFGAIGlobalCooldown::M_iCount' has a wrong offset!");
static_assert(offsetof(FBFGAIGlobalCooldown, M_pParticipant) == 0x000008, "Member 'FBFGAIGlobalCooldown::M_pParticipant' has a wrong offset!");
static_assert(offsetof(FBFGAIGlobalCooldown, M_apWaitingNPCs) == 0x000018, "Member 'FBFGAIGlobalCooldown::M_apWaitingNPCs' has a wrong offset!");
static_assert(offsetof(FBFGAIGlobalCooldown, M_cooldown) == 0x000028, "Member 'FBFGAIGlobalCooldown::M_cooldown' has a wrong offset!");
static_assert(offsetof(FBFGAIGlobalCooldown, M_pTargetActor) == 0x000030, "Member 'FBFGAIGlobalCooldown::M_pTargetActor' has a wrong offset!");

// ScriptStruct BFGCore.BFGWeaponObstacle
// 0x0010 (0x0010 - 0x0000)
struct FBFGWeaponObstacle final
{
public:
	float                                         M_fTimestamp;                                      // 0x0000(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_4[0x4];                                        // 0x0004(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class ABFGDynamicObstacle_Sphere*             M_pObstacle;                                       // 0x0008(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FBFGWeaponObstacle) == 0x000008, "Wrong alignment on FBFGWeaponObstacle");
static_assert(sizeof(FBFGWeaponObstacle) == 0x000010, "Wrong size on FBFGWeaponObstacle");
static_assert(offsetof(FBFGWeaponObstacle, M_fTimestamp) == 0x000000, "Member 'FBFGWeaponObstacle::M_fTimestamp' has a wrong offset!");
static_assert(offsetof(FBFGWeaponObstacle, M_pObstacle) == 0x000008, "Member 'FBFGWeaponObstacle::M_pObstacle' has a wrong offset!");

// ScriptStruct BFGCore.BFGAICombatRegistryData
// 0x0048 (0x0048 - 0x0000)
struct FBFGAICombatRegistryData final
{
public:
	float                                         M_fTimeout;                                        // 0x0000(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         M_fTimeWhenRegistered;                             // 0x0004(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TScriptInterface<class IBFGAICombatParticipant> M_pParticipant;                                    // 0x0008(0x0010)(ZeroConstructor, IsPlainOldData, NoDestructor, UObjectWrapper, NativeAccessSpecifierPublic)
	struct FGameplayTag                           M_mainGameplayTag;                                 // 0x0018(0x0008)(NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class AActor*                                 M_pTargetActor;                                    // 0x0020(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EBFGCombatState_NPC                           M_combatState;                                     // 0x0028(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EBFGAttackState_NPC                           M_attackState;                                     // 0x0029(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2A[0x2];                                       // 0x002A(0x0002)(Fixing Size After Last Property [ Dumper-7 ])
	struct FVector                                M_vIntendedPosition;                               // 0x002C(0x000C)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         M_fImportanceScore;                                // 0x0038(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_3C[0xC];                                       // 0x003C(0x000C)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FBFGAICombatRegistryData) == 0x000008, "Wrong alignment on FBFGAICombatRegistryData");
static_assert(sizeof(FBFGAICombatRegistryData) == 0x000048, "Wrong size on FBFGAICombatRegistryData");
static_assert(offsetof(FBFGAICombatRegistryData, M_fTimeout) == 0x000000, "Member 'FBFGAICombatRegistryData::M_fTimeout' has a wrong offset!");
static_assert(offsetof(FBFGAICombatRegistryData, M_fTimeWhenRegistered) == 0x000004, "Member 'FBFGAICombatRegistryData::M_fTimeWhenRegistered' has a wrong offset!");
static_assert(offsetof(FBFGAICombatRegistryData, M_pParticipant) == 0x000008, "Member 'FBFGAICombatRegistryData::M_pParticipant' has a wrong offset!");
static_assert(offsetof(FBFGAICombatRegistryData, M_mainGameplayTag) == 0x000018, "Member 'FBFGAICombatRegistryData::M_mainGameplayTag' has a wrong offset!");
static_assert(offsetof(FBFGAICombatRegistryData, M_pTargetActor) == 0x000020, "Member 'FBFGAICombatRegistryData::M_pTargetActor' has a wrong offset!");
static_assert(offsetof(FBFGAICombatRegistryData, M_combatState) == 0x000028, "Member 'FBFGAICombatRegistryData::M_combatState' has a wrong offset!");
static_assert(offsetof(FBFGAICombatRegistryData, M_attackState) == 0x000029, "Member 'FBFGAICombatRegistryData::M_attackState' has a wrong offset!");
static_assert(offsetof(FBFGAICombatRegistryData, M_vIntendedPosition) == 0x00002C, "Member 'FBFGAICombatRegistryData::M_vIntendedPosition' has a wrong offset!");
static_assert(offsetof(FBFGAICombatRegistryData, M_fImportanceScore) == 0x000038, "Member 'FBFGAICombatRegistryData::M_fImportanceScore' has a wrong offset!");

// ScriptStruct BFGCore.BFGTargetTracker_QueryParams
// 0x0010 (0x0010 - 0x0000)
struct FBFGTargetTracker_QueryParams final
{
public:
	float                                         M_fMaxAllowedOffset;                               // 0x0000(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          M_bRequireLineOfSightToRealTarget;                 // 0x0004(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          M_bRequireNoLineOfSightToRealTarget;               // 0x0005(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          M_bRequireLineOfSightToTarget;                     // 0x0006(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          M_bRequireNoLineOfSightToTarget;                   // 0x0007(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          M_bRequireLineOfSightToOrigin;                     // 0x0008(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          M_bRequireNoLineOfSightToOrigin;                   // 0x0009(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_A[0x2];                                        // 0x000A(0x0002)(Fixing Size After Last Property [ Dumper-7 ])
	uint32                                        M_uRequiredDataFlags;                              // 0x000C(0x0004)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
};
static_assert(alignof(FBFGTargetTracker_QueryParams) == 0x000004, "Wrong alignment on FBFGTargetTracker_QueryParams");
static_assert(sizeof(FBFGTargetTracker_QueryParams) == 0x000010, "Wrong size on FBFGTargetTracker_QueryParams");
static_assert(offsetof(FBFGTargetTracker_QueryParams, M_fMaxAllowedOffset) == 0x000000, "Member 'FBFGTargetTracker_QueryParams::M_fMaxAllowedOffset' has a wrong offset!");
static_assert(offsetof(FBFGTargetTracker_QueryParams, M_bRequireLineOfSightToRealTarget) == 0x000004, "Member 'FBFGTargetTracker_QueryParams::M_bRequireLineOfSightToRealTarget' has a wrong offset!");
static_assert(offsetof(FBFGTargetTracker_QueryParams, M_bRequireNoLineOfSightToRealTarget) == 0x000005, "Member 'FBFGTargetTracker_QueryParams::M_bRequireNoLineOfSightToRealTarget' has a wrong offset!");
static_assert(offsetof(FBFGTargetTracker_QueryParams, M_bRequireLineOfSightToTarget) == 0x000006, "Member 'FBFGTargetTracker_QueryParams::M_bRequireLineOfSightToTarget' has a wrong offset!");
static_assert(offsetof(FBFGTargetTracker_QueryParams, M_bRequireNoLineOfSightToTarget) == 0x000007, "Member 'FBFGTargetTracker_QueryParams::M_bRequireNoLineOfSightToTarget' has a wrong offset!");
static_assert(offsetof(FBFGTargetTracker_QueryParams, M_bRequireLineOfSightToOrigin) == 0x000008, "Member 'FBFGTargetTracker_QueryParams::M_bRequireLineOfSightToOrigin' has a wrong offset!");
static_assert(offsetof(FBFGTargetTracker_QueryParams, M_bRequireNoLineOfSightToOrigin) == 0x000009, "Member 'FBFGTargetTracker_QueryParams::M_bRequireNoLineOfSightToOrigin' has a wrong offset!");
static_assert(offsetof(FBFGTargetTracker_QueryParams, M_uRequiredDataFlags) == 0x00000C, "Member 'FBFGTargetTracker_QueryParams::M_uRequiredDataFlags' has a wrong offset!");

// ScriptStruct BFGCore.BFGSystemData_MothershipMenu
// 0x0001 (0x0001 - 0x0000)
struct FBFGSystemData_MothershipMenu final
{
public:
	EBFGNarrativeSequenceID_Pox                   M_eNarrativeSequenceID;                            // 0x0000(0x0001)(ZeroConstructor, SaveGame, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FBFGSystemData_MothershipMenu) == 0x000001, "Wrong alignment on FBFGSystemData_MothershipMenu");
static_assert(sizeof(FBFGSystemData_MothershipMenu) == 0x000001, "Wrong size on FBFGSystemData_MothershipMenu");
static_assert(offsetof(FBFGSystemData_MothershipMenu, M_eNarrativeSequenceID) == 0x000000, "Member 'FBFGSystemData_MothershipMenu::M_eNarrativeSequenceID' has a wrong offset!");

// ScriptStruct BFGCore.BFGNetworkPathAgentSpawnOptions
// 0x0078 (0x0078 - 0x0000)
struct FBFGNetworkPathAgentSpawnOptions final
{
public:
	struct FBFGPassengersData                     M_passengersData;                                  // 0x0000(0x0038)(Transient, NativeAccessSpecifierPublic)
	bool                                          M_bEnterCrowdFlow;                                 // 0x0038(0x0001)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          M_bRegisterToPath;                                 // 0x0039(0x0001)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EBFGBehaviourState_NPC                        M_eState;                                          // 0x003A(0x0001)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_3B[0x5];                                       // 0x003B(0x0005)(Fixing Size After Last Property [ Dumper-7 ])
	class AActor*                                 M_pTargetActor;                                    // 0x0040(0x0008)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	ESpawnActorCollisionHandlingMethod            M_eSpawnMethod;                                    // 0x0048(0x0001)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EBFGNetworkPathAgentSpawnTransformOptions     M_eSpawnTransformOptions;                          // 0x0049(0x0001)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_4A[0x2];                                       // 0x004A(0x0002)(Fixing Size After Last Property [ Dumper-7 ])
	struct FVector                                M_vLocation;                                       // 0x004C(0x000C)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FRotator                               M_vOrientation;                                    // 0x0058(0x000C)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
	bool                                          M_bDisableCollisions;                              // 0x0064(0x0001)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          M_bDespawnOnDeath;                                 // 0x0065(0x0001)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_66[0x2];                                       // 0x0066(0x0002)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         M_fMinRange;                                       // 0x0068(0x0004)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         M_fMaxRange;                                       // 0x006C(0x0004)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          M_bCombatBubbleEnabled;                            // 0x0070(0x0001)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          M_bIsEnemy;                                        // 0x0071(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_72[0x6];                                       // 0x0072(0x0006)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FBFGNetworkPathAgentSpawnOptions) == 0x000008, "Wrong alignment on FBFGNetworkPathAgentSpawnOptions");
static_assert(sizeof(FBFGNetworkPathAgentSpawnOptions) == 0x000078, "Wrong size on FBFGNetworkPathAgentSpawnOptions");
static_assert(offsetof(FBFGNetworkPathAgentSpawnOptions, M_passengersData) == 0x000000, "Member 'FBFGNetworkPathAgentSpawnOptions::M_passengersData' has a wrong offset!");
static_assert(offsetof(FBFGNetworkPathAgentSpawnOptions, M_bEnterCrowdFlow) == 0x000038, "Member 'FBFGNetworkPathAgentSpawnOptions::M_bEnterCrowdFlow' has a wrong offset!");
static_assert(offsetof(FBFGNetworkPathAgentSpawnOptions, M_bRegisterToPath) == 0x000039, "Member 'FBFGNetworkPathAgentSpawnOptions::M_bRegisterToPath' has a wrong offset!");
static_assert(offsetof(FBFGNetworkPathAgentSpawnOptions, M_eState) == 0x00003A, "Member 'FBFGNetworkPathAgentSpawnOptions::M_eState' has a wrong offset!");
static_assert(offsetof(FBFGNetworkPathAgentSpawnOptions, M_pTargetActor) == 0x000040, "Member 'FBFGNetworkPathAgentSpawnOptions::M_pTargetActor' has a wrong offset!");
static_assert(offsetof(FBFGNetworkPathAgentSpawnOptions, M_eSpawnMethod) == 0x000048, "Member 'FBFGNetworkPathAgentSpawnOptions::M_eSpawnMethod' has a wrong offset!");
static_assert(offsetof(FBFGNetworkPathAgentSpawnOptions, M_eSpawnTransformOptions) == 0x000049, "Member 'FBFGNetworkPathAgentSpawnOptions::M_eSpawnTransformOptions' has a wrong offset!");
static_assert(offsetof(FBFGNetworkPathAgentSpawnOptions, M_vLocation) == 0x00004C, "Member 'FBFGNetworkPathAgentSpawnOptions::M_vLocation' has a wrong offset!");
static_assert(offsetof(FBFGNetworkPathAgentSpawnOptions, M_vOrientation) == 0x000058, "Member 'FBFGNetworkPathAgentSpawnOptions::M_vOrientation' has a wrong offset!");
static_assert(offsetof(FBFGNetworkPathAgentSpawnOptions, M_bDisableCollisions) == 0x000064, "Member 'FBFGNetworkPathAgentSpawnOptions::M_bDisableCollisions' has a wrong offset!");
static_assert(offsetof(FBFGNetworkPathAgentSpawnOptions, M_bDespawnOnDeath) == 0x000065, "Member 'FBFGNetworkPathAgentSpawnOptions::M_bDespawnOnDeath' has a wrong offset!");
static_assert(offsetof(FBFGNetworkPathAgentSpawnOptions, M_fMinRange) == 0x000068, "Member 'FBFGNetworkPathAgentSpawnOptions::M_fMinRange' has a wrong offset!");
static_assert(offsetof(FBFGNetworkPathAgentSpawnOptions, M_fMaxRange) == 0x00006C, "Member 'FBFGNetworkPathAgentSpawnOptions::M_fMaxRange' has a wrong offset!");
static_assert(offsetof(FBFGNetworkPathAgentSpawnOptions, M_bCombatBubbleEnabled) == 0x000070, "Member 'FBFGNetworkPathAgentSpawnOptions::M_bCombatBubbleEnabled' has a wrong offset!");
static_assert(offsetof(FBFGNetworkPathAgentSpawnOptions, M_bIsEnemy) == 0x000071, "Member 'FBFGNetworkPathAgentSpawnOptions::M_bIsEnemy' has a wrong offset!");

// ScriptStruct BFGCore.BFGNetworkPathActorSpawnData
// 0x0108 (0x0108 - 0x0000)
struct FBFGNetworkPathActorSpawnData final
{
public:
	struct FVector                                M_vLocation;                                       // 0x0000(0x000C)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FRotator                               M_vOrientation;                                    // 0x000C(0x000C)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
	float                                         M_fSplineDistance;                                 // 0x0018(0x0004)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1C[0x4];                                       // 0x001C(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	struct FGameplayTagQuery                      M_query;                                           // 0x0020(0x0048)(Transient, NativeAccessSpecifierPublic)
	class FName                                   M_TableRowName;                                    // 0x0068(0x0008)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         M_iPreferredLOD;                                   // 0x0070(0x0004)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_74[0x4];                                       // 0x0074(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	TSubclassOf<class AActor>                     M_actorType;                                       // 0x0078(0x0008)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class AActor*                                 M_pActor;                                          // 0x0080(0x0008)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EBFGNetworkPathExtremity                      M_eTargetExtremity;                                // 0x0088(0x0001)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_89[0x7];                                       // 0x0089(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	struct FBFGNetworkPathAgentSpawnOptions       M_spawnOptions;                                    // 0x0090(0x0078)(Transient, NativeAccessSpecifierPublic)
};
static_assert(alignof(FBFGNetworkPathActorSpawnData) == 0x000008, "Wrong alignment on FBFGNetworkPathActorSpawnData");
static_assert(sizeof(FBFGNetworkPathActorSpawnData) == 0x000108, "Wrong size on FBFGNetworkPathActorSpawnData");
static_assert(offsetof(FBFGNetworkPathActorSpawnData, M_vLocation) == 0x000000, "Member 'FBFGNetworkPathActorSpawnData::M_vLocation' has a wrong offset!");
static_assert(offsetof(FBFGNetworkPathActorSpawnData, M_vOrientation) == 0x00000C, "Member 'FBFGNetworkPathActorSpawnData::M_vOrientation' has a wrong offset!");
static_assert(offsetof(FBFGNetworkPathActorSpawnData, M_fSplineDistance) == 0x000018, "Member 'FBFGNetworkPathActorSpawnData::M_fSplineDistance' has a wrong offset!");
static_assert(offsetof(FBFGNetworkPathActorSpawnData, M_query) == 0x000020, "Member 'FBFGNetworkPathActorSpawnData::M_query' has a wrong offset!");
static_assert(offsetof(FBFGNetworkPathActorSpawnData, M_TableRowName) == 0x000068, "Member 'FBFGNetworkPathActorSpawnData::M_TableRowName' has a wrong offset!");
static_assert(offsetof(FBFGNetworkPathActorSpawnData, M_iPreferredLOD) == 0x000070, "Member 'FBFGNetworkPathActorSpawnData::M_iPreferredLOD' has a wrong offset!");
static_assert(offsetof(FBFGNetworkPathActorSpawnData, M_actorType) == 0x000078, "Member 'FBFGNetworkPathActorSpawnData::M_actorType' has a wrong offset!");
static_assert(offsetof(FBFGNetworkPathActorSpawnData, M_pActor) == 0x000080, "Member 'FBFGNetworkPathActorSpawnData::M_pActor' has a wrong offset!");
static_assert(offsetof(FBFGNetworkPathActorSpawnData, M_eTargetExtremity) == 0x000088, "Member 'FBFGNetworkPathActorSpawnData::M_eTargetExtremity' has a wrong offset!");
static_assert(offsetof(FBFGNetworkPathActorSpawnData, M_spawnOptions) == 0x000090, "Member 'FBFGNetworkPathActorSpawnData::M_spawnOptions' has a wrong offset!");

// ScriptStruct BFGCore.BFGTargetTrackerData
// 0x0038 (0x0038 - 0x0000)
struct FBFGTargetTrackerData final
{
public:
	uint8                                         Pad_0[0x30];                                       // 0x0000(0x0030)(Fixing Size After Last Property [ Dumper-7 ])
	class AActor*                                 M_pAttackTarget;                                   // 0x0030(0x0008)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FBFGTargetTrackerData) == 0x000008, "Wrong alignment on FBFGTargetTrackerData");
static_assert(sizeof(FBFGTargetTrackerData) == 0x000038, "Wrong size on FBFGTargetTrackerData");
static_assert(offsetof(FBFGTargetTrackerData, M_pAttackTarget) == 0x000030, "Member 'FBFGTargetTrackerData::M_pAttackTarget' has a wrong offset!");

// ScriptStruct BFGCore.BFGAIWeaponCooldown
// 0x0008 (0x0008 - 0x0000)
struct alignas(0x04) FBFGAIWeaponCooldown final
{
public:
	uint8                                         Pad_0[0x8];                                        // 0x0000(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FBFGAIWeaponCooldown) == 0x000004, "Wrong alignment on FBFGAIWeaponCooldown");
static_assert(sizeof(FBFGAIWeaponCooldown) == 0x000008, "Wrong size on FBFGAIWeaponCooldown");

// ScriptStruct BFGCore.BFGConcaveHull2D
// 0x0001 (0x0001 - 0x0000)
struct FBFGConcaveHull2D final
{
public:
	uint8                                         Pad_0[0x1];                                        // 0x0000(0x0001)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FBFGConcaveHull2D) == 0x000001, "Wrong alignment on FBFGConcaveHull2D");
static_assert(sizeof(FBFGConcaveHull2D) == 0x000001, "Wrong size on FBFGConcaveHull2D");

// ScriptStruct BFGCore.BFGBehaviorState
// 0x0058 (0x0058 - 0x0000)
struct FBFGBehaviorState final
{
public:
	EBFGBehaviourState_NPC                        M_eRequestedState;                                 // 0x0000(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1[0x7];                                        // 0x0001(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	struct FBlackboardKeySelector                 M_suspiciousTargetKey;                             // 0x0008(0x0028)(Edit, NativeAccessSpecifierPublic)
	struct FBlackboardKeySelector                 M_suspiciousLocationKey;                           // 0x0030(0x0028)(Edit, NativeAccessSpecifierPublic)
};
static_assert(alignof(FBFGBehaviorState) == 0x000008, "Wrong alignment on FBFGBehaviorState");
static_assert(sizeof(FBFGBehaviorState) == 0x000058, "Wrong size on FBFGBehaviorState");
static_assert(offsetof(FBFGBehaviorState, M_eRequestedState) == 0x000000, "Member 'FBFGBehaviorState::M_eRequestedState' has a wrong offset!");
static_assert(offsetof(FBFGBehaviorState, M_suspiciousTargetKey) == 0x000008, "Member 'FBFGBehaviorState::M_suspiciousTargetKey' has a wrong offset!");
static_assert(offsetof(FBFGBehaviorState, M_suspiciousLocationKey) == 0x000030, "Member 'FBFGBehaviorState::M_suspiciousLocationKey' has a wrong offset!");

// ScriptStruct BFGCore.BFGCrowdLifeRecruitmentFilter
// 0x0028 (0x0028 - 0x0000)
struct FBFGCrowdLifeRecruitmentFilter final
{
public:
	float                                         M_fProbability;                                    // 0x0000(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_4[0x4];                                        // 0x0004(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	struct FGameplayTagContainer                  M_gameplayTags;                                    // 0x0008(0x0020)(Edit, BlueprintVisible, NativeAccessSpecifierPublic)
};
static_assert(alignof(FBFGCrowdLifeRecruitmentFilter) == 0x000008, "Wrong alignment on FBFGCrowdLifeRecruitmentFilter");
static_assert(sizeof(FBFGCrowdLifeRecruitmentFilter) == 0x000028, "Wrong size on FBFGCrowdLifeRecruitmentFilter");
static_assert(offsetof(FBFGCrowdLifeRecruitmentFilter, M_fProbability) == 0x000000, "Member 'FBFGCrowdLifeRecruitmentFilter::M_fProbability' has a wrong offset!");
static_assert(offsetof(FBFGCrowdLifeRecruitmentFilter, M_gameplayTags) == 0x000008, "Member 'FBFGCrowdLifeRecruitmentFilter::M_gameplayTags' has a wrong offset!");

// ScriptStruct BFGCore.BFGCrowdLifeRecruitmentFilterGroup
// 0x0020 (0x0020 - 0x0000)
struct FBFGCrowdLifeRecruitmentFilterGroup final
{
public:
	class FString                                 M_strGroup;                                        // 0x0000(0x0010)(Edit, BlueprintVisible, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TArray<struct FBFGCrowdLifeRecruitmentFilter> M_aFilters;                                        // 0x0010(0x0010)(Edit, BlueprintVisible, ZeroConstructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(FBFGCrowdLifeRecruitmentFilterGroup) == 0x000008, "Wrong alignment on FBFGCrowdLifeRecruitmentFilterGroup");
static_assert(sizeof(FBFGCrowdLifeRecruitmentFilterGroup) == 0x000020, "Wrong size on FBFGCrowdLifeRecruitmentFilterGroup");
static_assert(offsetof(FBFGCrowdLifeRecruitmentFilterGroup, M_strGroup) == 0x000000, "Member 'FBFGCrowdLifeRecruitmentFilterGroup::M_strGroup' has a wrong offset!");
static_assert(offsetof(FBFGCrowdLifeRecruitmentFilterGroup, M_aFilters) == 0x000010, "Member 'FBFGCrowdLifeRecruitmentFilterGroup::M_aFilters' has a wrong offset!");

// ScriptStruct BFGCore.BFGAimAssistTargetResult
// 0x0010 (0x0010 - 0x0000)
struct FBFGAimAssistTargetResult final
{
public:
	class UBFGActorComponent_AimAssistTarget*     M_pTarget;                                         // 0x0000(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_8[0x8];                                        // 0x0008(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FBFGAimAssistTargetResult) == 0x000008, "Wrong alignment on FBFGAimAssistTargetResult");
static_assert(sizeof(FBFGAimAssistTargetResult) == 0x000010, "Wrong size on FBFGAimAssistTargetResult");
static_assert(offsetof(FBFGAimAssistTargetResult, M_pTarget) == 0x000000, "Member 'FBFGAimAssistTargetResult::M_pTarget' has a wrong offset!");

// ScriptStruct BFGCore.BFGSaveSlotInfo
// 0x0038 (0x0038 - 0x0000)
struct FBFGSaveSlotInfo final
{
public:
	class FString                                 M_strFilename;                                     // 0x0000(0x0010)(ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FDateTime                              M_oDateTime;                                       // 0x0010(0x0008)(ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FString                                 M_strTitle;                                        // 0x0018(0x0010)(ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          M_bExists;                                         // 0x0028(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_29[0x3];                                       // 0x0029(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	int32                                         M_iSlotIndex;                                      // 0x002C(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UBFGSaveGame*                           M_pLoadedGame;                                     // 0x0030(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FBFGSaveSlotInfo) == 0x000008, "Wrong alignment on FBFGSaveSlotInfo");
static_assert(sizeof(FBFGSaveSlotInfo) == 0x000038, "Wrong size on FBFGSaveSlotInfo");
static_assert(offsetof(FBFGSaveSlotInfo, M_strFilename) == 0x000000, "Member 'FBFGSaveSlotInfo::M_strFilename' has a wrong offset!");
static_assert(offsetof(FBFGSaveSlotInfo, M_oDateTime) == 0x000010, "Member 'FBFGSaveSlotInfo::M_oDateTime' has a wrong offset!");
static_assert(offsetof(FBFGSaveSlotInfo, M_strTitle) == 0x000018, "Member 'FBFGSaveSlotInfo::M_strTitle' has a wrong offset!");
static_assert(offsetof(FBFGSaveSlotInfo, M_bExists) == 0x000028, "Member 'FBFGSaveSlotInfo::M_bExists' has a wrong offset!");
static_assert(offsetof(FBFGSaveSlotInfo, M_iSlotIndex) == 0x00002C, "Member 'FBFGSaveSlotInfo::M_iSlotIndex' has a wrong offset!");
static_assert(offsetof(FBFGSaveSlotInfo, M_pLoadedGame) == 0x000030, "Member 'FBFGSaveSlotInfo::M_pLoadedGame' has a wrong offset!");

// ScriptStruct BFGCore.BFGAimBallisticProjectileParameters
// 0x0030 (0x0030 - 0x0000)
struct FBFGAimBallisticProjectileParameters final
{
public:
	struct FVector                                M_vRelativeTargetPosition;                         // 0x0000(0x000C)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                M_vRelativeTargetVelocity;                         // 0x000C(0x000C)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                M_vGravity;                                        // 0x0018(0x000C)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         M_fProjectileSpeed;                                // 0x0024(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          M_bFavorLowArc;                                    // 0x0028(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_29[0x3];                                       // 0x0029(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         M_fDelay;                                          // 0x002C(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FBFGAimBallisticProjectileParameters) == 0x000004, "Wrong alignment on FBFGAimBallisticProjectileParameters");
static_assert(sizeof(FBFGAimBallisticProjectileParameters) == 0x000030, "Wrong size on FBFGAimBallisticProjectileParameters");
static_assert(offsetof(FBFGAimBallisticProjectileParameters, M_vRelativeTargetPosition) == 0x000000, "Member 'FBFGAimBallisticProjectileParameters::M_vRelativeTargetPosition' has a wrong offset!");
static_assert(offsetof(FBFGAimBallisticProjectileParameters, M_vRelativeTargetVelocity) == 0x00000C, "Member 'FBFGAimBallisticProjectileParameters::M_vRelativeTargetVelocity' has a wrong offset!");
static_assert(offsetof(FBFGAimBallisticProjectileParameters, M_vGravity) == 0x000018, "Member 'FBFGAimBallisticProjectileParameters::M_vGravity' has a wrong offset!");
static_assert(offsetof(FBFGAimBallisticProjectileParameters, M_fProjectileSpeed) == 0x000024, "Member 'FBFGAimBallisticProjectileParameters::M_fProjectileSpeed' has a wrong offset!");
static_assert(offsetof(FBFGAimBallisticProjectileParameters, M_bFavorLowArc) == 0x000028, "Member 'FBFGAimBallisticProjectileParameters::M_bFavorLowArc' has a wrong offset!");
static_assert(offsetof(FBFGAimBallisticProjectileParameters, M_fDelay) == 0x00002C, "Member 'FBFGAimBallisticProjectileParameters::M_fDelay' has a wrong offset!");

// ScriptStruct BFGCore.BFGSystemData_UFOManager_SiteData
// 0x0030 (0x0030 - 0x0000)
struct FBFGSystemData_UFOManager_SiteData final
{
public:
	TSoftObjectPtr<class ABFGUFOLandingSite>      M_softLandingSite;                                 // 0x0000(0x0028)(SaveGame, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          M_bUnlocked;                                       // 0x0028(0x0001)(ZeroConstructor, SaveGame, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_29[0x7];                                       // 0x0029(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FBFGSystemData_UFOManager_SiteData) == 0x000008, "Wrong alignment on FBFGSystemData_UFOManager_SiteData");
static_assert(sizeof(FBFGSystemData_UFOManager_SiteData) == 0x000030, "Wrong size on FBFGSystemData_UFOManager_SiteData");
static_assert(offsetof(FBFGSystemData_UFOManager_SiteData, M_softLandingSite) == 0x000000, "Member 'FBFGSystemData_UFOManager_SiteData::M_softLandingSite' has a wrong offset!");
static_assert(offsetof(FBFGSystemData_UFOManager_SiteData, M_bUnlocked) == 0x000028, "Member 'FBFGSystemData_UFOManager_SiteData::M_bUnlocked' has a wrong offset!");

// ScriptStruct BFGCore.BFGBrainExtractInfectionParams
// 0x001C (0x001C - 0x0000)
struct FBFGBrainExtractInfectionParams final
{
public:
	float                                         M_fInfectionDuration;                              // 0x0000(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         M_fInfectionDurationVariation;                     // 0x0004(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         M_fInfectionRadius;                                // 0x0008(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         M_fMaxInfections;                                  // 0x000C(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         M_fAllegianceSwitchDuration;                       // 0x0010(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         M_iMaxAllegianceSwitch;                            // 0x0014(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         M_fAttackRateModifier;                             // 0x0018(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FBFGBrainExtractInfectionParams) == 0x000004, "Wrong alignment on FBFGBrainExtractInfectionParams");
static_assert(sizeof(FBFGBrainExtractInfectionParams) == 0x00001C, "Wrong size on FBFGBrainExtractInfectionParams");
static_assert(offsetof(FBFGBrainExtractInfectionParams, M_fInfectionDuration) == 0x000000, "Member 'FBFGBrainExtractInfectionParams::M_fInfectionDuration' has a wrong offset!");
static_assert(offsetof(FBFGBrainExtractInfectionParams, M_fInfectionDurationVariation) == 0x000004, "Member 'FBFGBrainExtractInfectionParams::M_fInfectionDurationVariation' has a wrong offset!");
static_assert(offsetof(FBFGBrainExtractInfectionParams, M_fInfectionRadius) == 0x000008, "Member 'FBFGBrainExtractInfectionParams::M_fInfectionRadius' has a wrong offset!");
static_assert(offsetof(FBFGBrainExtractInfectionParams, M_fMaxInfections) == 0x00000C, "Member 'FBFGBrainExtractInfectionParams::M_fMaxInfections' has a wrong offset!");
static_assert(offsetof(FBFGBrainExtractInfectionParams, M_fAllegianceSwitchDuration) == 0x000010, "Member 'FBFGBrainExtractInfectionParams::M_fAllegianceSwitchDuration' has a wrong offset!");
static_assert(offsetof(FBFGBrainExtractInfectionParams, M_iMaxAllegianceSwitch) == 0x000014, "Member 'FBFGBrainExtractInfectionParams::M_iMaxAllegianceSwitch' has a wrong offset!");
static_assert(offsetof(FBFGBrainExtractInfectionParams, M_fAttackRateModifier) == 0x000018, "Member 'FBFGBrainExtractInfectionParams::M_fAttackRateModifier' has a wrong offset!");

// ScriptStruct BFGCore.BFGBrainExtractInfectionData
// 0x0030 (0x0030 - 0x0000)
struct FBFGBrainExtractInfectionData final
{
public:
	class AActor*                                 M_pTarget;                                         // 0x0000(0x0008)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         M_fTime;                                           // 0x0008(0x0004)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         M_fRandomInfectionDurationOffset;                  // 0x000C(0x0004)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          M_bIsExtracting;                                   // 0x0010(0x0001)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          M_bHasSwitchedAllegiance;                          // 0x0011(0x0001)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EBFGFaction                                   M_eOldFaction;                                     // 0x0012(0x0001)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_13[0x1];                                       // 0x0013(0x0001)(Fixing Size After Last Property [ Dumper-7 ])
	struct FBFGBrainExtractInfectionParams        M_oParams;                                         // 0x0014(0x001C)(Transient, NoDestructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(FBFGBrainExtractInfectionData) == 0x000008, "Wrong alignment on FBFGBrainExtractInfectionData");
static_assert(sizeof(FBFGBrainExtractInfectionData) == 0x000030, "Wrong size on FBFGBrainExtractInfectionData");
static_assert(offsetof(FBFGBrainExtractInfectionData, M_pTarget) == 0x000000, "Member 'FBFGBrainExtractInfectionData::M_pTarget' has a wrong offset!");
static_assert(offsetof(FBFGBrainExtractInfectionData, M_fTime) == 0x000008, "Member 'FBFGBrainExtractInfectionData::M_fTime' has a wrong offset!");
static_assert(offsetof(FBFGBrainExtractInfectionData, M_fRandomInfectionDurationOffset) == 0x00000C, "Member 'FBFGBrainExtractInfectionData::M_fRandomInfectionDurationOffset' has a wrong offset!");
static_assert(offsetof(FBFGBrainExtractInfectionData, M_bIsExtracting) == 0x000010, "Member 'FBFGBrainExtractInfectionData::M_bIsExtracting' has a wrong offset!");
static_assert(offsetof(FBFGBrainExtractInfectionData, M_bHasSwitchedAllegiance) == 0x000011, "Member 'FBFGBrainExtractInfectionData::M_bHasSwitchedAllegiance' has a wrong offset!");
static_assert(offsetof(FBFGBrainExtractInfectionData, M_eOldFaction) == 0x000012, "Member 'FBFGBrainExtractInfectionData::M_eOldFaction' has a wrong offset!");
static_assert(offsetof(FBFGBrainExtractInfectionData, M_oParams) == 0x000014, "Member 'FBFGBrainExtractInfectionData::M_oParams' has a wrong offset!");

// ScriptStruct BFGCore.BFGAimBallisticProjectileResponse
// 0x001C (0x001C - 0x0000)
struct FBFGAimBallisticProjectileResponse final
{
public:
	struct FVector                                M_vAimAtLocation;                                  // 0x0000(0x000C)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                M_vAimAtDirection;                                 // 0x000C(0x000C)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         M_fTimeOfImpact;                                   // 0x0018(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FBFGAimBallisticProjectileResponse) == 0x000004, "Wrong alignment on FBFGAimBallisticProjectileResponse");
static_assert(sizeof(FBFGAimBallisticProjectileResponse) == 0x00001C, "Wrong size on FBFGAimBallisticProjectileResponse");
static_assert(offsetof(FBFGAimBallisticProjectileResponse, M_vAimAtLocation) == 0x000000, "Member 'FBFGAimBallisticProjectileResponse::M_vAimAtLocation' has a wrong offset!");
static_assert(offsetof(FBFGAimBallisticProjectileResponse, M_vAimAtDirection) == 0x00000C, "Member 'FBFGAimBallisticProjectileResponse::M_vAimAtDirection' has a wrong offset!");
static_assert(offsetof(FBFGAimBallisticProjectileResponse, M_fTimeOfImpact) == 0x000018, "Member 'FBFGAimBallisticProjectileResponse::M_fTimeOfImpact' has a wrong offset!");

// ScriptStruct BFGCore.HUDShieldState
// 0x0014 (0x0014 - 0x0000)
struct alignas(0x04) FHUDShieldState final
{
public:
	uint8                                         Pad_0[0x14];                                       // 0x0000(0x0014)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FHUDShieldState) == 0x000004, "Wrong alignment on FHUDShieldState");
static_assert(sizeof(FHUDShieldState) == 0x000014, "Wrong size on FHUDShieldState");

// ScriptStruct BFGCore.BFGChaseSiteArrivalCounter
// 0x0018 (0x0018 - 0x0000)
struct FBFGChaseSiteArrivalCounter final
{
public:
	struct FBFGChaseTargetSite                    M_targetSite;                                      // 0x0000(0x0008)(Transient, NoDestructor, NativeAccessSpecifierPublic)
	EBFGNetworkPathExtremity                      M_eTargetExtremity;                                // 0x0008(0x0001)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_9[0xF];                                        // 0x0009(0x000F)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FBFGChaseSiteArrivalCounter) == 0x000008, "Wrong alignment on FBFGChaseSiteArrivalCounter");
static_assert(sizeof(FBFGChaseSiteArrivalCounter) == 0x000018, "Wrong size on FBFGChaseSiteArrivalCounter");
static_assert(offsetof(FBFGChaseSiteArrivalCounter, M_targetSite) == 0x000000, "Member 'FBFGChaseSiteArrivalCounter::M_targetSite' has a wrong offset!");
static_assert(offsetof(FBFGChaseSiteArrivalCounter, M_eTargetExtremity) == 0x000008, "Member 'FBFGChaseSiteArrivalCounter::M_eTargetExtremity' has a wrong offset!");

// ScriptStruct BFGCore.BFGCortexScanObjectiveTracker_Data
// 0x0040 (0x0040 - 0x0000)
struct FBFGCortexScanObjectiveTracker_Data final
{
public:
	class FName                                   M_strResponseSetName;                              // 0x0000(0x0008)(ZeroConstructor, SaveGame, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TSoftObjectPtr<class UBFGDataAsset_CortexScan> M_softDataAsset;                                   // 0x0008(0x0028)(SaveGame, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TArray<class FText>                           M_aAddedResponses;                                 // 0x0030(0x0010)(ZeroConstructor, SaveGame, NativeAccessSpecifierPublic)
};
static_assert(alignof(FBFGCortexScanObjectiveTracker_Data) == 0x000008, "Wrong alignment on FBFGCortexScanObjectiveTracker_Data");
static_assert(sizeof(FBFGCortexScanObjectiveTracker_Data) == 0x000040, "Wrong size on FBFGCortexScanObjectiveTracker_Data");
static_assert(offsetof(FBFGCortexScanObjectiveTracker_Data, M_strResponseSetName) == 0x000000, "Member 'FBFGCortexScanObjectiveTracker_Data::M_strResponseSetName' has a wrong offset!");
static_assert(offsetof(FBFGCortexScanObjectiveTracker_Data, M_softDataAsset) == 0x000008, "Member 'FBFGCortexScanObjectiveTracker_Data::M_softDataAsset' has a wrong offset!");
static_assert(offsetof(FBFGCortexScanObjectiveTracker_Data, M_aAddedResponses) == 0x000030, "Member 'FBFGCortexScanObjectiveTracker_Data::M_aAddedResponses' has a wrong offset!");

// ScriptStruct BFGCore.BFGSystemData_QuestManager_CortexScanObjectiveTracker
// 0x0018 (0x0018 - 0x0000)
struct FBFGSystemData_QuestManager_CortexScanObjectiveTracker final
{
public:
	class FName                                   M_strIdentifier;                                   // 0x0000(0x0008)(ZeroConstructor, SaveGame, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TArray<struct FBFGCortexScanObjectiveTracker_Data> M_aData;                                           // 0x0008(0x0010)(ZeroConstructor, SaveGame, NativeAccessSpecifierPublic)
};
static_assert(alignof(FBFGSystemData_QuestManager_CortexScanObjectiveTracker) == 0x000008, "Wrong alignment on FBFGSystemData_QuestManager_CortexScanObjectiveTracker");
static_assert(sizeof(FBFGSystemData_QuestManager_CortexScanObjectiveTracker) == 0x000018, "Wrong size on FBFGSystemData_QuestManager_CortexScanObjectiveTracker");
static_assert(offsetof(FBFGSystemData_QuestManager_CortexScanObjectiveTracker, M_strIdentifier) == 0x000000, "Member 'FBFGSystemData_QuestManager_CortexScanObjectiveTracker::M_strIdentifier' has a wrong offset!");
static_assert(offsetof(FBFGSystemData_QuestManager_CortexScanObjectiveTracker, M_aData) == 0x000008, "Member 'FBFGSystemData_QuestManager_CortexScanObjectiveTracker::M_aData' has a wrong offset!");

// ScriptStruct BFGCore.BFGSystemData_QuestManager
// 0x01D0 (0x01D0 - 0x0000)
struct FBFGSystemData_QuestManager final
{
public:
	int32                                         M_iVersion_QuestStructure;                         // 0x0000(0x0004)(ZeroConstructor, SaveGame, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EBFGGameSession_QuestDirective                M_questDirective;                                  // 0x0004(0x0001)(ZeroConstructor, SaveGame, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_5[0x3];                                        // 0x0005(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	TSoftClassPtr<class UClass>                   M_softQuestClass;                                  // 0x0008(0x0028)(SaveGame, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TSoftObjectPtr<class UBFGEnvironment>         M_softTargetEnvironment;                           // 0x0030(0x0028)(SaveGame, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TMap<class FName, struct FGuid>               M_aSubQuestIds;                                    // 0x0058(0x0050)(ZeroConstructor, SaveGame, NativeAccessSpecifierPublic)
	TMap<class FName, float>                      M_aQuestTimerInfo;                                 // 0x00A8(0x0050)(ZeroConstructor, SaveGame, NativeAccessSpecifierPublic)
	TSoftObjectPtr<class ABFGLevelCheckpoint>     M_softCheckpoint;                                  // 0x00F8(0x0028)(SaveGame, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TMap<class FName, float>                      M_aChallengeHighScore;                             // 0x0120(0x0050)(ZeroConstructor, SaveGame, NativeAccessSpecifierPublic)
	TMap<struct FGuid, struct FBFGSystemData_QuestManager_CompletionRating> M_aQuestCompletionRating;                          // 0x0170(0x0050)(ZeroConstructor, SaveGame, NativeAccessSpecifierPublic)
	TArray<struct FBFGSystemData_QuestManager_CortexScanObjectiveTracker> M_aCortexScanTrackers;                             // 0x01C0(0x0010)(ZeroConstructor, SaveGame, NativeAccessSpecifierPublic)
};
static_assert(alignof(FBFGSystemData_QuestManager) == 0x000008, "Wrong alignment on FBFGSystemData_QuestManager");
static_assert(sizeof(FBFGSystemData_QuestManager) == 0x0001D0, "Wrong size on FBFGSystemData_QuestManager");
static_assert(offsetof(FBFGSystemData_QuestManager, M_iVersion_QuestStructure) == 0x000000, "Member 'FBFGSystemData_QuestManager::M_iVersion_QuestStructure' has a wrong offset!");
static_assert(offsetof(FBFGSystemData_QuestManager, M_questDirective) == 0x000004, "Member 'FBFGSystemData_QuestManager::M_questDirective' has a wrong offset!");
static_assert(offsetof(FBFGSystemData_QuestManager, M_softQuestClass) == 0x000008, "Member 'FBFGSystemData_QuestManager::M_softQuestClass' has a wrong offset!");
static_assert(offsetof(FBFGSystemData_QuestManager, M_softTargetEnvironment) == 0x000030, "Member 'FBFGSystemData_QuestManager::M_softTargetEnvironment' has a wrong offset!");
static_assert(offsetof(FBFGSystemData_QuestManager, M_aSubQuestIds) == 0x000058, "Member 'FBFGSystemData_QuestManager::M_aSubQuestIds' has a wrong offset!");
static_assert(offsetof(FBFGSystemData_QuestManager, M_aQuestTimerInfo) == 0x0000A8, "Member 'FBFGSystemData_QuestManager::M_aQuestTimerInfo' has a wrong offset!");
static_assert(offsetof(FBFGSystemData_QuestManager, M_softCheckpoint) == 0x0000F8, "Member 'FBFGSystemData_QuestManager::M_softCheckpoint' has a wrong offset!");
static_assert(offsetof(FBFGSystemData_QuestManager, M_aChallengeHighScore) == 0x000120, "Member 'FBFGSystemData_QuestManager::M_aChallengeHighScore' has a wrong offset!");
static_assert(offsetof(FBFGSystemData_QuestManager, M_aQuestCompletionRating) == 0x000170, "Member 'FBFGSystemData_QuestManager::M_aQuestCompletionRating' has a wrong offset!");
static_assert(offsetof(FBFGSystemData_QuestManager, M_aCortexScanTrackers) == 0x0001C0, "Member 'FBFGSystemData_QuestManager::M_aCortexScanTrackers' has a wrong offset!");

// ScriptStruct BFGCore.BFGQuest_StreamingRequester
// 0x0038 (0x0038 - 0x0000)
struct FBFGQuest_StreamingRequester final
{
public:
	TArray<TSoftObjectPtr<class UWorld>>          M_aLoadLevels;                                     // 0x0000(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, UObjectWrapper, NativeAccessSpecifierPublic)
	TArray<TSoftObjectPtr<class UWorld>>          M_aUnloadLevels;                                   // 0x0010(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, UObjectWrapper, NativeAccessSpecifierPublic)
	bool                                          M_bRemainLoaded;                                   // 0x0020(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_21[0x7];                                       // 0x0021(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	class UBFGQuest_StreamingLevels*              M_pLoadLevelsTracker;                              // 0x0028(0x0008)(ExportObject, ZeroConstructor, Transient, InstancedReference, IsPlainOldData, NoDestructor, Protected, PersistentInstance, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UBFGQuest_StreamingLevels*              M_pUnloadLevelsTracker;                            // 0x0030(0x0008)(ExportObject, ZeroConstructor, Transient, InstancedReference, IsPlainOldData, NoDestructor, Protected, PersistentInstance, HasGetValueTypeHash, NativeAccessSpecifierProtected)
};
static_assert(alignof(FBFGQuest_StreamingRequester) == 0x000008, "Wrong alignment on FBFGQuest_StreamingRequester");
static_assert(sizeof(FBFGQuest_StreamingRequester) == 0x000038, "Wrong size on FBFGQuest_StreamingRequester");
static_assert(offsetof(FBFGQuest_StreamingRequester, M_aLoadLevels) == 0x000000, "Member 'FBFGQuest_StreamingRequester::M_aLoadLevels' has a wrong offset!");
static_assert(offsetof(FBFGQuest_StreamingRequester, M_aUnloadLevels) == 0x000010, "Member 'FBFGQuest_StreamingRequester::M_aUnloadLevels' has a wrong offset!");
static_assert(offsetof(FBFGQuest_StreamingRequester, M_bRemainLoaded) == 0x000020, "Member 'FBFGQuest_StreamingRequester::M_bRemainLoaded' has a wrong offset!");
static_assert(offsetof(FBFGQuest_StreamingRequester, M_pLoadLevelsTracker) == 0x000028, "Member 'FBFGQuest_StreamingRequester::M_pLoadLevelsTracker' has a wrong offset!");
static_assert(offsetof(FBFGQuest_StreamingRequester, M_pUnloadLevelsTracker) == 0x000030, "Member 'FBFGQuest_StreamingRequester::M_pUnloadLevelsTracker' has a wrong offset!");

// ScriptStruct BFGCore.BFGNetworkPath_ScriptedPathParam
// 0x0018 (0x0018 - 0x0000)
struct FBFGNetworkPath_ScriptedPathParam final
{
public:
	struct FVector                                M_vTargetLocation;                                 // 0x0000(0x000C)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_C[0xC];                                        // 0x000C(0x000C)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FBFGNetworkPath_ScriptedPathParam) == 0x000004, "Wrong alignment on FBFGNetworkPath_ScriptedPathParam");
static_assert(sizeof(FBFGNetworkPath_ScriptedPathParam) == 0x000018, "Wrong size on FBFGNetworkPath_ScriptedPathParam");
static_assert(offsetof(FBFGNetworkPath_ScriptedPathParam, M_vTargetLocation) == 0x000000, "Member 'FBFGNetworkPath_ScriptedPathParam::M_vTargetLocation' has a wrong offset!");

// ScriptStruct BFGCore.BFGChaseSiteArrivalWish
// 0x0010 (0x0010 - 0x0000)
struct FBFGChaseSiteArrivalWish final
{
public:
	class UBFGNetworkPath*                        M_pNetworkPath;                                    // 0x0000(0x0008)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_8[0x8];                                        // 0x0008(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FBFGChaseSiteArrivalWish) == 0x000008, "Wrong alignment on FBFGChaseSiteArrivalWish");
static_assert(sizeof(FBFGChaseSiteArrivalWish) == 0x000010, "Wrong size on FBFGChaseSiteArrivalWish");
static_assert(offsetof(FBFGChaseSiteArrivalWish, M_pNetworkPath) == 0x000000, "Member 'FBFGChaseSiteArrivalWish::M_pNetworkPath' has a wrong offset!");

// ScriptStruct BFGCore.BFGChaseSiteArrival
// 0x0010 (0x0010 - 0x0000)
struct FBFGChaseSiteArrival final
{
public:
	class UBFGNetworkPath*                        M_pNetworkPath;                                    // 0x0000(0x0008)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EBFGNetworkPathExtremity                      M_eTargetExtremityAtArrival;                       // 0x0008(0x0001)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_9[0x7];                                        // 0x0009(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FBFGChaseSiteArrival) == 0x000008, "Wrong alignment on FBFGChaseSiteArrival");
static_assert(sizeof(FBFGChaseSiteArrival) == 0x000010, "Wrong size on FBFGChaseSiteArrival");
static_assert(offsetof(FBFGChaseSiteArrival, M_pNetworkPath) == 0x000000, "Member 'FBFGChaseSiteArrival::M_pNetworkPath' has a wrong offset!");
static_assert(offsetof(FBFGChaseSiteArrival, M_eTargetExtremityAtArrival) == 0x000008, "Member 'FBFGChaseSiteArrival::M_eTargetExtremityAtArrival' has a wrong offset!");

// ScriptStruct BFGCore.BFGChaseParticipant
// 0x0028 (0x0028 - 0x0000)
struct FBFGChaseParticipant final
{
public:
	int32                                         M_iParticipantId;                                  // 0x0000(0x0004)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_4[0x4];                                        // 0x0004(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class UBFGNetworkPathAgent*                   M_pAgent;                                          // 0x0008(0x0008)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_10[0x8];                                       // 0x0010(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	struct FBFGChaseSiteArrival                   M_arrival;                                         // 0x0018(0x0010)(Transient, NoDestructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(FBFGChaseParticipant) == 0x000008, "Wrong alignment on FBFGChaseParticipant");
static_assert(sizeof(FBFGChaseParticipant) == 0x000028, "Wrong size on FBFGChaseParticipant");
static_assert(offsetof(FBFGChaseParticipant, M_iParticipantId) == 0x000000, "Member 'FBFGChaseParticipant::M_iParticipantId' has a wrong offset!");
static_assert(offsetof(FBFGChaseParticipant, M_pAgent) == 0x000008, "Member 'FBFGChaseParticipant::M_pAgent' has a wrong offset!");
static_assert(offsetof(FBFGChaseParticipant, M_arrival) == 0x000018, "Member 'FBFGChaseParticipant::M_arrival' has a wrong offset!");

// ScriptStruct BFGCore.BFGAlertEventNotification
// 0x0018 (0x0018 - 0x0000)
struct FBFGAlertEventNotification final
{
public:
	class UObject*                                M_pVictim;                                         // 0x0000(0x0008)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UObject*                                M_pWitness;                                        // 0x0008(0x0008)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         M_fTimerSinceNotified;                             // 0x0010(0x0004)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_14[0x4];                                       // 0x0014(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FBFGAlertEventNotification) == 0x000008, "Wrong alignment on FBFGAlertEventNotification");
static_assert(sizeof(FBFGAlertEventNotification) == 0x000018, "Wrong size on FBFGAlertEventNotification");
static_assert(offsetof(FBFGAlertEventNotification, M_pVictim) == 0x000000, "Member 'FBFGAlertEventNotification::M_pVictim' has a wrong offset!");
static_assert(offsetof(FBFGAlertEventNotification, M_pWitness) == 0x000008, "Member 'FBFGAlertEventNotification::M_pWitness' has a wrong offset!");
static_assert(offsetof(FBFGAlertEventNotification, M_fTimerSinceNotified) == 0x000010, "Member 'FBFGAlertEventNotification::M_fTimerSinceNotified' has a wrong offset!");

// ScriptStruct BFGCore.BFGAlertEventNotificationSet
// 0x0030 (0x0030 - 0x0000)
struct FBFGAlertEventNotificationSet final
{
public:
	struct FBFGAlertTriggerDef                    M_alertTrigger;                                    // 0x0000(0x0020)(Transient, NoDestructor, NativeAccessSpecifierPublic)
	TArray<struct FBFGAlertEventNotification>     M_notifications;                                   // 0x0020(0x0010)(ZeroConstructor, Transient, NativeAccessSpecifierPublic)
};
static_assert(alignof(FBFGAlertEventNotificationSet) == 0x000008, "Wrong alignment on FBFGAlertEventNotificationSet");
static_assert(sizeof(FBFGAlertEventNotificationSet) == 0x000030, "Wrong size on FBFGAlertEventNotificationSet");
static_assert(offsetof(FBFGAlertEventNotificationSet, M_alertTrigger) == 0x000000, "Member 'FBFGAlertEventNotificationSet::M_alertTrigger' has a wrong offset!");
static_assert(offsetof(FBFGAlertEventNotificationSet, M_notifications) == 0x000020, "Member 'FBFGAlertEventNotificationSet::M_notifications' has a wrong offset!");

// ScriptStruct BFGCore.BFGAIStatVariable
// 0x0058 (0x0058 - 0x0000)
struct alignas(0x08) FBFGAIStatVariable final
{
public:
	uint8                                         Pad_0[0x58];                                       // 0x0000(0x0058)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FBFGAIStatVariable) == 0x000008, "Wrong alignment on FBFGAIStatVariable");
static_assert(sizeof(FBFGAIStatVariable) == 0x000058, "Wrong size on FBFGAIStatVariable");

// ScriptStruct BFGCore.BFGAIStatVariableTableRow
// 0x0068 (0x0070 - 0x0008)
struct FBFGAIStatVariableTableRow final : public FTableRowBase
{
public:
	EBFGAIStatVariableName                        M_eVariable;                                       // 0x0008(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_9[0x3];                                        // 0x0009(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         M_fValue;                                          // 0x000C(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TArray<EBFGBehaviourState_NPC>                M_alertStates;                                     // 0x0010(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, NativeAccessSpecifierPublic)
	int32                                         M_eTargetType;                                     // 0x0020(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_24[0x4];                                       // 0x0024(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	struct FGameplayTagQuery                      M_actorQuery;                                      // 0x0028(0x0048)(Edit, BlueprintVisible, BlueprintReadOnly, DisableEditOnInstance, NativeAccessSpecifierPublic)
};
static_assert(alignof(FBFGAIStatVariableTableRow) == 0x000008, "Wrong alignment on FBFGAIStatVariableTableRow");
static_assert(sizeof(FBFGAIStatVariableTableRow) == 0x000070, "Wrong size on FBFGAIStatVariableTableRow");
static_assert(offsetof(FBFGAIStatVariableTableRow, M_eVariable) == 0x000008, "Member 'FBFGAIStatVariableTableRow::M_eVariable' has a wrong offset!");
static_assert(offsetof(FBFGAIStatVariableTableRow, M_fValue) == 0x00000C, "Member 'FBFGAIStatVariableTableRow::M_fValue' has a wrong offset!");
static_assert(offsetof(FBFGAIStatVariableTableRow, M_alertStates) == 0x000010, "Member 'FBFGAIStatVariableTableRow::M_alertStates' has a wrong offset!");
static_assert(offsetof(FBFGAIStatVariableTableRow, M_eTargetType) == 0x000020, "Member 'FBFGAIStatVariableTableRow::M_eTargetType' has a wrong offset!");
static_assert(offsetof(FBFGAIStatVariableTableRow, M_actorQuery) == 0x000028, "Member 'FBFGAIStatVariableTableRow::M_actorQuery' has a wrong offset!");

// ScriptStruct BFGCore.TickTrafficCrowdFunction
// 0x0008 (0x0078 - 0x0070)
struct FTickTrafficCrowdFunction final : public FTickFunction
{
public:
	class UBFGTrafficCrowdManager*                M_pManager;                                        // 0x0070(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FTickTrafficCrowdFunction) == 0x000008, "Wrong alignment on FTickTrafficCrowdFunction");
static_assert(sizeof(FTickTrafficCrowdFunction) == 0x000078, "Wrong size on FTickTrafficCrowdFunction");
static_assert(offsetof(FTickTrafficCrowdFunction, M_pManager) == 0x000070, "Member 'FTickTrafficCrowdFunction::M_pManager' has a wrong offset!");

// ScriptStruct BFGCore.BFGAlertEventDefinitionRow
// 0x01D8 (0x01E0 - 0x0008)
struct FBFGAlertEventDefinitionRow final : public FTableRowBase
{
public:
	class FName                                   M_strAlertEventDisplayName;                        // 0x0008(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         M_fAlertValue;                                     // 0x0010(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         M_fCooldown;                                       // 0x0014(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         M_fResponseValueCap;                               // 0x0018(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         M_iMaxWitnesses;                                   // 0x001C(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          M_bIsDelayed;                                      // 0x0020(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EBFGAlertTriggerMode                          M_eTriggerMode;                                    // 0x0021(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_22[0x6];                                       // 0x0022(0x0006)(Fixing Size After Last Property [ Dumper-7 ])
	struct FBFGActorBinding                       M_alertInstigator;                                 // 0x0028(0x0090)(Edit, BlueprintVisible, BlueprintReadOnly, EditConst, NativeAccessSpecifierPublic)
	struct FBFGActorBinding                       M_witness;                                         // 0x00B8(0x0090)(Edit, BlueprintVisible, BlueprintReadOnly, NativeAccessSpecifierPublic)
	struct FBFGActorBinding                       M_victim;                                          // 0x0148(0x0090)(Edit, BlueprintVisible, BlueprintReadOnly, NativeAccessSpecifierPublic)
	EBFGAlertType                                 M_eAlertType;                                      // 0x01D8(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1D9[0x7];                                      // 0x01D9(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FBFGAlertEventDefinitionRow) == 0x000008, "Wrong alignment on FBFGAlertEventDefinitionRow");
static_assert(sizeof(FBFGAlertEventDefinitionRow) == 0x0001E0, "Wrong size on FBFGAlertEventDefinitionRow");
static_assert(offsetof(FBFGAlertEventDefinitionRow, M_strAlertEventDisplayName) == 0x000008, "Member 'FBFGAlertEventDefinitionRow::M_strAlertEventDisplayName' has a wrong offset!");
static_assert(offsetof(FBFGAlertEventDefinitionRow, M_fAlertValue) == 0x000010, "Member 'FBFGAlertEventDefinitionRow::M_fAlertValue' has a wrong offset!");
static_assert(offsetof(FBFGAlertEventDefinitionRow, M_fCooldown) == 0x000014, "Member 'FBFGAlertEventDefinitionRow::M_fCooldown' has a wrong offset!");
static_assert(offsetof(FBFGAlertEventDefinitionRow, M_fResponseValueCap) == 0x000018, "Member 'FBFGAlertEventDefinitionRow::M_fResponseValueCap' has a wrong offset!");
static_assert(offsetof(FBFGAlertEventDefinitionRow, M_iMaxWitnesses) == 0x00001C, "Member 'FBFGAlertEventDefinitionRow::M_iMaxWitnesses' has a wrong offset!");
static_assert(offsetof(FBFGAlertEventDefinitionRow, M_bIsDelayed) == 0x000020, "Member 'FBFGAlertEventDefinitionRow::M_bIsDelayed' has a wrong offset!");
static_assert(offsetof(FBFGAlertEventDefinitionRow, M_eTriggerMode) == 0x000021, "Member 'FBFGAlertEventDefinitionRow::M_eTriggerMode' has a wrong offset!");
static_assert(offsetof(FBFGAlertEventDefinitionRow, M_alertInstigator) == 0x000028, "Member 'FBFGAlertEventDefinitionRow::M_alertInstigator' has a wrong offset!");
static_assert(offsetof(FBFGAlertEventDefinitionRow, M_witness) == 0x0000B8, "Member 'FBFGAlertEventDefinitionRow::M_witness' has a wrong offset!");
static_assert(offsetof(FBFGAlertEventDefinitionRow, M_victim) == 0x000148, "Member 'FBFGAlertEventDefinitionRow::M_victim' has a wrong offset!");
static_assert(offsetof(FBFGAlertEventDefinitionRow, M_eAlertType) == 0x0001D8, "Member 'FBFGAlertEventDefinitionRow::M_eAlertType' has a wrong offset!");

// ScriptStruct BFGCore.BFGDeferredSpawnRequest
// 0x00A8 (0x00A8 - 0x0000)
struct FBFGDeferredSpawnRequest final
{
public:
	struct FGameplayTagContainer                  M_gameplayTags;                                    // 0x0000(0x0020)(Transient, NativeAccessSpecifierPublic)
	class UBFGSpawningComposition*                M_pSpawningCompositionAsset;                       // 0x0020(0x0008)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         M_iNumRemainingToSpawn;                            // 0x0028(0x0004)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EBFGBehaviourState_NPC                        M_eBehaviorState;                                  // 0x002C(0x0001)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2D[0x3];                                       // 0x002D(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	class AActor*                                 M_pSuspiciousTarget;                               // 0x0030(0x0008)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FBFGResponseLevelSpawnWave_SpawnAroundPlayer M_spawnAroundPlayerInfo;                           // 0x0038(0x000C)(Transient, NoDestructor, NativeAccessSpecifierPublic)
	uint8                                         Pad_44[0x4];                                       // 0x0044(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	struct FBFGSpawnRequestVehicleData            M_vehicleData;                                     // 0x0048(0x0058)(Transient, NativeAccessSpecifierPublic)
	bool                                          M_bHasPassengerOverride;                           // 0x00A0(0x0001)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_A1[0x7];                                       // 0x00A1(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FBFGDeferredSpawnRequest) == 0x000008, "Wrong alignment on FBFGDeferredSpawnRequest");
static_assert(sizeof(FBFGDeferredSpawnRequest) == 0x0000A8, "Wrong size on FBFGDeferredSpawnRequest");
static_assert(offsetof(FBFGDeferredSpawnRequest, M_gameplayTags) == 0x000000, "Member 'FBFGDeferredSpawnRequest::M_gameplayTags' has a wrong offset!");
static_assert(offsetof(FBFGDeferredSpawnRequest, M_pSpawningCompositionAsset) == 0x000020, "Member 'FBFGDeferredSpawnRequest::M_pSpawningCompositionAsset' has a wrong offset!");
static_assert(offsetof(FBFGDeferredSpawnRequest, M_iNumRemainingToSpawn) == 0x000028, "Member 'FBFGDeferredSpawnRequest::M_iNumRemainingToSpawn' has a wrong offset!");
static_assert(offsetof(FBFGDeferredSpawnRequest, M_eBehaviorState) == 0x00002C, "Member 'FBFGDeferredSpawnRequest::M_eBehaviorState' has a wrong offset!");
static_assert(offsetof(FBFGDeferredSpawnRequest, M_pSuspiciousTarget) == 0x000030, "Member 'FBFGDeferredSpawnRequest::M_pSuspiciousTarget' has a wrong offset!");
static_assert(offsetof(FBFGDeferredSpawnRequest, M_spawnAroundPlayerInfo) == 0x000038, "Member 'FBFGDeferredSpawnRequest::M_spawnAroundPlayerInfo' has a wrong offset!");
static_assert(offsetof(FBFGDeferredSpawnRequest, M_vehicleData) == 0x000048, "Member 'FBFGDeferredSpawnRequest::M_vehicleData' has a wrong offset!");
static_assert(offsetof(FBFGDeferredSpawnRequest, M_bHasPassengerOverride) == 0x0000A0, "Member 'FBFGDeferredSpawnRequest::M_bHasPassengerOverride' has a wrong offset!");

// ScriptStruct BFGCore.BFGMissionOrbitalTransporterTarget
// 0x0010 (0x0010 - 0x0000)
struct FBFGMissionOrbitalTransporterTarget final
{
public:
	class AActor*                                 M_pTarget;                                         // 0x0000(0x0008)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_8[0x8];                                        // 0x0008(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FBFGMissionOrbitalTransporterTarget) == 0x000008, "Wrong alignment on FBFGMissionOrbitalTransporterTarget");
static_assert(sizeof(FBFGMissionOrbitalTransporterTarget) == 0x000010, "Wrong size on FBFGMissionOrbitalTransporterTarget");
static_assert(offsetof(FBFGMissionOrbitalTransporterTarget, M_pTarget) == 0x000000, "Member 'FBFGMissionOrbitalTransporterTarget::M_pTarget' has a wrong offset!");

// ScriptStruct BFGCore.BFGAlertEventCoolDownItem
// 0x0004 (0x0004 - 0x0000)
struct FBFGAlertEventCoolDownItem final
{
public:
	float                                         M_fRemainingTime;                                  // 0x0000(0x0004)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FBFGAlertEventCoolDownItem) == 0x000004, "Wrong alignment on FBFGAlertEventCoolDownItem");
static_assert(sizeof(FBFGAlertEventCoolDownItem) == 0x000004, "Wrong size on FBFGAlertEventCoolDownItem");
static_assert(offsetof(FBFGAlertEventCoolDownItem, M_fRemainingTime) == 0x000000, "Member 'FBFGAlertEventCoolDownItem::M_fRemainingTime' has a wrong offset!");

// ScriptStruct BFGCore.BFGAlertEventCoolDownsDebugInfo
// 0x0020 (0x0020 - 0x0000)
struct FBFGAlertEventCoolDownsDebugInfo final
{
public:
	class FName                                   M_strTriggerName;                                  // 0x0000(0x0008)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         M_fCoolDownValue;                                  // 0x0008(0x0004)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_C[0x4];                                        // 0x000C(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<struct FBFGAlertEventCoolDownItem>     M_aEventsInCooldown;                               // 0x0010(0x0010)(ZeroConstructor, Transient, NativeAccessSpecifierPublic)
};
static_assert(alignof(FBFGAlertEventCoolDownsDebugInfo) == 0x000008, "Wrong alignment on FBFGAlertEventCoolDownsDebugInfo");
static_assert(sizeof(FBFGAlertEventCoolDownsDebugInfo) == 0x000020, "Wrong size on FBFGAlertEventCoolDownsDebugInfo");
static_assert(offsetof(FBFGAlertEventCoolDownsDebugInfo, M_strTriggerName) == 0x000000, "Member 'FBFGAlertEventCoolDownsDebugInfo::M_strTriggerName' has a wrong offset!");
static_assert(offsetof(FBFGAlertEventCoolDownsDebugInfo, M_fCoolDownValue) == 0x000008, "Member 'FBFGAlertEventCoolDownsDebugInfo::M_fCoolDownValue' has a wrong offset!");
static_assert(offsetof(FBFGAlertEventCoolDownsDebugInfo, M_aEventsInCooldown) == 0x000010, "Member 'FBFGAlertEventCoolDownsDebugInfo::M_aEventsInCooldown' has a wrong offset!");

// ScriptStruct BFGCore.BFGAICrowdLifeLeaveRequest
// 0x0001 (0x0001 - 0x0000)
struct FBFGAICrowdLifeLeaveRequest final
{
public:
	bool                                          M_bPanic;                                          // 0x0000(0x0001)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FBFGAICrowdLifeLeaveRequest) == 0x000001, "Wrong alignment on FBFGAICrowdLifeLeaveRequest");
static_assert(sizeof(FBFGAICrowdLifeLeaveRequest) == 0x000001, "Wrong size on FBFGAICrowdLifeLeaveRequest");
static_assert(offsetof(FBFGAICrowdLifeLeaveRequest, M_bPanic) == 0x000000, "Member 'FBFGAICrowdLifeLeaveRequest::M_bPanic' has a wrong offset!");

// ScriptStruct BFGCore.BFGTrafficPathFinder_PathWaypoint
// 0x0038 (0x0038 - 0x0000)
struct FBFGTrafficPathFinder_PathWaypoint final
{
public:
	class UBFGNetworkPath*                        M_pPath;                                           // 0x0000(0x0008)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	int32                                         M_iDirection;                                      // 0x0008(0x0004)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_C[0x4];                                        // 0x000C(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<struct FGuid>                          M_apNextPathWaypoints;                             // 0x0010(0x0010)(ZeroConstructor, Transient, NativeAccessSpecifierPrivate)
	struct FGuid                                  M_id;                                              // 0x0020(0x0010)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UBFGTrafficPathFinder_Network*          M_pNetwork;                                        // 0x0030(0x0008)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
};
static_assert(alignof(FBFGTrafficPathFinder_PathWaypoint) == 0x000008, "Wrong alignment on FBFGTrafficPathFinder_PathWaypoint");
static_assert(sizeof(FBFGTrafficPathFinder_PathWaypoint) == 0x000038, "Wrong size on FBFGTrafficPathFinder_PathWaypoint");
static_assert(offsetof(FBFGTrafficPathFinder_PathWaypoint, M_pPath) == 0x000000, "Member 'FBFGTrafficPathFinder_PathWaypoint::M_pPath' has a wrong offset!");
static_assert(offsetof(FBFGTrafficPathFinder_PathWaypoint, M_iDirection) == 0x000008, "Member 'FBFGTrafficPathFinder_PathWaypoint::M_iDirection' has a wrong offset!");
static_assert(offsetof(FBFGTrafficPathFinder_PathWaypoint, M_apNextPathWaypoints) == 0x000010, "Member 'FBFGTrafficPathFinder_PathWaypoint::M_apNextPathWaypoints' has a wrong offset!");
static_assert(offsetof(FBFGTrafficPathFinder_PathWaypoint, M_id) == 0x000020, "Member 'FBFGTrafficPathFinder_PathWaypoint::M_id' has a wrong offset!");
static_assert(offsetof(FBFGTrafficPathFinder_PathWaypoint, M_pNetwork) == 0x000030, "Member 'FBFGTrafficPathFinder_PathWaypoint::M_pNetwork' has a wrong offset!");

// ScriptStruct BFGCore.BFGVehicleAgentDriveInfo
// 0x005C (0x005C - 0x0000)
struct FBFGVehicleAgentDriveInfo final
{
public:
	float                                         M_fDesiredSpeed;                                   // 0x0000(0x0004)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                M_vCurrentDesiredTangent;                          // 0x0004(0x000C)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                M_vTargetLocation;                                 // 0x0010(0x000C)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                M_vTargetTangent;                                  // 0x001C(0x000C)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          M_bTargetRadiusMode;                               // 0x0028(0x0001)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_29[0x3];                                       // 0x0029(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         M_fTurnGradient;                                   // 0x002C(0x0004)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         M_fTargetTurnGradient;                             // 0x0030(0x0004)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         M_fTurnTimer;                                      // 0x0034(0x0004)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         M_fMaxSpeed;                                       // 0x0038(0x0004)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         M_fViewDistance;                                   // 0x003C(0x0004)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         M_fCurrentAcceleration;                            // 0x0040(0x0004)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         M_fTimeRemainingForAcceleration;                   // 0x0044(0x0004)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         M_fLastDeltaSpeed;                                 // 0x0048(0x0004)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          M_bDoBenchMark;                                    // 0x004C(0x0001)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          M_bNightLightsOn;                                  // 0x004D(0x0001)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          M_bBrakingLightsOn;                                // 0x004E(0x0001)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          M_bSirenOn;                                        // 0x004F(0x0001)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          M_bSirenLightOn;                                   // 0x0050(0x0001)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EBFGVehicleTurnLightMode                      M_eTurnLightsMode;                                 // 0x0051(0x0001)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_52[0x2];                                       // 0x0052(0x0002)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         M_fTargetOffsetFromCenter;                         // 0x0054(0x0004)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          M_bHandBrake;                                      // 0x0058(0x0001)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_59[0x3];                                       // 0x0059(0x0003)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FBFGVehicleAgentDriveInfo) == 0x000004, "Wrong alignment on FBFGVehicleAgentDriveInfo");
static_assert(sizeof(FBFGVehicleAgentDriveInfo) == 0x00005C, "Wrong size on FBFGVehicleAgentDriveInfo");
static_assert(offsetof(FBFGVehicleAgentDriveInfo, M_fDesiredSpeed) == 0x000000, "Member 'FBFGVehicleAgentDriveInfo::M_fDesiredSpeed' has a wrong offset!");
static_assert(offsetof(FBFGVehicleAgentDriveInfo, M_vCurrentDesiredTangent) == 0x000004, "Member 'FBFGVehicleAgentDriveInfo::M_vCurrentDesiredTangent' has a wrong offset!");
static_assert(offsetof(FBFGVehicleAgentDriveInfo, M_vTargetLocation) == 0x000010, "Member 'FBFGVehicleAgentDriveInfo::M_vTargetLocation' has a wrong offset!");
static_assert(offsetof(FBFGVehicleAgentDriveInfo, M_vTargetTangent) == 0x00001C, "Member 'FBFGVehicleAgentDriveInfo::M_vTargetTangent' has a wrong offset!");
static_assert(offsetof(FBFGVehicleAgentDriveInfo, M_bTargetRadiusMode) == 0x000028, "Member 'FBFGVehicleAgentDriveInfo::M_bTargetRadiusMode' has a wrong offset!");
static_assert(offsetof(FBFGVehicleAgentDriveInfo, M_fTurnGradient) == 0x00002C, "Member 'FBFGVehicleAgentDriveInfo::M_fTurnGradient' has a wrong offset!");
static_assert(offsetof(FBFGVehicleAgentDriveInfo, M_fTargetTurnGradient) == 0x000030, "Member 'FBFGVehicleAgentDriveInfo::M_fTargetTurnGradient' has a wrong offset!");
static_assert(offsetof(FBFGVehicleAgentDriveInfo, M_fTurnTimer) == 0x000034, "Member 'FBFGVehicleAgentDriveInfo::M_fTurnTimer' has a wrong offset!");
static_assert(offsetof(FBFGVehicleAgentDriveInfo, M_fMaxSpeed) == 0x000038, "Member 'FBFGVehicleAgentDriveInfo::M_fMaxSpeed' has a wrong offset!");
static_assert(offsetof(FBFGVehicleAgentDriveInfo, M_fViewDistance) == 0x00003C, "Member 'FBFGVehicleAgentDriveInfo::M_fViewDistance' has a wrong offset!");
static_assert(offsetof(FBFGVehicleAgentDriveInfo, M_fCurrentAcceleration) == 0x000040, "Member 'FBFGVehicleAgentDriveInfo::M_fCurrentAcceleration' has a wrong offset!");
static_assert(offsetof(FBFGVehicleAgentDriveInfo, M_fTimeRemainingForAcceleration) == 0x000044, "Member 'FBFGVehicleAgentDriveInfo::M_fTimeRemainingForAcceleration' has a wrong offset!");
static_assert(offsetof(FBFGVehicleAgentDriveInfo, M_fLastDeltaSpeed) == 0x000048, "Member 'FBFGVehicleAgentDriveInfo::M_fLastDeltaSpeed' has a wrong offset!");
static_assert(offsetof(FBFGVehicleAgentDriveInfo, M_bDoBenchMark) == 0x00004C, "Member 'FBFGVehicleAgentDriveInfo::M_bDoBenchMark' has a wrong offset!");
static_assert(offsetof(FBFGVehicleAgentDriveInfo, M_bNightLightsOn) == 0x00004D, "Member 'FBFGVehicleAgentDriveInfo::M_bNightLightsOn' has a wrong offset!");
static_assert(offsetof(FBFGVehicleAgentDriveInfo, M_bBrakingLightsOn) == 0x00004E, "Member 'FBFGVehicleAgentDriveInfo::M_bBrakingLightsOn' has a wrong offset!");
static_assert(offsetof(FBFGVehicleAgentDriveInfo, M_bSirenOn) == 0x00004F, "Member 'FBFGVehicleAgentDriveInfo::M_bSirenOn' has a wrong offset!");
static_assert(offsetof(FBFGVehicleAgentDriveInfo, M_bSirenLightOn) == 0x000050, "Member 'FBFGVehicleAgentDriveInfo::M_bSirenLightOn' has a wrong offset!");
static_assert(offsetof(FBFGVehicleAgentDriveInfo, M_eTurnLightsMode) == 0x000051, "Member 'FBFGVehicleAgentDriveInfo::M_eTurnLightsMode' has a wrong offset!");
static_assert(offsetof(FBFGVehicleAgentDriveInfo, M_fTargetOffsetFromCenter) == 0x000054, "Member 'FBFGVehicleAgentDriveInfo::M_fTargetOffsetFromCenter' has a wrong offset!");
static_assert(offsetof(FBFGVehicleAgentDriveInfo, M_bHandBrake) == 0x000058, "Member 'FBFGVehicleAgentDriveInfo::M_bHandBrake' has a wrong offset!");

// ScriptStruct BFGCore.BFGAlertEventLogItem
// 0x0010 (0x0010 - 0x0000)
struct FBFGAlertEventLogItem final
{
public:
	class FName                                   M_strTriggerName;                                  // 0x0000(0x0008)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         M_fResponseValueChange;                            // 0x0008(0x0004)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         M_fResponseValueCap;                               // 0x000C(0x0004)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FBFGAlertEventLogItem) == 0x000004, "Wrong alignment on FBFGAlertEventLogItem");
static_assert(sizeof(FBFGAlertEventLogItem) == 0x000010, "Wrong size on FBFGAlertEventLogItem");
static_assert(offsetof(FBFGAlertEventLogItem, M_strTriggerName) == 0x000000, "Member 'FBFGAlertEventLogItem::M_strTriggerName' has a wrong offset!");
static_assert(offsetof(FBFGAlertEventLogItem, M_fResponseValueChange) == 0x000008, "Member 'FBFGAlertEventLogItem::M_fResponseValueChange' has a wrong offset!");
static_assert(offsetof(FBFGAlertEventLogItem, M_fResponseValueCap) == 0x00000C, "Member 'FBFGAlertEventLogItem::M_fResponseValueCap' has a wrong offset!");

// ScriptStruct BFGCore.BFGResponseLevelSpawnedElementDebugInfo
// 0x0028 (0x0028 - 0x0000)
struct FBFGResponseLevelSpawnedElementDebugInfo final
{
public:
	struct FGameplayTagContainer                  M_gameplayTags;                                    // 0x0000(0x0020)(Transient, NativeAccessSpecifierPublic)
	int32                                         M_iNumSpawned;                                     // 0x0020(0x0004)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         M_iMaxToSpawn;                                     // 0x0024(0x0004)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FBFGResponseLevelSpawnedElementDebugInfo) == 0x000008, "Wrong alignment on FBFGResponseLevelSpawnedElementDebugInfo");
static_assert(sizeof(FBFGResponseLevelSpawnedElementDebugInfo) == 0x000028, "Wrong size on FBFGResponseLevelSpawnedElementDebugInfo");
static_assert(offsetof(FBFGResponseLevelSpawnedElementDebugInfo, M_gameplayTags) == 0x000000, "Member 'FBFGResponseLevelSpawnedElementDebugInfo::M_gameplayTags' has a wrong offset!");
static_assert(offsetof(FBFGResponseLevelSpawnedElementDebugInfo, M_iNumSpawned) == 0x000020, "Member 'FBFGResponseLevelSpawnedElementDebugInfo::M_iNumSpawned' has a wrong offset!");
static_assert(offsetof(FBFGResponseLevelSpawnedElementDebugInfo, M_iMaxToSpawn) == 0x000024, "Member 'FBFGResponseLevelSpawnedElementDebugInfo::M_iMaxToSpawn' has a wrong offset!");

// ScriptStruct BFGCore.BFGResponseLevelDebugInfo
// 0x0030 (0x0030 - 0x0000)
struct FBFGResponseLevelDebugInfo final
{
public:
	class FString                                 M_strLevelName;                                    // 0x0000(0x0010)(ZeroConstructor, Transient, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         M_fResponseValue;                                  // 0x0010(0x0004)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         M_fNextResponseLevelValue;                         // 0x0014(0x0004)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         M_fPreviousResponseLevelValue;                     // 0x0018(0x0004)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1C[0x4];                                       // 0x001C(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<struct FBFGResponseLevelSpawnedElementDebugInfo> M_aSpawnedElementsInfo;                            // 0x0020(0x0010)(ZeroConstructor, Transient, NativeAccessSpecifierPublic)
};
static_assert(alignof(FBFGResponseLevelDebugInfo) == 0x000008, "Wrong alignment on FBFGResponseLevelDebugInfo");
static_assert(sizeof(FBFGResponseLevelDebugInfo) == 0x000030, "Wrong size on FBFGResponseLevelDebugInfo");
static_assert(offsetof(FBFGResponseLevelDebugInfo, M_strLevelName) == 0x000000, "Member 'FBFGResponseLevelDebugInfo::M_strLevelName' has a wrong offset!");
static_assert(offsetof(FBFGResponseLevelDebugInfo, M_fResponseValue) == 0x000010, "Member 'FBFGResponseLevelDebugInfo::M_fResponseValue' has a wrong offset!");
static_assert(offsetof(FBFGResponseLevelDebugInfo, M_fNextResponseLevelValue) == 0x000014, "Member 'FBFGResponseLevelDebugInfo::M_fNextResponseLevelValue' has a wrong offset!");
static_assert(offsetof(FBFGResponseLevelDebugInfo, M_fPreviousResponseLevelValue) == 0x000018, "Member 'FBFGResponseLevelDebugInfo::M_fPreviousResponseLevelValue' has a wrong offset!");
static_assert(offsetof(FBFGResponseLevelDebugInfo, M_aSpawnedElementsInfo) == 0x000020, "Member 'FBFGResponseLevelDebugInfo::M_aSpawnedElementsInfo' has a wrong offset!");

// ScriptStruct BFGCore.BFGTrafficPathFinder_StackItem
// 0x0024 (0x0024 - 0x0000)
struct FBFGTrafficPathFinder_StackItem final
{
public:
	struct FGuid                                  M_waypointId;                                      // 0x0000(0x0010)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FGuid                                  M_previousWaypointId;                              // 0x0010(0x0010)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         M_iCurrentIndex;                                   // 0x0020(0x0004)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FBFGTrafficPathFinder_StackItem) == 0x000004, "Wrong alignment on FBFGTrafficPathFinder_StackItem");
static_assert(sizeof(FBFGTrafficPathFinder_StackItem) == 0x000024, "Wrong size on FBFGTrafficPathFinder_StackItem");
static_assert(offsetof(FBFGTrafficPathFinder_StackItem, M_waypointId) == 0x000000, "Member 'FBFGTrafficPathFinder_StackItem::M_waypointId' has a wrong offset!");
static_assert(offsetof(FBFGTrafficPathFinder_StackItem, M_previousWaypointId) == 0x000010, "Member 'FBFGTrafficPathFinder_StackItem::M_previousWaypointId' has a wrong offset!");
static_assert(offsetof(FBFGTrafficPathFinder_StackItem, M_iCurrentIndex) == 0x000020, "Member 'FBFGTrafficPathFinder_StackItem::M_iCurrentIndex' has a wrong offset!");

// ScriptStruct BFGCore.BFGHighlightableRuntimeInfo
// 0x0018 (0x0018 - 0x0000)
struct FBFGHighlightableRuntimeInfo final
{
public:
	class UBFGSceneComponent_HighlightableSceneObject* M_pObject;                                         // 0x0000(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TArray<class UBFGWidgetSceneObjectHighlighter*> M_apHighlighters;                                  // 0x0008(0x0010)(ExportObject, ZeroConstructor, ContainsInstancedReference, NativeAccessSpecifierPublic)
};
static_assert(alignof(FBFGHighlightableRuntimeInfo) == 0x000008, "Wrong alignment on FBFGHighlightableRuntimeInfo");
static_assert(sizeof(FBFGHighlightableRuntimeInfo) == 0x000018, "Wrong size on FBFGHighlightableRuntimeInfo");
static_assert(offsetof(FBFGHighlightableRuntimeInfo, M_pObject) == 0x000000, "Member 'FBFGHighlightableRuntimeInfo::M_pObject' has a wrong offset!");
static_assert(offsetof(FBFGHighlightableRuntimeInfo, M_apHighlighters) == 0x000008, "Member 'FBFGHighlightableRuntimeInfo::M_apHighlighters' has a wrong offset!");

// ScriptStruct BFGCore.BFGTankInfo
// 0x0040 (0x0040 - 0x0000)
struct FBFGTankInfo final
{
public:
	struct FRotator                               M_targetOrientation;                               // 0x0000(0x000C)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
	struct FVector                                M_vTargetLocation;                                 // 0x000C(0x000C)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EBFGWeaponAimingMode                          M_eAimingMode;                                     // 0x0018(0x0001)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_19[0x3];                                       // 0x0019(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         M_fStateTimer;                                     // 0x001C(0x0004)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FRotator                               M_pitch;                                           // 0x0020(0x000C)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
	struct FRotator                               M_yaw;                                             // 0x002C(0x000C)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
	class ABFGWeapon*                             M_pTankWeapon;                                     // 0x0038(0x0008)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FBFGTankInfo) == 0x000008, "Wrong alignment on FBFGTankInfo");
static_assert(sizeof(FBFGTankInfo) == 0x000040, "Wrong size on FBFGTankInfo");
static_assert(offsetof(FBFGTankInfo, M_targetOrientation) == 0x000000, "Member 'FBFGTankInfo::M_targetOrientation' has a wrong offset!");
static_assert(offsetof(FBFGTankInfo, M_vTargetLocation) == 0x00000C, "Member 'FBFGTankInfo::M_vTargetLocation' has a wrong offset!");
static_assert(offsetof(FBFGTankInfo, M_eAimingMode) == 0x000018, "Member 'FBFGTankInfo::M_eAimingMode' has a wrong offset!");
static_assert(offsetof(FBFGTankInfo, M_fStateTimer) == 0x00001C, "Member 'FBFGTankInfo::M_fStateTimer' has a wrong offset!");
static_assert(offsetof(FBFGTankInfo, M_pitch) == 0x000020, "Member 'FBFGTankInfo::M_pitch' has a wrong offset!");
static_assert(offsetof(FBFGTankInfo, M_yaw) == 0x00002C, "Member 'FBFGTankInfo::M_yaw' has a wrong offset!");
static_assert(offsetof(FBFGTankInfo, M_pTankWeapon) == 0x000038, "Member 'FBFGTankInfo::M_pTankWeapon' has a wrong offset!");

// ScriptStruct BFGCore.BFGPopulationControlDef
// 0x0028 (0x0028 - 0x0000)
struct FBFGPopulationControlDef final
{
public:
	int32                                         CountMax;                                          // 0x0000(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_4[0x4];                                        // 0x0004(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	struct FGameplayTagContainer                  GameplayTag;                                       // 0x0008(0x0020)(Edit, BlueprintVisible, BlueprintReadOnly, DisableEditOnInstance, NativeAccessSpecifierPublic)
};
static_assert(alignof(FBFGPopulationControlDef) == 0x000008, "Wrong alignment on FBFGPopulationControlDef");
static_assert(sizeof(FBFGPopulationControlDef) == 0x000028, "Wrong size on FBFGPopulationControlDef");
static_assert(offsetof(FBFGPopulationControlDef, CountMax) == 0x000000, "Member 'FBFGPopulationControlDef::CountMax' has a wrong offset!");
static_assert(offsetof(FBFGPopulationControlDef, GameplayTag) == 0x000008, "Member 'FBFGPopulationControlDef::GameplayTag' has a wrong offset!");

// ScriptStruct BFGCore.BFGResponseLevelDef
// 0x0030 (0x0030 - 0x0000)
struct FBFGResponseLevelDef final
{
public:
	class FString                                 LevelName;                                         // 0x0000(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TSubclassOf<class UBFGAlertResponseLevelState> ResponseLevelState;                                // 0x0010(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         M_fActivationThreshold;                            // 0x0018(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         M_fDeactivationThreshold;                          // 0x001C(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TArray<struct FBFGResponseLevelSpawnWave>     SpawningWaves;                                     // 0x0020(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, NativeAccessSpecifierPublic)
};
static_assert(alignof(FBFGResponseLevelDef) == 0x000008, "Wrong alignment on FBFGResponseLevelDef");
static_assert(sizeof(FBFGResponseLevelDef) == 0x000030, "Wrong size on FBFGResponseLevelDef");
static_assert(offsetof(FBFGResponseLevelDef, LevelName) == 0x000000, "Member 'FBFGResponseLevelDef::LevelName' has a wrong offset!");
static_assert(offsetof(FBFGResponseLevelDef, ResponseLevelState) == 0x000010, "Member 'FBFGResponseLevelDef::ResponseLevelState' has a wrong offset!");
static_assert(offsetof(FBFGResponseLevelDef, M_fActivationThreshold) == 0x000018, "Member 'FBFGResponseLevelDef::M_fActivationThreshold' has a wrong offset!");
static_assert(offsetof(FBFGResponseLevelDef, M_fDeactivationThreshold) == 0x00001C, "Member 'FBFGResponseLevelDef::M_fDeactivationThreshold' has a wrong offset!");
static_assert(offsetof(FBFGResponseLevelDef, SpawningWaves) == 0x000020, "Member 'FBFGResponseLevelDef::SpawningWaves' has a wrong offset!");

// ScriptStruct BFGCore.BFGPopulationByTags
// 0x0030 (0x0030 - 0x0000)
struct FBFGPopulationByTags final
{
public:
	TSubclassOf<class AActor>                     Actortype;                                         // 0x0000(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         Count;                                             // 0x0008(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         CountMax;                                          // 0x000C(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FGameplayTagContainer                  GameplayTags;                                      // 0x0010(0x0020)(Edit, BlueprintVisible, BlueprintReadOnly, DisableEditOnInstance, NativeAccessSpecifierPublic)
};
static_assert(alignof(FBFGPopulationByTags) == 0x000008, "Wrong alignment on FBFGPopulationByTags");
static_assert(sizeof(FBFGPopulationByTags) == 0x000030, "Wrong size on FBFGPopulationByTags");
static_assert(offsetof(FBFGPopulationByTags, Actortype) == 0x000000, "Member 'FBFGPopulationByTags::Actortype' has a wrong offset!");
static_assert(offsetof(FBFGPopulationByTags, Count) == 0x000008, "Member 'FBFGPopulationByTags::Count' has a wrong offset!");
static_assert(offsetof(FBFGPopulationByTags, CountMax) == 0x00000C, "Member 'FBFGPopulationByTags::CountMax' has a wrong offset!");
static_assert(offsetof(FBFGPopulationByTags, GameplayTags) == 0x000010, "Member 'FBFGPopulationByTags::GameplayTags' has a wrong offset!");

// ScriptStruct BFGCore.BFGVehicleObstacleInFront
// 0x0084 (0x0084 - 0x0000)
struct FBFGVehicleObstacleInFront final
{
public:
	bool                                          M_bHasObstacleInFront;                             // 0x0000(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          M_bShouldHonk;                                     // 0x0001(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          M_bShouldBrake;                                    // 0x0002(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_3[0x1];                                        // 0x0003(0x0001)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         M_fObstacleInFrontStateTime;                       // 0x0004(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         M_fObstacleInFrontStartHonkingDelay;               // 0x0008(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         M_fObstacleInFrontTimeBeforeNextHonk;              // 0x000C(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_10[0x74];                                      // 0x0010(0x0074)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FBFGVehicleObstacleInFront) == 0x000004, "Wrong alignment on FBFGVehicleObstacleInFront");
static_assert(sizeof(FBFGVehicleObstacleInFront) == 0x000084, "Wrong size on FBFGVehicleObstacleInFront");
static_assert(offsetof(FBFGVehicleObstacleInFront, M_bHasObstacleInFront) == 0x000000, "Member 'FBFGVehicleObstacleInFront::M_bHasObstacleInFront' has a wrong offset!");
static_assert(offsetof(FBFGVehicleObstacleInFront, M_bShouldHonk) == 0x000001, "Member 'FBFGVehicleObstacleInFront::M_bShouldHonk' has a wrong offset!");
static_assert(offsetof(FBFGVehicleObstacleInFront, M_bShouldBrake) == 0x000002, "Member 'FBFGVehicleObstacleInFront::M_bShouldBrake' has a wrong offset!");
static_assert(offsetof(FBFGVehicleObstacleInFront, M_fObstacleInFrontStateTime) == 0x000004, "Member 'FBFGVehicleObstacleInFront::M_fObstacleInFrontStateTime' has a wrong offset!");
static_assert(offsetof(FBFGVehicleObstacleInFront, M_fObstacleInFrontStartHonkingDelay) == 0x000008, "Member 'FBFGVehicleObstacleInFront::M_fObstacleInFrontStartHonkingDelay' has a wrong offset!");
static_assert(offsetof(FBFGVehicleObstacleInFront, M_fObstacleInFrontTimeBeforeNextHonk) == 0x00000C, "Member 'FBFGVehicleObstacleInFront::M_fObstacleInFrontTimeBeforeNextHonk' has a wrong offset!");

// ScriptStruct BFGCore.BFGSpawningCompositionItem
// 0x0088 (0x0088 - 0x0000)
struct FBFGSpawningCompositionItem
{
public:
	class FText                                   M_entryDescription;                                // 0x0000(0x0018)(Edit, BlueprintVisible, BlueprintReadOnly, NativeAccessSpecifierPublic)
	float                                         M_fProbability;                                    // 0x0018(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1C[0x4];                                       // 0x001C(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	struct FGameplayTagContainer                  M_gameplayTags;                                    // 0x0020(0x0020)(Edit, BlueprintVisible, BlueprintReadOnly, DisableEditOnInstance, NativeAccessSpecifierPublic)
	struct FGameplayTagQuery                      M_unlockQuery;                                     // 0x0040(0x0048)(Edit, BlueprintVisible, BlueprintReadOnly, DisableEditOnInstance, NativeAccessSpecifierPublic)
};
static_assert(alignof(FBFGSpawningCompositionItem) == 0x000008, "Wrong alignment on FBFGSpawningCompositionItem");
static_assert(sizeof(FBFGSpawningCompositionItem) == 0x000088, "Wrong size on FBFGSpawningCompositionItem");
static_assert(offsetof(FBFGSpawningCompositionItem, M_entryDescription) == 0x000000, "Member 'FBFGSpawningCompositionItem::M_entryDescription' has a wrong offset!");
static_assert(offsetof(FBFGSpawningCompositionItem, M_fProbability) == 0x000018, "Member 'FBFGSpawningCompositionItem::M_fProbability' has a wrong offset!");
static_assert(offsetof(FBFGSpawningCompositionItem, M_gameplayTags) == 0x000020, "Member 'FBFGSpawningCompositionItem::M_gameplayTags' has a wrong offset!");
static_assert(offsetof(FBFGSpawningCompositionItem, M_unlockQuery) == 0x000040, "Member 'FBFGSpawningCompositionItem::M_unlockQuery' has a wrong offset!");

// ScriptStruct BFGCore.BFGAngleDamper
// 0x0018 (0x0018 - 0x0000)
struct alignas(0x08) FBFGAngleDamper final
{
public:
	uint8                                         Pad_0[0x8];                                        // 0x0000(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         M_fSmoothTime;                                     // 0x0008(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         M_fMaxSpeed;                                       // 0x000C(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_10[0x8];                                       // 0x0010(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FBFGAngleDamper) == 0x000008, "Wrong alignment on FBFGAngleDamper");
static_assert(sizeof(FBFGAngleDamper) == 0x000018, "Wrong size on FBFGAngleDamper");
static_assert(offsetof(FBFGAngleDamper, M_fSmoothTime) == 0x000008, "Member 'FBFGAngleDamper::M_fSmoothTime' has a wrong offset!");
static_assert(offsetof(FBFGAngleDamper, M_fMaxSpeed) == 0x00000C, "Member 'FBFGAngleDamper::M_fMaxSpeed' has a wrong offset!");

// ScriptStruct BFGCore.BFGEffectBlackboardParameterSlots_Name
// 0x0058 (0x0058 - 0x0000)
struct FBFGEffectBlackboardParameterSlots_Name final
{
public:
	class FName                                   M_oNoSlotValue;                                    // 0x0000(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TMap<int32, class FName>                      M_aSlotValues;                                     // 0x0008(0x0050)(ZeroConstructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(FBFGEffectBlackboardParameterSlots_Name) == 0x000008, "Wrong alignment on FBFGEffectBlackboardParameterSlots_Name");
static_assert(sizeof(FBFGEffectBlackboardParameterSlots_Name) == 0x000058, "Wrong size on FBFGEffectBlackboardParameterSlots_Name");
static_assert(offsetof(FBFGEffectBlackboardParameterSlots_Name, M_oNoSlotValue) == 0x000000, "Member 'FBFGEffectBlackboardParameterSlots_Name::M_oNoSlotValue' has a wrong offset!");
static_assert(offsetof(FBFGEffectBlackboardParameterSlots_Name, M_aSlotValues) == 0x000008, "Member 'FBFGEffectBlackboardParameterSlots_Name::M_aSlotValues' has a wrong offset!");

// ScriptStruct BFGCore.BFGAnimationVariables_Weapon
// 0x0060 (0x0060 - 0x0000)
struct FBFGAnimationVariables_Weapon final
{
public:
	bool                                          M_bWeaponEquipped;                                 // 0x0000(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EBFGAnimation_WeaponPosture                   M_eWeaponPosture;                                  // 0x0001(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          M_bWeaponShooting;                                 // 0x0002(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          M_bWeaponAiming;                                   // 0x0003(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          M_bWeaponReloading;                                // 0x0004(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          M_bWeaponTelegraphing;                             // 0x0005(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_6[0x2];                                        // 0x0006(0x0002)(Fixing Size After Last Property [ Dumper-7 ])
	struct FVector                                M_vAimedAtPosition;                                // 0x0008(0x000C)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                M_vBestShotDirection;                              // 0x0014(0x000C)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                M_vVectorToTarget;                                 // 0x0020(0x000C)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                M_vVectorToAimingAtLocation;                       // 0x002C(0x000C)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TSoftClassPtr<class UClass>                   M_pWeaponClass;                                    // 0x0038(0x0028)(Edit, BlueprintVisible, BlueprintReadOnly, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FBFGAnimationVariables_Weapon) == 0x000008, "Wrong alignment on FBFGAnimationVariables_Weapon");
static_assert(sizeof(FBFGAnimationVariables_Weapon) == 0x000060, "Wrong size on FBFGAnimationVariables_Weapon");
static_assert(offsetof(FBFGAnimationVariables_Weapon, M_bWeaponEquipped) == 0x000000, "Member 'FBFGAnimationVariables_Weapon::M_bWeaponEquipped' has a wrong offset!");
static_assert(offsetof(FBFGAnimationVariables_Weapon, M_eWeaponPosture) == 0x000001, "Member 'FBFGAnimationVariables_Weapon::M_eWeaponPosture' has a wrong offset!");
static_assert(offsetof(FBFGAnimationVariables_Weapon, M_bWeaponShooting) == 0x000002, "Member 'FBFGAnimationVariables_Weapon::M_bWeaponShooting' has a wrong offset!");
static_assert(offsetof(FBFGAnimationVariables_Weapon, M_bWeaponAiming) == 0x000003, "Member 'FBFGAnimationVariables_Weapon::M_bWeaponAiming' has a wrong offset!");
static_assert(offsetof(FBFGAnimationVariables_Weapon, M_bWeaponReloading) == 0x000004, "Member 'FBFGAnimationVariables_Weapon::M_bWeaponReloading' has a wrong offset!");
static_assert(offsetof(FBFGAnimationVariables_Weapon, M_bWeaponTelegraphing) == 0x000005, "Member 'FBFGAnimationVariables_Weapon::M_bWeaponTelegraphing' has a wrong offset!");
static_assert(offsetof(FBFGAnimationVariables_Weapon, M_vAimedAtPosition) == 0x000008, "Member 'FBFGAnimationVariables_Weapon::M_vAimedAtPosition' has a wrong offset!");
static_assert(offsetof(FBFGAnimationVariables_Weapon, M_vBestShotDirection) == 0x000014, "Member 'FBFGAnimationVariables_Weapon::M_vBestShotDirection' has a wrong offset!");
static_assert(offsetof(FBFGAnimationVariables_Weapon, M_vVectorToTarget) == 0x000020, "Member 'FBFGAnimationVariables_Weapon::M_vVectorToTarget' has a wrong offset!");
static_assert(offsetof(FBFGAnimationVariables_Weapon, M_vVectorToAimingAtLocation) == 0x00002C, "Member 'FBFGAnimationVariables_Weapon::M_vVectorToAimingAtLocation' has a wrong offset!");
static_assert(offsetof(FBFGAnimationVariables_Weapon, M_pWeaponClass) == 0x000038, "Member 'FBFGAnimationVariables_Weapon::M_pWeaponClass' has a wrong offset!");

// ScriptStruct BFGCore.BFGAIStateVehicleGotoLocationParameter
// 0x0018 (0x0018 - 0x0000)
struct FBFGAIStateVehicleGotoLocationParameter final
{
public:
	struct FVector                                M_vLocation;                                       // 0x0000(0x000C)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         M_fTolerance;                                      // 0x000C(0x0004)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          M_bStopAtEnd;                                      // 0x0010(0x0001)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          M_bGotoStandbyInsteadOfFinish;                     // 0x0011(0x0001)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          M_bReleasePassengers;                              // 0x0012(0x0001)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          M_bIgnoreAvailabilityFlag;                         // 0x0013(0x0001)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         M_fSpeedOverride;                                  // 0x0014(0x0004)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FBFGAIStateVehicleGotoLocationParameter) == 0x000004, "Wrong alignment on FBFGAIStateVehicleGotoLocationParameter");
static_assert(sizeof(FBFGAIStateVehicleGotoLocationParameter) == 0x000018, "Wrong size on FBFGAIStateVehicleGotoLocationParameter");
static_assert(offsetof(FBFGAIStateVehicleGotoLocationParameter, M_vLocation) == 0x000000, "Member 'FBFGAIStateVehicleGotoLocationParameter::M_vLocation' has a wrong offset!");
static_assert(offsetof(FBFGAIStateVehicleGotoLocationParameter, M_fTolerance) == 0x00000C, "Member 'FBFGAIStateVehicleGotoLocationParameter::M_fTolerance' has a wrong offset!");
static_assert(offsetof(FBFGAIStateVehicleGotoLocationParameter, M_bStopAtEnd) == 0x000010, "Member 'FBFGAIStateVehicleGotoLocationParameter::M_bStopAtEnd' has a wrong offset!");
static_assert(offsetof(FBFGAIStateVehicleGotoLocationParameter, M_bGotoStandbyInsteadOfFinish) == 0x000011, "Member 'FBFGAIStateVehicleGotoLocationParameter::M_bGotoStandbyInsteadOfFinish' has a wrong offset!");
static_assert(offsetof(FBFGAIStateVehicleGotoLocationParameter, M_bReleasePassengers) == 0x000012, "Member 'FBFGAIStateVehicleGotoLocationParameter::M_bReleasePassengers' has a wrong offset!");
static_assert(offsetof(FBFGAIStateVehicleGotoLocationParameter, M_bIgnoreAvailabilityFlag) == 0x000013, "Member 'FBFGAIStateVehicleGotoLocationParameter::M_bIgnoreAvailabilityFlag' has a wrong offset!");
static_assert(offsetof(FBFGAIStateVehicleGotoLocationParameter, M_fSpeedOverride) == 0x000014, "Member 'FBFGAIStateVehicleGotoLocationParameter::M_fSpeedOverride' has a wrong offset!");

// ScriptStruct BFGCore.BFGUpdateAnimationDistanceResultsParams
// 0x0010 (0x0010 - 0x0000)
struct FBFGUpdateAnimationDistanceResultsParams final
{
public:
	uint8                                         Pad_0[0x8];                                        // 0x0000(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	class UAnimSequence*                          M_pAnimationFilter;                                // 0x0008(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FBFGUpdateAnimationDistanceResultsParams) == 0x000008, "Wrong alignment on FBFGUpdateAnimationDistanceResultsParams");
static_assert(sizeof(FBFGUpdateAnimationDistanceResultsParams) == 0x000010, "Wrong size on FBFGUpdateAnimationDistanceResultsParams");
static_assert(offsetof(FBFGUpdateAnimationDistanceResultsParams, M_pAnimationFilter) == 0x000008, "Member 'FBFGUpdateAnimationDistanceResultsParams::M_pAnimationFilter' has a wrong offset!");

// ScriptStruct BFGCore.BFGAnimationDistanceCurveReader
// 0x0038 (0x0038 - 0x0000)
struct FBFGAnimationDistanceCurveReader final
{
public:
	struct FSmartName                             M_oCurveSmartName;                                 // 0x0000(0x000C)(Transient, NoDestructor, NativeAccessSpecifierPublic)
	uint8                                         Pad_C[0x4];                                        // 0x000C(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class UAnimSequence*                          M_pAnimation;                                      // 0x0010(0x0008)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_18[0x20];                                      // 0x0018(0x0020)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FBFGAnimationDistanceCurveReader) == 0x000008, "Wrong alignment on FBFGAnimationDistanceCurveReader");
static_assert(sizeof(FBFGAnimationDistanceCurveReader) == 0x000038, "Wrong size on FBFGAnimationDistanceCurveReader");
static_assert(offsetof(FBFGAnimationDistanceCurveReader, M_oCurveSmartName) == 0x000000, "Member 'FBFGAnimationDistanceCurveReader::M_oCurveSmartName' has a wrong offset!");
static_assert(offsetof(FBFGAnimationDistanceCurveReader, M_pAnimation) == 0x000010, "Member 'FBFGAnimationDistanceCurveReader::M_pAnimation' has a wrong offset!");

// ScriptStruct BFGCore.BFGAlertLevelIconPack
// 0x0220 (0x0220 - 0x0000)
struct FBFGAlertLevelIconPack final
{
public:
	struct FSlateBrush                            M_oIconOff;                                        // 0x0000(0x0088)(Edit, BlueprintVisible, BlueprintReadOnly, NativeAccessSpecifierPublic)
	struct FSlateBrush                            M_oIconInvestigative;                              // 0x0088(0x0088)(Edit, BlueprintVisible, BlueprintReadOnly, NativeAccessSpecifierPublic)
	struct FSlateBrush                            M_oIconAlert;                                      // 0x0110(0x0088)(Edit, BlueprintVisible, BlueprintReadOnly, NativeAccessSpecifierPublic)
	struct FSlateBrush                            M_oIconAlertHighlighted;                           // 0x0198(0x0088)(Edit, BlueprintVisible, BlueprintReadOnly, NativeAccessSpecifierPublic)
};
static_assert(alignof(FBFGAlertLevelIconPack) == 0x000008, "Wrong alignment on FBFGAlertLevelIconPack");
static_assert(sizeof(FBFGAlertLevelIconPack) == 0x000220, "Wrong size on FBFGAlertLevelIconPack");
static_assert(offsetof(FBFGAlertLevelIconPack, M_oIconOff) == 0x000000, "Member 'FBFGAlertLevelIconPack::M_oIconOff' has a wrong offset!");
static_assert(offsetof(FBFGAlertLevelIconPack, M_oIconInvestigative) == 0x000088, "Member 'FBFGAlertLevelIconPack::M_oIconInvestigative' has a wrong offset!");
static_assert(offsetof(FBFGAlertLevelIconPack, M_oIconAlert) == 0x000110, "Member 'FBFGAlertLevelIconPack::M_oIconAlert' has a wrong offset!");
static_assert(offsetof(FBFGAlertLevelIconPack, M_oIconAlertHighlighted) == 0x000198, "Member 'FBFGAlertLevelIconPack::M_oIconAlertHighlighted' has a wrong offset!");

// ScriptStruct BFGCore.Step
// 0x0020 (0x0020 - 0x0000)
struct FStep final
{
public:
	float                                         M_fDuration;                                       // 0x0000(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_4[0x4];                                        // 0x0004(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class UBehaviorTree*                          M_pSubtree;                                        // 0x0008(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TArray<class UDataTable*>                     M_aMetaPatterns;                                   // 0x0010(0x0010)(Edit, ZeroConstructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(FStep) == 0x000008, "Wrong alignment on FStep");
static_assert(sizeof(FStep) == 0x000020, "Wrong size on FStep");
static_assert(offsetof(FStep, M_fDuration) == 0x000000, "Member 'FStep::M_fDuration' has a wrong offset!");
static_assert(offsetof(FStep, M_pSubtree) == 0x000008, "Member 'FStep::M_pSubtree' has a wrong offset!");
static_assert(offsetof(FStep, M_aMetaPatterns) == 0x000010, "Member 'FStep::M_aMetaPatterns' has a wrong offset!");

// ScriptStruct BFGCore.BFG_WeightedVariation
// 0x0008 (0x0008 - 0x0000)
struct FBFG_WeightedVariation final
{
public:
	float                                         M_fSpeedModifier;                                  // 0x0000(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         M_fWeight;                                         // 0x0004(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FBFG_WeightedVariation) == 0x000004, "Wrong alignment on FBFG_WeightedVariation");
static_assert(sizeof(FBFG_WeightedVariation) == 0x000008, "Wrong size on FBFG_WeightedVariation");
static_assert(offsetof(FBFG_WeightedVariation, M_fSpeedModifier) == 0x000000, "Member 'FBFG_WeightedVariation::M_fSpeedModifier' has a wrong offset!");
static_assert(offsetof(FBFG_WeightedVariation, M_fWeight) == 0x000004, "Member 'FBFG_WeightedVariation::M_fWeight' has a wrong offset!");

// ScriptStruct BFGCore.BFG_AnimationMoveSpeedVariation
// 0x0018 (0x0018 - 0x0000)
struct FBFG_AnimationMoveSpeedVariation final
{
public:
	EBFGNPCCharacter_MoveSpeed                    M_MotionType;                                      // 0x0000(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1[0x7];                                        // 0x0001(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<struct FBFG_WeightedVariation>         M_aWeightedVariations;                             // 0x0008(0x0010)(Edit, BlueprintVisible, ZeroConstructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(FBFG_AnimationMoveSpeedVariation) == 0x000008, "Wrong alignment on FBFG_AnimationMoveSpeedVariation");
static_assert(sizeof(FBFG_AnimationMoveSpeedVariation) == 0x000018, "Wrong size on FBFG_AnimationMoveSpeedVariation");
static_assert(offsetof(FBFG_AnimationMoveSpeedVariation, M_MotionType) == 0x000000, "Member 'FBFG_AnimationMoveSpeedVariation::M_MotionType' has a wrong offset!");
static_assert(offsetof(FBFG_AnimationMoveSpeedVariation, M_aWeightedVariations) == 0x000008, "Member 'FBFG_AnimationMoveSpeedVariation::M_aWeightedVariations' has a wrong offset!");

// ScriptStruct BFGCore.BFGInFrontObstacleInfo
// 0x0028 (0x0028 - 0x0000)
struct FBFGInFrontObstacleInfo final
{
public:
	class UBFGNetworkPathAgent*                   M_pAgentInFront;                                   // 0x0000(0x0008)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         M_fObstacleRelativeDistance;                       // 0x0008(0x0004)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         M_fObstacleSpeed;                                  // 0x000C(0x0004)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         M_fRecommendedMaxSpeed;                            // 0x0010(0x0004)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          M_bPendingAvoidance;                               // 0x0014(0x0001)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          M_bHasObstacle;                                    // 0x0015(0x0001)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_16[0x2];                                       // 0x0016(0x0002)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         M_fMinPossibleOffset;                              // 0x0018(0x0004)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         M_fMaxPossibleOffset;                              // 0x001C(0x0004)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         M_fMaxPossibleOffsetForOvertaking;                 // 0x0020(0x0004)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          M_bIsLastKnownNonVehicleObstacle;                  // 0x0024(0x0001)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_25[0x3];                                       // 0x0025(0x0003)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FBFGInFrontObstacleInfo) == 0x000008, "Wrong alignment on FBFGInFrontObstacleInfo");
static_assert(sizeof(FBFGInFrontObstacleInfo) == 0x000028, "Wrong size on FBFGInFrontObstacleInfo");
static_assert(offsetof(FBFGInFrontObstacleInfo, M_pAgentInFront) == 0x000000, "Member 'FBFGInFrontObstacleInfo::M_pAgentInFront' has a wrong offset!");
static_assert(offsetof(FBFGInFrontObstacleInfo, M_fObstacleRelativeDistance) == 0x000008, "Member 'FBFGInFrontObstacleInfo::M_fObstacleRelativeDistance' has a wrong offset!");
static_assert(offsetof(FBFGInFrontObstacleInfo, M_fObstacleSpeed) == 0x00000C, "Member 'FBFGInFrontObstacleInfo::M_fObstacleSpeed' has a wrong offset!");
static_assert(offsetof(FBFGInFrontObstacleInfo, M_fRecommendedMaxSpeed) == 0x000010, "Member 'FBFGInFrontObstacleInfo::M_fRecommendedMaxSpeed' has a wrong offset!");
static_assert(offsetof(FBFGInFrontObstacleInfo, M_bPendingAvoidance) == 0x000014, "Member 'FBFGInFrontObstacleInfo::M_bPendingAvoidance' has a wrong offset!");
static_assert(offsetof(FBFGInFrontObstacleInfo, M_bHasObstacle) == 0x000015, "Member 'FBFGInFrontObstacleInfo::M_bHasObstacle' has a wrong offset!");
static_assert(offsetof(FBFGInFrontObstacleInfo, M_fMinPossibleOffset) == 0x000018, "Member 'FBFGInFrontObstacleInfo::M_fMinPossibleOffset' has a wrong offset!");
static_assert(offsetof(FBFGInFrontObstacleInfo, M_fMaxPossibleOffset) == 0x00001C, "Member 'FBFGInFrontObstacleInfo::M_fMaxPossibleOffset' has a wrong offset!");
static_assert(offsetof(FBFGInFrontObstacleInfo, M_fMaxPossibleOffsetForOvertaking) == 0x000020, "Member 'FBFGInFrontObstacleInfo::M_fMaxPossibleOffsetForOvertaking' has a wrong offset!");
static_assert(offsetof(FBFGInFrontObstacleInfo, M_bIsLastKnownNonVehicleObstacle) == 0x000024, "Member 'FBFGInFrontObstacleInfo::M_bIsLastKnownNonVehicleObstacle' has a wrong offset!");

// ScriptStruct BFGCore.BFGVehicleObstacleCorridorObstacleParam
// 0x0018 (0x0018 - 0x0000)
struct alignas(0x04) FBFGVehicleObstacleCorridorObstacleParam final
{
public:
	uint8                                         Pad_0[0x18];                                       // 0x0000(0x0018)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FBFGVehicleObstacleCorridorObstacleParam) == 0x000004, "Wrong alignment on FBFGVehicleObstacleCorridorObstacleParam");
static_assert(sizeof(FBFGVehicleObstacleCorridorObstacleParam) == 0x000018, "Wrong size on FBFGVehicleObstacleCorridorObstacleParam");

// ScriptStruct BFGCore.AOEData
// 0x0018 (0x0018 - 0x0000)
struct FAOEData final
{
public:
	float                                         M_fDamage;                                         // 0x0000(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         M_fPhysicsImpulseStrength;                         // 0x0004(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         M_fplayerImpulseStrengthMultiplier;                // 0x0008(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          M_bCanDamageInitiator;                             // 0x000C(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_D[0x3];                                        // 0x000D(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	TSubclassOf<class UDamageType>                M_pDamageType;                                     // 0x0010(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FAOEData) == 0x000008, "Wrong alignment on FAOEData");
static_assert(sizeof(FAOEData) == 0x000018, "Wrong size on FAOEData");
static_assert(offsetof(FAOEData, M_fDamage) == 0x000000, "Member 'FAOEData::M_fDamage' has a wrong offset!");
static_assert(offsetof(FAOEData, M_fPhysicsImpulseStrength) == 0x000004, "Member 'FAOEData::M_fPhysicsImpulseStrength' has a wrong offset!");
static_assert(offsetof(FAOEData, M_fplayerImpulseStrengthMultiplier) == 0x000008, "Member 'FAOEData::M_fplayerImpulseStrengthMultiplier' has a wrong offset!");
static_assert(offsetof(FAOEData, M_bCanDamageInitiator) == 0x00000C, "Member 'FAOEData::M_bCanDamageInitiator' has a wrong offset!");
static_assert(offsetof(FAOEData, M_pDamageType) == 0x000010, "Member 'FAOEData::M_pDamageType' has a wrong offset!");

// ScriptStruct BFGCore.BackgroundResourceEntryDelegate
// 0x0010 (0x0010 - 0x0000)
struct alignas(0x08) FBackgroundResourceEntryDelegate final
{
public:
	uint8                                         Pad_0[0x10];                                       // 0x0000(0x0010)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FBackgroundResourceEntryDelegate) == 0x000008, "Wrong alignment on FBackgroundResourceEntryDelegate");
static_assert(sizeof(FBackgroundResourceEntryDelegate) == 0x000010, "Wrong size on FBackgroundResourceEntryDelegate");

// ScriptStruct BFGCore.BFGBackgroundLoadableEntry
// 0x0050 (0x0050 - 0x0000)
struct FBFGBackgroundLoadableEntry final
{
public:
	uint8                                         Pad_0[0x18];                                       // 0x0000(0x0018)(Fixing Size After Last Property [ Dumper-7 ])
	struct FSoftObjectPath                        M_softPath;                                        // 0x0018(0x0018)(Edit, BlueprintVisible, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UObject*                                M_pLoadedObject;                                   // 0x0030(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TArray<struct FBackgroundResourceEntryDelegate> M_aQueuedDelegates;                                // 0x0038(0x0010)(ZeroConstructor, NativeAccessSpecifierPublic)
	uint8                                         Pad_48[0x8];                                       // 0x0048(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FBFGBackgroundLoadableEntry) == 0x000008, "Wrong alignment on FBFGBackgroundLoadableEntry");
static_assert(sizeof(FBFGBackgroundLoadableEntry) == 0x000050, "Wrong size on FBFGBackgroundLoadableEntry");
static_assert(offsetof(FBFGBackgroundLoadableEntry, M_softPath) == 0x000018, "Member 'FBFGBackgroundLoadableEntry::M_softPath' has a wrong offset!");
static_assert(offsetof(FBFGBackgroundLoadableEntry, M_pLoadedObject) == 0x000030, "Member 'FBFGBackgroundLoadableEntry::M_pLoadedObject' has a wrong offset!");
static_assert(offsetof(FBFGBackgroundLoadableEntry, M_aQueuedDelegates) == 0x000038, "Member 'FBFGBackgroundLoadableEntry::M_aQueuedDelegates' has a wrong offset!");

// ScriptStruct BFGCore.BFGVehicleMaterialEntry
// 0x0010 (0x0010 - 0x0000)
struct FBFGVehicleMaterialEntry final
{
public:
	class FName                                   M_MaterialName;                                    // 0x0000(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UMaterialInstance*                      M_pReplacementMaterial;                            // 0x0008(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FBFGVehicleMaterialEntry) == 0x000008, "Wrong alignment on FBFGVehicleMaterialEntry");
static_assert(sizeof(FBFGVehicleMaterialEntry) == 0x000010, "Wrong size on FBFGVehicleMaterialEntry");
static_assert(offsetof(FBFGVehicleMaterialEntry, M_MaterialName) == 0x000000, "Member 'FBFGVehicleMaterialEntry::M_MaterialName' has a wrong offset!");
static_assert(offsetof(FBFGVehicleMaterialEntry, M_pReplacementMaterial) == 0x000008, "Member 'FBFGVehicleMaterialEntry::M_pReplacementMaterial' has a wrong offset!");

// ScriptStruct BFGCore.BFGBox2
// 0x0010 (0x0010 - 0x0000)
struct alignas(0x04) FBFGBox2 final
{
public:
	uint8                                         Pad_0[0x10];                                       // 0x0000(0x0010)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FBFGBox2) == 0x000004, "Wrong alignment on FBFGBox2");
static_assert(sizeof(FBFGBox2) == 0x000010, "Wrong size on FBFGBox2");

// ScriptStruct BFGCore.BFGActorHandle
// 0x0020 (0x0020 - 0x0000)
struct alignas(0x08) FBFGActorHandle final
{
public:
	uint8                                         Pad_0[0x20];                                       // 0x0000(0x0020)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FBFGActorHandle) == 0x000008, "Wrong alignment on FBFGActorHandle");
static_assert(sizeof(FBFGActorHandle) == 0x000020, "Wrong size on FBFGActorHandle");

// ScriptStruct BFGCore.BFGBroadphaseEntry
// 0x0048 (0x0048 - 0x0000)
struct FBFGBroadphaseEntry final
{
public:
	class AActor*                                 M_pActor;                                          // 0x0000(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_8[0x40];                                       // 0x0008(0x0040)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FBFGBroadphaseEntry) == 0x000008, "Wrong alignment on FBFGBroadphaseEntry");
static_assert(sizeof(FBFGBroadphaseEntry) == 0x000048, "Wrong size on FBFGBroadphaseEntry");
static_assert(offsetof(FBFGBroadphaseEntry, M_pActor) == 0x000000, "Member 'FBFGBroadphaseEntry::M_pActor' has a wrong offset!");

// ScriptStruct BFGCore.BFGAlertSystemReportParams
// 0x0028 (0x0028 - 0x0000)
struct alignas(0x08) FBFGAlertSystemReportParams final
{
public:
	uint8                                         Pad_0[0x28];                                       // 0x0000(0x0028)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FBFGAlertSystemReportParams) == 0x000008, "Wrong alignment on FBFGAlertSystemReportParams");
static_assert(sizeof(FBFGAlertSystemReportParams) == 0x000028, "Wrong size on FBFGAlertSystemReportParams");

// ScriptStruct BFGCore.BFGEffectBlackboardParameterSlots_Vector
// 0x0060 (0x0060 - 0x0000)
struct FBFGEffectBlackboardParameterSlots_Vector final
{
public:
	struct FVector                                M_vNoSlotValue;                                    // 0x0000(0x000C)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_C[0x4];                                        // 0x000C(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	TMap<int32, struct FVector>                   M_aSlotValues;                                     // 0x0010(0x0050)(ZeroConstructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(FBFGEffectBlackboardParameterSlots_Vector) == 0x000008, "Wrong alignment on FBFGEffectBlackboardParameterSlots_Vector");
static_assert(sizeof(FBFGEffectBlackboardParameterSlots_Vector) == 0x000060, "Wrong size on FBFGEffectBlackboardParameterSlots_Vector");
static_assert(offsetof(FBFGEffectBlackboardParameterSlots_Vector, M_vNoSlotValue) == 0x000000, "Member 'FBFGEffectBlackboardParameterSlots_Vector::M_vNoSlotValue' has a wrong offset!");
static_assert(offsetof(FBFGEffectBlackboardParameterSlots_Vector, M_aSlotValues) == 0x000010, "Member 'FBFGEffectBlackboardParameterSlots_Vector::M_aSlotValues' has a wrong offset!");

// ScriptStruct BFGCore.BFGEQSWithFallbackRequest
// 0x002C (0x002C - 0x0000)
struct alignas(0x04) FBFGEQSWithFallbackRequest final
{
public:
	uint8                                         Pad_0[0x2C];                                       // 0x0000(0x002C)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FBFGEQSWithFallbackRequest) == 0x000004, "Wrong alignment on FBFGEQSWithFallbackRequest");
static_assert(sizeof(FBFGEQSWithFallbackRequest) == 0x00002C, "Wrong size on FBFGEQSWithFallbackRequest");

// ScriptStruct BFGCore.BFGVehiclePlugin
// 0x0010 (0x0010 - 0x0000)
struct FBFGVehiclePlugin final
{
public:
	EBFGVehiclePluginType                         M_ePlugin;                                         // 0x0000(0x0001)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1[0x7];                                        // 0x0001(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	class UPrimitiveComponent*                    M_pPrimitive;                                      // 0x0008(0x0008)(ExportObject, ZeroConstructor, Transient, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FBFGVehiclePlugin) == 0x000008, "Wrong alignment on FBFGVehiclePlugin");
static_assert(sizeof(FBFGVehiclePlugin) == 0x000010, "Wrong size on FBFGVehiclePlugin");
static_assert(offsetof(FBFGVehiclePlugin, M_ePlugin) == 0x000000, "Member 'FBFGVehiclePlugin::M_ePlugin' has a wrong offset!");
static_assert(offsetof(FBFGVehiclePlugin, M_pPrimitive) == 0x000008, "Member 'FBFGVehiclePlugin::M_pPrimitive' has a wrong offset!");

// ScriptStruct BFGCore.BFGService_VehicleStateContext
// 0x0020 (0x0020 - 0x0000)
struct FBFGService_VehicleStateContext final
{
public:
	class UBehaviorTreeComponent*                 M_pBTComponent;                                    // 0x0000(0x0008)(ExportObject, ZeroConstructor, Transient, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UBlackboardComponent*                   M_pBlackboard;                                     // 0x0008(0x0008)(ExportObject, ZeroConstructor, Transient, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UBFGNetworkPathAgent_Vehicle*           M_pVehicle;                                        // 0x0010(0x0008)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EBFGBehaviourState_NPC                        M_eState;                                          // 0x0018(0x0001)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_19[0x7];                                       // 0x0019(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FBFGService_VehicleStateContext) == 0x000008, "Wrong alignment on FBFGService_VehicleStateContext");
static_assert(sizeof(FBFGService_VehicleStateContext) == 0x000020, "Wrong size on FBFGService_VehicleStateContext");
static_assert(offsetof(FBFGService_VehicleStateContext, M_pBTComponent) == 0x000000, "Member 'FBFGService_VehicleStateContext::M_pBTComponent' has a wrong offset!");
static_assert(offsetof(FBFGService_VehicleStateContext, M_pBlackboard) == 0x000008, "Member 'FBFGService_VehicleStateContext::M_pBlackboard' has a wrong offset!");
static_assert(offsetof(FBFGService_VehicleStateContext, M_pVehicle) == 0x000010, "Member 'FBFGService_VehicleStateContext::M_pVehicle' has a wrong offset!");
static_assert(offsetof(FBFGService_VehicleStateContext, M_eState) == 0x000018, "Member 'FBFGService_VehicleStateContext::M_eState' has a wrong offset!");

// ScriptStruct BFGCore.BFGBuilding_LevelDecor
// 0x0040 (0x0040 - 0x0000)
struct FBFGBuilding_LevelDecor final
{
public:
	int32                                         M_iDecorIndex;                                     // 0x0000(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_4[0xC];                                        // 0x0004(0x000C)(Fixing Size After Last Property [ Dumper-7 ])
	struct FTransform                             M_relativeTransform;                               // 0x0010(0x0030)(Edit, BlueprintVisible, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(FBFGBuilding_LevelDecor) == 0x000010, "Wrong alignment on FBFGBuilding_LevelDecor");
static_assert(sizeof(FBFGBuilding_LevelDecor) == 0x000040, "Wrong size on FBFGBuilding_LevelDecor");
static_assert(offsetof(FBFGBuilding_LevelDecor, M_iDecorIndex) == 0x000000, "Member 'FBFGBuilding_LevelDecor::M_iDecorIndex' has a wrong offset!");
static_assert(offsetof(FBFGBuilding_LevelDecor, M_relativeTransform) == 0x000010, "Member 'FBFGBuilding_LevelDecor::M_relativeTransform' has a wrong offset!");

// ScriptStruct BFGCore.BFGBuilding_Level
// 0x0050 (0x0050 - 0x0000)
struct FBFGBuilding_Level final
{
public:
	EBFGBuilding_FloorCategory                    M_category;                                        // 0x0000(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1[0x3];                                        // 0x0001(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	int32                                         M_iFloorIndex;                                     // 0x0004(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          M_bSpawnLevel;                                     // 0x0008(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_9[0x7];                                        // 0x0009(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<struct FBFGBuilding_LevelDecor>        M_aDecorLayouts;                                   // 0x0010(0x0010)(Edit, BlueprintVisible, ZeroConstructor, NativeAccessSpecifierPublic)
	struct FTransform                             M_relativeTransform;                               // 0x0020(0x0030)(Edit, BlueprintVisible, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(FBFGBuilding_Level) == 0x000010, "Wrong alignment on FBFGBuilding_Level");
static_assert(sizeof(FBFGBuilding_Level) == 0x000050, "Wrong size on FBFGBuilding_Level");
static_assert(offsetof(FBFGBuilding_Level, M_category) == 0x000000, "Member 'FBFGBuilding_Level::M_category' has a wrong offset!");
static_assert(offsetof(FBFGBuilding_Level, M_iFloorIndex) == 0x000004, "Member 'FBFGBuilding_Level::M_iFloorIndex' has a wrong offset!");
static_assert(offsetof(FBFGBuilding_Level, M_bSpawnLevel) == 0x000008, "Member 'FBFGBuilding_Level::M_bSpawnLevel' has a wrong offset!");
static_assert(offsetof(FBFGBuilding_Level, M_aDecorLayouts) == 0x000010, "Member 'FBFGBuilding_Level::M_aDecorLayouts' has a wrong offset!");
static_assert(offsetof(FBFGBuilding_Level, M_relativeTransform) == 0x000020, "Member 'FBFGBuilding_Level::M_relativeTransform' has a wrong offset!");

// ScriptStruct BFGCore.BFGTransitionSplineBuilder
// 0x0068 (0x0068 - 0x0000)
struct FBFGTransitionSplineBuilder final
{
public:
	struct FSplineCurves                          M_transitionCurve;                                 // 0x0000(0x0060)(Transient, Protected, NativeAccessSpecifierProtected)
	float                                         M_fDistanceAlongTransitionCurve;                   // 0x0060(0x0004)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_64[0x4];                                       // 0x0064(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FBFGTransitionSplineBuilder) == 0x000008, "Wrong alignment on FBFGTransitionSplineBuilder");
static_assert(sizeof(FBFGTransitionSplineBuilder) == 0x000068, "Wrong size on FBFGTransitionSplineBuilder");
static_assert(offsetof(FBFGTransitionSplineBuilder, M_transitionCurve) == 0x000000, "Member 'FBFGTransitionSplineBuilder::M_transitionCurve' has a wrong offset!");
static_assert(offsetof(FBFGTransitionSplineBuilder, M_fDistanceAlongTransitionCurve) == 0x000060, "Member 'FBFGTransitionSplineBuilder::M_fDistanceAlongTransitionCurve' has a wrong offset!");

// ScriptStruct BFGCore.BFGSystemData_Statistics
// 0x0010 (0x0010 - 0x0000)
struct FBFGSystemData_Statistics final
{
public:
	TArray<struct FBFGStatSaveData>               M_aStatData;                                       // 0x0000(0x0010)(ZeroConstructor, SaveGame, NativeAccessSpecifierPublic)
};
static_assert(alignof(FBFGSystemData_Statistics) == 0x000008, "Wrong alignment on FBFGSystemData_Statistics");
static_assert(sizeof(FBFGSystemData_Statistics) == 0x000010, "Wrong size on FBFGSystemData_Statistics");
static_assert(offsetof(FBFGSystemData_Statistics, M_aStatData) == 0x000000, "Member 'FBFGSystemData_Statistics::M_aStatData' has a wrong offset!");

// ScriptStruct BFGCore.BFGBuilding_FloorDecorData
// 0x0050 (0x0050 - 0x0000)
struct FBFGBuilding_FloorDecorData final
{
public:
	class UStaticMesh*                            M_pMesh;                                           // 0x0000(0x0008)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   M_strSocket;                                       // 0x0008(0x0008)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TSoftObjectPtr<class UBlastMesh>              M_pDestructibleMesh;                               // 0x0010(0x0028)(Edit, BlueprintVisible, DisableEditOnInstance, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UBlastMesh*                             M_pDestructibleMesh_RuntimeCached;                 // 0x0038(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UGeometryCache*                         M_pGeometryCache;                                  // 0x0040(0x0008)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         M_fDestructLinearDamping;                          // 0x0048(0x0004)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EBFGBuilding_DestructionPhase                 M_ePhase;                                          // 0x004C(0x0001)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EBFGBuilding_DestructionBehavior              M_eDestructionBehavior;                            // 0x004D(0x0001)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_4E[0x2];                                       // 0x004E(0x0002)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FBFGBuilding_FloorDecorData) == 0x000008, "Wrong alignment on FBFGBuilding_FloorDecorData");
static_assert(sizeof(FBFGBuilding_FloorDecorData) == 0x000050, "Wrong size on FBFGBuilding_FloorDecorData");
static_assert(offsetof(FBFGBuilding_FloorDecorData, M_pMesh) == 0x000000, "Member 'FBFGBuilding_FloorDecorData::M_pMesh' has a wrong offset!");
static_assert(offsetof(FBFGBuilding_FloorDecorData, M_strSocket) == 0x000008, "Member 'FBFGBuilding_FloorDecorData::M_strSocket' has a wrong offset!");
static_assert(offsetof(FBFGBuilding_FloorDecorData, M_pDestructibleMesh) == 0x000010, "Member 'FBFGBuilding_FloorDecorData::M_pDestructibleMesh' has a wrong offset!");
static_assert(offsetof(FBFGBuilding_FloorDecorData, M_pDestructibleMesh_RuntimeCached) == 0x000038, "Member 'FBFGBuilding_FloorDecorData::M_pDestructibleMesh_RuntimeCached' has a wrong offset!");
static_assert(offsetof(FBFGBuilding_FloorDecorData, M_pGeometryCache) == 0x000040, "Member 'FBFGBuilding_FloorDecorData::M_pGeometryCache' has a wrong offset!");
static_assert(offsetof(FBFGBuilding_FloorDecorData, M_fDestructLinearDamping) == 0x000048, "Member 'FBFGBuilding_FloorDecorData::M_fDestructLinearDamping' has a wrong offset!");
static_assert(offsetof(FBFGBuilding_FloorDecorData, M_ePhase) == 0x00004C, "Member 'FBFGBuilding_FloorDecorData::M_ePhase' has a wrong offset!");
static_assert(offsetof(FBFGBuilding_FloorDecorData, M_eDestructionBehavior) == 0x00004D, "Member 'FBFGBuilding_FloorDecorData::M_eDestructionBehavior' has a wrong offset!");

// ScriptStruct BFGCore.BFGBuilding_FloorData
// 0x0068 (0x0068 - 0x0000)
struct FBFGBuilding_FloorData final
{
public:
	struct FLightingChannels                      LightingChannels;                                  // 0x0000(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, NoDestructor, NativeAccessSpecifierPublic)
	uint8                                         Pad_1[0x7];                                        // 0x0001(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	class UStaticMesh*                            M_pMainMesh;                                       // 0x0008(0x0008)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TSoftObjectPtr<class UBlastMesh>              M_pDestructibleMesh;                               // 0x0010(0x0028)(Edit, BlueprintVisible, DisableEditOnInstance, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UBlastMesh*                             M_pDestructibleMesh_RuntimeCached;                 // 0x0038(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UGeometryCache*                         M_pGeometryCache;                                  // 0x0040(0x0008)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         M_fDestructLinearDamping;                          // 0x0048(0x0004)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_4C[0x4];                                       // 0x004C(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<struct FBFGBuilding_FloorDecorData>    M_apDecor;                                         // 0x0050(0x0010)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, NativeAccessSpecifierPublic)
	EBFGBuilding_DestructionPhase                 M_ePhase;                                          // 0x0060(0x0001)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EBFGBuilding_DestructionBehavior              M_eDestructionBehavior;                            // 0x0061(0x0001)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_62[0x6];                                       // 0x0062(0x0006)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FBFGBuilding_FloorData) == 0x000008, "Wrong alignment on FBFGBuilding_FloorData");
static_assert(sizeof(FBFGBuilding_FloorData) == 0x000068, "Wrong size on FBFGBuilding_FloorData");
static_assert(offsetof(FBFGBuilding_FloorData, LightingChannels) == 0x000000, "Member 'FBFGBuilding_FloorData::LightingChannels' has a wrong offset!");
static_assert(offsetof(FBFGBuilding_FloorData, M_pMainMesh) == 0x000008, "Member 'FBFGBuilding_FloorData::M_pMainMesh' has a wrong offset!");
static_assert(offsetof(FBFGBuilding_FloorData, M_pDestructibleMesh) == 0x000010, "Member 'FBFGBuilding_FloorData::M_pDestructibleMesh' has a wrong offset!");
static_assert(offsetof(FBFGBuilding_FloorData, M_pDestructibleMesh_RuntimeCached) == 0x000038, "Member 'FBFGBuilding_FloorData::M_pDestructibleMesh_RuntimeCached' has a wrong offset!");
static_assert(offsetof(FBFGBuilding_FloorData, M_pGeometryCache) == 0x000040, "Member 'FBFGBuilding_FloorData::M_pGeometryCache' has a wrong offset!");
static_assert(offsetof(FBFGBuilding_FloorData, M_fDestructLinearDamping) == 0x000048, "Member 'FBFGBuilding_FloorData::M_fDestructLinearDamping' has a wrong offset!");
static_assert(offsetof(FBFGBuilding_FloorData, M_apDecor) == 0x000050, "Member 'FBFGBuilding_FloorData::M_apDecor' has a wrong offset!");
static_assert(offsetof(FBFGBuilding_FloorData, M_ePhase) == 0x000060, "Member 'FBFGBuilding_FloorData::M_ePhase' has a wrong offset!");
static_assert(offsetof(FBFGBuilding_FloorData, M_eDestructionBehavior) == 0x000061, "Member 'FBFGBuilding_FloorData::M_eDestructionBehavior' has a wrong offset!");

// ScriptStruct BFGCore.BFGBuildingMaterialVariation
// 0x0010 (0x0010 - 0x0000)
struct FBFGBuildingMaterialVariation final
{
public:
	int32                                         M_iElementIndex;                                   // 0x0000(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_4[0x4];                                        // 0x0004(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class UMaterialInterface*                     M_pMaterial;                                       // 0x0008(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FBFGBuildingMaterialVariation) == 0x000008, "Wrong alignment on FBFGBuildingMaterialVariation");
static_assert(sizeof(FBFGBuildingMaterialVariation) == 0x000010, "Wrong size on FBFGBuildingMaterialVariation");
static_assert(offsetof(FBFGBuildingMaterialVariation, M_iElementIndex) == 0x000000, "Member 'FBFGBuildingMaterialVariation::M_iElementIndex' has a wrong offset!");
static_assert(offsetof(FBFGBuildingMaterialVariation, M_pMaterial) == 0x000008, "Member 'FBFGBuildingMaterialVariation::M_pMaterial' has a wrong offset!");

// ScriptStruct BFGCore.BFGBuildingRuinElement
// 0x0060 (0x0060 - 0x0000)
struct alignas(0x10) FBFGBuildingRuinElement final
{
public:
	uint8                                         Pad_0[0x30];                                       // 0x0000(0x0030)(Fixing Size After Last Property [ Dumper-7 ])
	class UParticleSystem*                        M_pPFX;                                            // 0x0030(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UStaticMesh*                            M_pStaticMesh;                                     // 0x0038(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FLightingChannels                      LightingChannels;                                  // 0x0040(0x0001)(NoDestructor, NativeAccessSpecifierPublic)
	uint8                                         Pad_41[0x7];                                       // 0x0041(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<struct FBFGBuildingMaterialVariation>  M_aMaterialVariation;                              // 0x0048(0x0010)(ZeroConstructor, NativeAccessSpecifierPublic)
	uint8                                         Pad_58[0x8];                                       // 0x0058(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FBFGBuildingRuinElement) == 0x000010, "Wrong alignment on FBFGBuildingRuinElement");
static_assert(sizeof(FBFGBuildingRuinElement) == 0x000060, "Wrong size on FBFGBuildingRuinElement");
static_assert(offsetof(FBFGBuildingRuinElement, M_pPFX) == 0x000030, "Member 'FBFGBuildingRuinElement::M_pPFX' has a wrong offset!");
static_assert(offsetof(FBFGBuildingRuinElement, M_pStaticMesh) == 0x000038, "Member 'FBFGBuildingRuinElement::M_pStaticMesh' has a wrong offset!");
static_assert(offsetof(FBFGBuildingRuinElement, LightingChannels) == 0x000040, "Member 'FBFGBuildingRuinElement::LightingChannels' has a wrong offset!");
static_assert(offsetof(FBFGBuildingRuinElement, M_aMaterialVariation) == 0x000048, "Member 'FBFGBuildingRuinElement::M_aMaterialVariation' has a wrong offset!");

// ScriptStruct BFGCore.BFGBuildingFluffEffects
// 0x0060 (0x0060 - 0x0000)
struct FBFGBuildingFluffEffects final
{
public:
	class FName                                   M_SocketName;                                      // 0x0000(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_8[0x8];                                        // 0x0008(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	struct FTransform                             M_SpawnTransform;                                  // 0x0010(0x0030)(Edit, BlueprintVisible, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
	class UParticleSystem*                        M_pPFX;                                            // 0x0040(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class USoundWave*                             M_pSFX;                                            // 0x0048(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         M_fSpawnRateMultiplier;                            // 0x0050(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         M_iClusterSortPriority;                            // 0x0054(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_58[0x8];                                       // 0x0058(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FBFGBuildingFluffEffects) == 0x000010, "Wrong alignment on FBFGBuildingFluffEffects");
static_assert(sizeof(FBFGBuildingFluffEffects) == 0x000060, "Wrong size on FBFGBuildingFluffEffects");
static_assert(offsetof(FBFGBuildingFluffEffects, M_SocketName) == 0x000000, "Member 'FBFGBuildingFluffEffects::M_SocketName' has a wrong offset!");
static_assert(offsetof(FBFGBuildingFluffEffects, M_SpawnTransform) == 0x000010, "Member 'FBFGBuildingFluffEffects::M_SpawnTransform' has a wrong offset!");
static_assert(offsetof(FBFGBuildingFluffEffects, M_pPFX) == 0x000040, "Member 'FBFGBuildingFluffEffects::M_pPFX' has a wrong offset!");
static_assert(offsetof(FBFGBuildingFluffEffects, M_pSFX) == 0x000048, "Member 'FBFGBuildingFluffEffects::M_pSFX' has a wrong offset!");
static_assert(offsetof(FBFGBuildingFluffEffects, M_fSpawnRateMultiplier) == 0x000050, "Member 'FBFGBuildingFluffEffects::M_fSpawnRateMultiplier' has a wrong offset!");
static_assert(offsetof(FBFGBuildingFluffEffects, M_iClusterSortPriority) == 0x000054, "Member 'FBFGBuildingFluffEffects::M_iClusterSortPriority' has a wrong offset!");

// ScriptStruct BFGCore.BFGBuildingDestructionPropagationEffects
// 0x0060 (0x0060 - 0x0000)
struct FBFGBuildingDestructionPropagationEffects final
{
public:
	class FName                                   M_SocketName;                                      // 0x0000(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_8[0x8];                                        // 0x0008(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	struct FTransform                             M_SpawnTransform;                                  // 0x0010(0x0030)(Edit, BlueprintVisible, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
	class UParticleSystem*                        M_pPFX;                                            // 0x0040(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                M_vScaleForParticleParameter;                      // 0x0048(0x000C)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         M_fSpawnRateMultiplier;                            // 0x0054(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         M_iSortPriority;                                   // 0x0058(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         M_iClusterSortPriority;                            // 0x005C(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FBFGBuildingDestructionPropagationEffects) == 0x000010, "Wrong alignment on FBFGBuildingDestructionPropagationEffects");
static_assert(sizeof(FBFGBuildingDestructionPropagationEffects) == 0x000060, "Wrong size on FBFGBuildingDestructionPropagationEffects");
static_assert(offsetof(FBFGBuildingDestructionPropagationEffects, M_SocketName) == 0x000000, "Member 'FBFGBuildingDestructionPropagationEffects::M_SocketName' has a wrong offset!");
static_assert(offsetof(FBFGBuildingDestructionPropagationEffects, M_SpawnTransform) == 0x000010, "Member 'FBFGBuildingDestructionPropagationEffects::M_SpawnTransform' has a wrong offset!");
static_assert(offsetof(FBFGBuildingDestructionPropagationEffects, M_pPFX) == 0x000040, "Member 'FBFGBuildingDestructionPropagationEffects::M_pPFX' has a wrong offset!");
static_assert(offsetof(FBFGBuildingDestructionPropagationEffects, M_vScaleForParticleParameter) == 0x000048, "Member 'FBFGBuildingDestructionPropagationEffects::M_vScaleForParticleParameter' has a wrong offset!");
static_assert(offsetof(FBFGBuildingDestructionPropagationEffects, M_fSpawnRateMultiplier) == 0x000054, "Member 'FBFGBuildingDestructionPropagationEffects::M_fSpawnRateMultiplier' has a wrong offset!");
static_assert(offsetof(FBFGBuildingDestructionPropagationEffects, M_iSortPriority) == 0x000058, "Member 'FBFGBuildingDestructionPropagationEffects::M_iSortPriority' has a wrong offset!");
static_assert(offsetof(FBFGBuildingDestructionPropagationEffects, M_iClusterSortPriority) == 0x00005C, "Member 'FBFGBuildingDestructionPropagationEffects::M_iClusterSortPriority' has a wrong offset!");

// ScriptStruct BFGCore.BFGBuildingDestructionDetailEffects
// 0x0080 (0x0080 - 0x0000)
struct FBFGBuildingDestructionDetailEffects final
{
public:
	class FName                                   M_SocketName;                                      // 0x0000(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_8[0x8];                                        // 0x0008(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	struct FTransform                             M_SpawnTransform;                                  // 0x0010(0x0030)(Edit, BlueprintVisible, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
	class UParticleSystem*                        M_pTakingDamagePhasePFX;                           // 0x0040(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UParticleSystem*                        M_pExplosionPhasePFX;                              // 0x0048(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UParticleSystem*                        M_pImplosionPhasePFX;                              // 0x0050(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                M_vScaleForParticleParameter;                      // 0x0058(0x000C)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         M_fSpawnRateMultiplier;                            // 0x0064(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class USoundWave*                             M_pSFX;                                            // 0x0068(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         M_iSortPriority_TakingDamagePhase;                 // 0x0070(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         M_iSortPriority_ExplosionDamagePhase;              // 0x0074(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         M_iSortPriority_ImplosionDamagePhase;              // 0x0078(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         M_iClusterSortPriority;                            // 0x007C(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FBFGBuildingDestructionDetailEffects) == 0x000010, "Wrong alignment on FBFGBuildingDestructionDetailEffects");
static_assert(sizeof(FBFGBuildingDestructionDetailEffects) == 0x000080, "Wrong size on FBFGBuildingDestructionDetailEffects");
static_assert(offsetof(FBFGBuildingDestructionDetailEffects, M_SocketName) == 0x000000, "Member 'FBFGBuildingDestructionDetailEffects::M_SocketName' has a wrong offset!");
static_assert(offsetof(FBFGBuildingDestructionDetailEffects, M_SpawnTransform) == 0x000010, "Member 'FBFGBuildingDestructionDetailEffects::M_SpawnTransform' has a wrong offset!");
static_assert(offsetof(FBFGBuildingDestructionDetailEffects, M_pTakingDamagePhasePFX) == 0x000040, "Member 'FBFGBuildingDestructionDetailEffects::M_pTakingDamagePhasePFX' has a wrong offset!");
static_assert(offsetof(FBFGBuildingDestructionDetailEffects, M_pExplosionPhasePFX) == 0x000048, "Member 'FBFGBuildingDestructionDetailEffects::M_pExplosionPhasePFX' has a wrong offset!");
static_assert(offsetof(FBFGBuildingDestructionDetailEffects, M_pImplosionPhasePFX) == 0x000050, "Member 'FBFGBuildingDestructionDetailEffects::M_pImplosionPhasePFX' has a wrong offset!");
static_assert(offsetof(FBFGBuildingDestructionDetailEffects, M_vScaleForParticleParameter) == 0x000058, "Member 'FBFGBuildingDestructionDetailEffects::M_vScaleForParticleParameter' has a wrong offset!");
static_assert(offsetof(FBFGBuildingDestructionDetailEffects, M_fSpawnRateMultiplier) == 0x000064, "Member 'FBFGBuildingDestructionDetailEffects::M_fSpawnRateMultiplier' has a wrong offset!");
static_assert(offsetof(FBFGBuildingDestructionDetailEffects, M_pSFX) == 0x000068, "Member 'FBFGBuildingDestructionDetailEffects::M_pSFX' has a wrong offset!");
static_assert(offsetof(FBFGBuildingDestructionDetailEffects, M_iSortPriority_TakingDamagePhase) == 0x000070, "Member 'FBFGBuildingDestructionDetailEffects::M_iSortPriority_TakingDamagePhase' has a wrong offset!");
static_assert(offsetof(FBFGBuildingDestructionDetailEffects, M_iSortPriority_ExplosionDamagePhase) == 0x000074, "Member 'FBFGBuildingDestructionDetailEffects::M_iSortPriority_ExplosionDamagePhase' has a wrong offset!");
static_assert(offsetof(FBFGBuildingDestructionDetailEffects, M_iSortPriority_ImplosionDamagePhase) == 0x000078, "Member 'FBFGBuildingDestructionDetailEffects::M_iSortPriority_ImplosionDamagePhase' has a wrong offset!");
static_assert(offsetof(FBFGBuildingDestructionDetailEffects, M_iClusterSortPriority) == 0x00007C, "Member 'FBFGBuildingDestructionDetailEffects::M_iClusterSortPriority' has a wrong offset!");

// ScriptStruct BFGCore.BFGBuildingDestructionCloudEffects
// 0x0060 (0x0060 - 0x0000)
struct FBFGBuildingDestructionCloudEffects final
{
public:
	class FName                                   M_SocketName;                                      // 0x0000(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_8[0x8];                                        // 0x0008(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	struct FTransform                             M_SpawnTransform;                                  // 0x0010(0x0030)(Edit, BlueprintVisible, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
	class UParticleSystem*                        M_pPFX;                                            // 0x0040(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                M_vScaleForParticleParameter;                      // 0x0048(0x000C)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         M_fSpawnRateMultiplier;                            // 0x0054(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         M_iSortPriority;                                   // 0x0058(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         M_iClusterSortPriority;                            // 0x005C(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FBFGBuildingDestructionCloudEffects) == 0x000010, "Wrong alignment on FBFGBuildingDestructionCloudEffects");
static_assert(sizeof(FBFGBuildingDestructionCloudEffects) == 0x000060, "Wrong size on FBFGBuildingDestructionCloudEffects");
static_assert(offsetof(FBFGBuildingDestructionCloudEffects, M_SocketName) == 0x000000, "Member 'FBFGBuildingDestructionCloudEffects::M_SocketName' has a wrong offset!");
static_assert(offsetof(FBFGBuildingDestructionCloudEffects, M_SpawnTransform) == 0x000010, "Member 'FBFGBuildingDestructionCloudEffects::M_SpawnTransform' has a wrong offset!");
static_assert(offsetof(FBFGBuildingDestructionCloudEffects, M_pPFX) == 0x000040, "Member 'FBFGBuildingDestructionCloudEffects::M_pPFX' has a wrong offset!");
static_assert(offsetof(FBFGBuildingDestructionCloudEffects, M_vScaleForParticleParameter) == 0x000048, "Member 'FBFGBuildingDestructionCloudEffects::M_vScaleForParticleParameter' has a wrong offset!");
static_assert(offsetof(FBFGBuildingDestructionCloudEffects, M_fSpawnRateMultiplier) == 0x000054, "Member 'FBFGBuildingDestructionCloudEffects::M_fSpawnRateMultiplier' has a wrong offset!");
static_assert(offsetof(FBFGBuildingDestructionCloudEffects, M_iSortPriority) == 0x000058, "Member 'FBFGBuildingDestructionCloudEffects::M_iSortPriority' has a wrong offset!");
static_assert(offsetof(FBFGBuildingDestructionCloudEffects, M_iClusterSortPriority) == 0x00005C, "Member 'FBFGBuildingDestructionCloudEffects::M_iClusterSortPriority' has a wrong offset!");

// ScriptStruct BFGCore.BFGDataAsset_ChallengeInfo_StarDetails
// 0x0018 (0x0018 - 0x0000)
struct FBFGDataAsset_ChallengeInfo_StarDetails final
{
public:
	int32                                         M_iStarThreshold;                                  // 0x0000(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         M_iStarReward;                                     // 0x0004(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TArray<class FText>                           M_aEndVOs;                                         // 0x0008(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, NativeAccessSpecifierPublic)
};
static_assert(alignof(FBFGDataAsset_ChallengeInfo_StarDetails) == 0x000008, "Wrong alignment on FBFGDataAsset_ChallengeInfo_StarDetails");
static_assert(sizeof(FBFGDataAsset_ChallengeInfo_StarDetails) == 0x000018, "Wrong size on FBFGDataAsset_ChallengeInfo_StarDetails");
static_assert(offsetof(FBFGDataAsset_ChallengeInfo_StarDetails, M_iStarThreshold) == 0x000000, "Member 'FBFGDataAsset_ChallengeInfo_StarDetails::M_iStarThreshold' has a wrong offset!");
static_assert(offsetof(FBFGDataAsset_ChallengeInfo_StarDetails, M_iStarReward) == 0x000004, "Member 'FBFGDataAsset_ChallengeInfo_StarDetails::M_iStarReward' has a wrong offset!");
static_assert(offsetof(FBFGDataAsset_ChallengeInfo_StarDetails, M_aEndVOs) == 0x000008, "Member 'FBFGDataAsset_ChallengeInfo_StarDetails::M_aEndVOs' has a wrong offset!");

// ScriptStruct BFGCore.BFGBuildingElement
// 0x0050 (0x0050 - 0x0000)
struct FBFGBuildingElement final
{
public:
	bool                                          M_bDisabled;                                       // 0x0000(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1[0x7];                                        // 0x0001(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	class UBFGBuildingElementDataAsset*           M_pDataAsset;                                      // 0x0008(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FTransform                             M_relativeTransform;                               // 0x0010(0x0030)(Edit, BlueprintVisible, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
	TArray<struct FBFGBuildingMaterialVariation>  M_aMaterialVariation;                              // 0x0040(0x0010)(Edit, BlueprintVisible, ZeroConstructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(FBFGBuildingElement) == 0x000010, "Wrong alignment on FBFGBuildingElement");
static_assert(sizeof(FBFGBuildingElement) == 0x000050, "Wrong size on FBFGBuildingElement");
static_assert(offsetof(FBFGBuildingElement, M_bDisabled) == 0x000000, "Member 'FBFGBuildingElement::M_bDisabled' has a wrong offset!");
static_assert(offsetof(FBFGBuildingElement, M_pDataAsset) == 0x000008, "Member 'FBFGBuildingElement::M_pDataAsset' has a wrong offset!");
static_assert(offsetof(FBFGBuildingElement, M_relativeTransform) == 0x000010, "Member 'FBFGBuildingElement::M_relativeTransform' has a wrong offset!");
static_assert(offsetof(FBFGBuildingElement, M_aMaterialVariation) == 0x000040, "Member 'FBFGBuildingElement::M_aMaterialVariation' has a wrong offset!");

// ScriptStruct BFGCore.BFGNPCSubVariationEntry
// 0x0078 (0x0078 - 0x0000)
struct FBFGNPCSubVariationEntry final
{
public:
	class FName                                   M_name;                                            // 0x0000(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FBFGNPCVariationDefinitionRow          M_Data;                                            // 0x0008(0x0070)(NativeAccessSpecifierPublic)
};
static_assert(alignof(FBFGNPCSubVariationEntry) == 0x000008, "Wrong alignment on FBFGNPCSubVariationEntry");
static_assert(sizeof(FBFGNPCSubVariationEntry) == 0x000078, "Wrong size on FBFGNPCSubVariationEntry");
static_assert(offsetof(FBFGNPCSubVariationEntry, M_name) == 0x000000, "Member 'FBFGNPCSubVariationEntry::M_name' has a wrong offset!");
static_assert(offsetof(FBFGNPCSubVariationEntry, M_Data) == 0x000008, "Member 'FBFGNPCSubVariationEntry::M_Data' has a wrong offset!");

// ScriptStruct BFGCore.BFGRemovedFoliageTable
// 0x0010 (0x0010 - 0x0000)
struct alignas(0x08) FBFGRemovedFoliageTable final
{
public:
	uint8                                         Pad_0[0x10];                                       // 0x0000(0x0010)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FBFGRemovedFoliageTable) == 0x000008, "Wrong alignment on FBFGRemovedFoliageTable");
static_assert(sizeof(FBFGRemovedFoliageTable) == 0x000010, "Wrong size on FBFGRemovedFoliageTable");

// ScriptStruct BFGCore.BFGBurntFoliageTable
// 0x0018 (0x0018 - 0x0000)
struct FBFGBurntFoliageTable final
{
public:
	class UBFGFoliageBurnt*                       M_pComponent;                                      // 0x0000(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TArray<int32>                                 M_aInstancesAddedSinceLastCheckpoint;              // 0x0008(0x0010)(ZeroConstructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(FBFGBurntFoliageTable) == 0x000008, "Wrong alignment on FBFGBurntFoliageTable");
static_assert(sizeof(FBFGBurntFoliageTable) == 0x000018, "Wrong size on FBFGBurntFoliageTable");
static_assert(offsetof(FBFGBurntFoliageTable, M_pComponent) == 0x000000, "Member 'FBFGBurntFoliageTable::M_pComponent' has a wrong offset!");
static_assert(offsetof(FBFGBurntFoliageTable, M_aInstancesAddedSinceLastCheckpoint) == 0x000008, "Member 'FBFGBurntFoliageTable::M_aInstancesAddedSinceLastCheckpoint' has a wrong offset!");

// ScriptStruct BFGCore.BFGCheatTableEntry
// 0x00D8 (0x00E0 - 0x0008)
struct FBFGCheatTableEntry final : public FTableRowBase
{
public:
	class FString                                 M_strCategoryName;                                 // 0x0008(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EBFGCheatParamType                            M_type;                                            // 0x0018(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          M_bShowInUI;                                       // 0x0019(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1A[0x6];                                       // 0x001A(0x0006)(Fixing Size After Last Property [ Dumper-7 ])
	class FString                                 M_strCommandName;                                  // 0x0020(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TArray<struct FInputActionKeyMapping>         M_Keys;                                            // 0x0030(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, NativeAccessSpecifierPublic)
	class FString                                 M_strConsoleVariableName;                          // 0x0040(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FString                                 M_strDisplayName;                                  // 0x0050(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EBFGCheatParamType                            M_eParam1;                                         // 0x0060(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_61[0x7];                                       // 0x0061(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	class FString                                 M_strLabel1;                                       // 0x0068(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EBFGCheatParamType                            M_eParam2;                                         // 0x0078(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_79[0x7];                                       // 0x0079(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	class FString                                 M_strLabel2;                                       // 0x0080(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EBFGCheatParamType                            M_eParam3;                                         // 0x0090(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_91[0x7];                                       // 0x0091(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	class FString                                 M_strLabel3;                                       // 0x0098(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FString                                 M_strDescription;                                  // 0x00A8(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UClass*                                 M_pClass;                                          // 0x00B8(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FString                                 M_strObjectPath;                                   // 0x00C0(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FString                                 M_strEnumClass;                                    // 0x00D0(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FBFGCheatTableEntry) == 0x000008, "Wrong alignment on FBFGCheatTableEntry");
static_assert(sizeof(FBFGCheatTableEntry) == 0x0000E0, "Wrong size on FBFGCheatTableEntry");
static_assert(offsetof(FBFGCheatTableEntry, M_strCategoryName) == 0x000008, "Member 'FBFGCheatTableEntry::M_strCategoryName' has a wrong offset!");
static_assert(offsetof(FBFGCheatTableEntry, M_type) == 0x000018, "Member 'FBFGCheatTableEntry::M_type' has a wrong offset!");
static_assert(offsetof(FBFGCheatTableEntry, M_bShowInUI) == 0x000019, "Member 'FBFGCheatTableEntry::M_bShowInUI' has a wrong offset!");
static_assert(offsetof(FBFGCheatTableEntry, M_strCommandName) == 0x000020, "Member 'FBFGCheatTableEntry::M_strCommandName' has a wrong offset!");
static_assert(offsetof(FBFGCheatTableEntry, M_Keys) == 0x000030, "Member 'FBFGCheatTableEntry::M_Keys' has a wrong offset!");
static_assert(offsetof(FBFGCheatTableEntry, M_strConsoleVariableName) == 0x000040, "Member 'FBFGCheatTableEntry::M_strConsoleVariableName' has a wrong offset!");
static_assert(offsetof(FBFGCheatTableEntry, M_strDisplayName) == 0x000050, "Member 'FBFGCheatTableEntry::M_strDisplayName' has a wrong offset!");
static_assert(offsetof(FBFGCheatTableEntry, M_eParam1) == 0x000060, "Member 'FBFGCheatTableEntry::M_eParam1' has a wrong offset!");
static_assert(offsetof(FBFGCheatTableEntry, M_strLabel1) == 0x000068, "Member 'FBFGCheatTableEntry::M_strLabel1' has a wrong offset!");
static_assert(offsetof(FBFGCheatTableEntry, M_eParam2) == 0x000078, "Member 'FBFGCheatTableEntry::M_eParam2' has a wrong offset!");
static_assert(offsetof(FBFGCheatTableEntry, M_strLabel2) == 0x000080, "Member 'FBFGCheatTableEntry::M_strLabel2' has a wrong offset!");
static_assert(offsetof(FBFGCheatTableEntry, M_eParam3) == 0x000090, "Member 'FBFGCheatTableEntry::M_eParam3' has a wrong offset!");
static_assert(offsetof(FBFGCheatTableEntry, M_strLabel3) == 0x000098, "Member 'FBFGCheatTableEntry::M_strLabel3' has a wrong offset!");
static_assert(offsetof(FBFGCheatTableEntry, M_strDescription) == 0x0000A8, "Member 'FBFGCheatTableEntry::M_strDescription' has a wrong offset!");
static_assert(offsetof(FBFGCheatTableEntry, M_pClass) == 0x0000B8, "Member 'FBFGCheatTableEntry::M_pClass' has a wrong offset!");
static_assert(offsetof(FBFGCheatTableEntry, M_strObjectPath) == 0x0000C0, "Member 'FBFGCheatTableEntry::M_strObjectPath' has a wrong offset!");
static_assert(offsetof(FBFGCheatTableEntry, M_strEnumClass) == 0x0000D0, "Member 'FBFGCheatTableEntry::M_strEnumClass' has a wrong offset!");

// ScriptStruct BFGCore.BFGCortexScanResponseConfig
// 0x00E0 (0x00E0 - 0x0000)
struct FBFGCortexScanResponseConfig final
{
public:
	class FName                                   M_strIdentifier;                                   // 0x0000(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	struct FBFGActorBinding                       M_actorBinding;                                    // 0x0008(0x0090)(Protected, NativeAccessSpecifierProtected)
	TSoftObjectPtr<class UBFGDataAsset_CortexScan> M_softDataAsset;                                   // 0x0098(0x0028)(Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UBFGQuest_Trigger*                      M_pTriggerArea;                                    // 0x00C0(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_C8[0x18];                                      // 0x00C8(0x0018)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FBFGCortexScanResponseConfig) == 0x000008, "Wrong alignment on FBFGCortexScanResponseConfig");
static_assert(sizeof(FBFGCortexScanResponseConfig) == 0x0000E0, "Wrong size on FBFGCortexScanResponseConfig");
static_assert(offsetof(FBFGCortexScanResponseConfig, M_strIdentifier) == 0x000000, "Member 'FBFGCortexScanResponseConfig::M_strIdentifier' has a wrong offset!");
static_assert(offsetof(FBFGCortexScanResponseConfig, M_actorBinding) == 0x000008, "Member 'FBFGCortexScanResponseConfig::M_actorBinding' has a wrong offset!");
static_assert(offsetof(FBFGCortexScanResponseConfig, M_softDataAsset) == 0x000098, "Member 'FBFGCortexScanResponseConfig::M_softDataAsset' has a wrong offset!");
static_assert(offsetof(FBFGCortexScanResponseConfig, M_pTriggerArea) == 0x0000C0, "Member 'FBFGCortexScanResponseConfig::M_pTriggerArea' has a wrong offset!");

// ScriptStruct BFGCore.BFGCrowdLifeAnimationSequenceDefinition
// 0x01D8 (0x01D8 - 0x0000)
struct FBFGCrowdLifeAnimationSequenceDefinition final
{
public:
	uint8                                         Pad_0[0x4];                                        // 0x0000(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	EBFGAnimation_Interact                        M_eEntryAnimation;                                 // 0x0004(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	EBFGCrowdStation_AnimationSetType             M_eAnimationSetType;                               // 0x0005(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	EBFGAnimation_Interact                        M_eAnimationToPlay;                                // 0x0006(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_7[0x1];                                        // 0x0007(0x0001)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<EBFGAnimation_Interact>                M_aAnimationSetToPlay;                             // 0x0008(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Protected, NativeAccessSpecifierProtected)
	bool                                          M_bLoopingAnimation;                               // 0x0018(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_19[0x3];                                       // 0x0019(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	int32                                         M_iNumLoops;                                       // 0x001C(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	EBFGAnimation_Interact                        M_eLeaveAnimation;                                 // 0x0020(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	EBFGAnimation_Interact                        M_eLeaveAnimationAlert;                            // 0x0021(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          M_bEntryBlendingEnabled;                           // 0x0022(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_23[0x1];                                       // 0x0023(0x0001)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         M_fBlendingDuration;                               // 0x0024(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TArray<class UAnimationAsset*>                M_apCachedAnims;                                   // 0x0028(0x0010)(ZeroConstructor, Protected, NativeAccessSpecifierProtected)
	TSoftObjectPtr<class UAnimationAsset>         M_pEntryAnimationProp;                             // 0x0038(0x0028)(Edit, BlueprintVisible, BlueprintReadOnly, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UAnimationAsset*                        M_pEntryAnimationProp_Cached;                      // 0x0060(0x0008)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TSoftObjectPtr<class UAnimationAsset>         M_pAnimationToPlayProp;                            // 0x0068(0x0028)(Edit, BlueprintVisible, BlueprintReadOnly, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UAnimationAsset*                        M_pAnimationToPlayProp_Cached;                     // 0x0090(0x0008)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TArray<TSoftObjectPtr<class UAnimationAsset>> M_aAnimationSetToPlayProp;                         // 0x0098(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Protected, UObjectWrapper, NativeAccessSpecifierProtected)
	TArray<class UAnimationAsset*>                M_aAnimationSetToPlayProp_Cached;                  // 0x00A8(0x0010)(ZeroConstructor, Transient, Protected, NativeAccessSpecifierProtected)
	TSoftObjectPtr<class UAnimationAsset>         M_pLeaveAnimationProp;                             // 0x00B8(0x0028)(Edit, BlueprintVisible, BlueprintReadOnly, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UAnimationAsset*                        M_pLeaveAnimationProp_Cached;                      // 0x00E0(0x0008)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TSoftObjectPtr<class UAnimationAsset>         M_pLeaveAnimationAlertProp;                        // 0x00E8(0x0028)(Edit, BlueprintVisible, BlueprintReadOnly, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UAnimationAsset*                        M_pLeaveAnimationAlertProp_Cached;                 // 0x0110(0x0008)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TSubclassOf<class ABFGPropActor>              M_pPropActorType;                                  // 0x0118(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class ABFGPropActor*                          M_pPropActor;                                      // 0x0120(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          M_bPropStartVisible;                               // 0x0128(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_129[0x3];                                      // 0x0129(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	struct FVector                                M_vLocationOffset;                                 // 0x012C(0x000C)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	struct FRotator                               M_vRotationOffset;                                 // 0x0138(0x000C)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, NativeAccessSpecifierProtected)
	struct FVector                                M_vSpecificTranslationByQuery;                     // 0x0144(0x000C)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	struct FGameplayTagQuery                      M_specificTranslationQuery;                        // 0x0150(0x0048)(Edit, BlueprintVisible, BlueprintReadOnly, Protected, NativeAccessSpecifierProtected)
	bool                                          M_bFixedOrientation;                               // 0x0198(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          M_bFixedLocation;                                  // 0x0199(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_19A[0x2];                                      // 0x019A(0x0002)(Fixing Size After Last Property [ Dumper-7 ])
	struct FVector                                M_vPropActorLocationOffset;                        // 0x019C(0x000C)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	struct FRotator                               M_vPropActorRotationOffset;                        // 0x01A8(0x000C)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, NativeAccessSpecifierProtected)
	struct FVector                                M_vEntryAnimTranslation;                           // 0x01B4(0x000C)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	struct FRotator                               M_vEntryAnimRotation;                              // 0x01C0(0x000C)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, NativeAccessSpecifierProtected)
	struct FRotator                               M_vLeaveOrientation;                               // 0x01CC(0x000C)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, NativeAccessSpecifierProtected)
};
static_assert(alignof(FBFGCrowdLifeAnimationSequenceDefinition) == 0x000008, "Wrong alignment on FBFGCrowdLifeAnimationSequenceDefinition");
static_assert(sizeof(FBFGCrowdLifeAnimationSequenceDefinition) == 0x0001D8, "Wrong size on FBFGCrowdLifeAnimationSequenceDefinition");
static_assert(offsetof(FBFGCrowdLifeAnimationSequenceDefinition, M_eEntryAnimation) == 0x000004, "Member 'FBFGCrowdLifeAnimationSequenceDefinition::M_eEntryAnimation' has a wrong offset!");
static_assert(offsetof(FBFGCrowdLifeAnimationSequenceDefinition, M_eAnimationSetType) == 0x000005, "Member 'FBFGCrowdLifeAnimationSequenceDefinition::M_eAnimationSetType' has a wrong offset!");
static_assert(offsetof(FBFGCrowdLifeAnimationSequenceDefinition, M_eAnimationToPlay) == 0x000006, "Member 'FBFGCrowdLifeAnimationSequenceDefinition::M_eAnimationToPlay' has a wrong offset!");
static_assert(offsetof(FBFGCrowdLifeAnimationSequenceDefinition, M_aAnimationSetToPlay) == 0x000008, "Member 'FBFGCrowdLifeAnimationSequenceDefinition::M_aAnimationSetToPlay' has a wrong offset!");
static_assert(offsetof(FBFGCrowdLifeAnimationSequenceDefinition, M_bLoopingAnimation) == 0x000018, "Member 'FBFGCrowdLifeAnimationSequenceDefinition::M_bLoopingAnimation' has a wrong offset!");
static_assert(offsetof(FBFGCrowdLifeAnimationSequenceDefinition, M_iNumLoops) == 0x00001C, "Member 'FBFGCrowdLifeAnimationSequenceDefinition::M_iNumLoops' has a wrong offset!");
static_assert(offsetof(FBFGCrowdLifeAnimationSequenceDefinition, M_eLeaveAnimation) == 0x000020, "Member 'FBFGCrowdLifeAnimationSequenceDefinition::M_eLeaveAnimation' has a wrong offset!");
static_assert(offsetof(FBFGCrowdLifeAnimationSequenceDefinition, M_eLeaveAnimationAlert) == 0x000021, "Member 'FBFGCrowdLifeAnimationSequenceDefinition::M_eLeaveAnimationAlert' has a wrong offset!");
static_assert(offsetof(FBFGCrowdLifeAnimationSequenceDefinition, M_bEntryBlendingEnabled) == 0x000022, "Member 'FBFGCrowdLifeAnimationSequenceDefinition::M_bEntryBlendingEnabled' has a wrong offset!");
static_assert(offsetof(FBFGCrowdLifeAnimationSequenceDefinition, M_fBlendingDuration) == 0x000024, "Member 'FBFGCrowdLifeAnimationSequenceDefinition::M_fBlendingDuration' has a wrong offset!");
static_assert(offsetof(FBFGCrowdLifeAnimationSequenceDefinition, M_apCachedAnims) == 0x000028, "Member 'FBFGCrowdLifeAnimationSequenceDefinition::M_apCachedAnims' has a wrong offset!");
static_assert(offsetof(FBFGCrowdLifeAnimationSequenceDefinition, M_pEntryAnimationProp) == 0x000038, "Member 'FBFGCrowdLifeAnimationSequenceDefinition::M_pEntryAnimationProp' has a wrong offset!");
static_assert(offsetof(FBFGCrowdLifeAnimationSequenceDefinition, M_pEntryAnimationProp_Cached) == 0x000060, "Member 'FBFGCrowdLifeAnimationSequenceDefinition::M_pEntryAnimationProp_Cached' has a wrong offset!");
static_assert(offsetof(FBFGCrowdLifeAnimationSequenceDefinition, M_pAnimationToPlayProp) == 0x000068, "Member 'FBFGCrowdLifeAnimationSequenceDefinition::M_pAnimationToPlayProp' has a wrong offset!");
static_assert(offsetof(FBFGCrowdLifeAnimationSequenceDefinition, M_pAnimationToPlayProp_Cached) == 0x000090, "Member 'FBFGCrowdLifeAnimationSequenceDefinition::M_pAnimationToPlayProp_Cached' has a wrong offset!");
static_assert(offsetof(FBFGCrowdLifeAnimationSequenceDefinition, M_aAnimationSetToPlayProp) == 0x000098, "Member 'FBFGCrowdLifeAnimationSequenceDefinition::M_aAnimationSetToPlayProp' has a wrong offset!");
static_assert(offsetof(FBFGCrowdLifeAnimationSequenceDefinition, M_aAnimationSetToPlayProp_Cached) == 0x0000A8, "Member 'FBFGCrowdLifeAnimationSequenceDefinition::M_aAnimationSetToPlayProp_Cached' has a wrong offset!");
static_assert(offsetof(FBFGCrowdLifeAnimationSequenceDefinition, M_pLeaveAnimationProp) == 0x0000B8, "Member 'FBFGCrowdLifeAnimationSequenceDefinition::M_pLeaveAnimationProp' has a wrong offset!");
static_assert(offsetof(FBFGCrowdLifeAnimationSequenceDefinition, M_pLeaveAnimationProp_Cached) == 0x0000E0, "Member 'FBFGCrowdLifeAnimationSequenceDefinition::M_pLeaveAnimationProp_Cached' has a wrong offset!");
static_assert(offsetof(FBFGCrowdLifeAnimationSequenceDefinition, M_pLeaveAnimationAlertProp) == 0x0000E8, "Member 'FBFGCrowdLifeAnimationSequenceDefinition::M_pLeaveAnimationAlertProp' has a wrong offset!");
static_assert(offsetof(FBFGCrowdLifeAnimationSequenceDefinition, M_pLeaveAnimationAlertProp_Cached) == 0x000110, "Member 'FBFGCrowdLifeAnimationSequenceDefinition::M_pLeaveAnimationAlertProp_Cached' has a wrong offset!");
static_assert(offsetof(FBFGCrowdLifeAnimationSequenceDefinition, M_pPropActorType) == 0x000118, "Member 'FBFGCrowdLifeAnimationSequenceDefinition::M_pPropActorType' has a wrong offset!");
static_assert(offsetof(FBFGCrowdLifeAnimationSequenceDefinition, M_pPropActor) == 0x000120, "Member 'FBFGCrowdLifeAnimationSequenceDefinition::M_pPropActor' has a wrong offset!");
static_assert(offsetof(FBFGCrowdLifeAnimationSequenceDefinition, M_bPropStartVisible) == 0x000128, "Member 'FBFGCrowdLifeAnimationSequenceDefinition::M_bPropStartVisible' has a wrong offset!");
static_assert(offsetof(FBFGCrowdLifeAnimationSequenceDefinition, M_vLocationOffset) == 0x00012C, "Member 'FBFGCrowdLifeAnimationSequenceDefinition::M_vLocationOffset' has a wrong offset!");
static_assert(offsetof(FBFGCrowdLifeAnimationSequenceDefinition, M_vRotationOffset) == 0x000138, "Member 'FBFGCrowdLifeAnimationSequenceDefinition::M_vRotationOffset' has a wrong offset!");
static_assert(offsetof(FBFGCrowdLifeAnimationSequenceDefinition, M_vSpecificTranslationByQuery) == 0x000144, "Member 'FBFGCrowdLifeAnimationSequenceDefinition::M_vSpecificTranslationByQuery' has a wrong offset!");
static_assert(offsetof(FBFGCrowdLifeAnimationSequenceDefinition, M_specificTranslationQuery) == 0x000150, "Member 'FBFGCrowdLifeAnimationSequenceDefinition::M_specificTranslationQuery' has a wrong offset!");
static_assert(offsetof(FBFGCrowdLifeAnimationSequenceDefinition, M_bFixedOrientation) == 0x000198, "Member 'FBFGCrowdLifeAnimationSequenceDefinition::M_bFixedOrientation' has a wrong offset!");
static_assert(offsetof(FBFGCrowdLifeAnimationSequenceDefinition, M_bFixedLocation) == 0x000199, "Member 'FBFGCrowdLifeAnimationSequenceDefinition::M_bFixedLocation' has a wrong offset!");
static_assert(offsetof(FBFGCrowdLifeAnimationSequenceDefinition, M_vPropActorLocationOffset) == 0x00019C, "Member 'FBFGCrowdLifeAnimationSequenceDefinition::M_vPropActorLocationOffset' has a wrong offset!");
static_assert(offsetof(FBFGCrowdLifeAnimationSequenceDefinition, M_vPropActorRotationOffset) == 0x0001A8, "Member 'FBFGCrowdLifeAnimationSequenceDefinition::M_vPropActorRotationOffset' has a wrong offset!");
static_assert(offsetof(FBFGCrowdLifeAnimationSequenceDefinition, M_vEntryAnimTranslation) == 0x0001B4, "Member 'FBFGCrowdLifeAnimationSequenceDefinition::M_vEntryAnimTranslation' has a wrong offset!");
static_assert(offsetof(FBFGCrowdLifeAnimationSequenceDefinition, M_vEntryAnimRotation) == 0x0001C0, "Member 'FBFGCrowdLifeAnimationSequenceDefinition::M_vEntryAnimRotation' has a wrong offset!");
static_assert(offsetof(FBFGCrowdLifeAnimationSequenceDefinition, M_vLeaveOrientation) == 0x0001CC, "Member 'FBFGCrowdLifeAnimationSequenceDefinition::M_vLeaveOrientation' has a wrong offset!");

// ScriptStruct BFGCore.BFGCrowdLifeTaskNodeAnimSetup
// 0x0001 (0x0001 - 0x0000)
struct FBFGCrowdLifeTaskNodeAnimSetup final
{
public:
	uint8                                         Pad_0[0x1];                                        // 0x0000(0x0001)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FBFGCrowdLifeTaskNodeAnimSetup) == 0x000001, "Wrong alignment on FBFGCrowdLifeTaskNodeAnimSetup");
static_assert(sizeof(FBFGCrowdLifeTaskNodeAnimSetup) == 0x000001, "Wrong size on FBFGCrowdLifeTaskNodeAnimSetup");

// ScriptStruct BFGCore.BFGCrowdManagerPlatformSettings
// 0x0004 (0x0004 - 0x0000)
struct FBFGCrowdManagerPlatformSettings final
{
public:
	float                                         M_fMaxAgentFactor;                                 // 0x0000(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FBFGCrowdManagerPlatformSettings) == 0x000004, "Wrong alignment on FBFGCrowdManagerPlatformSettings");
static_assert(sizeof(FBFGCrowdManagerPlatformSettings) == 0x000004, "Wrong size on FBFGCrowdManagerPlatformSettings");
static_assert(offsetof(FBFGCrowdManagerPlatformSettings, M_fMaxAgentFactor) == 0x000000, "Member 'FBFGCrowdManagerPlatformSettings::M_fMaxAgentFactor' has a wrong offset!");

// ScriptStruct BFGCore.BFGCrowdScriptConAsset_Line
// 0x0060 (0x0060 - 0x0000)
struct FBFGCrowdScriptConAsset_Line final
{
public:
	class USoundBase*                             M_pAudioLine;                                      // 0x0000(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EBFGCrowdScriptConAsset_Participant           M_speaker;                                         // 0x0008(0x0001)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_9[0x7];                                        // 0x0009(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	TSoftObjectPtr<class UBFGCrowdLifeAnimationSequenceDefinitionAsset> M_softSpeakerAnimDef;                              // 0x0010(0x0028)(Edit, DisableEditOnInstance, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TSoftObjectPtr<class UBFGCrowdLifeAnimationSequenceDefinitionAsset> M_softListenerAnimDef;                             // 0x0038(0x0028)(Edit, DisableEditOnInstance, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FBFGCrowdScriptConAsset_Line) == 0x000008, "Wrong alignment on FBFGCrowdScriptConAsset_Line");
static_assert(sizeof(FBFGCrowdScriptConAsset_Line) == 0x000060, "Wrong size on FBFGCrowdScriptConAsset_Line");
static_assert(offsetof(FBFGCrowdScriptConAsset_Line, M_pAudioLine) == 0x000000, "Member 'FBFGCrowdScriptConAsset_Line::M_pAudioLine' has a wrong offset!");
static_assert(offsetof(FBFGCrowdScriptConAsset_Line, M_speaker) == 0x000008, "Member 'FBFGCrowdScriptConAsset_Line::M_speaker' has a wrong offset!");
static_assert(offsetof(FBFGCrowdScriptConAsset_Line, M_softSpeakerAnimDef) == 0x000010, "Member 'FBFGCrowdScriptConAsset_Line::M_softSpeakerAnimDef' has a wrong offset!");
static_assert(offsetof(FBFGCrowdScriptConAsset_Line, M_softListenerAnimDef) == 0x000038, "Member 'FBFGCrowdScriptConAsset_Line::M_softListenerAnimDef' has a wrong offset!");

// ScriptStruct BFGCore.BFGQuestSettings_ChallengeData
// 0x00D0 (0x00D0 - 0x0000)
struct FBFGQuestSettings_ChallengeData final
{
public:
	TSoftObjectPtr<class UPaperSprite>            M_spIconEmph;                                      // 0x0000(0x0028)(Edit, BlueprintVisible, BlueprintReadOnly, DisableEditOnInstance, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TSoftObjectPtr<class UPaperSprite>            M_spIcon;                                          // 0x0028(0x0028)(Edit, BlueprintVisible, BlueprintReadOnly, DisableEditOnInstance, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FText                                   M_strType;                                         // 0x0050(0x0018)(Edit, BlueprintVisible, BlueprintReadOnly, DisableEditOnInstance, NativeAccessSpecifierPublic)
	class FText                                   M_strConditionFormat;                              // 0x0068(0x0018)(Edit, BlueprintVisible, BlueprintReadOnly, DisableEditOnInstance, NativeAccessSpecifierPublic)
	TSoftObjectPtr<class UPaperSprite>            M_spObjectiveIconEmph;                             // 0x0080(0x0028)(Edit, BlueprintVisible, BlueprintReadOnly, DisableEditOnInstance, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TSoftObjectPtr<class UPaperSprite>            M_spObjectiveIcon;                                 // 0x00A8(0x0028)(Edit, BlueprintVisible, BlueprintReadOnly, DisableEditOnInstance, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FBFGQuestSettings_ChallengeData) == 0x000008, "Wrong alignment on FBFGQuestSettings_ChallengeData");
static_assert(sizeof(FBFGQuestSettings_ChallengeData) == 0x0000D0, "Wrong size on FBFGQuestSettings_ChallengeData");
static_assert(offsetof(FBFGQuestSettings_ChallengeData, M_spIconEmph) == 0x000000, "Member 'FBFGQuestSettings_ChallengeData::M_spIconEmph' has a wrong offset!");
static_assert(offsetof(FBFGQuestSettings_ChallengeData, M_spIcon) == 0x000028, "Member 'FBFGQuestSettings_ChallengeData::M_spIcon' has a wrong offset!");
static_assert(offsetof(FBFGQuestSettings_ChallengeData, M_strType) == 0x000050, "Member 'FBFGQuestSettings_ChallengeData::M_strType' has a wrong offset!");
static_assert(offsetof(FBFGQuestSettings_ChallengeData, M_strConditionFormat) == 0x000068, "Member 'FBFGQuestSettings_ChallengeData::M_strConditionFormat' has a wrong offset!");
static_assert(offsetof(FBFGQuestSettings_ChallengeData, M_spObjectiveIconEmph) == 0x000080, "Member 'FBFGQuestSettings_ChallengeData::M_spObjectiveIconEmph' has a wrong offset!");
static_assert(offsetof(FBFGQuestSettings_ChallengeData, M_spObjectiveIcon) == 0x0000A8, "Member 'FBFGQuestSettings_ChallengeData::M_spObjectiveIcon' has a wrong offset!");

// ScriptStruct BFGCore.BFGCrowdScriptConParticipant
// 0x0020 (0x0020 - 0x0000)
struct FBFGCrowdScriptConParticipant final
{
public:
	class UBFGNetworkPathAgent*                   M_pAgent;                                          // 0x0000(0x0008)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EBFGCrowdScriptConAsset_Participant           M_eParticipant;                                    // 0x0008(0x0001)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_9[0x7];                                        // 0x0009(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	class UBFGCrowdLifeStationComponent*          M_pStation;                                        // 0x0010(0x0008)(ExportObject, ZeroConstructor, Transient, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          M_bIsSpeaking;                                     // 0x0018(0x0001)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_19[0x7];                                       // 0x0019(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FBFGCrowdScriptConParticipant) == 0x000008, "Wrong alignment on FBFGCrowdScriptConParticipant");
static_assert(sizeof(FBFGCrowdScriptConParticipant) == 0x000020, "Wrong size on FBFGCrowdScriptConParticipant");
static_assert(offsetof(FBFGCrowdScriptConParticipant, M_pAgent) == 0x000000, "Member 'FBFGCrowdScriptConParticipant::M_pAgent' has a wrong offset!");
static_assert(offsetof(FBFGCrowdScriptConParticipant, M_eParticipant) == 0x000008, "Member 'FBFGCrowdScriptConParticipant::M_eParticipant' has a wrong offset!");
static_assert(offsetof(FBFGCrowdScriptConParticipant, M_pStation) == 0x000010, "Member 'FBFGCrowdScriptConParticipant::M_pStation' has a wrong offset!");
static_assert(offsetof(FBFGCrowdScriptConParticipant, M_bIsSpeaking) == 0x000018, "Member 'FBFGCrowdScriptConParticipant::M_bIsSpeaking' has a wrong offset!");

// ScriptStruct BFGCore.BFGQuestChallenge_Overview
// 0x0018 (0x0018 - 0x0000)
struct FBFGQuestChallenge_Overview final
{
public:
	TSubclassOf<class UBFGQuest>                  M_pQuestClass;                                     // 0x0000(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UBFGDataAsset_ChallengeInfo*            M_pAsset;                                          // 0x0008(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_10[0x8];                                       // 0x0010(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FBFGQuestChallenge_Overview) == 0x000008, "Wrong alignment on FBFGQuestChallenge_Overview");
static_assert(sizeof(FBFGQuestChallenge_Overview) == 0x000018, "Wrong size on FBFGQuestChallenge_Overview");
static_assert(offsetof(FBFGQuestChallenge_Overview, M_pQuestClass) == 0x000000, "Member 'FBFGQuestChallenge_Overview::M_pQuestClass' has a wrong offset!");
static_assert(offsetof(FBFGQuestChallenge_Overview, M_pAsset) == 0x000008, "Member 'FBFGQuestChallenge_Overview::M_pAsset' has a wrong offset!");

// ScriptStruct BFGCore.BFGDataAsset_ChallengeInfo_Objective
// 0x0048 (0x0048 - 0x0000)
struct FBFGDataAsset_ChallengeInfo_Objective final
{
public:
	TSoftObjectPtr<class UPaperSprite>            M_spIcon;                                          // 0x0000(0x0028)(Edit, BlueprintVisible, BlueprintReadOnly, DisableEditOnInstance, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FText                                   M_strText;                                         // 0x0028(0x0018)(Edit, BlueprintVisible, BlueprintReadOnly, DisableEditOnInstance, NativeAccessSpecifierPublic)
	int32                                         M_iReward;                                         // 0x0040(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_44[0x4];                                       // 0x0044(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FBFGDataAsset_ChallengeInfo_Objective) == 0x000008, "Wrong alignment on FBFGDataAsset_ChallengeInfo_Objective");
static_assert(sizeof(FBFGDataAsset_ChallengeInfo_Objective) == 0x000048, "Wrong size on FBFGDataAsset_ChallengeInfo_Objective");
static_assert(offsetof(FBFGDataAsset_ChallengeInfo_Objective, M_spIcon) == 0x000000, "Member 'FBFGDataAsset_ChallengeInfo_Objective::M_spIcon' has a wrong offset!");
static_assert(offsetof(FBFGDataAsset_ChallengeInfo_Objective, M_strText) == 0x000028, "Member 'FBFGDataAsset_ChallengeInfo_Objective::M_strText' has a wrong offset!");
static_assert(offsetof(FBFGDataAsset_ChallengeInfo_Objective, M_iReward) == 0x000040, "Member 'FBFGDataAsset_ChallengeInfo_Objective::M_iReward' has a wrong offset!");

// ScriptStruct BFGCore.BFGDataPausedTutorialStep
// 0x00A0 (0x00A0 - 0x0000)
struct FBFGDataPausedTutorialStep final
{
public:
	class FText                                   M_strDescription;                                  // 0x0000(0x0018)(Edit, BlueprintVisible, BlueprintReadOnly, NativeAccessSpecifierPublic)
	struct FSlateBrush                            M_oImage;                                          // 0x0018(0x0088)(Edit, BlueprintVisible, BlueprintReadOnly, NativeAccessSpecifierPublic)
};
static_assert(alignof(FBFGDataPausedTutorialStep) == 0x000008, "Wrong alignment on FBFGDataPausedTutorialStep");
static_assert(sizeof(FBFGDataPausedTutorialStep) == 0x0000A0, "Wrong size on FBFGDataPausedTutorialStep");
static_assert(offsetof(FBFGDataPausedTutorialStep, M_strDescription) == 0x000000, "Member 'FBFGDataPausedTutorialStep::M_strDescription' has a wrong offset!");
static_assert(offsetof(FBFGDataPausedTutorialStep, M_oImage) == 0x000018, "Member 'FBFGDataPausedTutorialStep::M_oImage' has a wrong offset!");

// ScriptStruct BFGCore.BFGQuestRewards
// 0x0050 (0x0050 - 0x0000)
struct FBFGQuestRewards final
{
public:
	struct FGameplayTag                           M_rewardTag;                                       // 0x0000(0x0008)(Edit, DisableEditOnInstance, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EBFGQuestRewardsType                          M_rewardType;                                      // 0x0008(0x0001)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_9[0x3];                                        // 0x0009(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	int32                                         M_iRewardData;                                     // 0x000C(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FText                                   M_strDisplayTitle;                                 // 0x0010(0x0018)(Edit, DisableEditOnInstance, NativeAccessSpecifierPublic)
	TSoftObjectPtr<class UPaperSprite>            M_softIcon;                                        // 0x0028(0x0028)(Edit, DisableEditOnInstance, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FBFGQuestRewards) == 0x000008, "Wrong alignment on FBFGQuestRewards");
static_assert(sizeof(FBFGQuestRewards) == 0x000050, "Wrong size on FBFGQuestRewards");
static_assert(offsetof(FBFGQuestRewards, M_rewardTag) == 0x000000, "Member 'FBFGQuestRewards::M_rewardTag' has a wrong offset!");
static_assert(offsetof(FBFGQuestRewards, M_rewardType) == 0x000008, "Member 'FBFGQuestRewards::M_rewardType' has a wrong offset!");
static_assert(offsetof(FBFGQuestRewards, M_iRewardData) == 0x00000C, "Member 'FBFGQuestRewards::M_iRewardData' has a wrong offset!");
static_assert(offsetof(FBFGQuestRewards, M_strDisplayTitle) == 0x000010, "Member 'FBFGQuestRewards::M_strDisplayTitle' has a wrong offset!");
static_assert(offsetof(FBFGQuestRewards, M_softIcon) == 0x000028, "Member 'FBFGQuestRewards::M_softIcon' has a wrong offset!");

// ScriptStruct BFGCore.BFGIntersectionUser
// 0x0038 (0x0038 - 0x0000)
struct FBFGIntersectionUser final
{
public:
	int32                                         M_iTicket;                                         // 0x0000(0x0004)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_4[0x4];                                        // 0x0004(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class UBFGNetworkPathAgent*                   M_pAgent;                                          // 0x0008(0x0008)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UBFGNetworkPath*                        M_pSourcePath;                                     // 0x0010(0x0008)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EBFGNetworkPathExtremity                      M_eSourceExtremity;                                // 0x0018(0x0001)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_19[0x7];                                       // 0x0019(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	class UBFGNetworkPath*                        M_pTargetPath;                                     // 0x0020(0x0008)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EBFGNetworkPathExtremity                      M_eTargetExtremity;                                // 0x0028(0x0001)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_29[0x3];                                       // 0x0029(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         M_fDistanceToEnd;                                  // 0x002C(0x0004)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EBFGIntersectionGranting                      M_eGranting;                                       // 0x0030(0x0001)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          M_bGrantingForced;                                 // 0x0031(0x0001)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_32[0x6];                                       // 0x0032(0x0006)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FBFGIntersectionUser) == 0x000008, "Wrong alignment on FBFGIntersectionUser");
static_assert(sizeof(FBFGIntersectionUser) == 0x000038, "Wrong size on FBFGIntersectionUser");
static_assert(offsetof(FBFGIntersectionUser, M_iTicket) == 0x000000, "Member 'FBFGIntersectionUser::M_iTicket' has a wrong offset!");
static_assert(offsetof(FBFGIntersectionUser, M_pAgent) == 0x000008, "Member 'FBFGIntersectionUser::M_pAgent' has a wrong offset!");
static_assert(offsetof(FBFGIntersectionUser, M_pSourcePath) == 0x000010, "Member 'FBFGIntersectionUser::M_pSourcePath' has a wrong offset!");
static_assert(offsetof(FBFGIntersectionUser, M_eSourceExtremity) == 0x000018, "Member 'FBFGIntersectionUser::M_eSourceExtremity' has a wrong offset!");
static_assert(offsetof(FBFGIntersectionUser, M_pTargetPath) == 0x000020, "Member 'FBFGIntersectionUser::M_pTargetPath' has a wrong offset!");
static_assert(offsetof(FBFGIntersectionUser, M_eTargetExtremity) == 0x000028, "Member 'FBFGIntersectionUser::M_eTargetExtremity' has a wrong offset!");
static_assert(offsetof(FBFGIntersectionUser, M_fDistanceToEnd) == 0x00002C, "Member 'FBFGIntersectionUser::M_fDistanceToEnd' has a wrong offset!");
static_assert(offsetof(FBFGIntersectionUser, M_eGranting) == 0x000030, "Member 'FBFGIntersectionUser::M_eGranting' has a wrong offset!");
static_assert(offsetof(FBFGIntersectionUser, M_bGrantingForced) == 0x000031, "Member 'FBFGIntersectionUser::M_bGrantingForced' has a wrong offset!");

// ScriptStruct BFGCore.BFGDataTableRow_TutorialChapter
// 0x0008 (0x0010 - 0x0008)
struct FBFGDataTableRow_TutorialChapter final : public FTableRowBase
{
public:
	class UBFGDataAsset_TutorialPage*             M_pPage;                                           // 0x0008(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FBFGDataTableRow_TutorialChapter) == 0x000008, "Wrong alignment on FBFGDataTableRow_TutorialChapter");
static_assert(sizeof(FBFGDataTableRow_TutorialChapter) == 0x000010, "Wrong size on FBFGDataTableRow_TutorialChapter");
static_assert(offsetof(FBFGDataTableRow_TutorialChapter, M_pPage) == 0x000008, "Member 'FBFGDataTableRow_TutorialChapter::M_pPage' has a wrong offset!");

// ScriptStruct BFGCore.BFGDataTableRow_TutorialHandbook
// 0x0008 (0x0010 - 0x0008)
struct FBFGDataTableRow_TutorialHandbook final : public FTableRowBase
{
public:
	class UBFGDataAsset_TutorialChapter*          M_pChapterEntry;                                   // 0x0008(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FBFGDataTableRow_TutorialHandbook) == 0x000008, "Wrong alignment on FBFGDataTableRow_TutorialHandbook");
static_assert(sizeof(FBFGDataTableRow_TutorialHandbook) == 0x000010, "Wrong size on FBFGDataTableRow_TutorialHandbook");
static_assert(offsetof(FBFGDataTableRow_TutorialHandbook, M_pChapterEntry) == 0x000008, "Member 'FBFGDataTableRow_TutorialHandbook::M_pChapterEntry' has a wrong offset!");

// ScriptStruct BFGCore.BFGDataLoadingscreenHint
// 0x0018 (0x0020 - 0x0008)
struct FBFGDataLoadingscreenHint final : public FTableRowBase
{
public:
	class FText                                   M_strText;                                         // 0x0008(0x0018)(Edit, BlueprintVisible, BlueprintReadOnly, NativeAccessSpecifierPublic)
};
static_assert(alignof(FBFGDataLoadingscreenHint) == 0x000008, "Wrong alignment on FBFGDataLoadingscreenHint");
static_assert(sizeof(FBFGDataLoadingscreenHint) == 0x000020, "Wrong size on FBFGDataLoadingscreenHint");
static_assert(offsetof(FBFGDataLoadingscreenHint, M_strText) == 0x000008, "Member 'FBFGDataLoadingscreenHint::M_strText' has a wrong offset!");

// ScriptStruct BFGCore.BFGDataMovieSubtitleTiming
// 0x0028 (0x0030 - 0x0008)
struct FBFGDataMovieSubtitleTiming final : public FTableRowBase
{
public:
	class FText                                   M_strText;                                         // 0x0008(0x0018)(Edit, BlueprintVisible, BlueprintReadOnly, NativeAccessSpecifierPublic)
	int32                                         M_iBeginMs;                                        // 0x0020(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         M_iEndMs;                                          // 0x0024(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          M_bHideInEN;                                       // 0x0028(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_29[0x7];                                       // 0x0029(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FBFGDataMovieSubtitleTiming) == 0x000008, "Wrong alignment on FBFGDataMovieSubtitleTiming");
static_assert(sizeof(FBFGDataMovieSubtitleTiming) == 0x000030, "Wrong size on FBFGDataMovieSubtitleTiming");
static_assert(offsetof(FBFGDataMovieSubtitleTiming, M_strText) == 0x000008, "Member 'FBFGDataMovieSubtitleTiming::M_strText' has a wrong offset!");
static_assert(offsetof(FBFGDataMovieSubtitleTiming, M_iBeginMs) == 0x000020, "Member 'FBFGDataMovieSubtitleTiming::M_iBeginMs' has a wrong offset!");
static_assert(offsetof(FBFGDataMovieSubtitleTiming, M_iEndMs) == 0x000024, "Member 'FBFGDataMovieSubtitleTiming::M_iEndMs' has a wrong offset!");
static_assert(offsetof(FBFGDataMovieSubtitleTiming, M_bHideInEN) == 0x000028, "Member 'FBFGDataMovieSubtitleTiming::M_bHideInEN' has a wrong offset!");

// ScriptStruct BFGCore.BFGQuest_ElementFallOutOfWorld_Objective
// 0x0090 (0x0090 - 0x0000)
struct FBFGQuest_ElementFallOutOfWorld_Objective final
{
public:
	struct FBFGActorBinding                       M_actorBinding;                                    // 0x0000(0x0090)(Edit, BlueprintVisible, BlueprintReadOnly, DisableEditOnInstance, NativeAccessSpecifierPublic)
};
static_assert(alignof(FBFGQuest_ElementFallOutOfWorld_Objective) == 0x000008, "Wrong alignment on FBFGQuest_ElementFallOutOfWorld_Objective");
static_assert(sizeof(FBFGQuest_ElementFallOutOfWorld_Objective) == 0x000090, "Wrong size on FBFGQuest_ElementFallOutOfWorld_Objective");
static_assert(offsetof(FBFGQuest_ElementFallOutOfWorld_Objective, M_actorBinding) == 0x000000, "Member 'FBFGQuest_ElementFallOutOfWorld_Objective::M_actorBinding' has a wrong offset!");

// ScriptStruct BFGCore.BFGDataTableRowNarrativeSequence_Pox
// 0x0020 (0x0028 - 0x0008)
struct FBFGDataTableRowNarrativeSequence_Pox final : public FTableRowBase
{
public:
	class FText                                   M_strTextline;                                     // 0x0008(0x0018)(Edit, BlueprintVisible, BlueprintReadOnly, NativeAccessSpecifierPublic)
	EBFGNarrativeSequenceID_Pox                   M_eSequenceID;                                     // 0x0020(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EBFGNarrativeSequenceID_Pox                   M_eNextSequenceID;                                 // 0x0021(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_22[0x6];                                       // 0x0022(0x0006)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FBFGDataTableRowNarrativeSequence_Pox) == 0x000008, "Wrong alignment on FBFGDataTableRowNarrativeSequence_Pox");
static_assert(sizeof(FBFGDataTableRowNarrativeSequence_Pox) == 0x000028, "Wrong size on FBFGDataTableRowNarrativeSequence_Pox");
static_assert(offsetof(FBFGDataTableRowNarrativeSequence_Pox, M_strTextline) == 0x000008, "Member 'FBFGDataTableRowNarrativeSequence_Pox::M_strTextline' has a wrong offset!");
static_assert(offsetof(FBFGDataTableRowNarrativeSequence_Pox, M_eSequenceID) == 0x000020, "Member 'FBFGDataTableRowNarrativeSequence_Pox::M_eSequenceID' has a wrong offset!");
static_assert(offsetof(FBFGDataTableRowNarrativeSequence_Pox, M_eNextSequenceID) == 0x000021, "Member 'FBFGDataTableRowNarrativeSequence_Pox::M_eNextSequenceID' has a wrong offset!");

// ScriptStruct BFGCore.BFGDebugStartMenu_EntryData
// 0x0050 (0x0050 - 0x0000)
struct FBFGDebugStartMenu_EntryData final
{
public:
	TSoftObjectPtr<class UWorld>                  M_softWorld;                                       // 0x0000(0x0028)(UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UClass*                                 M_pQuestClass;                                     // 0x0028(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FGuid                                  M_guidQuestElement;                                // 0x0030(0x0010)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_40[0x8];                                       // 0x0040(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	class UBFGMissionGroup*                       M_pMissionGroup;                                   // 0x0048(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FBFGDebugStartMenu_EntryData) == 0x000008, "Wrong alignment on FBFGDebugStartMenu_EntryData");
static_assert(sizeof(FBFGDebugStartMenu_EntryData) == 0x000050, "Wrong size on FBFGDebugStartMenu_EntryData");
static_assert(offsetof(FBFGDebugStartMenu_EntryData, M_softWorld) == 0x000000, "Member 'FBFGDebugStartMenu_EntryData::M_softWorld' has a wrong offset!");
static_assert(offsetof(FBFGDebugStartMenu_EntryData, M_pQuestClass) == 0x000028, "Member 'FBFGDebugStartMenu_EntryData::M_pQuestClass' has a wrong offset!");
static_assert(offsetof(FBFGDebugStartMenu_EntryData, M_guidQuestElement) == 0x000030, "Member 'FBFGDebugStartMenu_EntryData::M_guidQuestElement' has a wrong offset!");
static_assert(offsetof(FBFGDebugStartMenu_EntryData, M_pMissionGroup) == 0x000048, "Member 'FBFGDebugStartMenu_EntryData::M_pMissionGroup' has a wrong offset!");

// ScriptStruct BFGCore.BFGBTVariant_ConditionSet
// 0x00B0 (0x00B0 - 0x0000)
struct FBFGBTVariant_ConditionSet final
{
public:
	struct FBFGBTVariant_StaticConditions         M_staticConditions;                                // 0x0000(0x0048)(Edit, NativeAccessSpecifierPublic)
	struct FBFGBTVariant_DynamicConditions        M_dynamicConditions;                               // 0x0048(0x0060)(Edit, NativeAccessSpecifierPublic)
	float                                         M_fTimeLimit;                                      // 0x00A8(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         M_fCooldownTime;                                   // 0x00AC(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FBFGBTVariant_ConditionSet) == 0x000008, "Wrong alignment on FBFGBTVariant_ConditionSet");
static_assert(sizeof(FBFGBTVariant_ConditionSet) == 0x0000B0, "Wrong size on FBFGBTVariant_ConditionSet");
static_assert(offsetof(FBFGBTVariant_ConditionSet, M_staticConditions) == 0x000000, "Member 'FBFGBTVariant_ConditionSet::M_staticConditions' has a wrong offset!");
static_assert(offsetof(FBFGBTVariant_ConditionSet, M_dynamicConditions) == 0x000048, "Member 'FBFGBTVariant_ConditionSet::M_dynamicConditions' has a wrong offset!");
static_assert(offsetof(FBFGBTVariant_ConditionSet, M_fTimeLimit) == 0x0000A8, "Member 'FBFGBTVariant_ConditionSet::M_fTimeLimit' has a wrong offset!");
static_assert(offsetof(FBFGBTVariant_ConditionSet, M_fCooldownTime) == 0x0000AC, "Member 'FBFGBTVariant_ConditionSet::M_fCooldownTime' has a wrong offset!");

// ScriptStruct BFGCore.PhaseStepRange
// 0x0010 (0x0010 - 0x0000)
struct FPhaseStepRange final
{
public:
	int32                                         M_iPhase;                                          // 0x0000(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         M_iStepMin;                                        // 0x0004(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         M_iStepMax;                                        // 0x0008(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          M_bAllowRepeats;                                   // 0x000C(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_D[0x3];                                        // 0x000D(0x0003)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FPhaseStepRange) == 0x000004, "Wrong alignment on FPhaseStepRange");
static_assert(sizeof(FPhaseStepRange) == 0x000010, "Wrong size on FPhaseStepRange");
static_assert(offsetof(FPhaseStepRange, M_iPhase) == 0x000000, "Member 'FPhaseStepRange::M_iPhase' has a wrong offset!");
static_assert(offsetof(FPhaseStepRange, M_iStepMin) == 0x000004, "Member 'FPhaseStepRange::M_iStepMin' has a wrong offset!");
static_assert(offsetof(FPhaseStepRange, M_iStepMax) == 0x000008, "Member 'FPhaseStepRange::M_iStepMax' has a wrong offset!");
static_assert(offsetof(FPhaseStepRange, M_bAllowRepeats) == 0x00000C, "Member 'FPhaseStepRange::M_bAllowRepeats' has a wrong offset!");

// ScriptStruct BFGCore.BFGDeferredActor
// 0x0050 (0x0050 - 0x0000)
struct alignas(0x10) FBFGDeferredActor final
{
public:
	class AActor*                                 M_pActor;                                          // 0x0000(0x0008)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_8[0x48];                                       // 0x0008(0x0048)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FBFGDeferredActor) == 0x000010, "Wrong alignment on FBFGDeferredActor");
static_assert(sizeof(FBFGDeferredActor) == 0x000050, "Wrong size on FBFGDeferredActor");
static_assert(offsetof(FBFGDeferredActor, M_pActor) == 0x000000, "Member 'FBFGDeferredActor::M_pActor' has a wrong offset!");

// ScriptStruct BFGCore.BFGDestructionStreamingEntry
// 0x0010 (0x0010 - 0x0000)
struct FBFGDestructionStreamingEntry final
{
public:
	class UBlastMeshRecordedComponent*            M_pComponent;                                      // 0x0000(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UBlastRecordedCache*                    M_pCache;                                          // 0x0008(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FBFGDestructionStreamingEntry) == 0x000008, "Wrong alignment on FBFGDestructionStreamingEntry");
static_assert(sizeof(FBFGDestructionStreamingEntry) == 0x000010, "Wrong size on FBFGDestructionStreamingEntry");
static_assert(offsetof(FBFGDestructionStreamingEntry, M_pComponent) == 0x000000, "Member 'FBFGDestructionStreamingEntry::M_pComponent' has a wrong offset!");
static_assert(offsetof(FBFGDestructionStreamingEntry, M_pCache) == 0x000008, "Member 'FBFGDestructionStreamingEntry::M_pCache' has a wrong offset!");

// ScriptStruct BFGCore.BFGDLCLayout
// 0x0018 (0x0018 - 0x0000)
struct FBFGDLCLayout final
{
public:
	EBFGDLCItem                                   M_eDLCType;                                        // 0x0000(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1[0x7];                                        // 0x0001(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	class FString                                 M_strDLCName;                                      // 0x0008(0x0010)(Edit, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FBFGDLCLayout) == 0x000008, "Wrong alignment on FBFGDLCLayout");
static_assert(sizeof(FBFGDLCLayout) == 0x000018, "Wrong size on FBFGDLCLayout");
static_assert(offsetof(FBFGDLCLayout, M_eDLCType) == 0x000000, "Member 'FBFGDLCLayout::M_eDLCType' has a wrong offset!");
static_assert(offsetof(FBFGDLCLayout, M_strDLCName) == 0x000008, "Member 'FBFGDLCLayout::M_strDLCName' has a wrong offset!");

// ScriptStruct BFGCore.BFGDeferredActorActivationEntry
// 0x0018 (0x0018 - 0x0000)
struct FBFGDeferredActorActivationEntry final
{
public:
	class AActor*                                 M_pHitActor;                                       // 0x0000(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_8[0x10];                                       // 0x0008(0x0010)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FBFGDeferredActorActivationEntry) == 0x000008, "Wrong alignment on FBFGDeferredActorActivationEntry");
static_assert(sizeof(FBFGDeferredActorActivationEntry) == 0x000018, "Wrong size on FBFGDeferredActorActivationEntry");
static_assert(offsetof(FBFGDeferredActorActivationEntry, M_pHitActor) == 0x000000, "Member 'FBFGDeferredActorActivationEntry::M_pHitActor' has a wrong offset!");

// ScriptStruct BFGCore.BFGVirtualVehicle
// 0x00D0 (0x00D0 - 0x0000)
struct FBFGVirtualVehicle final
{
public:
	class UBFGNetworkPathAgent_Vehicle*           M_pAgentVehicle;                                   // 0x0000(0x0008)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          M_bIsActive;                                       // 0x0008(0x0001)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_9[0x7];                                        // 0x0009(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	struct FTransform                             M_sourceTransform;                                 // 0x0010(0x0030)(Transient, IsPlainOldData, NoDestructor, Protected, NativeAccessSpecifierProtected)
	struct FTransform                             M_targetTransform;                                 // 0x0040(0x0030)(Transient, IsPlainOldData, NoDestructor, Protected, NativeAccessSpecifierProtected)
	uint8                                         Pad_70[0x60];                                      // 0x0070(0x0060)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FBFGVirtualVehicle) == 0x000010, "Wrong alignment on FBFGVirtualVehicle");
static_assert(sizeof(FBFGVirtualVehicle) == 0x0000D0, "Wrong size on FBFGVirtualVehicle");
static_assert(offsetof(FBFGVirtualVehicle, M_pAgentVehicle) == 0x000000, "Member 'FBFGVirtualVehicle::M_pAgentVehicle' has a wrong offset!");
static_assert(offsetof(FBFGVirtualVehicle, M_bIsActive) == 0x000008, "Member 'FBFGVirtualVehicle::M_bIsActive' has a wrong offset!");
static_assert(offsetof(FBFGVirtualVehicle, M_sourceTransform) == 0x000010, "Member 'FBFGVirtualVehicle::M_sourceTransform' has a wrong offset!");
static_assert(offsetof(FBFGVirtualVehicle, M_targetTransform) == 0x000040, "Member 'FBFGVirtualVehicle::M_targetTransform' has a wrong offset!");

// ScriptStruct BFGCore.BFGCollisionEvent
// 0x00A0 (0x00A0 - 0x0000)
struct FBFGCollisionEvent final
{
public:
	class AActor*                                 M_pHitActor;                                       // 0x0000(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class AActor*                                 M_pCollidedActor;                                  // 0x0008(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_10[0x90];                                      // 0x0010(0x0090)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FBFGCollisionEvent) == 0x000008, "Wrong alignment on FBFGCollisionEvent");
static_assert(sizeof(FBFGCollisionEvent) == 0x0000A0, "Wrong size on FBFGCollisionEvent");
static_assert(offsetof(FBFGCollisionEvent, M_pHitActor) == 0x000000, "Member 'FBFGCollisionEvent::M_pHitActor' has a wrong offset!");
static_assert(offsetof(FBFGCollisionEvent, M_pCollidedActor) == 0x000008, "Member 'FBFGCollisionEvent::M_pCollidedActor' has a wrong offset!");

// ScriptStruct BFGCore.BFGItemDescription
// 0x0048 (0x0048 - 0x0000)
struct FBFGItemDescription final
{
public:
	class FText                                   M_strItemTopic;                                    // 0x0000(0x0018)(BlueprintVisible, BlueprintReadOnly, NativeAccessSpecifierPublic)
	class FText                                   M_strItemDescription;                              // 0x0018(0x0018)(BlueprintVisible, BlueprintReadOnly, NativeAccessSpecifierPublic)
	class FText                                   M_strItemTitle;                                    // 0x0030(0x0018)(BlueprintVisible, BlueprintReadOnly, NativeAccessSpecifierPublic)
};
static_assert(alignof(FBFGItemDescription) == 0x000008, "Wrong alignment on FBFGItemDescription");
static_assert(sizeof(FBFGItemDescription) == 0x000048, "Wrong size on FBFGItemDescription");
static_assert(offsetof(FBFGItemDescription, M_strItemTopic) == 0x000000, "Member 'FBFGItemDescription::M_strItemTopic' has a wrong offset!");
static_assert(offsetof(FBFGItemDescription, M_strItemDescription) == 0x000018, "Member 'FBFGItemDescription::M_strItemDescription' has a wrong offset!");
static_assert(offsetof(FBFGItemDescription, M_strItemTitle) == 0x000030, "Member 'FBFGItemDescription::M_strItemTitle' has a wrong offset!");

// ScriptStruct BFGCore.BFGObjectiveMarkerList
// 0x0010 (0x0010 - 0x0000)
struct FBFGObjectiveMarkerList final
{
public:
	TArray<class ABFGObjectiveMarker*>            M_aMarkers;                                        // 0x0000(0x0010)(ZeroConstructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(FBFGObjectiveMarkerList) == 0x000008, "Wrong alignment on FBFGObjectiveMarkerList");
static_assert(sizeof(FBFGObjectiveMarkerList) == 0x000010, "Wrong size on FBFGObjectiveMarkerList");
static_assert(offsetof(FBFGObjectiveMarkerList, M_aMarkers) == 0x000000, "Member 'FBFGObjectiveMarkerList::M_aMarkers' has a wrong offset!");

// ScriptStruct BFGCore.BFGActiveDynamicObjectData
// 0x0010 (0x0010 - 0x0000)
struct FBFGActiveDynamicObjectData final
{
public:
	class ABFGObject_StaticWithPhysics*           M_pObjectPointer;                                  // 0x0000(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_8[0x8];                                        // 0x0008(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FBFGActiveDynamicObjectData) == 0x000008, "Wrong alignment on FBFGActiveDynamicObjectData");
static_assert(sizeof(FBFGActiveDynamicObjectData) == 0x000010, "Wrong size on FBFGActiveDynamicObjectData");
static_assert(offsetof(FBFGActiveDynamicObjectData, M_pObjectPointer) == 0x000000, "Member 'FBFGActiveDynamicObjectData::M_pObjectPointer' has a wrong offset!");

// ScriptStruct BFGCore.BFGPlayerData_Collectables
// 0x0010 (0x0010 - 0x0000)
struct FBFGPlayerData_Collectables final
{
public:
	TArray<struct FBFGPlayerData_Collectables_WorldEntry> M_aData;                                           // 0x0000(0x0010)(ZeroConstructor, SaveGame, NativeAccessSpecifierPublic)
};
static_assert(alignof(FBFGPlayerData_Collectables) == 0x000008, "Wrong alignment on FBFGPlayerData_Collectables");
static_assert(sizeof(FBFGPlayerData_Collectables) == 0x000010, "Wrong size on FBFGPlayerData_Collectables");
static_assert(offsetof(FBFGPlayerData_Collectables, M_aData) == 0x000000, "Member 'FBFGPlayerData_Collectables::M_aData' has a wrong offset!");

// ScriptStruct BFGCore.BFGPlayerData_PlayerState
// 0x0140 (0x0140 - 0x0000)
struct FBFGPlayerData_PlayerState final
{
public:
	int32                                         M_iDNA;                                            // 0x0000(0x0004)(ZeroConstructor, SaveGame, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_4[0x4];                                        // 0x0004(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	TMap<EItemValueTypeEnum, int32>               M_aAmmo;                                           // 0x0008(0x0050)(ZeroConstructor, SaveGame, NativeAccessSpecifierPublic)
	struct FGameplayTag                           M_oSelectedSkin;                                   // 0x0058(0x0008)(SaveGame, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FGameplayTagContainer                  M_gameplayTagsUnlocked;                            // 0x0060(0x0020)(SaveGame, NativeAccessSpecifierPublic)
	struct FGameplayTagContainer                  M_gameplayTagsTempLocked;                          // 0x0080(0x0020)(SaveGame, NativeAccessSpecifierPublic)
	struct FGameplayTagContainer                  M_gameplayTagsTempUnlocked;                        // 0x00A0(0x0020)(SaveGame, NativeAccessSpecifierPublic)
	struct FGameplayTagContainer                  M_NotificationTagsSeen;                            // 0x00C0(0x0020)(SaveGame, NativeAccessSpecifierPublic)
	struct FBFGPlayerData_Collectables            M_collectables;                                    // 0x00E0(0x0010)(SaveGame, NativeAccessSpecifierPublic)
	TSet<class FName>                             M_NotificationNamesSeen;                           // 0x00F0(0x0050)(ZeroConstructor, SaveGame, NativeAccessSpecifierPublic)
};
static_assert(alignof(FBFGPlayerData_PlayerState) == 0x000008, "Wrong alignment on FBFGPlayerData_PlayerState");
static_assert(sizeof(FBFGPlayerData_PlayerState) == 0x000140, "Wrong size on FBFGPlayerData_PlayerState");
static_assert(offsetof(FBFGPlayerData_PlayerState, M_iDNA) == 0x000000, "Member 'FBFGPlayerData_PlayerState::M_iDNA' has a wrong offset!");
static_assert(offsetof(FBFGPlayerData_PlayerState, M_aAmmo) == 0x000008, "Member 'FBFGPlayerData_PlayerState::M_aAmmo' has a wrong offset!");
static_assert(offsetof(FBFGPlayerData_PlayerState, M_oSelectedSkin) == 0x000058, "Member 'FBFGPlayerData_PlayerState::M_oSelectedSkin' has a wrong offset!");
static_assert(offsetof(FBFGPlayerData_PlayerState, M_gameplayTagsUnlocked) == 0x000060, "Member 'FBFGPlayerData_PlayerState::M_gameplayTagsUnlocked' has a wrong offset!");
static_assert(offsetof(FBFGPlayerData_PlayerState, M_gameplayTagsTempLocked) == 0x000080, "Member 'FBFGPlayerData_PlayerState::M_gameplayTagsTempLocked' has a wrong offset!");
static_assert(offsetof(FBFGPlayerData_PlayerState, M_gameplayTagsTempUnlocked) == 0x0000A0, "Member 'FBFGPlayerData_PlayerState::M_gameplayTagsTempUnlocked' has a wrong offset!");
static_assert(offsetof(FBFGPlayerData_PlayerState, M_NotificationTagsSeen) == 0x0000C0, "Member 'FBFGPlayerData_PlayerState::M_NotificationTagsSeen' has a wrong offset!");
static_assert(offsetof(FBFGPlayerData_PlayerState, M_collectables) == 0x0000E0, "Member 'FBFGPlayerData_PlayerState::M_collectables' has a wrong offset!");
static_assert(offsetof(FBFGPlayerData_PlayerState, M_NotificationNamesSeen) == 0x0000F0, "Member 'FBFGPlayerData_PlayerState::M_NotificationNamesSeen' has a wrong offset!");

// ScriptStruct BFGCore.BFGSaveGame_PlayerData
// 0x0200 (0x0200 - 0x0000)
struct FBFGSaveGame_PlayerData final
{
public:
	bool                                          M_bHasSpawnLocation;                               // 0x0000(0x0001)(ZeroConstructor, SaveGame, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          M_bIsCharacterForm;                                // 0x0001(0x0001)(ZeroConstructor, SaveGame, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_2[0xE];                                        // 0x0002(0x000E)(Fixing Size After Last Property [ Dumper-7 ])
	struct FTransform                             M_characterTransform;                              // 0x0010(0x0030)(SaveGame, IsPlainOldData, NoDestructor, Protected, NativeAccessSpecifierProtected)
	struct FTransform                             M_ufoTransform;                                    // 0x0040(0x0030)(SaveGame, IsPlainOldData, NoDestructor, Protected, NativeAccessSpecifierProtected)
	bool                                          M_bIsHolobobing;                                   // 0x0070(0x0001)(ZeroConstructor, SaveGame, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_71[0x7];                                       // 0x0071(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	struct FSoftObjectPath                        M_oHolobobTargetSkeletalMesh;                      // 0x0078(0x0018)(ZeroConstructor, SaveGame, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	struct FSoftClassPath                         M_oHolobobAnimationComponentClass;                 // 0x0090(0x0018)(ZeroConstructor, SaveGame, Protected, NativeAccessSpecifierProtected)
	TArray<struct FGameplayTag>                   M_aHolobobCopiedGameplayTags;                      // 0x00A8(0x0010)(ZeroConstructor, SaveGame, Protected, NativeAccessSpecifierProtected)
	struct FBFGPlayerData_PlayerState             M_stateData;                                       // 0x00B8(0x0140)(SaveGame, Protected, NativeAccessSpecifierProtected)
	uint8                                         Pad_1F8[0x8];                                      // 0x01F8(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FBFGSaveGame_PlayerData) == 0x000010, "Wrong alignment on FBFGSaveGame_PlayerData");
static_assert(sizeof(FBFGSaveGame_PlayerData) == 0x000200, "Wrong size on FBFGSaveGame_PlayerData");
static_assert(offsetof(FBFGSaveGame_PlayerData, M_bHasSpawnLocation) == 0x000000, "Member 'FBFGSaveGame_PlayerData::M_bHasSpawnLocation' has a wrong offset!");
static_assert(offsetof(FBFGSaveGame_PlayerData, M_bIsCharacterForm) == 0x000001, "Member 'FBFGSaveGame_PlayerData::M_bIsCharacterForm' has a wrong offset!");
static_assert(offsetof(FBFGSaveGame_PlayerData, M_characterTransform) == 0x000010, "Member 'FBFGSaveGame_PlayerData::M_characterTransform' has a wrong offset!");
static_assert(offsetof(FBFGSaveGame_PlayerData, M_ufoTransform) == 0x000040, "Member 'FBFGSaveGame_PlayerData::M_ufoTransform' has a wrong offset!");
static_assert(offsetof(FBFGSaveGame_PlayerData, M_bIsHolobobing) == 0x000070, "Member 'FBFGSaveGame_PlayerData::M_bIsHolobobing' has a wrong offset!");
static_assert(offsetof(FBFGSaveGame_PlayerData, M_oHolobobTargetSkeletalMesh) == 0x000078, "Member 'FBFGSaveGame_PlayerData::M_oHolobobTargetSkeletalMesh' has a wrong offset!");
static_assert(offsetof(FBFGSaveGame_PlayerData, M_oHolobobAnimationComponentClass) == 0x000090, "Member 'FBFGSaveGame_PlayerData::M_oHolobobAnimationComponentClass' has a wrong offset!");
static_assert(offsetof(FBFGSaveGame_PlayerData, M_aHolobobCopiedGameplayTags) == 0x0000A8, "Member 'FBFGSaveGame_PlayerData::M_aHolobobCopiedGameplayTags' has a wrong offset!");
static_assert(offsetof(FBFGSaveGame_PlayerData, M_stateData) == 0x0000B8, "Member 'FBFGSaveGame_PlayerData::M_stateData' has a wrong offset!");

// ScriptStruct BFGCore.BFGEffectBankEntry
// 0x0118 (0x0118 - 0x0000)
struct FBFGEffectBankEntry final
{
public:
	EBFGEffect_Identifier                         M_eIdentifier;                                     // 0x0000(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1[0x3];                                        // 0x0001(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	int32                                         M_iPriority;                                       // 0x0004(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         M_fDelay;                                          // 0x0008(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_C[0x4];                                        // 0x000C(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	TSubclassOf<class ABFGEffectActor>            M_pEffectActorType;                                // 0x0010(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TSubclassOf<class UBFGEffectObject>           M_pEffectObjectType;                               // 0x0018(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UParticleSystem*                        M_pEffectTemplate;                                 // 0x0020(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class USoundCue*                              M_pAudioEffect;                                    // 0x0028(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FBFGEffectBankEntry_ForceFeedback      M_oForceFeedback;                                  // 0x0030(0x0018)(Edit, BlueprintVisible, BlueprintReadOnly, NoDestructor, NativeAccessSpecifierPublic)
	struct FBFGEffectBankEntry_CameraShake        M_oCameraShake;                                    // 0x0048(0x0018)(Edit, BlueprintVisible, BlueprintReadOnly, NoDestructor, NativeAccessSpecifierPublic)
	struct FBFGEffectBankEntry_SustainData        M_oSustain;                                        // 0x0060(0x0048)(Edit, BlueprintVisible, BlueprintReadOnly, NoDestructor, NativeAccessSpecifierPublic)
	struct FBFGEffectBankEntry_ReleaseData        M_oRelease;                                        // 0x00A8(0x0040)(Edit, BlueprintVisible, BlueprintReadOnly, NoDestructor, NativeAccessSpecifierPublic)
	bool                                          M_bIsPersistent;                                   // 0x00E8(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_E9[0x7];                                       // 0x00E9(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<EBFGEffect_Identifier>                 M_aOnDeathTriggers;                                // 0x00F0(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, NativeAccessSpecifierPublic)
	struct FGuid                                  M_entryId;                                         // 0x0100(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         M_iSlot;                                           // 0x0110(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_114[0x4];                                      // 0x0114(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FBFGEffectBankEntry) == 0x000008, "Wrong alignment on FBFGEffectBankEntry");
static_assert(sizeof(FBFGEffectBankEntry) == 0x000118, "Wrong size on FBFGEffectBankEntry");
static_assert(offsetof(FBFGEffectBankEntry, M_eIdentifier) == 0x000000, "Member 'FBFGEffectBankEntry::M_eIdentifier' has a wrong offset!");
static_assert(offsetof(FBFGEffectBankEntry, M_iPriority) == 0x000004, "Member 'FBFGEffectBankEntry::M_iPriority' has a wrong offset!");
static_assert(offsetof(FBFGEffectBankEntry, M_fDelay) == 0x000008, "Member 'FBFGEffectBankEntry::M_fDelay' has a wrong offset!");
static_assert(offsetof(FBFGEffectBankEntry, M_pEffectActorType) == 0x000010, "Member 'FBFGEffectBankEntry::M_pEffectActorType' has a wrong offset!");
static_assert(offsetof(FBFGEffectBankEntry, M_pEffectObjectType) == 0x000018, "Member 'FBFGEffectBankEntry::M_pEffectObjectType' has a wrong offset!");
static_assert(offsetof(FBFGEffectBankEntry, M_pEffectTemplate) == 0x000020, "Member 'FBFGEffectBankEntry::M_pEffectTemplate' has a wrong offset!");
static_assert(offsetof(FBFGEffectBankEntry, M_pAudioEffect) == 0x000028, "Member 'FBFGEffectBankEntry::M_pAudioEffect' has a wrong offset!");
static_assert(offsetof(FBFGEffectBankEntry, M_oForceFeedback) == 0x000030, "Member 'FBFGEffectBankEntry::M_oForceFeedback' has a wrong offset!");
static_assert(offsetof(FBFGEffectBankEntry, M_oCameraShake) == 0x000048, "Member 'FBFGEffectBankEntry::M_oCameraShake' has a wrong offset!");
static_assert(offsetof(FBFGEffectBankEntry, M_oSustain) == 0x000060, "Member 'FBFGEffectBankEntry::M_oSustain' has a wrong offset!");
static_assert(offsetof(FBFGEffectBankEntry, M_oRelease) == 0x0000A8, "Member 'FBFGEffectBankEntry::M_oRelease' has a wrong offset!");
static_assert(offsetof(FBFGEffectBankEntry, M_bIsPersistent) == 0x0000E8, "Member 'FBFGEffectBankEntry::M_bIsPersistent' has a wrong offset!");
static_assert(offsetof(FBFGEffectBankEntry, M_aOnDeathTriggers) == 0x0000F0, "Member 'FBFGEffectBankEntry::M_aOnDeathTriggers' has a wrong offset!");
static_assert(offsetof(FBFGEffectBankEntry, M_entryId) == 0x000100, "Member 'FBFGEffectBankEntry::M_entryId' has a wrong offset!");
static_assert(offsetof(FBFGEffectBankEntry, M_iSlot) == 0x000110, "Member 'FBFGEffectBankEntry::M_iSlot' has a wrong offset!");

// ScriptStruct BFGCore.BFGMissionSelectionState
// 0x0018 (0x0018 - 0x0000)
struct FBFGMissionSelectionState final
{
public:
	uint8                                         Pad_0[0x10];                                       // 0x0000(0x0010)(Fixing Size After Last Property [ Dumper-7 ])
	TSubclassOf<class UBFGQuest>                  M_pMainMissionQuest;                               // 0x0010(0x0008)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FBFGMissionSelectionState) == 0x000008, "Wrong alignment on FBFGMissionSelectionState");
static_assert(sizeof(FBFGMissionSelectionState) == 0x000018, "Wrong size on FBFGMissionSelectionState");
static_assert(offsetof(FBFGMissionSelectionState, M_pMainMissionQuest) == 0x000010, "Member 'FBFGMissionSelectionState::M_pMainMissionQuest' has a wrong offset!");

// ScriptStruct BFGCore.BFGEffectBlackboardParameterSlots_ActorComponent
// 0x0058 (0x0058 - 0x0000)
struct FBFGEffectBlackboardParameterSlots_ActorComponent final
{
public:
	class UActorComponent*                        M_pNoSlotValue;                                    // 0x0000(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TMap<int32, class UActorComponent*>           M_apSlotValues;                                    // 0x0008(0x0050)(ExportObject, ZeroConstructor, ContainsInstancedReference, NativeAccessSpecifierPublic)
};
static_assert(alignof(FBFGEffectBlackboardParameterSlots_ActorComponent) == 0x000008, "Wrong alignment on FBFGEffectBlackboardParameterSlots_ActorComponent");
static_assert(sizeof(FBFGEffectBlackboardParameterSlots_ActorComponent) == 0x000058, "Wrong size on FBFGEffectBlackboardParameterSlots_ActorComponent");
static_assert(offsetof(FBFGEffectBlackboardParameterSlots_ActorComponent, M_pNoSlotValue) == 0x000000, "Member 'FBFGEffectBlackboardParameterSlots_ActorComponent::M_pNoSlotValue' has a wrong offset!");
static_assert(offsetof(FBFGEffectBlackboardParameterSlots_ActorComponent, M_apSlotValues) == 0x000008, "Member 'FBFGEffectBlackboardParameterSlots_ActorComponent::M_apSlotValues' has a wrong offset!");

// ScriptStruct BFGCore.BFGEffectBlackboardParameterSlots_Object
// 0x0058 (0x0058 - 0x0000)
struct FBFGEffectBlackboardParameterSlots_Object final
{
public:
	class UObject*                                M_pNoSlotValue;                                    // 0x0000(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TMap<int32, class UObject*>                   M_apSlotValues;                                    // 0x0008(0x0050)(ZeroConstructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(FBFGEffectBlackboardParameterSlots_Object) == 0x000008, "Wrong alignment on FBFGEffectBlackboardParameterSlots_Object");
static_assert(sizeof(FBFGEffectBlackboardParameterSlots_Object) == 0x000058, "Wrong size on FBFGEffectBlackboardParameterSlots_Object");
static_assert(offsetof(FBFGEffectBlackboardParameterSlots_Object, M_pNoSlotValue) == 0x000000, "Member 'FBFGEffectBlackboardParameterSlots_Object::M_pNoSlotValue' has a wrong offset!");
static_assert(offsetof(FBFGEffectBlackboardParameterSlots_Object, M_apSlotValues) == 0x000008, "Member 'FBFGEffectBlackboardParameterSlots_Object::M_apSlotValues' has a wrong offset!");

// ScriptStruct BFGCore.BFGEffectBlackboardParameterSlots_Actor
// 0x0058 (0x0058 - 0x0000)
struct FBFGEffectBlackboardParameterSlots_Actor final
{
public:
	class AActor*                                 M_pNoSlotValue;                                    // 0x0000(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TMap<int32, class AActor*>                    M_apSlotValues;                                    // 0x0008(0x0050)(ZeroConstructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(FBFGEffectBlackboardParameterSlots_Actor) == 0x000008, "Wrong alignment on FBFGEffectBlackboardParameterSlots_Actor");
static_assert(sizeof(FBFGEffectBlackboardParameterSlots_Actor) == 0x000058, "Wrong size on FBFGEffectBlackboardParameterSlots_Actor");
static_assert(offsetof(FBFGEffectBlackboardParameterSlots_Actor, M_pNoSlotValue) == 0x000000, "Member 'FBFGEffectBlackboardParameterSlots_Actor::M_pNoSlotValue' has a wrong offset!");
static_assert(offsetof(FBFGEffectBlackboardParameterSlots_Actor, M_apSlotValues) == 0x000008, "Member 'FBFGEffectBlackboardParameterSlots_Actor::M_apSlotValues' has a wrong offset!");

// ScriptStruct BFGCore.BFGEffectBlackboardParameterSlots_Int
// 0x0058 (0x0058 - 0x0000)
struct FBFGEffectBlackboardParameterSlots_Int final
{
public:
	int32                                         M_iNoSlotValue;                                    // 0x0000(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_4[0x4];                                        // 0x0004(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	TMap<int32, int32>                            M_aSlotValues;                                     // 0x0008(0x0050)(ZeroConstructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(FBFGEffectBlackboardParameterSlots_Int) == 0x000008, "Wrong alignment on FBFGEffectBlackboardParameterSlots_Int");
static_assert(sizeof(FBFGEffectBlackboardParameterSlots_Int) == 0x000058, "Wrong size on FBFGEffectBlackboardParameterSlots_Int");
static_assert(offsetof(FBFGEffectBlackboardParameterSlots_Int, M_iNoSlotValue) == 0x000000, "Member 'FBFGEffectBlackboardParameterSlots_Int::M_iNoSlotValue' has a wrong offset!");
static_assert(offsetof(FBFGEffectBlackboardParameterSlots_Int, M_aSlotValues) == 0x000008, "Member 'FBFGEffectBlackboardParameterSlots_Int::M_aSlotValues' has a wrong offset!");

// ScriptStruct BFGCore.BFGEffectBlackboardParameterSlots_Bool
// 0x0058 (0x0058 - 0x0000)
struct FBFGEffectBlackboardParameterSlots_Bool final
{
public:
	bool                                          M_oNoSlotValue;                                    // 0x0000(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1[0x7];                                        // 0x0001(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	TMap<int32, bool>                             M_aSlotValues;                                     // 0x0008(0x0050)(ZeroConstructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(FBFGEffectBlackboardParameterSlots_Bool) == 0x000008, "Wrong alignment on FBFGEffectBlackboardParameterSlots_Bool");
static_assert(sizeof(FBFGEffectBlackboardParameterSlots_Bool) == 0x000058, "Wrong size on FBFGEffectBlackboardParameterSlots_Bool");
static_assert(offsetof(FBFGEffectBlackboardParameterSlots_Bool, M_oNoSlotValue) == 0x000000, "Member 'FBFGEffectBlackboardParameterSlots_Bool::M_oNoSlotValue' has a wrong offset!");
static_assert(offsetof(FBFGEffectBlackboardParameterSlots_Bool, M_aSlotValues) == 0x000008, "Member 'FBFGEffectBlackboardParameterSlots_Bool::M_aSlotValues' has a wrong offset!");

// ScriptStruct BFGCore.BFGEffectBlackboardParameterSlots_Rotator
// 0x0060 (0x0060 - 0x0000)
struct FBFGEffectBlackboardParameterSlots_Rotator final
{
public:
	struct FRotator                               M_oNoSlotValue;                                    // 0x0000(0x000C)(ZeroConstructor, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
	uint8                                         Pad_C[0x4];                                        // 0x000C(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	TMap<int32, struct FRotator>                  M_aSlotValues;                                     // 0x0010(0x0050)(ZeroConstructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(FBFGEffectBlackboardParameterSlots_Rotator) == 0x000008, "Wrong alignment on FBFGEffectBlackboardParameterSlots_Rotator");
static_assert(sizeof(FBFGEffectBlackboardParameterSlots_Rotator) == 0x000060, "Wrong size on FBFGEffectBlackboardParameterSlots_Rotator");
static_assert(offsetof(FBFGEffectBlackboardParameterSlots_Rotator, M_oNoSlotValue) == 0x000000, "Member 'FBFGEffectBlackboardParameterSlots_Rotator::M_oNoSlotValue' has a wrong offset!");
static_assert(offsetof(FBFGEffectBlackboardParameterSlots_Rotator, M_aSlotValues) == 0x000010, "Member 'FBFGEffectBlackboardParameterSlots_Rotator::M_aSlotValues' has a wrong offset!");

// ScriptStruct BFGCore.BFGVehicleFillWithPassengersHelper
// 0x0090 (0x0090 - 0x0000)
struct FBFGVehicleFillWithPassengersHelper final
{
public:
	struct FBFGVehiclePassengersOverride          M_passengersSetup;                                 // 0x0000(0x0048)(Transient, Protected, NativeAccessSpecifierProtected)
	struct FBFGPassengersData                     M_passengersData;                                  // 0x0048(0x0038)(Transient, Protected, NativeAccessSpecifierProtected)
	int32                                         M_iVehicleMaxPopulation;                           // 0x0080(0x0004)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	EBFGBehaviourState_NPC                        M_eBehaviourState;                                 // 0x0084(0x0001)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_85[0x3];                                       // 0x0085(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	int32                                         M_iVehicleRemainingPlaces;                         // 0x0088(0x0004)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_8C[0x4];                                       // 0x008C(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FBFGVehicleFillWithPassengersHelper) == 0x000008, "Wrong alignment on FBFGVehicleFillWithPassengersHelper");
static_assert(sizeof(FBFGVehicleFillWithPassengersHelper) == 0x000090, "Wrong size on FBFGVehicleFillWithPassengersHelper");
static_assert(offsetof(FBFGVehicleFillWithPassengersHelper, M_passengersSetup) == 0x000000, "Member 'FBFGVehicleFillWithPassengersHelper::M_passengersSetup' has a wrong offset!");
static_assert(offsetof(FBFGVehicleFillWithPassengersHelper, M_passengersData) == 0x000048, "Member 'FBFGVehicleFillWithPassengersHelper::M_passengersData' has a wrong offset!");
static_assert(offsetof(FBFGVehicleFillWithPassengersHelper, M_iVehicleMaxPopulation) == 0x000080, "Member 'FBFGVehicleFillWithPassengersHelper::M_iVehicleMaxPopulation' has a wrong offset!");
static_assert(offsetof(FBFGVehicleFillWithPassengersHelper, M_eBehaviourState) == 0x000084, "Member 'FBFGVehicleFillWithPassengersHelper::M_eBehaviourState' has a wrong offset!");
static_assert(offsetof(FBFGVehicleFillWithPassengersHelper, M_iVehicleRemainingPlaces) == 0x000088, "Member 'FBFGVehicleFillWithPassengersHelper::M_iVehicleRemainingPlaces' has a wrong offset!");

// ScriptStruct BFGCore.BFGEffectBlackboardParameter_RandVector
// 0x0018 (0x0018 - 0x0000)
struct FBFGEffectBlackboardParameter_RandVector final
{
public:
	struct FVector                                M_vMin;                                            // 0x0000(0x000C)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                M_vMax;                                            // 0x000C(0x000C)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FBFGEffectBlackboardParameter_RandVector) == 0x000004, "Wrong alignment on FBFGEffectBlackboardParameter_RandVector");
static_assert(sizeof(FBFGEffectBlackboardParameter_RandVector) == 0x000018, "Wrong size on FBFGEffectBlackboardParameter_RandVector");
static_assert(offsetof(FBFGEffectBlackboardParameter_RandVector, M_vMin) == 0x000000, "Member 'FBFGEffectBlackboardParameter_RandVector::M_vMin' has a wrong offset!");
static_assert(offsetof(FBFGEffectBlackboardParameter_RandVector, M_vMax) == 0x00000C, "Member 'FBFGEffectBlackboardParameter_RandVector::M_vMax' has a wrong offset!");

// ScriptStruct BFGCore.BFGEffectBlackboardParameterSlots_RandVector
// 0x0068 (0x0068 - 0x0000)
struct FBFGEffectBlackboardParameterSlots_RandVector final
{
public:
	struct FBFGEffectBlackboardParameter_RandVector M_oNoSlotValue;                                    // 0x0000(0x0018)(NoDestructor, NativeAccessSpecifierPublic)
	TMap<int32, struct FBFGEffectBlackboardParameter_RandVector> M_aSlotValues;                                     // 0x0018(0x0050)(ZeroConstructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(FBFGEffectBlackboardParameterSlots_RandVector) == 0x000008, "Wrong alignment on FBFGEffectBlackboardParameterSlots_RandVector");
static_assert(sizeof(FBFGEffectBlackboardParameterSlots_RandVector) == 0x000068, "Wrong size on FBFGEffectBlackboardParameterSlots_RandVector");
static_assert(offsetof(FBFGEffectBlackboardParameterSlots_RandVector, M_oNoSlotValue) == 0x000000, "Member 'FBFGEffectBlackboardParameterSlots_RandVector::M_oNoSlotValue' has a wrong offset!");
static_assert(offsetof(FBFGEffectBlackboardParameterSlots_RandVector, M_aSlotValues) == 0x000018, "Member 'FBFGEffectBlackboardParameterSlots_RandVector::M_aSlotValues' has a wrong offset!");

// ScriptStruct BFGCore.BFGEffectBlackboardParameter_RandFloat
// 0x0008 (0x0008 - 0x0000)
struct FBFGEffectBlackboardParameter_RandFloat final
{
public:
	float                                         M_fMin;                                            // 0x0000(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         M_fMax;                                            // 0x0004(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FBFGEffectBlackboardParameter_RandFloat) == 0x000004, "Wrong alignment on FBFGEffectBlackboardParameter_RandFloat");
static_assert(sizeof(FBFGEffectBlackboardParameter_RandFloat) == 0x000008, "Wrong size on FBFGEffectBlackboardParameter_RandFloat");
static_assert(offsetof(FBFGEffectBlackboardParameter_RandFloat, M_fMin) == 0x000000, "Member 'FBFGEffectBlackboardParameter_RandFloat::M_fMin' has a wrong offset!");
static_assert(offsetof(FBFGEffectBlackboardParameter_RandFloat, M_fMax) == 0x000004, "Member 'FBFGEffectBlackboardParameter_RandFloat::M_fMax' has a wrong offset!");

// ScriptStruct BFGCore.BFGEffectBlackboardParameterSlots_RandFloat
// 0x0058 (0x0058 - 0x0000)
struct FBFGEffectBlackboardParameterSlots_RandFloat final
{
public:
	struct FBFGEffectBlackboardParameter_RandFloat M_oNoSlotValue;                                    // 0x0000(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
	TMap<int32, struct FBFGEffectBlackboardParameter_RandFloat> M_aSlotValues;                                     // 0x0008(0x0050)(ZeroConstructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(FBFGEffectBlackboardParameterSlots_RandFloat) == 0x000008, "Wrong alignment on FBFGEffectBlackboardParameterSlots_RandFloat");
static_assert(sizeof(FBFGEffectBlackboardParameterSlots_RandFloat) == 0x000058, "Wrong size on FBFGEffectBlackboardParameterSlots_RandFloat");
static_assert(offsetof(FBFGEffectBlackboardParameterSlots_RandFloat, M_oNoSlotValue) == 0x000000, "Member 'FBFGEffectBlackboardParameterSlots_RandFloat::M_oNoSlotValue' has a wrong offset!");
static_assert(offsetof(FBFGEffectBlackboardParameterSlots_RandFloat, M_aSlotValues) == 0x000008, "Member 'FBFGEffectBlackboardParameterSlots_RandFloat::M_aSlotValues' has a wrong offset!");

// ScriptStruct BFGCore.BFGSystemData_AlertSystem
// 0x0014 (0x0014 - 0x0000)
struct FBFGSystemData_AlertSystem final
{
public:
	bool                                          M_bRestoreAlertData;                               // 0x0000(0x0001)(ZeroConstructor, SaveGame, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          M_bIsLocked;                                       // 0x0001(0x0001)(ZeroConstructor, SaveGame, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          M_bIsSpawningEnabled;                              // 0x0002(0x0001)(ZeroConstructor, SaveGame, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_3[0x1];                                        // 0x0003(0x0001)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         M_fResponseValue;                                  // 0x0004(0x0004)(ZeroConstructor, SaveGame, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         M_iCurrentLevelIndex;                              // 0x0008(0x0004)(ZeroConstructor, SaveGame, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         M_iMaxResponseLevelIndex;                          // 0x000C(0x0004)(ZeroConstructor, SaveGame, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          M_bIsStealthWarningEnabled;                        // 0x0010(0x0001)(ZeroConstructor, SaveGame, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EBFGAlertSystemState                          M_stealthWarningState;                             // 0x0011(0x0001)(ZeroConstructor, SaveGame, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_12[0x2];                                       // 0x0012(0x0002)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FBFGSystemData_AlertSystem) == 0x000004, "Wrong alignment on FBFGSystemData_AlertSystem");
static_assert(sizeof(FBFGSystemData_AlertSystem) == 0x000014, "Wrong size on FBFGSystemData_AlertSystem");
static_assert(offsetof(FBFGSystemData_AlertSystem, M_bRestoreAlertData) == 0x000000, "Member 'FBFGSystemData_AlertSystem::M_bRestoreAlertData' has a wrong offset!");
static_assert(offsetof(FBFGSystemData_AlertSystem, M_bIsLocked) == 0x000001, "Member 'FBFGSystemData_AlertSystem::M_bIsLocked' has a wrong offset!");
static_assert(offsetof(FBFGSystemData_AlertSystem, M_bIsSpawningEnabled) == 0x000002, "Member 'FBFGSystemData_AlertSystem::M_bIsSpawningEnabled' has a wrong offset!");
static_assert(offsetof(FBFGSystemData_AlertSystem, M_fResponseValue) == 0x000004, "Member 'FBFGSystemData_AlertSystem::M_fResponseValue' has a wrong offset!");
static_assert(offsetof(FBFGSystemData_AlertSystem, M_iCurrentLevelIndex) == 0x000008, "Member 'FBFGSystemData_AlertSystem::M_iCurrentLevelIndex' has a wrong offset!");
static_assert(offsetof(FBFGSystemData_AlertSystem, M_iMaxResponseLevelIndex) == 0x00000C, "Member 'FBFGSystemData_AlertSystem::M_iMaxResponseLevelIndex' has a wrong offset!");
static_assert(offsetof(FBFGSystemData_AlertSystem, M_bIsStealthWarningEnabled) == 0x000010, "Member 'FBFGSystemData_AlertSystem::M_bIsStealthWarningEnabled' has a wrong offset!");
static_assert(offsetof(FBFGSystemData_AlertSystem, M_stealthWarningState) == 0x000011, "Member 'FBFGSystemData_AlertSystem::M_stealthWarningState' has a wrong offset!");

// ScriptStruct BFGCore.BFGEffectBlackboardParameterSlots_Float
// 0x0058 (0x0058 - 0x0000)
struct FBFGEffectBlackboardParameterSlots_Float final
{
public:
	float                                         M_fNoSlotValue;                                    // 0x0000(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_4[0x4];                                        // 0x0004(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	TMap<int32, float>                            M_aSlotValues;                                     // 0x0008(0x0050)(ZeroConstructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(FBFGEffectBlackboardParameterSlots_Float) == 0x000008, "Wrong alignment on FBFGEffectBlackboardParameterSlots_Float");
static_assert(sizeof(FBFGEffectBlackboardParameterSlots_Float) == 0x000058, "Wrong size on FBFGEffectBlackboardParameterSlots_Float");
static_assert(offsetof(FBFGEffectBlackboardParameterSlots_Float, M_fNoSlotValue) == 0x000000, "Member 'FBFGEffectBlackboardParameterSlots_Float::M_fNoSlotValue' has a wrong offset!");
static_assert(offsetof(FBFGEffectBlackboardParameterSlots_Float, M_aSlotValues) == 0x000008, "Member 'FBFGEffectBlackboardParameterSlots_Float::M_aSlotValues' has a wrong offset!");

// ScriptStruct BFGCore.BFGEffectContainerDescriptor
// 0x0060 (0x0060 - 0x0000)
struct FBFGEffectContainerDescriptor final
{
public:
	struct FTransform                             M_Transform;                                       // 0x0000(0x0030)(Transient, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
	class FName                                   M_oSocketName;                                     // 0x0030(0x0008)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class AActor*                                 M_pAttachTo;                                       // 0x0038(0x0008)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class USceneComponent*                        M_pAttachToComponent;                              // 0x0040(0x0008)(ExportObject, ZeroConstructor, Transient, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EAttachmentRule                               M_eLocationAttachRule;                             // 0x0048(0x0001)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EAttachmentRule                               M_eRotationAttachRule;                             // 0x0049(0x0001)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EAttachmentRule                               M_eScaleAttachRule;                                // 0x004A(0x0001)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          M_bAbsoluteLocation;                               // 0x004B(0x0001)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          M_bAbsoluteRotation;                               // 0x004C(0x0001)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_4D[0x3];                                       // 0x004D(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	class ABFGPlayerController*                   M_pPlayerController;                               // 0x0050(0x0008)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         M_iSlot;                                           // 0x0058(0x0004)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         M_iEffectPriority;                                 // 0x005C(0x0004)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FBFGEffectContainerDescriptor) == 0x000010, "Wrong alignment on FBFGEffectContainerDescriptor");
static_assert(sizeof(FBFGEffectContainerDescriptor) == 0x000060, "Wrong size on FBFGEffectContainerDescriptor");
static_assert(offsetof(FBFGEffectContainerDescriptor, M_Transform) == 0x000000, "Member 'FBFGEffectContainerDescriptor::M_Transform' has a wrong offset!");
static_assert(offsetof(FBFGEffectContainerDescriptor, M_oSocketName) == 0x000030, "Member 'FBFGEffectContainerDescriptor::M_oSocketName' has a wrong offset!");
static_assert(offsetof(FBFGEffectContainerDescriptor, M_pAttachTo) == 0x000038, "Member 'FBFGEffectContainerDescriptor::M_pAttachTo' has a wrong offset!");
static_assert(offsetof(FBFGEffectContainerDescriptor, M_pAttachToComponent) == 0x000040, "Member 'FBFGEffectContainerDescriptor::M_pAttachToComponent' has a wrong offset!");
static_assert(offsetof(FBFGEffectContainerDescriptor, M_eLocationAttachRule) == 0x000048, "Member 'FBFGEffectContainerDescriptor::M_eLocationAttachRule' has a wrong offset!");
static_assert(offsetof(FBFGEffectContainerDescriptor, M_eRotationAttachRule) == 0x000049, "Member 'FBFGEffectContainerDescriptor::M_eRotationAttachRule' has a wrong offset!");
static_assert(offsetof(FBFGEffectContainerDescriptor, M_eScaleAttachRule) == 0x00004A, "Member 'FBFGEffectContainerDescriptor::M_eScaleAttachRule' has a wrong offset!");
static_assert(offsetof(FBFGEffectContainerDescriptor, M_bAbsoluteLocation) == 0x00004B, "Member 'FBFGEffectContainerDescriptor::M_bAbsoluteLocation' has a wrong offset!");
static_assert(offsetof(FBFGEffectContainerDescriptor, M_bAbsoluteRotation) == 0x00004C, "Member 'FBFGEffectContainerDescriptor::M_bAbsoluteRotation' has a wrong offset!");
static_assert(offsetof(FBFGEffectContainerDescriptor, M_pPlayerController) == 0x000050, "Member 'FBFGEffectContainerDescriptor::M_pPlayerController' has a wrong offset!");
static_assert(offsetof(FBFGEffectContainerDescriptor, M_iSlot) == 0x000058, "Member 'FBFGEffectContainerDescriptor::M_iSlot' has a wrong offset!");
static_assert(offsetof(FBFGEffectContainerDescriptor, M_iEffectPriority) == 0x00005C, "Member 'FBFGEffectContainerDescriptor::M_iEffectPriority' has a wrong offset!");

// ScriptStruct BFGCore.BFGTargetCachableLocationConstScore
// 0x0008 (0x0008 - 0x0000)
struct FBFGTargetCachableLocationConstScore final
{
public:
	float                                         M_fWeight;                                         // 0x0000(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         M_fScore;                                          // 0x0004(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FBFGTargetCachableLocationConstScore) == 0x000004, "Wrong alignment on FBFGTargetCachableLocationConstScore");
static_assert(sizeof(FBFGTargetCachableLocationConstScore) == 0x000008, "Wrong size on FBFGTargetCachableLocationConstScore");
static_assert(offsetof(FBFGTargetCachableLocationConstScore, M_fWeight) == 0x000000, "Member 'FBFGTargetCachableLocationConstScore::M_fWeight' has a wrong offset!");
static_assert(offsetof(FBFGTargetCachableLocationConstScore, M_fScore) == 0x000004, "Member 'FBFGTargetCachableLocationConstScore::M_fScore' has a wrong offset!");

// ScriptStruct BFGCore.BFGTargetCachableLocationDistanceScore
// 0x0010 (0x0010 - 0x0000)
struct FBFGTargetCachableLocationDistanceScore final
{
public:
	float                                         M_fWeight;                                         // 0x0000(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         M_fClampToMax;                                     // 0x0004(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         M_fFactor;                                         // 0x0008(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          M_bIgnoreSelf;                                     // 0x000C(0x0001)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_D[0x3];                                        // 0x000D(0x0003)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FBFGTargetCachableLocationDistanceScore) == 0x000004, "Wrong alignment on FBFGTargetCachableLocationDistanceScore");
static_assert(sizeof(FBFGTargetCachableLocationDistanceScore) == 0x000010, "Wrong size on FBFGTargetCachableLocationDistanceScore");
static_assert(offsetof(FBFGTargetCachableLocationDistanceScore, M_fWeight) == 0x000000, "Member 'FBFGTargetCachableLocationDistanceScore::M_fWeight' has a wrong offset!");
static_assert(offsetof(FBFGTargetCachableLocationDistanceScore, M_fClampToMax) == 0x000004, "Member 'FBFGTargetCachableLocationDistanceScore::M_fClampToMax' has a wrong offset!");
static_assert(offsetof(FBFGTargetCachableLocationDistanceScore, M_fFactor) == 0x000008, "Member 'FBFGTargetCachableLocationDistanceScore::M_fFactor' has a wrong offset!");
static_assert(offsetof(FBFGTargetCachableLocationDistanceScore, M_bIgnoreSelf) == 0x00000C, "Member 'FBFGTargetCachableLocationDistanceScore::M_bIgnoreSelf' has a wrong offset!");

// ScriptStruct BFGCore.BFGFoliageComponentInstancePair
// 0x0010 (0x0010 - 0x0000)
struct FBFGFoliageComponentInstancePair final
{
public:
	class UFoliageInstancedStaticMeshComponent*   M_pFoliageComponent;                               // 0x0000(0x0008)(Edit, BlueprintVisible, ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         M_iInstanceIndex;                                  // 0x0008(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_C[0x4];                                        // 0x000C(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FBFGFoliageComponentInstancePair) == 0x000008, "Wrong alignment on FBFGFoliageComponentInstancePair");
static_assert(sizeof(FBFGFoliageComponentInstancePair) == 0x000010, "Wrong size on FBFGFoliageComponentInstancePair");
static_assert(offsetof(FBFGFoliageComponentInstancePair, M_pFoliageComponent) == 0x000000, "Member 'FBFGFoliageComponentInstancePair::M_pFoliageComponent' has a wrong offset!");
static_assert(offsetof(FBFGFoliageComponentInstancePair, M_iInstanceIndex) == 0x000008, "Member 'FBFGFoliageComponentInstancePair::M_iInstanceIndex' has a wrong offset!");

// ScriptStruct BFGCore.BFGGameplayEndSequence_Data
// 0x0190 (0x0190 - 0x0000)
struct FBFGGameplayEndSequence_Data final
{
public:
	uint8                                         Pad_0[0x90];                                       // 0x0000(0x0090)(Fixing Size After Last Property [ Dumper-7 ])
	class UObject*                                M_pMenuContext;                                    // 0x0090(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FBFGSystemData_QuestManager_CompletionRating M_completionRating;                                // 0x0098(0x00F8)(NativeAccessSpecifierPublic)
};
static_assert(alignof(FBFGGameplayEndSequence_Data) == 0x000008, "Wrong alignment on FBFGGameplayEndSequence_Data");
static_assert(sizeof(FBFGGameplayEndSequence_Data) == 0x000190, "Wrong size on FBFGGameplayEndSequence_Data");
static_assert(offsetof(FBFGGameplayEndSequence_Data, M_pMenuContext) == 0x000090, "Member 'FBFGGameplayEndSequence_Data::M_pMenuContext' has a wrong offset!");
static_assert(offsetof(FBFGGameplayEndSequence_Data, M_completionRating) == 0x000098, "Member 'FBFGGameplayEndSequence_Data::M_completionRating' has a wrong offset!");

// ScriptStruct BFGCore.BFGQuest_ElementEscort_Objective
// 0x0090 (0x0090 - 0x0000)
struct FBFGQuest_ElementEscort_Objective final
{
public:
	TSoftObjectPtr<class APawn>                   M_softPawn;                                        // 0x0000(0x0028)(Edit, BlueprintVisible, BlueprintReadOnly, DisableEditOnInstance, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TSoftObjectPtr<class ABFGMissionPath>         M_softPath;                                        // 0x0028(0x0028)(Edit, BlueprintVisible, BlueprintReadOnly, DisableEditOnInstance, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FBFGObjectiveMarkerInfo                M_markerInfo;                                      // 0x0050(0x0028)(Edit, BlueprintVisible, BlueprintReadOnly, DisableEditOnInstance, ContainsInstancedReference, NativeAccessSpecifierPublic)
	float                                         M_fMaxRange;                                       // 0x0078(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         M_fMinRange;                                       // 0x007C(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          M_bUseTrafficSystem;                               // 0x0080(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EBFGNetworkPathAgentEnterExitRule             M_eEnterExitTrafficSystemRule;                     // 0x0081(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          M_bBehaviourStateLocked;                           // 0x0082(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EBFGNetworkPathAgentPriorityLevel             M_eAgentPriority;                                  // 0x0083(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          M_bStopAtEnd;                                      // 0x0084(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_85[0x3];                                       // 0x0085(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         M_fMaxSpeed;                                       // 0x0088(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          M_bUsePatrolPathExtension;                         // 0x008C(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EBFGNPCCharacter_MoveSpeed                    M_moveSpeed;                                       // 0x008D(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_8E[0x2];                                       // 0x008E(0x0002)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FBFGQuest_ElementEscort_Objective) == 0x000008, "Wrong alignment on FBFGQuest_ElementEscort_Objective");
static_assert(sizeof(FBFGQuest_ElementEscort_Objective) == 0x000090, "Wrong size on FBFGQuest_ElementEscort_Objective");
static_assert(offsetof(FBFGQuest_ElementEscort_Objective, M_softPawn) == 0x000000, "Member 'FBFGQuest_ElementEscort_Objective::M_softPawn' has a wrong offset!");
static_assert(offsetof(FBFGQuest_ElementEscort_Objective, M_softPath) == 0x000028, "Member 'FBFGQuest_ElementEscort_Objective::M_softPath' has a wrong offset!");
static_assert(offsetof(FBFGQuest_ElementEscort_Objective, M_markerInfo) == 0x000050, "Member 'FBFGQuest_ElementEscort_Objective::M_markerInfo' has a wrong offset!");
static_assert(offsetof(FBFGQuest_ElementEscort_Objective, M_fMaxRange) == 0x000078, "Member 'FBFGQuest_ElementEscort_Objective::M_fMaxRange' has a wrong offset!");
static_assert(offsetof(FBFGQuest_ElementEscort_Objective, M_fMinRange) == 0x00007C, "Member 'FBFGQuest_ElementEscort_Objective::M_fMinRange' has a wrong offset!");
static_assert(offsetof(FBFGQuest_ElementEscort_Objective, M_bUseTrafficSystem) == 0x000080, "Member 'FBFGQuest_ElementEscort_Objective::M_bUseTrafficSystem' has a wrong offset!");
static_assert(offsetof(FBFGQuest_ElementEscort_Objective, M_eEnterExitTrafficSystemRule) == 0x000081, "Member 'FBFGQuest_ElementEscort_Objective::M_eEnterExitTrafficSystemRule' has a wrong offset!");
static_assert(offsetof(FBFGQuest_ElementEscort_Objective, M_bBehaviourStateLocked) == 0x000082, "Member 'FBFGQuest_ElementEscort_Objective::M_bBehaviourStateLocked' has a wrong offset!");
static_assert(offsetof(FBFGQuest_ElementEscort_Objective, M_eAgentPriority) == 0x000083, "Member 'FBFGQuest_ElementEscort_Objective::M_eAgentPriority' has a wrong offset!");
static_assert(offsetof(FBFGQuest_ElementEscort_Objective, M_bStopAtEnd) == 0x000084, "Member 'FBFGQuest_ElementEscort_Objective::M_bStopAtEnd' has a wrong offset!");
static_assert(offsetof(FBFGQuest_ElementEscort_Objective, M_fMaxSpeed) == 0x000088, "Member 'FBFGQuest_ElementEscort_Objective::M_fMaxSpeed' has a wrong offset!");
static_assert(offsetof(FBFGQuest_ElementEscort_Objective, M_bUsePatrolPathExtension) == 0x00008C, "Member 'FBFGQuest_ElementEscort_Objective::M_bUsePatrolPathExtension' has a wrong offset!");
static_assert(offsetof(FBFGQuest_ElementEscort_Objective, M_moveSpeed) == 0x00008D, "Member 'FBFGQuest_ElementEscort_Objective::M_moveSpeed' has a wrong offset!");

// ScriptStruct BFGCore.BFGMenuGameOptionCultureInfo
// 0x0028 (0x0028 - 0x0000)
struct FBFGMenuGameOptionCultureInfo final
{
public:
	class FString                                 M_strCultureName;                                  // 0x0000(0x0010)(BlueprintVisible, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FText                                   M_strCultureText;                                  // 0x0010(0x0018)(BlueprintVisible, NativeAccessSpecifierPublic)
};
static_assert(alignof(FBFGMenuGameOptionCultureInfo) == 0x000008, "Wrong alignment on FBFGMenuGameOptionCultureInfo");
static_assert(sizeof(FBFGMenuGameOptionCultureInfo) == 0x000028, "Wrong size on FBFGMenuGameOptionCultureInfo");
static_assert(offsetof(FBFGMenuGameOptionCultureInfo, M_strCultureName) == 0x000000, "Member 'FBFGMenuGameOptionCultureInfo::M_strCultureName' has a wrong offset!");
static_assert(offsetof(FBFGMenuGameOptionCultureInfo, M_strCultureText) == 0x000010, "Member 'FBFGMenuGameOptionCultureInfo::M_strCultureText' has a wrong offset!");

// ScriptStruct BFGCore.BFGMenuGameOptionSupportedResolutions
// 0x0010 (0x0010 - 0x0000)
struct alignas(0x08) FBFGMenuGameOptionSupportedResolutions final
{
public:
	uint8                                         Pad_0[0x10];                                       // 0x0000(0x0010)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FBFGMenuGameOptionSupportedResolutions) == 0x000008, "Wrong alignment on FBFGMenuGameOptionSupportedResolutions");
static_assert(sizeof(FBFGMenuGameOptionSupportedResolutions) == 0x000010, "Wrong size on FBFGMenuGameOptionSupportedResolutions");

// ScriptStruct BFGCore.BFGQuest_ElementLocateHint_LayerRuntime
// 0x0070 (0x0070 - 0x0000)
struct FBFGQuest_ElementLocateHint_LayerRuntime final
{
public:
	uint8                                         Pad_0[0x18];                                       // 0x0000(0x0018)(Fixing Size After Last Property [ Dumper-7 ])
	class UBFGVariable*                           M_pVariable;                                       // 0x0018(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UBFGVariable*                           M_pVariableScanCount;                              // 0x0020(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UBFGVariable*                           M_pVariableIsObjective;                            // 0x0028(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UBFGQuest_CortexScanObjectiveTracker*   M_pTracker;                                        // 0x0030(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UBFGQuest_Trigger*                      M_pAreaTrigger;                                    // 0x0038(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UBFGObjectiveMarkerGroup*               M_pObjectiveGroup;                                 // 0x0040(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FBFGQuestOverrides                     M_overrides;                                       // 0x0048(0x0028)(NativeAccessSpecifierPublic)
};
static_assert(alignof(FBFGQuest_ElementLocateHint_LayerRuntime) == 0x000008, "Wrong alignment on FBFGQuest_ElementLocateHint_LayerRuntime");
static_assert(sizeof(FBFGQuest_ElementLocateHint_LayerRuntime) == 0x000070, "Wrong size on FBFGQuest_ElementLocateHint_LayerRuntime");
static_assert(offsetof(FBFGQuest_ElementLocateHint_LayerRuntime, M_pVariable) == 0x000018, "Member 'FBFGQuest_ElementLocateHint_LayerRuntime::M_pVariable' has a wrong offset!");
static_assert(offsetof(FBFGQuest_ElementLocateHint_LayerRuntime, M_pVariableScanCount) == 0x000020, "Member 'FBFGQuest_ElementLocateHint_LayerRuntime::M_pVariableScanCount' has a wrong offset!");
static_assert(offsetof(FBFGQuest_ElementLocateHint_LayerRuntime, M_pVariableIsObjective) == 0x000028, "Member 'FBFGQuest_ElementLocateHint_LayerRuntime::M_pVariableIsObjective' has a wrong offset!");
static_assert(offsetof(FBFGQuest_ElementLocateHint_LayerRuntime, M_pTracker) == 0x000030, "Member 'FBFGQuest_ElementLocateHint_LayerRuntime::M_pTracker' has a wrong offset!");
static_assert(offsetof(FBFGQuest_ElementLocateHint_LayerRuntime, M_pAreaTrigger) == 0x000038, "Member 'FBFGQuest_ElementLocateHint_LayerRuntime::M_pAreaTrigger' has a wrong offset!");
static_assert(offsetof(FBFGQuest_ElementLocateHint_LayerRuntime, M_pObjectiveGroup) == 0x000040, "Member 'FBFGQuest_ElementLocateHint_LayerRuntime::M_pObjectiveGroup' has a wrong offset!");
static_assert(offsetof(FBFGQuest_ElementLocateHint_LayerRuntime, M_overrides) == 0x000048, "Member 'FBFGQuest_ElementLocateHint_LayerRuntime::M_overrides' has a wrong offset!");

// ScriptStruct BFGCore.BFGMenuGameOptionFloatProps
// 0x0010 (0x0010 - 0x0000)
struct FBFGMenuGameOptionFloatProps final
{
public:
	EBFGMenuGameOptions                           M_eOptionID;                                       // 0x0000(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          M_bDisplayAsPercent;                               // 0x0001(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2[0x2];                                        // 0x0002(0x0002)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         M_fMinValue;                                       // 0x0004(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         M_fMaxValue;                                       // 0x0008(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         M_fInterval;                                       // 0x000C(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FBFGMenuGameOptionFloatProps) == 0x000004, "Wrong alignment on FBFGMenuGameOptionFloatProps");
static_assert(sizeof(FBFGMenuGameOptionFloatProps) == 0x000010, "Wrong size on FBFGMenuGameOptionFloatProps");
static_assert(offsetof(FBFGMenuGameOptionFloatProps, M_eOptionID) == 0x000000, "Member 'FBFGMenuGameOptionFloatProps::M_eOptionID' has a wrong offset!");
static_assert(offsetof(FBFGMenuGameOptionFloatProps, M_bDisplayAsPercent) == 0x000001, "Member 'FBFGMenuGameOptionFloatProps::M_bDisplayAsPercent' has a wrong offset!");
static_assert(offsetof(FBFGMenuGameOptionFloatProps, M_fMinValue) == 0x000004, "Member 'FBFGMenuGameOptionFloatProps::M_fMinValue' has a wrong offset!");
static_assert(offsetof(FBFGMenuGameOptionFloatProps, M_fMaxValue) == 0x000008, "Member 'FBFGMenuGameOptionFloatProps::M_fMaxValue' has a wrong offset!");
static_assert(offsetof(FBFGMenuGameOptionFloatProps, M_fInterval) == 0x00000C, "Member 'FBFGMenuGameOptionFloatProps::M_fInterval' has a wrong offset!");

// ScriptStruct BFGCore.BFGObject_StaticWithPhysics_SpawnParams
// 0x0002 (0x0002 - 0x0000)
struct FBFGObject_StaticWithPhysics_SpawnParams final
{
public:
	bool                                          M_bIsPKAllowed;                                    // 0x0000(0x0001)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          M_bRemoveAsSoonAsPossible;                         // 0x0001(0x0001)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FBFGObject_StaticWithPhysics_SpawnParams) == 0x000001, "Wrong alignment on FBFGObject_StaticWithPhysics_SpawnParams");
static_assert(sizeof(FBFGObject_StaticWithPhysics_SpawnParams) == 0x000002, "Wrong size on FBFGObject_StaticWithPhysics_SpawnParams");
static_assert(offsetof(FBFGObject_StaticWithPhysics_SpawnParams, M_bIsPKAllowed) == 0x000000, "Member 'FBFGObject_StaticWithPhysics_SpawnParams::M_bIsPKAllowed' has a wrong offset!");
static_assert(offsetof(FBFGObject_StaticWithPhysics_SpawnParams, M_bRemoveAsSoonAsPossible) == 0x000001, "Member 'FBFGObject_StaticWithPhysics_SpawnParams::M_bRemoveAsSoonAsPossible' has a wrong offset!");

// ScriptStruct BFGCore.BFGGameFlowStateLayout
// 0x02D0 (0x02D0 - 0x0000)
struct FBFGGameFlowStateLayout final
{
public:
	TSoftClassPtr<class UClass>                   M_pState_BumperVideo;                              // 0x0000(0x0028)(Edit, BlueprintVisible, BlueprintReadOnly, Config, DisableEditOnInstance, GlobalConfig, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TSoftClassPtr<class UClass>                   M_pState_Gamestart;                                // 0x0028(0x0028)(Edit, BlueprintVisible, BlueprintReadOnly, Config, DisableEditOnInstance, GlobalConfig, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TSoftClassPtr<class UClass>                   M_pState_MainMenu;                                 // 0x0050(0x0028)(Edit, BlueprintVisible, BlueprintReadOnly, Config, DisableEditOnInstance, GlobalConfig, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TSoftClassPtr<class UClass>                   M_pState_MainMenu_PublicDemo;                      // 0x0078(0x0028)(Edit, BlueprintVisible, BlueprintReadOnly, Config, DisableEditOnInstance, GlobalConfig, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TSoftClassPtr<class UClass>                   M_pState_Mothership;                               // 0x00A0(0x0028)(Edit, BlueprintVisible, BlueprintReadOnly, Config, DisableEditOnInstance, GlobalConfig, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TSoftClassPtr<class UClass>                   M_pState_Gameplay;                                 // 0x00C8(0x0028)(Edit, BlueprintVisible, BlueprintReadOnly, Config, DisableEditOnInstance, GlobalConfig, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TSoftClassPtr<class UClass>                   M_pState_Cutscene;                                 // 0x00F0(0x0028)(Edit, BlueprintVisible, BlueprintReadOnly, Config, DisableEditOnInstance, GlobalConfig, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TSoftClassPtr<class UClass>                   M_pState_MissionResults;                           // 0x0118(0x0028)(Edit, BlueprintVisible, BlueprintReadOnly, Config, DisableEditOnInstance, GlobalConfig, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TSoftClassPtr<class UClass>                   M_pState_ChallengeResults;                         // 0x0140(0x0028)(Edit, BlueprintVisible, BlueprintReadOnly, Config, DisableEditOnInstance, GlobalConfig, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TSoftClassPtr<class UClass>                   M_pState_Newspaper;                                // 0x0168(0x0028)(Edit, BlueprintVisible, BlueprintReadOnly, Config, DisableEditOnInstance, GlobalConfig, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TSoftClassPtr<class UClass>                   M_pFuronHandbookState;                             // 0x0190(0x0028)(Edit, DisableEditOnInstance, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TSoftClassPtr<class UClass>                   M_pControllerDisconnectedState;                    // 0x01B8(0x0028)(Edit, DisableEditOnInstance, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TSoftClassPtr<class UClass>                   M_pUserSignedOut;                                  // 0x01E0(0x0028)(Edit, DisableEditOnInstance, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TSoftClassPtr<class UClass>                   M_pMessageBox;                                     // 0x0208(0x0028)(Edit, DisableEditOnInstance, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TSoftClassPtr<class UClass>                   M_pChunkInstall;                                   // 0x0230(0x0028)(Edit, DisableEditOnInstance, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TSoftClassPtr<class UClass>                   M_pRestartMissionForLoadGame;                      // 0x0258(0x0028)(Edit, DisableEditOnInstance, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TSoftClassPtr<class UClass>                   M_pConfirmUpgradePrompt;                           // 0x0280(0x0028)(Edit, DisableEditOnInstance, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TSoftClassPtr<class UClass>                   M_pTimedConfirmPrompt;                             // 0x02A8(0x0028)(Edit, DisableEditOnInstance, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FBFGGameFlowStateLayout) == 0x000008, "Wrong alignment on FBFGGameFlowStateLayout");
static_assert(sizeof(FBFGGameFlowStateLayout) == 0x0002D0, "Wrong size on FBFGGameFlowStateLayout");
static_assert(offsetof(FBFGGameFlowStateLayout, M_pState_BumperVideo) == 0x000000, "Member 'FBFGGameFlowStateLayout::M_pState_BumperVideo' has a wrong offset!");
static_assert(offsetof(FBFGGameFlowStateLayout, M_pState_Gamestart) == 0x000028, "Member 'FBFGGameFlowStateLayout::M_pState_Gamestart' has a wrong offset!");
static_assert(offsetof(FBFGGameFlowStateLayout, M_pState_MainMenu) == 0x000050, "Member 'FBFGGameFlowStateLayout::M_pState_MainMenu' has a wrong offset!");
static_assert(offsetof(FBFGGameFlowStateLayout, M_pState_MainMenu_PublicDemo) == 0x000078, "Member 'FBFGGameFlowStateLayout::M_pState_MainMenu_PublicDemo' has a wrong offset!");
static_assert(offsetof(FBFGGameFlowStateLayout, M_pState_Mothership) == 0x0000A0, "Member 'FBFGGameFlowStateLayout::M_pState_Mothership' has a wrong offset!");
static_assert(offsetof(FBFGGameFlowStateLayout, M_pState_Gameplay) == 0x0000C8, "Member 'FBFGGameFlowStateLayout::M_pState_Gameplay' has a wrong offset!");
static_assert(offsetof(FBFGGameFlowStateLayout, M_pState_Cutscene) == 0x0000F0, "Member 'FBFGGameFlowStateLayout::M_pState_Cutscene' has a wrong offset!");
static_assert(offsetof(FBFGGameFlowStateLayout, M_pState_MissionResults) == 0x000118, "Member 'FBFGGameFlowStateLayout::M_pState_MissionResults' has a wrong offset!");
static_assert(offsetof(FBFGGameFlowStateLayout, M_pState_ChallengeResults) == 0x000140, "Member 'FBFGGameFlowStateLayout::M_pState_ChallengeResults' has a wrong offset!");
static_assert(offsetof(FBFGGameFlowStateLayout, M_pState_Newspaper) == 0x000168, "Member 'FBFGGameFlowStateLayout::M_pState_Newspaper' has a wrong offset!");
static_assert(offsetof(FBFGGameFlowStateLayout, M_pFuronHandbookState) == 0x000190, "Member 'FBFGGameFlowStateLayout::M_pFuronHandbookState' has a wrong offset!");
static_assert(offsetof(FBFGGameFlowStateLayout, M_pControllerDisconnectedState) == 0x0001B8, "Member 'FBFGGameFlowStateLayout::M_pControllerDisconnectedState' has a wrong offset!");
static_assert(offsetof(FBFGGameFlowStateLayout, M_pUserSignedOut) == 0x0001E0, "Member 'FBFGGameFlowStateLayout::M_pUserSignedOut' has a wrong offset!");
static_assert(offsetof(FBFGGameFlowStateLayout, M_pMessageBox) == 0x000208, "Member 'FBFGGameFlowStateLayout::M_pMessageBox' has a wrong offset!");
static_assert(offsetof(FBFGGameFlowStateLayout, M_pChunkInstall) == 0x000230, "Member 'FBFGGameFlowStateLayout::M_pChunkInstall' has a wrong offset!");
static_assert(offsetof(FBFGGameFlowStateLayout, M_pRestartMissionForLoadGame) == 0x000258, "Member 'FBFGGameFlowStateLayout::M_pRestartMissionForLoadGame' has a wrong offset!");
static_assert(offsetof(FBFGGameFlowStateLayout, M_pConfirmUpgradePrompt) == 0x000280, "Member 'FBFGGameFlowStateLayout::M_pConfirmUpgradePrompt' has a wrong offset!");
static_assert(offsetof(FBFGGameFlowStateLayout, M_pTimedConfirmPrompt) == 0x0002A8, "Member 'FBFGGameFlowStateLayout::M_pTimedConfirmPrompt' has a wrong offset!");

// ScriptStruct BFGCore.BFGGameFlowStateInfo
// 0x0010 (0x0010 - 0x0000)
struct FBFGGameFlowStateInfo final
{
public:
	class UBFGGameFlowState*                      M_pTargetState;                                    // 0x0000(0x0008)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          M_bKeepTopState;                                   // 0x0008(0x0001)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_9[0x7];                                        // 0x0009(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FBFGGameFlowStateInfo) == 0x000008, "Wrong alignment on FBFGGameFlowStateInfo");
static_assert(sizeof(FBFGGameFlowStateInfo) == 0x000010, "Wrong size on FBFGGameFlowStateInfo");
static_assert(offsetof(FBFGGameFlowStateInfo, M_pTargetState) == 0x000000, "Member 'FBFGGameFlowStateInfo::M_pTargetState' has a wrong offset!");
static_assert(offsetof(FBFGGameFlowStateInfo, M_bKeepTopState) == 0x000008, "Member 'FBFGGameFlowStateInfo::M_bKeepTopState' has a wrong offset!");

// ScriptStruct BFGCore.BFGGameplayEndSettings
// 0x0050 (0x0050 - 0x0000)
struct FBFGGameplayEndSettings final
{
public:
	TSoftObjectPtr<class ULevelSequence>          M_softLevelSequence;                               // 0x0000(0x0028)(Edit, BlueprintVisible, BlueprintReadOnly, Config, DisableEditOnInstance, GlobalConfig, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TSoftClassPtr<class UClass>                   M_softBackgroundBlur;                              // 0x0028(0x0028)(Edit, BlueprintVisible, BlueprintReadOnly, Config, DisableEditOnInstance, GlobalConfig, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FBFGGameplayEndSettings) == 0x000008, "Wrong alignment on FBFGGameplayEndSettings");
static_assert(sizeof(FBFGGameplayEndSettings) == 0x000050, "Wrong size on FBFGGameplayEndSettings");
static_assert(offsetof(FBFGGameplayEndSettings, M_softLevelSequence) == 0x000000, "Member 'FBFGGameplayEndSettings::M_softLevelSequence' has a wrong offset!");
static_assert(offsetof(FBFGGameplayEndSettings, M_softBackgroundBlur) == 0x000028, "Member 'FBFGGameplayEndSettings::M_softBackgroundBlur' has a wrong offset!");

// ScriptStruct BFGCore.BFGHeightAlongPathData
// 0x0020 (0x0020 - 0x0000)
struct FBFGHeightAlongPathData final
{
public:
	bool                                          M_bIsValid;                                        // 0x0000(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_1[0x3];                                        // 0x0001(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         M_fStepLength;                                     // 0x0004(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         M_fLength;                                         // 0x0008(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_C[0x4];                                        // 0x000C(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<float>                                 M_afHeights;                                       // 0x0010(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, EditConst, Protected, NativeAccessSpecifierProtected)
};
static_assert(alignof(FBFGHeightAlongPathData) == 0x000008, "Wrong alignment on FBFGHeightAlongPathData");
static_assert(sizeof(FBFGHeightAlongPathData) == 0x000020, "Wrong size on FBFGHeightAlongPathData");
static_assert(offsetof(FBFGHeightAlongPathData, M_bIsValid) == 0x000000, "Member 'FBFGHeightAlongPathData::M_bIsValid' has a wrong offset!");
static_assert(offsetof(FBFGHeightAlongPathData, M_fStepLength) == 0x000004, "Member 'FBFGHeightAlongPathData::M_fStepLength' has a wrong offset!");
static_assert(offsetof(FBFGHeightAlongPathData, M_fLength) == 0x000008, "Member 'FBFGHeightAlongPathData::M_fLength' has a wrong offset!");
static_assert(offsetof(FBFGHeightAlongPathData, M_afHeights) == 0x000010, "Member 'FBFGHeightAlongPathData::M_afHeights' has a wrong offset!");

// ScriptStruct BFGCore.BFGVectorDamper
// 0x0020 (0x0020 - 0x0000)
struct FBFGVectorDamper final
{
public:
	float                                         M_fSmoothTime;                                     // 0x0000(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         M_fMaxSpeed;                                       // 0x0004(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_8[0x18];                                       // 0x0008(0x0018)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FBFGVectorDamper) == 0x000004, "Wrong alignment on FBFGVectorDamper");
static_assert(sizeof(FBFGVectorDamper) == 0x000020, "Wrong size on FBFGVectorDamper");
static_assert(offsetof(FBFGVectorDamper, M_fSmoothTime) == 0x000000, "Member 'FBFGVectorDamper::M_fSmoothTime' has a wrong offset!");
static_assert(offsetof(FBFGVectorDamper, M_fMaxSpeed) == 0x000004, "Member 'FBFGVectorDamper::M_fMaxSpeed' has a wrong offset!");

// ScriptStruct BFGCore.TickHighlightableSceneObjectFunction
// 0x0008 (0x0078 - 0x0070)
struct FTickHighlightableSceneObjectFunction final : public FTickFunction
{
public:
	class UBFGHighlightableSceneObjectManager*    M_pManager;                                        // 0x0070(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FTickHighlightableSceneObjectFunction) == 0x000008, "Wrong alignment on FTickHighlightableSceneObjectFunction");
static_assert(sizeof(FTickHighlightableSceneObjectFunction) == 0x000078, "Wrong size on FTickHighlightableSceneObjectFunction");
static_assert(offsetof(FTickHighlightableSceneObjectFunction, M_pManager) == 0x000070, "Member 'FTickHighlightableSceneObjectFunction::M_pManager' has a wrong offset!");

// ScriptStruct BFGCore.BFGDebugLineHUDData
// 0x0014 (0x0014 - 0x0000)
struct alignas(0x04) FBFGDebugLineHUDData final
{
public:
	uint8                                         Pad_0[0x14];                                       // 0x0000(0x0014)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FBFGDebugLineHUDData) == 0x000004, "Wrong alignment on FBFGDebugLineHUDData");
static_assert(sizeof(FBFGDebugLineHUDData) == 0x000014, "Wrong size on FBFGDebugLineHUDData");

// ScriptStruct BFGCore.BFGInputAxisKeyMapping
// 0x0020 (0x0048 - 0x0028)
struct FBFGInputAxisKeyMapping final : public FInputAxisKeyMapping
{
public:
	struct FKey                                   M_oKeySecondary;                                   // 0x0028(0x0018)(Edit, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EBFGInputRebindIdentifier                     M_eRebindIdentifier;                               // 0x0040(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_41[0x7];                                       // 0x0041(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FBFGInputAxisKeyMapping) == 0x000008, "Wrong alignment on FBFGInputAxisKeyMapping");
static_assert(sizeof(FBFGInputAxisKeyMapping) == 0x000048, "Wrong size on FBFGInputAxisKeyMapping");
static_assert(offsetof(FBFGInputAxisKeyMapping, M_oKeySecondary) == 0x000028, "Member 'FBFGInputAxisKeyMapping::M_oKeySecondary' has a wrong offset!");
static_assert(offsetof(FBFGInputAxisKeyMapping, M_eRebindIdentifier) == 0x000040, "Member 'FBFGInputAxisKeyMapping::M_eRebindIdentifier' has a wrong offset!");

// ScriptStruct BFGCore.BFGInputAxisMap
// 0x0058 (0x0058 - 0x0000)
struct FBFGInputAxisMap final
{
public:
	TArray<struct FBFGInputAxisKeyMapping>        M_aAxisKeyMappings;                                // 0x0000(0x0010)(Edit, ZeroConstructor, NativeAccessSpecifierPublic)
	TSoftClassPtr<class UClass>                   M_pInputAxisClass;                                 // 0x0010(0x0028)(Edit, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EBFGInputLockGroups                           M_eLockGroup;                                      // 0x0038(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_39[0x7];                                       // 0x0039(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	class UBFGDataAsset_TutorialInputAction*      M_pInputActionInfo;                                // 0x0040(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   M_AxisName;                                        // 0x0048(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          M_bConsumeInput;                                   // 0x0050(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_51[0x7];                                       // 0x0051(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FBFGInputAxisMap) == 0x000008, "Wrong alignment on FBFGInputAxisMap");
static_assert(sizeof(FBFGInputAxisMap) == 0x000058, "Wrong size on FBFGInputAxisMap");
static_assert(offsetof(FBFGInputAxisMap, M_aAxisKeyMappings) == 0x000000, "Member 'FBFGInputAxisMap::M_aAxisKeyMappings' has a wrong offset!");
static_assert(offsetof(FBFGInputAxisMap, M_pInputAxisClass) == 0x000010, "Member 'FBFGInputAxisMap::M_pInputAxisClass' has a wrong offset!");
static_assert(offsetof(FBFGInputAxisMap, M_eLockGroup) == 0x000038, "Member 'FBFGInputAxisMap::M_eLockGroup' has a wrong offset!");
static_assert(offsetof(FBFGInputAxisMap, M_pInputActionInfo) == 0x000040, "Member 'FBFGInputAxisMap::M_pInputActionInfo' has a wrong offset!");
static_assert(offsetof(FBFGInputAxisMap, M_AxisName) == 0x000048, "Member 'FBFGInputAxisMap::M_AxisName' has a wrong offset!");
static_assert(offsetof(FBFGInputAxisMap, M_bConsumeInput) == 0x000050, "Member 'FBFGInputAxisMap::M_bConsumeInput' has a wrong offset!");

// ScriptStruct BFGCore.BFGInputPattern
// 0x0010 (0x0010 - 0x0000)
struct FBFGInputPattern final
{
public:
	TArray<struct FBFGInputPatternElement>        M_aInputPatternsElements;                          // 0x0000(0x0010)(Edit, ZeroConstructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(FBFGInputPattern) == 0x000008, "Wrong alignment on FBFGInputPattern");
static_assert(sizeof(FBFGInputPattern) == 0x000010, "Wrong size on FBFGInputPattern");
static_assert(offsetof(FBFGInputPattern, M_aInputPatternsElements) == 0x000000, "Member 'FBFGInputPattern::M_aInputPatternsElements' has a wrong offset!");

// ScriptStruct BFGCore.BFGInputActionMap
// 0x0058 (0x0058 - 0x0000)
struct FBFGInputActionMap final
{
public:
	TSoftClassPtr<class UClass>                   M_pInputActionClass;                               // 0x0000(0x0028)(Edit, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UBFGDataAsset_TutorialInputAction*      M_pInputActionInfo;                                // 0x0028(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TArray<class UBFGDataAsset_TutorialInputAction*> M_apAdditionalInputActionInfo;                     // 0x0030(0x0010)(Edit, ZeroConstructor, NativeAccessSpecifierPublic)
	EBFGInputLockGroups                           M_eLockGroup;                                      // 0x0040(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_41[0x7];                                       // 0x0041(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<struct FBFGInputPattern>               M_aInputPatterns;                                  // 0x0048(0x0010)(Edit, ZeroConstructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(FBFGInputActionMap) == 0x000008, "Wrong alignment on FBFGInputActionMap");
static_assert(sizeof(FBFGInputActionMap) == 0x000058, "Wrong size on FBFGInputActionMap");
static_assert(offsetof(FBFGInputActionMap, M_pInputActionClass) == 0x000000, "Member 'FBFGInputActionMap::M_pInputActionClass' has a wrong offset!");
static_assert(offsetof(FBFGInputActionMap, M_pInputActionInfo) == 0x000028, "Member 'FBFGInputActionMap::M_pInputActionInfo' has a wrong offset!");
static_assert(offsetof(FBFGInputActionMap, M_apAdditionalInputActionInfo) == 0x000030, "Member 'FBFGInputActionMap::M_apAdditionalInputActionInfo' has a wrong offset!");
static_assert(offsetof(FBFGInputActionMap, M_eLockGroup) == 0x000040, "Member 'FBFGInputActionMap::M_eLockGroup' has a wrong offset!");
static_assert(offsetof(FBFGInputActionMap, M_aInputPatterns) == 0x000048, "Member 'FBFGInputActionMap::M_aInputPatterns' has a wrong offset!");

// ScriptStruct BFGCore.BFGSequence_DynamicActorBinding
// 0x001C (0x001C - 0x0000)
struct FBFGSequence_DynamicActorBinding final
{
public:
	struct FMovieSceneObjectBindingID             M_sequenceBinding;                                 // 0x0000(0x0018)(Edit, BlueprintVisible, BlueprintReadOnly, DisableEditOnInstance, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          M_bBindPlayerCharacter;                            // 0x0018(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          M_bBindPlayerUFO;                                  // 0x0019(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          M_bBindSequencePivot;                              // 0x001A(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1B[0x1];                                       // 0x001B(0x0001)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FBFGSequence_DynamicActorBinding) == 0x000004, "Wrong alignment on FBFGSequence_DynamicActorBinding");
static_assert(sizeof(FBFGSequence_DynamicActorBinding) == 0x00001C, "Wrong size on FBFGSequence_DynamicActorBinding");
static_assert(offsetof(FBFGSequence_DynamicActorBinding, M_sequenceBinding) == 0x000000, "Member 'FBFGSequence_DynamicActorBinding::M_sequenceBinding' has a wrong offset!");
static_assert(offsetof(FBFGSequence_DynamicActorBinding, M_bBindPlayerCharacter) == 0x000018, "Member 'FBFGSequence_DynamicActorBinding::M_bBindPlayerCharacter' has a wrong offset!");
static_assert(offsetof(FBFGSequence_DynamicActorBinding, M_bBindPlayerUFO) == 0x000019, "Member 'FBFGSequence_DynamicActorBinding::M_bBindPlayerUFO' has a wrong offset!");
static_assert(offsetof(FBFGSequence_DynamicActorBinding, M_bBindSequencePivot) == 0x00001A, "Member 'FBFGSequence_DynamicActorBinding::M_bBindSequencePivot' has a wrong offset!");

// ScriptStruct BFGCore.BFGInputSchemeArray
// 0x0010 (0x0010 - 0x0000)
struct FBFGInputSchemeArray final
{
public:
	TArray<TSoftObjectPtr<class UBFGInputScheme>> M_apSchemes;                                       // 0x0000(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, UObjectWrapper, NativeAccessSpecifierPublic)
};
static_assert(alignof(FBFGInputSchemeArray) == 0x000008, "Wrong alignment on FBFGInputSchemeArray");
static_assert(sizeof(FBFGInputSchemeArray) == 0x000010, "Wrong size on FBFGInputSchemeArray");
static_assert(offsetof(FBFGInputSchemeArray, M_apSchemes) == 0x000000, "Member 'FBFGInputSchemeArray::M_apSchemes' has a wrong offset!");

// ScriptStruct BFGCore.BFGInteractableHelper
// 0x00B0 (0x00B0 - 0x0000)
struct FBFGInteractableHelper final
{
public:
	TArray<struct FHitResult>                     M_aResults;                                        // 0x0000(0x0010)(ZeroConstructor, Transient, ContainsInstancedReference, Protected, NativeAccessSpecifierProtected)
	struct FHitResult                             M_bestHit;                                         // 0x0010(0x0088)(Transient, IsPlainOldData, NoDestructor, ContainsInstancedReference, Protected, NativeAccessSpecifierProtected)
	class AActor*                                 M_pHitActor;                                       // 0x0098(0x0008)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UActorComponent*                        M_pHitComponent;                                   // 0x00A0(0x0008)(ExportObject, ZeroConstructor, Transient, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UObject*                                M_pHitObject;                                      // 0x00A8(0x0008)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
};
static_assert(alignof(FBFGInteractableHelper) == 0x000008, "Wrong alignment on FBFGInteractableHelper");
static_assert(sizeof(FBFGInteractableHelper) == 0x0000B0, "Wrong size on FBFGInteractableHelper");
static_assert(offsetof(FBFGInteractableHelper, M_aResults) == 0x000000, "Member 'FBFGInteractableHelper::M_aResults' has a wrong offset!");
static_assert(offsetof(FBFGInteractableHelper, M_bestHit) == 0x000010, "Member 'FBFGInteractableHelper::M_bestHit' has a wrong offset!");
static_assert(offsetof(FBFGInteractableHelper, M_pHitActor) == 0x000098, "Member 'FBFGInteractableHelper::M_pHitActor' has a wrong offset!");
static_assert(offsetof(FBFGInteractableHelper, M_pHitComponent) == 0x0000A0, "Member 'FBFGInteractableHelper::M_pHitComponent' has a wrong offset!");
static_assert(offsetof(FBFGInteractableHelper, M_pHitObject) == 0x0000A8, "Member 'FBFGInteractableHelper::M_pHitObject' has a wrong offset!");

// ScriptStruct BFGCore.BFGInteractAnimationAssetData
// 0x0020 (0x0020 - 0x0000)
struct FBFGInteractAnimationAssetData final
{
public:
	uint8                                         Pad_0[0x8];                                        // 0x0000(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	class UAnimationAsset*                        M_pMainAnimationAsset;                             // 0x0008(0x0008)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TArray<class UAnimationAsset*>                M_aAnimationVariationsAssets;                      // 0x0010(0x0010)(ZeroConstructor, Transient, NativeAccessSpecifierPublic)
};
static_assert(alignof(FBFGInteractAnimationAssetData) == 0x000008, "Wrong alignment on FBFGInteractAnimationAssetData");
static_assert(sizeof(FBFGInteractAnimationAssetData) == 0x000020, "Wrong size on FBFGInteractAnimationAssetData");
static_assert(offsetof(FBFGInteractAnimationAssetData, M_pMainAnimationAsset) == 0x000008, "Member 'FBFGInteractAnimationAssetData::M_pMainAnimationAsset' has a wrong offset!");
static_assert(offsetof(FBFGInteractAnimationAssetData, M_aAnimationVariationsAssets) == 0x000010, "Member 'FBFGInteractAnimationAssetData::M_aAnimationVariationsAssets' has a wrong offset!");

// ScriptStruct BFGCore.BFGSubMissionResultInfo
// 0x0020 (0x0020 - 0x0000)
struct FBFGSubMissionResultInfo final
{
public:
	bool                                          M_bCompletion;                                     // 0x0000(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1[0x7];                                        // 0x0001(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	class FText                                   M_strCompletionQuest;                              // 0x0008(0x0018)(BlueprintVisible, BlueprintReadOnly, NativeAccessSpecifierPublic)
};
static_assert(alignof(FBFGSubMissionResultInfo) == 0x000008, "Wrong alignment on FBFGSubMissionResultInfo");
static_assert(sizeof(FBFGSubMissionResultInfo) == 0x000020, "Wrong size on FBFGSubMissionResultInfo");
static_assert(offsetof(FBFGSubMissionResultInfo, M_bCompletion) == 0x000000, "Member 'FBFGSubMissionResultInfo::M_bCompletion' has a wrong offset!");
static_assert(offsetof(FBFGSubMissionResultInfo, M_strCompletionQuest) == 0x000008, "Member 'FBFGSubMissionResultInfo::M_strCompletionQuest' has a wrong offset!");

// ScriptStruct BFGCore.BFGInteractAnimationRow
// 0x00C0 (0x00C8 - 0x0008)
struct FBFGInteractAnimationRow final : public FTableRowBase
{
public:
	EBFGAnimation_Interact                        M_eAnimation;                                      // 0x0008(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_9[0x7];                                        // 0x0009(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	TSoftObjectPtr<class UAnimationAsset>         M_pAnimation;                                      // 0x0010(0x0028)(Edit, BlueprintVisible, BlueprintReadOnly, DisableEditOnInstance, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TSoftObjectPtr<class UAnimationAsset>         M_pStartAnimation;                                 // 0x0038(0x0028)(Edit, BlueprintVisible, BlueprintReadOnly, DisableEditOnInstance, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TSoftObjectPtr<class UAnimationAsset>         M_pEndAnimation;                                   // 0x0060(0x0028)(Edit, BlueprintVisible, BlueprintReadOnly, DisableEditOnInstance, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TSoftObjectPtr<class UAnimationAsset>         M_pPanicEndAnimation;                              // 0x0088(0x0028)(Edit, BlueprintVisible, BlueprintReadOnly, DisableEditOnInstance, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TArray<TSoftObjectPtr<class UAnimationAsset>> M_aAnimationVariations;                            // 0x00B0(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, UObjectWrapper, NativeAccessSpecifierPublic)
	bool                                          M_bAllowAbortByPlayerBump;                         // 0x00C0(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_C1[0x7];                                       // 0x00C1(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FBFGInteractAnimationRow) == 0x000008, "Wrong alignment on FBFGInteractAnimationRow");
static_assert(sizeof(FBFGInteractAnimationRow) == 0x0000C8, "Wrong size on FBFGInteractAnimationRow");
static_assert(offsetof(FBFGInteractAnimationRow, M_eAnimation) == 0x000008, "Member 'FBFGInteractAnimationRow::M_eAnimation' has a wrong offset!");
static_assert(offsetof(FBFGInteractAnimationRow, M_pAnimation) == 0x000010, "Member 'FBFGInteractAnimationRow::M_pAnimation' has a wrong offset!");
static_assert(offsetof(FBFGInteractAnimationRow, M_pStartAnimation) == 0x000038, "Member 'FBFGInteractAnimationRow::M_pStartAnimation' has a wrong offset!");
static_assert(offsetof(FBFGInteractAnimationRow, M_pEndAnimation) == 0x000060, "Member 'FBFGInteractAnimationRow::M_pEndAnimation' has a wrong offset!");
static_assert(offsetof(FBFGInteractAnimationRow, M_pPanicEndAnimation) == 0x000088, "Member 'FBFGInteractAnimationRow::M_pPanicEndAnimation' has a wrong offset!");
static_assert(offsetof(FBFGInteractAnimationRow, M_aAnimationVariations) == 0x0000B0, "Member 'FBFGInteractAnimationRow::M_aAnimationVariations' has a wrong offset!");
static_assert(offsetof(FBFGInteractAnimationRow, M_bAllowAbortByPlayerBump) == 0x0000C0, "Member 'FBFGInteractAnimationRow::M_bAllowAbortByPlayerBump' has a wrong offset!");

// ScriptStruct BFGCore.BFGInterpolationAttachmentEntry
// 0x0018 (0x0018 - 0x0000)
struct alignas(0x08) FBFGInterpolationAttachmentEntry final
{
public:
	uint8                                         Pad_0[0x18];                                       // 0x0000(0x0018)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FBFGInterpolationAttachmentEntry) == 0x000008, "Wrong alignment on FBFGInterpolationAttachmentEntry");
static_assert(sizeof(FBFGInterpolationAttachmentEntry) == 0x000018, "Wrong size on FBFGInterpolationAttachmentEntry");

// ScriptStruct BFGCore.BFGInterpolationEntry
// 0x0070 (0x0070 - 0x0000)
struct alignas(0x10) FBFGInterpolationEntry final
{
public:
	class AActor*                                 M_pActor;                                          // 0x0000(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_8[0x68];                                       // 0x0008(0x0068)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FBFGInterpolationEntry) == 0x000010, "Wrong alignment on FBFGInterpolationEntry");
static_assert(sizeof(FBFGInterpolationEntry) == 0x000070, "Wrong size on FBFGInterpolationEntry");
static_assert(offsetof(FBFGInterpolationEntry, M_pActor) == 0x000000, "Member 'FBFGInterpolationEntry::M_pActor' has a wrong offset!");

// ScriptStruct BFGCore.BFGVehicleObstacleCorridor
// 0x0018 (0x0018 - 0x0000)
struct alignas(0x04) FBFGVehicleObstacleCorridor final
{
public:
	uint8                                         Pad_0[0x18];                                       // 0x0000(0x0018)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FBFGVehicleObstacleCorridor) == 0x000004, "Wrong alignment on FBFGVehicleObstacleCorridor");
static_assert(sizeof(FBFGVehicleObstacleCorridor) == 0x000018, "Wrong size on FBFGVehicleObstacleCorridor");

// ScriptStruct BFGCore.BFGAbilityHintInfo
// 0x00A8 (0x00A8 - 0x0000)
struct FBFGAbilityHintInfo final
{
public:
	struct FGameplayTag                           M_oGameplayTagAbility;                             // 0x0000(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FSlateBrush                            M_oBrushAbility;                                   // 0x0008(0x0088)(Edit, BlueprintVisible, BlueprintReadOnly, NativeAccessSpecifierPublic)
	class FText                                   M_oTextInputAction;                                // 0x0090(0x0018)(Edit, BlueprintVisible, BlueprintReadOnly, NativeAccessSpecifierPublic)
};
static_assert(alignof(FBFGAbilityHintInfo) == 0x000008, "Wrong alignment on FBFGAbilityHintInfo");
static_assert(sizeof(FBFGAbilityHintInfo) == 0x0000A8, "Wrong size on FBFGAbilityHintInfo");
static_assert(offsetof(FBFGAbilityHintInfo, M_oGameplayTagAbility) == 0x000000, "Member 'FBFGAbilityHintInfo::M_oGameplayTagAbility' has a wrong offset!");
static_assert(offsetof(FBFGAbilityHintInfo, M_oBrushAbility) == 0x000008, "Member 'FBFGAbilityHintInfo::M_oBrushAbility' has a wrong offset!");
static_assert(offsetof(FBFGAbilityHintInfo, M_oTextInputAction) == 0x000090, "Member 'FBFGAbilityHintInfo::M_oTextInputAction' has a wrong offset!");

// ScriptStruct BFGCore.BFGLine2
// 0x0010 (0x0010 - 0x0000)
struct alignas(0x04) FBFGLine2
{
public:
	uint8                                         Pad_0[0x10];                                       // 0x0000(0x0010)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FBFGLine2) == 0x000004, "Wrong alignment on FBFGLine2");
static_assert(sizeof(FBFGLine2) == 0x000010, "Wrong size on FBFGLine2");

// ScriptStruct BFGCore.BFGSystemData_VariableMirror
// 0x00F0 (0x00F0 - 0x0000)
struct FBFGSystemData_VariableMirror final
{
public:
	TMap<class FName, struct FGuid>               M_aRuntimeIds;                                     // 0x0000(0x0050)(ZeroConstructor, SaveGame, NativeAccessSpecifierPublic)
	TMap<struct FGuid, int32>                     M_aStateValues;                                    // 0x0050(0x0050)(ZeroConstructor, SaveGame, NativeAccessSpecifierPublic)
	TMap<class FName, float>                      M_aCustomDataValues;                               // 0x00A0(0x0050)(ZeroConstructor, SaveGame, NativeAccessSpecifierPublic)
};
static_assert(alignof(FBFGSystemData_VariableMirror) == 0x000008, "Wrong alignment on FBFGSystemData_VariableMirror");
static_assert(sizeof(FBFGSystemData_VariableMirror) == 0x0000F0, "Wrong size on FBFGSystemData_VariableMirror");
static_assert(offsetof(FBFGSystemData_VariableMirror, M_aRuntimeIds) == 0x000000, "Member 'FBFGSystemData_VariableMirror::M_aRuntimeIds' has a wrong offset!");
static_assert(offsetof(FBFGSystemData_VariableMirror, M_aStateValues) == 0x000050, "Member 'FBFGSystemData_VariableMirror::M_aStateValues' has a wrong offset!");
static_assert(offsetof(FBFGSystemData_VariableMirror, M_aCustomDataValues) == 0x0000A0, "Member 'FBFGSystemData_VariableMirror::M_aCustomDataValues' has a wrong offset!");

// ScriptStruct BFGCore.BFGLoadingScreenTextFontInfo
// 0x0040 (0x0040 - 0x0000)
struct FBFGLoadingScreenTextFontInfo final
{
public:
	TSoftObjectPtr<class UFont>                   M_spFont;                                          // 0x0000(0x0028)(Edit, BlueprintVisible, BlueprintReadOnly, DisableEditOnInstance, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FLinearColor                           M_FontColor;                                       // 0x0028(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         M_iFontSize;                                       // 0x0038(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_3C[0x4];                                       // 0x003C(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FBFGLoadingScreenTextFontInfo) == 0x000008, "Wrong alignment on FBFGLoadingScreenTextFontInfo");
static_assert(sizeof(FBFGLoadingScreenTextFontInfo) == 0x000040, "Wrong size on FBFGLoadingScreenTextFontInfo");
static_assert(offsetof(FBFGLoadingScreenTextFontInfo, M_spFont) == 0x000000, "Member 'FBFGLoadingScreenTextFontInfo::M_spFont' has a wrong offset!");
static_assert(offsetof(FBFGLoadingScreenTextFontInfo, M_FontColor) == 0x000028, "Member 'FBFGLoadingScreenTextFontInfo::M_FontColor' has a wrong offset!");
static_assert(offsetof(FBFGLoadingScreenTextFontInfo, M_iFontSize) == 0x000038, "Member 'FBFGLoadingScreenTextFontInfo::M_iFontSize' has a wrong offset!");

// ScriptStruct BFGCore.BFGQuest_ElementInteract_SpecialRuntimeChecks
// 0x0001 (0x0001 - 0x0000)
struct FBFGQuest_ElementInteract_SpecialRuntimeChecks final
{
public:
	bool                                          M_bActivateIfPlayerAlreadyInUFO;                   // 0x0000(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FBFGQuest_ElementInteract_SpecialRuntimeChecks) == 0x000001, "Wrong alignment on FBFGQuest_ElementInteract_SpecialRuntimeChecks");
static_assert(sizeof(FBFGQuest_ElementInteract_SpecialRuntimeChecks) == 0x000001, "Wrong size on FBFGQuest_ElementInteract_SpecialRuntimeChecks");
static_assert(offsetof(FBFGQuest_ElementInteract_SpecialRuntimeChecks, M_bActivateIfPlayerAlreadyInUFO) == 0x000000, "Member 'FBFGQuest_ElementInteract_SpecialRuntimeChecks::M_bActivateIfPlayerAlreadyInUFO' has a wrong offset!");

// ScriptStruct BFGCore.BFGQuest_ElementInteract_Objective
// 0x01C0 (0x01C0 - 0x0000)
struct FBFGQuest_ElementInteract_Objective final
{
public:
	struct FBFGActorBinding                       M_actorBinding;                                    // 0x0000(0x0090)(Edit, BlueprintVisible, BlueprintReadOnly, DisableEditOnInstance, NativeAccessSpecifierPublic)
	struct FBFGActorBinding                       M_actorBindingUser;                                // 0x0090(0x0090)(Edit, BlueprintVisible, BlueprintReadOnly, DisableEditOnInstance, NativeAccessSpecifierPublic)
	int32                                         M_iQuantity;                                       // 0x0120(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_124[0x4];                                      // 0x0124(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	struct FBFGQuest_UIProvider                   M_descriptionProvider;                             // 0x0128(0x0050)(Edit, BlueprintVisible, BlueprintReadOnly, DisableEditOnInstance, NativeAccessSpecifierPublic)
	struct FBFGObjectiveMarkerInfo                M_markerInfo;                                      // 0x0178(0x0028)(Edit, BlueprintVisible, BlueprintReadOnly, DisableEditOnInstance, ContainsInstancedReference, NativeAccessSpecifierPublic)
	bool                                          M_bIsUniqueObjectives;                             // 0x01A0(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1A1[0x7];                                      // 0x01A1(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<class UBFGEffectBank*>                 M_apEnableEffectBanks;                             // 0x01A8(0x0010)(Edit, ZeroConstructor, DisableEditOnInstance, NativeAccessSpecifierPublic)
	EBFGEffect_Identifier                         M_activateEffect;                                  // 0x01B8(0x0001)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FBFGQuest_ElementInteract_SpecialRuntimeChecks M_SpecialRuntimeChecks;                            // 0x01B9(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, DisableEditOnInstance, NoDestructor, NativeAccessSpecifierPublic)
	uint8                                         Pad_1BA[0x6];                                      // 0x01BA(0x0006)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FBFGQuest_ElementInteract_Objective) == 0x000008, "Wrong alignment on FBFGQuest_ElementInteract_Objective");
static_assert(sizeof(FBFGQuest_ElementInteract_Objective) == 0x0001C0, "Wrong size on FBFGQuest_ElementInteract_Objective");
static_assert(offsetof(FBFGQuest_ElementInteract_Objective, M_actorBinding) == 0x000000, "Member 'FBFGQuest_ElementInteract_Objective::M_actorBinding' has a wrong offset!");
static_assert(offsetof(FBFGQuest_ElementInteract_Objective, M_actorBindingUser) == 0x000090, "Member 'FBFGQuest_ElementInteract_Objective::M_actorBindingUser' has a wrong offset!");
static_assert(offsetof(FBFGQuest_ElementInteract_Objective, M_iQuantity) == 0x000120, "Member 'FBFGQuest_ElementInteract_Objective::M_iQuantity' has a wrong offset!");
static_assert(offsetof(FBFGQuest_ElementInteract_Objective, M_descriptionProvider) == 0x000128, "Member 'FBFGQuest_ElementInteract_Objective::M_descriptionProvider' has a wrong offset!");
static_assert(offsetof(FBFGQuest_ElementInteract_Objective, M_markerInfo) == 0x000178, "Member 'FBFGQuest_ElementInteract_Objective::M_markerInfo' has a wrong offset!");
static_assert(offsetof(FBFGQuest_ElementInteract_Objective, M_bIsUniqueObjectives) == 0x0001A0, "Member 'FBFGQuest_ElementInteract_Objective::M_bIsUniqueObjectives' has a wrong offset!");
static_assert(offsetof(FBFGQuest_ElementInteract_Objective, M_apEnableEffectBanks) == 0x0001A8, "Member 'FBFGQuest_ElementInteract_Objective::M_apEnableEffectBanks' has a wrong offset!");
static_assert(offsetof(FBFGQuest_ElementInteract_Objective, M_activateEffect) == 0x0001B8, "Member 'FBFGQuest_ElementInteract_Objective::M_activateEffect' has a wrong offset!");
static_assert(offsetof(FBFGQuest_ElementInteract_Objective, M_SpecialRuntimeChecks) == 0x0001B9, "Member 'FBFGQuest_ElementInteract_Objective::M_SpecialRuntimeChecks' has a wrong offset!");

// ScriptStruct BFGCore.ThrownActorInformation
// 0x0048 (0x0048 - 0x0000)
struct alignas(0x08) FThrownActorInformation final
{
public:
	uint8                                         Pad_0[0x48];                                       // 0x0000(0x0048)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FThrownActorInformation) == 0x000008, "Wrong alignment on FThrownActorInformation");
static_assert(sizeof(FThrownActorInformation) == 0x000048, "Wrong size on FThrownActorInformation");

// ScriptStruct BFGCore.BFG2DActorArrayInner
// 0x0010 (0x0010 - 0x0000)
struct FBFG2DActorArrayInner final
{
public:
	TArray<class AActor*>                         PActors;                                           // 0x0000(0x0010)(ZeroConstructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(FBFG2DActorArrayInner) == 0x000008, "Wrong alignment on FBFG2DActorArrayInner");
static_assert(sizeof(FBFG2DActorArrayInner) == 0x000010, "Wrong size on FBFG2DActorArrayInner");
static_assert(offsetof(FBFG2DActorArrayInner, PActors) == 0x000000, "Member 'FBFG2DActorArrayInner::PActors' has a wrong offset!");

// ScriptStruct BFGCore.BFGMissionCinematicActorSettings
// 0x0038 (0x0038 - 0x0000)
struct FBFGMissionCinematicActorSettings final
{
public:
	class AActor*                                 M_pActor;                                          // 0x0000(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_8[0x8];                                        // 0x0008(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<class UPrimitiveComponent*>            M_apComponetsToEnablePhysicsAgain;                 // 0x0010(0x0010)(ExportObject, ZeroConstructor, ContainsInstancedReference, NativeAccessSpecifierPublic)
	TArray<class AActor*>                         M_apTouchedChildActors;                            // 0x0020(0x0010)(ZeroConstructor, NativeAccessSpecifierPublic)
	class UBFGNetworkPathAgent_AttachedEntity*    M_pAttachedEntity;                                 // 0x0030(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FBFGMissionCinematicActorSettings) == 0x000008, "Wrong alignment on FBFGMissionCinematicActorSettings");
static_assert(sizeof(FBFGMissionCinematicActorSettings) == 0x000038, "Wrong size on FBFGMissionCinematicActorSettings");
static_assert(offsetof(FBFGMissionCinematicActorSettings, M_pActor) == 0x000000, "Member 'FBFGMissionCinematicActorSettings::M_pActor' has a wrong offset!");
static_assert(offsetof(FBFGMissionCinematicActorSettings, M_apComponetsToEnablePhysicsAgain) == 0x000010, "Member 'FBFGMissionCinematicActorSettings::M_apComponetsToEnablePhysicsAgain' has a wrong offset!");
static_assert(offsetof(FBFGMissionCinematicActorSettings, M_apTouchedChildActors) == 0x000020, "Member 'FBFGMissionCinematicActorSettings::M_apTouchedChildActors' has a wrong offset!");
static_assert(offsetof(FBFGMissionCinematicActorSettings, M_pAttachedEntity) == 0x000030, "Member 'FBFGMissionCinematicActorSettings::M_pAttachedEntity' has a wrong offset!");

// ScriptStruct BFGCore.BFGVehicleVariationEntry
// 0x03E0 (0x03E0 - 0x0000)
struct FBFGVehicleVariationEntry final
{
public:
	class FName                                   M_name;                                            // 0x0000(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FBFGWheeledVehicleConfig               M_InputConfig;                                     // 0x0008(0x03B8)(NativeAccessSpecifierPublic)
	TArray<struct FBFGNPCVariationDefinitionRow>  M_Data;                                            // 0x03C0(0x0010)(ZeroConstructor, NativeAccessSpecifierPublic)
	TArray<class UMaterialInstanceDynamic*>       M_apMaterialInstances;                             // 0x03D0(0x0010)(ZeroConstructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(FBFGVehicleVariationEntry) == 0x000008, "Wrong alignment on FBFGVehicleVariationEntry");
static_assert(sizeof(FBFGVehicleVariationEntry) == 0x0003E0, "Wrong size on FBFGVehicleVariationEntry");
static_assert(offsetof(FBFGVehicleVariationEntry, M_name) == 0x000000, "Member 'FBFGVehicleVariationEntry::M_name' has a wrong offset!");
static_assert(offsetof(FBFGVehicleVariationEntry, M_InputConfig) == 0x000008, "Member 'FBFGVehicleVariationEntry::M_InputConfig' has a wrong offset!");
static_assert(offsetof(FBFGVehicleVariationEntry, M_Data) == 0x0003C0, "Member 'FBFGVehicleVariationEntry::M_Data' has a wrong offset!");
static_assert(offsetof(FBFGVehicleVariationEntry, M_apMaterialInstances) == 0x0003D0, "Member 'FBFGVehicleVariationEntry::M_apMaterialInstances' has a wrong offset!");

// ScriptStruct BFGCore.BFGQuest_ElementVandalize_Actor
// 0x01B0 (0x01B0 - 0x0000)
struct FBFGQuest_ElementVandalize_Actor final
{
public:
	struct FBFGActorBinding                       M_actorBinding;                                    // 0x0000(0x0090)(Edit, BlueprintVisible, BlueprintReadOnly, DisableEditOnInstance, NativeAccessSpecifierPublic)
	struct FGameplayTagQuery                      M_damageCauserTagQuery;                            // 0x0090(0x0048)(Edit, BlueprintVisible, BlueprintReadOnly, DisableEditOnInstance, NativeAccessSpecifierPublic)
	struct FGameplayTagQuery                      M_damageInstigatorTagQuery;                        // 0x00D8(0x0048)(Edit, BlueprintVisible, BlueprintReadOnly, DisableEditOnInstance, NativeAccessSpecifierPublic)
	struct FGameplayTagQuery                      M_damageSourceTagQuery;                            // 0x0120(0x0048)(Edit, BlueprintVisible, BlueprintReadOnly, DisableEditOnInstance, NativeAccessSpecifierPublic)
	float                                         M_fMultiplier;                                     // 0x0168(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_16C[0x4];                                      // 0x016C(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	struct FBFGObjectiveMarkerInfo                M_markerInfo;                                      // 0x0170(0x0028)(Edit, BlueprintVisible, BlueprintReadOnly, DisableEditOnInstance, ContainsInstancedReference, NativeAccessSpecifierPublic)
	TArray<class UBFGEffectBank*>                 M_apEnableEffectBanks;                             // 0x0198(0x0010)(Edit, ZeroConstructor, DisableEditOnInstance, NativeAccessSpecifierPublic)
	EBFGEffect_Identifier                         M_activateEffect;                                  // 0x01A8(0x0001)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1A9[0x7];                                      // 0x01A9(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FBFGQuest_ElementVandalize_Actor) == 0x000008, "Wrong alignment on FBFGQuest_ElementVandalize_Actor");
static_assert(sizeof(FBFGQuest_ElementVandalize_Actor) == 0x0001B0, "Wrong size on FBFGQuest_ElementVandalize_Actor");
static_assert(offsetof(FBFGQuest_ElementVandalize_Actor, M_actorBinding) == 0x000000, "Member 'FBFGQuest_ElementVandalize_Actor::M_actorBinding' has a wrong offset!");
static_assert(offsetof(FBFGQuest_ElementVandalize_Actor, M_damageCauserTagQuery) == 0x000090, "Member 'FBFGQuest_ElementVandalize_Actor::M_damageCauserTagQuery' has a wrong offset!");
static_assert(offsetof(FBFGQuest_ElementVandalize_Actor, M_damageInstigatorTagQuery) == 0x0000D8, "Member 'FBFGQuest_ElementVandalize_Actor::M_damageInstigatorTagQuery' has a wrong offset!");
static_assert(offsetof(FBFGQuest_ElementVandalize_Actor, M_damageSourceTagQuery) == 0x000120, "Member 'FBFGQuest_ElementVandalize_Actor::M_damageSourceTagQuery' has a wrong offset!");
static_assert(offsetof(FBFGQuest_ElementVandalize_Actor, M_fMultiplier) == 0x000168, "Member 'FBFGQuest_ElementVandalize_Actor::M_fMultiplier' has a wrong offset!");
static_assert(offsetof(FBFGQuest_ElementVandalize_Actor, M_markerInfo) == 0x000170, "Member 'FBFGQuest_ElementVandalize_Actor::M_markerInfo' has a wrong offset!");
static_assert(offsetof(FBFGQuest_ElementVandalize_Actor, M_apEnableEffectBanks) == 0x000198, "Member 'FBFGQuest_ElementVandalize_Actor::M_apEnableEffectBanks' has a wrong offset!");
static_assert(offsetof(FBFGQuest_ElementVandalize_Actor, M_activateEffect) == 0x0001A8, "Member 'FBFGQuest_ElementVandalize_Actor::M_activateEffect' has a wrong offset!");

// ScriptStruct BFGCore.BFGNetworkPathRenderHelper
// 0x0080 (0x0080 - 0x0000)
struct FBFGNetworkPathRenderHelper final
{
public:
	TWeakObjectPtr<class UBFGNetworkPathComponent> M_pComponent;                                      // 0x0000(0x0008)(ExportObject, ZeroConstructor, Transient, InstancedReference, IsPlainOldData, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	struct FInterpCurveVector                     M_leftCurve;                                       // 0x0008(0x0018)(ZeroConstructor, Transient, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	struct FInterpCurveVector                     M_rightCurve;                                      // 0x0020(0x0018)(ZeroConstructor, Transient, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	struct FInterpCurveVector                     M_centerCurve;                                     // 0x0038(0x0018)(ZeroConstructor, Transient, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TArray<struct FVector>                        M_avLeftPositions;                                 // 0x0050(0x0010)(ZeroConstructor, Transient, Protected, NativeAccessSpecifierProtected)
	TArray<struct FVector>                        M_avRightPositions;                                // 0x0060(0x0010)(ZeroConstructor, Transient, Protected, NativeAccessSpecifierProtected)
	TArray<float>                                 M_afTurnsAngle;                                    // 0x0070(0x0010)(ZeroConstructor, Transient, Protected, NativeAccessSpecifierProtected)
};
static_assert(alignof(FBFGNetworkPathRenderHelper) == 0x000008, "Wrong alignment on FBFGNetworkPathRenderHelper");
static_assert(sizeof(FBFGNetworkPathRenderHelper) == 0x000080, "Wrong size on FBFGNetworkPathRenderHelper");
static_assert(offsetof(FBFGNetworkPathRenderHelper, M_pComponent) == 0x000000, "Member 'FBFGNetworkPathRenderHelper::M_pComponent' has a wrong offset!");
static_assert(offsetof(FBFGNetworkPathRenderHelper, M_leftCurve) == 0x000008, "Member 'FBFGNetworkPathRenderHelper::M_leftCurve' has a wrong offset!");
static_assert(offsetof(FBFGNetworkPathRenderHelper, M_rightCurve) == 0x000020, "Member 'FBFGNetworkPathRenderHelper::M_rightCurve' has a wrong offset!");
static_assert(offsetof(FBFGNetworkPathRenderHelper, M_centerCurve) == 0x000038, "Member 'FBFGNetworkPathRenderHelper::M_centerCurve' has a wrong offset!");
static_assert(offsetof(FBFGNetworkPathRenderHelper, M_avLeftPositions) == 0x000050, "Member 'FBFGNetworkPathRenderHelper::M_avLeftPositions' has a wrong offset!");
static_assert(offsetof(FBFGNetworkPathRenderHelper, M_avRightPositions) == 0x000060, "Member 'FBFGNetworkPathRenderHelper::M_avRightPositions' has a wrong offset!");
static_assert(offsetof(FBFGNetworkPathRenderHelper, M_afTurnsAngle) == 0x000070, "Member 'FBFGNetworkPathRenderHelper::M_afTurnsAngle' has a wrong offset!");

// ScriptStruct BFGCore.BFGMissionConsequence_Context
// 0x0010 (0x0010 - 0x0000)
struct FBFGMissionConsequence_Context final
{
public:
	class AActor*                                 M_pSourceActor;                                    // 0x0000(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class AActor*                                 M_pTargetActor;                                    // 0x0008(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FBFGMissionConsequence_Context) == 0x000008, "Wrong alignment on FBFGMissionConsequence_Context");
static_assert(sizeof(FBFGMissionConsequence_Context) == 0x000010, "Wrong size on FBFGMissionConsequence_Context");
static_assert(offsetof(FBFGMissionConsequence_Context, M_pSourceActor) == 0x000000, "Member 'FBFGMissionConsequence_Context::M_pSourceActor' has a wrong offset!");
static_assert(offsetof(FBFGMissionConsequence_Context, M_pTargetActor) == 0x000008, "Member 'FBFGMissionConsequence_Context::M_pTargetActor' has a wrong offset!");

// ScriptStruct BFGCore.BFGMissionCustomTriggerZone_Status
// 0x0010 (0x0010 - 0x0000)
struct FBFGMissionCustomTriggerZone_Status final
{
public:
	class ABFGMissionCustomTriggerZone*           M_pTrigger;                                        // 0x0000(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_8[0x8];                                        // 0x0008(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FBFGMissionCustomTriggerZone_Status) == 0x000008, "Wrong alignment on FBFGMissionCustomTriggerZone_Status");
static_assert(sizeof(FBFGMissionCustomTriggerZone_Status) == 0x000010, "Wrong size on FBFGMissionCustomTriggerZone_Status");
static_assert(offsetof(FBFGMissionCustomTriggerZone_Status, M_pTrigger) == 0x000000, "Member 'FBFGMissionCustomTriggerZone_Status::M_pTrigger' has a wrong offset!");

// ScriptStruct BFGCore.BFGMissionCustomTriggerZone_StatusCollection
// 0x0010 (0x0010 - 0x0000)
struct FBFGMissionCustomTriggerZone_StatusCollection final
{
public:
	TArray<struct FBFGMissionCustomTriggerZone_Status> M_aStatus;                                         // 0x0000(0x0010)(ZeroConstructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(FBFGMissionCustomTriggerZone_StatusCollection) == 0x000008, "Wrong alignment on FBFGMissionCustomTriggerZone_StatusCollection");
static_assert(sizeof(FBFGMissionCustomTriggerZone_StatusCollection) == 0x000010, "Wrong size on FBFGMissionCustomTriggerZone_StatusCollection");
static_assert(offsetof(FBFGMissionCustomTriggerZone_StatusCollection, M_aStatus) == 0x000000, "Member 'FBFGMissionCustomTriggerZone_StatusCollection::M_aStatus' has a wrong offset!");

// ScriptStruct BFGCore.BFGMissionWorldLayout
// 0x0150 (0x0150 - 0x0000)
struct FBFGMissionWorldLayout final
{
public:
	TSoftObjectPtr<class UWorld>                  M_softWorld;                                       // 0x0000(0x0028)(Edit, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FText                                   M_strWorldName;                                    // 0x0028(0x0018)(Edit, NativeAccessSpecifierPublic)
	class FName                                   M_oWorldIdentifier;                                // 0x0040(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EBFGMissionLayout_WorldType                   M_type;                                            // 0x0048(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_49[0x7];                                       // 0x0049(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<TSoftObjectPtr<class UBFGMissionGroup>> M_aSoftMissions;                                   // 0x0050(0x0010)(Edit, ZeroConstructor, UObjectWrapper, NativeAccessSpecifierPublic)
	TSoftObjectPtr<class UBFGLoadingScreenInfo>   M_spLoadingscreenInfo;                             // 0x0060(0x0028)(Edit, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TSoftObjectPtr<class UBFGDataAsset_WorldDefaultSelectionInfo> M_pWorldDefaultSelectionInfo;                      // 0x0088(0x0028)(Edit, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TArray<TSoftObjectPtr<class UBFGEnvironment>> M_aSoftWorldEnvironments;                          // 0x00B0(0x0010)(Edit, ZeroConstructor, UObjectWrapper, NativeAccessSpecifierPublic)
	int32                                         M_iTotalNumOfDrones;                               // 0x00C0(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_C4[0x4];                                       // 0x00C4(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	TSoftObjectPtr<class UBFGDataAsset_NewspaperInfo> M_softNewspaper_DeathOnFoot;                       // 0x00C8(0x0028)(Edit, Config, DisableEditOnInstance, GlobalConfig, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TSoftObjectPtr<class UBFGDataAsset_NewspaperInfo> M_softNewspaper_DeathInSaucer;                     // 0x00F0(0x0028)(Edit, Config, DisableEditOnInstance, GlobalConfig, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TSoftObjectPtr<class UBFGDataAsset_NewspaperInfo> M_softNewspaper_DeathWater;                        // 0x0118(0x0028)(Edit, Config, DisableEditOnInstance, GlobalConfig, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         M_iStreamingPool_PS4;                              // 0x0140(0x0004)(Edit, ZeroConstructor, Config, DisableEditOnInstance, GlobalConfig, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         M_iStreamingPool_Xbox;                             // 0x0144(0x0004)(Edit, ZeroConstructor, Config, DisableEditOnInstance, GlobalConfig, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         M_iChunkIndexForPlayGo;                            // 0x0148(0x0004)(Edit, ZeroConstructor, Config, DisableEditOnInstance, GlobalConfig, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_14C[0x4];                                      // 0x014C(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FBFGMissionWorldLayout) == 0x000008, "Wrong alignment on FBFGMissionWorldLayout");
static_assert(sizeof(FBFGMissionWorldLayout) == 0x000150, "Wrong size on FBFGMissionWorldLayout");
static_assert(offsetof(FBFGMissionWorldLayout, M_softWorld) == 0x000000, "Member 'FBFGMissionWorldLayout::M_softWorld' has a wrong offset!");
static_assert(offsetof(FBFGMissionWorldLayout, M_strWorldName) == 0x000028, "Member 'FBFGMissionWorldLayout::M_strWorldName' has a wrong offset!");
static_assert(offsetof(FBFGMissionWorldLayout, M_oWorldIdentifier) == 0x000040, "Member 'FBFGMissionWorldLayout::M_oWorldIdentifier' has a wrong offset!");
static_assert(offsetof(FBFGMissionWorldLayout, M_type) == 0x000048, "Member 'FBFGMissionWorldLayout::M_type' has a wrong offset!");
static_assert(offsetof(FBFGMissionWorldLayout, M_aSoftMissions) == 0x000050, "Member 'FBFGMissionWorldLayout::M_aSoftMissions' has a wrong offset!");
static_assert(offsetof(FBFGMissionWorldLayout, M_spLoadingscreenInfo) == 0x000060, "Member 'FBFGMissionWorldLayout::M_spLoadingscreenInfo' has a wrong offset!");
static_assert(offsetof(FBFGMissionWorldLayout, M_pWorldDefaultSelectionInfo) == 0x000088, "Member 'FBFGMissionWorldLayout::M_pWorldDefaultSelectionInfo' has a wrong offset!");
static_assert(offsetof(FBFGMissionWorldLayout, M_aSoftWorldEnvironments) == 0x0000B0, "Member 'FBFGMissionWorldLayout::M_aSoftWorldEnvironments' has a wrong offset!");
static_assert(offsetof(FBFGMissionWorldLayout, M_iTotalNumOfDrones) == 0x0000C0, "Member 'FBFGMissionWorldLayout::M_iTotalNumOfDrones' has a wrong offset!");
static_assert(offsetof(FBFGMissionWorldLayout, M_softNewspaper_DeathOnFoot) == 0x0000C8, "Member 'FBFGMissionWorldLayout::M_softNewspaper_DeathOnFoot' has a wrong offset!");
static_assert(offsetof(FBFGMissionWorldLayout, M_softNewspaper_DeathInSaucer) == 0x0000F0, "Member 'FBFGMissionWorldLayout::M_softNewspaper_DeathInSaucer' has a wrong offset!");
static_assert(offsetof(FBFGMissionWorldLayout, M_softNewspaper_DeathWater) == 0x000118, "Member 'FBFGMissionWorldLayout::M_softNewspaper_DeathWater' has a wrong offset!");
static_assert(offsetof(FBFGMissionWorldLayout, M_iStreamingPool_PS4) == 0x000140, "Member 'FBFGMissionWorldLayout::M_iStreamingPool_PS4' has a wrong offset!");
static_assert(offsetof(FBFGMissionWorldLayout, M_iStreamingPool_Xbox) == 0x000144, "Member 'FBFGMissionWorldLayout::M_iStreamingPool_Xbox' has a wrong offset!");
static_assert(offsetof(FBFGMissionWorldLayout, M_iChunkIndexForPlayGo) == 0x000148, "Member 'FBFGMissionWorldLayout::M_iChunkIndexForPlayGo' has a wrong offset!");

// ScriptStruct BFGCore.BFGMissionLayout
// 0x0038 (0x0038 - 0x0000)
struct FBFGMissionLayout final
{
public:
	TSoftObjectPtr<class UWorld>                  M_softNewGameMap;                                  // 0x0000(0x0028)(Edit, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TArray<struct FBFGMissionWorldLayout>         M_aWorlds;                                         // 0x0028(0x0010)(Edit, ZeroConstructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(FBFGMissionLayout) == 0x000008, "Wrong alignment on FBFGMissionLayout");
static_assert(sizeof(FBFGMissionLayout) == 0x000038, "Wrong size on FBFGMissionLayout");
static_assert(offsetof(FBFGMissionLayout, M_softNewGameMap) == 0x000000, "Member 'FBFGMissionLayout::M_softNewGameMap' has a wrong offset!");
static_assert(offsetof(FBFGMissionLayout, M_aWorlds) == 0x000028, "Member 'FBFGMissionLayout::M_aWorlds' has a wrong offset!");

// ScriptStruct BFGCore.BFGMissionSpawnManager_Enemies
// 0x0148 (0x0148 - 0x0000)
struct FBFGMissionSpawnManager_Enemies final
{
public:
	TSoftObjectPtr<class UBFGMissionSpawnRequestAsset> M_spSpawnData;                                     // 0x0000(0x0028)(Edit, BlueprintVisible, BlueprintReadOnly, DisableEditOnTemplate, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UBFGMissionSpawnRequestAsset*           M_pSpawnDataAsset;                                 // 0x0028(0x0008)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FBFGInteractAnimationSequence          M_animationSequence;                               // 0x0030(0x0018)(Edit, BlueprintVisible, BlueprintReadOnly, EditConst, NativeAccessSpecifierPublic)
	TSubclassOf<class AActor>                     M_pClass;                                          // 0x0048(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnTemplate, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         M_iAmount;                                         // 0x0050(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnTemplate, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_54[0x4];                                       // 0x0054(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	TSoftObjectPtr<class AActor>                  M_pMissionTargetActor;                             // 0x0058(0x0028)(Edit, BlueprintVisible, BlueprintReadOnly, EditConst, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EBFGMissionTargetAction_NPC                   M_eMissionTargetAction;                            // 0x0080(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          M_bForceTargetEvenIfNotInPerceptionRange;          // 0x0081(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          M_bJoinTrafficSystem;                              // 0x0082(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          M_bLockAlertMode;                                  // 0x0083(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnTemplate, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EBFGNPCCharacter_MoveSpeed                    M_moveSpeed;                                       // 0x0084(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          M_bDeprecatedMode;                                 // 0x0085(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnTemplate, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_86[0x2];                                       // 0x0086(0x0002)(Fixing Size After Last Property [ Dumper-7 ])
	struct FBFGAgentAIData                        M_agentAIData;                                     // 0x0088(0x00B0)(Edit, BlueprintVisible, BlueprintReadOnly, DisableEditOnTemplate, ContainsInstancedReference, NativeAccessSpecifierPublic)
	bool                                          M_bLODEnabled;                                     // 0x0138(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnTemplate, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          M_bDespawnOnDeath;                                 // 0x0139(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnTemplate, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          M_bStayAttachedToLevel;                            // 0x013A(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnTemplate, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_13B[0x1];                                      // 0x013B(0x0001)(Fixing Size After Last Property [ Dumper-7 ])
	class FName                                   M_strEnemyIdentifier;                              // 0x013C(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnTemplate, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          M_bAdjustSpawnPosition;                            // 0x0144(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnTemplate, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_145[0x3];                                      // 0x0145(0x0003)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FBFGMissionSpawnManager_Enemies) == 0x000008, "Wrong alignment on FBFGMissionSpawnManager_Enemies");
static_assert(sizeof(FBFGMissionSpawnManager_Enemies) == 0x000148, "Wrong size on FBFGMissionSpawnManager_Enemies");
static_assert(offsetof(FBFGMissionSpawnManager_Enemies, M_spSpawnData) == 0x000000, "Member 'FBFGMissionSpawnManager_Enemies::M_spSpawnData' has a wrong offset!");
static_assert(offsetof(FBFGMissionSpawnManager_Enemies, M_pSpawnDataAsset) == 0x000028, "Member 'FBFGMissionSpawnManager_Enemies::M_pSpawnDataAsset' has a wrong offset!");
static_assert(offsetof(FBFGMissionSpawnManager_Enemies, M_animationSequence) == 0x000030, "Member 'FBFGMissionSpawnManager_Enemies::M_animationSequence' has a wrong offset!");
static_assert(offsetof(FBFGMissionSpawnManager_Enemies, M_pClass) == 0x000048, "Member 'FBFGMissionSpawnManager_Enemies::M_pClass' has a wrong offset!");
static_assert(offsetof(FBFGMissionSpawnManager_Enemies, M_iAmount) == 0x000050, "Member 'FBFGMissionSpawnManager_Enemies::M_iAmount' has a wrong offset!");
static_assert(offsetof(FBFGMissionSpawnManager_Enemies, M_pMissionTargetActor) == 0x000058, "Member 'FBFGMissionSpawnManager_Enemies::M_pMissionTargetActor' has a wrong offset!");
static_assert(offsetof(FBFGMissionSpawnManager_Enemies, M_eMissionTargetAction) == 0x000080, "Member 'FBFGMissionSpawnManager_Enemies::M_eMissionTargetAction' has a wrong offset!");
static_assert(offsetof(FBFGMissionSpawnManager_Enemies, M_bForceTargetEvenIfNotInPerceptionRange) == 0x000081, "Member 'FBFGMissionSpawnManager_Enemies::M_bForceTargetEvenIfNotInPerceptionRange' has a wrong offset!");
static_assert(offsetof(FBFGMissionSpawnManager_Enemies, M_bJoinTrafficSystem) == 0x000082, "Member 'FBFGMissionSpawnManager_Enemies::M_bJoinTrafficSystem' has a wrong offset!");
static_assert(offsetof(FBFGMissionSpawnManager_Enemies, M_bLockAlertMode) == 0x000083, "Member 'FBFGMissionSpawnManager_Enemies::M_bLockAlertMode' has a wrong offset!");
static_assert(offsetof(FBFGMissionSpawnManager_Enemies, M_moveSpeed) == 0x000084, "Member 'FBFGMissionSpawnManager_Enemies::M_moveSpeed' has a wrong offset!");
static_assert(offsetof(FBFGMissionSpawnManager_Enemies, M_bDeprecatedMode) == 0x000085, "Member 'FBFGMissionSpawnManager_Enemies::M_bDeprecatedMode' has a wrong offset!");
static_assert(offsetof(FBFGMissionSpawnManager_Enemies, M_agentAIData) == 0x000088, "Member 'FBFGMissionSpawnManager_Enemies::M_agentAIData' has a wrong offset!");
static_assert(offsetof(FBFGMissionSpawnManager_Enemies, M_bLODEnabled) == 0x000138, "Member 'FBFGMissionSpawnManager_Enemies::M_bLODEnabled' has a wrong offset!");
static_assert(offsetof(FBFGMissionSpawnManager_Enemies, M_bDespawnOnDeath) == 0x000139, "Member 'FBFGMissionSpawnManager_Enemies::M_bDespawnOnDeath' has a wrong offset!");
static_assert(offsetof(FBFGMissionSpawnManager_Enemies, M_bStayAttachedToLevel) == 0x00013A, "Member 'FBFGMissionSpawnManager_Enemies::M_bStayAttachedToLevel' has a wrong offset!");
static_assert(offsetof(FBFGMissionSpawnManager_Enemies, M_strEnemyIdentifier) == 0x00013C, "Member 'FBFGMissionSpawnManager_Enemies::M_strEnemyIdentifier' has a wrong offset!");
static_assert(offsetof(FBFGMissionSpawnManager_Enemies, M_bAdjustSpawnPosition) == 0x000144, "Member 'FBFGMissionSpawnManager_Enemies::M_bAdjustSpawnPosition' has a wrong offset!");

// ScriptStruct BFGCore.BFGMissionSpawnManager_Wave
// 0x0038 (0x0038 - 0x0000)
struct FBFGMissionSpawnManager_Wave final
{
public:
	TArray<TSoftObjectPtr<class ABFGMissionSpawnerGroup>> M_aSpawnerGroups;                                  // 0x0000(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnTemplate, UObjectWrapper, NativeAccessSpecifierPublic)
	TArray<struct FBFGMissionSpawnManager_Enemies> M_aEnemies;                                        // 0x0010(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnTemplate, ContainsInstancedReference, NativeAccessSpecifierPublic)
	float                                         M_fInitialDelay;                                   // 0x0020(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnTemplate, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         M_fDelay;                                          // 0x0024(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnTemplate, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         M_iAliveLimit;                                     // 0x0028(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnTemplate, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         M_iDuration;                                       // 0x002C(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnTemplate, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         M_iAlivePercentage;                                // 0x0030(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnTemplate, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_34[0x4];                                       // 0x0034(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FBFGMissionSpawnManager_Wave) == 0x000008, "Wrong alignment on FBFGMissionSpawnManager_Wave");
static_assert(sizeof(FBFGMissionSpawnManager_Wave) == 0x000038, "Wrong size on FBFGMissionSpawnManager_Wave");
static_assert(offsetof(FBFGMissionSpawnManager_Wave, M_aSpawnerGroups) == 0x000000, "Member 'FBFGMissionSpawnManager_Wave::M_aSpawnerGroups' has a wrong offset!");
static_assert(offsetof(FBFGMissionSpawnManager_Wave, M_aEnemies) == 0x000010, "Member 'FBFGMissionSpawnManager_Wave::M_aEnemies' has a wrong offset!");
static_assert(offsetof(FBFGMissionSpawnManager_Wave, M_fInitialDelay) == 0x000020, "Member 'FBFGMissionSpawnManager_Wave::M_fInitialDelay' has a wrong offset!");
static_assert(offsetof(FBFGMissionSpawnManager_Wave, M_fDelay) == 0x000024, "Member 'FBFGMissionSpawnManager_Wave::M_fDelay' has a wrong offset!");
static_assert(offsetof(FBFGMissionSpawnManager_Wave, M_iAliveLimit) == 0x000028, "Member 'FBFGMissionSpawnManager_Wave::M_iAliveLimit' has a wrong offset!");
static_assert(offsetof(FBFGMissionSpawnManager_Wave, M_iDuration) == 0x00002C, "Member 'FBFGMissionSpawnManager_Wave::M_iDuration' has a wrong offset!");
static_assert(offsetof(FBFGMissionSpawnManager_Wave, M_iAlivePercentage) == 0x000030, "Member 'FBFGMissionSpawnManager_Wave::M_iAlivePercentage' has a wrong offset!");

// ScriptStruct BFGCore.BFGNarrativeSequence_LogContext
// 0x0030 (0x0030 - 0x0000)
struct FBFGNarrativeSequence_LogContext final
{
public:
	TArray<class UBFGNarrativeSequenceNode*>      M_apDone;                                          // 0x0000(0x0010)(ExportObject, ZeroConstructor, Transient, ContainsInstancedReference, NativeAccessSpecifierPublic)
	TArray<class UBFGNarrativeSequenceNode*>      M_apRoots;                                         // 0x0010(0x0010)(ExportObject, ZeroConstructor, Transient, ContainsInstancedReference, NativeAccessSpecifierPrivate)
	TArray<class UBFGNarrativeSequenceNode*>      M_apEnds;                                          // 0x0020(0x0010)(ExportObject, ZeroConstructor, Transient, ContainsInstancedReference, NativeAccessSpecifierPrivate)
};
static_assert(alignof(FBFGNarrativeSequence_LogContext) == 0x000008, "Wrong alignment on FBFGNarrativeSequence_LogContext");
static_assert(sizeof(FBFGNarrativeSequence_LogContext) == 0x000030, "Wrong size on FBFGNarrativeSequence_LogContext");
static_assert(offsetof(FBFGNarrativeSequence_LogContext, M_apDone) == 0x000000, "Member 'FBFGNarrativeSequence_LogContext::M_apDone' has a wrong offset!");
static_assert(offsetof(FBFGNarrativeSequence_LogContext, M_apRoots) == 0x000010, "Member 'FBFGNarrativeSequence_LogContext::M_apRoots' has a wrong offset!");
static_assert(offsetof(FBFGNarrativeSequence_LogContext, M_apEnds) == 0x000020, "Member 'FBFGNarrativeSequence_LogContext::M_apEnds' has a wrong offset!");

// ScriptStruct BFGCore.BFGNetworkPathEventReport
// 0x001C (0x001C - 0x0000)
struct FBFGNetworkPathEventReport final
{
public:
	struct FVector                                M_vLocation;                                       // 0x0000(0x000C)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                M_vTargetLocation;                                 // 0x000C(0x000C)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EBFGNetworkPathEventReportType                M_eventType;                                       // 0x0018(0x0001)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_19[0x3];                                       // 0x0019(0x0003)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FBFGNetworkPathEventReport) == 0x000004, "Wrong alignment on FBFGNetworkPathEventReport");
static_assert(sizeof(FBFGNetworkPathEventReport) == 0x00001C, "Wrong size on FBFGNetworkPathEventReport");
static_assert(offsetof(FBFGNetworkPathEventReport, M_vLocation) == 0x000000, "Member 'FBFGNetworkPathEventReport::M_vLocation' has a wrong offset!");
static_assert(offsetof(FBFGNetworkPathEventReport, M_vTargetLocation) == 0x00000C, "Member 'FBFGNetworkPathEventReport::M_vTargetLocation' has a wrong offset!");
static_assert(offsetof(FBFGNetworkPathEventReport, M_eventType) == 0x000018, "Member 'FBFGNetworkPathEventReport::M_eventType' has a wrong offset!");

// ScriptStruct BFGCore.BFGNetworkPathAgentBlending
// 0x0054 (0x0054 - 0x0000)
struct FBFGNetworkPathAgentBlending final
{
public:
	struct FVector                                M_vCurrentLocation;                                // 0x0000(0x000C)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FRotator                               M_vCurrentOrientation;                             // 0x000C(0x000C)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
	struct FVector                                M_vFromLocation;                                   // 0x0018(0x000C)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FRotator                               M_vFromOrientation;                                // 0x0024(0x000C)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
	struct FVector                                M_vToLocation;                                     // 0x0030(0x000C)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FRotator                               M_vToOrientation;                                  // 0x003C(0x000C)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
	float                                         M_fDuration;                                       // 0x0048(0x0004)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         M_fTime;                                           // 0x004C(0x0004)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          M_bIsActive;                                       // 0x0050(0x0001)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_51[0x3];                                       // 0x0051(0x0003)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FBFGNetworkPathAgentBlending) == 0x000004, "Wrong alignment on FBFGNetworkPathAgentBlending");
static_assert(sizeof(FBFGNetworkPathAgentBlending) == 0x000054, "Wrong size on FBFGNetworkPathAgentBlending");
static_assert(offsetof(FBFGNetworkPathAgentBlending, M_vCurrentLocation) == 0x000000, "Member 'FBFGNetworkPathAgentBlending::M_vCurrentLocation' has a wrong offset!");
static_assert(offsetof(FBFGNetworkPathAgentBlending, M_vCurrentOrientation) == 0x00000C, "Member 'FBFGNetworkPathAgentBlending::M_vCurrentOrientation' has a wrong offset!");
static_assert(offsetof(FBFGNetworkPathAgentBlending, M_vFromLocation) == 0x000018, "Member 'FBFGNetworkPathAgentBlending::M_vFromLocation' has a wrong offset!");
static_assert(offsetof(FBFGNetworkPathAgentBlending, M_vFromOrientation) == 0x000024, "Member 'FBFGNetworkPathAgentBlending::M_vFromOrientation' has a wrong offset!");
static_assert(offsetof(FBFGNetworkPathAgentBlending, M_vToLocation) == 0x000030, "Member 'FBFGNetworkPathAgentBlending::M_vToLocation' has a wrong offset!");
static_assert(offsetof(FBFGNetworkPathAgentBlending, M_vToOrientation) == 0x00003C, "Member 'FBFGNetworkPathAgentBlending::M_vToOrientation' has a wrong offset!");
static_assert(offsetof(FBFGNetworkPathAgentBlending, M_fDuration) == 0x000048, "Member 'FBFGNetworkPathAgentBlending::M_fDuration' has a wrong offset!");
static_assert(offsetof(FBFGNetworkPathAgentBlending, M_fTime) == 0x00004C, "Member 'FBFGNetworkPathAgentBlending::M_fTime' has a wrong offset!");
static_assert(offsetof(FBFGNetworkPathAgentBlending, M_bIsActive) == 0x000050, "Member 'FBFGNetworkPathAgentBlending::M_bIsActive' has a wrong offset!");

// ScriptStruct BFGCore.BFGInFrontVehicleInfo
// 0x0030 (0x0030 - 0x0000)
struct FBFGInFrontVehicleInfo final
{
public:
	class UBFGNetworkPathAgent_Vehicle*           M_pAgent;                                          // 0x0000(0x0008)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UBFGNetworkPathAgent_Vehicle*           M_pInfrontVehicle;                                 // 0x0008(0x0008)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         M_fSpeed;                                          // 0x0010(0x0004)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         M_fRelativeDistance;                               // 0x0014(0x0004)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         M_fAdjustedRelativeDistance;                       // 0x0018(0x0004)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         M_fRecommendedSpeed;                               // 0x001C(0x0004)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         M_fRecommendedAcceleration;                        // 0x0020(0x0004)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         M_fRecommendedAccelerationDuration;                // 0x0024(0x0004)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         M_fComputedSecurityDistance;                       // 0x0028(0x0004)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          M_bCanBeOvertaken;                                 // 0x002C(0x0001)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2D[0x3];                                       // 0x002D(0x0003)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FBFGInFrontVehicleInfo) == 0x000008, "Wrong alignment on FBFGInFrontVehicleInfo");
static_assert(sizeof(FBFGInFrontVehicleInfo) == 0x000030, "Wrong size on FBFGInFrontVehicleInfo");
static_assert(offsetof(FBFGInFrontVehicleInfo, M_pAgent) == 0x000000, "Member 'FBFGInFrontVehicleInfo::M_pAgent' has a wrong offset!");
static_assert(offsetof(FBFGInFrontVehicleInfo, M_pInfrontVehicle) == 0x000008, "Member 'FBFGInFrontVehicleInfo::M_pInfrontVehicle' has a wrong offset!");
static_assert(offsetof(FBFGInFrontVehicleInfo, M_fSpeed) == 0x000010, "Member 'FBFGInFrontVehicleInfo::M_fSpeed' has a wrong offset!");
static_assert(offsetof(FBFGInFrontVehicleInfo, M_fRelativeDistance) == 0x000014, "Member 'FBFGInFrontVehicleInfo::M_fRelativeDistance' has a wrong offset!");
static_assert(offsetof(FBFGInFrontVehicleInfo, M_fAdjustedRelativeDistance) == 0x000018, "Member 'FBFGInFrontVehicleInfo::M_fAdjustedRelativeDistance' has a wrong offset!");
static_assert(offsetof(FBFGInFrontVehicleInfo, M_fRecommendedSpeed) == 0x00001C, "Member 'FBFGInFrontVehicleInfo::M_fRecommendedSpeed' has a wrong offset!");
static_assert(offsetof(FBFGInFrontVehicleInfo, M_fRecommendedAcceleration) == 0x000020, "Member 'FBFGInFrontVehicleInfo::M_fRecommendedAcceleration' has a wrong offset!");
static_assert(offsetof(FBFGInFrontVehicleInfo, M_fRecommendedAccelerationDuration) == 0x000024, "Member 'FBFGInFrontVehicleInfo::M_fRecommendedAccelerationDuration' has a wrong offset!");
static_assert(offsetof(FBFGInFrontVehicleInfo, M_fComputedSecurityDistance) == 0x000028, "Member 'FBFGInFrontVehicleInfo::M_fComputedSecurityDistance' has a wrong offset!");
static_assert(offsetof(FBFGInFrontVehicleInfo, M_bCanBeOvertaken) == 0x00002C, "Member 'FBFGInFrontVehicleInfo::M_bCanBeOvertaken' has a wrong offset!");

// ScriptStruct BFGCore.BFGInFrontIntersectionInfo
// 0x0048 (0x0048 - 0x0000)
struct FBFGInFrontIntersectionInfo final
{
public:
	class UBFGNetworkPathIntersection*            M_pIntersection;                                   // 0x0000(0x0008)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         M_fIntersectionRelativeDistance;                   // 0x0008(0x0004)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          M_bIntersectionCrossingAllowed;                    // 0x000C(0x0001)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_D[0x3];                                        // 0x000D(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	class UBFGNetworkPathAgent*                   M_pIntersectionAgentInFront;                       // 0x0010(0x0008)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UBFGNetworkPath*                        M_pNextCrossWalk;                                  // 0x0018(0x0008)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         M_fNextCrossWalkRelativeDistance;                  // 0x0020(0x0004)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          M_bCrossWalksCrossingAllowed;                      // 0x0024(0x0001)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_25[0x3];                                       // 0x0025(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         M_fBlockingSpeed;                                  // 0x0028(0x0004)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         M_fMaxSpeed;                                       // 0x002C(0x0004)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         M_fDefaultBrakeAcceleration;                       // 0x0030(0x0004)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         M_fDefaultMarginDistance;                          // 0x0034(0x0004)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UBFGNetworkPathAgent*                   M_pAgent;                                          // 0x0038(0x0008)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          M_bHasForcedPriority;                              // 0x0040(0x0001)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_41[0x7];                                       // 0x0041(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FBFGInFrontIntersectionInfo) == 0x000008, "Wrong alignment on FBFGInFrontIntersectionInfo");
static_assert(sizeof(FBFGInFrontIntersectionInfo) == 0x000048, "Wrong size on FBFGInFrontIntersectionInfo");
static_assert(offsetof(FBFGInFrontIntersectionInfo, M_pIntersection) == 0x000000, "Member 'FBFGInFrontIntersectionInfo::M_pIntersection' has a wrong offset!");
static_assert(offsetof(FBFGInFrontIntersectionInfo, M_fIntersectionRelativeDistance) == 0x000008, "Member 'FBFGInFrontIntersectionInfo::M_fIntersectionRelativeDistance' has a wrong offset!");
static_assert(offsetof(FBFGInFrontIntersectionInfo, M_bIntersectionCrossingAllowed) == 0x00000C, "Member 'FBFGInFrontIntersectionInfo::M_bIntersectionCrossingAllowed' has a wrong offset!");
static_assert(offsetof(FBFGInFrontIntersectionInfo, M_pIntersectionAgentInFront) == 0x000010, "Member 'FBFGInFrontIntersectionInfo::M_pIntersectionAgentInFront' has a wrong offset!");
static_assert(offsetof(FBFGInFrontIntersectionInfo, M_pNextCrossWalk) == 0x000018, "Member 'FBFGInFrontIntersectionInfo::M_pNextCrossWalk' has a wrong offset!");
static_assert(offsetof(FBFGInFrontIntersectionInfo, M_fNextCrossWalkRelativeDistance) == 0x000020, "Member 'FBFGInFrontIntersectionInfo::M_fNextCrossWalkRelativeDistance' has a wrong offset!");
static_assert(offsetof(FBFGInFrontIntersectionInfo, M_bCrossWalksCrossingAllowed) == 0x000024, "Member 'FBFGInFrontIntersectionInfo::M_bCrossWalksCrossingAllowed' has a wrong offset!");
static_assert(offsetof(FBFGInFrontIntersectionInfo, M_fBlockingSpeed) == 0x000028, "Member 'FBFGInFrontIntersectionInfo::M_fBlockingSpeed' has a wrong offset!");
static_assert(offsetof(FBFGInFrontIntersectionInfo, M_fMaxSpeed) == 0x00002C, "Member 'FBFGInFrontIntersectionInfo::M_fMaxSpeed' has a wrong offset!");
static_assert(offsetof(FBFGInFrontIntersectionInfo, M_fDefaultBrakeAcceleration) == 0x000030, "Member 'FBFGInFrontIntersectionInfo::M_fDefaultBrakeAcceleration' has a wrong offset!");
static_assert(offsetof(FBFGInFrontIntersectionInfo, M_fDefaultMarginDistance) == 0x000034, "Member 'FBFGInFrontIntersectionInfo::M_fDefaultMarginDistance' has a wrong offset!");
static_assert(offsetof(FBFGInFrontIntersectionInfo, M_pAgent) == 0x000038, "Member 'FBFGInFrontIntersectionInfo::M_pAgent' has a wrong offset!");
static_assert(offsetof(FBFGInFrontIntersectionInfo, M_bHasForcedPriority) == 0x000040, "Member 'FBFGInFrontIntersectionInfo::M_bHasForcedPriority' has a wrong offset!");

// ScriptStruct BFGCore.BFGQuest_ElementMentalAbility_Overrides
// 0x00C8 (0x00C8 - 0x0000)
struct FBFGQuest_ElementMentalAbility_Overrides final
{
public:
	bool                                          M_bUseUniqueObjectives;                            // 0x0000(0x0001)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1[0x7];                                        // 0x0001(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	struct FBFGActorBinding                       M_actorBinding;                                    // 0x0008(0x0090)(Edit, DisableEditOnInstance, NativeAccessSpecifierPublic)
	TSoftObjectPtr<class UBFGDataAsset_CortexScan> M_softCortexScanData;                              // 0x0098(0x0028)(Edit, DisableEditOnInstance, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   M_strSharedLocate_OverrideName;                    // 0x00C0(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FBFGQuest_ElementMentalAbility_Overrides) == 0x000008, "Wrong alignment on FBFGQuest_ElementMentalAbility_Overrides");
static_assert(sizeof(FBFGQuest_ElementMentalAbility_Overrides) == 0x0000C8, "Wrong size on FBFGQuest_ElementMentalAbility_Overrides");
static_assert(offsetof(FBFGQuest_ElementMentalAbility_Overrides, M_bUseUniqueObjectives) == 0x000000, "Member 'FBFGQuest_ElementMentalAbility_Overrides::M_bUseUniqueObjectives' has a wrong offset!");
static_assert(offsetof(FBFGQuest_ElementMentalAbility_Overrides, M_actorBinding) == 0x000008, "Member 'FBFGQuest_ElementMentalAbility_Overrides::M_actorBinding' has a wrong offset!");
static_assert(offsetof(FBFGQuest_ElementMentalAbility_Overrides, M_softCortexScanData) == 0x000098, "Member 'FBFGQuest_ElementMentalAbility_Overrides::M_softCortexScanData' has a wrong offset!");
static_assert(offsetof(FBFGQuest_ElementMentalAbility_Overrides, M_strSharedLocate_OverrideName) == 0x0000C0, "Member 'FBFGQuest_ElementMentalAbility_Overrides::M_strSharedLocate_OverrideName' has a wrong offset!");

// ScriptStruct BFGCore.BFGVehicleDrivingState
// 0x0018 (0x0018 - 0x0000)
struct FBFGVehicleDrivingState final
{
public:
	EBFGVehicleDrivingMode                        M_eMode;                                           // 0x0000(0x0001)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EBFGBehaviourState_NPC                        M_eBehaviorState;                                  // 0x0001(0x0001)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          M_bIsInPanic;                                      // 0x0002(0x0001)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EBFGDriverNPCState                            M_eDriverNPCState;                                 // 0x0003(0x0001)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_4[0x4];                                        // 0x0004(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class UBFGNetworkPathAgent*                   M_pDriver;                                         // 0x0008(0x0008)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         M_fStopRelativeDistance;                           // 0x0010(0x0004)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EBFGVehicleStopState                          M_eStopState;                                      // 0x0014(0x0001)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EBFGAgentStopMode                             M_eStopMode;                                       // 0x0015(0x0001)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_16[0x2];                                       // 0x0016(0x0002)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FBFGVehicleDrivingState) == 0x000008, "Wrong alignment on FBFGVehicleDrivingState");
static_assert(sizeof(FBFGVehicleDrivingState) == 0x000018, "Wrong size on FBFGVehicleDrivingState");
static_assert(offsetof(FBFGVehicleDrivingState, M_eMode) == 0x000000, "Member 'FBFGVehicleDrivingState::M_eMode' has a wrong offset!");
static_assert(offsetof(FBFGVehicleDrivingState, M_eBehaviorState) == 0x000001, "Member 'FBFGVehicleDrivingState::M_eBehaviorState' has a wrong offset!");
static_assert(offsetof(FBFGVehicleDrivingState, M_bIsInPanic) == 0x000002, "Member 'FBFGVehicleDrivingState::M_bIsInPanic' has a wrong offset!");
static_assert(offsetof(FBFGVehicleDrivingState, M_eDriverNPCState) == 0x000003, "Member 'FBFGVehicleDrivingState::M_eDriverNPCState' has a wrong offset!");
static_assert(offsetof(FBFGVehicleDrivingState, M_pDriver) == 0x000008, "Member 'FBFGVehicleDrivingState::M_pDriver' has a wrong offset!");
static_assert(offsetof(FBFGVehicleDrivingState, M_fStopRelativeDistance) == 0x000010, "Member 'FBFGVehicleDrivingState::M_fStopRelativeDistance' has a wrong offset!");
static_assert(offsetof(FBFGVehicleDrivingState, M_eStopState) == 0x000014, "Member 'FBFGVehicleDrivingState::M_eStopState' has a wrong offset!");
static_assert(offsetof(FBFGVehicleDrivingState, M_eStopMode) == 0x000015, "Member 'FBFGVehicleDrivingState::M_eStopMode' has a wrong offset!");

// ScriptStruct BFGCore.BFGVehicleStop_Param
// 0x000C (0x000C - 0x0000)
struct FBFGVehicleStop_Param final
{
public:
	EBFGVehicleStopAggressivity                   M_eStopType;                                       // 0x0000(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1[0x3];                                        // 0x0001(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         M_fStopDistance;                                   // 0x0004(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EBFGAgentStopMode                             M_stopMode;                                        // 0x0008(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EBFGVehicleStop_PassengerRelease              M_passengerReleaseMode;                            // 0x0009(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_A[0x2];                                        // 0x000A(0x0002)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FBFGVehicleStop_Param) == 0x000004, "Wrong alignment on FBFGVehicleStop_Param");
static_assert(sizeof(FBFGVehicleStop_Param) == 0x00000C, "Wrong size on FBFGVehicleStop_Param");
static_assert(offsetof(FBFGVehicleStop_Param, M_eStopType) == 0x000000, "Member 'FBFGVehicleStop_Param::M_eStopType' has a wrong offset!");
static_assert(offsetof(FBFGVehicleStop_Param, M_fStopDistance) == 0x000004, "Member 'FBFGVehicleStop_Param::M_fStopDistance' has a wrong offset!");
static_assert(offsetof(FBFGVehicleStop_Param, M_stopMode) == 0x000008, "Member 'FBFGVehicleStop_Param::M_stopMode' has a wrong offset!");
static_assert(offsetof(FBFGVehicleStop_Param, M_passengerReleaseMode) == 0x000009, "Member 'FBFGVehicleStop_Param::M_passengerReleaseMode' has a wrong offset!");

// ScriptStruct BFGCore.BFGSplineLocationTracker
// 0x0150 (0x0150 - 0x0000)
struct FBFGSplineLocationTracker final
{
public:
	uint8                                         Pad_0[0x1];                                        // 0x0000(0x0001)(Fixing Size After Last Property [ Dumper-7 ])
	bool                                          M_bPassedEnd;                                      // 0x0001(0x0001)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_2[0x2];                                        // 0x0002(0x0002)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         M_fMargin;                                         // 0x0004(0x0004)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UBFGNetworkPath*                        M_pPath;                                           // 0x0008(0x0008)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	struct FSplineCurves                          M_spline;                                          // 0x0010(0x0060)(Transient, Protected, NativeAccessSpecifierProtected)
	struct FTransform                             M_Transform;                                       // 0x0070(0x0030)(Transient, IsPlainOldData, NoDestructor, Protected, NativeAccessSpecifierProtected)
	float                                         M_fLocationDistance;                               // 0x00A0(0x0004)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         M_fWay;                                            // 0x00A4(0x0004)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	struct FVector                                M_vLocation;                                       // 0x00A8(0x000C)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	struct FVector                                M_vDirection;                                      // 0x00B4(0x000C)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	struct FVector                                M_vSegmentDirection;                               // 0x00C0(0x000C)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	struct FVector                                M_vTangent;                                        // 0x00CC(0x000C)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	struct FVector                                M_vRadial;                                         // 0x00D8(0x000C)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	struct FVector                                M_vRightVector;                                    // 0x00E4(0x000C)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         M_fLength;                                         // 0x00F0(0x0004)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         M_fWidth;                                          // 0x00F4(0x0004)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_F8[0x4];                                       // 0x00F8(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	bool                                          M_bIsTwoSides;                                     // 0x00FC(0x0001)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          M_bIsTransitionPath;                               // 0x00FD(0x0001)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_FE[0x2];                                       // 0x00FE(0x0002)(Fixing Size After Last Property [ Dumper-7 ])
	struct FBFGHeightAlongPathData                M_transitionPathHeightData;                        // 0x0100(0x0020)(Transient, Protected, NativeAccessSpecifierProtected)
	struct FVector                                M_vEntryDirection;                                 // 0x0120(0x000C)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	struct FVector                                M_vExitDirection;                                  // 0x012C(0x000C)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         M_fLastKeyTime;                                    // 0x0138(0x0004)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         M_fDefaultAgentWidth;                              // 0x013C(0x0004)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         M_fCurrentOffsetFromCenter;                        // 0x0140(0x0004)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_144[0x4];                                      // 0x0144(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class UBFGNetworkPathAgent*                   M_pAgent;                                          // 0x0148(0x0008)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
};
static_assert(alignof(FBFGSplineLocationTracker) == 0x000010, "Wrong alignment on FBFGSplineLocationTracker");
static_assert(sizeof(FBFGSplineLocationTracker) == 0x000150, "Wrong size on FBFGSplineLocationTracker");
static_assert(offsetof(FBFGSplineLocationTracker, M_bPassedEnd) == 0x000001, "Member 'FBFGSplineLocationTracker::M_bPassedEnd' has a wrong offset!");
static_assert(offsetof(FBFGSplineLocationTracker, M_fMargin) == 0x000004, "Member 'FBFGSplineLocationTracker::M_fMargin' has a wrong offset!");
static_assert(offsetof(FBFGSplineLocationTracker, M_pPath) == 0x000008, "Member 'FBFGSplineLocationTracker::M_pPath' has a wrong offset!");
static_assert(offsetof(FBFGSplineLocationTracker, M_spline) == 0x000010, "Member 'FBFGSplineLocationTracker::M_spline' has a wrong offset!");
static_assert(offsetof(FBFGSplineLocationTracker, M_Transform) == 0x000070, "Member 'FBFGSplineLocationTracker::M_Transform' has a wrong offset!");
static_assert(offsetof(FBFGSplineLocationTracker, M_fLocationDistance) == 0x0000A0, "Member 'FBFGSplineLocationTracker::M_fLocationDistance' has a wrong offset!");
static_assert(offsetof(FBFGSplineLocationTracker, M_fWay) == 0x0000A4, "Member 'FBFGSplineLocationTracker::M_fWay' has a wrong offset!");
static_assert(offsetof(FBFGSplineLocationTracker, M_vLocation) == 0x0000A8, "Member 'FBFGSplineLocationTracker::M_vLocation' has a wrong offset!");
static_assert(offsetof(FBFGSplineLocationTracker, M_vDirection) == 0x0000B4, "Member 'FBFGSplineLocationTracker::M_vDirection' has a wrong offset!");
static_assert(offsetof(FBFGSplineLocationTracker, M_vSegmentDirection) == 0x0000C0, "Member 'FBFGSplineLocationTracker::M_vSegmentDirection' has a wrong offset!");
static_assert(offsetof(FBFGSplineLocationTracker, M_vTangent) == 0x0000CC, "Member 'FBFGSplineLocationTracker::M_vTangent' has a wrong offset!");
static_assert(offsetof(FBFGSplineLocationTracker, M_vRadial) == 0x0000D8, "Member 'FBFGSplineLocationTracker::M_vRadial' has a wrong offset!");
static_assert(offsetof(FBFGSplineLocationTracker, M_vRightVector) == 0x0000E4, "Member 'FBFGSplineLocationTracker::M_vRightVector' has a wrong offset!");
static_assert(offsetof(FBFGSplineLocationTracker, M_fLength) == 0x0000F0, "Member 'FBFGSplineLocationTracker::M_fLength' has a wrong offset!");
static_assert(offsetof(FBFGSplineLocationTracker, M_fWidth) == 0x0000F4, "Member 'FBFGSplineLocationTracker::M_fWidth' has a wrong offset!");
static_assert(offsetof(FBFGSplineLocationTracker, M_bIsTwoSides) == 0x0000FC, "Member 'FBFGSplineLocationTracker::M_bIsTwoSides' has a wrong offset!");
static_assert(offsetof(FBFGSplineLocationTracker, M_bIsTransitionPath) == 0x0000FD, "Member 'FBFGSplineLocationTracker::M_bIsTransitionPath' has a wrong offset!");
static_assert(offsetof(FBFGSplineLocationTracker, M_transitionPathHeightData) == 0x000100, "Member 'FBFGSplineLocationTracker::M_transitionPathHeightData' has a wrong offset!");
static_assert(offsetof(FBFGSplineLocationTracker, M_vEntryDirection) == 0x000120, "Member 'FBFGSplineLocationTracker::M_vEntryDirection' has a wrong offset!");
static_assert(offsetof(FBFGSplineLocationTracker, M_vExitDirection) == 0x00012C, "Member 'FBFGSplineLocationTracker::M_vExitDirection' has a wrong offset!");
static_assert(offsetof(FBFGSplineLocationTracker, M_fLastKeyTime) == 0x000138, "Member 'FBFGSplineLocationTracker::M_fLastKeyTime' has a wrong offset!");
static_assert(offsetof(FBFGSplineLocationTracker, M_fDefaultAgentWidth) == 0x00013C, "Member 'FBFGSplineLocationTracker::M_fDefaultAgentWidth' has a wrong offset!");
static_assert(offsetof(FBFGSplineLocationTracker, M_fCurrentOffsetFromCenter) == 0x000140, "Member 'FBFGSplineLocationTracker::M_fCurrentOffsetFromCenter' has a wrong offset!");
static_assert(offsetof(FBFGSplineLocationTracker, M_pAgent) == 0x000148, "Member 'FBFGSplineLocationTracker::M_pAgent' has a wrong offset!");

// ScriptStruct BFGCore.BFGVehicleObstacleAvoidanceCandidate
// 0x01D0 (0x01D0 - 0x0000)
struct FBFGVehicleObstacleAvoidanceCandidate final
{
public:
	bool                                          M_bAccurateInformationComputed;                    // 0x0000(0x0001)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1[0xF];                                        // 0x0001(0x000F)(Fixing Size After Last Property [ Dumper-7 ])
	struct FBFGSplineLocationTracker              M_vTracker;                                        // 0x0010(0x0150)(Transient, NativeAccessSpecifierPublic)
	class UBFGNetworkPathAgent*                   M_pAgent;                                          // 0x0160(0x0008)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class AActor*                                 M_pObstacleActor;                                  // 0x0168(0x0008)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         M_fAgentWidth;                                     // 0x0170(0x0004)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          M_bHasWidthForDoors;                               // 0x0174(0x0001)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_175[0x3];                                      // 0x0175(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         M_fAgentLength;                                    // 0x0178(0x0004)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                M_vLocation;                                       // 0x017C(0x000C)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                M_vDirection;                                      // 0x0188(0x000C)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         M_fCurrentDistance;                                // 0x0194(0x0004)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         M_fRelativeDistance;                               // 0x0198(0x0004)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          M_bIsOnTheOtherSide;                               // 0x019C(0x0001)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          M_bIsIntersectionObstacle;                         // 0x019D(0x0001)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          M_bIsFaceToFace;                                   // 0x019E(0x0001)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          M_bIsStandby;                                      // 0x019F(0x0001)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          M_bIsAboutToStop;                                  // 0x01A0(0x0001)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1A1[0x3];                                      // 0x01A1(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         M_fLeftOffset;                                     // 0x01A4(0x0004)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         M_fRightOffset;                                    // 0x01A8(0x0004)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         M_fApparentWidth;                                  // 0x01AC(0x0004)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         M_fApparentLength;                                 // 0x01B0(0x0004)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         M_fFrontDistance;                                  // 0x01B4(0x0004)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         M_fBackDistance;                                   // 0x01B8(0x0004)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         M_fPathWidth;                                      // 0x01BC(0x0004)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         M_fSpeed;                                          // 0x01C0(0x0004)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         M_fCrossingRelativeDistance;                       // 0x01C4(0x0004)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         M_fCrossingTime;                                   // 0x01C8(0x0004)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EBFGNetworkPathAgentPriorityLevel             M_ePriority;                                       // 0x01CC(0x0001)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EBFGBehaviourState_NPC                        M_eAlertState;                                     // 0x01CD(0x0001)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          M_bIsObstacleProxy;                                // 0x01CE(0x0001)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1CF[0x1];                                      // 0x01CF(0x0001)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FBFGVehicleObstacleAvoidanceCandidate) == 0x000010, "Wrong alignment on FBFGVehicleObstacleAvoidanceCandidate");
static_assert(sizeof(FBFGVehicleObstacleAvoidanceCandidate) == 0x0001D0, "Wrong size on FBFGVehicleObstacleAvoidanceCandidate");
static_assert(offsetof(FBFGVehicleObstacleAvoidanceCandidate, M_bAccurateInformationComputed) == 0x000000, "Member 'FBFGVehicleObstacleAvoidanceCandidate::M_bAccurateInformationComputed' has a wrong offset!");
static_assert(offsetof(FBFGVehicleObstacleAvoidanceCandidate, M_vTracker) == 0x000010, "Member 'FBFGVehicleObstacleAvoidanceCandidate::M_vTracker' has a wrong offset!");
static_assert(offsetof(FBFGVehicleObstacleAvoidanceCandidate, M_pAgent) == 0x000160, "Member 'FBFGVehicleObstacleAvoidanceCandidate::M_pAgent' has a wrong offset!");
static_assert(offsetof(FBFGVehicleObstacleAvoidanceCandidate, M_pObstacleActor) == 0x000168, "Member 'FBFGVehicleObstacleAvoidanceCandidate::M_pObstacleActor' has a wrong offset!");
static_assert(offsetof(FBFGVehicleObstacleAvoidanceCandidate, M_fAgentWidth) == 0x000170, "Member 'FBFGVehicleObstacleAvoidanceCandidate::M_fAgentWidth' has a wrong offset!");
static_assert(offsetof(FBFGVehicleObstacleAvoidanceCandidate, M_bHasWidthForDoors) == 0x000174, "Member 'FBFGVehicleObstacleAvoidanceCandidate::M_bHasWidthForDoors' has a wrong offset!");
static_assert(offsetof(FBFGVehicleObstacleAvoidanceCandidate, M_fAgentLength) == 0x000178, "Member 'FBFGVehicleObstacleAvoidanceCandidate::M_fAgentLength' has a wrong offset!");
static_assert(offsetof(FBFGVehicleObstacleAvoidanceCandidate, M_vLocation) == 0x00017C, "Member 'FBFGVehicleObstacleAvoidanceCandidate::M_vLocation' has a wrong offset!");
static_assert(offsetof(FBFGVehicleObstacleAvoidanceCandidate, M_vDirection) == 0x000188, "Member 'FBFGVehicleObstacleAvoidanceCandidate::M_vDirection' has a wrong offset!");
static_assert(offsetof(FBFGVehicleObstacleAvoidanceCandidate, M_fCurrentDistance) == 0x000194, "Member 'FBFGVehicleObstacleAvoidanceCandidate::M_fCurrentDistance' has a wrong offset!");
static_assert(offsetof(FBFGVehicleObstacleAvoidanceCandidate, M_fRelativeDistance) == 0x000198, "Member 'FBFGVehicleObstacleAvoidanceCandidate::M_fRelativeDistance' has a wrong offset!");
static_assert(offsetof(FBFGVehicleObstacleAvoidanceCandidate, M_bIsOnTheOtherSide) == 0x00019C, "Member 'FBFGVehicleObstacleAvoidanceCandidate::M_bIsOnTheOtherSide' has a wrong offset!");
static_assert(offsetof(FBFGVehicleObstacleAvoidanceCandidate, M_bIsIntersectionObstacle) == 0x00019D, "Member 'FBFGVehicleObstacleAvoidanceCandidate::M_bIsIntersectionObstacle' has a wrong offset!");
static_assert(offsetof(FBFGVehicleObstacleAvoidanceCandidate, M_bIsFaceToFace) == 0x00019E, "Member 'FBFGVehicleObstacleAvoidanceCandidate::M_bIsFaceToFace' has a wrong offset!");
static_assert(offsetof(FBFGVehicleObstacleAvoidanceCandidate, M_bIsStandby) == 0x00019F, "Member 'FBFGVehicleObstacleAvoidanceCandidate::M_bIsStandby' has a wrong offset!");
static_assert(offsetof(FBFGVehicleObstacleAvoidanceCandidate, M_bIsAboutToStop) == 0x0001A0, "Member 'FBFGVehicleObstacleAvoidanceCandidate::M_bIsAboutToStop' has a wrong offset!");
static_assert(offsetof(FBFGVehicleObstacleAvoidanceCandidate, M_fLeftOffset) == 0x0001A4, "Member 'FBFGVehicleObstacleAvoidanceCandidate::M_fLeftOffset' has a wrong offset!");
static_assert(offsetof(FBFGVehicleObstacleAvoidanceCandidate, M_fRightOffset) == 0x0001A8, "Member 'FBFGVehicleObstacleAvoidanceCandidate::M_fRightOffset' has a wrong offset!");
static_assert(offsetof(FBFGVehicleObstacleAvoidanceCandidate, M_fApparentWidth) == 0x0001AC, "Member 'FBFGVehicleObstacleAvoidanceCandidate::M_fApparentWidth' has a wrong offset!");
static_assert(offsetof(FBFGVehicleObstacleAvoidanceCandidate, M_fApparentLength) == 0x0001B0, "Member 'FBFGVehicleObstacleAvoidanceCandidate::M_fApparentLength' has a wrong offset!");
static_assert(offsetof(FBFGVehicleObstacleAvoidanceCandidate, M_fFrontDistance) == 0x0001B4, "Member 'FBFGVehicleObstacleAvoidanceCandidate::M_fFrontDistance' has a wrong offset!");
static_assert(offsetof(FBFGVehicleObstacleAvoidanceCandidate, M_fBackDistance) == 0x0001B8, "Member 'FBFGVehicleObstacleAvoidanceCandidate::M_fBackDistance' has a wrong offset!");
static_assert(offsetof(FBFGVehicleObstacleAvoidanceCandidate, M_fPathWidth) == 0x0001BC, "Member 'FBFGVehicleObstacleAvoidanceCandidate::M_fPathWidth' has a wrong offset!");
static_assert(offsetof(FBFGVehicleObstacleAvoidanceCandidate, M_fSpeed) == 0x0001C0, "Member 'FBFGVehicleObstacleAvoidanceCandidate::M_fSpeed' has a wrong offset!");
static_assert(offsetof(FBFGVehicleObstacleAvoidanceCandidate, M_fCrossingRelativeDistance) == 0x0001C4, "Member 'FBFGVehicleObstacleAvoidanceCandidate::M_fCrossingRelativeDistance' has a wrong offset!");
static_assert(offsetof(FBFGVehicleObstacleAvoidanceCandidate, M_fCrossingTime) == 0x0001C8, "Member 'FBFGVehicleObstacleAvoidanceCandidate::M_fCrossingTime' has a wrong offset!");
static_assert(offsetof(FBFGVehicleObstacleAvoidanceCandidate, M_ePriority) == 0x0001CC, "Member 'FBFGVehicleObstacleAvoidanceCandidate::M_ePriority' has a wrong offset!");
static_assert(offsetof(FBFGVehicleObstacleAvoidanceCandidate, M_eAlertState) == 0x0001CD, "Member 'FBFGVehicleObstacleAvoidanceCandidate::M_eAlertState' has a wrong offset!");
static_assert(offsetof(FBFGVehicleObstacleAvoidanceCandidate, M_bIsObstacleProxy) == 0x0001CE, "Member 'FBFGVehicleObstacleAvoidanceCandidate::M_bIsObstacleProxy' has a wrong offset!");

// ScriptStruct BFGCore.BFGQuest_DevDebug
// 0x0007 (0x0007 - 0x0000)
struct FBFGQuest_DevDebug final
{
public:
	bool                                          M_bShow_Missions;                                  // 0x0000(0x0001)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          M_bShow_Quest;                                     // 0x0001(0x0001)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          M_bShow_Additionals;                               // 0x0002(0x0001)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          M_bShow_CompletionRating;                          // 0x0003(0x0001)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          M_bShow_Locate;                                    // 0x0004(0x0001)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          M_bShow_Deliver;                                   // 0x0005(0x0001)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          M_bShow_ScriptedSequence;                          // 0x0006(0x0001)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FBFGQuest_DevDebug) == 0x000001, "Wrong alignment on FBFGQuest_DevDebug");
static_assert(sizeof(FBFGQuest_DevDebug) == 0x000007, "Wrong size on FBFGQuest_DevDebug");
static_assert(offsetof(FBFGQuest_DevDebug, M_bShow_Missions) == 0x000000, "Member 'FBFGQuest_DevDebug::M_bShow_Missions' has a wrong offset!");
static_assert(offsetof(FBFGQuest_DevDebug, M_bShow_Quest) == 0x000001, "Member 'FBFGQuest_DevDebug::M_bShow_Quest' has a wrong offset!");
static_assert(offsetof(FBFGQuest_DevDebug, M_bShow_Additionals) == 0x000002, "Member 'FBFGQuest_DevDebug::M_bShow_Additionals' has a wrong offset!");
static_assert(offsetof(FBFGQuest_DevDebug, M_bShow_CompletionRating) == 0x000003, "Member 'FBFGQuest_DevDebug::M_bShow_CompletionRating' has a wrong offset!");
static_assert(offsetof(FBFGQuest_DevDebug, M_bShow_Locate) == 0x000004, "Member 'FBFGQuest_DevDebug::M_bShow_Locate' has a wrong offset!");
static_assert(offsetof(FBFGQuest_DevDebug, M_bShow_Deliver) == 0x000005, "Member 'FBFGQuest_DevDebug::M_bShow_Deliver' has a wrong offset!");
static_assert(offsetof(FBFGQuest_DevDebug, M_bShow_ScriptedSequence) == 0x000006, "Member 'FBFGQuest_DevDebug::M_bShow_ScriptedSequence' has a wrong offset!");

// ScriptStruct BFGCore.BFGNetworkPathNavigationData
// 0x0370 (0x0370 - 0x0000)
struct FBFGNetworkPathNavigationData final
{
public:
	class UBFGNetworkPath*                        M_pCurrentPathSegment;                             // 0x0000(0x0008)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UBFGNetworkPath*                        M_pNextPathSegment;                                // 0x0008(0x0008)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         M_iIntersectionTicket;                             // 0x0010(0x0004)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_14[0x4];                                       // 0x0014(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	struct FSplineCurves                          M_transitionCurve;                                 // 0x0018(0x0060)(Transient, NativeAccessSpecifierPublic)
	struct FBFGHeightAlongPathData                M_transitionCurveHeightData;                       // 0x0078(0x0020)(Transient, NativeAccessSpecifierPublic)
	EBFGNetworkPathExtremity                      M_eCurrentTargetExtremity;                         // 0x0098(0x0001)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EBFGNetworkPathExtremity                      M_eNextPathExtremity;                              // 0x0099(0x0001)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_9A[0x6];                                       // 0x009A(0x0006)(Fixing Size After Last Property [ Dumper-7 ])
	class UBFGNetworkPathIntersection*            M_pCurrentIntersection;                            // 0x00A0(0x0008)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_A8[0x8];                                       // 0x00A8(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	struct FBFGSplineLocationTracker              M_trackerCurrent;                                  // 0x00B0(0x0150)(Transient, NativeAccessSpecifierPublic)
	struct FBFGSplineLocationTracker              M_trackerTarget;                                   // 0x0200(0x0150)(Transient, NativeAccessSpecifierPublic)
	float                                         M_fDistanceFromSplineCenter;                       // 0x0350(0x0004)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         M_fEndPathMargin;                                  // 0x0354(0x0004)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         M_fDistanceStepLength;                             // 0x0358(0x0004)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         M_fSavedDistanceOnSpline;                          // 0x035C(0x0004)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         M_fDistanceAlongTransitionCurve;                   // 0x0360(0x0004)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_364[0xC];                                      // 0x0364(0x000C)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FBFGNetworkPathNavigationData) == 0x000010, "Wrong alignment on FBFGNetworkPathNavigationData");
static_assert(sizeof(FBFGNetworkPathNavigationData) == 0x000370, "Wrong size on FBFGNetworkPathNavigationData");
static_assert(offsetof(FBFGNetworkPathNavigationData, M_pCurrentPathSegment) == 0x000000, "Member 'FBFGNetworkPathNavigationData::M_pCurrentPathSegment' has a wrong offset!");
static_assert(offsetof(FBFGNetworkPathNavigationData, M_pNextPathSegment) == 0x000008, "Member 'FBFGNetworkPathNavigationData::M_pNextPathSegment' has a wrong offset!");
static_assert(offsetof(FBFGNetworkPathNavigationData, M_iIntersectionTicket) == 0x000010, "Member 'FBFGNetworkPathNavigationData::M_iIntersectionTicket' has a wrong offset!");
static_assert(offsetof(FBFGNetworkPathNavigationData, M_transitionCurve) == 0x000018, "Member 'FBFGNetworkPathNavigationData::M_transitionCurve' has a wrong offset!");
static_assert(offsetof(FBFGNetworkPathNavigationData, M_transitionCurveHeightData) == 0x000078, "Member 'FBFGNetworkPathNavigationData::M_transitionCurveHeightData' has a wrong offset!");
static_assert(offsetof(FBFGNetworkPathNavigationData, M_eCurrentTargetExtremity) == 0x000098, "Member 'FBFGNetworkPathNavigationData::M_eCurrentTargetExtremity' has a wrong offset!");
static_assert(offsetof(FBFGNetworkPathNavigationData, M_eNextPathExtremity) == 0x000099, "Member 'FBFGNetworkPathNavigationData::M_eNextPathExtremity' has a wrong offset!");
static_assert(offsetof(FBFGNetworkPathNavigationData, M_pCurrentIntersection) == 0x0000A0, "Member 'FBFGNetworkPathNavigationData::M_pCurrentIntersection' has a wrong offset!");
static_assert(offsetof(FBFGNetworkPathNavigationData, M_trackerCurrent) == 0x0000B0, "Member 'FBFGNetworkPathNavigationData::M_trackerCurrent' has a wrong offset!");
static_assert(offsetof(FBFGNetworkPathNavigationData, M_trackerTarget) == 0x000200, "Member 'FBFGNetworkPathNavigationData::M_trackerTarget' has a wrong offset!");
static_assert(offsetof(FBFGNetworkPathNavigationData, M_fDistanceFromSplineCenter) == 0x000350, "Member 'FBFGNetworkPathNavigationData::M_fDistanceFromSplineCenter' has a wrong offset!");
static_assert(offsetof(FBFGNetworkPathNavigationData, M_fEndPathMargin) == 0x000354, "Member 'FBFGNetworkPathNavigationData::M_fEndPathMargin' has a wrong offset!");
static_assert(offsetof(FBFGNetworkPathNavigationData, M_fDistanceStepLength) == 0x000358, "Member 'FBFGNetworkPathNavigationData::M_fDistanceStepLength' has a wrong offset!");
static_assert(offsetof(FBFGNetworkPathNavigationData, M_fSavedDistanceOnSpline) == 0x00035C, "Member 'FBFGNetworkPathNavigationData::M_fSavedDistanceOnSpline' has a wrong offset!");
static_assert(offsetof(FBFGNetworkPathNavigationData, M_fDistanceAlongTransitionCurve) == 0x000360, "Member 'FBFGNetworkPathNavigationData::M_fDistanceAlongTransitionCurve' has a wrong offset!");

// ScriptStruct BFGCore.BFGVehicleHeightData
// 0x0020 (0x0020 - 0x0000)
struct FBFGVehicleHeightData final
{
public:
	uint8                                         Pad_0[0x14];                                       // 0x0000(0x0014)(Fixing Size After Last Property [ Dumper-7 ])
	struct FVector                                M_vSplineDirection;                                // 0x0014(0x000C)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FBFGVehicleHeightData) == 0x000004, "Wrong alignment on FBFGVehicleHeightData");
static_assert(sizeof(FBFGVehicleHeightData) == 0x000020, "Wrong size on FBFGVehicleHeightData");
static_assert(offsetof(FBFGVehicleHeightData, M_vSplineDirection) == 0x000014, "Member 'FBFGVehicleHeightData::M_vSplineDirection' has a wrong offset!");

// ScriptStruct BFGCore.BFGTriggerManager_TriggerZoneData
// 0x0020 (0x0020 - 0x0000)
struct FBFGTriggerManager_TriggerZoneData final
{
public:
	class ABFGMissionCustomTriggerZone*           M_pTriggerZone;                                    // 0x0000(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_8[0x18];                                       // 0x0008(0x0018)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FBFGTriggerManager_TriggerZoneData) == 0x000008, "Wrong alignment on FBFGTriggerManager_TriggerZoneData");
static_assert(sizeof(FBFGTriggerManager_TriggerZoneData) == 0x000020, "Wrong size on FBFGTriggerManager_TriggerZoneData");
static_assert(offsetof(FBFGTriggerManager_TriggerZoneData, M_pTriggerZone) == 0x000000, "Member 'FBFGTriggerManager_TriggerZoneData::M_pTriggerZone' has a wrong offset!");

// ScriptStruct BFGCore.BFGMissionRewards
// 0x0048 (0x0048 - 0x0000)
struct FBFGMissionRewards final
{
public:
	class FText                                   M_strRewardTitle;                                  // 0x0000(0x0018)(BlueprintVisible, BlueprintReadOnly, NativeAccessSpecifierPublic)
	TSoftObjectPtr<class UPaperSprite>            M_pIcon;                                           // 0x0018(0x0028)(BlueprintVisible, BlueprintReadOnly, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EBFGQuestRewardsType                          M_rewardType;                                      // 0x0040(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_41[0x3];                                       // 0x0041(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	int32                                         M_iRewardAmount;                                   // 0x0044(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FBFGMissionRewards) == 0x000008, "Wrong alignment on FBFGMissionRewards");
static_assert(sizeof(FBFGMissionRewards) == 0x000048, "Wrong size on FBFGMissionRewards");
static_assert(offsetof(FBFGMissionRewards, M_strRewardTitle) == 0x000000, "Member 'FBFGMissionRewards::M_strRewardTitle' has a wrong offset!");
static_assert(offsetof(FBFGMissionRewards, M_pIcon) == 0x000018, "Member 'FBFGMissionRewards::M_pIcon' has a wrong offset!");
static_assert(offsetof(FBFGMissionRewards, M_rewardType) == 0x000040, "Member 'FBFGMissionRewards::M_rewardType' has a wrong offset!");
static_assert(offsetof(FBFGMissionRewards, M_iRewardAmount) == 0x000044, "Member 'FBFGMissionRewards::M_iRewardAmount' has a wrong offset!");

// ScriptStruct BFGCore.BFGMissionResultInfo
// 0x0090 (0x0090 - 0x0000)
struct FBFGMissionResultInfo final
{
public:
	int32                                         M_iCompletionOverall;                              // 0x0000(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_4[0x4];                                        // 0x0004(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<int32>                                 M_aiCompletionQuest;                               // 0x0008(0x0010)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, NativeAccessSpecifierPublic)
	TArray<class FText>                           M_aoCompletionQuestText;                           // 0x0018(0x0010)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, NativeAccessSpecifierPublic)
	TArray<struct FSlateBrush>                    M_aoCompletionQuestIcon;                           // 0x0028(0x0010)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, NativeAccessSpecifierPublic)
	class FText                                   M_oTextCompletionReward;                           // 0x0038(0x0018)(BlueprintVisible, BlueprintReadOnly, NativeAccessSpecifierPublic)
	class FText                                   M_oTextMissionFailed;                              // 0x0050(0x0018)(BlueprintVisible, BlueprintReadOnly, NativeAccessSpecifierPublic)
	TArray<struct FBFGSubMissionResultInfo>       M_aoCompletionSubQuestText;                        // 0x0068(0x0010)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, NativeAccessSpecifierPublic)
	TArray<struct FBFGMissionRewards>             M_aoGainedRewards;                                 // 0x0078(0x0010)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, NativeAccessSpecifierPublic)
	bool                                          M_bReceivedReward;                                 // 0x0088(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_89[0x7];                                       // 0x0089(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FBFGMissionResultInfo) == 0x000008, "Wrong alignment on FBFGMissionResultInfo");
static_assert(sizeof(FBFGMissionResultInfo) == 0x000090, "Wrong size on FBFGMissionResultInfo");
static_assert(offsetof(FBFGMissionResultInfo, M_iCompletionOverall) == 0x000000, "Member 'FBFGMissionResultInfo::M_iCompletionOverall' has a wrong offset!");
static_assert(offsetof(FBFGMissionResultInfo, M_aiCompletionQuest) == 0x000008, "Member 'FBFGMissionResultInfo::M_aiCompletionQuest' has a wrong offset!");
static_assert(offsetof(FBFGMissionResultInfo, M_aoCompletionQuestText) == 0x000018, "Member 'FBFGMissionResultInfo::M_aoCompletionQuestText' has a wrong offset!");
static_assert(offsetof(FBFGMissionResultInfo, M_aoCompletionQuestIcon) == 0x000028, "Member 'FBFGMissionResultInfo::M_aoCompletionQuestIcon' has a wrong offset!");
static_assert(offsetof(FBFGMissionResultInfo, M_oTextCompletionReward) == 0x000038, "Member 'FBFGMissionResultInfo::M_oTextCompletionReward' has a wrong offset!");
static_assert(offsetof(FBFGMissionResultInfo, M_oTextMissionFailed) == 0x000050, "Member 'FBFGMissionResultInfo::M_oTextMissionFailed' has a wrong offset!");
static_assert(offsetof(FBFGMissionResultInfo, M_aoCompletionSubQuestText) == 0x000068, "Member 'FBFGMissionResultInfo::M_aoCompletionSubQuestText' has a wrong offset!");
static_assert(offsetof(FBFGMissionResultInfo, M_aoGainedRewards) == 0x000078, "Member 'FBFGMissionResultInfo::M_aoGainedRewards' has a wrong offset!");
static_assert(offsetof(FBFGMissionResultInfo, M_bReceivedReward) == 0x000088, "Member 'FBFGMissionResultInfo::M_bReceivedReward' has a wrong offset!");

// ScriptStruct BFGCore.BFGSpotPassengerAnimData
// 0x0018 (0x0018 - 0x0000)
struct FBFGSpotPassengerAnimData final
{
public:
	EBFGAnimation_Interact                        M_eAnimationVehicleEnter;                          // 0x0000(0x0001)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EBFGAnimation_Interact                        M_eAnimationVehicleEnterFast;                      // 0x0001(0x0001)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EBFGAnimation_Interact                        M_eAnimationVehicleLoop;                           // 0x0002(0x0001)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EBFGAnimation_Interact                        M_eAnimationVehicleExit;                           // 0x0003(0x0001)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EBFGAnimation_Interact                        M_eAnimationVehicleExitPanic;                      // 0x0004(0x0001)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EBFGAnimation_Interact                        M_eAnimationVehicleExitAggressive;                 // 0x0005(0x0001)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_6[0x2];                                        // 0x0006(0x0002)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<EBFGAnimation_Interact>                M_aAnimationVehiclePanicLoopVariations;            // 0x0008(0x0010)(ZeroConstructor, Transient, NativeAccessSpecifierPublic)
};
static_assert(alignof(FBFGSpotPassengerAnimData) == 0x000008, "Wrong alignment on FBFGSpotPassengerAnimData");
static_assert(sizeof(FBFGSpotPassengerAnimData) == 0x000018, "Wrong size on FBFGSpotPassengerAnimData");
static_assert(offsetof(FBFGSpotPassengerAnimData, M_eAnimationVehicleEnter) == 0x000000, "Member 'FBFGSpotPassengerAnimData::M_eAnimationVehicleEnter' has a wrong offset!");
static_assert(offsetof(FBFGSpotPassengerAnimData, M_eAnimationVehicleEnterFast) == 0x000001, "Member 'FBFGSpotPassengerAnimData::M_eAnimationVehicleEnterFast' has a wrong offset!");
static_assert(offsetof(FBFGSpotPassengerAnimData, M_eAnimationVehicleLoop) == 0x000002, "Member 'FBFGSpotPassengerAnimData::M_eAnimationVehicleLoop' has a wrong offset!");
static_assert(offsetof(FBFGSpotPassengerAnimData, M_eAnimationVehicleExit) == 0x000003, "Member 'FBFGSpotPassengerAnimData::M_eAnimationVehicleExit' has a wrong offset!");
static_assert(offsetof(FBFGSpotPassengerAnimData, M_eAnimationVehicleExitPanic) == 0x000004, "Member 'FBFGSpotPassengerAnimData::M_eAnimationVehicleExitPanic' has a wrong offset!");
static_assert(offsetof(FBFGSpotPassengerAnimData, M_eAnimationVehicleExitAggressive) == 0x000005, "Member 'FBFGSpotPassengerAnimData::M_eAnimationVehicleExitAggressive' has a wrong offset!");
static_assert(offsetof(FBFGSpotPassengerAnimData, M_aAnimationVehiclePanicLoopVariations) == 0x000008, "Member 'FBFGSpotPassengerAnimData::M_aAnimationVehiclePanicLoopVariations' has a wrong offset!");

// ScriptStruct BFGCore.CharacterAimData
// 0x00CC (0x00CC - 0x0000)
struct FCharacterAimData final
{
public:
	struct FVector                                M_vAimedAtPosition;                                // 0x0000(0x000C)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                M_vBestShotDirection;                              // 0x000C(0x000C)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                M_vSpawnLocation;                                  // 0x0018(0x000C)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FRotator                               M_rSpawnRotation;                                  // 0x0024(0x000C)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
	TWeakObjectPtr<class AActor>                  M_pTargetActor;                                    // 0x0030(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FHitResult                             M_HitResult;                                       // 0x0038(0x0088)(Edit, BlueprintVisible, IsPlainOldData, NoDestructor, ContainsInstancedReference, NativeAccessSpecifierPublic)
	bool                                          M_bHitEnvironment;                                 // 0x00C0(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_C1[0x3];                                       // 0x00C1(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         M_fTimeOfImpact;                                   // 0x00C4(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          M_bIsValid;                                        // 0x00C8(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_C9[0x3];                                       // 0x00C9(0x0003)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FCharacterAimData) == 0x000004, "Wrong alignment on FCharacterAimData");
static_assert(sizeof(FCharacterAimData) == 0x0000CC, "Wrong size on FCharacterAimData");
static_assert(offsetof(FCharacterAimData, M_vAimedAtPosition) == 0x000000, "Member 'FCharacterAimData::M_vAimedAtPosition' has a wrong offset!");
static_assert(offsetof(FCharacterAimData, M_vBestShotDirection) == 0x00000C, "Member 'FCharacterAimData::M_vBestShotDirection' has a wrong offset!");
static_assert(offsetof(FCharacterAimData, M_vSpawnLocation) == 0x000018, "Member 'FCharacterAimData::M_vSpawnLocation' has a wrong offset!");
static_assert(offsetof(FCharacterAimData, M_rSpawnRotation) == 0x000024, "Member 'FCharacterAimData::M_rSpawnRotation' has a wrong offset!");
static_assert(offsetof(FCharacterAimData, M_pTargetActor) == 0x000030, "Member 'FCharacterAimData::M_pTargetActor' has a wrong offset!");
static_assert(offsetof(FCharacterAimData, M_HitResult) == 0x000038, "Member 'FCharacterAimData::M_HitResult' has a wrong offset!");
static_assert(offsetof(FCharacterAimData, M_bHitEnvironment) == 0x0000C0, "Member 'FCharacterAimData::M_bHitEnvironment' has a wrong offset!");
static_assert(offsetof(FCharacterAimData, M_fTimeOfImpact) == 0x0000C4, "Member 'FCharacterAimData::M_fTimeOfImpact' has a wrong offset!");
static_assert(offsetof(FCharacterAimData, M_bIsValid) == 0x0000C8, "Member 'FCharacterAimData::M_bIsValid' has a wrong offset!");

// ScriptStruct BFGCore.MetaPattern
// 0x0020 (0x0028 - 0x0008)
struct FMetaPattern : public FTableRowBase
{
public:
	float                                         M_fDuration;                                       // 0x0008(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         M_fTelegraphDuration;                              // 0x000C(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         M_fCooldownDuration;                               // 0x0010(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_14[0x4];                                       // 0x0014(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<EBFGAttackQuadrant>                    M_aBlackListedQuadrants;                           // 0x0018(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(FMetaPattern) == 0x000008, "Wrong alignment on FMetaPattern");
static_assert(sizeof(FMetaPattern) == 0x000028, "Wrong size on FMetaPattern");
static_assert(offsetof(FMetaPattern, M_fDuration) == 0x000008, "Member 'FMetaPattern::M_fDuration' has a wrong offset!");
static_assert(offsetof(FMetaPattern, M_fTelegraphDuration) == 0x00000C, "Member 'FMetaPattern::M_fTelegraphDuration' has a wrong offset!");
static_assert(offsetof(FMetaPattern, M_fCooldownDuration) == 0x000010, "Member 'FMetaPattern::M_fCooldownDuration' has a wrong offset!");
static_assert(offsetof(FMetaPattern, M_aBlackListedQuadrants) == 0x000018, "Member 'FMetaPattern::M_aBlackListedQuadrants' has a wrong offset!");

// ScriptStruct BFGCore.BFGNetworkPathInfo
// 0x0120 (0x0120 - 0x0000)
struct FBFGNetworkPathInfo final
{
public:
	struct FGuid                                  PathId;                                            // 0x0000(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UBFGNetworkPathAsset*                   M_pPathAsset;                                      // 0x0010(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TSoftObjectPtr<class UBFGSpawningComposition> M_pSpawningComposition;                            // 0x0018(0x0028)(Edit, BlueprintVisible, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TArray<struct FBFGNetworkPathConnection>      OutConnections;                                    // 0x0040(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, EditConst, NativeAccessSpecifierPublic)
	TArray<struct FBFGNetworkPathConnection>      IncomingConnections;                               // 0x0050(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, EditConst, NativeAccessSpecifierPublic)
	bool                                          Available;                                         // 0x0060(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_61[0x3];                                       // 0x0061(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         PathWidth;                                         // 0x0064(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         MaxAvoidanceDistanceFromPath;                      // 0x0068(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         MaxSpawnedAgents;                                  // 0x006C(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TSubclassOf<class AActor>                     AllowedActor;                                      // 0x0070(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FGameplayTagQuery                      AllowedByTagQuery;                                 // 0x0078(0x0048)(Edit, BlueprintVisible, NativeAccessSpecifierPublic)
	struct FGameplayTagQuery                      AllowedByTagQueryOverride;                         // 0x00C0(0x0048)(Transient, NativeAccessSpecifierPublic)
	float                                         Weight;                                            // 0x0108(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         SpeedOverride;                                     // 0x010C(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          GroupsAllowed;                                     // 0x0110(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          IsPatrolPath;                                      // 0x0111(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_112[0x2];                                      // 0x0112(0x0002)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         ToleranceRadius;                                   // 0x0114(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          IsLooping;                                         // 0x0118(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          IsTwoSides;                                        // 0x0119(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          IsCrossWalk;                                       // 0x011A(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_11B[0x5];                                      // 0x011B(0x0005)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FBFGNetworkPathInfo) == 0x000008, "Wrong alignment on FBFGNetworkPathInfo");
static_assert(sizeof(FBFGNetworkPathInfo) == 0x000120, "Wrong size on FBFGNetworkPathInfo");
static_assert(offsetof(FBFGNetworkPathInfo, PathId) == 0x000000, "Member 'FBFGNetworkPathInfo::PathId' has a wrong offset!");
static_assert(offsetof(FBFGNetworkPathInfo, M_pPathAsset) == 0x000010, "Member 'FBFGNetworkPathInfo::M_pPathAsset' has a wrong offset!");
static_assert(offsetof(FBFGNetworkPathInfo, M_pSpawningComposition) == 0x000018, "Member 'FBFGNetworkPathInfo::M_pSpawningComposition' has a wrong offset!");
static_assert(offsetof(FBFGNetworkPathInfo, OutConnections) == 0x000040, "Member 'FBFGNetworkPathInfo::OutConnections' has a wrong offset!");
static_assert(offsetof(FBFGNetworkPathInfo, IncomingConnections) == 0x000050, "Member 'FBFGNetworkPathInfo::IncomingConnections' has a wrong offset!");
static_assert(offsetof(FBFGNetworkPathInfo, Available) == 0x000060, "Member 'FBFGNetworkPathInfo::Available' has a wrong offset!");
static_assert(offsetof(FBFGNetworkPathInfo, PathWidth) == 0x000064, "Member 'FBFGNetworkPathInfo::PathWidth' has a wrong offset!");
static_assert(offsetof(FBFGNetworkPathInfo, MaxAvoidanceDistanceFromPath) == 0x000068, "Member 'FBFGNetworkPathInfo::MaxAvoidanceDistanceFromPath' has a wrong offset!");
static_assert(offsetof(FBFGNetworkPathInfo, MaxSpawnedAgents) == 0x00006C, "Member 'FBFGNetworkPathInfo::MaxSpawnedAgents' has a wrong offset!");
static_assert(offsetof(FBFGNetworkPathInfo, AllowedActor) == 0x000070, "Member 'FBFGNetworkPathInfo::AllowedActor' has a wrong offset!");
static_assert(offsetof(FBFGNetworkPathInfo, AllowedByTagQuery) == 0x000078, "Member 'FBFGNetworkPathInfo::AllowedByTagQuery' has a wrong offset!");
static_assert(offsetof(FBFGNetworkPathInfo, AllowedByTagQueryOverride) == 0x0000C0, "Member 'FBFGNetworkPathInfo::AllowedByTagQueryOverride' has a wrong offset!");
static_assert(offsetof(FBFGNetworkPathInfo, Weight) == 0x000108, "Member 'FBFGNetworkPathInfo::Weight' has a wrong offset!");
static_assert(offsetof(FBFGNetworkPathInfo, SpeedOverride) == 0x00010C, "Member 'FBFGNetworkPathInfo::SpeedOverride' has a wrong offset!");
static_assert(offsetof(FBFGNetworkPathInfo, GroupsAllowed) == 0x000110, "Member 'FBFGNetworkPathInfo::GroupsAllowed' has a wrong offset!");
static_assert(offsetof(FBFGNetworkPathInfo, IsPatrolPath) == 0x000111, "Member 'FBFGNetworkPathInfo::IsPatrolPath' has a wrong offset!");
static_assert(offsetof(FBFGNetworkPathInfo, ToleranceRadius) == 0x000114, "Member 'FBFGNetworkPathInfo::ToleranceRadius' has a wrong offset!");
static_assert(offsetof(FBFGNetworkPathInfo, IsLooping) == 0x000118, "Member 'FBFGNetworkPathInfo::IsLooping' has a wrong offset!");
static_assert(offsetof(FBFGNetworkPathInfo, IsTwoSides) == 0x000119, "Member 'FBFGNetworkPathInfo::IsTwoSides' has a wrong offset!");
static_assert(offsetof(FBFGNetworkPathInfo, IsCrossWalk) == 0x00011A, "Member 'FBFGNetworkPathInfo::IsCrossWalk' has a wrong offset!");

// ScriptStruct BFGCore.BFGIntersectionPathExtremity
// 0x00E0 (0x00E0 - 0x0000)
struct FBFGIntersectionPathExtremity final
{
public:
	class UBFGNetworkPath*                        M_pPath;                                           // 0x0000(0x0008)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EBFGNetworkPathExtremity                      M_eExtremity;                                      // 0x0008(0x0001)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_9[0x7];                                        // 0x0009(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	class UBFGNetworkPathIntersection*            M_pIntersection;                                   // 0x0010(0x0008)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                M_vLocation;                                       // 0x0018(0x000C)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                M_vDirection;                                      // 0x0024(0x000C)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         M_fFillRatio;                                      // 0x0030(0x0004)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         M_iOrdinalIndex;                                   // 0x0034(0x0004)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TArray<int32>                                 M_aIncomingRequests;                               // 0x0038(0x0010)(ZeroConstructor, Transient, Protected, NativeAccessSpecifierProtected)
	TArray<int32>                                 M_aGrantedRequests;                                // 0x0048(0x0010)(ZeroConstructor, Transient, Protected, NativeAccessSpecifierProtected)
	TMap<int32, struct FBFGIntersectionUser>      M_aIncomingUsers;                                  // 0x0058(0x0050)(ZeroConstructor, Transient, Protected, NativeAccessSpecifierProtected)
	TArray<int32>                                 M_aInTransition;                                   // 0x00A8(0x0010)(ZeroConstructor, Transient, Protected, NativeAccessSpecifierProtected)
	int32                                         M_iNumLocks;                                       // 0x00B8(0x0004)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          M_bCanBeLocked;                                    // 0x00BC(0x0001)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_BD[0x3];                                       // 0x00BD(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	int32                                         M_iNumLocksOnIncoming;                             // 0x00C0(0x0004)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         M_fTimeSpentLocked;                                // 0x00C4(0x0004)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UBFGNetworkPath*                        M_pCrossWalk;                                      // 0x00C8(0x0008)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	EBFGCrossWalkState                            M_eCrossWalkState;                                 // 0x00D0(0x0001)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_D1[0x3];                                       // 0x00D1(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         M_fCrossWalkCoolDownTimer;                         // 0x00D4(0x0004)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	int32                                         M_iStuckVehicleTicket;                             // 0x00D8(0x0004)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         M_fStuckTimer;                                     // 0x00DC(0x0004)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
};
static_assert(alignof(FBFGIntersectionPathExtremity) == 0x000008, "Wrong alignment on FBFGIntersectionPathExtremity");
static_assert(sizeof(FBFGIntersectionPathExtremity) == 0x0000E0, "Wrong size on FBFGIntersectionPathExtremity");
static_assert(offsetof(FBFGIntersectionPathExtremity, M_pPath) == 0x000000, "Member 'FBFGIntersectionPathExtremity::M_pPath' has a wrong offset!");
static_assert(offsetof(FBFGIntersectionPathExtremity, M_eExtremity) == 0x000008, "Member 'FBFGIntersectionPathExtremity::M_eExtremity' has a wrong offset!");
static_assert(offsetof(FBFGIntersectionPathExtremity, M_pIntersection) == 0x000010, "Member 'FBFGIntersectionPathExtremity::M_pIntersection' has a wrong offset!");
static_assert(offsetof(FBFGIntersectionPathExtremity, M_vLocation) == 0x000018, "Member 'FBFGIntersectionPathExtremity::M_vLocation' has a wrong offset!");
static_assert(offsetof(FBFGIntersectionPathExtremity, M_vDirection) == 0x000024, "Member 'FBFGIntersectionPathExtremity::M_vDirection' has a wrong offset!");
static_assert(offsetof(FBFGIntersectionPathExtremity, M_fFillRatio) == 0x000030, "Member 'FBFGIntersectionPathExtremity::M_fFillRatio' has a wrong offset!");
static_assert(offsetof(FBFGIntersectionPathExtremity, M_iOrdinalIndex) == 0x000034, "Member 'FBFGIntersectionPathExtremity::M_iOrdinalIndex' has a wrong offset!");
static_assert(offsetof(FBFGIntersectionPathExtremity, M_aIncomingRequests) == 0x000038, "Member 'FBFGIntersectionPathExtremity::M_aIncomingRequests' has a wrong offset!");
static_assert(offsetof(FBFGIntersectionPathExtremity, M_aGrantedRequests) == 0x000048, "Member 'FBFGIntersectionPathExtremity::M_aGrantedRequests' has a wrong offset!");
static_assert(offsetof(FBFGIntersectionPathExtremity, M_aIncomingUsers) == 0x000058, "Member 'FBFGIntersectionPathExtremity::M_aIncomingUsers' has a wrong offset!");
static_assert(offsetof(FBFGIntersectionPathExtremity, M_aInTransition) == 0x0000A8, "Member 'FBFGIntersectionPathExtremity::M_aInTransition' has a wrong offset!");
static_assert(offsetof(FBFGIntersectionPathExtremity, M_iNumLocks) == 0x0000B8, "Member 'FBFGIntersectionPathExtremity::M_iNumLocks' has a wrong offset!");
static_assert(offsetof(FBFGIntersectionPathExtremity, M_bCanBeLocked) == 0x0000BC, "Member 'FBFGIntersectionPathExtremity::M_bCanBeLocked' has a wrong offset!");
static_assert(offsetof(FBFGIntersectionPathExtremity, M_iNumLocksOnIncoming) == 0x0000C0, "Member 'FBFGIntersectionPathExtremity::M_iNumLocksOnIncoming' has a wrong offset!");
static_assert(offsetof(FBFGIntersectionPathExtremity, M_fTimeSpentLocked) == 0x0000C4, "Member 'FBFGIntersectionPathExtremity::M_fTimeSpentLocked' has a wrong offset!");
static_assert(offsetof(FBFGIntersectionPathExtremity, M_pCrossWalk) == 0x0000C8, "Member 'FBFGIntersectionPathExtremity::M_pCrossWalk' has a wrong offset!");
static_assert(offsetof(FBFGIntersectionPathExtremity, M_eCrossWalkState) == 0x0000D0, "Member 'FBFGIntersectionPathExtremity::M_eCrossWalkState' has a wrong offset!");
static_assert(offsetof(FBFGIntersectionPathExtremity, M_fCrossWalkCoolDownTimer) == 0x0000D4, "Member 'FBFGIntersectionPathExtremity::M_fCrossWalkCoolDownTimer' has a wrong offset!");
static_assert(offsetof(FBFGIntersectionPathExtremity, M_iStuckVehicleTicket) == 0x0000D8, "Member 'FBFGIntersectionPathExtremity::M_iStuckVehicleTicket' has a wrong offset!");
static_assert(offsetof(FBFGIntersectionPathExtremity, M_fStuckTimer) == 0x0000DC, "Member 'FBFGIntersectionPathExtremity::M_fStuckTimer' has a wrong offset!");

// ScriptStruct BFGCore.BossData_AnimData
// 0x00D0 (0x00D8 - 0x0008)
struct FBossData_AnimData final : public FTableRowBase
{
public:
	uint8                                         Pad_8[0x38];                                       // 0x0008(0x0038)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         M_fAnimationLength_CallReinforcements;             // 0x0040(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         M_fAnimationLength_Leap;                           // 0x0044(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         M_fAnimationLength_Stomp;                          // 0x0048(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         M_fAnimationLength_ChargeEnd;                      // 0x004C(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         M_fAnimationLength_KnockDown;                      // 0x0050(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         M_fAnimationLength_StandUp;                        // 0x0054(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         M_fAnimationLength_Enraged;                        // 0x0058(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         M_fAnimationDelay_RetractMissiles;                 // 0x005C(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_60[0x10];                                      // 0x0060(0x0010)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         M_fLevitationHeight;                               // 0x0070(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         M_fEvasionTargetRotationDelay;                     // 0x0074(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         M_fMaxHeight_Evasion;                              // 0x0078(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         M_fMaxHeight_InnerRadius;                          // 0x007C(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         M_fMaxHeight_OuterRadius;                          // 0x0080(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         M_fActionTelegraphTime_Evasion;                    // 0x0084(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         M_fEvasionAnimationLength;                         // 0x0088(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         M_fAction_Attack360_StartDelay;                    // 0x008C(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         M_fAction_Attack360_StopDelay;                     // 0x0090(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         M_fAction_TornadoStartDelay;                       // 0x0094(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         M_fAction_TornadoStopDelay;                        // 0x0098(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         M_fAnimationDelay_NasalProbe_Start;                // 0x009C(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         M_fAnimationDelay_NasalProbe_End;                  // 0x00A0(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         M_fAnimationDelay_NasalProbeCharge;                // 0x00A4(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         M_fAnimationLength_NasalProbeShot;                 // 0x00A8(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          M_bIsActivelyDrainingPSI;                          // 0x00AC(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          M_bIsUnderCover;                                   // 0x00AD(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          M_bIsTakingDamage;                                 // 0x00AE(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          M_bIsShootingBeam;                                 // 0x00AF(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	EBFGBeamAttackPhase                           M_eBeamAttackPhase;                                // 0x00B0(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_B1[0xF];                                       // 0x00B1(0x000F)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         M_fTurnInPlacePreDelay;                            // 0x00C0(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         M_fTurnInPlacePostDelay;                           // 0x00C4(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         M_fTurnInPlaceDuration;                            // 0x00C8(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_CC[0x4];                                       // 0x00CC(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         M_fPhaseTransitionTriggeredByHitDelay;             // 0x00D0(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         M_fWeakStateTriggeredByHitDelay;                   // 0x00D4(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
};
static_assert(alignof(FBossData_AnimData) == 0x000008, "Wrong alignment on FBossData_AnimData");
static_assert(sizeof(FBossData_AnimData) == 0x0000D8, "Wrong size on FBossData_AnimData");
static_assert(offsetof(FBossData_AnimData, M_fAnimationLength_CallReinforcements) == 0x000040, "Member 'FBossData_AnimData::M_fAnimationLength_CallReinforcements' has a wrong offset!");
static_assert(offsetof(FBossData_AnimData, M_fAnimationLength_Leap) == 0x000044, "Member 'FBossData_AnimData::M_fAnimationLength_Leap' has a wrong offset!");
static_assert(offsetof(FBossData_AnimData, M_fAnimationLength_Stomp) == 0x000048, "Member 'FBossData_AnimData::M_fAnimationLength_Stomp' has a wrong offset!");
static_assert(offsetof(FBossData_AnimData, M_fAnimationLength_ChargeEnd) == 0x00004C, "Member 'FBossData_AnimData::M_fAnimationLength_ChargeEnd' has a wrong offset!");
static_assert(offsetof(FBossData_AnimData, M_fAnimationLength_KnockDown) == 0x000050, "Member 'FBossData_AnimData::M_fAnimationLength_KnockDown' has a wrong offset!");
static_assert(offsetof(FBossData_AnimData, M_fAnimationLength_StandUp) == 0x000054, "Member 'FBossData_AnimData::M_fAnimationLength_StandUp' has a wrong offset!");
static_assert(offsetof(FBossData_AnimData, M_fAnimationLength_Enraged) == 0x000058, "Member 'FBossData_AnimData::M_fAnimationLength_Enraged' has a wrong offset!");
static_assert(offsetof(FBossData_AnimData, M_fAnimationDelay_RetractMissiles) == 0x00005C, "Member 'FBossData_AnimData::M_fAnimationDelay_RetractMissiles' has a wrong offset!");
static_assert(offsetof(FBossData_AnimData, M_fLevitationHeight) == 0x000070, "Member 'FBossData_AnimData::M_fLevitationHeight' has a wrong offset!");
static_assert(offsetof(FBossData_AnimData, M_fEvasionTargetRotationDelay) == 0x000074, "Member 'FBossData_AnimData::M_fEvasionTargetRotationDelay' has a wrong offset!");
static_assert(offsetof(FBossData_AnimData, M_fMaxHeight_Evasion) == 0x000078, "Member 'FBossData_AnimData::M_fMaxHeight_Evasion' has a wrong offset!");
static_assert(offsetof(FBossData_AnimData, M_fMaxHeight_InnerRadius) == 0x00007C, "Member 'FBossData_AnimData::M_fMaxHeight_InnerRadius' has a wrong offset!");
static_assert(offsetof(FBossData_AnimData, M_fMaxHeight_OuterRadius) == 0x000080, "Member 'FBossData_AnimData::M_fMaxHeight_OuterRadius' has a wrong offset!");
static_assert(offsetof(FBossData_AnimData, M_fActionTelegraphTime_Evasion) == 0x000084, "Member 'FBossData_AnimData::M_fActionTelegraphTime_Evasion' has a wrong offset!");
static_assert(offsetof(FBossData_AnimData, M_fEvasionAnimationLength) == 0x000088, "Member 'FBossData_AnimData::M_fEvasionAnimationLength' has a wrong offset!");
static_assert(offsetof(FBossData_AnimData, M_fAction_Attack360_StartDelay) == 0x00008C, "Member 'FBossData_AnimData::M_fAction_Attack360_StartDelay' has a wrong offset!");
static_assert(offsetof(FBossData_AnimData, M_fAction_Attack360_StopDelay) == 0x000090, "Member 'FBossData_AnimData::M_fAction_Attack360_StopDelay' has a wrong offset!");
static_assert(offsetof(FBossData_AnimData, M_fAction_TornadoStartDelay) == 0x000094, "Member 'FBossData_AnimData::M_fAction_TornadoStartDelay' has a wrong offset!");
static_assert(offsetof(FBossData_AnimData, M_fAction_TornadoStopDelay) == 0x000098, "Member 'FBossData_AnimData::M_fAction_TornadoStopDelay' has a wrong offset!");
static_assert(offsetof(FBossData_AnimData, M_fAnimationDelay_NasalProbe_Start) == 0x00009C, "Member 'FBossData_AnimData::M_fAnimationDelay_NasalProbe_Start' has a wrong offset!");
static_assert(offsetof(FBossData_AnimData, M_fAnimationDelay_NasalProbe_End) == 0x0000A0, "Member 'FBossData_AnimData::M_fAnimationDelay_NasalProbe_End' has a wrong offset!");
static_assert(offsetof(FBossData_AnimData, M_fAnimationDelay_NasalProbeCharge) == 0x0000A4, "Member 'FBossData_AnimData::M_fAnimationDelay_NasalProbeCharge' has a wrong offset!");
static_assert(offsetof(FBossData_AnimData, M_fAnimationLength_NasalProbeShot) == 0x0000A8, "Member 'FBossData_AnimData::M_fAnimationLength_NasalProbeShot' has a wrong offset!");
static_assert(offsetof(FBossData_AnimData, M_bIsActivelyDrainingPSI) == 0x0000AC, "Member 'FBossData_AnimData::M_bIsActivelyDrainingPSI' has a wrong offset!");
static_assert(offsetof(FBossData_AnimData, M_bIsUnderCover) == 0x0000AD, "Member 'FBossData_AnimData::M_bIsUnderCover' has a wrong offset!");
static_assert(offsetof(FBossData_AnimData, M_bIsTakingDamage) == 0x0000AE, "Member 'FBossData_AnimData::M_bIsTakingDamage' has a wrong offset!");
static_assert(offsetof(FBossData_AnimData, M_bIsShootingBeam) == 0x0000AF, "Member 'FBossData_AnimData::M_bIsShootingBeam' has a wrong offset!");
static_assert(offsetof(FBossData_AnimData, M_eBeamAttackPhase) == 0x0000B0, "Member 'FBossData_AnimData::M_eBeamAttackPhase' has a wrong offset!");
static_assert(offsetof(FBossData_AnimData, M_fTurnInPlacePreDelay) == 0x0000C0, "Member 'FBossData_AnimData::M_fTurnInPlacePreDelay' has a wrong offset!");
static_assert(offsetof(FBossData_AnimData, M_fTurnInPlacePostDelay) == 0x0000C4, "Member 'FBossData_AnimData::M_fTurnInPlacePostDelay' has a wrong offset!");
static_assert(offsetof(FBossData_AnimData, M_fTurnInPlaceDuration) == 0x0000C8, "Member 'FBossData_AnimData::M_fTurnInPlaceDuration' has a wrong offset!");
static_assert(offsetof(FBossData_AnimData, M_fPhaseTransitionTriggeredByHitDelay) == 0x0000D0, "Member 'FBossData_AnimData::M_fPhaseTransitionTriggeredByHitDelay' has a wrong offset!");
static_assert(offsetof(FBossData_AnimData, M_fWeakStateTriggeredByHitDelay) == 0x0000D4, "Member 'FBossData_AnimData::M_fWeakStateTriggeredByHitDelay' has a wrong offset!");

// ScriptStruct BFGCore.BFGChallengeInfo
// 0x0040 (0x0040 - 0x0000)
struct FBFGChallengeInfo final
{
public:
	int32                                         M_iChallengeHighScore;                             // 0x0000(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         M_iCurrentScore;                                   // 0x0004(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FTimespan                              M_fChallengeTime;                                  // 0x0008(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         M_iRateScore;                                      // 0x0010(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_14[0x4];                                       // 0x0014(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class FText                                   M_strChallengeName;                                // 0x0018(0x0018)(BlueprintVisible, BlueprintReadOnly, NativeAccessSpecifierPublic)
	int32                                         M_iMaxStarUnlockedOld;                             // 0x0030(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         M_iMaxStarUnlockedNew;                             // 0x0034(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         M_iMaxStarCurrentScore;                            // 0x0038(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          M_bSucceeded;                                      // 0x003C(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EBFGChallengeType                             M_eType;                                           // 0x003D(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_3E[0x2];                                       // 0x003E(0x0002)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FBFGChallengeInfo) == 0x000008, "Wrong alignment on FBFGChallengeInfo");
static_assert(sizeof(FBFGChallengeInfo) == 0x000040, "Wrong size on FBFGChallengeInfo");
static_assert(offsetof(FBFGChallengeInfo, M_iChallengeHighScore) == 0x000000, "Member 'FBFGChallengeInfo::M_iChallengeHighScore' has a wrong offset!");
static_assert(offsetof(FBFGChallengeInfo, M_iCurrentScore) == 0x000004, "Member 'FBFGChallengeInfo::M_iCurrentScore' has a wrong offset!");
static_assert(offsetof(FBFGChallengeInfo, M_fChallengeTime) == 0x000008, "Member 'FBFGChallengeInfo::M_fChallengeTime' has a wrong offset!");
static_assert(offsetof(FBFGChallengeInfo, M_iRateScore) == 0x000010, "Member 'FBFGChallengeInfo::M_iRateScore' has a wrong offset!");
static_assert(offsetof(FBFGChallengeInfo, M_strChallengeName) == 0x000018, "Member 'FBFGChallengeInfo::M_strChallengeName' has a wrong offset!");
static_assert(offsetof(FBFGChallengeInfo, M_iMaxStarUnlockedOld) == 0x000030, "Member 'FBFGChallengeInfo::M_iMaxStarUnlockedOld' has a wrong offset!");
static_assert(offsetof(FBFGChallengeInfo, M_iMaxStarUnlockedNew) == 0x000034, "Member 'FBFGChallengeInfo::M_iMaxStarUnlockedNew' has a wrong offset!");
static_assert(offsetof(FBFGChallengeInfo, M_iMaxStarCurrentScore) == 0x000038, "Member 'FBFGChallengeInfo::M_iMaxStarCurrentScore' has a wrong offset!");
static_assert(offsetof(FBFGChallengeInfo, M_bSucceeded) == 0x00003C, "Member 'FBFGChallengeInfo::M_bSucceeded' has a wrong offset!");
static_assert(offsetof(FBFGChallengeInfo, M_eType) == 0x00003D, "Member 'FBFGChallengeInfo::M_eType' has a wrong offset!");

// ScriptStruct BFGCore.MetaPattern_Roboprez
// 0x0038 (0x0060 - 0x0028)
struct FMetaPattern_Roboprez final : public FMetaPattern
{
public:
	TSubclassOf<class ABFGPattern_Beam>           M_pBeam;                                           // 0x0028(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TSubclassOf<class ABFGPattern_Projectile>     M_pRocketsMGLeft;                                  // 0x0030(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TSubclassOf<class ABFGPattern_Projectile>     M_pRocketsMGRight;                                 // 0x0038(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TSubclassOf<class ABFGPattern_AOE>            M_pRocketsAOELeft;                                 // 0x0040(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TSubclassOf<class ABFGPattern_AOE>            M_pAirMineLauncherRight;                           // 0x0048(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TSubclassOf<class ABFGPattern_Projectile>     M_pSeekingMissileLeft;                             // 0x0050(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TSubclassOf<class ABFGPattern_Projectile>     M_pSeekingMissileRight;                            // 0x0058(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FMetaPattern_Roboprez) == 0x000008, "Wrong alignment on FMetaPattern_Roboprez");
static_assert(sizeof(FMetaPattern_Roboprez) == 0x000060, "Wrong size on FMetaPattern_Roboprez");
static_assert(offsetof(FMetaPattern_Roboprez, M_pBeam) == 0x000028, "Member 'FMetaPattern_Roboprez::M_pBeam' has a wrong offset!");
static_assert(offsetof(FMetaPattern_Roboprez, M_pRocketsMGLeft) == 0x000030, "Member 'FMetaPattern_Roboprez::M_pRocketsMGLeft' has a wrong offset!");
static_assert(offsetof(FMetaPattern_Roboprez, M_pRocketsMGRight) == 0x000038, "Member 'FMetaPattern_Roboprez::M_pRocketsMGRight' has a wrong offset!");
static_assert(offsetof(FMetaPattern_Roboprez, M_pRocketsAOELeft) == 0x000040, "Member 'FMetaPattern_Roboprez::M_pRocketsAOELeft' has a wrong offset!");
static_assert(offsetof(FMetaPattern_Roboprez, M_pAirMineLauncherRight) == 0x000048, "Member 'FMetaPattern_Roboprez::M_pAirMineLauncherRight' has a wrong offset!");
static_assert(offsetof(FMetaPattern_Roboprez, M_pSeekingMissileLeft) == 0x000050, "Member 'FMetaPattern_Roboprez::M_pSeekingMissileLeft' has a wrong offset!");
static_assert(offsetof(FMetaPattern_Roboprez, M_pSeekingMissileRight) == 0x000058, "Member 'FMetaPattern_Roboprez::M_pSeekingMissileRight' has a wrong offset!");

// ScriptStruct BFGCore.MetaPattern_Silhouette
// 0x0020 (0x0048 - 0x0028)
struct FMetaPattern_Silhouette final : public FMetaPattern
{
public:
	TSubclassOf<class ABFGPattern_Projectile>     M_pAtomizerBeam;                                   // 0x0028(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TSubclassOf<class ABFGPattern_AOE>            M_pParticleExploder;                               // 0x0030(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TSubclassOf<class ABFGPattern_Beam>           M_pShockomator;                                    // 0x0038(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bIs360Pattern;                                     // 0x0040(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_41[0x7];                                       // 0x0041(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FMetaPattern_Silhouette) == 0x000008, "Wrong alignment on FMetaPattern_Silhouette");
static_assert(sizeof(FMetaPattern_Silhouette) == 0x000048, "Wrong size on FMetaPattern_Silhouette");
static_assert(offsetof(FMetaPattern_Silhouette, M_pAtomizerBeam) == 0x000028, "Member 'FMetaPattern_Silhouette::M_pAtomizerBeam' has a wrong offset!");
static_assert(offsetof(FMetaPattern_Silhouette, M_pParticleExploder) == 0x000030, "Member 'FMetaPattern_Silhouette::M_pParticleExploder' has a wrong offset!");
static_assert(offsetof(FMetaPattern_Silhouette, M_pShockomator) == 0x000038, "Member 'FMetaPattern_Silhouette::M_pShockomator' has a wrong offset!");
static_assert(offsetof(FMetaPattern_Silhouette, bIs360Pattern) == 0x000040, "Member 'FMetaPattern_Silhouette::bIs360Pattern' has a wrong offset!");

// ScriptStruct BFGCore.MetaPattern_Armquist
// 0x0020 (0x0048 - 0x0028)
struct FMetaPattern_Armquist final : public FMetaPattern
{
public:
	TSubclassOf<class ABFGPattern_Projectile>     M_pMachineGunLeft;                                 // 0x0028(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TSubclassOf<class ABFGPattern_Projectile>     M_pMachineGunRight;                                // 0x0030(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TSubclassOf<class ABFGPattern_AOE>            M_pRocketsLeft;                                    // 0x0038(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TSubclassOf<class ABFGPattern_AOE>            M_pRocketsRight;                                   // 0x0040(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FMetaPattern_Armquist) == 0x000008, "Wrong alignment on FMetaPattern_Armquist");
static_assert(sizeof(FMetaPattern_Armquist) == 0x000048, "Wrong size on FMetaPattern_Armquist");
static_assert(offsetof(FMetaPattern_Armquist, M_pMachineGunLeft) == 0x000028, "Member 'FMetaPattern_Armquist::M_pMachineGunLeft' has a wrong offset!");
static_assert(offsetof(FMetaPattern_Armquist, M_pMachineGunRight) == 0x000030, "Member 'FMetaPattern_Armquist::M_pMachineGunRight' has a wrong offset!");
static_assert(offsetof(FMetaPattern_Armquist, M_pRocketsLeft) == 0x000038, "Member 'FMetaPattern_Armquist::M_pRocketsLeft' has a wrong offset!");
static_assert(offsetof(FMetaPattern_Armquist, M_pRocketsRight) == 0x000040, "Member 'FMetaPattern_Armquist::M_pRocketsRight' has a wrong offset!");

// ScriptStruct BFGCore.BFGNPCDefinitionRow
// 0x0010 (0x0018 - 0x0008)
struct FBFGNPCDefinitionRow final : public FTableRowBase
{
public:
	class FName                                   M_strName;                                         // 0x0008(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TSubclassOf<class AActor>                     M_actorType;                                       // 0x0010(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FBFGNPCDefinitionRow) == 0x000008, "Wrong alignment on FBFGNPCDefinitionRow");
static_assert(sizeof(FBFGNPCDefinitionRow) == 0x000018, "Wrong size on FBFGNPCDefinitionRow");
static_assert(offsetof(FBFGNPCDefinitionRow, M_strName) == 0x000008, "Member 'FBFGNPCDefinitionRow::M_strName' has a wrong offset!");
static_assert(offsetof(FBFGNPCDefinitionRow, M_actorType) == 0x000010, "Member 'FBFGNPCDefinitionRow::M_actorType' has a wrong offset!");

// ScriptStruct BFGCore.BFGObjectiveMarkerGroupContext
// 0x00C8 (0x00C8 - 0x0000)
struct FBFGObjectiveMarkerGroupContext final
{
public:
	uint8                                         Pad_0[0x8];                                        // 0x0000(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	struct FBFGActorBinding                       M_actorBinding;                                    // 0x0008(0x0090)(Transient, NativeAccessSpecifierPublic)
	struct FBFGObjectiveMarkerInfo                M_info;                                            // 0x0098(0x0028)(Transient, ContainsInstancedReference, NativeAccessSpecifierPublic)
	uint8                                         Pad_C0[0x8];                                       // 0x00C0(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FBFGObjectiveMarkerGroupContext) == 0x000008, "Wrong alignment on FBFGObjectiveMarkerGroupContext");
static_assert(sizeof(FBFGObjectiveMarkerGroupContext) == 0x0000C8, "Wrong size on FBFGObjectiveMarkerGroupContext");
static_assert(offsetof(FBFGObjectiveMarkerGroupContext, M_actorBinding) == 0x000008, "Member 'FBFGObjectiveMarkerGroupContext::M_actorBinding' has a wrong offset!");
static_assert(offsetof(FBFGObjectiveMarkerGroupContext, M_info) == 0x000098, "Member 'FBFGObjectiveMarkerGroupContext::M_info' has a wrong offset!");

// ScriptStruct BFGCore.BFGObjectiveMarkerSystemSettings
// 0x0018 (0x0018 - 0x0000)
struct FBFGObjectiveMarkerSystemSettings final
{
public:
	float                                         M_fBeamFadedInDistance;                            // 0x0000(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Config, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         M_fBeamFadedOutDistance;                           // 0x0004(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Config, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         M_fBeamIntensity;                                  // 0x0008(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Config, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         M_fBeamFallOff;                                    // 0x000C(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Config, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         M_fMarkerFadedInDistance;                          // 0x0010(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Config, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         M_fMarkerFadedOutDistance;                         // 0x0014(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Config, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FBFGObjectiveMarkerSystemSettings) == 0x000004, "Wrong alignment on FBFGObjectiveMarkerSystemSettings");
static_assert(sizeof(FBFGObjectiveMarkerSystemSettings) == 0x000018, "Wrong size on FBFGObjectiveMarkerSystemSettings");
static_assert(offsetof(FBFGObjectiveMarkerSystemSettings, M_fBeamFadedInDistance) == 0x000000, "Member 'FBFGObjectiveMarkerSystemSettings::M_fBeamFadedInDistance' has a wrong offset!");
static_assert(offsetof(FBFGObjectiveMarkerSystemSettings, M_fBeamFadedOutDistance) == 0x000004, "Member 'FBFGObjectiveMarkerSystemSettings::M_fBeamFadedOutDistance' has a wrong offset!");
static_assert(offsetof(FBFGObjectiveMarkerSystemSettings, M_fBeamIntensity) == 0x000008, "Member 'FBFGObjectiveMarkerSystemSettings::M_fBeamIntensity' has a wrong offset!");
static_assert(offsetof(FBFGObjectiveMarkerSystemSettings, M_fBeamFallOff) == 0x00000C, "Member 'FBFGObjectiveMarkerSystemSettings::M_fBeamFallOff' has a wrong offset!");
static_assert(offsetof(FBFGObjectiveMarkerSystemSettings, M_fMarkerFadedInDistance) == 0x000010, "Member 'FBFGObjectiveMarkerSystemSettings::M_fMarkerFadedInDistance' has a wrong offset!");
static_assert(offsetof(FBFGObjectiveMarkerSystemSettings, M_fMarkerFadedOutDistance) == 0x000014, "Member 'FBFGObjectiveMarkerSystemSettings::M_fMarkerFadedOutDistance' has a wrong offset!");

// ScriptStruct BFGCore.BFGObjectiveMarkerSettingsEntry
// 0x0068 (0x0068 - 0x0000)
struct FBFGObjectiveMarkerSettingsEntry final
{
public:
	TSoftClassPtr<class UClass>                   M_actorClass;                                      // 0x0000(0x0028)(Edit, BlueprintVisible, BlueprintReadOnly, Config, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FBFGObjectiveMarkerInfoEntry           M_infoEntry;                                       // 0x0028(0x0040)(Edit, BlueprintVisible, BlueprintReadOnly, Config, ContainsInstancedReference, NativeAccessSpecifierPublic)
};
static_assert(alignof(FBFGObjectiveMarkerSettingsEntry) == 0x000008, "Wrong alignment on FBFGObjectiveMarkerSettingsEntry");
static_assert(sizeof(FBFGObjectiveMarkerSettingsEntry) == 0x000068, "Wrong size on FBFGObjectiveMarkerSettingsEntry");
static_assert(offsetof(FBFGObjectiveMarkerSettingsEntry, M_actorClass) == 0x000000, "Member 'FBFGObjectiveMarkerSettingsEntry::M_actorClass' has a wrong offset!");
static_assert(offsetof(FBFGObjectiveMarkerSettingsEntry, M_infoEntry) == 0x000028, "Member 'FBFGObjectiveMarkerSettingsEntry::M_infoEntry' has a wrong offset!");

// ScriptStruct BFGCore.TickObjectiveMarkerFunction
// 0x0008 (0x0078 - 0x0070)
struct FTickObjectiveMarkerFunction final : public FTickFunction
{
public:
	class UBFGObjectiveMarkerSystem*              M_pManager;                                        // 0x0070(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FTickObjectiveMarkerFunction) == 0x000008, "Wrong alignment on FTickObjectiveMarkerFunction");
static_assert(sizeof(FTickObjectiveMarkerFunction) == 0x000078, "Wrong size on FTickObjectiveMarkerFunction");
static_assert(offsetof(FTickObjectiveMarkerFunction, M_pManager) == 0x000070, "Member 'FTickObjectiveMarkerFunction::M_pManager' has a wrong offset!");

// ScriptStruct BFGCore.BFGRespawnInformationData
// 0x0060 (0x0060 - 0x0000)
struct FBFGRespawnInformationData final
{
public:
	EBFGObjectRespawnType                         M_eRespawnType;                                    // 0x0000(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1[0x3];                                        // 0x0001(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	TWeakObjectPtr<class UStaticMesh>             M_pStaticMesh;                                     // 0x0004(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_C[0x4];                                        // 0x000C(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	TSubclassOf<class ABFGBasicVehicle>           M_pVehicleClass;                                   // 0x0010(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          M_bWasPKAble;                                      // 0x0018(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          M_bWasMoveableWithoutPK;                           // 0x0019(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1A[0x6];                                       // 0x001A(0x0006)(Fixing Size After Last Property [ Dumper-7 ])
	struct FTransform                             M_tTransform;                                      // 0x0020(0x0030)(IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
	TWeakObjectPtr<class ULevel>                  M_pLevelOfTheOriginal;                             // 0x0050(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TWeakObjectPtr<class AActor>                  M_pObjectPointer;                                  // 0x0058(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FBFGRespawnInformationData) == 0x000010, "Wrong alignment on FBFGRespawnInformationData");
static_assert(sizeof(FBFGRespawnInformationData) == 0x000060, "Wrong size on FBFGRespawnInformationData");
static_assert(offsetof(FBFGRespawnInformationData, M_eRespawnType) == 0x000000, "Member 'FBFGRespawnInformationData::M_eRespawnType' has a wrong offset!");
static_assert(offsetof(FBFGRespawnInformationData, M_pStaticMesh) == 0x000004, "Member 'FBFGRespawnInformationData::M_pStaticMesh' has a wrong offset!");
static_assert(offsetof(FBFGRespawnInformationData, M_pVehicleClass) == 0x000010, "Member 'FBFGRespawnInformationData::M_pVehicleClass' has a wrong offset!");
static_assert(offsetof(FBFGRespawnInformationData, M_bWasPKAble) == 0x000018, "Member 'FBFGRespawnInformationData::M_bWasPKAble' has a wrong offset!");
static_assert(offsetof(FBFGRespawnInformationData, M_bWasMoveableWithoutPK) == 0x000019, "Member 'FBFGRespawnInformationData::M_bWasMoveableWithoutPK' has a wrong offset!");
static_assert(offsetof(FBFGRespawnInformationData, M_tTransform) == 0x000020, "Member 'FBFGRespawnInformationData::M_tTransform' has a wrong offset!");
static_assert(offsetof(FBFGRespawnInformationData, M_pLevelOfTheOriginal) == 0x000050, "Member 'FBFGRespawnInformationData::M_pLevelOfTheOriginal' has a wrong offset!");
static_assert(offsetof(FBFGRespawnInformationData, M_pObjectPointer) == 0x000058, "Member 'FBFGRespawnInformationData::M_pObjectPointer' has a wrong offset!");

// ScriptStruct BFGCore.BFGObjectRespawnParams
// 0x0098 (0x0098 - 0x0000)
struct FBFGObjectRespawnParams final
{
public:
	bool                                          M_bShouldRespawnStaticObjects;                     // 0x0000(0x0001)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          M_bShouldRespawnBuildings;                         // 0x0001(0x0001)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          M_bForceResetProxies;                              // 0x0002(0x0001)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_3[0x5];                                        // 0x0003(0x0005)(Fixing Size After Last Property [ Dumper-7 ])
	struct FBFGActorBinding                       M_actorBinding_ProxiesToReset;                     // 0x0008(0x0090)(Edit, DisableEditOnInstance, NativeAccessSpecifierPublic)
};
static_assert(alignof(FBFGObjectRespawnParams) == 0x000008, "Wrong alignment on FBFGObjectRespawnParams");
static_assert(sizeof(FBFGObjectRespawnParams) == 0x000098, "Wrong size on FBFGObjectRespawnParams");
static_assert(offsetof(FBFGObjectRespawnParams, M_bShouldRespawnStaticObjects) == 0x000000, "Member 'FBFGObjectRespawnParams::M_bShouldRespawnStaticObjects' has a wrong offset!");
static_assert(offsetof(FBFGObjectRespawnParams, M_bShouldRespawnBuildings) == 0x000001, "Member 'FBFGObjectRespawnParams::M_bShouldRespawnBuildings' has a wrong offset!");
static_assert(offsetof(FBFGObjectRespawnParams, M_bForceResetProxies) == 0x000002, "Member 'FBFGObjectRespawnParams::M_bForceResetProxies' has a wrong offset!");
static_assert(offsetof(FBFGObjectRespawnParams, M_actorBinding_ProxiesToReset) == 0x000008, "Member 'FBFGObjectRespawnParams::M_actorBinding_ProxiesToReset' has a wrong offset!");

// ScriptStruct BFGCore.BFGPatrolPathInfo
// 0x0018 (0x0018 - 0x0000)
struct FBFGPatrolPathInfo final
{
public:
	TArray<struct FBFGPatrolPathInterestPoint>    M_aInterestPoints;                                 // 0x0000(0x0010)(Edit, BlueprintVisible, ZeroConstructor, NativeAccessSpecifierPublic)
	EBFGNPCCharacter_MoveSpeed                    M_moveSpeed;                                       // 0x0010(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_11[0x7];                                       // 0x0011(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FBFGPatrolPathInfo) == 0x000008, "Wrong alignment on FBFGPatrolPathInfo");
static_assert(sizeof(FBFGPatrolPathInfo) == 0x000018, "Wrong size on FBFGPatrolPathInfo");
static_assert(offsetof(FBFGPatrolPathInfo, M_aInterestPoints) == 0x000000, "Member 'FBFGPatrolPathInfo::M_aInterestPoints' has a wrong offset!");
static_assert(offsetof(FBFGPatrolPathInfo, M_moveSpeed) == 0x000010, "Member 'FBFGPatrolPathInfo::M_moveSpeed' has a wrong offset!");

// ScriptStruct BFGCore.BFG_PlayCrowdLifeStationAnimTaskContext
// 0x0030 (0x0030 - 0x0000)
struct FBFG_PlayCrowdLifeStationAnimTaskContext final
{
public:
	class UBFGCrowdLifeStationComponent*          M_pStation;                                        // 0x0000(0x0008)(ExportObject, ZeroConstructor, Transient, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class AAIController*                          M_pController;                                     // 0x0008(0x0008)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UBFGNetworkPathAgent*                   M_pAgent;                                          // 0x0010(0x0008)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UBFGAnimationInstance_Npc*              M_pNPCAnimationInstance;                           // 0x0018(0x0008)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_20[0x8];                                       // 0x0020(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	bool                                          M_bJustSwitchedLOD;                                // 0x0028(0x0001)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EBFGBehaviourState_NPC                        M_eBehaviourState;                                 // 0x0029(0x0001)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          M_bSnapToEntranceOnAbort;                          // 0x002A(0x0001)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2B[0x5];                                       // 0x002B(0x0005)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FBFG_PlayCrowdLifeStationAnimTaskContext) == 0x000008, "Wrong alignment on FBFG_PlayCrowdLifeStationAnimTaskContext");
static_assert(sizeof(FBFG_PlayCrowdLifeStationAnimTaskContext) == 0x000030, "Wrong size on FBFG_PlayCrowdLifeStationAnimTaskContext");
static_assert(offsetof(FBFG_PlayCrowdLifeStationAnimTaskContext, M_pStation) == 0x000000, "Member 'FBFG_PlayCrowdLifeStationAnimTaskContext::M_pStation' has a wrong offset!");
static_assert(offsetof(FBFG_PlayCrowdLifeStationAnimTaskContext, M_pController) == 0x000008, "Member 'FBFG_PlayCrowdLifeStationAnimTaskContext::M_pController' has a wrong offset!");
static_assert(offsetof(FBFG_PlayCrowdLifeStationAnimTaskContext, M_pAgent) == 0x000010, "Member 'FBFG_PlayCrowdLifeStationAnimTaskContext::M_pAgent' has a wrong offset!");
static_assert(offsetof(FBFG_PlayCrowdLifeStationAnimTaskContext, M_pNPCAnimationInstance) == 0x000018, "Member 'FBFG_PlayCrowdLifeStationAnimTaskContext::M_pNPCAnimationInstance' has a wrong offset!");
static_assert(offsetof(FBFG_PlayCrowdLifeStationAnimTaskContext, M_bJustSwitchedLOD) == 0x000028, "Member 'FBFG_PlayCrowdLifeStationAnimTaskContext::M_bJustSwitchedLOD' has a wrong offset!");
static_assert(offsetof(FBFG_PlayCrowdLifeStationAnimTaskContext, M_eBehaviourState) == 0x000029, "Member 'FBFG_PlayCrowdLifeStationAnimTaskContext::M_eBehaviourState' has a wrong offset!");
static_assert(offsetof(FBFG_PlayCrowdLifeStationAnimTaskContext, M_bSnapToEntranceOnAbort) == 0x00002A, "Member 'FBFG_PlayCrowdLifeStationAnimTaskContext::M_bSnapToEntranceOnAbort' has a wrong offset!");

// ScriptStruct BFGCore.BFG_PlayCrowdLifeStationAnim_AnimInfo
// 0x001C (0x001C - 0x0000)
struct FBFG_PlayCrowdLifeStationAnim_AnimInfo final
{
public:
	struct FVector                                M_vLowResAnimTranslation;                          // 0x0000(0x000C)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FRotator                               M_vLowResAnimRotation;                             // 0x000C(0x000C)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
	float                                         M_fLowResAnimationLength;                          // 0x0018(0x0004)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FBFG_PlayCrowdLifeStationAnim_AnimInfo) == 0x000004, "Wrong alignment on FBFG_PlayCrowdLifeStationAnim_AnimInfo");
static_assert(sizeof(FBFG_PlayCrowdLifeStationAnim_AnimInfo) == 0x00001C, "Wrong size on FBFG_PlayCrowdLifeStationAnim_AnimInfo");
static_assert(offsetof(FBFG_PlayCrowdLifeStationAnim_AnimInfo, M_vLowResAnimTranslation) == 0x000000, "Member 'FBFG_PlayCrowdLifeStationAnim_AnimInfo::M_vLowResAnimTranslation' has a wrong offset!");
static_assert(offsetof(FBFG_PlayCrowdLifeStationAnim_AnimInfo, M_vLowResAnimRotation) == 0x00000C, "Member 'FBFG_PlayCrowdLifeStationAnim_AnimInfo::M_vLowResAnimRotation' has a wrong offset!");
static_assert(offsetof(FBFG_PlayCrowdLifeStationAnim_AnimInfo, M_fLowResAnimationLength) == 0x000018, "Member 'FBFG_PlayCrowdLifeStationAnim_AnimInfo::M_fLowResAnimationLength' has a wrong offset!");

// ScriptStruct BFGCore.BFG_PlayCrowdLifeStationAnimTaskMemory
// 0x0140 (0x0140 - 0x0000)
struct FBFG_PlayCrowdLifeStationAnimTaskMemory final
{
public:
	struct FBFGInteractAnimationSequence          M_animationSequence;                               // 0x0000(0x0018)(Transient, NativeAccessSpecifierPublic)
	struct FBFGInteractAnimationData              M_currentAnimData;                                 // 0x0018(0x0060)(Transient, NoDestructor, NativeAccessSpecifierPublic)
	struct FBFGInteractAnimationSequence          M_propActorAnimationSequence;                      // 0x0078(0x0018)(Transient, NativeAccessSpecifierPublic)
	TWeakObjectPtr<class AActor>                  M_pPropActor;                                      // 0x0090(0x0008)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TWeakObjectPtr<class USkeletalMeshComponent>  M_pCachedSkeletonMesh;                             // 0x0098(0x0008)(ExportObject, ZeroConstructor, Transient, InstancedReference, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_A0[0x4];                                       // 0x00A0(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	struct FVector                                M_vSpotLocation;                                   // 0x00A4(0x000C)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                M_vAdjustedSpotLocation;                           // 0x00B0(0x000C)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FRotator                               M_vSpotOrientation;                                // 0x00BC(0x000C)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
	struct FRotator                               M_vSpotExitOrientation;                            // 0x00C8(0x000C)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
	struct FVector                                M_vEntryTranslation;                               // 0x00D4(0x000C)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FRotator                               M_vEntryRotation;                                  // 0x00E0(0x000C)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
	bool                                          M_bEntryTransformSet;                              // 0x00EC(0x0001)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          M_bIsLightWeightActor;                             // 0x00ED(0x0001)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_EE[0x2];                                       // 0x00EE(0x0002)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         M_fTimer;                                          // 0x00F0(0x0004)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          M_bIsInfiniteLoop;                                 // 0x00F4(0x0001)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EBFGAnimation_Interact                        M_eAnimationEntryId;                               // 0x00F5(0x0001)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EBFGAnimation_Interact                        M_eAnimationExitId;                                // 0x00F6(0x0001)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EBFGAnimation_Interact                        M_eAnimationExitAlertedId;                         // 0x00F7(0x0001)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          M_bExitAlreadyRequested;                           // 0x00F8(0x0001)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_F9[0x3];                                       // 0x00F9(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	struct FBFG_PlayCrowdLifeStationAnim_AnimInfo M_entryAnimInfo;                                   // 0x00FC(0x001C)(Transient, NoDestructor, NativeAccessSpecifierPublic)
	struct FBFG_PlayCrowdLifeStationAnim_AnimInfo M_leaveAnimInfo;                                   // 0x0118(0x001C)(Transient, NoDestructor, NativeAccessSpecifierPublic)
	uint8                                         Pad_134[0x4];                                      // 0x0134(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class UDataTable*                             M_pAnimationTable;                                 // 0x0138(0x0008)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FBFG_PlayCrowdLifeStationAnimTaskMemory) == 0x000008, "Wrong alignment on FBFG_PlayCrowdLifeStationAnimTaskMemory");
static_assert(sizeof(FBFG_PlayCrowdLifeStationAnimTaskMemory) == 0x000140, "Wrong size on FBFG_PlayCrowdLifeStationAnimTaskMemory");
static_assert(offsetof(FBFG_PlayCrowdLifeStationAnimTaskMemory, M_animationSequence) == 0x000000, "Member 'FBFG_PlayCrowdLifeStationAnimTaskMemory::M_animationSequence' has a wrong offset!");
static_assert(offsetof(FBFG_PlayCrowdLifeStationAnimTaskMemory, M_currentAnimData) == 0x000018, "Member 'FBFG_PlayCrowdLifeStationAnimTaskMemory::M_currentAnimData' has a wrong offset!");
static_assert(offsetof(FBFG_PlayCrowdLifeStationAnimTaskMemory, M_propActorAnimationSequence) == 0x000078, "Member 'FBFG_PlayCrowdLifeStationAnimTaskMemory::M_propActorAnimationSequence' has a wrong offset!");
static_assert(offsetof(FBFG_PlayCrowdLifeStationAnimTaskMemory, M_pPropActor) == 0x000090, "Member 'FBFG_PlayCrowdLifeStationAnimTaskMemory::M_pPropActor' has a wrong offset!");
static_assert(offsetof(FBFG_PlayCrowdLifeStationAnimTaskMemory, M_pCachedSkeletonMesh) == 0x000098, "Member 'FBFG_PlayCrowdLifeStationAnimTaskMemory::M_pCachedSkeletonMesh' has a wrong offset!");
static_assert(offsetof(FBFG_PlayCrowdLifeStationAnimTaskMemory, M_vSpotLocation) == 0x0000A4, "Member 'FBFG_PlayCrowdLifeStationAnimTaskMemory::M_vSpotLocation' has a wrong offset!");
static_assert(offsetof(FBFG_PlayCrowdLifeStationAnimTaskMemory, M_vAdjustedSpotLocation) == 0x0000B0, "Member 'FBFG_PlayCrowdLifeStationAnimTaskMemory::M_vAdjustedSpotLocation' has a wrong offset!");
static_assert(offsetof(FBFG_PlayCrowdLifeStationAnimTaskMemory, M_vSpotOrientation) == 0x0000BC, "Member 'FBFG_PlayCrowdLifeStationAnimTaskMemory::M_vSpotOrientation' has a wrong offset!");
static_assert(offsetof(FBFG_PlayCrowdLifeStationAnimTaskMemory, M_vSpotExitOrientation) == 0x0000C8, "Member 'FBFG_PlayCrowdLifeStationAnimTaskMemory::M_vSpotExitOrientation' has a wrong offset!");
static_assert(offsetof(FBFG_PlayCrowdLifeStationAnimTaskMemory, M_vEntryTranslation) == 0x0000D4, "Member 'FBFG_PlayCrowdLifeStationAnimTaskMemory::M_vEntryTranslation' has a wrong offset!");
static_assert(offsetof(FBFG_PlayCrowdLifeStationAnimTaskMemory, M_vEntryRotation) == 0x0000E0, "Member 'FBFG_PlayCrowdLifeStationAnimTaskMemory::M_vEntryRotation' has a wrong offset!");
static_assert(offsetof(FBFG_PlayCrowdLifeStationAnimTaskMemory, M_bEntryTransformSet) == 0x0000EC, "Member 'FBFG_PlayCrowdLifeStationAnimTaskMemory::M_bEntryTransformSet' has a wrong offset!");
static_assert(offsetof(FBFG_PlayCrowdLifeStationAnimTaskMemory, M_bIsLightWeightActor) == 0x0000ED, "Member 'FBFG_PlayCrowdLifeStationAnimTaskMemory::M_bIsLightWeightActor' has a wrong offset!");
static_assert(offsetof(FBFG_PlayCrowdLifeStationAnimTaskMemory, M_fTimer) == 0x0000F0, "Member 'FBFG_PlayCrowdLifeStationAnimTaskMemory::M_fTimer' has a wrong offset!");
static_assert(offsetof(FBFG_PlayCrowdLifeStationAnimTaskMemory, M_bIsInfiniteLoop) == 0x0000F4, "Member 'FBFG_PlayCrowdLifeStationAnimTaskMemory::M_bIsInfiniteLoop' has a wrong offset!");
static_assert(offsetof(FBFG_PlayCrowdLifeStationAnimTaskMemory, M_eAnimationEntryId) == 0x0000F5, "Member 'FBFG_PlayCrowdLifeStationAnimTaskMemory::M_eAnimationEntryId' has a wrong offset!");
static_assert(offsetof(FBFG_PlayCrowdLifeStationAnimTaskMemory, M_eAnimationExitId) == 0x0000F6, "Member 'FBFG_PlayCrowdLifeStationAnimTaskMemory::M_eAnimationExitId' has a wrong offset!");
static_assert(offsetof(FBFG_PlayCrowdLifeStationAnimTaskMemory, M_eAnimationExitAlertedId) == 0x0000F7, "Member 'FBFG_PlayCrowdLifeStationAnimTaskMemory::M_eAnimationExitAlertedId' has a wrong offset!");
static_assert(offsetof(FBFG_PlayCrowdLifeStationAnimTaskMemory, M_bExitAlreadyRequested) == 0x0000F8, "Member 'FBFG_PlayCrowdLifeStationAnimTaskMemory::M_bExitAlreadyRequested' has a wrong offset!");
static_assert(offsetof(FBFG_PlayCrowdLifeStationAnimTaskMemory, M_entryAnimInfo) == 0x0000FC, "Member 'FBFG_PlayCrowdLifeStationAnimTaskMemory::M_entryAnimInfo' has a wrong offset!");
static_assert(offsetof(FBFG_PlayCrowdLifeStationAnimTaskMemory, M_leaveAnimInfo) == 0x000118, "Member 'FBFG_PlayCrowdLifeStationAnimTaskMemory::M_leaveAnimInfo' has a wrong offset!");
static_assert(offsetof(FBFG_PlayCrowdLifeStationAnimTaskMemory, M_pAnimationTable) == 0x000138, "Member 'FBFG_PlayCrowdLifeStationAnimTaskMemory::M_pAnimationTable' has a wrong offset!");

// ScriptStruct BFGCore.BFGVehicleObstacleAvoidingAgent
// 0x01C0 (0x01C0 - 0x0000)
struct FBFGVehicleObstacleAvoidingAgent final
{
public:
	class UBFGNetworkPathAgent_Vehicle*           M_pAgent;                                          // 0x0000(0x0008)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         M_fAgentWidth;                                     // 0x0008(0x0004)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         M_fAgentLength;                                    // 0x000C(0x0004)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UBFGNetworkPathIntersection*            M_pIntersection;                                   // 0x0010(0x0008)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UBFGNetworkPath*                        M_pCurrentPath;                                    // 0x0018(0x0008)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FBFGSplineLocationTracker              M_vTransitionTracker;                              // 0x0020(0x0150)(Transient, NativeAccessSpecifierPublic)
	bool                                          M_bIsTransitionTrackerValid;                       // 0x0170(0x0001)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          M_bIsInTransition;                                 // 0x0171(0x0001)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_172[0x2];                                      // 0x0172(0x0002)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         M_fCurrentDistanceAlongSpline;                     // 0x0174(0x0004)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         M_fRemainingDistance;                              // 0x0178(0x0004)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         M_fCurrentOffsetFromCenter;                        // 0x017C(0x0004)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         M_fCurrentPathWidth;                               // 0x0180(0x0004)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         M_fLeftSpace;                                      // 0x0184(0x0004)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         M_fRightSpace;                                     // 0x0188(0x0004)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         M_fHalfPathWidth;                                  // 0x018C(0x0004)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         M_fSpeed;                                          // 0x0190(0x0004)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         M_fRequestedOffset;                                // 0x0194(0x0004)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         M_fRecommendedMaxSpeed;                            // 0x0198(0x0004)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EBFGNetworkPathAgentPriorityLevel             M_ePriority;                                       // 0x019C(0x0001)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EBFGNetworkAgentAvoidanceStatus               M_eStatus;                                         // 0x019D(0x0001)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EBFGNetworkAgentPathCenterMode                M_eCenterMode;                                     // 0x019E(0x0001)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_19F[0x1];                                      // 0x019F(0x0001)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         M_fAdjustedObstacleRelativeDistance;               // 0x01A0(0x0004)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1A4[0x4];                                      // 0x01A4(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<struct FBFGVehicleObstacleCorridor>    M_availableCorridors;                              // 0x01A8(0x0010)(ZeroConstructor, Transient, NativeAccessSpecifierPublic)
	uint8                                         Pad_1B8[0x8];                                      // 0x01B8(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FBFGVehicleObstacleAvoidingAgent) == 0x000010, "Wrong alignment on FBFGVehicleObstacleAvoidingAgent");
static_assert(sizeof(FBFGVehicleObstacleAvoidingAgent) == 0x0001C0, "Wrong size on FBFGVehicleObstacleAvoidingAgent");
static_assert(offsetof(FBFGVehicleObstacleAvoidingAgent, M_pAgent) == 0x000000, "Member 'FBFGVehicleObstacleAvoidingAgent::M_pAgent' has a wrong offset!");
static_assert(offsetof(FBFGVehicleObstacleAvoidingAgent, M_fAgentWidth) == 0x000008, "Member 'FBFGVehicleObstacleAvoidingAgent::M_fAgentWidth' has a wrong offset!");
static_assert(offsetof(FBFGVehicleObstacleAvoidingAgent, M_fAgentLength) == 0x00000C, "Member 'FBFGVehicleObstacleAvoidingAgent::M_fAgentLength' has a wrong offset!");
static_assert(offsetof(FBFGVehicleObstacleAvoidingAgent, M_pIntersection) == 0x000010, "Member 'FBFGVehicleObstacleAvoidingAgent::M_pIntersection' has a wrong offset!");
static_assert(offsetof(FBFGVehicleObstacleAvoidingAgent, M_pCurrentPath) == 0x000018, "Member 'FBFGVehicleObstacleAvoidingAgent::M_pCurrentPath' has a wrong offset!");
static_assert(offsetof(FBFGVehicleObstacleAvoidingAgent, M_vTransitionTracker) == 0x000020, "Member 'FBFGVehicleObstacleAvoidingAgent::M_vTransitionTracker' has a wrong offset!");
static_assert(offsetof(FBFGVehicleObstacleAvoidingAgent, M_bIsTransitionTrackerValid) == 0x000170, "Member 'FBFGVehicleObstacleAvoidingAgent::M_bIsTransitionTrackerValid' has a wrong offset!");
static_assert(offsetof(FBFGVehicleObstacleAvoidingAgent, M_bIsInTransition) == 0x000171, "Member 'FBFGVehicleObstacleAvoidingAgent::M_bIsInTransition' has a wrong offset!");
static_assert(offsetof(FBFGVehicleObstacleAvoidingAgent, M_fCurrentDistanceAlongSpline) == 0x000174, "Member 'FBFGVehicleObstacleAvoidingAgent::M_fCurrentDistanceAlongSpline' has a wrong offset!");
static_assert(offsetof(FBFGVehicleObstacleAvoidingAgent, M_fRemainingDistance) == 0x000178, "Member 'FBFGVehicleObstacleAvoidingAgent::M_fRemainingDistance' has a wrong offset!");
static_assert(offsetof(FBFGVehicleObstacleAvoidingAgent, M_fCurrentOffsetFromCenter) == 0x00017C, "Member 'FBFGVehicleObstacleAvoidingAgent::M_fCurrentOffsetFromCenter' has a wrong offset!");
static_assert(offsetof(FBFGVehicleObstacleAvoidingAgent, M_fCurrentPathWidth) == 0x000180, "Member 'FBFGVehicleObstacleAvoidingAgent::M_fCurrentPathWidth' has a wrong offset!");
static_assert(offsetof(FBFGVehicleObstacleAvoidingAgent, M_fLeftSpace) == 0x000184, "Member 'FBFGVehicleObstacleAvoidingAgent::M_fLeftSpace' has a wrong offset!");
static_assert(offsetof(FBFGVehicleObstacleAvoidingAgent, M_fRightSpace) == 0x000188, "Member 'FBFGVehicleObstacleAvoidingAgent::M_fRightSpace' has a wrong offset!");
static_assert(offsetof(FBFGVehicleObstacleAvoidingAgent, M_fHalfPathWidth) == 0x00018C, "Member 'FBFGVehicleObstacleAvoidingAgent::M_fHalfPathWidth' has a wrong offset!");
static_assert(offsetof(FBFGVehicleObstacleAvoidingAgent, M_fSpeed) == 0x000190, "Member 'FBFGVehicleObstacleAvoidingAgent::M_fSpeed' has a wrong offset!");
static_assert(offsetof(FBFGVehicleObstacleAvoidingAgent, M_fRequestedOffset) == 0x000194, "Member 'FBFGVehicleObstacleAvoidingAgent::M_fRequestedOffset' has a wrong offset!");
static_assert(offsetof(FBFGVehicleObstacleAvoidingAgent, M_fRecommendedMaxSpeed) == 0x000198, "Member 'FBFGVehicleObstacleAvoidingAgent::M_fRecommendedMaxSpeed' has a wrong offset!");
static_assert(offsetof(FBFGVehicleObstacleAvoidingAgent, M_ePriority) == 0x00019C, "Member 'FBFGVehicleObstacleAvoidingAgent::M_ePriority' has a wrong offset!");
static_assert(offsetof(FBFGVehicleObstacleAvoidingAgent, M_eStatus) == 0x00019D, "Member 'FBFGVehicleObstacleAvoidingAgent::M_eStatus' has a wrong offset!");
static_assert(offsetof(FBFGVehicleObstacleAvoidingAgent, M_eCenterMode) == 0x00019E, "Member 'FBFGVehicleObstacleAvoidingAgent::M_eCenterMode' has a wrong offset!");
static_assert(offsetof(FBFGVehicleObstacleAvoidingAgent, M_fAdjustedObstacleRelativeDistance) == 0x0001A0, "Member 'FBFGVehicleObstacleAvoidingAgent::M_fAdjustedObstacleRelativeDistance' has a wrong offset!");
static_assert(offsetof(FBFGVehicleObstacleAvoidingAgent, M_availableCorridors) == 0x0001A8, "Member 'FBFGVehicleObstacleAvoidingAgent::M_availableCorridors' has a wrong offset!");

// ScriptStruct BFGCore.BFGVehicleObstacleAvoidanceHelper
// 0x02B0 (0x02B0 - 0x0000)
struct FBFGVehicleObstacleAvoidanceHelper final
{
public:
	uint8                                         Pad_0[0x10];                                       // 0x0000(0x0010)(Fixing Size After Last Property [ Dumper-7 ])
	struct FBFGVehicleObstacleAvoidingAgent       M_avoidingAgent;                                   // 0x0010(0x01C0)(Transient, NativeAccessSpecifierPublic)
	TArray<struct FBFGVehicleObstacleAvoidanceCandidate> M_aCandidates;                                     // 0x01D0(0x0010)(ZeroConstructor, Transient, NativeAccessSpecifierPublic)
	TArray<int32>                                 M_aHighPriorityCandidates;                         // 0x01E0(0x0010)(ZeroConstructor, Transient, NativeAccessSpecifierPublic)
	class UBFGNetworkPathAgent*                   M_pBlockingAgent;                                  // 0x01F0(0x0008)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class AActor*                                 M_pBlockingActor;                                  // 0x01F8(0x0008)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         M_fRelativeDistance;                               // 0x0200(0x0004)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         M_fMaxRightOffset;                                 // 0x0204(0x0004)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         M_fMaxLeftOffset;                                  // 0x0208(0x0004)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          M_bHasObstacle;                                    // 0x020C(0x0001)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_20D[0x3];                                      // 0x020D(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         M_fRequestedOffset;                                // 0x0210(0x0004)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         M_fRecommendedMaxSpeed;                            // 0x0214(0x0004)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EBFGNetworkAgentPathCenterMode                M_eCenterMode;                                     // 0x0218(0x0001)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EBFGNetworkAgentAvoidanceStatus               M_eStatus;                                         // 0x0219(0x0001)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_21A[0x2];                                      // 0x021A(0x0002)(Fixing Size After Last Property [ Dumper-7 ])
	int32                                         M_iFaceToFaceAgentIndex;                           // 0x021C(0x0004)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         M_iBestCandidateIndex;                             // 0x0220(0x0004)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         M_fCurrentPathNeutralOffset;                       // 0x0224(0x0004)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         M_fMaxRelevantDistance;                            // 0x0228(0x0004)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_22C[0x4];                                      // 0x022C(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<int32>                                 M_aOtherNearbyObstacles;                           // 0x0230(0x0010)(ZeroConstructor, Transient, NativeAccessSpecifierPublic)
	uint8                                         Pad_240[0x70];                                     // 0x0240(0x0070)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FBFGVehicleObstacleAvoidanceHelper) == 0x000010, "Wrong alignment on FBFGVehicleObstacleAvoidanceHelper");
static_assert(sizeof(FBFGVehicleObstacleAvoidanceHelper) == 0x0002B0, "Wrong size on FBFGVehicleObstacleAvoidanceHelper");
static_assert(offsetof(FBFGVehicleObstacleAvoidanceHelper, M_avoidingAgent) == 0x000010, "Member 'FBFGVehicleObstacleAvoidanceHelper::M_avoidingAgent' has a wrong offset!");
static_assert(offsetof(FBFGVehicleObstacleAvoidanceHelper, M_aCandidates) == 0x0001D0, "Member 'FBFGVehicleObstacleAvoidanceHelper::M_aCandidates' has a wrong offset!");
static_assert(offsetof(FBFGVehicleObstacleAvoidanceHelper, M_aHighPriorityCandidates) == 0x0001E0, "Member 'FBFGVehicleObstacleAvoidanceHelper::M_aHighPriorityCandidates' has a wrong offset!");
static_assert(offsetof(FBFGVehicleObstacleAvoidanceHelper, M_pBlockingAgent) == 0x0001F0, "Member 'FBFGVehicleObstacleAvoidanceHelper::M_pBlockingAgent' has a wrong offset!");
static_assert(offsetof(FBFGVehicleObstacleAvoidanceHelper, M_pBlockingActor) == 0x0001F8, "Member 'FBFGVehicleObstacleAvoidanceHelper::M_pBlockingActor' has a wrong offset!");
static_assert(offsetof(FBFGVehicleObstacleAvoidanceHelper, M_fRelativeDistance) == 0x000200, "Member 'FBFGVehicleObstacleAvoidanceHelper::M_fRelativeDistance' has a wrong offset!");
static_assert(offsetof(FBFGVehicleObstacleAvoidanceHelper, M_fMaxRightOffset) == 0x000204, "Member 'FBFGVehicleObstacleAvoidanceHelper::M_fMaxRightOffset' has a wrong offset!");
static_assert(offsetof(FBFGVehicleObstacleAvoidanceHelper, M_fMaxLeftOffset) == 0x000208, "Member 'FBFGVehicleObstacleAvoidanceHelper::M_fMaxLeftOffset' has a wrong offset!");
static_assert(offsetof(FBFGVehicleObstacleAvoidanceHelper, M_bHasObstacle) == 0x00020C, "Member 'FBFGVehicleObstacleAvoidanceHelper::M_bHasObstacle' has a wrong offset!");
static_assert(offsetof(FBFGVehicleObstacleAvoidanceHelper, M_fRequestedOffset) == 0x000210, "Member 'FBFGVehicleObstacleAvoidanceHelper::M_fRequestedOffset' has a wrong offset!");
static_assert(offsetof(FBFGVehicleObstacleAvoidanceHelper, M_fRecommendedMaxSpeed) == 0x000214, "Member 'FBFGVehicleObstacleAvoidanceHelper::M_fRecommendedMaxSpeed' has a wrong offset!");
static_assert(offsetof(FBFGVehicleObstacleAvoidanceHelper, M_eCenterMode) == 0x000218, "Member 'FBFGVehicleObstacleAvoidanceHelper::M_eCenterMode' has a wrong offset!");
static_assert(offsetof(FBFGVehicleObstacleAvoidanceHelper, M_eStatus) == 0x000219, "Member 'FBFGVehicleObstacleAvoidanceHelper::M_eStatus' has a wrong offset!");
static_assert(offsetof(FBFGVehicleObstacleAvoidanceHelper, M_iFaceToFaceAgentIndex) == 0x00021C, "Member 'FBFGVehicleObstacleAvoidanceHelper::M_iFaceToFaceAgentIndex' has a wrong offset!");
static_assert(offsetof(FBFGVehicleObstacleAvoidanceHelper, M_iBestCandidateIndex) == 0x000220, "Member 'FBFGVehicleObstacleAvoidanceHelper::M_iBestCandidateIndex' has a wrong offset!");
static_assert(offsetof(FBFGVehicleObstacleAvoidanceHelper, M_fCurrentPathNeutralOffset) == 0x000224, "Member 'FBFGVehicleObstacleAvoidanceHelper::M_fCurrentPathNeutralOffset' has a wrong offset!");
static_assert(offsetof(FBFGVehicleObstacleAvoidanceHelper, M_fMaxRelevantDistance) == 0x000228, "Member 'FBFGVehicleObstacleAvoidanceHelper::M_fMaxRelevantDistance' has a wrong offset!");
static_assert(offsetof(FBFGVehicleObstacleAvoidanceHelper, M_aOtherNearbyObstacles) == 0x000230, "Member 'FBFGVehicleObstacleAvoidanceHelper::M_aOtherNearbyObstacles' has a wrong offset!");

// ScriptStruct BFGCore.BFGZapomaticZappedUnitData
// 0x00A0 (0x00A0 - 0x0000)
struct FBFGZapomaticZappedUnitData final
{
public:
	class AActor*                                 M_pTarget;                                         // 0x0000(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class AActor*                                 M_pJumpSourceActor;                                // 0x0008(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_10[0x90];                                      // 0x0010(0x0090)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FBFGZapomaticZappedUnitData) == 0x000008, "Wrong alignment on FBFGZapomaticZappedUnitData");
static_assert(sizeof(FBFGZapomaticZappedUnitData) == 0x0000A0, "Wrong size on FBFGZapomaticZappedUnitData");
static_assert(offsetof(FBFGZapomaticZappedUnitData, M_pTarget) == 0x000000, "Member 'FBFGZapomaticZappedUnitData::M_pTarget' has a wrong offset!");
static_assert(offsetof(FBFGZapomaticZappedUnitData, M_pJumpSourceActor) == 0x000008, "Member 'FBFGZapomaticZappedUnitData::M_pJumpSourceActor' has a wrong offset!");

// ScriptStruct BFGCore.BFGPlayerSettingsWeaponInfo
// 0x00F0 (0x00F0 - 0x0000)
struct FBFGPlayerSettingsWeaponInfo final
{
public:
	struct FSoftClassPath                         WeaponClass;                                       // 0x0000(0x0018)(Edit, BlueprintVisible, ZeroConstructor, NativeAccessSpecifierPublic)
	class FName                                   ParentSocket;                                      // 0x0018(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FSoftClassPath                         M_pOptionIcon;                                     // 0x0020(0x0018)(Edit, BlueprintVisible, ZeroConstructor, NativeAccessSpecifierPublic)
	struct FSlateBrush                            M_oBrush;                                          // 0x0038(0x0088)(Edit, BlueprintVisible, NativeAccessSpecifierPublic)
	class FName                                   M_strInputActionName;                              // 0x00C0(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FBFGPlayerSkill_Tags                   M_UnlockTags;                                      // 0x00C8(0x0018)(Edit, BlueprintVisible, NativeAccessSpecifierPublic)
	class USceneComponent*                        M_pWeaponParentComponent;                          // 0x00E0(0x0008)(Edit, BlueprintVisible, ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EItemValueTypeEnum                            M_ammoType;                                        // 0x00E8(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_E9[0x7];                                       // 0x00E9(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FBFGPlayerSettingsWeaponInfo) == 0x000008, "Wrong alignment on FBFGPlayerSettingsWeaponInfo");
static_assert(sizeof(FBFGPlayerSettingsWeaponInfo) == 0x0000F0, "Wrong size on FBFGPlayerSettingsWeaponInfo");
static_assert(offsetof(FBFGPlayerSettingsWeaponInfo, WeaponClass) == 0x000000, "Member 'FBFGPlayerSettingsWeaponInfo::WeaponClass' has a wrong offset!");
static_assert(offsetof(FBFGPlayerSettingsWeaponInfo, ParentSocket) == 0x000018, "Member 'FBFGPlayerSettingsWeaponInfo::ParentSocket' has a wrong offset!");
static_assert(offsetof(FBFGPlayerSettingsWeaponInfo, M_pOptionIcon) == 0x000020, "Member 'FBFGPlayerSettingsWeaponInfo::M_pOptionIcon' has a wrong offset!");
static_assert(offsetof(FBFGPlayerSettingsWeaponInfo, M_oBrush) == 0x000038, "Member 'FBFGPlayerSettingsWeaponInfo::M_oBrush' has a wrong offset!");
static_assert(offsetof(FBFGPlayerSettingsWeaponInfo, M_strInputActionName) == 0x0000C0, "Member 'FBFGPlayerSettingsWeaponInfo::M_strInputActionName' has a wrong offset!");
static_assert(offsetof(FBFGPlayerSettingsWeaponInfo, M_UnlockTags) == 0x0000C8, "Member 'FBFGPlayerSettingsWeaponInfo::M_UnlockTags' has a wrong offset!");
static_assert(offsetof(FBFGPlayerSettingsWeaponInfo, M_pWeaponParentComponent) == 0x0000E0, "Member 'FBFGPlayerSettingsWeaponInfo::M_pWeaponParentComponent' has a wrong offset!");
static_assert(offsetof(FBFGPlayerSettingsWeaponInfo, M_ammoType) == 0x0000E8, "Member 'FBFGPlayerSettingsWeaponInfo::M_ammoType' has a wrong offset!");

// ScriptStruct BFGCore.BFGVehicleGatheredSpawnNPCData
// 0x0078 (0x0078 - 0x0000)
struct FBFGVehicleGatheredSpawnNPCData final
{
public:
	struct FGameplayTagContainer                  M_gameplayTags;                                    // 0x0000(0x0020)(Transient, NativeAccessSpecifierPublic)
	struct FGameplayTagQuery                      M_query;                                           // 0x0020(0x0048)(Transient, NativeAccessSpecifierPublic)
	int32                                         M_iInitialCount;                                   // 0x0068(0x0004)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         M_remaining;                                       // 0x006C(0x0004)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EBFGBehaviourState_NPC                        M_eBehaviourState;                                 // 0x0070(0x0001)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_71[0x7];                                       // 0x0071(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FBFGVehicleGatheredSpawnNPCData) == 0x000008, "Wrong alignment on FBFGVehicleGatheredSpawnNPCData");
static_assert(sizeof(FBFGVehicleGatheredSpawnNPCData) == 0x000078, "Wrong size on FBFGVehicleGatheredSpawnNPCData");
static_assert(offsetof(FBFGVehicleGatheredSpawnNPCData, M_gameplayTags) == 0x000000, "Member 'FBFGVehicleGatheredSpawnNPCData::M_gameplayTags' has a wrong offset!");
static_assert(offsetof(FBFGVehicleGatheredSpawnNPCData, M_query) == 0x000020, "Member 'FBFGVehicleGatheredSpawnNPCData::M_query' has a wrong offset!");
static_assert(offsetof(FBFGVehicleGatheredSpawnNPCData, M_iInitialCount) == 0x000068, "Member 'FBFGVehicleGatheredSpawnNPCData::M_iInitialCount' has a wrong offset!");
static_assert(offsetof(FBFGVehicleGatheredSpawnNPCData, M_remaining) == 0x00006C, "Member 'FBFGVehicleGatheredSpawnNPCData::M_remaining' has a wrong offset!");
static_assert(offsetof(FBFGVehicleGatheredSpawnNPCData, M_eBehaviourState) == 0x000070, "Member 'FBFGVehicleGatheredSpawnNPCData::M_eBehaviourState' has a wrong offset!");

// ScriptStruct BFGCore.BFGVehicleFleetPopulationDispatcher
// 0x0060 (0x0060 - 0x0000)
struct FBFGVehicleFleetPopulationDispatcher final
{
public:
	struct FBFGPassengersData                     M_passengersData;                                  // 0x0000(0x0038)(Transient, Protected, NativeAccessSpecifierProtected)
	TArray<struct FBFGVehicleFleet_VehicleItemData> M_aVehicleFleet;                                   // 0x0038(0x0010)(ZeroConstructor, Transient, Protected, NativeAccessSpecifierProtected)
	TArray<struct FBFGVehicleGatheredSpawnNPCData> M_aPassengerPopulation;                            // 0x0048(0x0010)(ZeroConstructor, Transient, Protected, NativeAccessSpecifierProtected)
	int32                                         M_iCachedPopulationCount;                          // 0x0058(0x0004)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_5C[0x4];                                       // 0x005C(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FBFGVehicleFleetPopulationDispatcher) == 0x000008, "Wrong alignment on FBFGVehicleFleetPopulationDispatcher");
static_assert(sizeof(FBFGVehicleFleetPopulationDispatcher) == 0x000060, "Wrong size on FBFGVehicleFleetPopulationDispatcher");
static_assert(offsetof(FBFGVehicleFleetPopulationDispatcher, M_passengersData) == 0x000000, "Member 'FBFGVehicleFleetPopulationDispatcher::M_passengersData' has a wrong offset!");
static_assert(offsetof(FBFGVehicleFleetPopulationDispatcher, M_aVehicleFleet) == 0x000038, "Member 'FBFGVehicleFleetPopulationDispatcher::M_aVehicleFleet' has a wrong offset!");
static_assert(offsetof(FBFGVehicleFleetPopulationDispatcher, M_aPassengerPopulation) == 0x000048, "Member 'FBFGVehicleFleetPopulationDispatcher::M_aPassengerPopulation' has a wrong offset!");
static_assert(offsetof(FBFGVehicleFleetPopulationDispatcher, M_iCachedPopulationCount) == 0x000058, "Member 'FBFGVehicleFleetPopulationDispatcher::M_iCachedPopulationCount' has a wrong offset!");

// ScriptStruct BFGCore.BFGPlayerState_UpgradesSetEntry
// 0x0018 (0x0018 - 0x0000)
struct alignas(0x08) FBFGPlayerState_UpgradesSetEntry final
{
public:
	uint8                                         Pad_0[0x8];                                        // 0x0000(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	struct FGameplayTag                           M_oUpgradesUnlockTag;                              // 0x0008(0x0008)(BlueprintVisible, BlueprintReadOnly, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_10[0x8];                                       // 0x0010(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FBFGPlayerState_UpgradesSetEntry) == 0x000008, "Wrong alignment on FBFGPlayerState_UpgradesSetEntry");
static_assert(sizeof(FBFGPlayerState_UpgradesSetEntry) == 0x000018, "Wrong size on FBFGPlayerState_UpgradesSetEntry");
static_assert(offsetof(FBFGPlayerState_UpgradesSetEntry, M_oUpgradesUnlockTag) == 0x000008, "Member 'FBFGPlayerState_UpgradesSetEntry::M_oUpgradesUnlockTag' has a wrong offset!");

// ScriptStruct BFGCore.BFGBeamObstacle
// 0x0020 (0x0020 - 0x0000)
struct FBFGBeamObstacle final
{
public:
	float                                         M_fTimestamp;                                      // 0x0000(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                M_vLocation;                                       // 0x0004(0x000C)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class ABFGDynamicObstacle_Sphere*             M_pObstacle;                                       // 0x0010(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          M_bIsEnd;                                          // 0x0018(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_19[0x7];                                       // 0x0019(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FBFGBeamObstacle) == 0x000008, "Wrong alignment on FBFGBeamObstacle");
static_assert(sizeof(FBFGBeamObstacle) == 0x000020, "Wrong size on FBFGBeamObstacle");
static_assert(offsetof(FBFGBeamObstacle, M_fTimestamp) == 0x000000, "Member 'FBFGBeamObstacle::M_fTimestamp' has a wrong offset!");
static_assert(offsetof(FBFGBeamObstacle, M_vLocation) == 0x000004, "Member 'FBFGBeamObstacle::M_vLocation' has a wrong offset!");
static_assert(offsetof(FBFGBeamObstacle, M_pObstacle) == 0x000010, "Member 'FBFGBeamObstacle::M_pObstacle' has a wrong offset!");
static_assert(offsetof(FBFGBeamObstacle, M_bIsEnd) == 0x000018, "Member 'FBFGBeamObstacle::M_bIsEnd' has a wrong offset!");

// ScriptStruct BFGCore.BFGZapomaticBeamData
// 0x0018 (0x0018 - 0x0000)
struct FBFGZapomaticBeamData final
{
public:
	class AActor*                                 M_pSource;                                         // 0x0000(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class AActor*                                 M_pTarget;                                         // 0x0008(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UBFGEffectContainer*                    M_pEffectContainer;                                // 0x0010(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FBFGZapomaticBeamData) == 0x000008, "Wrong alignment on FBFGZapomaticBeamData");
static_assert(sizeof(FBFGZapomaticBeamData) == 0x000018, "Wrong size on FBFGZapomaticBeamData");
static_assert(offsetof(FBFGZapomaticBeamData, M_pSource) == 0x000000, "Member 'FBFGZapomaticBeamData::M_pSource' has a wrong offset!");
static_assert(offsetof(FBFGZapomaticBeamData, M_pTarget) == 0x000008, "Member 'FBFGZapomaticBeamData::M_pTarget' has a wrong offset!");
static_assert(offsetof(FBFGZapomaticBeamData, M_pEffectContainer) == 0x000010, "Member 'FBFGZapomaticBeamData::M_pEffectContainer' has a wrong offset!");

// ScriptStruct BFGCore.BFGPulseActorData
// 0x0090 (0x0090 - 0x0000)
struct FBFGPulseActorData final
{
public:
	class AActor*                                 M_pActor;                                          // 0x0000(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FHitResult                             M_oHitResult;                                      // 0x0008(0x0088)(IsPlainOldData, NoDestructor, ContainsInstancedReference, NativeAccessSpecifierPublic)
};
static_assert(alignof(FBFGPulseActorData) == 0x000008, "Wrong alignment on FBFGPulseActorData");
static_assert(sizeof(FBFGPulseActorData) == 0x000090, "Wrong size on FBFGPulseActorData");
static_assert(offsetof(FBFGPulseActorData, M_pActor) == 0x000000, "Member 'FBFGPulseActorData::M_pActor' has a wrong offset!");
static_assert(offsetof(FBFGPulseActorData, M_oHitResult) == 0x000008, "Member 'FBFGPulseActorData::M_oHitResult' has a wrong offset!");

// ScriptStruct BFGCore.BFGPulseFieldPulseData
// 0x0038 (0x0038 - 0x0000)
struct FBFGPulseFieldPulseData final
{
public:
	uint8                                         Pad_0[0x20];                                       // 0x0000(0x0020)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<struct FBFGPulseActorData>             M_aHitActors;                                      // 0x0020(0x0010)(ZeroConstructor, ContainsInstancedReference, NativeAccessSpecifierPublic)
	uint8                                         Pad_30[0x8];                                       // 0x0030(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FBFGPulseFieldPulseData) == 0x000008, "Wrong alignment on FBFGPulseFieldPulseData");
static_assert(sizeof(FBFGPulseFieldPulseData) == 0x000038, "Wrong size on FBFGPulseFieldPulseData");
static_assert(offsetof(FBFGPulseFieldPulseData, M_aHitActors) == 0x000020, "Member 'FBFGPulseFieldPulseData::M_aHitActors' has a wrong offset!");

// ScriptStruct BFGCore.BFGQuest_ChallengeStars
// 0x0010 (0x0010 - 0x0000)
struct FBFGQuest_ChallengeStars final
{
public:
	bool                                          M_bHasStars;                                       // 0x0000(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1[0x3];                                        // 0x0001(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	int32                                         M_iFirstThreshold;                                 // 0x0004(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         M_iSecondThreshold;                                // 0x0008(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         M_iThirdThreshold;                                 // 0x000C(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FBFGQuest_ChallengeStars) == 0x000004, "Wrong alignment on FBFGQuest_ChallengeStars");
static_assert(sizeof(FBFGQuest_ChallengeStars) == 0x000010, "Wrong size on FBFGQuest_ChallengeStars");
static_assert(offsetof(FBFGQuest_ChallengeStars, M_bHasStars) == 0x000000, "Member 'FBFGQuest_ChallengeStars::M_bHasStars' has a wrong offset!");
static_assert(offsetof(FBFGQuest_ChallengeStars, M_iFirstThreshold) == 0x000004, "Member 'FBFGQuest_ChallengeStars::M_iFirstThreshold' has a wrong offset!");
static_assert(offsetof(FBFGQuest_ChallengeStars, M_iSecondThreshold) == 0x000008, "Member 'FBFGQuest_ChallengeStars::M_iSecondThreshold' has a wrong offset!");
static_assert(offsetof(FBFGQuest_ChallengeStars, M_iThirdThreshold) == 0x00000C, "Member 'FBFGQuest_ChallengeStars::M_iThirdThreshold' has a wrong offset!");

// ScriptStruct BFGCore.BFGQuest_ElementDefend_Attackers
// 0x0088 (0x0088 - 0x0000)
struct FBFGQuest_ElementDefend_Attackers final
{
public:
	TSoftObjectPtr<class ABFGMissionSpawnManager> M_softPawn;                                        // 0x0000(0x0028)(Edit, BlueprintVisible, BlueprintReadOnly, DisableEditOnInstance, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FBFGQuest_UIProvider                   M_descriptionProvider;                             // 0x0028(0x0050)(Edit, BlueprintVisible, BlueprintReadOnly, DisableEditOnInstance, NativeAccessSpecifierPublic)
	uint8                                         Pad_78[0x10];                                      // 0x0078(0x0010)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FBFGQuest_ElementDefend_Attackers) == 0x000008, "Wrong alignment on FBFGQuest_ElementDefend_Attackers");
static_assert(sizeof(FBFGQuest_ElementDefend_Attackers) == 0x000088, "Wrong size on FBFGQuest_ElementDefend_Attackers");
static_assert(offsetof(FBFGQuest_ElementDefend_Attackers, M_softPawn) == 0x000000, "Member 'FBFGQuest_ElementDefend_Attackers::M_softPawn' has a wrong offset!");
static_assert(offsetof(FBFGQuest_ElementDefend_Attackers, M_descriptionProvider) == 0x000028, "Member 'FBFGQuest_ElementDefend_Attackers::M_descriptionProvider' has a wrong offset!");

// ScriptStruct BFGCore.BFGSplineDistanceHelper
// 0x0120 (0x0120 - 0x0000)
struct FBFGSplineDistanceHelper final
{
public:
	int32                                         M_iPreviousPointIndex;                             // 0x0000(0x0004)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         M_iNextPointIndex;                                 // 0x0004(0x0004)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                M_vSegmentDirection;                               // 0x0008(0x000C)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                M_vPreviousTangent;                                // 0x0014(0x000C)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                M_vPreviousLocation;                               // 0x0020(0x000C)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         M_fRelativeProjectedDistanceToPrevious;            // 0x002C(0x0004)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         M_fDistanceAtStart;                                // 0x0030(0x0004)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                M_vNextTangent;                                    // 0x0034(0x000C)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                M_vNextLocation;                                   // 0x0040(0x000C)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         M_fRelativeProjectedDistanceToNext;                // 0x004C(0x0004)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         M_fDistanceAtEnd;                                  // 0x0050(0x0004)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                M_vLocation;                                       // 0x0054(0x000C)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         M_fLastDistance;                                   // 0x0060(0x0004)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         M_fResultDistance;                                 // 0x0064(0x0004)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         M_fPreviousDistance;                               // 0x0068(0x0004)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         M_fTolerance;                                      // 0x006C(0x0004)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         M_fRangeCurveDistance;                             // 0x0070(0x0004)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         M_iWay;                                            // 0x0074(0x0004)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UBFGNetworkPathComponent*               M_pPath;                                           // 0x0078(0x0008)(ExportObject, ZeroConstructor, Transient, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EBFGNetworkPathLocalization                   M_eLocalization;                                   // 0x0080(0x0001)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          M_bRangeNotFound;                                  // 0x0081(0x0001)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_82[0x6];                                       // 0x0082(0x0006)(Fixing Size After Last Property [ Dumper-7 ])
	struct FSplineCurves                          M_spline;                                          // 0x0088(0x0060)(Transient, NativeAccessSpecifierPublic)
	uint8                                         Pad_E8[0x8];                                       // 0x00E8(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	struct FTransform                             M_Transform;                                       // 0x00F0(0x0030)(Transient, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(FBFGSplineDistanceHelper) == 0x000010, "Wrong alignment on FBFGSplineDistanceHelper");
static_assert(sizeof(FBFGSplineDistanceHelper) == 0x000120, "Wrong size on FBFGSplineDistanceHelper");
static_assert(offsetof(FBFGSplineDistanceHelper, M_iPreviousPointIndex) == 0x000000, "Member 'FBFGSplineDistanceHelper::M_iPreviousPointIndex' has a wrong offset!");
static_assert(offsetof(FBFGSplineDistanceHelper, M_iNextPointIndex) == 0x000004, "Member 'FBFGSplineDistanceHelper::M_iNextPointIndex' has a wrong offset!");
static_assert(offsetof(FBFGSplineDistanceHelper, M_vSegmentDirection) == 0x000008, "Member 'FBFGSplineDistanceHelper::M_vSegmentDirection' has a wrong offset!");
static_assert(offsetof(FBFGSplineDistanceHelper, M_vPreviousTangent) == 0x000014, "Member 'FBFGSplineDistanceHelper::M_vPreviousTangent' has a wrong offset!");
static_assert(offsetof(FBFGSplineDistanceHelper, M_vPreviousLocation) == 0x000020, "Member 'FBFGSplineDistanceHelper::M_vPreviousLocation' has a wrong offset!");
static_assert(offsetof(FBFGSplineDistanceHelper, M_fRelativeProjectedDistanceToPrevious) == 0x00002C, "Member 'FBFGSplineDistanceHelper::M_fRelativeProjectedDistanceToPrevious' has a wrong offset!");
static_assert(offsetof(FBFGSplineDistanceHelper, M_fDistanceAtStart) == 0x000030, "Member 'FBFGSplineDistanceHelper::M_fDistanceAtStart' has a wrong offset!");
static_assert(offsetof(FBFGSplineDistanceHelper, M_vNextTangent) == 0x000034, "Member 'FBFGSplineDistanceHelper::M_vNextTangent' has a wrong offset!");
static_assert(offsetof(FBFGSplineDistanceHelper, M_vNextLocation) == 0x000040, "Member 'FBFGSplineDistanceHelper::M_vNextLocation' has a wrong offset!");
static_assert(offsetof(FBFGSplineDistanceHelper, M_fRelativeProjectedDistanceToNext) == 0x00004C, "Member 'FBFGSplineDistanceHelper::M_fRelativeProjectedDistanceToNext' has a wrong offset!");
static_assert(offsetof(FBFGSplineDistanceHelper, M_fDistanceAtEnd) == 0x000050, "Member 'FBFGSplineDistanceHelper::M_fDistanceAtEnd' has a wrong offset!");
static_assert(offsetof(FBFGSplineDistanceHelper, M_vLocation) == 0x000054, "Member 'FBFGSplineDistanceHelper::M_vLocation' has a wrong offset!");
static_assert(offsetof(FBFGSplineDistanceHelper, M_fLastDistance) == 0x000060, "Member 'FBFGSplineDistanceHelper::M_fLastDistance' has a wrong offset!");
static_assert(offsetof(FBFGSplineDistanceHelper, M_fResultDistance) == 0x000064, "Member 'FBFGSplineDistanceHelper::M_fResultDistance' has a wrong offset!");
static_assert(offsetof(FBFGSplineDistanceHelper, M_fPreviousDistance) == 0x000068, "Member 'FBFGSplineDistanceHelper::M_fPreviousDistance' has a wrong offset!");
static_assert(offsetof(FBFGSplineDistanceHelper, M_fTolerance) == 0x00006C, "Member 'FBFGSplineDistanceHelper::M_fTolerance' has a wrong offset!");
static_assert(offsetof(FBFGSplineDistanceHelper, M_fRangeCurveDistance) == 0x000070, "Member 'FBFGSplineDistanceHelper::M_fRangeCurveDistance' has a wrong offset!");
static_assert(offsetof(FBFGSplineDistanceHelper, M_iWay) == 0x000074, "Member 'FBFGSplineDistanceHelper::M_iWay' has a wrong offset!");
static_assert(offsetof(FBFGSplineDistanceHelper, M_pPath) == 0x000078, "Member 'FBFGSplineDistanceHelper::M_pPath' has a wrong offset!");
static_assert(offsetof(FBFGSplineDistanceHelper, M_eLocalization) == 0x000080, "Member 'FBFGSplineDistanceHelper::M_eLocalization' has a wrong offset!");
static_assert(offsetof(FBFGSplineDistanceHelper, M_bRangeNotFound) == 0x000081, "Member 'FBFGSplineDistanceHelper::M_bRangeNotFound' has a wrong offset!");
static_assert(offsetof(FBFGSplineDistanceHelper, M_spline) == 0x000088, "Member 'FBFGSplineDistanceHelper::M_spline' has a wrong offset!");
static_assert(offsetof(FBFGSplineDistanceHelper, M_Transform) == 0x0000F0, "Member 'FBFGSplineDistanceHelper::M_Transform' has a wrong offset!");

// ScriptStruct BFGCore.BFGQuest_ElementDefend_Defendee
// 0x00B8 (0x00B8 - 0x0000)
struct FBFGQuest_ElementDefend_Defendee final
{
public:
	TSoftObjectPtr<class AActor>                  M_softPawn;                                        // 0x0000(0x0028)(Edit, BlueprintVisible, BlueprintReadOnly, DisableEditOnInstance, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FBFGQuest_UIProvider                   M_descriptionProvider;                             // 0x0028(0x0050)(Edit, BlueprintVisible, BlueprintReadOnly, DisableEditOnInstance, NativeAccessSpecifierPublic)
	struct FBFGObjectiveMarkerInfo                M_markerInfo;                                      // 0x0078(0x0028)(Edit, BlueprintVisible, BlueprintReadOnly, DisableEditOnInstance, ContainsInstancedReference, NativeAccessSpecifierPublic)
	uint8                                         Pad_A0[0x10];                                      // 0x00A0(0x0010)(Fixing Size After Last Property [ Dumper-7 ])
	class UBFGObjectiveMarkerGroup*               M_markerGroup;                                     // 0x00B0(0x0008)(ExportObject, ZeroConstructor, Transient, InstancedReference, IsPlainOldData, NoDestructor, PersistentInstance, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FBFGQuest_ElementDefend_Defendee) == 0x000008, "Wrong alignment on FBFGQuest_ElementDefend_Defendee");
static_assert(sizeof(FBFGQuest_ElementDefend_Defendee) == 0x0000B8, "Wrong size on FBFGQuest_ElementDefend_Defendee");
static_assert(offsetof(FBFGQuest_ElementDefend_Defendee, M_softPawn) == 0x000000, "Member 'FBFGQuest_ElementDefend_Defendee::M_softPawn' has a wrong offset!");
static_assert(offsetof(FBFGQuest_ElementDefend_Defendee, M_descriptionProvider) == 0x000028, "Member 'FBFGQuest_ElementDefend_Defendee::M_descriptionProvider' has a wrong offset!");
static_assert(offsetof(FBFGQuest_ElementDefend_Defendee, M_markerInfo) == 0x000078, "Member 'FBFGQuest_ElementDefend_Defendee::M_markerInfo' has a wrong offset!");
static_assert(offsetof(FBFGQuest_ElementDefend_Defendee, M_markerGroup) == 0x0000B0, "Member 'FBFGQuest_ElementDefend_Defendee::M_markerGroup' has a wrong offset!");

// ScriptStruct BFGCore.BFGQuest_ElementEscort_RuntimeObjective
// 0x0030 (0x0030 - 0x0000)
struct FBFGQuest_ElementEscort_RuntimeObjective final
{
public:
	uint8                                         Pad_0[0x20];                                       // 0x0000(0x0020)(Fixing Size After Last Property [ Dumper-7 ])
	class UBFG_AITask_Escort*                     M_pAITask;                                         // 0x0020(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UBFGVariable*                           M_pTaskVariable;                                   // 0x0028(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FBFGQuest_ElementEscort_RuntimeObjective) == 0x000008, "Wrong alignment on FBFGQuest_ElementEscort_RuntimeObjective");
static_assert(sizeof(FBFGQuest_ElementEscort_RuntimeObjective) == 0x000030, "Wrong size on FBFGQuest_ElementEscort_RuntimeObjective");
static_assert(offsetof(FBFGQuest_ElementEscort_RuntimeObjective, M_pAITask) == 0x000020, "Member 'FBFGQuest_ElementEscort_RuntimeObjective::M_pAITask' has a wrong offset!");
static_assert(offsetof(FBFGQuest_ElementEscort_RuntimeObjective, M_pTaskVariable) == 0x000028, "Member 'FBFGQuest_ElementEscort_RuntimeObjective::M_pTaskVariable' has a wrong offset!");

// ScriptStruct BFGCore.BFGQuest_ElementKill_Actor
// 0x0200 (0x0200 - 0x0000)
struct FBFGQuest_ElementKill_Actor final
{
public:
	struct FBFGActorBinding                       M_actorBinding;                                    // 0x0000(0x0090)(Edit, BlueprintVisible, BlueprintReadOnly, DisableEditOnInstance, NativeAccessSpecifierPublic)
	int32                                         M_iQuantity;                                       // 0x0090(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_94[0x4];                                       // 0x0094(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	struct FGameplayTagQuery                      M_damageCauserTagQuery;                            // 0x0098(0x0048)(Edit, BlueprintVisible, BlueprintReadOnly, DisableEditOnInstance, NativeAccessSpecifierPublic)
	struct FGameplayTagQuery                      M_damageInstigatorTagQuery;                        // 0x00E0(0x0048)(Edit, BlueprintVisible, BlueprintReadOnly, DisableEditOnInstance, NativeAccessSpecifierPublic)
	struct FGameplayTagQuery                      M_damageSourceTagQuery;                            // 0x0128(0x0048)(Edit, BlueprintVisible, BlueprintReadOnly, DisableEditOnInstance, NativeAccessSpecifierPublic)
	struct FBFGQuest_UIProvider                   M_descriptionProvider;                             // 0x0170(0x0050)(Edit, BlueprintVisible, BlueprintReadOnly, DisableEditOnInstance, NativeAccessSpecifierPublic)
	struct FBFGObjectiveMarkerInfo                M_markerInfo;                                      // 0x01C0(0x0028)(Edit, BlueprintVisible, BlueprintReadOnly, DisableEditOnInstance, ContainsInstancedReference, NativeAccessSpecifierPublic)
	TArray<class UBFGEffectBank*>                 M_apEnableEffectBanks;                             // 0x01E8(0x0010)(Edit, ZeroConstructor, DisableEditOnInstance, NativeAccessSpecifierPublic)
	EBFGEffect_Identifier                         M_activateEffect;                                  // 0x01F8(0x0001)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1F9[0x7];                                      // 0x01F9(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FBFGQuest_ElementKill_Actor) == 0x000008, "Wrong alignment on FBFGQuest_ElementKill_Actor");
static_assert(sizeof(FBFGQuest_ElementKill_Actor) == 0x000200, "Wrong size on FBFGQuest_ElementKill_Actor");
static_assert(offsetof(FBFGQuest_ElementKill_Actor, M_actorBinding) == 0x000000, "Member 'FBFGQuest_ElementKill_Actor::M_actorBinding' has a wrong offset!");
static_assert(offsetof(FBFGQuest_ElementKill_Actor, M_iQuantity) == 0x000090, "Member 'FBFGQuest_ElementKill_Actor::M_iQuantity' has a wrong offset!");
static_assert(offsetof(FBFGQuest_ElementKill_Actor, M_damageCauserTagQuery) == 0x000098, "Member 'FBFGQuest_ElementKill_Actor::M_damageCauserTagQuery' has a wrong offset!");
static_assert(offsetof(FBFGQuest_ElementKill_Actor, M_damageInstigatorTagQuery) == 0x0000E0, "Member 'FBFGQuest_ElementKill_Actor::M_damageInstigatorTagQuery' has a wrong offset!");
static_assert(offsetof(FBFGQuest_ElementKill_Actor, M_damageSourceTagQuery) == 0x000128, "Member 'FBFGQuest_ElementKill_Actor::M_damageSourceTagQuery' has a wrong offset!");
static_assert(offsetof(FBFGQuest_ElementKill_Actor, M_descriptionProvider) == 0x000170, "Member 'FBFGQuest_ElementKill_Actor::M_descriptionProvider' has a wrong offset!");
static_assert(offsetof(FBFGQuest_ElementKill_Actor, M_markerInfo) == 0x0001C0, "Member 'FBFGQuest_ElementKill_Actor::M_markerInfo' has a wrong offset!");
static_assert(offsetof(FBFGQuest_ElementKill_Actor, M_apEnableEffectBanks) == 0x0001E8, "Member 'FBFGQuest_ElementKill_Actor::M_apEnableEffectBanks' has a wrong offset!");
static_assert(offsetof(FBFGQuest_ElementKill_Actor, M_activateEffect) == 0x0001F8, "Member 'FBFGQuest_ElementKill_Actor::M_activateEffect' has a wrong offset!");

// ScriptStruct BFGCore.BFGTrafficPathFinder_VisitedPath
// 0x0060 (0x0060 - 0x0000)
struct FBFGTrafficPathFinder_VisitedPath final
{
public:
	UMulticastDelegateProperty_                   M_OnCostDirty;                                     // 0x0000(0x0018)(ZeroConstructor, InstancedReference, NativeAccessSpecifierPublic)
	struct FGuid                                  M_waypointId;                                      // 0x0018(0x0010)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	float                                         M_fCost;                                           // 0x0028(0x0004)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	float                                         M_fOwnCost;                                        // 0x002C(0x0004)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	TArray<struct FGuid>                          M_aPreviousPath;                                   // 0x0030(0x0010)(ZeroConstructor, Transient, NativeAccessSpecifierPrivate)
	bool                                          M_bIsDirty;                                        // 0x0040(0x0001)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_41[0x7];                                       // 0x0041(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	class UBFGTrafficPathFinder_Visitor*          M_pVisitor;                                        // 0x0048(0x0008)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	TArray<struct FGuid>                          M_aCostChangedListeners;                           // 0x0050(0x0010)(ZeroConstructor, Transient, NativeAccessSpecifierPrivate)
};
static_assert(alignof(FBFGTrafficPathFinder_VisitedPath) == 0x000008, "Wrong alignment on FBFGTrafficPathFinder_VisitedPath");
static_assert(sizeof(FBFGTrafficPathFinder_VisitedPath) == 0x000060, "Wrong size on FBFGTrafficPathFinder_VisitedPath");
static_assert(offsetof(FBFGTrafficPathFinder_VisitedPath, M_OnCostDirty) == 0x000000, "Member 'FBFGTrafficPathFinder_VisitedPath::M_OnCostDirty' has a wrong offset!");
static_assert(offsetof(FBFGTrafficPathFinder_VisitedPath, M_waypointId) == 0x000018, "Member 'FBFGTrafficPathFinder_VisitedPath::M_waypointId' has a wrong offset!");
static_assert(offsetof(FBFGTrafficPathFinder_VisitedPath, M_fCost) == 0x000028, "Member 'FBFGTrafficPathFinder_VisitedPath::M_fCost' has a wrong offset!");
static_assert(offsetof(FBFGTrafficPathFinder_VisitedPath, M_fOwnCost) == 0x00002C, "Member 'FBFGTrafficPathFinder_VisitedPath::M_fOwnCost' has a wrong offset!");
static_assert(offsetof(FBFGTrafficPathFinder_VisitedPath, M_aPreviousPath) == 0x000030, "Member 'FBFGTrafficPathFinder_VisitedPath::M_aPreviousPath' has a wrong offset!");
static_assert(offsetof(FBFGTrafficPathFinder_VisitedPath, M_bIsDirty) == 0x000040, "Member 'FBFGTrafficPathFinder_VisitedPath::M_bIsDirty' has a wrong offset!");
static_assert(offsetof(FBFGTrafficPathFinder_VisitedPath, M_pVisitor) == 0x000048, "Member 'FBFGTrafficPathFinder_VisitedPath::M_pVisitor' has a wrong offset!");
static_assert(offsetof(FBFGTrafficPathFinder_VisitedPath, M_aCostChangedListeners) == 0x000050, "Member 'FBFGTrafficPathFinder_VisitedPath::M_aCostChangedListeners' has a wrong offset!");

// ScriptStruct BFGCore.BFGQuest_ElementLocateHint_Layer
// 0x0128 (0x0128 - 0x0000)
struct FBFGQuest_ElementLocateHint_Layer final
{
public:
	int32                                         M_iDisableAfterScanQuantity;                       // 0x0000(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          M_bUseUniqueVOObjectives;                          // 0x0004(0x0001)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          M_bIsSharedLayer;                                  // 0x0005(0x0001)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_6[0x2];                                        // 0x0006(0x0002)(Fixing Size After Last Property [ Dumper-7 ])
	class FName                                   M_strSharedLayerName;                              // 0x0008(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FBFGQuest_UIProvider                   M_descriptionProvider;                             // 0x0010(0x0050)(Edit, BlueprintVisible, BlueprintReadOnly, DisableEditOnInstance, NativeAccessSpecifierPublic)
	struct FBFGActorBinding                       M_areaBinding;                                     // 0x0060(0x0090)(Edit, DisableEditOnInstance, NativeAccessSpecifierPublic)
	struct FBFGObjectiveMarkerInfo                M_markerInfo;                                      // 0x00F0(0x0028)(Edit, BlueprintVisible, BlueprintReadOnly, DisableEditOnInstance, ContainsInstancedReference, NativeAccessSpecifierPublic)
	TArray<struct FBFGQuest_ElementMentalAbility_Overrides> M_aOverrides;                                      // 0x0118(0x0010)(Edit, ZeroConstructor, DisableEditOnInstance, NativeAccessSpecifierPublic)
};
static_assert(alignof(FBFGQuest_ElementLocateHint_Layer) == 0x000008, "Wrong alignment on FBFGQuest_ElementLocateHint_Layer");
static_assert(sizeof(FBFGQuest_ElementLocateHint_Layer) == 0x000128, "Wrong size on FBFGQuest_ElementLocateHint_Layer");
static_assert(offsetof(FBFGQuest_ElementLocateHint_Layer, M_iDisableAfterScanQuantity) == 0x000000, "Member 'FBFGQuest_ElementLocateHint_Layer::M_iDisableAfterScanQuantity' has a wrong offset!");
static_assert(offsetof(FBFGQuest_ElementLocateHint_Layer, M_bUseUniqueVOObjectives) == 0x000004, "Member 'FBFGQuest_ElementLocateHint_Layer::M_bUseUniqueVOObjectives' has a wrong offset!");
static_assert(offsetof(FBFGQuest_ElementLocateHint_Layer, M_bIsSharedLayer) == 0x000005, "Member 'FBFGQuest_ElementLocateHint_Layer::M_bIsSharedLayer' has a wrong offset!");
static_assert(offsetof(FBFGQuest_ElementLocateHint_Layer, M_strSharedLayerName) == 0x000008, "Member 'FBFGQuest_ElementLocateHint_Layer::M_strSharedLayerName' has a wrong offset!");
static_assert(offsetof(FBFGQuest_ElementLocateHint_Layer, M_descriptionProvider) == 0x000010, "Member 'FBFGQuest_ElementLocateHint_Layer::M_descriptionProvider' has a wrong offset!");
static_assert(offsetof(FBFGQuest_ElementLocateHint_Layer, M_areaBinding) == 0x000060, "Member 'FBFGQuest_ElementLocateHint_Layer::M_areaBinding' has a wrong offset!");
static_assert(offsetof(FBFGQuest_ElementLocateHint_Layer, M_markerInfo) == 0x0000F0, "Member 'FBFGQuest_ElementLocateHint_Layer::M_markerInfo' has a wrong offset!");
static_assert(offsetof(FBFGQuest_ElementLocateHint_Layer, M_aOverrides) == 0x000118, "Member 'FBFGQuest_ElementLocateHint_Layer::M_aOverrides' has a wrong offset!");

// ScriptStruct BFGCore.BFGQuest_ElementMentalAbility_Objective
// 0x0188 (0x0188 - 0x0000)
struct FBFGQuest_ElementMentalAbility_Objective final
{
public:
	struct FBFGActorBinding                       M_actorBinding;                                    // 0x0000(0x0090)(Edit, BlueprintVisible, BlueprintReadOnly, DisableEditOnInstance, NativeAccessSpecifierPublic)
	struct FGameplayTagQuery                      M_gamplayTagQuery;                                 // 0x0090(0x0048)(Edit, BlueprintVisible, BlueprintReadOnly, DisableEditOnInstance, NativeAccessSpecifierPublic)
	int32                                         M_iQuantity;                                       // 0x00D8(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_DC[0x4];                                       // 0x00DC(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	struct FBFGQuest_UIProvider                   M_descriptionProvider;                             // 0x00E0(0x0050)(Edit, BlueprintVisible, BlueprintReadOnly, DisableEditOnInstance, NativeAccessSpecifierPublic)
	EMentalAbility_EventState                     M_objectiveState;                                  // 0x0130(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          M_bIsUniqueObjectives;                             // 0x0131(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_132[0x6];                                      // 0x0132(0x0006)(Fixing Size After Last Property [ Dumper-7 ])
	struct FBFGObjectiveMarkerInfo                M_markerInfo;                                      // 0x0138(0x0028)(Edit, BlueprintVisible, BlueprintReadOnly, DisableEditOnInstance, ContainsInstancedReference, NativeAccessSpecifierPublic)
	TArray<class UBFGEffectBank*>                 M_apEnableEffectBanks;                             // 0x0160(0x0010)(Edit, ZeroConstructor, DisableEditOnInstance, NativeAccessSpecifierPublic)
	EBFGEffect_Identifier                         M_activateEffect;                                  // 0x0170(0x0001)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_171[0x7];                                      // 0x0171(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<struct FBFGQuest_ElementMentalAbility_Overrides> M_aOverrides;                                      // 0x0178(0x0010)(Edit, ZeroConstructor, DisableEditOnInstance, NativeAccessSpecifierPublic)
};
static_assert(alignof(FBFGQuest_ElementMentalAbility_Objective) == 0x000008, "Wrong alignment on FBFGQuest_ElementMentalAbility_Objective");
static_assert(sizeof(FBFGQuest_ElementMentalAbility_Objective) == 0x000188, "Wrong size on FBFGQuest_ElementMentalAbility_Objective");
static_assert(offsetof(FBFGQuest_ElementMentalAbility_Objective, M_actorBinding) == 0x000000, "Member 'FBFGQuest_ElementMentalAbility_Objective::M_actorBinding' has a wrong offset!");
static_assert(offsetof(FBFGQuest_ElementMentalAbility_Objective, M_gamplayTagQuery) == 0x000090, "Member 'FBFGQuest_ElementMentalAbility_Objective::M_gamplayTagQuery' has a wrong offset!");
static_assert(offsetof(FBFGQuest_ElementMentalAbility_Objective, M_iQuantity) == 0x0000D8, "Member 'FBFGQuest_ElementMentalAbility_Objective::M_iQuantity' has a wrong offset!");
static_assert(offsetof(FBFGQuest_ElementMentalAbility_Objective, M_descriptionProvider) == 0x0000E0, "Member 'FBFGQuest_ElementMentalAbility_Objective::M_descriptionProvider' has a wrong offset!");
static_assert(offsetof(FBFGQuest_ElementMentalAbility_Objective, M_objectiveState) == 0x000130, "Member 'FBFGQuest_ElementMentalAbility_Objective::M_objectiveState' has a wrong offset!");
static_assert(offsetof(FBFGQuest_ElementMentalAbility_Objective, M_bIsUniqueObjectives) == 0x000131, "Member 'FBFGQuest_ElementMentalAbility_Objective::M_bIsUniqueObjectives' has a wrong offset!");
static_assert(offsetof(FBFGQuest_ElementMentalAbility_Objective, M_markerInfo) == 0x000138, "Member 'FBFGQuest_ElementMentalAbility_Objective::M_markerInfo' has a wrong offset!");
static_assert(offsetof(FBFGQuest_ElementMentalAbility_Objective, M_apEnableEffectBanks) == 0x000160, "Member 'FBFGQuest_ElementMentalAbility_Objective::M_apEnableEffectBanks' has a wrong offset!");
static_assert(offsetof(FBFGQuest_ElementMentalAbility_Objective, M_activateEffect) == 0x000170, "Member 'FBFGQuest_ElementMentalAbility_Objective::M_activateEffect' has a wrong offset!");
static_assert(offsetof(FBFGQuest_ElementMentalAbility_Objective, M_aOverrides) == 0x000178, "Member 'FBFGQuest_ElementMentalAbility_Objective::M_aOverrides' has a wrong offset!");

// ScriptStruct BFGCore.BFGQuest_ElementScriptedSequence_RuntimeData
// 0x0010 (0x0010 - 0x0000)
struct FBFGQuest_ElementScriptedSequence_RuntimeData final
{
public:
	class UBFGScriptedSequence_Persistent*        M_pScriptedSequence;                               // 0x0000(0x0008)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UBFGVariable*                           M_pVariableStarted;                                // 0x0008(0x0008)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FBFGQuest_ElementScriptedSequence_RuntimeData) == 0x000008, "Wrong alignment on FBFGQuest_ElementScriptedSequence_RuntimeData");
static_assert(sizeof(FBFGQuest_ElementScriptedSequence_RuntimeData) == 0x000010, "Wrong size on FBFGQuest_ElementScriptedSequence_RuntimeData");
static_assert(offsetof(FBFGQuest_ElementScriptedSequence_RuntimeData, M_pScriptedSequence) == 0x000000, "Member 'FBFGQuest_ElementScriptedSequence_RuntimeData::M_pScriptedSequence' has a wrong offset!");
static_assert(offsetof(FBFGQuest_ElementScriptedSequence_RuntimeData, M_pVariableStarted) == 0x000008, "Member 'FBFGQuest_ElementScriptedSequence_RuntimeData::M_pVariableStarted' has a wrong offset!");

// ScriptStruct BFGCore.BFGQuest_TimerSettings
// 0x0040 (0x0040 - 0x0000)
struct FBFGQuest_TimerSettings final
{
public:
	class FName                                   M_strIdentifier;                                   // 0x0000(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EBFGQuest_TimerMode                           M_eMode;                                           // 0x0008(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_9[0x7];                                        // 0x0009(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	struct FTimespan                              M_tsDuration;                                      // 0x0010(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FTimespan                              M_tsValidateAt;                                    // 0x0018(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TArray<struct FTimespan>                      M_aSubgoalLimits;                                  // 0x0020(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, NativeAccessSpecifierPublic)
	uint8                                         Pad_30[0x10];                                      // 0x0030(0x0010)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FBFGQuest_TimerSettings) == 0x000008, "Wrong alignment on FBFGQuest_TimerSettings");
static_assert(sizeof(FBFGQuest_TimerSettings) == 0x000040, "Wrong size on FBFGQuest_TimerSettings");
static_assert(offsetof(FBFGQuest_TimerSettings, M_strIdentifier) == 0x000000, "Member 'FBFGQuest_TimerSettings::M_strIdentifier' has a wrong offset!");
static_assert(offsetof(FBFGQuest_TimerSettings, M_eMode) == 0x000008, "Member 'FBFGQuest_TimerSettings::M_eMode' has a wrong offset!");
static_assert(offsetof(FBFGQuest_TimerSettings, M_tsDuration) == 0x000010, "Member 'FBFGQuest_TimerSettings::M_tsDuration' has a wrong offset!");
static_assert(offsetof(FBFGQuest_TimerSettings, M_tsValidateAt) == 0x000018, "Member 'FBFGQuest_TimerSettings::M_tsValidateAt' has a wrong offset!");
static_assert(offsetof(FBFGQuest_TimerSettings, M_aSubgoalLimits) == 0x000020, "Member 'FBFGQuest_TimerSettings::M_aSubgoalLimits' has a wrong offset!");

// ScriptStruct BFGCore.BFGQuest_UIProvider_Title
// 0x0020 (0x0020 - 0x0000)
struct FBFGQuest_UIProvider_Title final
{
public:
	bool                                          M_bShowInUI;                                       // 0x0000(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1[0x7];                                        // 0x0001(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	class FText                                   M_strText;                                         // 0x0008(0x0018)(Edit, BlueprintVisible, BlueprintReadOnly, DisableEditOnInstance, NativeAccessSpecifierPublic)
};
static_assert(alignof(FBFGQuest_UIProvider_Title) == 0x000008, "Wrong alignment on FBFGQuest_UIProvider_Title");
static_assert(sizeof(FBFGQuest_UIProvider_Title) == 0x000020, "Wrong size on FBFGQuest_UIProvider_Title");
static_assert(offsetof(FBFGQuest_UIProvider_Title, M_bShowInUI) == 0x000000, "Member 'FBFGQuest_UIProvider_Title::M_bShowInUI' has a wrong offset!");
static_assert(offsetof(FBFGQuest_UIProvider_Title, M_strText) == 0x000008, "Member 'FBFGQuest_UIProvider_Title::M_strText' has a wrong offset!");

// ScriptStruct BFGCore.BFGRadarResult
// 0x0030 (0x0030 - 0x0000)
struct FBFGRadarResult final
{
public:
	struct FVector                                M_vPosition;                                       // 0x0000(0x000C)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_C[0x4];                                        // 0x000C(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class UBFGDataAsset_RadarObjectStaticInfo*    M_pStaticInfo;                                     // 0x0010(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TScriptInterface<class IBFGRadarObjectInterface> M_pObject;                                         // 0x0018(0x0010)(ZeroConstructor, IsPlainOldData, NoDestructor, UObjectWrapper, NativeAccessSpecifierPublic)
	uint8                                         Pad_28[0x8];                                       // 0x0028(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FBFGRadarResult) == 0x000008, "Wrong alignment on FBFGRadarResult");
static_assert(sizeof(FBFGRadarResult) == 0x000030, "Wrong size on FBFGRadarResult");
static_assert(offsetof(FBFGRadarResult, M_vPosition) == 0x000000, "Member 'FBFGRadarResult::M_vPosition' has a wrong offset!");
static_assert(offsetof(FBFGRadarResult, M_pStaticInfo) == 0x000010, "Member 'FBFGRadarResult::M_pStaticInfo' has a wrong offset!");
static_assert(offsetof(FBFGRadarResult, M_pObject) == 0x000018, "Member 'FBFGRadarResult::M_pObject' has a wrong offset!");

// ScriptStruct BFGCore.BFGAmmunitionInfo
// 0x0008 (0x0008 - 0x0000)
struct FBFGAmmunitionInfo final
{
public:
	int32                                         M_iCurrentAmmunition;                              // 0x0000(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         M_iAmmunitionCount;                                // 0x0004(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FBFGAmmunitionInfo) == 0x000004, "Wrong alignment on FBFGAmmunitionInfo");
static_assert(sizeof(FBFGAmmunitionInfo) == 0x000008, "Wrong size on FBFGAmmunitionInfo");
static_assert(offsetof(FBFGAmmunitionInfo, M_iCurrentAmmunition) == 0x000000, "Member 'FBFGAmmunitionInfo::M_iCurrentAmmunition' has a wrong offset!");
static_assert(offsetof(FBFGAmmunitionInfo, M_iAmmunitionCount) == 0x000004, "Member 'FBFGAmmunitionInfo::M_iAmmunitionCount' has a wrong offset!");

// ScriptStruct BFGCore.BFGSystemData_TrafficCrowdManager_QueryToBoolean
// 0x0050 (0x0050 - 0x0000)
struct FBFGSystemData_TrafficCrowdManager_QueryToBoolean final
{
public:
	struct FGameplayTagQuery                      M_key;                                             // 0x0000(0x0048)(SaveGame, NativeAccessSpecifierPublic)
	bool                                          M_value;                                           // 0x0048(0x0001)(ZeroConstructor, SaveGame, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_49[0x7];                                       // 0x0049(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FBFGSystemData_TrafficCrowdManager_QueryToBoolean) == 0x000008, "Wrong alignment on FBFGSystemData_TrafficCrowdManager_QueryToBoolean");
static_assert(sizeof(FBFGSystemData_TrafficCrowdManager_QueryToBoolean) == 0x000050, "Wrong size on FBFGSystemData_TrafficCrowdManager_QueryToBoolean");
static_assert(offsetof(FBFGSystemData_TrafficCrowdManager_QueryToBoolean, M_key) == 0x000000, "Member 'FBFGSystemData_TrafficCrowdManager_QueryToBoolean::M_key' has a wrong offset!");
static_assert(offsetof(FBFGSystemData_TrafficCrowdManager_QueryToBoolean, M_value) == 0x000048, "Member 'FBFGSystemData_TrafficCrowdManager_QueryToBoolean::M_value' has a wrong offset!");

// ScriptStruct BFGCore.BFGSystemData_TrafficCrowdManager_QueryToQuery
// 0x0090 (0x0090 - 0x0000)
struct FBFGSystemData_TrafficCrowdManager_QueryToQuery final
{
public:
	struct FGameplayTagQuery                      M_key;                                             // 0x0000(0x0048)(SaveGame, NativeAccessSpecifierPublic)
	struct FGameplayTagQuery                      M_value;                                           // 0x0048(0x0048)(SaveGame, NativeAccessSpecifierPublic)
};
static_assert(alignof(FBFGSystemData_TrafficCrowdManager_QueryToQuery) == 0x000008, "Wrong alignment on FBFGSystemData_TrafficCrowdManager_QueryToQuery");
static_assert(sizeof(FBFGSystemData_TrafficCrowdManager_QueryToQuery) == 0x000090, "Wrong size on FBFGSystemData_TrafficCrowdManager_QueryToQuery");
static_assert(offsetof(FBFGSystemData_TrafficCrowdManager_QueryToQuery, M_key) == 0x000000, "Member 'FBFGSystemData_TrafficCrowdManager_QueryToQuery::M_key' has a wrong offset!");
static_assert(offsetof(FBFGSystemData_TrafficCrowdManager_QueryToQuery, M_value) == 0x000048, "Member 'FBFGSystemData_TrafficCrowdManager_QueryToQuery::M_value' has a wrong offset!");

// ScriptStruct BFGCore.BFGSystemData_TrafficCrowdManager
// 0x0048 (0x0048 - 0x0000)
struct FBFGSystemData_TrafficCrowdManager final
{
public:
	bool                                          M_bRestoreTrafficCrowdManagerData;                 // 0x0000(0x0001)(ZeroConstructor, SaveGame, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1[0x7];                                        // 0x0001(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<struct FBFGSystemData_TrafficCrowdManager_QueryToBoolean> M_aSetCrowdflowAvailableByGameplayTag;             // 0x0008(0x0010)(ZeroConstructor, SaveGame, NativeAccessSpecifierPublic)
	TArray<struct FBFGSystemData_TrafficCrowdManager_QueryToQuery> M_aSetCrowdflowAllowedByTagQueryOverrideByGameplayTag; // 0x0018(0x0010)(ZeroConstructor, SaveGame, NativeAccessSpecifierPublic)
	TArray<struct FBFGSystemData_TrafficCrowdManager_QueryToBoolean> M_aSetCrowdLifeStationsAvailableByGameplayTag;     // 0x0028(0x0010)(ZeroConstructor, SaveGame, NativeAccessSpecifierPublic)
	TArray<struct FBFGSystemData_TrafficCrowdManager_QueryToBoolean> M_aSetCrowdScriptConsAvailableByGameplayTag;       // 0x0038(0x0010)(ZeroConstructor, SaveGame, NativeAccessSpecifierPublic)
};
static_assert(alignof(FBFGSystemData_TrafficCrowdManager) == 0x000008, "Wrong alignment on FBFGSystemData_TrafficCrowdManager");
static_assert(sizeof(FBFGSystemData_TrafficCrowdManager) == 0x000048, "Wrong size on FBFGSystemData_TrafficCrowdManager");
static_assert(offsetof(FBFGSystemData_TrafficCrowdManager, M_bRestoreTrafficCrowdManagerData) == 0x000000, "Member 'FBFGSystemData_TrafficCrowdManager::M_bRestoreTrafficCrowdManagerData' has a wrong offset!");
static_assert(offsetof(FBFGSystemData_TrafficCrowdManager, M_aSetCrowdflowAvailableByGameplayTag) == 0x000008, "Member 'FBFGSystemData_TrafficCrowdManager::M_aSetCrowdflowAvailableByGameplayTag' has a wrong offset!");
static_assert(offsetof(FBFGSystemData_TrafficCrowdManager, M_aSetCrowdflowAllowedByTagQueryOverrideByGameplayTag) == 0x000018, "Member 'FBFGSystemData_TrafficCrowdManager::M_aSetCrowdflowAllowedByTagQueryOverrideByGameplayTag' has a wrong offset!");
static_assert(offsetof(FBFGSystemData_TrafficCrowdManager, M_aSetCrowdLifeStationsAvailableByGameplayTag) == 0x000028, "Member 'FBFGSystemData_TrafficCrowdManager::M_aSetCrowdLifeStationsAvailableByGameplayTag' has a wrong offset!");
static_assert(offsetof(FBFGSystemData_TrafficCrowdManager, M_aSetCrowdScriptConsAvailableByGameplayTag) == 0x000038, "Member 'FBFGSystemData_TrafficCrowdManager::M_aSetCrowdScriptConsAvailableByGameplayTag' has a wrong offset!");

// ScriptStruct BFGCore.BFGSystemData_ObjectiveMarker_Entitlements
// 0x0038 (0x0038 - 0x0000)
struct FBFGSystemData_ObjectiveMarker_Entitlements final
{
public:
	TSoftObjectPtr<class AActor>                  M_softActor;                                       // 0x0000(0x0028)(SaveGame, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TArray<class FName>                           M_aConsumed;                                       // 0x0028(0x0010)(ZeroConstructor, SaveGame, NativeAccessSpecifierPublic)
};
static_assert(alignof(FBFGSystemData_ObjectiveMarker_Entitlements) == 0x000008, "Wrong alignment on FBFGSystemData_ObjectiveMarker_Entitlements");
static_assert(sizeof(FBFGSystemData_ObjectiveMarker_Entitlements) == 0x000038, "Wrong size on FBFGSystemData_ObjectiveMarker_Entitlements");
static_assert(offsetof(FBFGSystemData_ObjectiveMarker_Entitlements, M_softActor) == 0x000000, "Member 'FBFGSystemData_ObjectiveMarker_Entitlements::M_softActor' has a wrong offset!");
static_assert(offsetof(FBFGSystemData_ObjectiveMarker_Entitlements, M_aConsumed) == 0x000028, "Member 'FBFGSystemData_ObjectiveMarker_Entitlements::M_aConsumed' has a wrong offset!");

// ScriptStruct BFGCore.BFGSystemData_ObjectiveMarker
// 0x0060 (0x0060 - 0x0000)
struct FBFGSystemData_ObjectiveMarker final
{
public:
	TMap<class FName, struct FGuid>               M_aGroupIds;                                       // 0x0000(0x0050)(ZeroConstructor, SaveGame, NativeAccessSpecifierPublic)
	TArray<struct FBFGSystemData_ObjectiveMarker_Entitlements> M_aEntitlements;                                   // 0x0050(0x0010)(ZeroConstructor, SaveGame, NativeAccessSpecifierPublic)
};
static_assert(alignof(FBFGSystemData_ObjectiveMarker) == 0x000008, "Wrong alignment on FBFGSystemData_ObjectiveMarker");
static_assert(sizeof(FBFGSystemData_ObjectiveMarker) == 0x000060, "Wrong size on FBFGSystemData_ObjectiveMarker");
static_assert(offsetof(FBFGSystemData_ObjectiveMarker, M_aGroupIds) == 0x000000, "Member 'FBFGSystemData_ObjectiveMarker::M_aGroupIds' has a wrong offset!");
static_assert(offsetof(FBFGSystemData_ObjectiveMarker, M_aEntitlements) == 0x000050, "Member 'FBFGSystemData_ObjectiveMarker::M_aEntitlements' has a wrong offset!");

// ScriptStruct BFGCore.BFGSystemData_UFOManager
// 0x0010 (0x0010 - 0x0000)
struct FBFGSystemData_UFOManager final
{
public:
	TArray<struct FBFGSystemData_UFOManager_SiteData> M_aData;                                           // 0x0000(0x0010)(ZeroConstructor, SaveGame, NativeAccessSpecifierPublic)
};
static_assert(alignof(FBFGSystemData_UFOManager) == 0x000008, "Wrong alignment on FBFGSystemData_UFOManager");
static_assert(sizeof(FBFGSystemData_UFOManager) == 0x000010, "Wrong size on FBFGSystemData_UFOManager");
static_assert(offsetof(FBFGSystemData_UFOManager, M_aData) == 0x000000, "Member 'FBFGSystemData_UFOManager::M_aData' has a wrong offset!");

// ScriptStruct BFGCore.BFGSystemData_BurningGround_Event
// 0x000A (0x000A - 0x0000)
struct FBFGSystemData_BurningGround_Event final
{
public:
	uint16                                        M_usX;                                             // 0x0000(0x0002)(ZeroConstructor, SaveGame, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint16                                        M_usY;                                             // 0x0002(0x0002)(ZeroConstructor, SaveGame, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint16                                        M_ucDrawSize;                                      // 0x0004(0x0002)(ZeroConstructor, SaveGame, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         M_ucRotation;                                      // 0x0006(0x0001)(ZeroConstructor, SaveGame, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         M_ucGlow;                                          // 0x0007(0x0001)(ZeroConstructor, SaveGame, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         M_bChanneled : 1;                                  // 0x0008(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (SaveGame, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         Pad_9[0x1];                                        // 0x0009(0x0001)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FBFGSystemData_BurningGround_Event) == 0x000002, "Wrong alignment on FBFGSystemData_BurningGround_Event");
static_assert(sizeof(FBFGSystemData_BurningGround_Event) == 0x00000A, "Wrong size on FBFGSystemData_BurningGround_Event");
static_assert(offsetof(FBFGSystemData_BurningGround_Event, M_usX) == 0x000000, "Member 'FBFGSystemData_BurningGround_Event::M_usX' has a wrong offset!");
static_assert(offsetof(FBFGSystemData_BurningGround_Event, M_usY) == 0x000002, "Member 'FBFGSystemData_BurningGround_Event::M_usY' has a wrong offset!");
static_assert(offsetof(FBFGSystemData_BurningGround_Event, M_ucDrawSize) == 0x000004, "Member 'FBFGSystemData_BurningGround_Event::M_ucDrawSize' has a wrong offset!");
static_assert(offsetof(FBFGSystemData_BurningGround_Event, M_ucRotation) == 0x000006, "Member 'FBFGSystemData_BurningGround_Event::M_ucRotation' has a wrong offset!");
static_assert(offsetof(FBFGSystemData_BurningGround_Event, M_ucGlow) == 0x000007, "Member 'FBFGSystemData_BurningGround_Event::M_ucGlow' has a wrong offset!");

// ScriptStruct BFGCore.BFGSystemData_BurningGround
// 0x0010 (0x0010 - 0x0000)
struct FBFGSystemData_BurningGround final
{
public:
	TArray<struct FBFGSystemData_BurningGround_Event> M_aData;                                           // 0x0000(0x0010)(ZeroConstructor, SaveGame, NativeAccessSpecifierPublic)
};
static_assert(alignof(FBFGSystemData_BurningGround) == 0x000008, "Wrong alignment on FBFGSystemData_BurningGround");
static_assert(sizeof(FBFGSystemData_BurningGround) == 0x000010, "Wrong size on FBFGSystemData_BurningGround");
static_assert(offsetof(FBFGSystemData_BurningGround, M_aData) == 0x000000, "Member 'FBFGSystemData_BurningGround::M_aData' has a wrong offset!");

// ScriptStruct BFGCore.BFGSystemData_Environment
// 0x0050 (0x0050 - 0x0000)
struct FBFGSystemData_Environment final
{
public:
	TMap<class FName, TSoftObjectPtr<class UBFGEnvironment>> M_aLevelEnvironments;                              // 0x0000(0x0050)(ZeroConstructor, SaveGame, UObjectWrapper, NativeAccessSpecifierPublic)
};
static_assert(alignof(FBFGSystemData_Environment) == 0x000008, "Wrong alignment on FBFGSystemData_Environment");
static_assert(sizeof(FBFGSystemData_Environment) == 0x000050, "Wrong size on FBFGSystemData_Environment");
static_assert(offsetof(FBFGSystemData_Environment, M_aLevelEnvironments) == 0x000000, "Member 'FBFGSystemData_Environment::M_aLevelEnvironments' has a wrong offset!");

// ScriptStruct BFGCore.BFGSaveGame_SystemData
// 0x0408 (0x0408 - 0x0000)
struct FBFGSaveGame_SystemData final
{
public:
	struct FBFGSystemData_VariableMirror          M_dataVariableMirror;                              // 0x0000(0x00F0)(SaveGame, NativeAccessSpecifierPublic)
	struct FBFGSystemData_QuestManager            M_dataQuestManager;                                // 0x00F0(0x01D0)(SaveGame, NativeAccessSpecifierPublic)
	struct FBFGSystemData_ObjectiveMarker         M_dataObjectiveMarkers;                            // 0x02C0(0x0060)(SaveGame, NativeAccessSpecifierPublic)
	struct FBFGSystemData_AlertSystem             M_dataAlertSystem;                                 // 0x0320(0x0014)(SaveGame, NoDestructor, NativeAccessSpecifierPublic)
	uint8                                         Pad_334[0x4];                                      // 0x0334(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	struct FBFGSystemData_UFOManager              M_dataUFOManager;                                  // 0x0338(0x0010)(SaveGame, NativeAccessSpecifierPublic)
	struct FBFGSystemData_BurningGround           M_dataBurningGround;                               // 0x0348(0x0010)(Transient, NativeAccessSpecifierPublic)
	struct FBFGSystemData_Statistics              M_dataStats;                                       // 0x0358(0x0010)(SaveGame, NativeAccessSpecifierPublic)
	struct FBFGSystemData_MothershipMenu          M_dataMothershipMenu;                              // 0x0368(0x0001)(SaveGame, NoDestructor, NativeAccessSpecifierPublic)
	uint8                                         Pad_369[0x7];                                      // 0x0369(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	struct FBFGSystemData_Environment             M_dataEnvironmentSystem;                           // 0x0370(0x0050)(SaveGame, NativeAccessSpecifierPublic)
	struct FBFGSystemData_TrafficCrowdManager     M_dataTrafficCrowdManager;                         // 0x03C0(0x0048)(SaveGame, NativeAccessSpecifierPublic)
};
static_assert(alignof(FBFGSaveGame_SystemData) == 0x000008, "Wrong alignment on FBFGSaveGame_SystemData");
static_assert(sizeof(FBFGSaveGame_SystemData) == 0x000408, "Wrong size on FBFGSaveGame_SystemData");
static_assert(offsetof(FBFGSaveGame_SystemData, M_dataVariableMirror) == 0x000000, "Member 'FBFGSaveGame_SystemData::M_dataVariableMirror' has a wrong offset!");
static_assert(offsetof(FBFGSaveGame_SystemData, M_dataQuestManager) == 0x0000F0, "Member 'FBFGSaveGame_SystemData::M_dataQuestManager' has a wrong offset!");
static_assert(offsetof(FBFGSaveGame_SystemData, M_dataObjectiveMarkers) == 0x0002C0, "Member 'FBFGSaveGame_SystemData::M_dataObjectiveMarkers' has a wrong offset!");
static_assert(offsetof(FBFGSaveGame_SystemData, M_dataAlertSystem) == 0x000320, "Member 'FBFGSaveGame_SystemData::M_dataAlertSystem' has a wrong offset!");
static_assert(offsetof(FBFGSaveGame_SystemData, M_dataUFOManager) == 0x000338, "Member 'FBFGSaveGame_SystemData::M_dataUFOManager' has a wrong offset!");
static_assert(offsetof(FBFGSaveGame_SystemData, M_dataBurningGround) == 0x000348, "Member 'FBFGSaveGame_SystemData::M_dataBurningGround' has a wrong offset!");
static_assert(offsetof(FBFGSaveGame_SystemData, M_dataStats) == 0x000358, "Member 'FBFGSaveGame_SystemData::M_dataStats' has a wrong offset!");
static_assert(offsetof(FBFGSaveGame_SystemData, M_dataMothershipMenu) == 0x000368, "Member 'FBFGSaveGame_SystemData::M_dataMothershipMenu' has a wrong offset!");
static_assert(offsetof(FBFGSaveGame_SystemData, M_dataEnvironmentSystem) == 0x000370, "Member 'FBFGSaveGame_SystemData::M_dataEnvironmentSystem' has a wrong offset!");
static_assert(offsetof(FBFGSaveGame_SystemData, M_dataTrafficCrowdManager) == 0x0003C0, "Member 'FBFGSaveGame_SystemData::M_dataTrafficCrowdManager' has a wrong offset!");

// ScriptStruct BFGCore.BFGBuoyancyBoneOverride
// 0x0010 (0x0010 - 0x0000)
struct FBFGBuoyancyBoneOverride final
{
public:
	class FName                                   BoneName;                                          // 0x0000(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         Density;                                           // 0x0008(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         TestRadius;                                        // 0x000C(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FBFGBuoyancyBoneOverride) == 0x000004, "Wrong alignment on FBFGBuoyancyBoneOverride");
static_assert(sizeof(FBFGBuoyancyBoneOverride) == 0x000010, "Wrong size on FBFGBuoyancyBoneOverride");
static_assert(offsetof(FBFGBuoyancyBoneOverride, BoneName) == 0x000000, "Member 'FBFGBuoyancyBoneOverride::BoneName' has a wrong offset!");
static_assert(offsetof(FBFGBuoyancyBoneOverride, Density) == 0x000008, "Member 'FBFGBuoyancyBoneOverride::Density' has a wrong offset!");
static_assert(offsetof(FBFGBuoyancyBoneOverride, TestRadius) == 0x00000C, "Member 'FBFGBuoyancyBoneOverride::TestRadius' has a wrong offset!");

// ScriptStruct BFGCore.BFGIonVortexCoilsWeightClassData
// 0x0018 (0x0018 - 0x0000)
struct FBFGIonVortexCoilsWeightClassData final
{
public:
	EObjectWeightClass                            M_eWeightClass;                                    // 0x0000(0x0001)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1[0x7];                                        // 0x0001(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	class UCurveFloat*                            M_pStrengthMultiplier;                             // 0x0008(0x0008)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         M_oImpulseStrength;                                // 0x0010(0x0004)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_14[0x4];                                       // 0x0014(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FBFGIonVortexCoilsWeightClassData) == 0x000008, "Wrong alignment on FBFGIonVortexCoilsWeightClassData");
static_assert(sizeof(FBFGIonVortexCoilsWeightClassData) == 0x000018, "Wrong size on FBFGIonVortexCoilsWeightClassData");
static_assert(offsetof(FBFGIonVortexCoilsWeightClassData, M_eWeightClass) == 0x000000, "Member 'FBFGIonVortexCoilsWeightClassData::M_eWeightClass' has a wrong offset!");
static_assert(offsetof(FBFGIonVortexCoilsWeightClassData, M_pStrengthMultiplier) == 0x000008, "Member 'FBFGIonVortexCoilsWeightClassData::M_pStrengthMultiplier' has a wrong offset!");
static_assert(offsetof(FBFGIonVortexCoilsWeightClassData, M_oImpulseStrength) == 0x000010, "Member 'FBFGIonVortexCoilsWeightClassData::M_oImpulseStrength' has a wrong offset!");

// ScriptStruct BFGCore.BFGSavedMapDescription
// 0x0038 (0x0038 - 0x0000)
struct FBFGSavedMapDescription final
{
public:
	class FString                                 M_strMapLevelName;                                 // 0x0000(0x0010)(ZeroConstructor, SaveGame, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TSoftObjectPtr<class UTexture2D>              M_pLoadingScreenTexture;                           // 0x0010(0x0028)(SaveGame, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FBFGSavedMapDescription) == 0x000008, "Wrong alignment on FBFGSavedMapDescription");
static_assert(sizeof(FBFGSavedMapDescription) == 0x000038, "Wrong size on FBFGSavedMapDescription");
static_assert(offsetof(FBFGSavedMapDescription, M_strMapLevelName) == 0x000000, "Member 'FBFGSavedMapDescription::M_strMapLevelName' has a wrong offset!");
static_assert(offsetof(FBFGSavedMapDescription, M_pLoadingScreenTexture) == 0x000010, "Member 'FBFGSavedMapDescription::M_pLoadingScreenTexture' has a wrong offset!");

// ScriptStruct BFGCore.BFGSaveDescription
// 0x0070 (0x0070 - 0x0000)
struct FBFGSaveDescription final
{
public:
	class FText                                   M_strTitle;                                        // 0x0000(0x0018)(BlueprintVisible, BlueprintReadOnly, SaveGame, NativeAccessSpecifierPublic)
	class FText                                   M_strDescription;                                  // 0x0018(0x0018)(BlueprintVisible, BlueprintReadOnly, SaveGame, NativeAccessSpecifierPublic)
	struct FDateTime                              M_oDateTime;                                       // 0x0030(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, SaveGame, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FBFGSavedMapDescription                M_mapDescription;                                  // 0x0038(0x0038)(SaveGame, NativeAccessSpecifierPublic)
};
static_assert(alignof(FBFGSaveDescription) == 0x000008, "Wrong alignment on FBFGSaveDescription");
static_assert(sizeof(FBFGSaveDescription) == 0x000070, "Wrong size on FBFGSaveDescription");
static_assert(offsetof(FBFGSaveDescription, M_strTitle) == 0x000000, "Member 'FBFGSaveDescription::M_strTitle' has a wrong offset!");
static_assert(offsetof(FBFGSaveDescription, M_strDescription) == 0x000018, "Member 'FBFGSaveDescription::M_strDescription' has a wrong offset!");
static_assert(offsetof(FBFGSaveDescription, M_oDateTime) == 0x000030, "Member 'FBFGSaveDescription::M_oDateTime' has a wrong offset!");
static_assert(offsetof(FBFGSaveDescription, M_mapDescription) == 0x000038, "Member 'FBFGSaveDescription::M_mapDescription' has a wrong offset!");

// ScriptStruct BFGCore.BFGAchievementsAwait
// 0x000C (0x000C - 0x0000)
struct FBFGAchievementsAwait final
{
public:
	class FName                                   M_strIdentifier;                                   // 0x0000(0x0008)(Edit, ZeroConstructor, SaveGame, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         M_fProgress;                                       // 0x0008(0x0004)(Edit, ZeroConstructor, SaveGame, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FBFGAchievementsAwait) == 0x000004, "Wrong alignment on FBFGAchievementsAwait");
static_assert(sizeof(FBFGAchievementsAwait) == 0x00000C, "Wrong size on FBFGAchievementsAwait");
static_assert(offsetof(FBFGAchievementsAwait, M_strIdentifier) == 0x000000, "Member 'FBFGAchievementsAwait::M_strIdentifier' has a wrong offset!");
static_assert(offsetof(FBFGAchievementsAwait, M_fProgress) == 0x000008, "Member 'FBFGAchievementsAwait::M_fProgress' has a wrong offset!");

// ScriptStruct BFGCore.BFGSaveSystem_SaveGameAction_Params
// 0x0028 (0x0028 - 0x0000)
struct FBFGSaveSystem_SaveGameAction_Params final
{
public:
	class UBFGSaveContext*                        M_pSaveContext;                                    // 0x0000(0x0008)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_8[0x8];                                        // 0x0008(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	class UBFGQuest*                              M_pQuestUseCase;                                   // 0x0010(0x0008)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_18[0x10];                                      // 0x0018(0x0010)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FBFGSaveSystem_SaveGameAction_Params) == 0x000008, "Wrong alignment on FBFGSaveSystem_SaveGameAction_Params");
static_assert(sizeof(FBFGSaveSystem_SaveGameAction_Params) == 0x000028, "Wrong size on FBFGSaveSystem_SaveGameAction_Params");
static_assert(offsetof(FBFGSaveSystem_SaveGameAction_Params, M_pSaveContext) == 0x000000, "Member 'FBFGSaveSystem_SaveGameAction_Params::M_pSaveContext' has a wrong offset!");
static_assert(offsetof(FBFGSaveSystem_SaveGameAction_Params, M_pQuestUseCase) == 0x000010, "Member 'FBFGSaveSystem_SaveGameAction_Params::M_pQuestUseCase' has a wrong offset!");

// ScriptStruct BFGCore.BFGScriptedSequence_TaskVehicleStop_Param
// 0x0010 (0x0010 - 0x0000)
struct FBFGScriptedSequence_TaskVehicleStop_Param final
{
public:
	struct FBFGVehicleStop_Param                  M_stopSetup;                                       // 0x0000(0x000C)(Edit, BlueprintVisible, NoDestructor, NativeAccessSpecifierPublic)
	bool                                          M_doWaitInStandby;                                 // 0x000C(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_D[0x3];                                        // 0x000D(0x0003)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FBFGScriptedSequence_TaskVehicleStop_Param) == 0x000004, "Wrong alignment on FBFGScriptedSequence_TaskVehicleStop_Param");
static_assert(sizeof(FBFGScriptedSequence_TaskVehicleStop_Param) == 0x000010, "Wrong size on FBFGScriptedSequence_TaskVehicleStop_Param");
static_assert(offsetof(FBFGScriptedSequence_TaskVehicleStop_Param, M_stopSetup) == 0x000000, "Member 'FBFGScriptedSequence_TaskVehicleStop_Param::M_stopSetup' has a wrong offset!");
static_assert(offsetof(FBFGScriptedSequence_TaskVehicleStop_Param, M_doWaitInStandby) == 0x00000C, "Member 'FBFGScriptedSequence_TaskVehicleStop_Param::M_doWaitInStandby' has a wrong offset!");

// ScriptStruct BFGCore.BFGSegment2
// 0x0000 (0x0010 - 0x0010)
struct FBFGSegment2 final : public FBFGLine2
{
};
static_assert(alignof(FBFGSegment2) == 0x000004, "Wrong alignment on FBFGSegment2");
static_assert(sizeof(FBFGSegment2) == 0x000010, "Wrong size on FBFGSegment2");

// ScriptStruct BFGCore.BFGSequencePlayer_Parameters
// 0x0070 (0x0070 - 0x0000)
struct FBFGSequencePlayer_Parameters final
{
public:
	bool                                          M_bUseCutsceneFlowState;                           // 0x0000(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1[0x7];                                        // 0x0001(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	struct FBFGGameFlowState_CutsceneParameters   M_oCutsceneParameters;                             // 0x0008(0x0060)(Edit, NativeAccessSpecifierPublic)
	bool                                          M_bResetOnPause;                                   // 0x0068(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          M_bSequencePlayerStopsSequence;                    // 0x0069(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_6A[0x6];                                       // 0x006A(0x0006)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FBFGSequencePlayer_Parameters) == 0x000008, "Wrong alignment on FBFGSequencePlayer_Parameters");
static_assert(sizeof(FBFGSequencePlayer_Parameters) == 0x000070, "Wrong size on FBFGSequencePlayer_Parameters");
static_assert(offsetof(FBFGSequencePlayer_Parameters, M_bUseCutsceneFlowState) == 0x000000, "Member 'FBFGSequencePlayer_Parameters::M_bUseCutsceneFlowState' has a wrong offset!");
static_assert(offsetof(FBFGSequencePlayer_Parameters, M_oCutsceneParameters) == 0x000008, "Member 'FBFGSequencePlayer_Parameters::M_oCutsceneParameters' has a wrong offset!");
static_assert(offsetof(FBFGSequencePlayer_Parameters, M_bResetOnPause) == 0x000068, "Member 'FBFGSequencePlayer_Parameters::M_bResetOnPause' has a wrong offset!");
static_assert(offsetof(FBFGSequencePlayer_Parameters, M_bSequencePlayerStopsSequence) == 0x000069, "Member 'FBFGSequencePlayer_Parameters::M_bSequencePlayerStopsSequence' has a wrong offset!");

// ScriptStruct BFGCore.BFGSpawningCompositionItemActortype
// 0x0008 (0x0090 - 0x0088)
struct FBFGSpawningCompositionItemActortype final : public FBFGSpawningCompositionItem
{
public:
	TSubclassOf<class AActor>                     M_pActorType;                                      // 0x0088(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FBFGSpawningCompositionItemActortype) == 0x000008, "Wrong alignment on FBFGSpawningCompositionItemActortype");
static_assert(sizeof(FBFGSpawningCompositionItemActortype) == 0x000090, "Wrong size on FBFGSpawningCompositionItemActortype");
static_assert(offsetof(FBFGSpawningCompositionItemActortype, M_pActorType) == 0x000088, "Member 'FBFGSpawningCompositionItemActortype::M_pActorType' has a wrong offset!");

// ScriptStruct BFGCore.BFGSpawningCompositionItemVehicle
// 0x0000 (0x0088 - 0x0088)
struct FBFGSpawningCompositionItemVehicle final : public FBFGSpawningCompositionItem
{
};
static_assert(alignof(FBFGSpawningCompositionItemVehicle) == 0x000008, "Wrong alignment on FBFGSpawningCompositionItemVehicle");
static_assert(sizeof(FBFGSpawningCompositionItemVehicle) == 0x000088, "Wrong size on FBFGSpawningCompositionItemVehicle");

// ScriptStruct BFGCore.BFGActorArray
// 0x0010 (0x0010 - 0x0000)
struct FBFGActorArray final
{
public:
	TArray<class AActor*>                         M_aActors;                                         // 0x0000(0x0010)(ZeroConstructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(FBFGActorArray) == 0x000008, "Wrong alignment on FBFGActorArray");
static_assert(sizeof(FBFGActorArray) == 0x000010, "Wrong size on FBFGActorArray");
static_assert(offsetof(FBFGActorArray, M_aActors) == 0x000000, "Member 'FBFGActorArray::M_aActors' has a wrong offset!");

// ScriptStruct BFGCore.BFGStreamingRequest
// 0x0008 (0x0008 - 0x0000)
struct alignas(0x04) FBFGStreamingRequest final
{
public:
	uint8                                         Pad_0[0x8];                                        // 0x0000(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FBFGStreamingRequest) == 0x000004, "Wrong alignment on FBFGStreamingRequest");
static_assert(sizeof(FBFGStreamingRequest) == 0x000008, "Wrong size on FBFGStreamingRequest");

// ScriptStruct BFGCore.BFG_MoveToCrowdLifeStationTaskContext
// 0x0028 (0x0028 - 0x0000)
struct FBFG_MoveToCrowdLifeStationTaskContext final
{
public:
	class UBFGCrowdLifeStationComponent*          M_pStation;                                        // 0x0000(0x0008)(ExportObject, ZeroConstructor, Transient, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class AAIController*                          M_pController;                                     // 0x0008(0x0008)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UBFGNetworkPathAgent*                   M_pAgent;                                          // 0x0010(0x0008)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_18[0x8];                                       // 0x0018(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	bool                                          M_bIsLowRes;                                       // 0x0020(0x0001)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_21[0x7];                                       // 0x0021(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FBFG_MoveToCrowdLifeStationTaskContext) == 0x000008, "Wrong alignment on FBFG_MoveToCrowdLifeStationTaskContext");
static_assert(sizeof(FBFG_MoveToCrowdLifeStationTaskContext) == 0x000028, "Wrong size on FBFG_MoveToCrowdLifeStationTaskContext");
static_assert(offsetof(FBFG_MoveToCrowdLifeStationTaskContext, M_pStation) == 0x000000, "Member 'FBFG_MoveToCrowdLifeStationTaskContext::M_pStation' has a wrong offset!");
static_assert(offsetof(FBFG_MoveToCrowdLifeStationTaskContext, M_pController) == 0x000008, "Member 'FBFG_MoveToCrowdLifeStationTaskContext::M_pController' has a wrong offset!");
static_assert(offsetof(FBFG_MoveToCrowdLifeStationTaskContext, M_pAgent) == 0x000010, "Member 'FBFG_MoveToCrowdLifeStationTaskContext::M_pAgent' has a wrong offset!");
static_assert(offsetof(FBFG_MoveToCrowdLifeStationTaskContext, M_bIsLowRes) == 0x000020, "Member 'FBFG_MoveToCrowdLifeStationTaskContext::M_bIsLowRes' has a wrong offset!");

// ScriptStruct BFGCore.BFGTaskNode_VehicleContext
// 0x0028 (0x0028 - 0x0000)
struct FBFGTaskNode_VehicleContext final
{
public:
	class UBehaviorTreeComponent*                 M_pBTComponent;                                    // 0x0000(0x0008)(ExportObject, ZeroConstructor, Transient, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UBlackboardComponent*                   M_pBlackboard;                                     // 0x0008(0x0008)(ExportObject, ZeroConstructor, Transient, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UBFGNetworkPathAgent_Vehicle*           M_pVehicle;                                        // 0x0010(0x0008)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EBFGBehaviourState_NPC                        M_eState;                                          // 0x0018(0x0001)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_19[0xF];                                       // 0x0019(0x000F)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FBFGTaskNode_VehicleContext) == 0x000008, "Wrong alignment on FBFGTaskNode_VehicleContext");
static_assert(sizeof(FBFGTaskNode_VehicleContext) == 0x000028, "Wrong size on FBFGTaskNode_VehicleContext");
static_assert(offsetof(FBFGTaskNode_VehicleContext, M_pBTComponent) == 0x000000, "Member 'FBFGTaskNode_VehicleContext::M_pBTComponent' has a wrong offset!");
static_assert(offsetof(FBFGTaskNode_VehicleContext, M_pBlackboard) == 0x000008, "Member 'FBFGTaskNode_VehicleContext::M_pBlackboard' has a wrong offset!");
static_assert(offsetof(FBFGTaskNode_VehicleContext, M_pVehicle) == 0x000010, "Member 'FBFGTaskNode_VehicleContext::M_pVehicle' has a wrong offset!");
static_assert(offsetof(FBFGTaskNode_VehicleContext, M_eState) == 0x000018, "Member 'FBFGTaskNode_VehicleContext::M_eState' has a wrong offset!");

// ScriptStruct BFGCore.QueuedDamageEvent
// 0x00C8 (0x00C8 - 0x0000)
struct FQueuedDamageEvent final
{
public:
	uint8                                         Pad_0[0x8];                                        // 0x0000(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	struct FPointDamageEvent                      DamageEvent;                                       // 0x0008(0x00A8)(ContainsInstancedReference, NativeAccessSpecifierPublic)
	class AController*                            EventInstigator;                                   // 0x00B0(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class AActor*                                 DamageCauser;                                      // 0x00B8(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UBFGNetworkPathAgent*                   M_pTarget;                                         // 0x00C0(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FQueuedDamageEvent) == 0x000008, "Wrong alignment on FQueuedDamageEvent");
static_assert(sizeof(FQueuedDamageEvent) == 0x0000C8, "Wrong size on FQueuedDamageEvent");
static_assert(offsetof(FQueuedDamageEvent, DamageEvent) == 0x000008, "Member 'FQueuedDamageEvent::DamageEvent' has a wrong offset!");
static_assert(offsetof(FQueuedDamageEvent, EventInstigator) == 0x0000B0, "Member 'FQueuedDamageEvent::EventInstigator' has a wrong offset!");
static_assert(offsetof(FQueuedDamageEvent, DamageCauser) == 0x0000B8, "Member 'FQueuedDamageEvent::DamageCauser' has a wrong offset!");
static_assert(offsetof(FQueuedDamageEvent, M_pTarget) == 0x0000C0, "Member 'FQueuedDamageEvent::M_pTarget' has a wrong offset!");

// ScriptStruct BFGCore.BFGTransmogrifyLootData
// 0x0010 (0x0010 - 0x0000)
struct FBFGTransmogrifyLootData final
{
public:
	TSubclassOf<class ABFGItemValuePack>          M_pItemClass;                                      // 0x0000(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         M_iQuantity;                                       // 0x0008(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_C[0x4];                                        // 0x000C(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FBFGTransmogrifyLootData) == 0x000008, "Wrong alignment on FBFGTransmogrifyLootData");
static_assert(sizeof(FBFGTransmogrifyLootData) == 0x000010, "Wrong size on FBFGTransmogrifyLootData");
static_assert(offsetof(FBFGTransmogrifyLootData, M_pItemClass) == 0x000000, "Member 'FBFGTransmogrifyLootData::M_pItemClass' has a wrong offset!");
static_assert(offsetof(FBFGTransmogrifyLootData, M_iQuantity) == 0x000008, "Member 'FBFGTransmogrifyLootData::M_iQuantity' has a wrong offset!");

// ScriptStruct BFGCore.BFGTransmogrifyLootTableEntry
// 0x0030 (0x0030 - 0x0000)
struct FBFGTransmogrifyLootTableEntry final
{
public:
	TArray<struct FBFGTransmogrifyLootData>       M_aLootData;                                       // 0x0000(0x0010)(Edit, ZeroConstructor, NativeAccessSpecifierPublic)
	struct FGameplayTagContainer                  M_oPrerequisites;                                  // 0x0010(0x0020)(Edit, NativeAccessSpecifierPublic)
};
static_assert(alignof(FBFGTransmogrifyLootTableEntry) == 0x000008, "Wrong alignment on FBFGTransmogrifyLootTableEntry");
static_assert(sizeof(FBFGTransmogrifyLootTableEntry) == 0x000030, "Wrong size on FBFGTransmogrifyLootTableEntry");
static_assert(offsetof(FBFGTransmogrifyLootTableEntry, M_aLootData) == 0x000000, "Member 'FBFGTransmogrifyLootTableEntry::M_aLootData' has a wrong offset!");
static_assert(offsetof(FBFGTransmogrifyLootTableEntry, M_oPrerequisites) == 0x000010, "Member 'FBFGTransmogrifyLootTableEntry::M_oPrerequisites' has a wrong offset!");

// ScriptStruct BFGCore.BFGVehicleDefinitionRow
// 0x0400 (0x0408 - 0x0008)
struct FBFGVehicleDefinitionRow final : public FTableRowBase
{
public:
	class FName                                   M_strName;                                         // 0x0008(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TSubclassOf<class AActor>                     M_initialSpawningActorType;                        // 0x0010(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FBFGWheeledVehicleConfig               M_config;                                          // 0x0018(0x03B8)(Edit, BlueprintVisible, BlueprintReadOnly, DisableEditOnInstance, NativeAccessSpecifierPublic)
	struct FBFGNetworkPathAgentLODInfo            M_lodInfo;                                         // 0x03D0(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, DisableEditOnInstance, NativeAccessSpecifierPublic)
	struct FGameplayTagContainer                  M_gameplayTags;                                    // 0x03E0(0x0020)(Edit, BlueprintVisible, BlueprintReadOnly, DisableEditOnInstance, NativeAccessSpecifierPublic)
	bool                                          M_bIsEnemy;                                        // 0x0400(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_401[0x7];                                      // 0x0401(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FBFGVehicleDefinitionRow) == 0x000008, "Wrong alignment on FBFGVehicleDefinitionRow");
static_assert(sizeof(FBFGVehicleDefinitionRow) == 0x000408, "Wrong size on FBFGVehicleDefinitionRow");
static_assert(offsetof(FBFGVehicleDefinitionRow, M_strName) == 0x000008, "Member 'FBFGVehicleDefinitionRow::M_strName' has a wrong offset!");
static_assert(offsetof(FBFGVehicleDefinitionRow, M_initialSpawningActorType) == 0x000010, "Member 'FBFGVehicleDefinitionRow::M_initialSpawningActorType' has a wrong offset!");
static_assert(offsetof(FBFGVehicleDefinitionRow, M_config) == 0x000018, "Member 'FBFGVehicleDefinitionRow::M_config' has a wrong offset!");
static_assert(offsetof(FBFGVehicleDefinitionRow, M_lodInfo) == 0x0003D0, "Member 'FBFGVehicleDefinitionRow::M_lodInfo' has a wrong offset!");
static_assert(offsetof(FBFGVehicleDefinitionRow, M_gameplayTags) == 0x0003E0, "Member 'FBFGVehicleDefinitionRow::M_gameplayTags' has a wrong offset!");
static_assert(offsetof(FBFGVehicleDefinitionRow, M_bIsEnemy) == 0x000400, "Member 'FBFGVehicleDefinitionRow::M_bIsEnemy' has a wrong offset!");

// ScriptStruct BFGCore.BFGDoorState
// 0x0038 (0x0038 - 0x0000)
struct FBFGDoorState final
{
public:
	int32                                         M_iDoorIndex;                                      // 0x0000(0x0004)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EBFGDoorState                                 M_eDoorState;                                      // 0x0004(0x0001)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_5[0x3];                                        // 0x0005(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         M_fCurrentAnimTime;                                // 0x0008(0x0004)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         M_fAnimLength;                                     // 0x000C(0x0004)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UCurveFloat*                            M_pAnimation;                                      // 0x0010(0x0008)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   M_boneName;                                        // 0x0018(0x0008)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          M_bDirty;                                          // 0x0020(0x0001)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_21[0x3];                                       // 0x0021(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         M_fInitialAngle;                                   // 0x0024(0x0004)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         M_fCurrentAngle;                                   // 0x0028(0x0004)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         M_fTargetAngle;                                    // 0x002C(0x0004)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EBFGDoorRotationAxis                          M_eRotationAxis;                                   // 0x0030(0x0001)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_31[0x7];                                       // 0x0031(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FBFGDoorState) == 0x000008, "Wrong alignment on FBFGDoorState");
static_assert(sizeof(FBFGDoorState) == 0x000038, "Wrong size on FBFGDoorState");
static_assert(offsetof(FBFGDoorState, M_iDoorIndex) == 0x000000, "Member 'FBFGDoorState::M_iDoorIndex' has a wrong offset!");
static_assert(offsetof(FBFGDoorState, M_eDoorState) == 0x000004, "Member 'FBFGDoorState::M_eDoorState' has a wrong offset!");
static_assert(offsetof(FBFGDoorState, M_fCurrentAnimTime) == 0x000008, "Member 'FBFGDoorState::M_fCurrentAnimTime' has a wrong offset!");
static_assert(offsetof(FBFGDoorState, M_fAnimLength) == 0x00000C, "Member 'FBFGDoorState::M_fAnimLength' has a wrong offset!");
static_assert(offsetof(FBFGDoorState, M_pAnimation) == 0x000010, "Member 'FBFGDoorState::M_pAnimation' has a wrong offset!");
static_assert(offsetof(FBFGDoorState, M_boneName) == 0x000018, "Member 'FBFGDoorState::M_boneName' has a wrong offset!");
static_assert(offsetof(FBFGDoorState, M_bDirty) == 0x000020, "Member 'FBFGDoorState::M_bDirty' has a wrong offset!");
static_assert(offsetof(FBFGDoorState, M_fInitialAngle) == 0x000024, "Member 'FBFGDoorState::M_fInitialAngle' has a wrong offset!");
static_assert(offsetof(FBFGDoorState, M_fCurrentAngle) == 0x000028, "Member 'FBFGDoorState::M_fCurrentAngle' has a wrong offset!");
static_assert(offsetof(FBFGDoorState, M_fTargetAngle) == 0x00002C, "Member 'FBFGDoorState::M_fTargetAngle' has a wrong offset!");
static_assert(offsetof(FBFGDoorState, M_eRotationAxis) == 0x000030, "Member 'FBFGDoorState::M_eRotationAxis' has a wrong offset!");

// ScriptStruct BFGCore.BFGVehicleState
// 0x0018 (0x0018 - 0x0000)
struct FBFGVehicleState final
{
public:
	TArray<struct FBFGDoorState>                  M_aDoorsState;                                     // 0x0000(0x0010)(ZeroConstructor, Transient, NativeAccessSpecifierPublic)
	bool                                          M_bIsNavModifierActive;                            // 0x0010(0x0001)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_11[0x7];                                       // 0x0011(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FBFGVehicleState) == 0x000008, "Wrong alignment on FBFGVehicleState");
static_assert(sizeof(FBFGVehicleState) == 0x000018, "Wrong size on FBFGVehicleState");
static_assert(offsetof(FBFGVehicleState, M_aDoorsState) == 0x000000, "Member 'FBFGVehicleState::M_aDoorsState' has a wrong offset!");
static_assert(offsetof(FBFGVehicleState, M_bIsNavModifierActive) == 0x000010, "Member 'FBFGVehicleState::M_bIsNavModifierActive' has a wrong offset!");

// ScriptStruct BFGCore.BFGVehiclePassengerSpot
// 0x0190 (0x0190 - 0x0000)
struct FBFGVehiclePassengerSpot final
{
public:
	struct FBFGSpotPassengerAnimData              M_passengerAnimationData;                          // 0x0000(0x0018)(Transient, Protected, NativeAccessSpecifierProtected)
	EBFGVehiclePassenger_Spot                     M_eSpot;                                           // 0x0018(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_19[0x7];                                       // 0x0019(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	class UBFGNetworkPathAgent_Human*             M_pPassenger;                                      // 0x0020(0x0008)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	EBFGVehiclePassenger_PassengerState           M_ePassengerState;                                 // 0x0028(0x0001)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_29[0x7];                                       // 0x0029(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	class UBFGNetworkPathAgent_Vehicle*           M_pVehicle;                                        // 0x0030(0x0008)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_38[0x4];                                       // 0x0038(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	struct FVector                                M_vCarEntryLocationOffset;                         // 0x003C(0x000C)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	struct FRotator                               M_vCarEntryRotationOffset;                         // 0x0048(0x000C)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, NativeAccessSpecifierProtected)
	class FName                                   M_DoorBoneName;                                    // 0x0054(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_5C[0x4];                                       // 0x005C(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class UCurveFloat*                            M_pDoorAnimCurve;                                  // 0x0060(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UBFGVehiclePassengerContainer*          M_pContainer;                                      // 0x0068(0x0008)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	struct FGameplayTagContainer                  M_passengerTags;                                   // 0x0070(0x0020)(Transient, Protected, NativeAccessSpecifierProtected)
	struct FGameplayTagQuery                      M_passengerTagQuery;                               // 0x0090(0x0048)(Transient, Protected, NativeAccessSpecifierProtected)
	uint8                                         Pad_D8[0x4];                                       // 0x00D8(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class FName                                   M_SeatBoneName;                                    // 0x00DC(0x0008)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	struct FVector                                M_vOffsetFromStandardAnim;                         // 0x00E4(0x000C)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         M_fProbability;                                    // 0x00F0(0x0004)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_F4[0x4];                                       // 0x00F4(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	struct FGameplayTagContainer                  M_tagsToAdd;                                       // 0x00F8(0x0020)(Transient, Protected, NativeAccessSpecifierProtected)
	struct FGameplayTagContainer                  M_tagsToAddGameplayEffects;                        // 0x0118(0x0020)(Transient, Protected, NativeAccessSpecifierProtected)
	bool                                          M_bEnabled;                                        // 0x0138(0x0001)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_139[0x7];                                      // 0x0139(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	struct FTransform                             M_cachedRelativeTransform;                         // 0x0140(0x0030)(Transient, IsPlainOldData, NoDestructor, Protected, NativeAccessSpecifierProtected)
	bool                                          M_bRelativeTransformCached;                        // 0x0170(0x0001)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_171[0x3];                                      // 0x0171(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	int32                                         M_iSynchronizationTicket;                          // 0x0174(0x0004)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          M_bPlayFastAnimationRequested;                     // 0x0178(0x0001)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	EBFGVehiclePassenger_PassengerInVehicleAnimation M_eInVehicleAnimation;                             // 0x0179(0x0001)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_17A[0x2];                                      // 0x017A(0x0002)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         M_fAnimationTimer;                                 // 0x017C(0x0004)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          M_bIsTransformAttachedToVehicle;                   // 0x0180(0x0001)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_181[0xF];                                      // 0x0181(0x000F)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FBFGVehiclePassengerSpot) == 0x000010, "Wrong alignment on FBFGVehiclePassengerSpot");
static_assert(sizeof(FBFGVehiclePassengerSpot) == 0x000190, "Wrong size on FBFGVehiclePassengerSpot");
static_assert(offsetof(FBFGVehiclePassengerSpot, M_passengerAnimationData) == 0x000000, "Member 'FBFGVehiclePassengerSpot::M_passengerAnimationData' has a wrong offset!");
static_assert(offsetof(FBFGVehiclePassengerSpot, M_eSpot) == 0x000018, "Member 'FBFGVehiclePassengerSpot::M_eSpot' has a wrong offset!");
static_assert(offsetof(FBFGVehiclePassengerSpot, M_pPassenger) == 0x000020, "Member 'FBFGVehiclePassengerSpot::M_pPassenger' has a wrong offset!");
static_assert(offsetof(FBFGVehiclePassengerSpot, M_ePassengerState) == 0x000028, "Member 'FBFGVehiclePassengerSpot::M_ePassengerState' has a wrong offset!");
static_assert(offsetof(FBFGVehiclePassengerSpot, M_pVehicle) == 0x000030, "Member 'FBFGVehiclePassengerSpot::M_pVehicle' has a wrong offset!");
static_assert(offsetof(FBFGVehiclePassengerSpot, M_vCarEntryLocationOffset) == 0x00003C, "Member 'FBFGVehiclePassengerSpot::M_vCarEntryLocationOffset' has a wrong offset!");
static_assert(offsetof(FBFGVehiclePassengerSpot, M_vCarEntryRotationOffset) == 0x000048, "Member 'FBFGVehiclePassengerSpot::M_vCarEntryRotationOffset' has a wrong offset!");
static_assert(offsetof(FBFGVehiclePassengerSpot, M_DoorBoneName) == 0x000054, "Member 'FBFGVehiclePassengerSpot::M_DoorBoneName' has a wrong offset!");
static_assert(offsetof(FBFGVehiclePassengerSpot, M_pDoorAnimCurve) == 0x000060, "Member 'FBFGVehiclePassengerSpot::M_pDoorAnimCurve' has a wrong offset!");
static_assert(offsetof(FBFGVehiclePassengerSpot, M_pContainer) == 0x000068, "Member 'FBFGVehiclePassengerSpot::M_pContainer' has a wrong offset!");
static_assert(offsetof(FBFGVehiclePassengerSpot, M_passengerTags) == 0x000070, "Member 'FBFGVehiclePassengerSpot::M_passengerTags' has a wrong offset!");
static_assert(offsetof(FBFGVehiclePassengerSpot, M_passengerTagQuery) == 0x000090, "Member 'FBFGVehiclePassengerSpot::M_passengerTagQuery' has a wrong offset!");
static_assert(offsetof(FBFGVehiclePassengerSpot, M_SeatBoneName) == 0x0000DC, "Member 'FBFGVehiclePassengerSpot::M_SeatBoneName' has a wrong offset!");
static_assert(offsetof(FBFGVehiclePassengerSpot, M_vOffsetFromStandardAnim) == 0x0000E4, "Member 'FBFGVehiclePassengerSpot::M_vOffsetFromStandardAnim' has a wrong offset!");
static_assert(offsetof(FBFGVehiclePassengerSpot, M_fProbability) == 0x0000F0, "Member 'FBFGVehiclePassengerSpot::M_fProbability' has a wrong offset!");
static_assert(offsetof(FBFGVehiclePassengerSpot, M_tagsToAdd) == 0x0000F8, "Member 'FBFGVehiclePassengerSpot::M_tagsToAdd' has a wrong offset!");
static_assert(offsetof(FBFGVehiclePassengerSpot, M_tagsToAddGameplayEffects) == 0x000118, "Member 'FBFGVehiclePassengerSpot::M_tagsToAddGameplayEffects' has a wrong offset!");
static_assert(offsetof(FBFGVehiclePassengerSpot, M_bEnabled) == 0x000138, "Member 'FBFGVehiclePassengerSpot::M_bEnabled' has a wrong offset!");
static_assert(offsetof(FBFGVehiclePassengerSpot, M_cachedRelativeTransform) == 0x000140, "Member 'FBFGVehiclePassengerSpot::M_cachedRelativeTransform' has a wrong offset!");
static_assert(offsetof(FBFGVehiclePassengerSpot, M_bRelativeTransformCached) == 0x000170, "Member 'FBFGVehiclePassengerSpot::M_bRelativeTransformCached' has a wrong offset!");
static_assert(offsetof(FBFGVehiclePassengerSpot, M_iSynchronizationTicket) == 0x000174, "Member 'FBFGVehiclePassengerSpot::M_iSynchronizationTicket' has a wrong offset!");
static_assert(offsetof(FBFGVehiclePassengerSpot, M_bPlayFastAnimationRequested) == 0x000178, "Member 'FBFGVehiclePassengerSpot::M_bPlayFastAnimationRequested' has a wrong offset!");
static_assert(offsetof(FBFGVehiclePassengerSpot, M_eInVehicleAnimation) == 0x000179, "Member 'FBFGVehiclePassengerSpot::M_eInVehicleAnimation' has a wrong offset!");
static_assert(offsetof(FBFGVehiclePassengerSpot, M_fAnimationTimer) == 0x00017C, "Member 'FBFGVehiclePassengerSpot::M_fAnimationTimer' has a wrong offset!");
static_assert(offsetof(FBFGVehiclePassengerSpot, M_bIsTransformAttachedToVehicle) == 0x000180, "Member 'FBFGVehiclePassengerSpot::M_bIsTransformAttachedToVehicle' has a wrong offset!");

// ScriptStruct BFGCore.BFGVoiceoverQueuedRequest
// 0x0140 (0x0140 - 0x0000)
struct FBFGVoiceoverQueuedRequest final
{
public:
	float                                         M_fTimeRemainingInQueue;                           // 0x0000(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_4[0x4];                                        // 0x0004(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	struct FBFGVoiceoverPlaybackRequest           M_request;                                         // 0x0008(0x0130)(NativeAccessSpecifierPublic)
	EBFGVoiceoverQueuedRequestState               M_state;                                           // 0x0138(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_139[0x7];                                      // 0x0139(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FBFGVoiceoverQueuedRequest) == 0x000008, "Wrong alignment on FBFGVoiceoverQueuedRequest");
static_assert(sizeof(FBFGVoiceoverQueuedRequest) == 0x000140, "Wrong size on FBFGVoiceoverQueuedRequest");
static_assert(offsetof(FBFGVoiceoverQueuedRequest, M_fTimeRemainingInQueue) == 0x000000, "Member 'FBFGVoiceoverQueuedRequest::M_fTimeRemainingInQueue' has a wrong offset!");
static_assert(offsetof(FBFGVoiceoverQueuedRequest, M_request) == 0x000008, "Member 'FBFGVoiceoverQueuedRequest::M_request' has a wrong offset!");
static_assert(offsetof(FBFGVoiceoverQueuedRequest, M_state) == 0x000138, "Member 'FBFGVoiceoverQueuedRequest::M_state' has a wrong offset!");

// ScriptStruct BFGCore.ResponseGraph
// 0x0008 (0x0008 - 0x0000)
struct alignas(0x04) FResponseGraph final
{
public:
	uint8                                         Pad_0[0x8];                                        // 0x0000(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FResponseGraph) == 0x000004, "Wrong alignment on FResponseGraph");
static_assert(sizeof(FResponseGraph) == 0x000008, "Wrong size on FResponseGraph");

// ScriptStruct BFGCore.BFGWaterManagerCachedMesh
// 0x0020 (0x0020 - 0x0000)
struct FBFGWaterManagerCachedMesh final
{
public:
	class UStaticMeshComponent*                   PMesh;                                             // 0x0000(0x0008)(ExportObject, ZeroConstructor, Transient, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FBox2D                                 OBounds;                                           // 0x0008(0x0014)(ZeroConstructor, Transient, NoDestructor, NativeAccessSpecifierPublic)
	uint8                                         Pad_1C[0x4];                                       // 0x001C(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FBFGWaterManagerCachedMesh) == 0x000008, "Wrong alignment on FBFGWaterManagerCachedMesh");
static_assert(sizeof(FBFGWaterManagerCachedMesh) == 0x000020, "Wrong size on FBFGWaterManagerCachedMesh");
static_assert(offsetof(FBFGWaterManagerCachedMesh, PMesh) == 0x000000, "Member 'FBFGWaterManagerCachedMesh::PMesh' has a wrong offset!");
static_assert(offsetof(FBFGWaterManagerCachedMesh, OBounds) == 0x000008, "Member 'FBFGWaterManagerCachedMesh::OBounds' has a wrong offset!");

// ScriptStruct BFGCore.BFGWaterManagerCachedActor
// 0x0028 (0x0028 - 0x0000)
struct FBFGWaterManagerCachedActor final
{
public:
	TArray<struct FBFGWaterManagerCachedMesh>     AMeshes;                                           // 0x0000(0x0010)(ZeroConstructor, Transient, ContainsInstancedReference, NativeAccessSpecifierPublic)
	struct FBox2D                                 OBounds;                                           // 0x0010(0x0014)(ZeroConstructor, Transient, NoDestructor, NativeAccessSpecifierPublic)
	uint8                                         Pad_24[0x4];                                       // 0x0024(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FBFGWaterManagerCachedActor) == 0x000008, "Wrong alignment on FBFGWaterManagerCachedActor");
static_assert(sizeof(FBFGWaterManagerCachedActor) == 0x000028, "Wrong size on FBFGWaterManagerCachedActor");
static_assert(offsetof(FBFGWaterManagerCachedActor, AMeshes) == 0x000000, "Member 'FBFGWaterManagerCachedActor::AMeshes' has a wrong offset!");
static_assert(offsetof(FBFGWaterManagerCachedActor, OBounds) == 0x000010, "Member 'FBFGWaterManagerCachedActor::OBounds' has a wrong offset!");

// ScriptStruct BFGCore.BFGDisintegratorDotInfo
// 0x0018 (0x0018 - 0x0000)
struct FBFGDisintegratorDotInfo final
{
public:
	class AActor*                                 M_pActor;                                          // 0x0000(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_8[0x10];                                       // 0x0008(0x0010)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FBFGDisintegratorDotInfo) == 0x000008, "Wrong alignment on FBFGDisintegratorDotInfo");
static_assert(sizeof(FBFGDisintegratorDotInfo) == 0x000018, "Wrong size on FBFGDisintegratorDotInfo");
static_assert(offsetof(FBFGDisintegratorDotInfo, M_pActor) == 0x000000, "Member 'FBFGDisintegratorDotInfo::M_pActor' has a wrong offset!");

// ScriptStruct BFGCore.BFGHoloPoxDeckInfo
// 0x0020 (0x0020 - 0x0000)
struct FBFGHoloPoxDeckInfo final
{
public:
	bool                                          M_bCompletion;                                     // 0x0000(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1[0x7];                                        // 0x0001(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	class FText                                   M_strCompletionQuest;                              // 0x0008(0x0018)(BlueprintVisible, BlueprintReadOnly, NativeAccessSpecifierPublic)
};
static_assert(alignof(FBFGHoloPoxDeckInfo) == 0x000008, "Wrong alignment on FBFGHoloPoxDeckInfo");
static_assert(sizeof(FBFGHoloPoxDeckInfo) == 0x000020, "Wrong size on FBFGHoloPoxDeckInfo");
static_assert(offsetof(FBFGHoloPoxDeckInfo, M_bCompletion) == 0x000000, "Member 'FBFGHoloPoxDeckInfo::M_bCompletion' has a wrong offset!");
static_assert(offsetof(FBFGHoloPoxDeckInfo, M_strCompletionQuest) == 0x000008, "Member 'FBFGHoloPoxDeckInfo::M_strCompletionQuest' has a wrong offset!");

// ScriptStruct BFGCore.BFGHolobobDeckSelectionInfo
// 0x0130 (0x0130 - 0x0000)
struct FBFGHolobobDeckSelectionInfo final
{
public:
	class FName                                   M_oWorldIdentifier;                                // 0x0000(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FText                                   M_oWorldName;                                      // 0x0008(0x0018)(BlueprintVisible, BlueprintReadOnly, NativeAccessSpecifierPublic)
	class FText                                   M_oMissionName;                                    // 0x0020(0x0018)(BlueprintVisible, BlueprintReadOnly, NativeAccessSpecifierPublic)
	struct FSlateBrush                            M_oMissionImage;                                   // 0x0038(0x0088)(BlueprintVisible, BlueprintReadOnly, NativeAccessSpecifierPublic)
	class FText                                   M_oMissionDescription;                             // 0x00C0(0x0018)(BlueprintVisible, BlueprintReadOnly, NativeAccessSpecifierPublic)
	class FString                                 M_strLongPackageName;                              // 0x00D8(0x0010)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         M_fCompletionRating;                               // 0x00E8(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         M_iTotalStars;                                     // 0x00EC(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         M_iGainedStars;                                    // 0x00F0(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          M_bIsAvailable;                                    // 0x00F4(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          M_bGainedReward;                                   // 0x00F5(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_F6[0x2];                                       // 0x00F6(0x0002)(Fixing Size After Last Property [ Dumper-7 ])
	class FText                                   M_bRewardDescription;                              // 0x00F8(0x0018)(BlueprintVisible, BlueprintReadOnly, NativeAccessSpecifierPublic)
	TArray<struct FBFGHoloPoxDeckInfo>            M_aoCompletionSubQuestText;                        // 0x0110(0x0010)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, NativeAccessSpecifierPublic)
	int32                                         M_iSortIndex;                                      // 0x0120(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_124[0x4];                                      // 0x0124(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	TSubclassOf<class UBFGQuest>                  M_pQuestClass;                                     // 0x0128(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FBFGHolobobDeckSelectionInfo) == 0x000008, "Wrong alignment on FBFGHolobobDeckSelectionInfo");
static_assert(sizeof(FBFGHolobobDeckSelectionInfo) == 0x000130, "Wrong size on FBFGHolobobDeckSelectionInfo");
static_assert(offsetof(FBFGHolobobDeckSelectionInfo, M_oWorldIdentifier) == 0x000000, "Member 'FBFGHolobobDeckSelectionInfo::M_oWorldIdentifier' has a wrong offset!");
static_assert(offsetof(FBFGHolobobDeckSelectionInfo, M_oWorldName) == 0x000008, "Member 'FBFGHolobobDeckSelectionInfo::M_oWorldName' has a wrong offset!");
static_assert(offsetof(FBFGHolobobDeckSelectionInfo, M_oMissionName) == 0x000020, "Member 'FBFGHolobobDeckSelectionInfo::M_oMissionName' has a wrong offset!");
static_assert(offsetof(FBFGHolobobDeckSelectionInfo, M_oMissionImage) == 0x000038, "Member 'FBFGHolobobDeckSelectionInfo::M_oMissionImage' has a wrong offset!");
static_assert(offsetof(FBFGHolobobDeckSelectionInfo, M_oMissionDescription) == 0x0000C0, "Member 'FBFGHolobobDeckSelectionInfo::M_oMissionDescription' has a wrong offset!");
static_assert(offsetof(FBFGHolobobDeckSelectionInfo, M_strLongPackageName) == 0x0000D8, "Member 'FBFGHolobobDeckSelectionInfo::M_strLongPackageName' has a wrong offset!");
static_assert(offsetof(FBFGHolobobDeckSelectionInfo, M_fCompletionRating) == 0x0000E8, "Member 'FBFGHolobobDeckSelectionInfo::M_fCompletionRating' has a wrong offset!");
static_assert(offsetof(FBFGHolobobDeckSelectionInfo, M_iTotalStars) == 0x0000EC, "Member 'FBFGHolobobDeckSelectionInfo::M_iTotalStars' has a wrong offset!");
static_assert(offsetof(FBFGHolobobDeckSelectionInfo, M_iGainedStars) == 0x0000F0, "Member 'FBFGHolobobDeckSelectionInfo::M_iGainedStars' has a wrong offset!");
static_assert(offsetof(FBFGHolobobDeckSelectionInfo, M_bIsAvailable) == 0x0000F4, "Member 'FBFGHolobobDeckSelectionInfo::M_bIsAvailable' has a wrong offset!");
static_assert(offsetof(FBFGHolobobDeckSelectionInfo, M_bGainedReward) == 0x0000F5, "Member 'FBFGHolobobDeckSelectionInfo::M_bGainedReward' has a wrong offset!");
static_assert(offsetof(FBFGHolobobDeckSelectionInfo, M_bRewardDescription) == 0x0000F8, "Member 'FBFGHolobobDeckSelectionInfo::M_bRewardDescription' has a wrong offset!");
static_assert(offsetof(FBFGHolobobDeckSelectionInfo, M_aoCompletionSubQuestText) == 0x000110, "Member 'FBFGHolobobDeckSelectionInfo::M_aoCompletionSubQuestText' has a wrong offset!");
static_assert(offsetof(FBFGHolobobDeckSelectionInfo, M_iSortIndex) == 0x000120, "Member 'FBFGHolobobDeckSelectionInfo::M_iSortIndex' has a wrong offset!");
static_assert(offsetof(FBFGHolobobDeckSelectionInfo, M_pQuestClass) == 0x000128, "Member 'FBFGHolobobDeckSelectionInfo::M_pQuestClass' has a wrong offset!");

// ScriptStruct BFGCore.RadarWidgetPair
// 0x0018 (0x0018 - 0x0000)
struct FRadarWidgetPair final
{
public:
	class UWidget*                                M_pWidget;                                         // 0x0000(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UCanvasPanelSlot*                       M_pSlot;                                           // 0x0008(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_10[0x8];                                       // 0x0010(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FRadarWidgetPair) == 0x000008, "Wrong alignment on FRadarWidgetPair");
static_assert(sizeof(FRadarWidgetPair) == 0x000018, "Wrong size on FRadarWidgetPair");
static_assert(offsetof(FRadarWidgetPair, M_pWidget) == 0x000000, "Member 'FRadarWidgetPair::M_pWidget' has a wrong offset!");
static_assert(offsetof(FRadarWidgetPair, M_pSlot) == 0x000008, "Member 'FRadarWidgetPair::M_pSlot' has a wrong offset!");

// ScriptStruct BFGCore.WidgetPool
// 0x0070 (0x0070 - 0x0000)
struct FWidgetPool final
{
public:
	TArray<class UWidget*>                        M_apUnattachedPool;                                // 0x0000(0x0010)(ExportObject, ZeroConstructor, ContainsInstancedReference, NativeAccessSpecifierPublic)
	TArray<struct FRadarWidgetPair>               M_apAttachedPool;                                  // 0x0010(0x0010)(ZeroConstructor, ContainsInstancedReference, NativeAccessSpecifierPublic)
	uint8                                         Pad_20[0x50];                                      // 0x0020(0x0050)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FWidgetPool) == 0x000008, "Wrong alignment on FWidgetPool");
static_assert(sizeof(FWidgetPool) == 0x000070, "Wrong size on FWidgetPool");
static_assert(offsetof(FWidgetPool, M_apUnattachedPool) == 0x000000, "Member 'FWidgetPool::M_apUnattachedPool' has a wrong offset!");
static_assert(offsetof(FWidgetPool, M_apAttachedPool) == 0x000010, "Member 'FWidgetPool::M_apAttachedPool' has a wrong offset!");

// ScriptStruct BFGCore.DeferredMaterialCreate
// 0x0018 (0x0018 - 0x0000)
struct alignas(0x08) FDeferredMaterialCreate final
{
public:
	uint8                                         Pad_0[0x18];                                       // 0x0000(0x0018)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FDeferredMaterialCreate) == 0x000008, "Wrong alignment on FDeferredMaterialCreate");
static_assert(sizeof(FDeferredMaterialCreate) == 0x000018, "Wrong size on FDeferredMaterialCreate");

// ScriptStruct BFGCore.DeferredElementUpdate
// 0x0020 (0x0020 - 0x0000)
struct FDeferredElementUpdate final
{
public:
	class UWidget*                                M_pWidget;                                         // 0x0000(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UObject*                                M_pHint;                                           // 0x0008(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_10[0x10];                                      // 0x0010(0x0010)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FDeferredElementUpdate) == 0x000008, "Wrong alignment on FDeferredElementUpdate");
static_assert(sizeof(FDeferredElementUpdate) == 0x000020, "Wrong size on FDeferredElementUpdate");
static_assert(offsetof(FDeferredElementUpdate, M_pWidget) == 0x000000, "Member 'FDeferredElementUpdate::M_pWidget' has a wrong offset!");
static_assert(offsetof(FDeferredElementUpdate, M_pHint) == 0x000008, "Member 'FDeferredElementUpdate::M_pHint' has a wrong offset!");

// ScriptStruct BFGCore.BFGMessageBoxParams
// 0x0038 (0x0038 - 0x0000)
struct FBFGMessageBoxParams final
{
public:
	class FText                                   M_message;                                         // 0x0000(0x0018)(BlueprintVisible, NativeAccessSpecifierPublic)
	EBFGMessageBoxType                            M_type;                                            // 0x0018(0x0001)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_19[0x7];                                       // 0x0019(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	UMulticastDelegateProperty_                   M_onClosed;                                        // 0x0020(0x0018)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
};
static_assert(alignof(FBFGMessageBoxParams) == 0x000008, "Wrong alignment on FBFGMessageBoxParams");
static_assert(sizeof(FBFGMessageBoxParams) == 0x000038, "Wrong size on FBFGMessageBoxParams");
static_assert(offsetof(FBFGMessageBoxParams, M_message) == 0x000000, "Member 'FBFGMessageBoxParams::M_message' has a wrong offset!");
static_assert(offsetof(FBFGMessageBoxParams, M_type) == 0x000018, "Member 'FBFGMessageBoxParams::M_type' has a wrong offset!");
static_assert(offsetof(FBFGMessageBoxParams, M_onClosed) == 0x000020, "Member 'FBFGMessageBoxParams::M_onClosed' has a wrong offset!");

// ScriptStruct BFGCore.BFGUpgradeInfo
// 0x0040 (0x0040 - 0x0000)
struct FBFGUpgradeInfo final
{
public:
	class FText                                   M_strUpgrade;                                      // 0x0000(0x0018)(BlueprintVisible, BlueprintReadOnly, NativeAccessSpecifierPublic)
	class FText                                   M_strUpgradeDescription;                           // 0x0018(0x0018)(BlueprintVisible, BlueprintReadOnly, NativeAccessSpecifierPublic)
	int32                                         M_iUpgradeLevel;                                   // 0x0030(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         M_iUpgradeCosts;                                   // 0x0034(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          M_bUpgraded;                                       // 0x0038(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          M_bPurchaseable;                                   // 0x0039(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          M_bIsSelected;                                     // 0x003A(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          M_bIsUpgradeable;                                  // 0x003B(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_3C[0x4];                                       // 0x003C(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FBFGUpgradeInfo) == 0x000008, "Wrong alignment on FBFGUpgradeInfo");
static_assert(sizeof(FBFGUpgradeInfo) == 0x000040, "Wrong size on FBFGUpgradeInfo");
static_assert(offsetof(FBFGUpgradeInfo, M_strUpgrade) == 0x000000, "Member 'FBFGUpgradeInfo::M_strUpgrade' has a wrong offset!");
static_assert(offsetof(FBFGUpgradeInfo, M_strUpgradeDescription) == 0x000018, "Member 'FBFGUpgradeInfo::M_strUpgradeDescription' has a wrong offset!");
static_assert(offsetof(FBFGUpgradeInfo, M_iUpgradeLevel) == 0x000030, "Member 'FBFGUpgradeInfo::M_iUpgradeLevel' has a wrong offset!");
static_assert(offsetof(FBFGUpgradeInfo, M_iUpgradeCosts) == 0x000034, "Member 'FBFGUpgradeInfo::M_iUpgradeCosts' has a wrong offset!");
static_assert(offsetof(FBFGUpgradeInfo, M_bUpgraded) == 0x000038, "Member 'FBFGUpgradeInfo::M_bUpgraded' has a wrong offset!");
static_assert(offsetof(FBFGUpgradeInfo, M_bPurchaseable) == 0x000039, "Member 'FBFGUpgradeInfo::M_bPurchaseable' has a wrong offset!");
static_assert(offsetof(FBFGUpgradeInfo, M_bIsSelected) == 0x00003A, "Member 'FBFGUpgradeInfo::M_bIsSelected' has a wrong offset!");
static_assert(offsetof(FBFGUpgradeInfo, M_bIsUpgradeable) == 0x00003B, "Member 'FBFGUpgradeInfo::M_bIsUpgradeable' has a wrong offset!");

// ScriptStruct BFGCore.InputHintBlockGridMapping
// 0x0010 (0x0010 - 0x0000)
struct FInputHintBlockGridMapping final
{
public:
	int32                                         M_iRow;                                            // 0x0000(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         M_iColumn;                                         // 0x0004(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         M_iRowSpan;                                        // 0x0008(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         M_iColumnSpan;                                     // 0x000C(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FInputHintBlockGridMapping) == 0x000004, "Wrong alignment on FInputHintBlockGridMapping");
static_assert(sizeof(FInputHintBlockGridMapping) == 0x000010, "Wrong size on FInputHintBlockGridMapping");
static_assert(offsetof(FInputHintBlockGridMapping, M_iRow) == 0x000000, "Member 'FInputHintBlockGridMapping::M_iRow' has a wrong offset!");
static_assert(offsetof(FInputHintBlockGridMapping, M_iColumn) == 0x000004, "Member 'FInputHintBlockGridMapping::M_iColumn' has a wrong offset!");
static_assert(offsetof(FInputHintBlockGridMapping, M_iRowSpan) == 0x000008, "Member 'FInputHintBlockGridMapping::M_iRowSpan' has a wrong offset!");
static_assert(offsetof(FInputHintBlockGridMapping, M_iColumnSpan) == 0x00000C, "Member 'FInputHintBlockGridMapping::M_iColumnSpan' has a wrong offset!");

}

