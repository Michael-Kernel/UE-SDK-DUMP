#pragma once

/*
* SDK generated by Dumper-7
*
* https://github.com/Encryqed/Dumper-7
*/

// Package: Blast

#include "Basic.hpp"

#include "Blast_structs.hpp"
#include "CoreUObject_structs.hpp"
#include "CoreUObject_classes.hpp"
#include "Engine_structs.hpp"
#include "Engine_classes.hpp"


namespace SDK
{

// Class Blast.BlastMeshComponent
// 0x0380 (0x0B70 - 0x07F0)
#pragma pack(push, 0x1)
class alignas(0x10) UBlastMeshComponent : public USkinnedMeshComponent
{
public:
	class UBlastMesh*                             BlastMesh;                                         // 0x07F0(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UBlastAsset*                            ModifiedAssetOwned;                                // 0x07F8(0x0008)(Edit, ExportObject, ZeroConstructor, EditConst, InstancedReference, IsPlainOldData, NoDestructor, AdvancedDisplay, Protected, PersistentInstance, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UBlastAsset*                            ModifiedAsset;                                     // 0x0800(0x0008)(Edit, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, AdvancedDisplay, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_808[0x8];                                      // 0x0808(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	struct FTransform                             ModifiedAssetComponentToWorldAtBake;               // 0x0810(0x0030)(Edit, EditConst, IsPlainOldData, NoDestructor, AdvancedDisplay, Protected, NativeAccessSpecifierProtected)
	class ABlastExtendedSupportStructure*         OwningSupportStructure;                            // 0x0840(0x0008)(Edit, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, AdvancedDisplay, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	int32                                         OwningSupportStructureIndex;                       // 0x0848(0x0004)(Edit, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, AdvancedDisplay, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bSupportedByWorld;                                 // 0x084C(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bOverride_BlastMaterial;                           // 0x084D(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_84E[0x2];                                      // 0x084E(0x0002)(Fixing Size After Last Property [ Dumper-7 ])
	struct FBlastMaterial                         BlastMaterial;                                     // 0x0850(0x0010)(Edit, NoDestructor, NativeAccessSpecifierPublic)
	bool                                          bOverride_ImpactDamageProperties;                  // 0x0860(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_861[0x3];                                      // 0x0861(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	struct FBlastImpactDamageProperties           ImpactDamageProperties;                            // 0x0864(0x0024)(Edit, NoDestructor, NativeAccessSpecifierPublic)
	bool                                          bOverride_StressProperties;                        // 0x0888(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_889[0x3];                                      // 0x0889(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	struct FBlastStressProperties                 StressProperties;                                  // 0x088C(0x0020)(Edit, NoDestructor, NativeAccessSpecifierPublic)
	bool                                          bOverride_DebrisProperties;                        // 0x08AC(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_8AD[0x3];                                      // 0x08AD(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	struct FBlastDebrisProperties                 DebrisProperties;                                  // 0x08B0(0x0010)(Edit, NativeAccessSpecifierPublic)
	struct FBodyInstance                          DynamicChunkBodyInstance;                          // 0x08C0(0x0160)(Edit, BlueprintVisible, BlueprintReadOnly, NativeAccessSpecifierPublic)
	UMulticastDelegateProperty_                   OnDamaged;                                         // 0x0A20(0x0018)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	UMulticastDelegateProperty_                   OnActorCreated;                                    // 0x0A38(0x0018)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	UMulticastDelegateProperty_                   OnActorDestroyed;                                  // 0x0A50(0x0018)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	UMulticastDelegateProperty_                   OnActorCreatedFromDamage;                          // 0x0A68(0x0018)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	UMulticastDelegateProperty_                   OnBondsDamaged;                                    // 0x0A80(0x0018)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	UMulticastDelegateProperty_                   OnChunksDamaged;                                   // 0x0A98(0x0018)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	uint8                                         Pad_AB0[0x98];                                     // 0x0AB0(0x0098)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<class UBodySetup*>                     ActorBodySetups;                                   // 0x0B48(0x0010)(ZeroConstructor, Transient, DuplicateTransient, Protected, NativeAccessSpecifierProtected)
	uint8                                         Pad_B58[0x10];                                     // 0x0B58(0x0010)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static EBlastDamageResult ApplyCapsuleDamageAll(const struct FVector& Origin, const struct FRotator& Rot, float HalfHeight, float MinRadius, float MaxRadius, float Damage, float ImpulseStrength, bool bImpulseVelChange);
	static EBlastDamageResult ApplyDamageComponentOverlapAll(class UBlastBaseDamageComponent* DamageComponent, const struct FVector& Origin, const struct FRotator& Rot);
	static EBlastDamageResult ApplyRadialDamageAll(const struct FVector& Origin, float MinRadius, float MaxRadius, float Damage, float ImpulseStrength, bool bImpulseVelChange);

	EBlastDamageResult ApplyCapsuleDamage(const struct FVector& Origin, const struct FRotator& Rot, float HalfHeight, float MinRadius, float MaxRadius, float Damage, float ImpulseStrength, bool bImpulseVelChange);
	EBlastDamageResult ApplyDamageComponent(class UBlastBaseDamageComponent* DamageComponent, const struct FVector& Origin, const struct FRotator& Rot, class FName BoneName);
	EBlastDamageResult ApplyDamageComponentOverlap(class UBlastBaseDamageComponent* DamageComponent, const struct FVector& Origin, const struct FRotator& Rot);
	EBlastDamageResult ApplyRadialDamage(const struct FVector& Origin, float MinRadius, float MaxRadius, float Damage, float ImpulseStrength, bool bImpulseVelChange);
	void OnHit(class UPrimitiveComponent* HitComponent, class AActor* OtherActor, class UPrimitiveComponent* OtherComp, const struct FVector& NormalImpulse, const struct FHitResult& Hit);
	void Reset();
	void SetBlastMesh(class UBlastMesh* NewBlastMesh);
	void SetDynamicChunkCollisionEnabled(ECollisionEnabled NewType);
	void SetDynamicChunkCollisionObjectType(ECollisionChannel Channel);
	void SetDynamicChunkCollisionProfileName(class FName InCollisionProfileName);
	void SetDynamicChunkCollisionResponseToAllChannels(ECollisionResponse NewResponse);
	void SetDynamicChunkCollisionResponseToChannel(ECollisionChannel Channel, ECollisionResponse NewResponse);

	class FName GetActorBoneName(class FName ActorName) const;
	struct FVector GetActorCOMWorldPosition(class FName ActorName) const;
	class FName GetActorForChunk(int32 ChunkIndex) const;
	float GetActorMass(class FName ActorName) const;
	struct FVector GetActorWorldAngularVelocity(class FName ActorName) const;
	struct FVector GetActorWorldAngularVelocityInDegrees(class FName ActorName) const;
	struct FVector GetActorWorldAngularVelocityInRadians(class FName ActorName) const;
	struct FBox GetActorWorldBounds(class FName ActorName) const;
	struct FTransform GetActorWorldTransform(class FName ActorName) const;
	struct FVector GetActorWorldVelocity(class FName ActorName) const;
	struct FTransform GetChunkActorRelativeTransform(int32 ChunkIndex) const;
	struct FVector GetChunkCenterWorldPosition(int32 ChunkIndex) const;
	struct FVector GetChunkWorldAngularVelocity(int32 ChunkIndex) const;
	struct FVector GetChunkWorldAngularVelocityInDegrees(int32 ChunkIndex) const;
	struct FVector GetChunkWorldAngularVelocityInRadians(int32 ChunkIndex) const;
	struct FBoxSphereBounds GetChunkWorldBounds(int32 ChunkIndex) const;
	struct FTransform GetChunkWorldTransform(int32 ChunkIndex) const;
	struct FVector GetChunkWorldVelocity(int32 ChunkIndex) const;
	class FName GetDynamicChunkCollisionProfileName() const;
	int32 HasChunkInSphere(const struct FVector& Center, float Radius) const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"BlastMeshComponent">();
	}
	static class UBlastMeshComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UBlastMeshComponent>();
	}
};
#pragma pack(pop)
static_assert(alignof(UBlastMeshComponent) == 0x000010, "Wrong alignment on UBlastMeshComponent");
static_assert(sizeof(UBlastMeshComponent) == 0x000B70, "Wrong size on UBlastMeshComponent");
static_assert(offsetof(UBlastMeshComponent, BlastMesh) == 0x0007F0, "Member 'UBlastMeshComponent::BlastMesh' has a wrong offset!");
static_assert(offsetof(UBlastMeshComponent, ModifiedAssetOwned) == 0x0007F8, "Member 'UBlastMeshComponent::ModifiedAssetOwned' has a wrong offset!");
static_assert(offsetof(UBlastMeshComponent, ModifiedAsset) == 0x000800, "Member 'UBlastMeshComponent::ModifiedAsset' has a wrong offset!");
static_assert(offsetof(UBlastMeshComponent, ModifiedAssetComponentToWorldAtBake) == 0x000810, "Member 'UBlastMeshComponent::ModifiedAssetComponentToWorldAtBake' has a wrong offset!");
static_assert(offsetof(UBlastMeshComponent, OwningSupportStructure) == 0x000840, "Member 'UBlastMeshComponent::OwningSupportStructure' has a wrong offset!");
static_assert(offsetof(UBlastMeshComponent, OwningSupportStructureIndex) == 0x000848, "Member 'UBlastMeshComponent::OwningSupportStructureIndex' has a wrong offset!");
static_assert(offsetof(UBlastMeshComponent, bSupportedByWorld) == 0x00084C, "Member 'UBlastMeshComponent::bSupportedByWorld' has a wrong offset!");
static_assert(offsetof(UBlastMeshComponent, bOverride_BlastMaterial) == 0x00084D, "Member 'UBlastMeshComponent::bOverride_BlastMaterial' has a wrong offset!");
static_assert(offsetof(UBlastMeshComponent, BlastMaterial) == 0x000850, "Member 'UBlastMeshComponent::BlastMaterial' has a wrong offset!");
static_assert(offsetof(UBlastMeshComponent, bOverride_ImpactDamageProperties) == 0x000860, "Member 'UBlastMeshComponent::bOverride_ImpactDamageProperties' has a wrong offset!");
static_assert(offsetof(UBlastMeshComponent, ImpactDamageProperties) == 0x000864, "Member 'UBlastMeshComponent::ImpactDamageProperties' has a wrong offset!");
static_assert(offsetof(UBlastMeshComponent, bOverride_StressProperties) == 0x000888, "Member 'UBlastMeshComponent::bOverride_StressProperties' has a wrong offset!");
static_assert(offsetof(UBlastMeshComponent, StressProperties) == 0x00088C, "Member 'UBlastMeshComponent::StressProperties' has a wrong offset!");
static_assert(offsetof(UBlastMeshComponent, bOverride_DebrisProperties) == 0x0008AC, "Member 'UBlastMeshComponent::bOverride_DebrisProperties' has a wrong offset!");
static_assert(offsetof(UBlastMeshComponent, DebrisProperties) == 0x0008B0, "Member 'UBlastMeshComponent::DebrisProperties' has a wrong offset!");
static_assert(offsetof(UBlastMeshComponent, DynamicChunkBodyInstance) == 0x0008C0, "Member 'UBlastMeshComponent::DynamicChunkBodyInstance' has a wrong offset!");
static_assert(offsetof(UBlastMeshComponent, OnDamaged) == 0x000A20, "Member 'UBlastMeshComponent::OnDamaged' has a wrong offset!");
static_assert(offsetof(UBlastMeshComponent, OnActorCreated) == 0x000A38, "Member 'UBlastMeshComponent::OnActorCreated' has a wrong offset!");
static_assert(offsetof(UBlastMeshComponent, OnActorDestroyed) == 0x000A50, "Member 'UBlastMeshComponent::OnActorDestroyed' has a wrong offset!");
static_assert(offsetof(UBlastMeshComponent, OnActorCreatedFromDamage) == 0x000A68, "Member 'UBlastMeshComponent::OnActorCreatedFromDamage' has a wrong offset!");
static_assert(offsetof(UBlastMeshComponent, OnBondsDamaged) == 0x000A80, "Member 'UBlastMeshComponent::OnBondsDamaged' has a wrong offset!");
static_assert(offsetof(UBlastMeshComponent, OnChunksDamaged) == 0x000A98, "Member 'UBlastMeshComponent::OnChunksDamaged' has a wrong offset!");
static_assert(offsetof(UBlastMeshComponent, ActorBodySetups) == 0x000B48, "Member 'UBlastMeshComponent::ActorBodySetups' has a wrong offset!");

// Class Blast.BlastExtendedSupportMeshComponent
// 0x0020 (0x0B90 - 0x0B70)
class UBlastExtendedSupportMeshComponent final : public UBlastMeshComponent
{
public:
	TArray<struct FBlastExtendedStructureComponent> SavedComponents;                                   // 0x0B68(0x0010)(Edit, ZeroConstructor, DisableEditOnTemplate, EditConst, ContainsInstancedReference, AdvancedDisplay, NativeAccessSpecifierPublic)
	TArray<struct FIntPoint>                      ChunkToOriginalChunkMap;                           // 0x0B78(0x0010)(ZeroConstructor, NativeAccessSpecifierPublic)
	uint8                                         Pad_B88[0x8];                                      // 0x0B88(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"BlastExtendedSupportMeshComponent">();
	}
	static class UBlastExtendedSupportMeshComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UBlastExtendedSupportMeshComponent>();
	}
};
static_assert(alignof(UBlastExtendedSupportMeshComponent) == 0x000010, "Wrong alignment on UBlastExtendedSupportMeshComponent");
static_assert(sizeof(UBlastExtendedSupportMeshComponent) == 0x000B90, "Wrong size on UBlastExtendedSupportMeshComponent");
static_assert(offsetof(UBlastExtendedSupportMeshComponent, SavedComponents) == 0x000B68, "Member 'UBlastExtendedSupportMeshComponent::SavedComponents' has a wrong offset!");
static_assert(offsetof(UBlastExtendedSupportMeshComponent, ChunkToOriginalChunkMap) == 0x000B78, "Member 'UBlastExtendedSupportMeshComponent::ChunkToOriginalChunkMap' has a wrong offset!");

// Class Blast.BlastAsset
// 0x0118 (0x0140 - 0x0028)
class UBlastAsset : public UObject
{
public:
	TArray<EBlastAssetChunkFlags>                 ChunksFlags;                                       // 0x0028(0x0010)(ZeroConstructor, NativeAccessSpecifierPrivate)
	struct FGuid                                  AssetGUID;                                         // 0x0038(0x0010)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_48[0xF8];                                      // 0x0048(0x00F8)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"BlastAsset">();
	}
	static class UBlastAsset* GetDefaultObj()
	{
		return GetDefaultObjImpl<UBlastAsset>();
	}
};
static_assert(alignof(UBlastAsset) == 0x000008, "Wrong alignment on UBlastAsset");
static_assert(sizeof(UBlastAsset) == 0x000140, "Wrong size on UBlastAsset");
static_assert(offsetof(UBlastAsset, ChunksFlags) == 0x000028, "Member 'UBlastAsset::ChunksFlags' has a wrong offset!");
static_assert(offsetof(UBlastAsset, AssetGUID) == 0x000038, "Member 'UBlastAsset::AssetGUID' has a wrong offset!");

// Class Blast.BlastAssetImportData
// 0x0020 (0x0048 - 0x0028)
class UBlastAssetImportData final : public UAssetImportData
{
public:
	struct FBlastAssetImportOptions               ImportOptions;                                     // 0x0028(0x0020)(Edit, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"BlastAssetImportData">();
	}
	static class UBlastAssetImportData* GetDefaultObj()
	{
		return GetDefaultObjImpl<UBlastAssetImportData>();
	}
};
static_assert(alignof(UBlastAssetImportData) == 0x000008, "Wrong alignment on UBlastAssetImportData");
static_assert(sizeof(UBlastAssetImportData) == 0x000048, "Wrong size on UBlastAssetImportData");
static_assert(offsetof(UBlastAssetImportData, ImportOptions) == 0x000028, "Member 'UBlastAssetImportData::ImportOptions' has a wrong offset!");

// Class Blast.BlastBaseDamageComponent
// 0x0008 (0x02A0 - 0x0298)
class UBlastBaseDamageComponent : public USceneComponent
{
public:
	bool                                          bDamageOnHit;                                      // 0x0298(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_299[0x7];                                      // 0x0299(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"BlastBaseDamageComponent">();
	}
	static class UBlastBaseDamageComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UBlastBaseDamageComponent>();
	}
};
static_assert(alignof(UBlastBaseDamageComponent) == 0x000008, "Wrong alignment on UBlastBaseDamageComponent");
static_assert(sizeof(UBlastBaseDamageComponent) == 0x0002A0, "Wrong size on UBlastBaseDamageComponent");
static_assert(offsetof(UBlastBaseDamageComponent, bDamageOnHit) == 0x000298, "Member 'UBlastBaseDamageComponent::bDamageOnHit' has a wrong offset!");

// Class Blast.BlastBlueprintFunctionLibrary
// 0x0000 (0x0028 - 0x0028)
class UBlastBlueprintFunctionLibrary final : public UBlueprintFunctionLibrary
{
public:
	static bool IsValidToApplyForces(class UPrimitiveComponent* Component, class FName BoneName);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"BlastBlueprintFunctionLibrary">();
	}
	static class UBlastBlueprintFunctionLibrary* GetDefaultObj()
	{
		return GetDefaultObjImpl<UBlastBlueprintFunctionLibrary>();
	}
};
static_assert(alignof(UBlastBlueprintFunctionLibrary) == 0x000008, "Wrong alignment on UBlastBlueprintFunctionLibrary");
static_assert(sizeof(UBlastBlueprintFunctionLibrary) == 0x000028, "Wrong size on UBlastBlueprintFunctionLibrary");

// Class Blast.BlastExtendedSupportStructure
// 0x0028 (0x0400 - 0x03D8)
class ABlastExtendedSupportStructure final : public AInfo
{
public:
	TArray<class AActor*>                         StructureActors;                                   // 0x03D8(0x0010)(Edit, ZeroConstructor, DisableEditOnTemplate, Protected, NativeAccessSpecifierProtected)
	float                                         bondGenerationDistance;                            // 0x03E8(0x0004)(Edit, ZeroConstructor, DisableEditOnTemplate, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_3EC[0x4];                                      // 0x03EC(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class UBlastExtendedSupportMeshComponent*     ExtendedSupportMesh;                               // 0x03F0(0x0008)(Edit, ExportObject, ZeroConstructor, EditConst, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bEnabled;                                          // 0x03F8(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_3F9[0x7];                                      // 0x03F9(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"BlastExtendedSupportStructure">();
	}
	static class ABlastExtendedSupportStructure* GetDefaultObj()
	{
		return GetDefaultObjImpl<ABlastExtendedSupportStructure>();
	}
};
static_assert(alignof(ABlastExtendedSupportStructure) == 0x000008, "Wrong alignment on ABlastExtendedSupportStructure");
static_assert(sizeof(ABlastExtendedSupportStructure) == 0x000400, "Wrong size on ABlastExtendedSupportStructure");
static_assert(offsetof(ABlastExtendedSupportStructure, StructureActors) == 0x0003D8, "Member 'ABlastExtendedSupportStructure::StructureActors' has a wrong offset!");
static_assert(offsetof(ABlastExtendedSupportStructure, bondGenerationDistance) == 0x0003E8, "Member 'ABlastExtendedSupportStructure::bondGenerationDistance' has a wrong offset!");
static_assert(offsetof(ABlastExtendedSupportStructure, ExtendedSupportMesh) == 0x0003F0, "Member 'ABlastExtendedSupportStructure::ExtendedSupportMesh' has a wrong offset!");
static_assert(offsetof(ABlastExtendedSupportStructure, bEnabled) == 0x0003F8, "Member 'ABlastExtendedSupportStructure::bEnabled' has a wrong offset!");

// Class Blast.BlastMesh
// 0x00D8 (0x0218 - 0x0140)
class UBlastMesh : public UBlastAsset
{
public:
	class USkeletalMesh*                          Mesh;                                              // 0x0140(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, PersistentInstance, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         NumTexCoord;                                       // 0x0148(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_14C[0x4];                                      // 0x014C(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class USkeleton*                              Skeleton;                                          // 0x0150(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, PersistentInstance, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UPhysicsAsset*                          PhysicsAsset;                                      // 0x0158(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, PersistentInstance, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FBlastMaterial                         BlastMaterial;                                     // 0x0160(0x0010)(Edit, NoDestructor, NativeAccessSpecifierPublic)
	struct FBlastImpactDamageProperties           ImpactDamageProperties;                            // 0x0170(0x0024)(Edit, NoDestructor, NativeAccessSpecifierPublic)
	struct FBlastStressProperties                 StressProperties;                                  // 0x0194(0x0020)(Edit, NoDestructor, NativeAccessSpecifierPublic)
	uint8                                         Pad_1B4[0x4];                                      // 0x01B4(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	struct FBlastDebrisProperties                 DebrisProperties;                                  // 0x01B8(0x0010)(Edit, NativeAccessSpecifierPublic)
	TArray<class FName>                           ChunkIndexToBoneName;                              // 0x01C8(0x0010)(ZeroConstructor, NativeAccessSpecifierPublic)
	TArray<uint32>                                ChunkIndexToBoneIndex;                             // 0x01D8(0x0010)(ZeroConstructor, Transient, NativeAccessSpecifierPublic)
	uint8                                         Pad_1E8[0x10];                                     // 0x01E8(0x0010)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<struct FBlastCookedChunkData>          CookedChunkData;                                   // 0x01F8(0x0010)(ZeroConstructor, DuplicateTransient, ContainsInstancedReference, Protected, NativeAccessSpecifierProtected)
	TArray<struct FTransform>                     ComponentSpaceInitialBoneTransforms;               // 0x0208(0x0010)(ZeroConstructor, Protected, NativeAccessSpecifierProtected)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"BlastMesh">();
	}
	static class UBlastMesh* GetDefaultObj()
	{
		return GetDefaultObjImpl<UBlastMesh>();
	}
};
static_assert(alignof(UBlastMesh) == 0x000008, "Wrong alignment on UBlastMesh");
static_assert(sizeof(UBlastMesh) == 0x000218, "Wrong size on UBlastMesh");
static_assert(offsetof(UBlastMesh, Mesh) == 0x000140, "Member 'UBlastMesh::Mesh' has a wrong offset!");
static_assert(offsetof(UBlastMesh, NumTexCoord) == 0x000148, "Member 'UBlastMesh::NumTexCoord' has a wrong offset!");
static_assert(offsetof(UBlastMesh, Skeleton) == 0x000150, "Member 'UBlastMesh::Skeleton' has a wrong offset!");
static_assert(offsetof(UBlastMesh, PhysicsAsset) == 0x000158, "Member 'UBlastMesh::PhysicsAsset' has a wrong offset!");
static_assert(offsetof(UBlastMesh, BlastMaterial) == 0x000160, "Member 'UBlastMesh::BlastMaterial' has a wrong offset!");
static_assert(offsetof(UBlastMesh, ImpactDamageProperties) == 0x000170, "Member 'UBlastMesh::ImpactDamageProperties' has a wrong offset!");
static_assert(offsetof(UBlastMesh, StressProperties) == 0x000194, "Member 'UBlastMesh::StressProperties' has a wrong offset!");
static_assert(offsetof(UBlastMesh, DebrisProperties) == 0x0001B8, "Member 'UBlastMesh::DebrisProperties' has a wrong offset!");
static_assert(offsetof(UBlastMesh, ChunkIndexToBoneName) == 0x0001C8, "Member 'UBlastMesh::ChunkIndexToBoneName' has a wrong offset!");
static_assert(offsetof(UBlastMesh, ChunkIndexToBoneIndex) == 0x0001D8, "Member 'UBlastMesh::ChunkIndexToBoneIndex' has a wrong offset!");
static_assert(offsetof(UBlastMesh, CookedChunkData) == 0x0001F8, "Member 'UBlastMesh::CookedChunkData' has a wrong offset!");
static_assert(offsetof(UBlastMesh, ComponentSpaceInitialBoneTransforms) == 0x000208, "Member 'UBlastMesh::ComponentSpaceInitialBoneTransforms' has a wrong offset!");

// Class Blast.BlastMeshExtendedSupport
// 0x0000 (0x0218 - 0x0218)
class UBlastMeshExtendedSupport final : public UBlastMesh
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"BlastMeshExtendedSupport">();
	}
	static class UBlastMeshExtendedSupport* GetDefaultObj()
	{
		return GetDefaultObjImpl<UBlastMeshExtendedSupport>();
	}
};
static_assert(alignof(UBlastMeshExtendedSupport) == 0x000008, "Wrong alignment on UBlastMeshExtendedSupport");
static_assert(sizeof(UBlastMeshExtendedSupport) == 0x000218, "Wrong size on UBlastMeshExtendedSupport");

// Class Blast.BlastGlueWorldTag
// 0x0000 (0x0028 - 0x0028)
class UBlastGlueWorldTag final : public UObject
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"BlastGlueWorldTag">();
	}
	static class UBlastGlueWorldTag* GetDefaultObj()
	{
		return GetDefaultObjImpl<UBlastGlueWorldTag>();
	}
};
static_assert(alignof(UBlastGlueWorldTag) == 0x000008, "Wrong alignment on UBlastGlueWorldTag");
static_assert(sizeof(UBlastGlueWorldTag) == 0x000028, "Wrong size on UBlastGlueWorldTag");

// Class Blast.BlastGlueVolume
// 0x0010 (0x0420 - 0x0410)
class ABlastGlueVolume final : public AVolume
{
public:
	bool                                          bEnabled;                                          // 0x0410(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_411[0x3];                                      // 0x0411(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	struct FVector                                GlueVector;                                        // 0x0414(0x000C)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"BlastGlueVolume">();
	}
	static class ABlastGlueVolume* GetDefaultObj()
	{
		return GetDefaultObjImpl<ABlastGlueVolume>();
	}
};
static_assert(alignof(ABlastGlueVolume) == 0x000008, "Wrong alignment on ABlastGlueVolume");
static_assert(sizeof(ABlastGlueVolume) == 0x000420, "Wrong size on ABlastGlueVolume");
static_assert(offsetof(ABlastGlueVolume, bEnabled) == 0x000410, "Member 'ABlastGlueVolume::bEnabled' has a wrong offset!");
static_assert(offsetof(ABlastGlueVolume, GlueVector) == 0x000414, "Member 'ABlastGlueVolume::GlueVector' has a wrong offset!");

// Class Blast.BlastMeshActor
// 0x0008 (0x03E0 - 0x03D8)
class ABlastMeshActor final : public AActor
{
public:
	class UBlastMeshComponent*                    BlastMeshComponent;                                // 0x03D8(0x0008)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, EditConst, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"BlastMeshActor">();
	}
	static class ABlastMeshActor* GetDefaultObj()
	{
		return GetDefaultObjImpl<ABlastMeshActor>();
	}
};
static_assert(alignof(ABlastMeshActor) == 0x000008, "Wrong alignment on ABlastMeshActor");
static_assert(sizeof(ABlastMeshActor) == 0x0003E0, "Wrong size on ABlastMeshActor");
static_assert(offsetof(ABlastMeshActor, BlastMeshComponent) == 0x0003D8, "Member 'ABlastMeshActor::BlastMeshComponent' has a wrong offset!");

// Class Blast.BlastMeshRecordedComponent
// 0x0138 (0x03D0 - 0x0298)
class UBlastMeshRecordedComponent final : public USceneComponent
{
public:
	class USkeletalMeshComponent*                 M_pTestingComponent;                               // 0x0298(0x0008)(ExportObject, ZeroConstructor, Transient, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TArray<class UBlastMeshComponent*>            M_apRecordingComponents;                           // 0x02A0(0x0010)(ExportObject, ZeroConstructor, Transient, DuplicateTransient, ContainsInstancedReference, NativeAccessSpecifierPublic)
	TArray<class USkeletalMeshComponent*>         M_pPlaybackComponents;                             // 0x02B0(0x0010)(ExportObject, ZeroConstructor, Transient, DuplicateTransient, ContainsInstancedReference, NativeAccessSpecifierPublic)
	bool                                          M_bRecord;                                         // 0x02C0(0x0001)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, NonPIEDuplicateTransient, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2C1[0x3];                                      // 0x02C1(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         M_fMaxRecordTime;                                  // 0x02C4(0x0004)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnTemplate, Transient, IsPlainOldData, NoDestructor, NonPIEDuplicateTransient, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         M_iRecordIndex;                                    // 0x02C8(0x0004)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, NonPIEDuplicateTransient, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FGuid                                  M_RecordingGuid;                                   // 0x02CC(0x0010)(Edit, ZeroConstructor, DisableEditOnTemplate, EditConst, IsPlainOldData, NoDestructor, NonPIEDuplicateTransient, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2DC[0x4];                                      // 0x02DC(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class UBlastMeshRecordedComponent*            M_pSourceComponent;                                // 0x02E0(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          M_bPlayback;                                       // 0x02E8(0x0001)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnTemplate, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2E9[0x7];                                      // 0x02E9(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	TSoftObjectPtr<class UBlastRecordedCache>     M_CachePath;                                       // 0x02F0(0x0028)(Edit, DisableEditOnTemplate, DuplicateTransient, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UBlastRecordedCache*                    M_pCache;                                          // 0x0318(0x0008)(Edit, ZeroConstructor, DisableEditOnTemplate, Transient, DuplicateTransient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TArray<struct FCachedBlastRecordingEvent>     M_aEvents;                                         // 0x0320(0x0010)(Edit, ZeroConstructor, DisableEditOnTemplate, NativeAccessSpecifierPublic)
	struct FVector                                M_vRecordLocation;                                 // 0x0330(0x000C)(Edit, ZeroConstructor, DisableEditOnTemplate, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_33C[0x9];                                      // 0x033C(0x0009)(Fixing Size After Last Property [ Dumper-7 ])
	bool                                          M_bHasMergedData;                                  // 0x0345(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_346[0x8A];                                     // 0x0346(0x008A)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void ApplyMaterialVariation();
	class UBlastMesh* GetBlastMeshFromSoftPath(const struct FSoftObjectPath& _path);
	void MergeMeshesAndAnimations();
	void OnCreatedBlastMeshComponent(class UBlastMeshComponent* _pComponent);
	void OnEffectEvent(ECachedBlastRecordingEvent _eEvent, int32 _iCustomData, int32 _iCustomData2);
	void OnRemovedBlastMeshComponent(class UBlastMeshComponent* _pComponent);
	void RequestPlayback();
	void ResetCache();
	void ResetForPlayback();
	void UpdateBillboardForState();
	void UpdateRecordingAndPlayback(float _fTimeDelta);

	bool HasValidCachedData() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"BlastMeshRecordedComponent">();
	}
	static class UBlastMeshRecordedComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UBlastMeshRecordedComponent>();
	}
};
static_assert(alignof(UBlastMeshRecordedComponent) == 0x000008, "Wrong alignment on UBlastMeshRecordedComponent");
static_assert(sizeof(UBlastMeshRecordedComponent) == 0x0003D0, "Wrong size on UBlastMeshRecordedComponent");
static_assert(offsetof(UBlastMeshRecordedComponent, M_pTestingComponent) == 0x000298, "Member 'UBlastMeshRecordedComponent::M_pTestingComponent' has a wrong offset!");
static_assert(offsetof(UBlastMeshRecordedComponent, M_apRecordingComponents) == 0x0002A0, "Member 'UBlastMeshRecordedComponent::M_apRecordingComponents' has a wrong offset!");
static_assert(offsetof(UBlastMeshRecordedComponent, M_pPlaybackComponents) == 0x0002B0, "Member 'UBlastMeshRecordedComponent::M_pPlaybackComponents' has a wrong offset!");
static_assert(offsetof(UBlastMeshRecordedComponent, M_bRecord) == 0x0002C0, "Member 'UBlastMeshRecordedComponent::M_bRecord' has a wrong offset!");
static_assert(offsetof(UBlastMeshRecordedComponent, M_fMaxRecordTime) == 0x0002C4, "Member 'UBlastMeshRecordedComponent::M_fMaxRecordTime' has a wrong offset!");
static_assert(offsetof(UBlastMeshRecordedComponent, M_iRecordIndex) == 0x0002C8, "Member 'UBlastMeshRecordedComponent::M_iRecordIndex' has a wrong offset!");
static_assert(offsetof(UBlastMeshRecordedComponent, M_RecordingGuid) == 0x0002CC, "Member 'UBlastMeshRecordedComponent::M_RecordingGuid' has a wrong offset!");
static_assert(offsetof(UBlastMeshRecordedComponent, M_pSourceComponent) == 0x0002E0, "Member 'UBlastMeshRecordedComponent::M_pSourceComponent' has a wrong offset!");
static_assert(offsetof(UBlastMeshRecordedComponent, M_bPlayback) == 0x0002E8, "Member 'UBlastMeshRecordedComponent::M_bPlayback' has a wrong offset!");
static_assert(offsetof(UBlastMeshRecordedComponent, M_CachePath) == 0x0002F0, "Member 'UBlastMeshRecordedComponent::M_CachePath' has a wrong offset!");
static_assert(offsetof(UBlastMeshRecordedComponent, M_pCache) == 0x000318, "Member 'UBlastMeshRecordedComponent::M_pCache' has a wrong offset!");
static_assert(offsetof(UBlastMeshRecordedComponent, M_aEvents) == 0x000320, "Member 'UBlastMeshRecordedComponent::M_aEvents' has a wrong offset!");
static_assert(offsetof(UBlastMeshRecordedComponent, M_vRecordLocation) == 0x000330, "Member 'UBlastMeshRecordedComponent::M_vRecordLocation' has a wrong offset!");
static_assert(offsetof(UBlastMeshRecordedComponent, M_bHasMergedData) == 0x000345, "Member 'UBlastMeshRecordedComponent::M_bHasMergedData' has a wrong offset!");

// Class Blast.BlastMeshRecordedSkeletalComponent
// 0x0000 (0x0D20 - 0x0D20)
class UBlastMeshRecordedSkeletalComponent final : public USkeletalMeshComponent
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"BlastMeshRecordedSkeletalComponent">();
	}
	static class UBlastMeshRecordedSkeletalComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UBlastMeshRecordedSkeletalComponent>();
	}
};
static_assert(alignof(UBlastMeshRecordedSkeletalComponent) == 0x000008, "Wrong alignment on UBlastMeshRecordedSkeletalComponent");
static_assert(sizeof(UBlastMeshRecordedSkeletalComponent) == 0x000D20, "Wrong size on UBlastMeshRecordedSkeletalComponent");

// Class Blast.BlastRadialDamageComponent
// 0x0030 (0x02D0 - 0x02A0)
class UBlastRadialDamageComponent final : public UBlastBaseDamageComponent
{
public:
	float                                         Damage;                                            // 0x02A0(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         MinRadius;                                         // 0x02A4(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         MaxRadius;                                         // 0x02A8(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bAddPhysicsImpulse;                                // 0x02AC(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2AD[0x1B];                                     // 0x02AD(0x001B)(Fixing Size After Last Property [ Dumper-7 ])
	class URadialForceComponent*                  ForceComponent;                                    // 0x02C8(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"BlastRadialDamageComponent">();
	}
	static class UBlastRadialDamageComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UBlastRadialDamageComponent>();
	}
};
static_assert(alignof(UBlastRadialDamageComponent) == 0x000008, "Wrong alignment on UBlastRadialDamageComponent");
static_assert(sizeof(UBlastRadialDamageComponent) == 0x0002D0, "Wrong size on UBlastRadialDamageComponent");
static_assert(offsetof(UBlastRadialDamageComponent, Damage) == 0x0002A0, "Member 'UBlastRadialDamageComponent::Damage' has a wrong offset!");
static_assert(offsetof(UBlastRadialDamageComponent, MinRadius) == 0x0002A4, "Member 'UBlastRadialDamageComponent::MinRadius' has a wrong offset!");
static_assert(offsetof(UBlastRadialDamageComponent, MaxRadius) == 0x0002A8, "Member 'UBlastRadialDamageComponent::MaxRadius' has a wrong offset!");
static_assert(offsetof(UBlastRadialDamageComponent, bAddPhysicsImpulse) == 0x0002AC, "Member 'UBlastRadialDamageComponent::bAddPhysicsImpulse' has a wrong offset!");
static_assert(offsetof(UBlastRadialDamageComponent, ForceComponent) == 0x0002C8, "Member 'UBlastRadialDamageComponent::ForceComponent' has a wrong offset!");

// Class Blast.BlastRecordedCache
// 0x0028 (0x0058 - 0x0030)
class UBlastRecordedCache final : public UDataAsset
{
public:
	TArray<struct FCachedBlastRecording>          M_aCache;                                          // 0x0030(0x0010)(Edit, ZeroConstructor, NativeAccessSpecifierPublic)
	float                                         M_fSimulationLength;                               // 0x0040(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_44[0x4];                                       // 0x0044(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class USkeletalMesh*                          M_pMergedMesh;                                     // 0x0048(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UAnimSequence*                          M_pMergedAnimSeq;                                  // 0x0050(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"BlastRecordedCache">();
	}
	static class UBlastRecordedCache* GetDefaultObj()
	{
		return GetDefaultObjImpl<UBlastRecordedCache>();
	}
};
static_assert(alignof(UBlastRecordedCache) == 0x000008, "Wrong alignment on UBlastRecordedCache");
static_assert(sizeof(UBlastRecordedCache) == 0x000058, "Wrong size on UBlastRecordedCache");
static_assert(offsetof(UBlastRecordedCache, M_aCache) == 0x000030, "Member 'UBlastRecordedCache::M_aCache' has a wrong offset!");
static_assert(offsetof(UBlastRecordedCache, M_fSimulationLength) == 0x000040, "Member 'UBlastRecordedCache::M_fSimulationLength' has a wrong offset!");
static_assert(offsetof(UBlastRecordedCache, M_pMergedMesh) == 0x000048, "Member 'UBlastRecordedCache::M_pMergedMesh' has a wrong offset!");
static_assert(offsetof(UBlastRecordedCache, M_pMergedAnimSeq) == 0x000050, "Member 'UBlastRecordedCache::M_pMergedAnimSeq' has a wrong offset!");

}

