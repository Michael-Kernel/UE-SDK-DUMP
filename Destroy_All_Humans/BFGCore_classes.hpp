#pragma once

/*
* SDK generated by Dumper-7
*
* https://github.com/Encryqed/Dumper-7
*/

// Package: BFGCore

#include "Basic.hpp"

#include "MovieScene_structs.hpp"
#include "GameplayTags_structs.hpp"
#include "BFGCore_structs.hpp"
#include "AnimationSharing_classes.hpp"
#include "Engine_structs.hpp"
#include "Engine_classes.hpp"
#include "CoreUObject_structs.hpp"
#include "CoreUObject_classes.hpp"
#include "UMG_structs.hpp"
#include "UMG_classes.hpp"
#include "AIModule_structs.hpp"
#include "AIModule_classes.hpp"
#include "SlateCore_structs.hpp"
#include "Foliage_classes.hpp"
#include "AnimationBudgetAllocator_classes.hpp"
#include "InputCore_structs.hpp"
#include "GenericGraphRuntime_classes.hpp"
#include "NavigationSystem_classes.hpp"
#include "BFGSessionFoundation_classes.hpp"
#include "PhysXVehicles_classes.hpp"
#include "Slate_structs.hpp"


namespace SDK
{

// Class BFGCore.BFGScriptedSequence_Task
// 0x0028 (0x0050 - 0x0028)
class UBFGScriptedSequence_Task : public UObject
{
public:
	class UBFGScriptedSequence*                   M_pParentSequence;                                 // 0x0028(0x0008)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UBFGNetworkPathAgent*                   M_pAgent;                                          // 0x0030(0x0008)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_38[0x8];                                       // 0x0038(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	class UBFGNetworkPathAgent_AIStateBase*       M_pRunningAIState;                                 // 0x0040(0x0008)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_48[0x8];                                       // 0x0048(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void OnActorDestroyed(class AActor* _pActor);
	void OnActorIsDeadStatChanged(class AActor* _pActor, class UBFGActorStat_Bool* _pDeathStat);
	void OnAITaskAborted(class UBFGNetworkPathAgent_AIStateBase* _pTask);
	void OnAITaskFinished(class UBFGNetworkPathAgent_AIStateBase* _pTask);
	void OnAITaskStarted(class UBFGNetworkPathAgent_AIStateBase* _pTask);
	void OnCrowdLifeSystemJoined();
	void OnCrowdLifeSystemLeft();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"BFGScriptedSequence_Task">();
	}
	static class UBFGScriptedSequence_Task* GetDefaultObj()
	{
		return GetDefaultObjImpl<UBFGScriptedSequence_Task>();
	}
};
static_assert(alignof(UBFGScriptedSequence_Task) == 0x000008, "Wrong alignment on UBFGScriptedSequence_Task");
static_assert(sizeof(UBFGScriptedSequence_Task) == 0x000050, "Wrong size on UBFGScriptedSequence_Task");
static_assert(offsetof(UBFGScriptedSequence_Task, M_pParentSequence) == 0x000028, "Member 'UBFGScriptedSequence_Task::M_pParentSequence' has a wrong offset!");
static_assert(offsetof(UBFGScriptedSequence_Task, M_pAgent) == 0x000030, "Member 'UBFGScriptedSequence_Task::M_pAgent' has a wrong offset!");
static_assert(offsetof(UBFGScriptedSequence_Task, M_pRunningAIState) == 0x000040, "Member 'UBFGScriptedSequence_Task::M_pRunningAIState' has a wrong offset!");

// Class BFGCore.BFGEventTrigger
// 0x0018 (0x0040 - 0x0028)
class UBFGEventTrigger : public UObject
{
public:
	uint8                                         Pad_28[0x8];                                       // 0x0028(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<class UBFGEvent*>                      M_aEvents;                                         // 0x0030(0x0010)(ZeroConstructor, Transient, NativeAccessSpecifierPrivate)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"BFGEventTrigger">();
	}
	static class UBFGEventTrigger* GetDefaultObj()
	{
		return GetDefaultObjImpl<UBFGEventTrigger>();
	}
};
static_assert(alignof(UBFGEventTrigger) == 0x000008, "Wrong alignment on UBFGEventTrigger");
static_assert(sizeof(UBFGEventTrigger) == 0x000040, "Wrong size on UBFGEventTrigger");
static_assert(offsetof(UBFGEventTrigger, M_aEvents) == 0x000030, "Member 'UBFGEventTrigger::M_aEvents' has a wrong offset!");

// Class BFGCore.BFGEventTrigger_DestroyedStaticObject
// 0x00E0 (0x0120 - 0x0040)
class UBFGEventTrigger_DestroyedStaticObject final : public UBFGEventTrigger
{
public:
	struct FBFGActorBinding                       M_actorBinding;                                    // 0x0040(0x0090)(Transient, Protected, NativeAccessSpecifierProtected)
	struct FGameplayTagQuery                      M_queryDamageType;                                 // 0x00D0(0x0048)(Transient, Protected, NativeAccessSpecifierProtected)
	uint8                                         Pad_118[0x8];                                      // 0x0118(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void OnStaticObjectDestroyed(class ABFGObject_StaticWithPhysics* _pDestroyedObject);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"BFGEventTrigger_DestroyedStaticObject">();
	}
	static class UBFGEventTrigger_DestroyedStaticObject* GetDefaultObj()
	{
		return GetDefaultObjImpl<UBFGEventTrigger_DestroyedStaticObject>();
	}
};
static_assert(alignof(UBFGEventTrigger_DestroyedStaticObject) == 0x000008, "Wrong alignment on UBFGEventTrigger_DestroyedStaticObject");
static_assert(sizeof(UBFGEventTrigger_DestroyedStaticObject) == 0x000120, "Wrong size on UBFGEventTrigger_DestroyedStaticObject");
static_assert(offsetof(UBFGEventTrigger_DestroyedStaticObject, M_actorBinding) == 0x000040, "Member 'UBFGEventTrigger_DestroyedStaticObject::M_actorBinding' has a wrong offset!");
static_assert(offsetof(UBFGEventTrigger_DestroyedStaticObject, M_queryDamageType) == 0x0000D0, "Member 'UBFGEventTrigger_DestroyedStaticObject::M_queryDamageType' has a wrong offset!");

// Class BFGCore.BFGWidgetSceneObjectHighlighter
// 0x0060 (0x02A0 - 0x0240)
class UBFGWidgetSceneObjectHighlighter : public UUserWidget
{
public:
	class UBFGDataAsset_HighlightableSceneObject* M_pData;                                           // 0x0240(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	struct FLinearColor                           M_oColorNear;                                      // 0x0248(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	struct FLinearColor                           M_oColorFar;                                       // 0x0258(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         M_fDistanceNear;                                   // 0x0268(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         M_fDistanceFar;                                    // 0x026C(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          M_bShouldScale;                                    // 0x0270(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_271[0x3];                                      // 0x0271(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         M_fScaleDistanceFar;                               // 0x0274(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         M_fScaleFactorAtDistanceFar;                       // 0x0278(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         M_fScaleDistanceNear;                              // 0x027C(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         M_fScaleFactorAtDistanceNear;                      // 0x0280(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	EBFGSceneObjectHighlighterType                M_eHighlighterType;                                // 0x0284(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_285[0x3];                                      // 0x0285(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	class UImage*                                 M_pImageIcon;                                      // 0x0288(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UImage*                                 M_pImageOffscreenPointer;                          // 0x0290(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UWidget*                                M_pContainerOffscreenPointer;                      // 0x0298(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)

public:
	class UWidget* GetContainerOffscreenPointer();
	class UImage* GetImageIcon();
	class UImage* GetImageOffscreenPointer();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"BFGWidgetSceneObjectHighlighter">();
	}
	static class UBFGWidgetSceneObjectHighlighter* GetDefaultObj()
	{
		return GetDefaultObjImpl<UBFGWidgetSceneObjectHighlighter>();
	}
};
static_assert(alignof(UBFGWidgetSceneObjectHighlighter) == 0x000008, "Wrong alignment on UBFGWidgetSceneObjectHighlighter");
static_assert(sizeof(UBFGWidgetSceneObjectHighlighter) == 0x0002A0, "Wrong size on UBFGWidgetSceneObjectHighlighter");
static_assert(offsetof(UBFGWidgetSceneObjectHighlighter, M_pData) == 0x000240, "Member 'UBFGWidgetSceneObjectHighlighter::M_pData' has a wrong offset!");
static_assert(offsetof(UBFGWidgetSceneObjectHighlighter, M_oColorNear) == 0x000248, "Member 'UBFGWidgetSceneObjectHighlighter::M_oColorNear' has a wrong offset!");
static_assert(offsetof(UBFGWidgetSceneObjectHighlighter, M_oColorFar) == 0x000258, "Member 'UBFGWidgetSceneObjectHighlighter::M_oColorFar' has a wrong offset!");
static_assert(offsetof(UBFGWidgetSceneObjectHighlighter, M_fDistanceNear) == 0x000268, "Member 'UBFGWidgetSceneObjectHighlighter::M_fDistanceNear' has a wrong offset!");
static_assert(offsetof(UBFGWidgetSceneObjectHighlighter, M_fDistanceFar) == 0x00026C, "Member 'UBFGWidgetSceneObjectHighlighter::M_fDistanceFar' has a wrong offset!");
static_assert(offsetof(UBFGWidgetSceneObjectHighlighter, M_bShouldScale) == 0x000270, "Member 'UBFGWidgetSceneObjectHighlighter::M_bShouldScale' has a wrong offset!");
static_assert(offsetof(UBFGWidgetSceneObjectHighlighter, M_fScaleDistanceFar) == 0x000274, "Member 'UBFGWidgetSceneObjectHighlighter::M_fScaleDistanceFar' has a wrong offset!");
static_assert(offsetof(UBFGWidgetSceneObjectHighlighter, M_fScaleFactorAtDistanceFar) == 0x000278, "Member 'UBFGWidgetSceneObjectHighlighter::M_fScaleFactorAtDistanceFar' has a wrong offset!");
static_assert(offsetof(UBFGWidgetSceneObjectHighlighter, M_fScaleDistanceNear) == 0x00027C, "Member 'UBFGWidgetSceneObjectHighlighter::M_fScaleDistanceNear' has a wrong offset!");
static_assert(offsetof(UBFGWidgetSceneObjectHighlighter, M_fScaleFactorAtDistanceNear) == 0x000280, "Member 'UBFGWidgetSceneObjectHighlighter::M_fScaleFactorAtDistanceNear' has a wrong offset!");
static_assert(offsetof(UBFGWidgetSceneObjectHighlighter, M_eHighlighterType) == 0x000284, "Member 'UBFGWidgetSceneObjectHighlighter::M_eHighlighterType' has a wrong offset!");
static_assert(offsetof(UBFGWidgetSceneObjectHighlighter, M_pImageIcon) == 0x000288, "Member 'UBFGWidgetSceneObjectHighlighter::M_pImageIcon' has a wrong offset!");
static_assert(offsetof(UBFGWidgetSceneObjectHighlighter, M_pImageOffscreenPointer) == 0x000290, "Member 'UBFGWidgetSceneObjectHighlighter::M_pImageOffscreenPointer' has a wrong offset!");
static_assert(offsetof(UBFGWidgetSceneObjectHighlighter, M_pContainerOffscreenPointer) == 0x000298, "Member 'UBFGWidgetSceneObjectHighlighter::M_pContainerOffscreenPointer' has a wrong offset!");

// Class BFGCore.BFGWidgetSceneObjectHighlighter_QuestMarker
// 0x0000 (0x02A0 - 0x02A0)
class UBFGWidgetSceneObjectHighlighter_QuestMarker : public UBFGWidgetSceneObjectHighlighter
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"BFGWidgetSceneObjectHighlighter_QuestMarker">();
	}
	static class UBFGWidgetSceneObjectHighlighter_QuestMarker* GetDefaultObj()
	{
		return GetDefaultObjImpl<UBFGWidgetSceneObjectHighlighter_QuestMarker>();
	}
};
static_assert(alignof(UBFGWidgetSceneObjectHighlighter_QuestMarker) == 0x000008, "Wrong alignment on UBFGWidgetSceneObjectHighlighter_QuestMarker");
static_assert(sizeof(UBFGWidgetSceneObjectHighlighter_QuestMarker) == 0x0002A0, "Wrong size on UBFGWidgetSceneObjectHighlighter_QuestMarker");

// Class BFGCore.BFG_AISenseAgression
// 0x0060 (0x00E0 - 0x0080)
class UBFG_AISenseAgression final : public UAISense
{
public:
	uint8                                         Pad_80[0x50];                                      // 0x0080(0x0050)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<struct FAIAgressiveEvent>              AggressiveEvents;                                  // 0x00D0(0x0010)(ZeroConstructor, NativeAccessSpecifierPublic)

public:
	static void ReportAgressiveEvent(class UObject* _pWorldContextObject, const struct FVector& _pAggressiveEventLocation, class AActor* _pInstigator, class AActor* _pVictim, class FName Tag, float _fMaxRange);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"BFG_AISenseAgression">();
	}
	static class UBFG_AISenseAgression* GetDefaultObj()
	{
		return GetDefaultObjImpl<UBFG_AISenseAgression>();
	}
};
static_assert(alignof(UBFG_AISenseAgression) == 0x000008, "Wrong alignment on UBFG_AISenseAgression");
static_assert(sizeof(UBFG_AISenseAgression) == 0x0000E0, "Wrong size on UBFG_AISenseAgression");
static_assert(offsetof(UBFG_AISenseAgression, AggressiveEvents) == 0x0000D0, "Member 'UBFG_AISenseAgression::AggressiveEvents' has a wrong offset!");

// Class BFGCore.BFGEventTest
// 0x0000 (0x0028 - 0x0028)
class UBFGEventTest : public UObject
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"BFGEventTest">();
	}
	static class UBFGEventTest* GetDefaultObj()
	{
		return GetDefaultObjImpl<UBFGEventTest>();
	}
};
static_assert(alignof(UBFGEventTest) == 0x000008, "Wrong alignment on UBFGEventTest");
static_assert(sizeof(UBFGEventTest) == 0x000028, "Wrong size on UBFGEventTest");

// Class BFGCore.BFGEventTest_StoppedFading
// 0x0008 (0x0030 - 0x0028)
class UBFGEventTest_StoppedFading final : public UBFGEventTest
{
public:
	uint8                                         Pad_28[0x8];                                       // 0x0028(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"BFGEventTest_StoppedFading">();
	}
	static class UBFGEventTest_StoppedFading* GetDefaultObj()
	{
		return GetDefaultObjImpl<UBFGEventTest_StoppedFading>();
	}
};
static_assert(alignof(UBFGEventTest_StoppedFading) == 0x000008, "Wrong alignment on UBFGEventTest_StoppedFading");
static_assert(sizeof(UBFGEventTest_StoppedFading) == 0x000030, "Wrong size on UBFGEventTest_StoppedFading");

// Class BFGCore.BFGActorComponent_GameplayEffectTags
// 0x01D0 (0x02F8 - 0x0128)
class UBFGActorComponent_GameplayEffectTags final : public UActorComponent
{
public:
	UMulticastDelegateProperty_                   M_oOnTagActive;                                    // 0x0128(0x0018)(ZeroConstructor, InstancedReference, BlueprintAssignable, BlueprintCallable, NativeAccessSpecifierPublic)
	UMulticastDelegateProperty_                   M_oOnTagActiveWithTarget;                          // 0x0140(0x0018)(ZeroConstructor, InstancedReference, BlueprintAssignable, BlueprintCallable, NativeAccessSpecifierPublic)
	UMulticastDelegateProperty_                   M_oOnTagInactive;                                  // 0x0158(0x0018)(ZeroConstructor, InstancedReference, BlueprintAssignable, BlueprintCallable, NativeAccessSpecifierPublic)
	UMulticastDelegateProperty_                   M_oOnTagInactiveWithTarget;                        // 0x0170(0x0018)(ZeroConstructor, InstancedReference, BlueprintAssignable, BlueprintCallable, NativeAccessSpecifierPublic)
	struct FGameplayTagContainer                  M_oDefaultTags;                                    // 0x0188(0x0020)(Edit, Protected, NativeAccessSpecifierProtected)
	TArray<struct FGameplayEffectTagsTriggerData> M_aTagEffectTriggers;                              // 0x01A8(0x0010)(Edit, ZeroConstructor, Protected, NativeAccessSpecifierProtected)
	uint8                                         Pad_1B8[0x140];                                    // 0x01B8(0x0140)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void ClearTags();
	void DecrementGameplayEffectTag(const struct FGameplayTag& _rTag);
	void DecrementGameplayEffectTags(const struct FGameplayTagContainer& _rTags);
	int32 GetTagCount(const struct FGameplayTag& _oTag);
	void IncrementGameplayEffectTag(const struct FGameplayTag& _rTag);
	void IncrementGameplayEffectTags(const struct FGameplayTagContainer& _rTags);
	void IncrementGameplayEffectTagsTimer(const struct FGameplayEffectTagsTimer& _rTagsTimer);
	bool IsAffectedByAllTags(const struct FGameplayTagContainer& _rTags);
	bool IsAffectedByAnyTags(const struct FGameplayTagContainer& _rTags);
	bool IsAffectedByTag(const struct FGameplayTag& _rTag);
	void RemoveGameplayEffectTag(const struct FGameplayTag& _rTag);
	void RemoveGameplayEffectTags(const struct FGameplayTagContainer& _rTags);

	struct FGameplayEffectTagsTimer AffectedTimeLeftForQuery(const struct FGameplayTagQuery& _rQuery) const;
	bool IsAffectedByQuery(const struct FGameplayTagQuery& _rQuery) const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"BFGActorComponent_GameplayEffectTags">();
	}
	static class UBFGActorComponent_GameplayEffectTags* GetDefaultObj()
	{
		return GetDefaultObjImpl<UBFGActorComponent_GameplayEffectTags>();
	}
};
static_assert(alignof(UBFGActorComponent_GameplayEffectTags) == 0x000008, "Wrong alignment on UBFGActorComponent_GameplayEffectTags");
static_assert(sizeof(UBFGActorComponent_GameplayEffectTags) == 0x0002F8, "Wrong size on UBFGActorComponent_GameplayEffectTags");
static_assert(offsetof(UBFGActorComponent_GameplayEffectTags, M_oOnTagActive) == 0x000128, "Member 'UBFGActorComponent_GameplayEffectTags::M_oOnTagActive' has a wrong offset!");
static_assert(offsetof(UBFGActorComponent_GameplayEffectTags, M_oOnTagActiveWithTarget) == 0x000140, "Member 'UBFGActorComponent_GameplayEffectTags::M_oOnTagActiveWithTarget' has a wrong offset!");
static_assert(offsetof(UBFGActorComponent_GameplayEffectTags, M_oOnTagInactive) == 0x000158, "Member 'UBFGActorComponent_GameplayEffectTags::M_oOnTagInactive' has a wrong offset!");
static_assert(offsetof(UBFGActorComponent_GameplayEffectTags, M_oOnTagInactiveWithTarget) == 0x000170, "Member 'UBFGActorComponent_GameplayEffectTags::M_oOnTagInactiveWithTarget' has a wrong offset!");
static_assert(offsetof(UBFGActorComponent_GameplayEffectTags, M_oDefaultTags) == 0x000188, "Member 'UBFGActorComponent_GameplayEffectTags::M_oDefaultTags' has a wrong offset!");
static_assert(offsetof(UBFGActorComponent_GameplayEffectTags, M_aTagEffectTriggers) == 0x0001A8, "Member 'UBFGActorComponent_GameplayEffectTags::M_aTagEffectTriggers' has a wrong offset!");

// Class BFGCore.BFGInputUserWidget
// 0x0038 (0x0278 - 0x0240)
class UBFGInputUserWidget : public UUserWidget
{
public:
	TSoftObjectPtr<class UBFGInputScheme>         M_pOverrideInputScheme;                            // 0x0240(0x0028)(Edit, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          M_bFlushPlayerInputOnConstruct;                    // 0x0268(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          M_bFlushPlayerInputOnDestroy;                      // 0x0269(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          M_bIsStandaloneWidget;                             // 0x026A(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_26B[0x5];                                      // 0x026B(0x0005)(Fixing Size After Last Property [ Dumper-7 ])
	class UBFGInputScheme*                        M_pRuntimeInputScheme;                             // 0x0270(0x0008)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)

public:
	void AdvancePressed();
	void AdvanceReleased();
	void AnyKeyPressed();
	void BackPressed();
	void BackReleased();
	void ChangeProfilePressed();
	void ChangeProfileReleased();
	void ModeBackPressed();
	void ModeBackReleased();
	void ModeForwardPressed();
	void ModeForwardReleased();
	void OpenDebugMenuPressed();
	void OpenDebugMenuReleased();
	void Option1Pressed();
	void Option1Released();
	void Option2Pressed();
	void Option2Released();
	void UpdateAxis1(float _fValue);
	void UpdateAxis2(float _fValue);
	void UpdateAxis3(float _fValue);
	void UpdateAxis4(float _fValue);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"BFGInputUserWidget">();
	}
	static class UBFGInputUserWidget* GetDefaultObj()
	{
		return GetDefaultObjImpl<UBFGInputUserWidget>();
	}
};
static_assert(alignof(UBFGInputUserWidget) == 0x000008, "Wrong alignment on UBFGInputUserWidget");
static_assert(sizeof(UBFGInputUserWidget) == 0x000278, "Wrong size on UBFGInputUserWidget");
static_assert(offsetof(UBFGInputUserWidget, M_pOverrideInputScheme) == 0x000240, "Member 'UBFGInputUserWidget::M_pOverrideInputScheme' has a wrong offset!");
static_assert(offsetof(UBFGInputUserWidget, M_bFlushPlayerInputOnConstruct) == 0x000268, "Member 'UBFGInputUserWidget::M_bFlushPlayerInputOnConstruct' has a wrong offset!");
static_assert(offsetof(UBFGInputUserWidget, M_bFlushPlayerInputOnDestroy) == 0x000269, "Member 'UBFGInputUserWidget::M_bFlushPlayerInputOnDestroy' has a wrong offset!");
static_assert(offsetof(UBFGInputUserWidget, M_bIsStandaloneWidget) == 0x00026A, "Member 'UBFGInputUserWidget::M_bIsStandaloneWidget' has a wrong offset!");
static_assert(offsetof(UBFGInputUserWidget, M_pRuntimeInputScheme) == 0x000270, "Member 'UBFGInputUserWidget::M_pRuntimeInputScheme' has a wrong offset!");

// Class BFGCore.BFGWidget_MenuBase
// 0x0058 (0x02D0 - 0x0278)
class UBFGWidget_MenuBase : public UBFGInputUserWidget
{
public:
	UMulticastDelegateProperty_                   M_OnInitEvent;                                     // 0x0278(0x0018)(Edit, ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	UMulticastDelegateProperty_                   M_OnExitEvent;                                     // 0x0290(0x0018)(Edit, ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	UMulticastDelegateProperty_                   M_OnFinalizedEvent;                                // 0x02A8(0x0018)(Edit, ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	float                                         M_fFadeDuration;                                   // 0x02C0(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          M_bFadedWhileChildShown;                           // 0x02C4(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          M_bIsDirty;                                        // 0x02C5(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2C6[0xA];                                      // 0x02C6(0x000A)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void Action__DelegateSignature(class UBFGWidget_MenuBase* _pMenu);
	void FadeIn();
	void FadeOut();
	void Invalidate();
	void NativeBeforeDiscard();
	void NativeOnExit();
	void NativeOnInit();
	void OnInputDeviceChanged(bool _bIsGamepad);
	void OnRefresh();

	float ComputeFadingSpeed() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"BFGWidget_MenuBase">();
	}
	static class UBFGWidget_MenuBase* GetDefaultObj()
	{
		return GetDefaultObjImpl<UBFGWidget_MenuBase>();
	}
};
static_assert(alignof(UBFGWidget_MenuBase) == 0x000008, "Wrong alignment on UBFGWidget_MenuBase");
static_assert(sizeof(UBFGWidget_MenuBase) == 0x0002D0, "Wrong size on UBFGWidget_MenuBase");
static_assert(offsetof(UBFGWidget_MenuBase, M_OnInitEvent) == 0x000278, "Member 'UBFGWidget_MenuBase::M_OnInitEvent' has a wrong offset!");
static_assert(offsetof(UBFGWidget_MenuBase, M_OnExitEvent) == 0x000290, "Member 'UBFGWidget_MenuBase::M_OnExitEvent' has a wrong offset!");
static_assert(offsetof(UBFGWidget_MenuBase, M_OnFinalizedEvent) == 0x0002A8, "Member 'UBFGWidget_MenuBase::M_OnFinalizedEvent' has a wrong offset!");
static_assert(offsetof(UBFGWidget_MenuBase, M_fFadeDuration) == 0x0002C0, "Member 'UBFGWidget_MenuBase::M_fFadeDuration' has a wrong offset!");
static_assert(offsetof(UBFGWidget_MenuBase, M_bFadedWhileChildShown) == 0x0002C4, "Member 'UBFGWidget_MenuBase::M_bFadedWhileChildShown' has a wrong offset!");
static_assert(offsetof(UBFGWidget_MenuBase, M_bIsDirty) == 0x0002C5, "Member 'UBFGWidget_MenuBase::M_bIsDirty' has a wrong offset!");

// Class BFGCore.BFGWidget_GenericDialog
// 0x0158 (0x0428 - 0x02D0)
class UBFGWidget_GenericDialog : public UBFGWidget_MenuBase
{
public:
	UMulticastDelegateProperty_                   M_OnOptionRegistered;                              // 0x02D0(0x0018)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	UMulticastDelegateProperty_                   M_OnAccepted;                                      // 0x02E8(0x0018)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	UMulticastDelegateProperty_                   M_OnCancelled;                                     // 0x0300(0x0018)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	UMulticastDelegateProperty_                   M_OnOptionSelected;                                // 0x0318(0x0018)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	UMulticastDelegateProperty_                   M_OnOptionUnselected;                              // 0x0330(0x0018)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	UMulticastDelegateProperty_                   M_OnOptionSelectionChanged;                        // 0x0348(0x0018)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	uint8                                         Pad_360[0x18];                                     // 0x0360(0x0018)(Fixing Size After Last Property [ Dumper-7 ])
	int32                                         M_iSelectedOption;                                 // 0x0378(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          M_bIsRing;                                         // 0x037C(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          M_bUseHorizontalAxis;                              // 0x037D(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          M_bUseVerticalAxis;                                // 0x037E(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          M_bRepeatAxis;                                     // 0x037F(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         M_fRepeatDelay;                                    // 0x0380(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         M_fRepeatIncrement;                                // 0x0384(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         M_fRepeatMaxSpeed;                                 // 0x0388(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          M_bKeepOptionsHighlighted;                         // 0x038C(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          M_bAcceptFirstOptionOnShow;                        // 0x038D(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_38E[0x2];                                      // 0x038E(0x0002)(Fixing Size After Last Property [ Dumper-7 ])
	TMap<class FName, struct FBFGNotifications>   M_aMapNotificationTags;                            // 0x0390(0x0050)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Protected, NativeAccessSpecifierProtected)
	TArray<struct FBFGDialogNotificationINode>    M_aoMothershipINodes;                              // 0x03E0(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Protected, NativeAccessSpecifierProtected)
	TArray<class UBFGWidget_DialogOption*>        M_apOptions;                                       // 0x03F0(0x0010)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, ContainsInstancedReference, Protected, NativeAccessSpecifierProtected)
	uint8                                         Pad_400[0x28];                                     // 0x0400(0x0028)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void Action__DelegateSignature();
	void ActionIndex__DelegateSignature(int32 _iIndex);
	void ActionName__DelegateSignature(class FName _oName);
	void ArrangeOptions();
	void Cancel();
	void ClearOptions();
	void DisableOption(class UBFGWidget_DialogOption* _pOption, bool _bDisabled);
	class UBFGWidget_DialogOption* GetAcceptButton();
	class UBFGWidget_DialogOption* GetBackButton();
	class UBFGWidget_DialogOption* GetOption1Button();
	void OnOptionHover(class UBFGWidget_DialogOption* _pOption);
	void OnOptionPressed(class UBFGWidget_DialogOption* _pOption);
	void OnOptionReleased(class UBFGWidget_DialogOption* _pOption);
	void OnOptionUnhover(class UBFGWidget_DialogOption* _pOption);
	void OnSFX_Cancel();
	void OnSFX_Option1();
	void OnSFX_Option2();
	void OnSFX_OptionAccepted();
	void OnSFX_OptionGamepadKBAccept();
	void OnSFX_OptionGamepadKBSelect();
	void OnSFX_OptionMouseHover();
	void OnSFX_OptionMousePressed();
	void OnSFX_OptionMouseReleased();
	void OnSFX_OptionMouseUnhover();
	void OnSFX_OptionSelected();
	void RegisterOption(class UBFGWidget_DialogOption* _pOption, class FName _targetHandlerName);
	void RemoveOption(int32 _iIndexOption);
	void SelectOption(class UBFGWidget_DialogOption* _pOption);

	int32 GetNumOptions() const;
	class UBFGWidget_DialogOption* GetOptionAtIndex(int32 _iIndex) const;
	class UBFGWidget_DialogOption* GetOptionByHandlerName(class FName _oHandlerName) const;
	class UBFGWidget_DialogOption* GetSelectedOption() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"BFGWidget_GenericDialog">();
	}
	static class UBFGWidget_GenericDialog* GetDefaultObj()
	{
		return GetDefaultObjImpl<UBFGWidget_GenericDialog>();
	}
};
static_assert(alignof(UBFGWidget_GenericDialog) == 0x000008, "Wrong alignment on UBFGWidget_GenericDialog");
static_assert(sizeof(UBFGWidget_GenericDialog) == 0x000428, "Wrong size on UBFGWidget_GenericDialog");
static_assert(offsetof(UBFGWidget_GenericDialog, M_OnOptionRegistered) == 0x0002D0, "Member 'UBFGWidget_GenericDialog::M_OnOptionRegistered' has a wrong offset!");
static_assert(offsetof(UBFGWidget_GenericDialog, M_OnAccepted) == 0x0002E8, "Member 'UBFGWidget_GenericDialog::M_OnAccepted' has a wrong offset!");
static_assert(offsetof(UBFGWidget_GenericDialog, M_OnCancelled) == 0x000300, "Member 'UBFGWidget_GenericDialog::M_OnCancelled' has a wrong offset!");
static_assert(offsetof(UBFGWidget_GenericDialog, M_OnOptionSelected) == 0x000318, "Member 'UBFGWidget_GenericDialog::M_OnOptionSelected' has a wrong offset!");
static_assert(offsetof(UBFGWidget_GenericDialog, M_OnOptionUnselected) == 0x000330, "Member 'UBFGWidget_GenericDialog::M_OnOptionUnselected' has a wrong offset!");
static_assert(offsetof(UBFGWidget_GenericDialog, M_OnOptionSelectionChanged) == 0x000348, "Member 'UBFGWidget_GenericDialog::M_OnOptionSelectionChanged' has a wrong offset!");
static_assert(offsetof(UBFGWidget_GenericDialog, M_iSelectedOption) == 0x000378, "Member 'UBFGWidget_GenericDialog::M_iSelectedOption' has a wrong offset!");
static_assert(offsetof(UBFGWidget_GenericDialog, M_bIsRing) == 0x00037C, "Member 'UBFGWidget_GenericDialog::M_bIsRing' has a wrong offset!");
static_assert(offsetof(UBFGWidget_GenericDialog, M_bUseHorizontalAxis) == 0x00037D, "Member 'UBFGWidget_GenericDialog::M_bUseHorizontalAxis' has a wrong offset!");
static_assert(offsetof(UBFGWidget_GenericDialog, M_bUseVerticalAxis) == 0x00037E, "Member 'UBFGWidget_GenericDialog::M_bUseVerticalAxis' has a wrong offset!");
static_assert(offsetof(UBFGWidget_GenericDialog, M_bRepeatAxis) == 0x00037F, "Member 'UBFGWidget_GenericDialog::M_bRepeatAxis' has a wrong offset!");
static_assert(offsetof(UBFGWidget_GenericDialog, M_fRepeatDelay) == 0x000380, "Member 'UBFGWidget_GenericDialog::M_fRepeatDelay' has a wrong offset!");
static_assert(offsetof(UBFGWidget_GenericDialog, M_fRepeatIncrement) == 0x000384, "Member 'UBFGWidget_GenericDialog::M_fRepeatIncrement' has a wrong offset!");
static_assert(offsetof(UBFGWidget_GenericDialog, M_fRepeatMaxSpeed) == 0x000388, "Member 'UBFGWidget_GenericDialog::M_fRepeatMaxSpeed' has a wrong offset!");
static_assert(offsetof(UBFGWidget_GenericDialog, M_bKeepOptionsHighlighted) == 0x00038C, "Member 'UBFGWidget_GenericDialog::M_bKeepOptionsHighlighted' has a wrong offset!");
static_assert(offsetof(UBFGWidget_GenericDialog, M_bAcceptFirstOptionOnShow) == 0x00038D, "Member 'UBFGWidget_GenericDialog::M_bAcceptFirstOptionOnShow' has a wrong offset!");
static_assert(offsetof(UBFGWidget_GenericDialog, M_aMapNotificationTags) == 0x000390, "Member 'UBFGWidget_GenericDialog::M_aMapNotificationTags' has a wrong offset!");
static_assert(offsetof(UBFGWidget_GenericDialog, M_aoMothershipINodes) == 0x0003E0, "Member 'UBFGWidget_GenericDialog::M_aoMothershipINodes' has a wrong offset!");
static_assert(offsetof(UBFGWidget_GenericDialog, M_apOptions) == 0x0003F0, "Member 'UBFGWidget_GenericDialog::M_apOptions' has a wrong offset!");

// Class BFGCore.BFGWidget_TutorialHandbook
// 0x0120 (0x0548 - 0x0428)
class UBFGWidget_TutorialHandbook final : public UBFGWidget_GenericDialog
{
public:
	UMulticastDelegateProperty_                   M_OnChapterSelected;                               // 0x0428(0x0018)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	TMap<class UBFGDataAsset_TutorialChapter*, int32> M_aLookupChapters;                                 // 0x0440(0x0050)(ZeroConstructor, Protected, NativeAccessSpecifierProtected)
	TMap<class UBFGDataAsset_TutorialPage*, int32> M_aLookupEntries;                                  // 0x0490(0x0050)(ZeroConstructor, Protected, NativeAccessSpecifierProtected)
	TMap<class FName, class UBFGWidget_DialogOption*> M_aLookupHandlers;                                 // 0x04E0(0x0050)(ExportObject, ZeroConstructor, ContainsInstancedReference, Protected, NativeAccessSpecifierProtected)
	TArray<class UBFGWidget_TutorialHandbookChapter*> M_apChapters;                                      // 0x0530(0x0010)(ExportObject, ZeroConstructor, ContainsInstancedReference, Protected, NativeAccessSpecifierProtected)
	uint8                                         Pad_540[0x8];                                      // 0x0540(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	class UBFGWidget_TutorialHandbookChapter* EnsureChapter(class UBFGDataAsset_TutorialChapter* _pDataAssetChapter);
	void SetHandbookEntry(class FName _targetHandlerName, class UBFGWidget_DialogOption* POptions, class UBFGDataAsset_TutorialPage* _pDataAssetPage, class UBFGDataAsset_TutorialChapter* _pDataAssetChapter);

	class UBFGWidgetPoolManager* GetPoolManager() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"BFGWidget_TutorialHandbook">();
	}
	static class UBFGWidget_TutorialHandbook* GetDefaultObj()
	{
		return GetDefaultObjImpl<UBFGWidget_TutorialHandbook>();
	}
};
static_assert(alignof(UBFGWidget_TutorialHandbook) == 0x000008, "Wrong alignment on UBFGWidget_TutorialHandbook");
static_assert(sizeof(UBFGWidget_TutorialHandbook) == 0x000548, "Wrong size on UBFGWidget_TutorialHandbook");
static_assert(offsetof(UBFGWidget_TutorialHandbook, M_OnChapterSelected) == 0x000428, "Member 'UBFGWidget_TutorialHandbook::M_OnChapterSelected' has a wrong offset!");
static_assert(offsetof(UBFGWidget_TutorialHandbook, M_aLookupChapters) == 0x000440, "Member 'UBFGWidget_TutorialHandbook::M_aLookupChapters' has a wrong offset!");
static_assert(offsetof(UBFGWidget_TutorialHandbook, M_aLookupEntries) == 0x000490, "Member 'UBFGWidget_TutorialHandbook::M_aLookupEntries' has a wrong offset!");
static_assert(offsetof(UBFGWidget_TutorialHandbook, M_aLookupHandlers) == 0x0004E0, "Member 'UBFGWidget_TutorialHandbook::M_aLookupHandlers' has a wrong offset!");
static_assert(offsetof(UBFGWidget_TutorialHandbook, M_apChapters) == 0x000530, "Member 'UBFGWidget_TutorialHandbook::M_apChapters' has a wrong offset!");

// Class BFGCore.BFGNPCCharacter
// 0x01C0 (0x09D0 - 0x0810)
class ABFGNPCCharacter : public ACharacter
{
public:
	uint8                                         Pad_808[0x38];                                     // 0x0808(0x0038)(Fixing Size After Last Property [ Dumper-7 ])
	struct FGameplayTagContainer                  M_gameplayTags;                                    // 0x0840(0x0020)(Edit, BlueprintVisible, BlueprintReadOnly, NativeAccessSpecifierPublic)
	class UBFGActorComponent_GameplayEffectTags*  M_pGameplayEffectTagsComponent;                    // 0x0860(0x0008)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, EditConst, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UBFGActorComponent_GameplayEffectResponses* M_pGameplayEffectResponse;                         // 0x0868(0x0008)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, EditConst, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UBFGActorComponent_Effect*              M_pEffectComponent;                                // 0x0870(0x0008)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, EditConst, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UBFGActorComponent_CharacterStats*      M_pStatsComponent;                                 // 0x0878(0x0008)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, EditConst, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UBFGActorComponent_Animation*           M_pAnimationComponent;                             // 0x0880(0x0008)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, EditConst, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UBFGActorComponent_CharacterPhysics*    M_pCharacterPhysicsComponent;                      // 0x0888(0x0008)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, EditConst, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UBFGActorComponent_Objective*           M_pObjectiveComponent;                             // 0x0890(0x0008)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, EditConst, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UBFGVariationDressingComponent*         M_pDressingComponent;                              // 0x0898(0x0008)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, EditConst, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UBFGBuoyancyForceComponent*             M_pBouyancyComponent;                              // 0x08A0(0x0008)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, EditConst, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UBFGActorComponent_FallDamage*          M_pFallDamageComponent;                            // 0x08A8(0x0008)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, EditConst, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UBFGNetworkPathAgentComponent*          M_pNetworkPathAgentComponent;                      // 0x08B0(0x0008)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, EditConst, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   M_voice;                                           // 0x08B8(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          M_bCanBeTargetedByMentalAbilities;                 // 0x08C0(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          M_bCanBeTargetedByWeapons;                         // 0x08C1(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          M_bUsesCharacterPhysics;                           // 0x08C2(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_8C3[0x5];                                      // 0x08C3(0x0005)(Fixing Size After Last Property [ Dumper-7 ])
	struct FGameplayTagContainer                  M_pExcludedFromAbilitiesTags;                      // 0x08C8(0x0020)(Edit, BlueprintVisible, NativeAccessSpecifierPublic)
	TMap<class UObject*, int32>                   M_aMinTickRateLocks;                               // 0x08E8(0x0050)(ZeroConstructor, Transient, Protected, NativeAccessSpecifierProtected)
	bool                                          M_bAutoActivateNavigationInvoker;                  // 0x0938(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_939[0x7];                                      // 0x0939(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	class UNavigationInvokerComponent*            M_pInvokerComponent;                               // 0x0940(0x0008)(Edit, ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	EBFGFaction                                   M_faction;                                         // 0x0948(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_949[0x7];                                      // 0x0949(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	class UBFGActorComponent_PawnDamage*          M_pDamageComponent;                                // 0x0950(0x0008)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, EditConst, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class USceneComponent*                        M_pObjectiveMarkerParentComponent;                 // 0x0958(0x0008)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, EditConst, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UBFGActorComponent_AimAssistTarget*     M_pAimAssistTargetComponent;                       // 0x0960(0x0008)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, EditConst, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UBFGActorComponent_LockOnTarget*        M_pLockOnTargetComponent;                          // 0x0968(0x0008)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, EditConst, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UDataTable*                             M_pInteractAnimationTable;                         // 0x0970(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UBFGActorComponent_AIAnimations*        M_pAIAnimationsComponent;                          // 0x0978(0x0008)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, EditConst, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UBFGActorComponent_CortexScanResponse*  M_pCortexScanResponseComponent;                    // 0x0980(0x0008)(Edit, ExportObject, ZeroConstructor, EditConst, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UBFGActorComponent_MonetaryValue*       M_pMonetaryValueComponent;                         // 0x0988(0x0008)(Edit, ExportObject, ZeroConstructor, EditConst, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UBFGActorComponent_MentallyInteractable* M_pMentallyInteractableComponent;                  // 0x0990(0x0008)(Edit, ExportObject, ZeroConstructor, EditConst, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UBFGActorComponent_MissionGameplay*     M_pMissionGameplayComponent;                       // 0x0998(0x0008)(Edit, ExportObject, ZeroConstructor, EditConst, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UBFGActorComponent_AITarget*            M_pAITargetComponent;                              // 0x09A0(0x0008)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, EditConst, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          M_bHideWhenCameraIsInside;                         // 0x09A8(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_9A9[0x7];                                      // 0x09A9(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	struct FGameplayTagContainer                  M_oCapTickRateGameplayEffectTags;                  // 0x09B0(0x0020)(Edit, BlueprintVisible, BlueprintReadOnly, DisableEditOnInstance, Protected, NativeAccessSpecifierProtected)

public:
	class UPrimitiveComponent* GetMainMeshComponent();
	void TriggerVO(class FName _event);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"BFGNPCCharacter">();
	}
	static class ABFGNPCCharacter* GetDefaultObj()
	{
		return GetDefaultObjImpl<ABFGNPCCharacter>();
	}
};
static_assert(alignof(ABFGNPCCharacter) == 0x000010, "Wrong alignment on ABFGNPCCharacter");
static_assert(sizeof(ABFGNPCCharacter) == 0x0009D0, "Wrong size on ABFGNPCCharacter");
static_assert(offsetof(ABFGNPCCharacter, M_gameplayTags) == 0x000840, "Member 'ABFGNPCCharacter::M_gameplayTags' has a wrong offset!");
static_assert(offsetof(ABFGNPCCharacter, M_pGameplayEffectTagsComponent) == 0x000860, "Member 'ABFGNPCCharacter::M_pGameplayEffectTagsComponent' has a wrong offset!");
static_assert(offsetof(ABFGNPCCharacter, M_pGameplayEffectResponse) == 0x000868, "Member 'ABFGNPCCharacter::M_pGameplayEffectResponse' has a wrong offset!");
static_assert(offsetof(ABFGNPCCharacter, M_pEffectComponent) == 0x000870, "Member 'ABFGNPCCharacter::M_pEffectComponent' has a wrong offset!");
static_assert(offsetof(ABFGNPCCharacter, M_pStatsComponent) == 0x000878, "Member 'ABFGNPCCharacter::M_pStatsComponent' has a wrong offset!");
static_assert(offsetof(ABFGNPCCharacter, M_pAnimationComponent) == 0x000880, "Member 'ABFGNPCCharacter::M_pAnimationComponent' has a wrong offset!");
static_assert(offsetof(ABFGNPCCharacter, M_pCharacterPhysicsComponent) == 0x000888, "Member 'ABFGNPCCharacter::M_pCharacterPhysicsComponent' has a wrong offset!");
static_assert(offsetof(ABFGNPCCharacter, M_pObjectiveComponent) == 0x000890, "Member 'ABFGNPCCharacter::M_pObjectiveComponent' has a wrong offset!");
static_assert(offsetof(ABFGNPCCharacter, M_pDressingComponent) == 0x000898, "Member 'ABFGNPCCharacter::M_pDressingComponent' has a wrong offset!");
static_assert(offsetof(ABFGNPCCharacter, M_pBouyancyComponent) == 0x0008A0, "Member 'ABFGNPCCharacter::M_pBouyancyComponent' has a wrong offset!");
static_assert(offsetof(ABFGNPCCharacter, M_pFallDamageComponent) == 0x0008A8, "Member 'ABFGNPCCharacter::M_pFallDamageComponent' has a wrong offset!");
static_assert(offsetof(ABFGNPCCharacter, M_pNetworkPathAgentComponent) == 0x0008B0, "Member 'ABFGNPCCharacter::M_pNetworkPathAgentComponent' has a wrong offset!");
static_assert(offsetof(ABFGNPCCharacter, M_voice) == 0x0008B8, "Member 'ABFGNPCCharacter::M_voice' has a wrong offset!");
static_assert(offsetof(ABFGNPCCharacter, M_bCanBeTargetedByMentalAbilities) == 0x0008C0, "Member 'ABFGNPCCharacter::M_bCanBeTargetedByMentalAbilities' has a wrong offset!");
static_assert(offsetof(ABFGNPCCharacter, M_bCanBeTargetedByWeapons) == 0x0008C1, "Member 'ABFGNPCCharacter::M_bCanBeTargetedByWeapons' has a wrong offset!");
static_assert(offsetof(ABFGNPCCharacter, M_bUsesCharacterPhysics) == 0x0008C2, "Member 'ABFGNPCCharacter::M_bUsesCharacterPhysics' has a wrong offset!");
static_assert(offsetof(ABFGNPCCharacter, M_pExcludedFromAbilitiesTags) == 0x0008C8, "Member 'ABFGNPCCharacter::M_pExcludedFromAbilitiesTags' has a wrong offset!");
static_assert(offsetof(ABFGNPCCharacter, M_aMinTickRateLocks) == 0x0008E8, "Member 'ABFGNPCCharacter::M_aMinTickRateLocks' has a wrong offset!");
static_assert(offsetof(ABFGNPCCharacter, M_bAutoActivateNavigationInvoker) == 0x000938, "Member 'ABFGNPCCharacter::M_bAutoActivateNavigationInvoker' has a wrong offset!");
static_assert(offsetof(ABFGNPCCharacter, M_pInvokerComponent) == 0x000940, "Member 'ABFGNPCCharacter::M_pInvokerComponent' has a wrong offset!");
static_assert(offsetof(ABFGNPCCharacter, M_faction) == 0x000948, "Member 'ABFGNPCCharacter::M_faction' has a wrong offset!");
static_assert(offsetof(ABFGNPCCharacter, M_pDamageComponent) == 0x000950, "Member 'ABFGNPCCharacter::M_pDamageComponent' has a wrong offset!");
static_assert(offsetof(ABFGNPCCharacter, M_pObjectiveMarkerParentComponent) == 0x000958, "Member 'ABFGNPCCharacter::M_pObjectiveMarkerParentComponent' has a wrong offset!");
static_assert(offsetof(ABFGNPCCharacter, M_pAimAssistTargetComponent) == 0x000960, "Member 'ABFGNPCCharacter::M_pAimAssistTargetComponent' has a wrong offset!");
static_assert(offsetof(ABFGNPCCharacter, M_pLockOnTargetComponent) == 0x000968, "Member 'ABFGNPCCharacter::M_pLockOnTargetComponent' has a wrong offset!");
static_assert(offsetof(ABFGNPCCharacter, M_pInteractAnimationTable) == 0x000970, "Member 'ABFGNPCCharacter::M_pInteractAnimationTable' has a wrong offset!");
static_assert(offsetof(ABFGNPCCharacter, M_pAIAnimationsComponent) == 0x000978, "Member 'ABFGNPCCharacter::M_pAIAnimationsComponent' has a wrong offset!");
static_assert(offsetof(ABFGNPCCharacter, M_pCortexScanResponseComponent) == 0x000980, "Member 'ABFGNPCCharacter::M_pCortexScanResponseComponent' has a wrong offset!");
static_assert(offsetof(ABFGNPCCharacter, M_pMonetaryValueComponent) == 0x000988, "Member 'ABFGNPCCharacter::M_pMonetaryValueComponent' has a wrong offset!");
static_assert(offsetof(ABFGNPCCharacter, M_pMentallyInteractableComponent) == 0x000990, "Member 'ABFGNPCCharacter::M_pMentallyInteractableComponent' has a wrong offset!");
static_assert(offsetof(ABFGNPCCharacter, M_pMissionGameplayComponent) == 0x000998, "Member 'ABFGNPCCharacter::M_pMissionGameplayComponent' has a wrong offset!");
static_assert(offsetof(ABFGNPCCharacter, M_pAITargetComponent) == 0x0009A0, "Member 'ABFGNPCCharacter::M_pAITargetComponent' has a wrong offset!");
static_assert(offsetof(ABFGNPCCharacter, M_bHideWhenCameraIsInside) == 0x0009A8, "Member 'ABFGNPCCharacter::M_bHideWhenCameraIsInside' has a wrong offset!");
static_assert(offsetof(ABFGNPCCharacter, M_oCapTickRateGameplayEffectTags) == 0x0009B0, "Member 'ABFGNPCCharacter::M_oCapTickRateGameplayEffectTags' has a wrong offset!");

// Class BFGCore.BFGWidget_GenericMenuTree
// 0x0098 (0x04C0 - 0x0428)
class UBFGWidget_GenericMenuTree : public UBFGWidget_GenericDialog
{
public:
	class UBFGDataAssetGenericMenuDescription*    M_pMenuDescription;                                // 0x0428(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	UMulticastDelegateProperty_                   M_OnOptionClicked;                                 // 0x0430(0x0018)(ZeroConstructor, InstancedReference, NativeAccessSpecifierPublic)
	TArray<class UBFGWidget_GenericMenuTree*>     M_apGenericTreeChildren;                           // 0x0448(0x0010)(ExportObject, ZeroConstructor, ContainsInstancedReference, Protected, NativeAccessSpecifierProtected)
	TSoftClassPtr<class UClass>                   M_pOptionClass;                                    // 0x0458(0x0028)(Edit, BlueprintVisible, BlueprintReadOnly, DisableEditOnInstance, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TArray<TSoftClassPtr<class UClass>>           M_apGenericTreeClasses;                            // 0x0480(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, Protected, UObjectWrapper, NativeAccessSpecifierProtected)
	class FText                                   M_strName;                                         // 0x0490(0x0018)(Edit, BlueprintVisible, BlueprintReadOnly, Protected, NativeAccessSpecifierProtected)
	class FName                                   M_oInternalName;                                   // 0x04A8(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_4B0[0x10];                                     // 0x04B0(0x0010)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void Action__DelegateSignature();
	void AddOptionToLayout(class UBFGWidget_DialogOption* _pOption);
	void AddWidgetToLayout(class UBFGWidget_GenericMenuTree* _pWidget);
	void ClearOptionLayout();
	void ClearWidgetLayout();
	void HideSelf(bool _bDown);
	void OnChildNotificationSeen(class FName _oHandlerName);
	void OnDialogCancel();
	void OnDialogChangedSelection();
	void OnDialogOption(int32 IIndex);
	void OnOptionClicked();
	void OnSFX_TreeAdvance();
	void OnSFX_TreeBack();
	void ShowSelf(bool _bDown);

	class FName GetInternalName() const;
	class FText GetNiceName() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"BFGWidget_GenericMenuTree">();
	}
	static class UBFGWidget_GenericMenuTree* GetDefaultObj()
	{
		return GetDefaultObjImpl<UBFGWidget_GenericMenuTree>();
	}
};
static_assert(alignof(UBFGWidget_GenericMenuTree) == 0x000008, "Wrong alignment on UBFGWidget_GenericMenuTree");
static_assert(sizeof(UBFGWidget_GenericMenuTree) == 0x0004C0, "Wrong size on UBFGWidget_GenericMenuTree");
static_assert(offsetof(UBFGWidget_GenericMenuTree, M_pMenuDescription) == 0x000428, "Member 'UBFGWidget_GenericMenuTree::M_pMenuDescription' has a wrong offset!");
static_assert(offsetof(UBFGWidget_GenericMenuTree, M_OnOptionClicked) == 0x000430, "Member 'UBFGWidget_GenericMenuTree::M_OnOptionClicked' has a wrong offset!");
static_assert(offsetof(UBFGWidget_GenericMenuTree, M_apGenericTreeChildren) == 0x000448, "Member 'UBFGWidget_GenericMenuTree::M_apGenericTreeChildren' has a wrong offset!");
static_assert(offsetof(UBFGWidget_GenericMenuTree, M_pOptionClass) == 0x000458, "Member 'UBFGWidget_GenericMenuTree::M_pOptionClass' has a wrong offset!");
static_assert(offsetof(UBFGWidget_GenericMenuTree, M_apGenericTreeClasses) == 0x000480, "Member 'UBFGWidget_GenericMenuTree::M_apGenericTreeClasses' has a wrong offset!");
static_assert(offsetof(UBFGWidget_GenericMenuTree, M_strName) == 0x000490, "Member 'UBFGWidget_GenericMenuTree::M_strName' has a wrong offset!");
static_assert(offsetof(UBFGWidget_GenericMenuTree, M_oInternalName) == 0x0004A8, "Member 'UBFGWidget_GenericMenuTree::M_oInternalName' has a wrong offset!");

// Class BFGCore.BFGWidget_Archive_SubMenu
// 0x0030 (0x04F0 - 0x04C0)
class UBFGWidget_Archive_SubMenu : public UBFGWidget_GenericMenuTree
{
public:
	class FText                                   M_strTopic;                                        // 0x04C0(0x0018)(Edit, BlueprintVisible, BlueprintReadOnly, DisableEditOnInstance, Protected, NativeAccessSpecifierProtected)
	class FText                                   M_strDescription;                                  // 0x04D8(0x0018)(Edit, BlueprintVisible, BlueprintReadOnly, DisableEditOnInstance, Protected, NativeAccessSpecifierProtected)

public:
	class FText GetDescription() const;
	class FText GetTitle() const;
	class FText GetTopic() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"BFGWidget_Archive_SubMenu">();
	}
	static class UBFGWidget_Archive_SubMenu* GetDefaultObj()
	{
		return GetDefaultObjImpl<UBFGWidget_Archive_SubMenu>();
	}
};
static_assert(alignof(UBFGWidget_Archive_SubMenu) == 0x000008, "Wrong alignment on UBFGWidget_Archive_SubMenu");
static_assert(sizeof(UBFGWidget_Archive_SubMenu) == 0x0004F0, "Wrong size on UBFGWidget_Archive_SubMenu");
static_assert(offsetof(UBFGWidget_Archive_SubMenu, M_strTopic) == 0x0004C0, "Member 'UBFGWidget_Archive_SubMenu::M_strTopic' has a wrong offset!");
static_assert(offsetof(UBFGWidget_Archive_SubMenu, M_strDescription) == 0x0004D8, "Member 'UBFGWidget_Archive_SubMenu::M_strDescription' has a wrong offset!");

// Class BFGCore.BFGWidget_Archive_Furonigami
// 0x00A8 (0x0598 - 0x04F0)
class UBFGWidget_Archive_Furonigami final : public UBFGWidget_Archive_SubMenu
{
public:
	class UBFGSpinningWidget*                     M_pSpinningWidget;                                 // 0x04F0(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, Transient, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TArray<class UBFGFuronigamiSelectionInfo*>    M_aFuronigamiInfo;                                 // 0x04F8(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, Protected, NativeAccessSpecifierProtected)
	TSoftClassPtr<class UClass>                   M_pSpinningWidgetOptionClass;                      // 0x0508(0x0028)(Edit, BlueprintVisible, BlueprintReadOnly, DisableEditOnInstance, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TSoftClassPtr<class UClass>                   M_pMediaWidgetStateClass;                          // 0x0530(0x0028)(Edit, BlueprintVisible, BlueprintReadOnly, DisableEditOnInstance, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UBFGGameFlowState_GenericDialog_Customizable* M_pMediaWidgetState;                               // 0x0558(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_560[0x8];                                      // 0x0560(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<class UBFGFuronigamiSelectionInfo*>    M_aAvailableFuronigamiItems;                       // 0x0568(0x0010)(ZeroConstructor, Protected, NativeAccessSpecifierProtected)
	TArray<int32>                                 M_aVisitedIndex;                                   // 0x0578(0x0010)(ZeroConstructor, Protected, NativeAccessSpecifierProtected)
	class UBFGFuronigamiSelectionInfo*            M_pDefaultNoUnlockAsset;                           // 0x0588(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          M_bHasNoUnlocks;                                   // 0x0590(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_591[0x7];                                      // 0x0591(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	class UBFGSpinningWidget* GetSpinningWidget();
	bool HasSpinningWidget();
	void OnMediaPlaybackFinished(EBFGDialogMessage _eMessage);
	void OnMediaWidgetOpened(class UBFGWidget_GenericDialog* _pDialog);
	void OnSpinningWidgetAccepted();
	void OnSpinningWidgetIndexChanged(int32 _iIndex);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"BFGWidget_Archive_Furonigami">();
	}
	static class UBFGWidget_Archive_Furonigami* GetDefaultObj()
	{
		return GetDefaultObjImpl<UBFGWidget_Archive_Furonigami>();
	}
};
static_assert(alignof(UBFGWidget_Archive_Furonigami) == 0x000008, "Wrong alignment on UBFGWidget_Archive_Furonigami");
static_assert(sizeof(UBFGWidget_Archive_Furonigami) == 0x000598, "Wrong size on UBFGWidget_Archive_Furonigami");
static_assert(offsetof(UBFGWidget_Archive_Furonigami, M_pSpinningWidget) == 0x0004F0, "Member 'UBFGWidget_Archive_Furonigami::M_pSpinningWidget' has a wrong offset!");
static_assert(offsetof(UBFGWidget_Archive_Furonigami, M_aFuronigamiInfo) == 0x0004F8, "Member 'UBFGWidget_Archive_Furonigami::M_aFuronigamiInfo' has a wrong offset!");
static_assert(offsetof(UBFGWidget_Archive_Furonigami, M_pSpinningWidgetOptionClass) == 0x000508, "Member 'UBFGWidget_Archive_Furonigami::M_pSpinningWidgetOptionClass' has a wrong offset!");
static_assert(offsetof(UBFGWidget_Archive_Furonigami, M_pMediaWidgetStateClass) == 0x000530, "Member 'UBFGWidget_Archive_Furonigami::M_pMediaWidgetStateClass' has a wrong offset!");
static_assert(offsetof(UBFGWidget_Archive_Furonigami, M_pMediaWidgetState) == 0x000558, "Member 'UBFGWidget_Archive_Furonigami::M_pMediaWidgetState' has a wrong offset!");
static_assert(offsetof(UBFGWidget_Archive_Furonigami, M_aAvailableFuronigamiItems) == 0x000568, "Member 'UBFGWidget_Archive_Furonigami::M_aAvailableFuronigamiItems' has a wrong offset!");
static_assert(offsetof(UBFGWidget_Archive_Furonigami, M_aVisitedIndex) == 0x000578, "Member 'UBFGWidget_Archive_Furonigami::M_aVisitedIndex' has a wrong offset!");
static_assert(offsetof(UBFGWidget_Archive_Furonigami, M_pDefaultNoUnlockAsset) == 0x000588, "Member 'UBFGWidget_Archive_Furonigami::M_pDefaultNoUnlockAsset' has a wrong offset!");
static_assert(offsetof(UBFGWidget_Archive_Furonigami, M_bHasNoUnlocks) == 0x000590, "Member 'UBFGWidget_Archive_Furonigami::M_bHasNoUnlocks' has a wrong offset!");

// Class BFGCore.BFGActorComponent_GameplayToHud
// 0x0070 (0x0198 - 0x0128)
class UBFGActorComponent_GameplayToHud final : public UActorComponent
{
public:
	UMulticastDelegateProperty_                   M_oDamageHitFeedback;                              // 0x0128(0x0018)(ZeroConstructor, InstancedReference, BlueprintAssignable, BlueprintCallable, NativeAccessSpecifierPublic)
	UMulticastDelegateProperty_                   M_oCrosshairScreenLocationChanged;                 // 0x0140(0x0018)(ZeroConstructor, InstancedReference, BlueprintAssignable, BlueprintCallable, NativeAccessSpecifierPublic)
	UMulticastDelegateProperty_                   M_oCrosshairOpacityChanged;                        // 0x0158(0x0018)(ZeroConstructor, InstancedReference, BlueprintAssignable, BlueprintCallable, NativeAccessSpecifierPublic)
	UMulticastDelegateProperty_                   M_oWeaponAndAbilitySharedTargetChanged;            // 0x0170(0x0018)(ZeroConstructor, InstancedReference, BlueprintAssignable, BlueprintCallable, NativeAccessSpecifierPublic)
	struct FVector2D                              M_vCrosshairScreenLocation;                        // 0x0188(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         M_fCrosshairOpacity;                               // 0x0190(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          M_bWeaponAndAbilitySharedTarget;                   // 0x0194(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_195[0x3];                                      // 0x0195(0x0003)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"BFGActorComponent_GameplayToHud">();
	}
	static class UBFGActorComponent_GameplayToHud* GetDefaultObj()
	{
		return GetDefaultObjImpl<UBFGActorComponent_GameplayToHud>();
	}
};
static_assert(alignof(UBFGActorComponent_GameplayToHud) == 0x000008, "Wrong alignment on UBFGActorComponent_GameplayToHud");
static_assert(sizeof(UBFGActorComponent_GameplayToHud) == 0x000198, "Wrong size on UBFGActorComponent_GameplayToHud");
static_assert(offsetof(UBFGActorComponent_GameplayToHud, M_oDamageHitFeedback) == 0x000128, "Member 'UBFGActorComponent_GameplayToHud::M_oDamageHitFeedback' has a wrong offset!");
static_assert(offsetof(UBFGActorComponent_GameplayToHud, M_oCrosshairScreenLocationChanged) == 0x000140, "Member 'UBFGActorComponent_GameplayToHud::M_oCrosshairScreenLocationChanged' has a wrong offset!");
static_assert(offsetof(UBFGActorComponent_GameplayToHud, M_oCrosshairOpacityChanged) == 0x000158, "Member 'UBFGActorComponent_GameplayToHud::M_oCrosshairOpacityChanged' has a wrong offset!");
static_assert(offsetof(UBFGActorComponent_GameplayToHud, M_oWeaponAndAbilitySharedTargetChanged) == 0x000170, "Member 'UBFGActorComponent_GameplayToHud::M_oWeaponAndAbilitySharedTargetChanged' has a wrong offset!");
static_assert(offsetof(UBFGActorComponent_GameplayToHud, M_vCrosshairScreenLocation) == 0x000188, "Member 'UBFGActorComponent_GameplayToHud::M_vCrosshairScreenLocation' has a wrong offset!");
static_assert(offsetof(UBFGActorComponent_GameplayToHud, M_fCrosshairOpacity) == 0x000190, "Member 'UBFGActorComponent_GameplayToHud::M_fCrosshairOpacity' has a wrong offset!");
static_assert(offsetof(UBFGActorComponent_GameplayToHud, M_bWeaponAndAbilitySharedTarget) == 0x000194, "Member 'UBFGActorComponent_GameplayToHud::M_bWeaponAndAbilitySharedTarget' has a wrong offset!");

// Class BFGCore.BFGRichTextBlockDecorator_InputAction
// 0x00C0 (0x00F0 - 0x0030)
class UBFGRichTextBlockDecorator_InputAction : public URichTextBlockImageDecorator
{
public:
	TSoftObjectPtr<class UBFGInputScheme>         M_pInputScheme;                                    // 0x0030(0x0028)(Edit, DisableEditOnInstance, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EInputSchemeIdentifier                        M_eInputSchemeIdentifier;                          // 0x0058(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_59[0x7];                                       // 0x0059(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	struct FSlateBrush                            M_missingTexture;                                  // 0x0060(0x0088)(Edit, Protected, NativeAccessSpecifierProtected)
	TWeakObjectPtr<class URichTextBlock>          M_pOwner;                                          // 0x00E8(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"BFGRichTextBlockDecorator_InputAction">();
	}
	static class UBFGRichTextBlockDecorator_InputAction* GetDefaultObj()
	{
		return GetDefaultObjImpl<UBFGRichTextBlockDecorator_InputAction>();
	}
};
static_assert(alignof(UBFGRichTextBlockDecorator_InputAction) == 0x000008, "Wrong alignment on UBFGRichTextBlockDecorator_InputAction");
static_assert(sizeof(UBFGRichTextBlockDecorator_InputAction) == 0x0000F0, "Wrong size on UBFGRichTextBlockDecorator_InputAction");
static_assert(offsetof(UBFGRichTextBlockDecorator_InputAction, M_pInputScheme) == 0x000030, "Member 'UBFGRichTextBlockDecorator_InputAction::M_pInputScheme' has a wrong offset!");
static_assert(offsetof(UBFGRichTextBlockDecorator_InputAction, M_eInputSchemeIdentifier) == 0x000058, "Member 'UBFGRichTextBlockDecorator_InputAction::M_eInputSchemeIdentifier' has a wrong offset!");
static_assert(offsetof(UBFGRichTextBlockDecorator_InputAction, M_missingTexture) == 0x000060, "Member 'UBFGRichTextBlockDecorator_InputAction::M_missingTexture' has a wrong offset!");
static_assert(offsetof(UBFGRichTextBlockDecorator_InputAction, M_pOwner) == 0x0000E8, "Member 'UBFGRichTextBlockDecorator_InputAction::M_pOwner' has a wrong offset!");

// Class BFGCore.BFGNPCCharacterGameplay
// 0x01C0 (0x0B90 - 0x09D0)
#pragma pack(push, 0x1)
class alignas(0x10) ABFGNPCCharacterGameplay : public ABFGNPCCharacter
{
public:
	uint8                                         Pad_9D0[0x10];                                     // 0x09D0(0x0010)(Fixing Size After Last Property [ Dumper-7 ])
	bool                                          M_bIsMarked;                                       // 0x09E0(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_9E1[0x7];                                      // 0x09E1(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	UMulticastDelegateProperty_                   OnPKPickUpBindableEvent;                           // 0x09E8(0x0018)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	class UBFGActorComponent_EquipmentManager*    M_pEquipmentManagerComponent;                      // 0x0A00(0x0008)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, EditConst, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         M_fAccessoryDropchanceOnDamage;                    // 0x0A08(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_A0C[0x4];                                      // 0x0A0C(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class USkeletalMeshComponent*                 M_pSkeletonMesh;                                   // 0x0A10(0x0008)(Edit, BlueprintVisible, ExportObject, ZeroConstructor, EditConst, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   M_nTargetBoneName;                                 // 0x0A18(0x0008)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   M_nHeadBoneName;                                   // 0x0A20(0x0008)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          M_bCanBeKnockedOver;                               // 0x0A28(0x0001)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_A29[0x3];                                      // 0x0A29(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         M_fPKDamageMultiplier;                             // 0x0A2C(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          M_bCanBeSetOnFire;                                 // 0x0A30(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_A31[0x3];                                      // 0x0A31(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	struct FGameplayTag                           M_oOnFireEffectTag;                                // 0x0A34(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, DisableEditOnInstance, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         M_fFireTickFrequency;                              // 0x0A3C(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         M_fFireDamagePerSecond;                            // 0x0A40(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_A44[0x4];                                      // 0x0A44(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	TSubclassOf<class UDamageType>                M_pFireDamageType;                                 // 0x0A48(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FGameplayTagContainer                  M_oFireExtinguishingTags;                          // 0x0A50(0x0020)(Edit, BlueprintVisible, BlueprintReadOnly, DisableEditOnInstance, NativeAccessSpecifierPublic)
	EObjectWeightClass                            M_oWeightClass;                                    // 0x0A70(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          M_bDisableRagdollCollisionOnDeath;                 // 0x0A71(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          M_bMakeNavObstacleOnDeath;                         // 0x0A72(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_A73[0x1];                                      // 0x0A73(0x0001)(Fixing Size After Last Property [ Dumper-7 ])
	class FName                                   M_nPKGrabBoneName;                                 // 0x0A74(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_A7C[0x4];                                      // 0x0A7C(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	TSubclassOf<class AActor>                     M_spawnOnDeathType;                                // 0x0A80(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          M_bDeathCapsuleCollision;                          // 0x0A88(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          M_bDeathDisableTick;                               // 0x0A89(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_A8A[0xA6];                                     // 0x0A8A(0x00A6)(Fixing Size After Last Property [ Dumper-7 ])
	EBFGAlertSystemSeenState                      M_ePlayerSeenState;                                // 0x0B30(0x0001)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          M_bIsPKed;                                         // 0x0B31(0x0001)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_B32[0x2];                                      // 0x0B32(0x0002)(Fixing Size After Last Property [ Dumper-7 ])
	struct FVector                                M_vCustomMovementVelocity;                         // 0x0B34(0x000C)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class AActor*                                 M_pCurrentTarget;                                  // 0x0B40(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class AActor*                                 M_pCurrentSuspisciousTarget;                       // 0x0B48(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	struct FVector                                M_vCurrentSuspisciousLocation;                     // 0x0B50(0x000C)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	EBFGCuriosityReason_NPC                       M_eCuriosityReason;                                // 0x0B5C(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          M_bDeprecatedAIPropertiesCopyDone;                 // 0x0B5D(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_B5E[0xA];                                      // 0x0B5E(0x000A)(Fixing Size After Last Property [ Dumper-7 ])
	class ABFGDynamicObstacle_Sphere*             M_pDynamicObstacle;                                // 0x0B68(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class AActor*                                 M_pCurrentMissionTarget;                           // 0x0B70(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	EBFGMissionTargetAction_NPC                   M_eCurrentMissionTargetAction;                     // 0x0B78(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          M_bForceTargetEvenIfNotInPerceptionRange;          // 0x0B79(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          M_bForceTargetEvenIfDisguised;                     // 0x0B7A(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_B7B[0x1];                                      // 0x0B7B(0x0001)(Fixing Size After Last Property [ Dumper-7 ])
	class FName                                   M_oExplodeHeadSocket;                              // 0x0B7C(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_B84[0x4];                                      // 0x0B84(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void ChangePhysicsAsset(class UPhysicsAsset* _pNewPhysicsAsset, bool _bAttemptToKeepRagdollTransform);
	void DisableCharacter();
	void ForceAllyNonActive();
	void ForceCoward();
	void FreezeMeshShowSkeleton(bool M_bHideMesh);
	void GameplayCharacterOnPickupSignature__DelegateSignature(class AActor* _pSourceActor);
	struct FVector GetCustomMovementVelocity();
	float GetStandupAnimationDuration();
	float GetStandupProgress();
	void OnCanNotStandUp();
	void OnDeathStatChanged(class AActor* _pActor, class UBFGActorStat_Bool* _pStat);
	void OnFinishedStandingUp();
	void OnFireExinguished();
	void OnPKDrop();
	void OnPKPickUp();
	void OnReadyToStandUp(bool _bIsFaceDown, const struct FPoseSnapshot& _oAnimationSnapshot);
	void OnSetOnFire();
	void OnShowHealthBar();
	void OnTakesFireDamage();
	void OnWasHolobobed();
	void OnWeaponEquipChanged(class ABFGWeapon* _pWeapon, bool _bEnabled);
	void OnWeaponFireChanged(class ABFGWeapon* _pWeapon, bool _bEnabled);
	void OnWeaponReloadDone(class ABFGWeapon* _pWeapon);
	void OnWeaponReloadStarted(class ABFGWeapon* _pWeapon);
	void ResetMissionTargetData();
	void SetCuriosityReason(EBFGCuriosityReason_NPC _curiosityReason);
	void SetCurrentMissionTarget(class AActor* _pActor);
	void SetCurrentMissionTargetAction(EBFGMissionTargetAction_NPC _eMissionTargetAction);
	void SetCurrentSusciousTargetAndLocation(class AActor* _pTarget, const struct FVector& _vLocation);
	void SetCurrentTarget(class AActor* _pTarget);
	void SetForceTargetEvenIfDisguised(bool _bValue);
	void SetForceTargetEvenIfNotInPerceptionRange(bool _bForceTargetEvenIfNotInPerceptionRange);

	EBFGCuriosityReason_NPC GetCuriosityReason() const;
	class AActor* GetCurrentMissionTarget() const;
	EBFGMissionTargetAction_NPC GetCurrentMissionTargetAction() const;
	class AActor* GetCurrentTarget() const;
	struct FVector GetCurrentVectorToSuspiciousLocation() const;
	struct FVector GetCurrentVectorToTarget() const;
	bool GetForceTargetEvenIfDisguised() const;
	bool GetForceTargetEvenIfNotInPerceptionRange() const;
	bool IsOnFire() const;
	bool IsPKed() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"BFGNPCCharacterGameplay">();
	}
	static class ABFGNPCCharacterGameplay* GetDefaultObj()
	{
		return GetDefaultObjImpl<ABFGNPCCharacterGameplay>();
	}
};
#pragma pack(pop)
static_assert(alignof(ABFGNPCCharacterGameplay) == 0x000010, "Wrong alignment on ABFGNPCCharacterGameplay");
static_assert(sizeof(ABFGNPCCharacterGameplay) == 0x000B90, "Wrong size on ABFGNPCCharacterGameplay");
static_assert(offsetof(ABFGNPCCharacterGameplay, M_bIsMarked) == 0x0009E0, "Member 'ABFGNPCCharacterGameplay::M_bIsMarked' has a wrong offset!");
static_assert(offsetof(ABFGNPCCharacterGameplay, OnPKPickUpBindableEvent) == 0x0009E8, "Member 'ABFGNPCCharacterGameplay::OnPKPickUpBindableEvent' has a wrong offset!");
static_assert(offsetof(ABFGNPCCharacterGameplay, M_pEquipmentManagerComponent) == 0x000A00, "Member 'ABFGNPCCharacterGameplay::M_pEquipmentManagerComponent' has a wrong offset!");
static_assert(offsetof(ABFGNPCCharacterGameplay, M_fAccessoryDropchanceOnDamage) == 0x000A08, "Member 'ABFGNPCCharacterGameplay::M_fAccessoryDropchanceOnDamage' has a wrong offset!");
static_assert(offsetof(ABFGNPCCharacterGameplay, M_pSkeletonMesh) == 0x000A10, "Member 'ABFGNPCCharacterGameplay::M_pSkeletonMesh' has a wrong offset!");
static_assert(offsetof(ABFGNPCCharacterGameplay, M_nTargetBoneName) == 0x000A18, "Member 'ABFGNPCCharacterGameplay::M_nTargetBoneName' has a wrong offset!");
static_assert(offsetof(ABFGNPCCharacterGameplay, M_nHeadBoneName) == 0x000A20, "Member 'ABFGNPCCharacterGameplay::M_nHeadBoneName' has a wrong offset!");
static_assert(offsetof(ABFGNPCCharacterGameplay, M_bCanBeKnockedOver) == 0x000A28, "Member 'ABFGNPCCharacterGameplay::M_bCanBeKnockedOver' has a wrong offset!");
static_assert(offsetof(ABFGNPCCharacterGameplay, M_fPKDamageMultiplier) == 0x000A2C, "Member 'ABFGNPCCharacterGameplay::M_fPKDamageMultiplier' has a wrong offset!");
static_assert(offsetof(ABFGNPCCharacterGameplay, M_bCanBeSetOnFire) == 0x000A30, "Member 'ABFGNPCCharacterGameplay::M_bCanBeSetOnFire' has a wrong offset!");
static_assert(offsetof(ABFGNPCCharacterGameplay, M_oOnFireEffectTag) == 0x000A34, "Member 'ABFGNPCCharacterGameplay::M_oOnFireEffectTag' has a wrong offset!");
static_assert(offsetof(ABFGNPCCharacterGameplay, M_fFireTickFrequency) == 0x000A3C, "Member 'ABFGNPCCharacterGameplay::M_fFireTickFrequency' has a wrong offset!");
static_assert(offsetof(ABFGNPCCharacterGameplay, M_fFireDamagePerSecond) == 0x000A40, "Member 'ABFGNPCCharacterGameplay::M_fFireDamagePerSecond' has a wrong offset!");
static_assert(offsetof(ABFGNPCCharacterGameplay, M_pFireDamageType) == 0x000A48, "Member 'ABFGNPCCharacterGameplay::M_pFireDamageType' has a wrong offset!");
static_assert(offsetof(ABFGNPCCharacterGameplay, M_oFireExtinguishingTags) == 0x000A50, "Member 'ABFGNPCCharacterGameplay::M_oFireExtinguishingTags' has a wrong offset!");
static_assert(offsetof(ABFGNPCCharacterGameplay, M_oWeightClass) == 0x000A70, "Member 'ABFGNPCCharacterGameplay::M_oWeightClass' has a wrong offset!");
static_assert(offsetof(ABFGNPCCharacterGameplay, M_bDisableRagdollCollisionOnDeath) == 0x000A71, "Member 'ABFGNPCCharacterGameplay::M_bDisableRagdollCollisionOnDeath' has a wrong offset!");
static_assert(offsetof(ABFGNPCCharacterGameplay, M_bMakeNavObstacleOnDeath) == 0x000A72, "Member 'ABFGNPCCharacterGameplay::M_bMakeNavObstacleOnDeath' has a wrong offset!");
static_assert(offsetof(ABFGNPCCharacterGameplay, M_nPKGrabBoneName) == 0x000A74, "Member 'ABFGNPCCharacterGameplay::M_nPKGrabBoneName' has a wrong offset!");
static_assert(offsetof(ABFGNPCCharacterGameplay, M_spawnOnDeathType) == 0x000A80, "Member 'ABFGNPCCharacterGameplay::M_spawnOnDeathType' has a wrong offset!");
static_assert(offsetof(ABFGNPCCharacterGameplay, M_bDeathCapsuleCollision) == 0x000A88, "Member 'ABFGNPCCharacterGameplay::M_bDeathCapsuleCollision' has a wrong offset!");
static_assert(offsetof(ABFGNPCCharacterGameplay, M_bDeathDisableTick) == 0x000A89, "Member 'ABFGNPCCharacterGameplay::M_bDeathDisableTick' has a wrong offset!");
static_assert(offsetof(ABFGNPCCharacterGameplay, M_ePlayerSeenState) == 0x000B30, "Member 'ABFGNPCCharacterGameplay::M_ePlayerSeenState' has a wrong offset!");
static_assert(offsetof(ABFGNPCCharacterGameplay, M_bIsPKed) == 0x000B31, "Member 'ABFGNPCCharacterGameplay::M_bIsPKed' has a wrong offset!");
static_assert(offsetof(ABFGNPCCharacterGameplay, M_vCustomMovementVelocity) == 0x000B34, "Member 'ABFGNPCCharacterGameplay::M_vCustomMovementVelocity' has a wrong offset!");
static_assert(offsetof(ABFGNPCCharacterGameplay, M_pCurrentTarget) == 0x000B40, "Member 'ABFGNPCCharacterGameplay::M_pCurrentTarget' has a wrong offset!");
static_assert(offsetof(ABFGNPCCharacterGameplay, M_pCurrentSuspisciousTarget) == 0x000B48, "Member 'ABFGNPCCharacterGameplay::M_pCurrentSuspisciousTarget' has a wrong offset!");
static_assert(offsetof(ABFGNPCCharacterGameplay, M_vCurrentSuspisciousLocation) == 0x000B50, "Member 'ABFGNPCCharacterGameplay::M_vCurrentSuspisciousLocation' has a wrong offset!");
static_assert(offsetof(ABFGNPCCharacterGameplay, M_eCuriosityReason) == 0x000B5C, "Member 'ABFGNPCCharacterGameplay::M_eCuriosityReason' has a wrong offset!");
static_assert(offsetof(ABFGNPCCharacterGameplay, M_bDeprecatedAIPropertiesCopyDone) == 0x000B5D, "Member 'ABFGNPCCharacterGameplay::M_bDeprecatedAIPropertiesCopyDone' has a wrong offset!");
static_assert(offsetof(ABFGNPCCharacterGameplay, M_pDynamicObstacle) == 0x000B68, "Member 'ABFGNPCCharacterGameplay::M_pDynamicObstacle' has a wrong offset!");
static_assert(offsetof(ABFGNPCCharacterGameplay, M_pCurrentMissionTarget) == 0x000B70, "Member 'ABFGNPCCharacterGameplay::M_pCurrentMissionTarget' has a wrong offset!");
static_assert(offsetof(ABFGNPCCharacterGameplay, M_eCurrentMissionTargetAction) == 0x000B78, "Member 'ABFGNPCCharacterGameplay::M_eCurrentMissionTargetAction' has a wrong offset!");
static_assert(offsetof(ABFGNPCCharacterGameplay, M_bForceTargetEvenIfNotInPerceptionRange) == 0x000B79, "Member 'ABFGNPCCharacterGameplay::M_bForceTargetEvenIfNotInPerceptionRange' has a wrong offset!");
static_assert(offsetof(ABFGNPCCharacterGameplay, M_bForceTargetEvenIfDisguised) == 0x000B7A, "Member 'ABFGNPCCharacterGameplay::M_bForceTargetEvenIfDisguised' has a wrong offset!");
static_assert(offsetof(ABFGNPCCharacterGameplay, M_oExplodeHeadSocket) == 0x000B7C, "Member 'ABFGNPCCharacterGameplay::M_oExplodeHeadSocket' has a wrong offset!");

// Class BFGCore.BFGEventAction
// 0x0008 (0x0030 - 0x0028)
class UBFGEventAction : public UObject
{
public:
	uint8                                         Pad_28[0x8];                                       // 0x0028(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"BFGEventAction">();
	}
	static class UBFGEventAction* GetDefaultObj()
	{
		return GetDefaultObjImpl<UBFGEventAction>();
	}
};
static_assert(alignof(UBFGEventAction) == 0x000008, "Wrong alignment on UBFGEventAction");
static_assert(sizeof(UBFGEventAction) == 0x000030, "Wrong size on UBFGEventAction");

// Class BFGCore.BFGEventAction_Checkpoint
// 0x0018 (0x0048 - 0x0030)
class UBFGEventAction_Checkpoint final : public UBFGEventAction
{
public:
	uint8                                         Pad_30[0x18];                                      // 0x0030(0x0018)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"BFGEventAction_Checkpoint">();
	}
	static class UBFGEventAction_Checkpoint* GetDefaultObj()
	{
		return GetDefaultObjImpl<UBFGEventAction_Checkpoint>();
	}
};
static_assert(alignof(UBFGEventAction_Checkpoint) == 0x000008, "Wrong alignment on UBFGEventAction_Checkpoint");
static_assert(sizeof(UBFGEventAction_Checkpoint) == 0x000048, "Wrong size on UBFGEventAction_Checkpoint");

// Class BFGCore.BFGBTBaseTaskNode
// 0x0008 (0x0078 - 0x0070)
class UBFGBTBaseTaskNode : public UBTTaskNode
{
public:
	bool                                          M_bAutoResolveBlackboardKeys;                      // 0x0070(0x0001)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_71[0x7];                                       // 0x0071(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"BFGBTBaseTaskNode">();
	}
	static class UBFGBTBaseTaskNode* GetDefaultObj()
	{
		return GetDefaultObjImpl<UBFGBTBaseTaskNode>();
	}
};
static_assert(alignof(UBFGBTBaseTaskNode) == 0x000008, "Wrong alignment on UBFGBTBaseTaskNode");
static_assert(sizeof(UBFGBTBaseTaskNode) == 0x000078, "Wrong size on UBFGBTBaseTaskNode");
static_assert(offsetof(UBFGBTBaseTaskNode, M_bAutoResolveBlackboardKeys) == 0x000070, "Member 'UBFGBTBaseTaskNode::M_bAutoResolveBlackboardKeys' has a wrong offset!");

// Class BFGCore.BFGTaskNode_BossBase
// 0x0028 (0x00A0 - 0x0078)
class UBFGTaskNode_BossBase : public UBFGBTBaseTaskNode
{
public:
	uint8                                         Pad_78[0x10];                                      // 0x0078(0x0010)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         M_fActionTelegraphTime;                            // 0x0088(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         M_fAnimationLength;                                // 0x008C(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UBehaviorTreeComponent*                 M_pOwnerComp;                                      // 0x0090(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class ABFGNPCCharacterBoss*                   M_pOwnerCharacterBoss;                             // 0x0098(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)

public:
	void ActionComplete();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"BFGTaskNode_BossBase">();
	}
	static class UBFGTaskNode_BossBase* GetDefaultObj()
	{
		return GetDefaultObjImpl<UBFGTaskNode_BossBase>();
	}
};
static_assert(alignof(UBFGTaskNode_BossBase) == 0x000008, "Wrong alignment on UBFGTaskNode_BossBase");
static_assert(sizeof(UBFGTaskNode_BossBase) == 0x0000A0, "Wrong size on UBFGTaskNode_BossBase");
static_assert(offsetof(UBFGTaskNode_BossBase, M_fActionTelegraphTime) == 0x000088, "Member 'UBFGTaskNode_BossBase::M_fActionTelegraphTime' has a wrong offset!");
static_assert(offsetof(UBFGTaskNode_BossBase, M_fAnimationLength) == 0x00008C, "Member 'UBFGTaskNode_BossBase::M_fAnimationLength' has a wrong offset!");
static_assert(offsetof(UBFGTaskNode_BossBase, M_pOwnerComp) == 0x000090, "Member 'UBFGTaskNode_BossBase::M_pOwnerComp' has a wrong offset!");
static_assert(offsetof(UBFGTaskNode_BossBase, M_pOwnerCharacterBoss) == 0x000098, "Member 'UBFGTaskNode_BossBase::M_pOwnerCharacterBoss' has a wrong offset!");

// Class BFGCore.BFG_AISenseConfigAgression
// 0x0018 (0x0060 - 0x0048)
class UBFG_AISenseConfigAgression final : public UAISenseConfig
{
public:
	TSubclassOf<class UBFG_AISenseAgression>      Implementation;                                    // 0x0048(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Config, DisableEditOnInstance, NoClear, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         WitnessingRange;                                   // 0x0050(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         LoSWitnessingRange;                                // 0x0054(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         bUseLoSWitnessing : 1;                             // 0x0058(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (Edit, DisableEditOnInstance, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         Pad_59[0x3];                                       // 0x0059(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	struct FAISenseAffiliationFilter              DetectionByAffiliation;                            // 0x005C(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Config, DisableEditOnInstance, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"BFG_AISenseConfigAgression">();
	}
	static class UBFG_AISenseConfigAgression* GetDefaultObj()
	{
		return GetDefaultObjImpl<UBFG_AISenseConfigAgression>();
	}
};
static_assert(alignof(UBFG_AISenseConfigAgression) == 0x000008, "Wrong alignment on UBFG_AISenseConfigAgression");
static_assert(sizeof(UBFG_AISenseConfigAgression) == 0x000060, "Wrong size on UBFG_AISenseConfigAgression");
static_assert(offsetof(UBFG_AISenseConfigAgression, Implementation) == 0x000048, "Member 'UBFG_AISenseConfigAgression::Implementation' has a wrong offset!");
static_assert(offsetof(UBFG_AISenseConfigAgression, WitnessingRange) == 0x000050, "Member 'UBFG_AISenseConfigAgression::WitnessingRange' has a wrong offset!");
static_assert(offsetof(UBFG_AISenseConfigAgression, LoSWitnessingRange) == 0x000054, "Member 'UBFG_AISenseConfigAgression::LoSWitnessingRange' has a wrong offset!");
static_assert(offsetof(UBFG_AISenseConfigAgression, DetectionByAffiliation) == 0x00005C, "Member 'UBFG_AISenseConfigAgression::DetectionByAffiliation' has a wrong offset!");

// Class BFGCore.BFGActorComponent_HolobobSuppressionAura
// 0x0050 (0x0178 - 0x0128)
class UBFGActorComponent_HolobobSuppressionAura final : public UActorComponent
{
public:
	float                                         M_fAuraRadius;                                     // 0x0128(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_12C[0x4];                                      // 0x012C(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	struct FGameplayTagContainer                  M_oForbiddenTags;                                  // 0x0130(0x0020)(Edit, BlueprintVisible, BlueprintReadOnly, DisableEditOnInstance, NativeAccessSpecifierPublic)
	class UBFGActorComponent_RadarObject_ExactRadius* M_pRadarComponent;                                 // 0x0150(0x0008)(Edit, ExportObject, ZeroConstructor, Transient, EditConst, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UBFGActorComponent_PawnStats*           M_pOwnerStats;                                     // 0x0158(0x0008)(ExportObject, ZeroConstructor, Transient, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UBFGNetworkPathAgentComponent*          M_pNetworkPathAgent;                               // 0x0160(0x0008)(ExportObject, ZeroConstructor, Transient, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	struct FVector                                M_vLastActorLocation;                              // 0x0168(0x000C)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_174[0x4];                                      // 0x0174(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void SetupRadarComponent(class UBFGActorComponent_RadarObject_ExactRadius* _pRadarComponent);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"BFGActorComponent_HolobobSuppressionAura">();
	}
	static class UBFGActorComponent_HolobobSuppressionAura* GetDefaultObj()
	{
		return GetDefaultObjImpl<UBFGActorComponent_HolobobSuppressionAura>();
	}
};
static_assert(alignof(UBFGActorComponent_HolobobSuppressionAura) == 0x000008, "Wrong alignment on UBFGActorComponent_HolobobSuppressionAura");
static_assert(sizeof(UBFGActorComponent_HolobobSuppressionAura) == 0x000178, "Wrong size on UBFGActorComponent_HolobobSuppressionAura");
static_assert(offsetof(UBFGActorComponent_HolobobSuppressionAura, M_fAuraRadius) == 0x000128, "Member 'UBFGActorComponent_HolobobSuppressionAura::M_fAuraRadius' has a wrong offset!");
static_assert(offsetof(UBFGActorComponent_HolobobSuppressionAura, M_oForbiddenTags) == 0x000130, "Member 'UBFGActorComponent_HolobobSuppressionAura::M_oForbiddenTags' has a wrong offset!");
static_assert(offsetof(UBFGActorComponent_HolobobSuppressionAura, M_pRadarComponent) == 0x000150, "Member 'UBFGActorComponent_HolobobSuppressionAura::M_pRadarComponent' has a wrong offset!");
static_assert(offsetof(UBFGActorComponent_HolobobSuppressionAura, M_pOwnerStats) == 0x000158, "Member 'UBFGActorComponent_HolobobSuppressionAura::M_pOwnerStats' has a wrong offset!");
static_assert(offsetof(UBFGActorComponent_HolobobSuppressionAura, M_pNetworkPathAgent) == 0x000160, "Member 'UBFGActorComponent_HolobobSuppressionAura::M_pNetworkPathAgent' has a wrong offset!");
static_assert(offsetof(UBFGActorComponent_HolobobSuppressionAura, M_vLastActorLocation) == 0x000168, "Member 'UBFGActorComponent_HolobobSuppressionAura::M_vLastActorLocation' has a wrong offset!");

// Class BFGCore.BFGTaskNode_SetMoveSpeed
// 0x0008 (0x0080 - 0x0078)
class UBFGTaskNode_SetMoveSpeed final : public UBFGBTBaseTaskNode
{
public:
	EBFGNPCCharacter_MoveSpeed                    M_moveSpeed;                                       // 0x0078(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_79[0x7];                                       // 0x0079(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"BFGTaskNode_SetMoveSpeed">();
	}
	static class UBFGTaskNode_SetMoveSpeed* GetDefaultObj()
	{
		return GetDefaultObjImpl<UBFGTaskNode_SetMoveSpeed>();
	}
};
static_assert(alignof(UBFGTaskNode_SetMoveSpeed) == 0x000008, "Wrong alignment on UBFGTaskNode_SetMoveSpeed");
static_assert(sizeof(UBFGTaskNode_SetMoveSpeed) == 0x000080, "Wrong size on UBFGTaskNode_SetMoveSpeed");
static_assert(offsetof(UBFGTaskNode_SetMoveSpeed, M_moveSpeed) == 0x000078, "Member 'UBFGTaskNode_SetMoveSpeed::M_moveSpeed' has a wrong offset!");

// Class BFGCore.BFGEventTrigger_FadeFinished
// 0x0010 (0x0050 - 0x0040)
class UBFGEventTrigger_FadeFinished final : public UBFGEventTrigger
{
public:
	uint8                                         Pad_40[0x10];                                      // 0x0040(0x0010)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void OnFadeFinished(class FName _strFadeIdentifier, bool _bFadeOut);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"BFGEventTrigger_FadeFinished">();
	}
	static class UBFGEventTrigger_FadeFinished* GetDefaultObj()
	{
		return GetDefaultObjImpl<UBFGEventTrigger_FadeFinished>();
	}
};
static_assert(alignof(UBFGEventTrigger_FadeFinished) == 0x000008, "Wrong alignment on UBFGEventTrigger_FadeFinished");
static_assert(sizeof(UBFGEventTrigger_FadeFinished) == 0x000050, "Wrong size on UBFGEventTrigger_FadeFinished");

// Class BFGCore.BFGNPCCharacterHuman
// 0x0050 (0x0BE0 - 0x0B90)
#pragma pack(push, 0x1)
class alignas(0x10) ABFGNPCCharacterHuman : public ABFGNPCCharacterGameplay
{
public:
	struct FSoftClassPath                         M_brainClass;                                      // 0x0B88(0x0018)(Edit, ZeroConstructor, DisableEditOnInstance, NativeAccessSpecifierPublic)
	UMulticastDelegateProperty_                   M_OnDeadStateChanged;                              // 0x0BA0(0x0018)(ZeroConstructor, InstancedReference, NativeAccessSpecifierPublic)
	UMulticastDelegateProperty_                   M_OnAIStateChanged;                                // 0x0BB8(0x0018)(ZeroConstructor, InstancedReference, NativeAccessSpecifierPublic)
	bool                                          M_bCowering;                                       // 0x0BD0(0x0001)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	EBFGHypnotizeState_NPC                        M_eHypnotizeState;                                 // 0x0BD1(0x0001)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          M_bShowAlertTransitions;                           // 0x0BD2(0x0001)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_BD3[0x5];                                      // 0x0BD3(0x0005)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void ActionBehaviourState__DelegateSignature(EBFGBehaviourState_NPC _eState);
	void ActionBool__DelegateSignature(bool _bState);
	void DoDecapitateDressing();
	void OnAIStateChanged(EBFGBehaviourState_NPC _newState);
	void OnDeadStateChanged(bool _bNewState);
	void OnStatDeadStateChanged(class AActor* _pTargetActor, class UBFGActorStat_Bool* _pStat);
	void TriggerEventAIStateChanged(EBFGBehaviourState_NPC _newState);

	struct FVector GetBrainSpawnLocation() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"BFGNPCCharacterHuman">();
	}
	static class ABFGNPCCharacterHuman* GetDefaultObj()
	{
		return GetDefaultObjImpl<ABFGNPCCharacterHuman>();
	}
};
#pragma pack(pop)
static_assert(alignof(ABFGNPCCharacterHuman) == 0x000010, "Wrong alignment on ABFGNPCCharacterHuman");
static_assert(sizeof(ABFGNPCCharacterHuman) == 0x000BE0, "Wrong size on ABFGNPCCharacterHuman");
static_assert(offsetof(ABFGNPCCharacterHuman, M_brainClass) == 0x000B88, "Member 'ABFGNPCCharacterHuman::M_brainClass' has a wrong offset!");
static_assert(offsetof(ABFGNPCCharacterHuman, M_OnDeadStateChanged) == 0x000BA0, "Member 'ABFGNPCCharacterHuman::M_OnDeadStateChanged' has a wrong offset!");
static_assert(offsetof(ABFGNPCCharacterHuman, M_OnAIStateChanged) == 0x000BB8, "Member 'ABFGNPCCharacterHuman::M_OnAIStateChanged' has a wrong offset!");
static_assert(offsetof(ABFGNPCCharacterHuman, M_bCowering) == 0x000BD0, "Member 'ABFGNPCCharacterHuman::M_bCowering' has a wrong offset!");
static_assert(offsetof(ABFGNPCCharacterHuman, M_eHypnotizeState) == 0x000BD1, "Member 'ABFGNPCCharacterHuman::M_eHypnotizeState' has a wrong offset!");
static_assert(offsetof(ABFGNPCCharacterHuman, M_bShowAlertTransitions) == 0x000BD2, "Member 'ABFGNPCCharacterHuman::M_bShowAlertTransitions' has a wrong offset!");

// Class BFGCore.BFGWidget_ConfirmUpgrade
// 0x0000 (0x0428 - 0x0428)
class UBFGWidget_ConfirmUpgrade final : public UBFGWidget_GenericDialog
{
public:
	void Setup(const class FText& _strUpgradeName, int32 _iUpgradeCost);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"BFGWidget_ConfirmUpgrade">();
	}
	static class UBFGWidget_ConfirmUpgrade* GetDefaultObj()
	{
		return GetDefaultObjImpl<UBFGWidget_ConfirmUpgrade>();
	}
};
static_assert(alignof(UBFGWidget_ConfirmUpgrade) == 0x000008, "Wrong alignment on UBFGWidget_ConfirmUpgrade");
static_assert(sizeof(UBFGWidget_ConfirmUpgrade) == 0x000428, "Wrong size on UBFGWidget_ConfirmUpgrade");

// Class BFGCore.BFGHUDVisibilityStateCapable
// 0x0000 (0x0028 - 0x0028)
class IBFGHUDVisibilityStateCapable final : public IInterface
{
public:
	bool ComputeDesiredVisibility();
	void SetManagedVisibilityState(bool _bVisible);
	void SetRegistered(bool _bRegistered);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"BFGHUDVisibilityStateCapable">();
	}
	static class IBFGHUDVisibilityStateCapable* GetDefaultObj()
	{
		return GetDefaultObjImpl<IBFGHUDVisibilityStateCapable>();
	}
};
static_assert(alignof(IBFGHUDVisibilityStateCapable) == 0x000008, "Wrong alignment on IBFGHUDVisibilityStateCapable");
static_assert(sizeof(IBFGHUDVisibilityStateCapable) == 0x000028, "Wrong size on IBFGHUDVisibilityStateCapable");

// Class BFGCore.BFGNPCCharacterEnemy
// 0x0000 (0x0BE0 - 0x0BE0)
#pragma pack(push, 0x1)
class alignas(0x10) ABFGNPCCharacterEnemy : public ABFGNPCCharacterHuman
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"BFGNPCCharacterEnemy">();
	}
	static class ABFGNPCCharacterEnemy* GetDefaultObj()
	{
		return GetDefaultObjImpl<ABFGNPCCharacterEnemy>();
	}
};
#pragma pack(pop)
static_assert(alignof(ABFGNPCCharacterEnemy) == 0x000010, "Wrong alignment on ABFGNPCCharacterEnemy");
static_assert(sizeof(ABFGNPCCharacterEnemy) == 0x000BE0, "Wrong size on ABFGNPCCharacterEnemy");

// Class BFGCore.BFGActorComponent_HUDVisibilityStateManager
// 0x0028 (0x0150 - 0x0128)
class UBFGActorComponent_HUDVisibilityStateManager : public UActorComponent
{
public:
	TArray<TScriptInterface<class IBFGHUDVisibilityStateCapable>> M_apRegisteredObjects;                             // 0x0128(0x0010)(ZeroConstructor, Protected, UObjectWrapper, NativeAccessSpecifierProtected)
	uint8                                         Pad_138[0x18];                                     // 0x0138(0x0018)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void AddState(EBFGHUDVisibilityState _eState);
	void ForceUpdateNextFrame();
	void RegisterObject(TScriptInterface<class IBFGHUDVisibilityStateCapable> _pObject);
	void RemoveState(EBFGHUDVisibilityState _eState);
	void UnregisterObject(TScriptInterface<class IBFGHUDVisibilityStateCapable> _pObject);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"BFGActorComponent_HUDVisibilityStateManager">();
	}
	static class UBFGActorComponent_HUDVisibilityStateManager* GetDefaultObj()
	{
		return GetDefaultObjImpl<UBFGActorComponent_HUDVisibilityStateManager>();
	}
};
static_assert(alignof(UBFGActorComponent_HUDVisibilityStateManager) == 0x000008, "Wrong alignment on UBFGActorComponent_HUDVisibilityStateManager");
static_assert(sizeof(UBFGActorComponent_HUDVisibilityStateManager) == 0x000150, "Wrong size on UBFGActorComponent_HUDVisibilityStateManager");
static_assert(offsetof(UBFGActorComponent_HUDVisibilityStateManager, M_apRegisteredObjects) == 0x000128, "Member 'UBFGActorComponent_HUDVisibilityStateManager::M_apRegisteredObjects' has a wrong offset!");

// Class BFGCore.BFGNetworkPathAgent_AIStateBase
// 0x0030 (0x0058 - 0x0028)
class UBFGNetworkPathAgent_AIStateBase : public UObject
{
public:
	class UBFGNetworkPathAgent_AI*                M_pAI;                                             // 0x0028(0x0008)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UBFGNetworkPathAgent*                   M_pAgent;                                          // 0x0030(0x0008)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          M_bIsPaused;                                       // 0x0038(0x0001)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          M_bIsFinished;                                     // 0x0039(0x0001)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_3A[0x6];                                       // 0x003A(0x0006)(Fixing Size After Last Property [ Dumper-7 ])
	class UBFGNetworkPathAgent_AIStateBase*       M_pNextState;                                      // 0x0040(0x0008)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UBFGNetworkPathAgent_AIStateBase*       M_pChildState;                                     // 0x0048(0x0008)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          M_bIsPlayingInteract;                              // 0x0050(0x0001)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_51[0x7];                                       // 0x0051(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void OnAgentAttachedActorResetCallback(class UBFGNetworkPathAgent* _pAgent);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"BFGNetworkPathAgent_AIStateBase">();
	}
	static class UBFGNetworkPathAgent_AIStateBase* GetDefaultObj()
	{
		return GetDefaultObjImpl<UBFGNetworkPathAgent_AIStateBase>();
	}
};
static_assert(alignof(UBFGNetworkPathAgent_AIStateBase) == 0x000008, "Wrong alignment on UBFGNetworkPathAgent_AIStateBase");
static_assert(sizeof(UBFGNetworkPathAgent_AIStateBase) == 0x000058, "Wrong size on UBFGNetworkPathAgent_AIStateBase");
static_assert(offsetof(UBFGNetworkPathAgent_AIStateBase, M_pAI) == 0x000028, "Member 'UBFGNetworkPathAgent_AIStateBase::M_pAI' has a wrong offset!");
static_assert(offsetof(UBFGNetworkPathAgent_AIStateBase, M_pAgent) == 0x000030, "Member 'UBFGNetworkPathAgent_AIStateBase::M_pAgent' has a wrong offset!");
static_assert(offsetof(UBFGNetworkPathAgent_AIStateBase, M_bIsPaused) == 0x000038, "Member 'UBFGNetworkPathAgent_AIStateBase::M_bIsPaused' has a wrong offset!");
static_assert(offsetof(UBFGNetworkPathAgent_AIStateBase, M_bIsFinished) == 0x000039, "Member 'UBFGNetworkPathAgent_AIStateBase::M_bIsFinished' has a wrong offset!");
static_assert(offsetof(UBFGNetworkPathAgent_AIStateBase, M_pNextState) == 0x000040, "Member 'UBFGNetworkPathAgent_AIStateBase::M_pNextState' has a wrong offset!");
static_assert(offsetof(UBFGNetworkPathAgent_AIStateBase, M_pChildState) == 0x000048, "Member 'UBFGNetworkPathAgent_AIStateBase::M_pChildState' has a wrong offset!");
static_assert(offsetof(UBFGNetworkPathAgent_AIStateBase, M_bIsPlayingInteract) == 0x000050, "Member 'UBFGNetworkPathAgent_AIStateBase::M_bIsPlayingInteract' has a wrong offset!");

// Class BFGCore.BFGNetworkPathAgent_AIStateCrowdLife
// 0x0048 (0x00A0 - 0x0058)
class UBFGNetworkPathAgent_AIStateCrowdLife final : public UBFGNetworkPathAgent_AIStateBase
{
public:
	class UBFGCrowdLifeStationComponent*          M_pStation;                                        // 0x0058(0x0008)(ExportObject, ZeroConstructor, Transient, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UBFGCrowdLifeStationComponent*          M_pLastStation;                                    // 0x0060(0x0008)(ExportObject, ZeroConstructor, Transient, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UBFGCrowdScriptConComponent*            M_pScriptConComponent;                             // 0x0068(0x0008)(ExportObject, ZeroConstructor, Transient, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	struct FVector                                M_vStationTargetLocation;                          // 0x0070(0x000C)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          M_bStationChanged;                                 // 0x007C(0x0001)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	struct FBFGAICrowdLifeLeaveRequest            M_lastLeaveRequest;                                // 0x007D(0x0001)(Transient, NoDestructor, Protected, NativeAccessSpecifierProtected)
	EBFGAICrowdLifeState                          M_eState;                                          // 0x007E(0x0001)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          M_bAnimationSequenceDefinitionChanged;             // 0x007F(0x0001)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          M_bActorChanged;                                   // 0x0080(0x0001)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          M_bHasEquippedAgentWithWeapon;                     // 0x0081(0x0001)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_82[0x6];                                       // 0x0082(0x0006)(Fixing Size After Last Property [ Dumper-7 ])
	class UBFGPlayCrowdLifeStationAnim*           M_pPlayCrowdLifeAnimObject;                        // 0x0088(0x0008)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	struct FVector                                M_vAgentLastLocation;                              // 0x0090(0x000C)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_9C[0x4];                                       // 0x009C(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void OnAnimationSequenceChanged(class UBFGCrowdLifeStationComponent* _pStation);
	void OnAttachedACtorChanged(class UBFGNetworkPathAgent* _pAgent, class AActor* _pActor, bool _bIsAttached);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"BFGNetworkPathAgent_AIStateCrowdLife">();
	}
	static class UBFGNetworkPathAgent_AIStateCrowdLife* GetDefaultObj()
	{
		return GetDefaultObjImpl<UBFGNetworkPathAgent_AIStateCrowdLife>();
	}
};
static_assert(alignof(UBFGNetworkPathAgent_AIStateCrowdLife) == 0x000008, "Wrong alignment on UBFGNetworkPathAgent_AIStateCrowdLife");
static_assert(sizeof(UBFGNetworkPathAgent_AIStateCrowdLife) == 0x0000A0, "Wrong size on UBFGNetworkPathAgent_AIStateCrowdLife");
static_assert(offsetof(UBFGNetworkPathAgent_AIStateCrowdLife, M_pStation) == 0x000058, "Member 'UBFGNetworkPathAgent_AIStateCrowdLife::M_pStation' has a wrong offset!");
static_assert(offsetof(UBFGNetworkPathAgent_AIStateCrowdLife, M_pLastStation) == 0x000060, "Member 'UBFGNetworkPathAgent_AIStateCrowdLife::M_pLastStation' has a wrong offset!");
static_assert(offsetof(UBFGNetworkPathAgent_AIStateCrowdLife, M_pScriptConComponent) == 0x000068, "Member 'UBFGNetworkPathAgent_AIStateCrowdLife::M_pScriptConComponent' has a wrong offset!");
static_assert(offsetof(UBFGNetworkPathAgent_AIStateCrowdLife, M_vStationTargetLocation) == 0x000070, "Member 'UBFGNetworkPathAgent_AIStateCrowdLife::M_vStationTargetLocation' has a wrong offset!");
static_assert(offsetof(UBFGNetworkPathAgent_AIStateCrowdLife, M_bStationChanged) == 0x00007C, "Member 'UBFGNetworkPathAgent_AIStateCrowdLife::M_bStationChanged' has a wrong offset!");
static_assert(offsetof(UBFGNetworkPathAgent_AIStateCrowdLife, M_lastLeaveRequest) == 0x00007D, "Member 'UBFGNetworkPathAgent_AIStateCrowdLife::M_lastLeaveRequest' has a wrong offset!");
static_assert(offsetof(UBFGNetworkPathAgent_AIStateCrowdLife, M_eState) == 0x00007E, "Member 'UBFGNetworkPathAgent_AIStateCrowdLife::M_eState' has a wrong offset!");
static_assert(offsetof(UBFGNetworkPathAgent_AIStateCrowdLife, M_bAnimationSequenceDefinitionChanged) == 0x00007F, "Member 'UBFGNetworkPathAgent_AIStateCrowdLife::M_bAnimationSequenceDefinitionChanged' has a wrong offset!");
static_assert(offsetof(UBFGNetworkPathAgent_AIStateCrowdLife, M_bActorChanged) == 0x000080, "Member 'UBFGNetworkPathAgent_AIStateCrowdLife::M_bActorChanged' has a wrong offset!");
static_assert(offsetof(UBFGNetworkPathAgent_AIStateCrowdLife, M_bHasEquippedAgentWithWeapon) == 0x000081, "Member 'UBFGNetworkPathAgent_AIStateCrowdLife::M_bHasEquippedAgentWithWeapon' has a wrong offset!");
static_assert(offsetof(UBFGNetworkPathAgent_AIStateCrowdLife, M_pPlayCrowdLifeAnimObject) == 0x000088, "Member 'UBFGNetworkPathAgent_AIStateCrowdLife::M_pPlayCrowdLifeAnimObject' has a wrong offset!");
static_assert(offsetof(UBFGNetworkPathAgent_AIStateCrowdLife, M_vAgentLastLocation) == 0x000090, "Member 'UBFGNetworkPathAgent_AIStateCrowdLife::M_vAgentLastLocation' has a wrong offset!");

// Class BFGCore.BFGTaskNode_SetWeaponState
// 0x0038 (0x00B0 - 0x0078)
class UBFGTaskNode_SetWeaponState final : public UBFGBTBaseTaskNode
{
public:
	bool                                          M_bAiming;                                         // 0x0078(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_79[0x3];                                       // 0x0079(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         M_fStopAimingDelay;                                // 0x007C(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         M_fTimeout;                                        // 0x0080(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_84[0x4];                                       // 0x0084(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	struct FBlackboardKeySelector                 M_BBKeyAttackTarget;                               // 0x0088(0x0028)(Edit, BlueprintVisible, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"BFGTaskNode_SetWeaponState">();
	}
	static class UBFGTaskNode_SetWeaponState* GetDefaultObj()
	{
		return GetDefaultObjImpl<UBFGTaskNode_SetWeaponState>();
	}
};
static_assert(alignof(UBFGTaskNode_SetWeaponState) == 0x000008, "Wrong alignment on UBFGTaskNode_SetWeaponState");
static_assert(sizeof(UBFGTaskNode_SetWeaponState) == 0x0000B0, "Wrong size on UBFGTaskNode_SetWeaponState");
static_assert(offsetof(UBFGTaskNode_SetWeaponState, M_bAiming) == 0x000078, "Member 'UBFGTaskNode_SetWeaponState::M_bAiming' has a wrong offset!");
static_assert(offsetof(UBFGTaskNode_SetWeaponState, M_fStopAimingDelay) == 0x00007C, "Member 'UBFGTaskNode_SetWeaponState::M_fStopAimingDelay' has a wrong offset!");
static_assert(offsetof(UBFGTaskNode_SetWeaponState, M_fTimeout) == 0x000080, "Member 'UBFGTaskNode_SetWeaponState::M_fTimeout' has a wrong offset!");
static_assert(offsetof(UBFGTaskNode_SetWeaponState, M_BBKeyAttackTarget) == 0x000088, "Member 'UBFGTaskNode_SetWeaponState::M_BBKeyAttackTarget' has a wrong offset!");

// Class BFGCore.BFGEventTrigger_AITaskFinished
// 0x0018 (0x0058 - 0x0040)
class UBFGEventTrigger_AITaskFinished final : public UBFGEventTrigger
{
public:
	TWeakObjectPtr<class UBFG_AITask>             M_pTask;                                           // 0x0040(0x0008)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_48[0x10];                                      // 0x0048(0x0010)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void OnFinishedTask(class APawn* _pPawn, class AController* _pController, class UBFG_AITask* _pTask);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"BFGEventTrigger_AITaskFinished">();
	}
	static class UBFGEventTrigger_AITaskFinished* GetDefaultObj()
	{
		return GetDefaultObjImpl<UBFGEventTrigger_AITaskFinished>();
	}
};
static_assert(alignof(UBFGEventTrigger_AITaskFinished) == 0x000008, "Wrong alignment on UBFGEventTrigger_AITaskFinished");
static_assert(sizeof(UBFGEventTrigger_AITaskFinished) == 0x000058, "Wrong size on UBFGEventTrigger_AITaskFinished");
static_assert(offsetof(UBFGEventTrigger_AITaskFinished, M_pTask) == 0x000040, "Member 'UBFGEventTrigger_AITaskFinished::M_pTask' has a wrong offset!");

// Class BFGCore.BFGNPCCharacterEnemy_Turret
// 0x0020 (0x0C00 - 0x0BE0)
class ABFGNPCCharacterEnemy_Turret : public ABFGNPCCharacterEnemy
{
public:
	bool                                          M_bCanShootAtCrypto;                               // 0x0BD8(0x0001)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          M_bCanShootAtUFO;                                  // 0x0BD9(0x0001)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          M_bIgnoresWalkingCrypto;                           // 0x0BDA(0x0001)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_BDB[0x1];                                      // 0x0BDB(0x0001)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         M_fCombatParticipantRqadius;                       // 0x0BDC(0x0004)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FGameplayTagContainer                  M_aDisabledByTags;                                 // 0x0BE0(0x0020)(Edit, BlueprintVisible, DisableEditOnInstance, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"BFGNPCCharacterEnemy_Turret">();
	}
	static class ABFGNPCCharacterEnemy_Turret* GetDefaultObj()
	{
		return GetDefaultObjImpl<ABFGNPCCharacterEnemy_Turret>();
	}
};
static_assert(alignof(ABFGNPCCharacterEnemy_Turret) == 0x000010, "Wrong alignment on ABFGNPCCharacterEnemy_Turret");
static_assert(sizeof(ABFGNPCCharacterEnemy_Turret) == 0x000C00, "Wrong size on ABFGNPCCharacterEnemy_Turret");
static_assert(offsetof(ABFGNPCCharacterEnemy_Turret, M_bCanShootAtCrypto) == 0x000BD8, "Member 'ABFGNPCCharacterEnemy_Turret::M_bCanShootAtCrypto' has a wrong offset!");
static_assert(offsetof(ABFGNPCCharacterEnemy_Turret, M_bCanShootAtUFO) == 0x000BD9, "Member 'ABFGNPCCharacterEnemy_Turret::M_bCanShootAtUFO' has a wrong offset!");
static_assert(offsetof(ABFGNPCCharacterEnemy_Turret, M_bIgnoresWalkingCrypto) == 0x000BDA, "Member 'ABFGNPCCharacterEnemy_Turret::M_bIgnoresWalkingCrypto' has a wrong offset!");
static_assert(offsetof(ABFGNPCCharacterEnemy_Turret, M_fCombatParticipantRqadius) == 0x000BDC, "Member 'ABFGNPCCharacterEnemy_Turret::M_fCombatParticipantRqadius' has a wrong offset!");
static_assert(offsetof(ABFGNPCCharacterEnemy_Turret, M_aDisabledByTags) == 0x000BE0, "Member 'ABFGNPCCharacterEnemy_Turret::M_aDisabledByTags' has a wrong offset!");

// Class BFGCore.BFGNPCCharacterEnemy_Turret_Roboprez
// 0x0010 (0x0C10 - 0x0C00)
class ABFGNPCCharacterEnemy_Turret_Roboprez final : public ABFGNPCCharacterEnemy_Turret
{
public:
	int32                                         M_iActivePhase;                                    // 0x0C00(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         M_fAwakenCountdown;                                // 0x0C04(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_C08[0x8];                                      // 0x0C08(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void Awaken();
	void OnAwaken();
	void OnBecomeDormant();
	void StartCountdownIfPhaseMatches(int32 M_iPhase);
	void StartCountdownToAwaken();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"BFGNPCCharacterEnemy_Turret_Roboprez">();
	}
	static class ABFGNPCCharacterEnemy_Turret_Roboprez* GetDefaultObj()
	{
		return GetDefaultObjImpl<ABFGNPCCharacterEnemy_Turret_Roboprez>();
	}
};
static_assert(alignof(ABFGNPCCharacterEnemy_Turret_Roboprez) == 0x000010, "Wrong alignment on ABFGNPCCharacterEnemy_Turret_Roboprez");
static_assert(sizeof(ABFGNPCCharacterEnemy_Turret_Roboprez) == 0x000C10, "Wrong size on ABFGNPCCharacterEnemy_Turret_Roboprez");
static_assert(offsetof(ABFGNPCCharacterEnemy_Turret_Roboprez, M_iActivePhase) == 0x000C00, "Member 'ABFGNPCCharacterEnemy_Turret_Roboprez::M_iActivePhase' has a wrong offset!");
static_assert(offsetof(ABFGNPCCharacterEnemy_Turret_Roboprez, M_fAwakenCountdown) == 0x000C04, "Member 'ABFGNPCCharacterEnemy_Turret_Roboprez::M_fAwakenCountdown' has a wrong offset!");

// Class BFGCore.BFGPlayerCameraManager
// 0x0000 (0x2710 - 0x2710)
class ABFGPlayerCameraManager : public APlayerCameraManager
{
public:
	class UBFGPhotographySystem*                  M_pPhotographySystem;                              // 0x2708(0x0008)(ExportObject, ZeroConstructor, Transient, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"BFGPlayerCameraManager">();
	}
	static class ABFGPlayerCameraManager* GetDefaultObj()
	{
		return GetDefaultObjImpl<ABFGPlayerCameraManager>();
	}
};
static_assert(alignof(ABFGPlayerCameraManager) == 0x000010, "Wrong alignment on ABFGPlayerCameraManager");
static_assert(sizeof(ABFGPlayerCameraManager) == 0x002710, "Wrong size on ABFGPlayerCameraManager");
static_assert(offsetof(ABFGPlayerCameraManager, M_pPhotographySystem) == 0x002708, "Member 'ABFGPlayerCameraManager::M_pPhotographySystem' has a wrong offset!");

// Class BFGCore.BFG_AISettings
// 0x0260 (0x0298 - 0x0038)
class UBFG_AISettings final : public UDeveloperSettings
{
public:
	class FName                                   M_strBBKey_AITaskActor;                            // 0x0038(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Config, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   M_strBBKey_AITask;                                 // 0x0040(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Config, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FBFG_AITaskConfig                      M_escortConfig;                                    // 0x0048(0x0030)(Edit, BlueprintVisible, BlueprintReadOnly, Config, NativeAccessSpecifierPublic)
	class FName                                   M_strBBKey_CrowdFlowPathTargetLocationActor;       // 0x0078(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Config, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   M_strBBKey_CrowdFlowAgent;                         // 0x0080(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Config, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   M_strBBKey_AutoAssignToTrafficAndCrowdFlow;        // 0x0088(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Config, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   M_strBBKey_IsCrowdFlowControlled;                  // 0x0090(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Config, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   M_strBBKey_IsMoveToNavigationActive;               // 0x0098(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Config, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   M_strBBKey_CrowdLifeStation;                       // 0x00A0(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Config, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   M_strBBKey_MoveToLocationThroughCrowdSystem;       // 0x00A8(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Config, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   M_strBBKey_HasMoveToLocationThroughCrowdSystem;    // 0x00B0(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Config, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   M_strBBKey_IsInCarInCarInteract;                   // 0x00B8(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Config, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TSoftObjectPtr<class UDataTable>              M_pNPCVariables;                                   // 0x00C0(0x0028)(Edit, BlueprintVisible, Config, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         M_fReloadLogBase;                                  // 0x00E8(0x0004)(Edit, BlueprintVisible, ZeroConstructor, Config, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         M_fReloadTimeScalingFactor;                        // 0x00EC(0x0004)(Edit, BlueprintVisible, ZeroConstructor, Config, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         M_fAmmoShotLogBase;                                // 0x00F0(0x0004)(Edit, BlueprintVisible, ZeroConstructor, Config, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         M_fAmmoShotTimeScalingFactor;                      // 0x00F4(0x0004)(Edit, BlueprintVisible, ZeroConstructor, Config, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          M_bImportanceScalingEnabled;                       // 0x00F8(0x0001)(Edit, BlueprintVisible, ZeroConstructor, Config, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_F9[0x3];                                       // 0x00F9(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         M_fImportanceSignalWeight_Visibility;              // 0x00FC(0x0004)(Edit, BlueprintVisible, ZeroConstructor, Config, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         M_fImportanceSignalWeight_Uniqueness;              // 0x0100(0x0004)(Edit, BlueprintVisible, ZeroConstructor, Config, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         M_fImportanceSignalWeight_Fireline;                // 0x0104(0x0004)(Edit, BlueprintVisible, ZeroConstructor, Config, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         M_fImportanceSignalWeight_Distance;                // 0x0108(0x0004)(Edit, BlueprintVisible, ZeroConstructor, Config, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         M_fImportanceScale_Min;                            // 0x010C(0x0004)(Edit, BlueprintVisible, ZeroConstructor, Config, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         M_fImportanceScale_Max;                            // 0x0110(0x0004)(Edit, BlueprintVisible, ZeroConstructor, Config, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         M_fRestrictedAreaGracePeriod;                      // 0x0114(0x0004)(Edit, BlueprintVisible, ZeroConstructor, Config, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         M_fRestrictedAreaConsequenceDelayInside;           // 0x0118(0x0004)(Edit, BlueprintVisible, ZeroConstructor, Config, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         M_fRestrictedAreaConsequenceDelayDetected;         // 0x011C(0x0004)(Edit, BlueprintVisible, ZeroConstructor, Config, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TMap<EBFGGlobalCooldown, struct FBFG_AISettings_GlobalCooldown> M_aGlobalCooldowns;                                // 0x0120(0x0050)(Edit, BlueprintVisible, ZeroConstructor, Config, NativeAccessSpecifierPublic)
	TSoftObjectPtr<class UBehaviorTree>           M_spEnemyVehicleBehaviourTree;                     // 0x0170(0x0028)(Edit, BlueprintVisible, Config, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TSoftObjectPtr<class UBFGAITagQueries>        M_pTagQueries;                                     // 0x0198(0x0028)(Edit, BlueprintVisible, Config, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TSoftObjectPtr<class UDataTable>              M_pEnemyTagsTable;                                 // 0x01C0(0x0028)(Edit, DisableEditOnInstance, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         AlertSystemSpawnSoftCap;                           // 0x01E8(0x0004)(Edit, BlueprintVisible, ZeroConstructor, Config, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         AlertSystemSpawnHardCap;                           // 0x01EC(0x0004)(Edit, BlueprintVisible, ZeroConstructor, Config, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TMap<EBFGVehiclePassenger_AnimationSetupID, struct FBFGVehiclePassenger_AnimationSetup> M_aPassengerAnimationSetups;                       // 0x01F0(0x0050)(Edit, BlueprintVisible, ZeroConstructor, Config, NativeAccessSpecifierPublic)
	struct FBFGVehicleSpeed_Settings              M_civilianCarSpeed;                                // 0x0240(0x0008)(Edit, BlueprintVisible, Config, NoDestructor, NativeAccessSpecifierPublic)
	struct FBFGVehicleSpeed_Settings              M_enemyCarSpeed;                                   // 0x0248(0x0008)(Edit, BlueprintVisible, Config, NoDestructor, NativeAccessSpecifierPublic)
	struct FBFGVehicleSpeed_Settings              M_enemyTruckSpeed;                                 // 0x0250(0x0008)(Edit, BlueprintVisible, Config, NoDestructor, NativeAccessSpecifierPublic)
	TSubclassOf<class UNavigationQueryFilter>     M_pTargetTrackerNavQueryFilterClass;               // 0x0258(0x0008)(Edit, ZeroConstructor, Config, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TArray<TSoftObjectPtr<class UDataTable>>      M_apInteractAnimationTables;                       // 0x0260(0x0010)(Edit, BlueprintVisible, ZeroConstructor, Config, UObjectWrapper, NativeAccessSpecifierPublic)
	TSoftClassPtr<class UClass>                   M_spDamageTypeClass_KillPassengersWhilePKed;       // 0x0270(0x0028)(Edit, Config, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"BFG_AISettings">();
	}
	static class UBFG_AISettings* GetDefaultObj()
	{
		return GetDefaultObjImpl<UBFG_AISettings>();
	}
};
static_assert(alignof(UBFG_AISettings) == 0x000008, "Wrong alignment on UBFG_AISettings");
static_assert(sizeof(UBFG_AISettings) == 0x000298, "Wrong size on UBFG_AISettings");
static_assert(offsetof(UBFG_AISettings, M_strBBKey_AITaskActor) == 0x000038, "Member 'UBFG_AISettings::M_strBBKey_AITaskActor' has a wrong offset!");
static_assert(offsetof(UBFG_AISettings, M_strBBKey_AITask) == 0x000040, "Member 'UBFG_AISettings::M_strBBKey_AITask' has a wrong offset!");
static_assert(offsetof(UBFG_AISettings, M_escortConfig) == 0x000048, "Member 'UBFG_AISettings::M_escortConfig' has a wrong offset!");
static_assert(offsetof(UBFG_AISettings, M_strBBKey_CrowdFlowPathTargetLocationActor) == 0x000078, "Member 'UBFG_AISettings::M_strBBKey_CrowdFlowPathTargetLocationActor' has a wrong offset!");
static_assert(offsetof(UBFG_AISettings, M_strBBKey_CrowdFlowAgent) == 0x000080, "Member 'UBFG_AISettings::M_strBBKey_CrowdFlowAgent' has a wrong offset!");
static_assert(offsetof(UBFG_AISettings, M_strBBKey_AutoAssignToTrafficAndCrowdFlow) == 0x000088, "Member 'UBFG_AISettings::M_strBBKey_AutoAssignToTrafficAndCrowdFlow' has a wrong offset!");
static_assert(offsetof(UBFG_AISettings, M_strBBKey_IsCrowdFlowControlled) == 0x000090, "Member 'UBFG_AISettings::M_strBBKey_IsCrowdFlowControlled' has a wrong offset!");
static_assert(offsetof(UBFG_AISettings, M_strBBKey_IsMoveToNavigationActive) == 0x000098, "Member 'UBFG_AISettings::M_strBBKey_IsMoveToNavigationActive' has a wrong offset!");
static_assert(offsetof(UBFG_AISettings, M_strBBKey_CrowdLifeStation) == 0x0000A0, "Member 'UBFG_AISettings::M_strBBKey_CrowdLifeStation' has a wrong offset!");
static_assert(offsetof(UBFG_AISettings, M_strBBKey_MoveToLocationThroughCrowdSystem) == 0x0000A8, "Member 'UBFG_AISettings::M_strBBKey_MoveToLocationThroughCrowdSystem' has a wrong offset!");
static_assert(offsetof(UBFG_AISettings, M_strBBKey_HasMoveToLocationThroughCrowdSystem) == 0x0000B0, "Member 'UBFG_AISettings::M_strBBKey_HasMoveToLocationThroughCrowdSystem' has a wrong offset!");
static_assert(offsetof(UBFG_AISettings, M_strBBKey_IsInCarInCarInteract) == 0x0000B8, "Member 'UBFG_AISettings::M_strBBKey_IsInCarInCarInteract' has a wrong offset!");
static_assert(offsetof(UBFG_AISettings, M_pNPCVariables) == 0x0000C0, "Member 'UBFG_AISettings::M_pNPCVariables' has a wrong offset!");
static_assert(offsetof(UBFG_AISettings, M_fReloadLogBase) == 0x0000E8, "Member 'UBFG_AISettings::M_fReloadLogBase' has a wrong offset!");
static_assert(offsetof(UBFG_AISettings, M_fReloadTimeScalingFactor) == 0x0000EC, "Member 'UBFG_AISettings::M_fReloadTimeScalingFactor' has a wrong offset!");
static_assert(offsetof(UBFG_AISettings, M_fAmmoShotLogBase) == 0x0000F0, "Member 'UBFG_AISettings::M_fAmmoShotLogBase' has a wrong offset!");
static_assert(offsetof(UBFG_AISettings, M_fAmmoShotTimeScalingFactor) == 0x0000F4, "Member 'UBFG_AISettings::M_fAmmoShotTimeScalingFactor' has a wrong offset!");
static_assert(offsetof(UBFG_AISettings, M_bImportanceScalingEnabled) == 0x0000F8, "Member 'UBFG_AISettings::M_bImportanceScalingEnabled' has a wrong offset!");
static_assert(offsetof(UBFG_AISettings, M_fImportanceSignalWeight_Visibility) == 0x0000FC, "Member 'UBFG_AISettings::M_fImportanceSignalWeight_Visibility' has a wrong offset!");
static_assert(offsetof(UBFG_AISettings, M_fImportanceSignalWeight_Uniqueness) == 0x000100, "Member 'UBFG_AISettings::M_fImportanceSignalWeight_Uniqueness' has a wrong offset!");
static_assert(offsetof(UBFG_AISettings, M_fImportanceSignalWeight_Fireline) == 0x000104, "Member 'UBFG_AISettings::M_fImportanceSignalWeight_Fireline' has a wrong offset!");
static_assert(offsetof(UBFG_AISettings, M_fImportanceSignalWeight_Distance) == 0x000108, "Member 'UBFG_AISettings::M_fImportanceSignalWeight_Distance' has a wrong offset!");
static_assert(offsetof(UBFG_AISettings, M_fImportanceScale_Min) == 0x00010C, "Member 'UBFG_AISettings::M_fImportanceScale_Min' has a wrong offset!");
static_assert(offsetof(UBFG_AISettings, M_fImportanceScale_Max) == 0x000110, "Member 'UBFG_AISettings::M_fImportanceScale_Max' has a wrong offset!");
static_assert(offsetof(UBFG_AISettings, M_fRestrictedAreaGracePeriod) == 0x000114, "Member 'UBFG_AISettings::M_fRestrictedAreaGracePeriod' has a wrong offset!");
static_assert(offsetof(UBFG_AISettings, M_fRestrictedAreaConsequenceDelayInside) == 0x000118, "Member 'UBFG_AISettings::M_fRestrictedAreaConsequenceDelayInside' has a wrong offset!");
static_assert(offsetof(UBFG_AISettings, M_fRestrictedAreaConsequenceDelayDetected) == 0x00011C, "Member 'UBFG_AISettings::M_fRestrictedAreaConsequenceDelayDetected' has a wrong offset!");
static_assert(offsetof(UBFG_AISettings, M_aGlobalCooldowns) == 0x000120, "Member 'UBFG_AISettings::M_aGlobalCooldowns' has a wrong offset!");
static_assert(offsetof(UBFG_AISettings, M_spEnemyVehicleBehaviourTree) == 0x000170, "Member 'UBFG_AISettings::M_spEnemyVehicleBehaviourTree' has a wrong offset!");
static_assert(offsetof(UBFG_AISettings, M_pTagQueries) == 0x000198, "Member 'UBFG_AISettings::M_pTagQueries' has a wrong offset!");
static_assert(offsetof(UBFG_AISettings, M_pEnemyTagsTable) == 0x0001C0, "Member 'UBFG_AISettings::M_pEnemyTagsTable' has a wrong offset!");
static_assert(offsetof(UBFG_AISettings, AlertSystemSpawnSoftCap) == 0x0001E8, "Member 'UBFG_AISettings::AlertSystemSpawnSoftCap' has a wrong offset!");
static_assert(offsetof(UBFG_AISettings, AlertSystemSpawnHardCap) == 0x0001EC, "Member 'UBFG_AISettings::AlertSystemSpawnHardCap' has a wrong offset!");
static_assert(offsetof(UBFG_AISettings, M_aPassengerAnimationSetups) == 0x0001F0, "Member 'UBFG_AISettings::M_aPassengerAnimationSetups' has a wrong offset!");
static_assert(offsetof(UBFG_AISettings, M_civilianCarSpeed) == 0x000240, "Member 'UBFG_AISettings::M_civilianCarSpeed' has a wrong offset!");
static_assert(offsetof(UBFG_AISettings, M_enemyCarSpeed) == 0x000248, "Member 'UBFG_AISettings::M_enemyCarSpeed' has a wrong offset!");
static_assert(offsetof(UBFG_AISettings, M_enemyTruckSpeed) == 0x000250, "Member 'UBFG_AISettings::M_enemyTruckSpeed' has a wrong offset!");
static_assert(offsetof(UBFG_AISettings, M_pTargetTrackerNavQueryFilterClass) == 0x000258, "Member 'UBFG_AISettings::M_pTargetTrackerNavQueryFilterClass' has a wrong offset!");
static_assert(offsetof(UBFG_AISettings, M_apInteractAnimationTables) == 0x000260, "Member 'UBFG_AISettings::M_apInteractAnimationTables' has a wrong offset!");
static_assert(offsetof(UBFG_AISettings, M_spDamageTypeClass_KillPassengersWhilePKed) == 0x000270, "Member 'UBFG_AISettings::M_spDamageTypeClass_KillPassengersWhilePKed' has a wrong offset!");

// Class BFGCore.BFGTaskNode_Action_MetaPattern
// 0x0038 (0x00D8 - 0x00A0)
class UBFGTaskNode_Action_MetaPattern : public UBFGTaskNode_BossBase
{
public:
	EBFGMetaPatternCategory                       M_eMetaPatternCategory;                            // 0x00A0(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_A1[0x7];                                       // 0x00A1(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	struct FMetaPattern                           M_oMetaPattern;                                    // 0x00A8(0x0028)(NativeAccessSpecifierPublic)
	uint8                                         Pad_D0[0x8];                                       // 0x00D0(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void OnShootingComplete();
	void OnShootingStarted();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"BFGTaskNode_Action_MetaPattern">();
	}
	static class UBFGTaskNode_Action_MetaPattern* GetDefaultObj()
	{
		return GetDefaultObjImpl<UBFGTaskNode_Action_MetaPattern>();
	}
};
static_assert(alignof(UBFGTaskNode_Action_MetaPattern) == 0x000008, "Wrong alignment on UBFGTaskNode_Action_MetaPattern");
static_assert(sizeof(UBFGTaskNode_Action_MetaPattern) == 0x0000D8, "Wrong size on UBFGTaskNode_Action_MetaPattern");
static_assert(offsetof(UBFGTaskNode_Action_MetaPattern, M_eMetaPatternCategory) == 0x0000A0, "Member 'UBFGTaskNode_Action_MetaPattern::M_eMetaPatternCategory' has a wrong offset!");
static_assert(offsetof(UBFGTaskNode_Action_MetaPattern, M_oMetaPattern) == 0x0000A8, "Member 'UBFGTaskNode_Action_MetaPattern::M_oMetaPattern' has a wrong offset!");

// Class BFGCore.BFGTaskNode_Action_MetaPattern_Specific
// 0x0008 (0x00E0 - 0x00D8)
class UBFGTaskNode_Action_MetaPattern_Specific final : public UBFGTaskNode_Action_MetaPattern
{
public:
	class UDataTable*                             M_pMetaPatternData;                                // 0x00D8(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"BFGTaskNode_Action_MetaPattern_Specific">();
	}
	static class UBFGTaskNode_Action_MetaPattern_Specific* GetDefaultObj()
	{
		return GetDefaultObjImpl<UBFGTaskNode_Action_MetaPattern_Specific>();
	}
};
static_assert(alignof(UBFGTaskNode_Action_MetaPattern_Specific) == 0x000008, "Wrong alignment on UBFGTaskNode_Action_MetaPattern_Specific");
static_assert(sizeof(UBFGTaskNode_Action_MetaPattern_Specific) == 0x0000E0, "Wrong size on UBFGTaskNode_Action_MetaPattern_Specific");
static_assert(offsetof(UBFGTaskNode_Action_MetaPattern_Specific, M_pMetaPatternData) == 0x0000D8, "Member 'UBFGTaskNode_Action_MetaPattern_Specific::M_pMetaPatternData' has a wrong offset!");

// Class BFGCore.BFG_AITask
// 0x0010 (0x0038 - 0x0028)
class UBFG_AITask : public UObject
{
public:
	class UBehaviorTree*                          M_pBehaviourTree;                                  // 0x0028(0x0008)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	struct FGameplayTag                           M_defaultBTTag;                                    // 0x0030(0x0008)(Transient, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"BFG_AITask">();
	}
	static class UBFG_AITask* GetDefaultObj()
	{
		return GetDefaultObjImpl<UBFG_AITask>();
	}
};
static_assert(alignof(UBFG_AITask) == 0x000008, "Wrong alignment on UBFG_AITask");
static_assert(sizeof(UBFG_AITask) == 0x000038, "Wrong size on UBFG_AITask");
static_assert(offsetof(UBFG_AITask, M_pBehaviourTree) == 0x000028, "Member 'UBFG_AITask::M_pBehaviourTree' has a wrong offset!");
static_assert(offsetof(UBFG_AITask, M_defaultBTTag) == 0x000030, "Member 'UBFG_AITask::M_defaultBTTag' has a wrong offset!");

// Class BFGCore.BFG_AITask_Escort
// 0x0050 (0x0088 - 0x0038)
class UBFG_AITask_Escort final : public UBFG_AITask
{
public:
	bool                                          M_bEscortComplete;                                 // 0x0038(0x0001)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_39[0x27];                                      // 0x0039(0x0027)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         M_fMaxRange;                                       // 0x0060(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         M_fMinRange;                                       // 0x0064(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          M_bUseTrafficSystem;                               // 0x0068(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          M_bBehaviourStateLocked;                           // 0x0069(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	EBFGNetworkPathAgentEnterExitRule             M_eEnterExitTrafficSystemRule;                     // 0x006A(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	EBFGNetworkPathAgentPriorityLevel             M_eAgentPriority;                                  // 0x006B(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	EBFGNetworkPathAgentPriorityLevel             M_eSavedPrority;                                   // 0x006C(0x0001)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_6D[0x3];                                       // 0x006D(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	class UBFGNetworkPathAgent*                   M_pAgent;                                          // 0x0070(0x0008)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          M_bStopAtEnd;                                      // 0x0078(0x0001)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          M_bHasBehaviourStateLock;                          // 0x0079(0x0001)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_7A[0x2];                                       // 0x007A(0x0002)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         M_fMaxSpeed;                                       // 0x007C(0x0004)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          M_bUsePatrolPathExtension;                         // 0x0080(0x0001)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	EBFGNPCCharacter_MoveSpeed                    M_moveSpeed;                                       // 0x0081(0x0001)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          M_bTrafficSystemExitHandled;                       // 0x0082(0x0001)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_83[0x5];                                       // 0x0083(0x0005)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"BFG_AITask_Escort">();
	}
	static class UBFG_AITask_Escort* GetDefaultObj()
	{
		return GetDefaultObjImpl<UBFG_AITask_Escort>();
	}
};
static_assert(alignof(UBFG_AITask_Escort) == 0x000008, "Wrong alignment on UBFG_AITask_Escort");
static_assert(sizeof(UBFG_AITask_Escort) == 0x000088, "Wrong size on UBFG_AITask_Escort");
static_assert(offsetof(UBFG_AITask_Escort, M_bEscortComplete) == 0x000038, "Member 'UBFG_AITask_Escort::M_bEscortComplete' has a wrong offset!");
static_assert(offsetof(UBFG_AITask_Escort, M_fMaxRange) == 0x000060, "Member 'UBFG_AITask_Escort::M_fMaxRange' has a wrong offset!");
static_assert(offsetof(UBFG_AITask_Escort, M_fMinRange) == 0x000064, "Member 'UBFG_AITask_Escort::M_fMinRange' has a wrong offset!");
static_assert(offsetof(UBFG_AITask_Escort, M_bUseTrafficSystem) == 0x000068, "Member 'UBFG_AITask_Escort::M_bUseTrafficSystem' has a wrong offset!");
static_assert(offsetof(UBFG_AITask_Escort, M_bBehaviourStateLocked) == 0x000069, "Member 'UBFG_AITask_Escort::M_bBehaviourStateLocked' has a wrong offset!");
static_assert(offsetof(UBFG_AITask_Escort, M_eEnterExitTrafficSystemRule) == 0x00006A, "Member 'UBFG_AITask_Escort::M_eEnterExitTrafficSystemRule' has a wrong offset!");
static_assert(offsetof(UBFG_AITask_Escort, M_eAgentPriority) == 0x00006B, "Member 'UBFG_AITask_Escort::M_eAgentPriority' has a wrong offset!");
static_assert(offsetof(UBFG_AITask_Escort, M_eSavedPrority) == 0x00006C, "Member 'UBFG_AITask_Escort::M_eSavedPrority' has a wrong offset!");
static_assert(offsetof(UBFG_AITask_Escort, M_pAgent) == 0x000070, "Member 'UBFG_AITask_Escort::M_pAgent' has a wrong offset!");
static_assert(offsetof(UBFG_AITask_Escort, M_bStopAtEnd) == 0x000078, "Member 'UBFG_AITask_Escort::M_bStopAtEnd' has a wrong offset!");
static_assert(offsetof(UBFG_AITask_Escort, M_bHasBehaviourStateLock) == 0x000079, "Member 'UBFG_AITask_Escort::M_bHasBehaviourStateLock' has a wrong offset!");
static_assert(offsetof(UBFG_AITask_Escort, M_fMaxSpeed) == 0x00007C, "Member 'UBFG_AITask_Escort::M_fMaxSpeed' has a wrong offset!");
static_assert(offsetof(UBFG_AITask_Escort, M_bUsePatrolPathExtension) == 0x000080, "Member 'UBFG_AITask_Escort::M_bUsePatrolPathExtension' has a wrong offset!");
static_assert(offsetof(UBFG_AITask_Escort, M_moveSpeed) == 0x000081, "Member 'UBFG_AITask_Escort::M_moveSpeed' has a wrong offset!");
static_assert(offsetof(UBFG_AITask_Escort, M_bTrafficSystemExitHandled) == 0x000082, "Member 'UBFG_AITask_Escort::M_bTrafficSystemExitHandled' has a wrong offset!");

// Class BFGCore.BFGNetworkPathAgent_NavModeBase
// 0x0018 (0x0040 - 0x0028)
class UBFGNetworkPathAgent_NavModeBase : public UObject
{
public:
	class UBFGNetworkPathAgent_Navigation*        M_pNavigation;                                     // 0x0028(0x0008)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UBFGNetworkPathAgent*                   M_pAgent;                                          // 0x0030(0x0008)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          M_bIsMoving;                                       // 0x0038(0x0001)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_39[0x7];                                       // 0x0039(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"BFGNetworkPathAgent_NavModeBase">();
	}
	static class UBFGNetworkPathAgent_NavModeBase* GetDefaultObj()
	{
		return GetDefaultObjImpl<UBFGNetworkPathAgent_NavModeBase>();
	}
};
static_assert(alignof(UBFGNetworkPathAgent_NavModeBase) == 0x000008, "Wrong alignment on UBFGNetworkPathAgent_NavModeBase");
static_assert(sizeof(UBFGNetworkPathAgent_NavModeBase) == 0x000040, "Wrong size on UBFGNetworkPathAgent_NavModeBase");
static_assert(offsetof(UBFGNetworkPathAgent_NavModeBase, M_pNavigation) == 0x000028, "Member 'UBFGNetworkPathAgent_NavModeBase::M_pNavigation' has a wrong offset!");
static_assert(offsetof(UBFGNetworkPathAgent_NavModeBase, M_pAgent) == 0x000030, "Member 'UBFGNetworkPathAgent_NavModeBase::M_pAgent' has a wrong offset!");
static_assert(offsetof(UBFGNetworkPathAgent_NavModeBase, M_bIsMoving) == 0x000038, "Member 'UBFGNetworkPathAgent_NavModeBase::M_bIsMoving' has a wrong offset!");

// Class BFGCore.BFGNetworkPathAgent_NavModeTargetLocation
// 0x0010 (0x0050 - 0x0040)
class UBFGNetworkPathAgent_NavModeTargetLocation final : public UBFGNetworkPathAgent_NavModeBase
{
public:
	struct FVector                                M_vNavTargetLocation;                              // 0x0040(0x000C)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_4C[0x4];                                       // 0x004C(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"BFGNetworkPathAgent_NavModeTargetLocation">();
	}
	static class UBFGNetworkPathAgent_NavModeTargetLocation* GetDefaultObj()
	{
		return GetDefaultObjImpl<UBFGNetworkPathAgent_NavModeTargetLocation>();
	}
};
static_assert(alignof(UBFGNetworkPathAgent_NavModeTargetLocation) == 0x000008, "Wrong alignment on UBFGNetworkPathAgent_NavModeTargetLocation");
static_assert(sizeof(UBFGNetworkPathAgent_NavModeTargetLocation) == 0x000050, "Wrong size on UBFGNetworkPathAgent_NavModeTargetLocation");
static_assert(offsetof(UBFGNetworkPathAgent_NavModeTargetLocation, M_vNavTargetLocation) == 0x000040, "Member 'UBFGNetworkPathAgent_NavModeTargetLocation::M_vNavTargetLocation' has a wrong offset!");

// Class BFGCore.BFGEnvQueryTest_TargetCachableLocation
// 0x0068 (0x0228 - 0x01C0)
class UBFGEnvQueryTest_TargetCachableLocation final : public UEnvQueryTest
{
public:
	TSubclassOf<class UEnvQueryContext>           M_pTarget;                                         // 0x01C0(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          M_bIsPreprojected;                                 // 0x01C8(0x0001)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1C9[0x3];                                      // 0x01C9(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	struct FBFGTargetTracker_QueryParams          M_queryParams;                                     // 0x01CC(0x0010)(Edit, DisableEditOnInstance, NoDestructor, NativeAccessSpecifierPublic)
	struct FBFGTargetCachableLocationConstScore   M_scoreQuerySucceeded;                             // 0x01DC(0x0008)(Edit, DisableEditOnInstance, NoDestructor, NativeAccessSpecifierPublic)
	struct FBFGTargetCachableLocationConstScore   M_scoreLOSToOrigin;                                // 0x01E4(0x0008)(Edit, DisableEditOnInstance, NoDestructor, NativeAccessSpecifierPublic)
	struct FBFGTargetCachableLocationConstScore   M_scoreLOSToLKP;                                   // 0x01EC(0x0008)(Edit, DisableEditOnInstance, NoDestructor, NativeAccessSpecifierPublic)
	struct FBFGTargetCachableLocationConstScore   M_scoreLOSToTarget;                                // 0x01F4(0x0008)(Edit, DisableEditOnInstance, NoDestructor, NativeAccessSpecifierPublic)
	struct FBFGTargetCachableLocationConstScore   M_scoreInViewFrustum;                              // 0x01FC(0x0008)(Edit, DisableEditOnInstance, NoDestructor, NativeAccessSpecifierPublic)
	struct FBFGTargetCachableLocationDistanceScore M_scoreDistanceToFireline;                         // 0x0204(0x0010)(Edit, DisableEditOnInstance, NoDestructor, NativeAccessSpecifierPublic)
	struct FBFGTargetCachableLocationDistanceScore M_scoreDistanceToParticipant;                      // 0x0214(0x0010)(Edit, DisableEditOnInstance, NoDestructor, NativeAccessSpecifierPublic)
	uint8                                         Pad_224[0x4];                                      // 0x0224(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"BFGEnvQueryTest_TargetCachableLocation">();
	}
	static class UBFGEnvQueryTest_TargetCachableLocation* GetDefaultObj()
	{
		return GetDefaultObjImpl<UBFGEnvQueryTest_TargetCachableLocation>();
	}
};
static_assert(alignof(UBFGEnvQueryTest_TargetCachableLocation) == 0x000008, "Wrong alignment on UBFGEnvQueryTest_TargetCachableLocation");
static_assert(sizeof(UBFGEnvQueryTest_TargetCachableLocation) == 0x000228, "Wrong size on UBFGEnvQueryTest_TargetCachableLocation");
static_assert(offsetof(UBFGEnvQueryTest_TargetCachableLocation, M_pTarget) == 0x0001C0, "Member 'UBFGEnvQueryTest_TargetCachableLocation::M_pTarget' has a wrong offset!");
static_assert(offsetof(UBFGEnvQueryTest_TargetCachableLocation, M_bIsPreprojected) == 0x0001C8, "Member 'UBFGEnvQueryTest_TargetCachableLocation::M_bIsPreprojected' has a wrong offset!");
static_assert(offsetof(UBFGEnvQueryTest_TargetCachableLocation, M_queryParams) == 0x0001CC, "Member 'UBFGEnvQueryTest_TargetCachableLocation::M_queryParams' has a wrong offset!");
static_assert(offsetof(UBFGEnvQueryTest_TargetCachableLocation, M_scoreQuerySucceeded) == 0x0001DC, "Member 'UBFGEnvQueryTest_TargetCachableLocation::M_scoreQuerySucceeded' has a wrong offset!");
static_assert(offsetof(UBFGEnvQueryTest_TargetCachableLocation, M_scoreLOSToOrigin) == 0x0001E4, "Member 'UBFGEnvQueryTest_TargetCachableLocation::M_scoreLOSToOrigin' has a wrong offset!");
static_assert(offsetof(UBFGEnvQueryTest_TargetCachableLocation, M_scoreLOSToLKP) == 0x0001EC, "Member 'UBFGEnvQueryTest_TargetCachableLocation::M_scoreLOSToLKP' has a wrong offset!");
static_assert(offsetof(UBFGEnvQueryTest_TargetCachableLocation, M_scoreLOSToTarget) == 0x0001F4, "Member 'UBFGEnvQueryTest_TargetCachableLocation::M_scoreLOSToTarget' has a wrong offset!");
static_assert(offsetof(UBFGEnvQueryTest_TargetCachableLocation, M_scoreInViewFrustum) == 0x0001FC, "Member 'UBFGEnvQueryTest_TargetCachableLocation::M_scoreInViewFrustum' has a wrong offset!");
static_assert(offsetof(UBFGEnvQueryTest_TargetCachableLocation, M_scoreDistanceToFireline) == 0x000204, "Member 'UBFGEnvQueryTest_TargetCachableLocation::M_scoreDistanceToFireline' has a wrong offset!");
static_assert(offsetof(UBFGEnvQueryTest_TargetCachableLocation, M_scoreDistanceToParticipant) == 0x000214, "Member 'UBFGEnvQueryTest_TargetCachableLocation::M_scoreDistanceToParticipant' has a wrong offset!");

// Class BFGCore.BFGMaterialUtils
// 0x0000 (0x0028 - 0x0028)
class UBFGMaterialUtils final : public UBlueprintFunctionLibrary
{
public:
	static class APostProcessVolume* GetCurrentPostProcessVolume(class UWorld* _pWorld);
	static void SetTextureParameterValueBySprite(class UMaterialInstanceDynamic* _pMaterialInstance, class FName _parameterName, class UPaperSprite* _pSprite);
	static void SetVectorParameterValueBySprite(class UMaterialInstanceDynamic* _pMaterialInstance, class FName _parameterName, class UPaperSprite* _pSprite);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"BFGMaterialUtils">();
	}
	static class UBFGMaterialUtils* GetDefaultObj()
	{
		return GetDefaultObjImpl<UBFGMaterialUtils>();
	}
};
static_assert(alignof(UBFGMaterialUtils) == 0x000008, "Wrong alignment on UBFGMaterialUtils");
static_assert(sizeof(UBFGMaterialUtils) == 0x000028, "Wrong size on UBFGMaterialUtils");

// Class BFGCore.BFGWidget_HUD
// 0x00B8 (0x02F8 - 0x0240)
class UBFGWidget_HUD : public UUserWidget
{
public:
	uint8                                         Pad_240[0x8];                                      // 0x0240(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	class ABFGGameState*                          M_pGameState;                                      // 0x0248(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TSet<EBFGHUDVisibilityState>                  M_aeHUDVisibilityStates;                           // 0x0250(0x0050)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Protected, NativeAccessSpecifierProtected)
	TSet<EBFGHUDVisibilityState>                  M_aeHUDVisibilityStatesRequired;                   // 0x02A0(0x0050)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Protected, NativeAccessSpecifierProtected)
	uint8                                         Pad_2F0[0x8];                                      // 0x02F0(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	class ABFGGameState* GetGameState();
	void ValidateData();

	class UBFGActorComponent_GameplayToHud* GetOwningGameplayToHud() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"BFGWidget_HUD">();
	}
	static class UBFGWidget_HUD* GetDefaultObj()
	{
		return GetDefaultObjImpl<UBFGWidget_HUD>();
	}
};
static_assert(alignof(UBFGWidget_HUD) == 0x000008, "Wrong alignment on UBFGWidget_HUD");
static_assert(sizeof(UBFGWidget_HUD) == 0x0002F8, "Wrong size on UBFGWidget_HUD");
static_assert(offsetof(UBFGWidget_HUD, M_pGameState) == 0x000248, "Member 'UBFGWidget_HUD::M_pGameState' has a wrong offset!");
static_assert(offsetof(UBFGWidget_HUD, M_aeHUDVisibilityStates) == 0x000250, "Member 'UBFGWidget_HUD::M_aeHUDVisibilityStates' has a wrong offset!");
static_assert(offsetof(UBFGWidget_HUD, M_aeHUDVisibilityStatesRequired) == 0x0002A0, "Member 'UBFGWidget_HUD::M_aeHUDVisibilityStatesRequired' has a wrong offset!");

// Class BFGCore.BFGWidget_HUD_Subtitle
// 0x0028 (0x0320 - 0x02F8)
class UBFGWidget_HUD_Subtitle : public UBFGWidget_HUD
{
public:
	uint8                                         Pad_2F8[0x8];                                      // 0x02F8(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	class FText                                   M_strcurrentMessage;                               // 0x0300(0x0018)(Edit, BlueprintVisible, BlueprintReadOnly, DisableEditOnInstance, NativeAccessSpecifierPublic)
	bool                                          M_bShow;                                           // 0x0318(0x0001)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_319[0x7];                                      // 0x0319(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void OnUpdateMessage();
	void PlayHideAnimation();
	void PlayShowAnimation();
	void ShowWidget(bool _bShow);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"BFGWidget_HUD_Subtitle">();
	}
	static class UBFGWidget_HUD_Subtitle* GetDefaultObj()
	{
		return GetDefaultObjImpl<UBFGWidget_HUD_Subtitle>();
	}
};
static_assert(alignof(UBFGWidget_HUD_Subtitle) == 0x000008, "Wrong alignment on UBFGWidget_HUD_Subtitle");
static_assert(sizeof(UBFGWidget_HUD_Subtitle) == 0x000320, "Wrong size on UBFGWidget_HUD_Subtitle");
static_assert(offsetof(UBFGWidget_HUD_Subtitle, M_strcurrentMessage) == 0x000300, "Member 'UBFGWidget_HUD_Subtitle::M_strcurrentMessage' has a wrong offset!");
static_assert(offsetof(UBFGWidget_HUD_Subtitle, M_bShow) == 0x000318, "Member 'UBFGWidget_HUD_Subtitle::M_bShow' has a wrong offset!");

// Class BFGCore.BFGGameSystem
// 0x0008 (0x0030 - 0x0028)
class UBFGGameSystem : public UObject
{
public:
	uint8                                         Pad_28[0x8];                                       // 0x0028(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"BFGGameSystem">();
	}
	static class UBFGGameSystem* GetDefaultObj()
	{
		return GetDefaultObjImpl<UBFGGameSystem>();
	}
};
static_assert(alignof(UBFGGameSystem) == 0x000008, "Wrong alignment on UBFGGameSystem");
static_assert(sizeof(UBFGGameSystem) == 0x000030, "Wrong size on UBFGGameSystem");

// Class BFGCore.BFGAbilitySystem
// 0x0018 (0x0048 - 0x0030)
class UBFGAbilitySystem final : public UBFGGameSystem
{
public:
	class ABFGGameState*                          M_pGameState;                                      // 0x0030(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TArray<class UBFGCortexScanResponseSet*>      M_apResponseSets;                                  // 0x0038(0x0010)(ZeroConstructor, Protected, NativeAccessSpecifierProtected)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"BFGAbilitySystem">();
	}
	static class UBFGAbilitySystem* GetDefaultObj()
	{
		return GetDefaultObjImpl<UBFGAbilitySystem>();
	}
};
static_assert(alignof(UBFGAbilitySystem) == 0x000008, "Wrong alignment on UBFGAbilitySystem");
static_assert(sizeof(UBFGAbilitySystem) == 0x000048, "Wrong size on UBFGAbilitySystem");
static_assert(offsetof(UBFGAbilitySystem, M_pGameState) == 0x000030, "Member 'UBFGAbilitySystem::M_pGameState' has a wrong offset!");
static_assert(offsetof(UBFGAbilitySystem, M_apResponseSets) == 0x000038, "Member 'UBFGAbilitySystem::M_apResponseSets' has a wrong offset!");

// Class BFGCore.BFGInterpolationManager
// 0x0160 (0x0190 - 0x0030)
class UBFGInterpolationManager final : public UBFGGameSystem
{
public:
	class ABFGGameState*                          M_pGameState;                                      // 0x0030(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	TArray<struct FBFGInterpolationEntry>         M_aInterpolationRequests_Transform;                // 0x0038(0x0010)(ZeroConstructor, NativeAccessSpecifierPrivate)
	TArray<class UBFGSkeletalMeshComponentBudgeted*> M_aInterpolationRequests_Animation;                // 0x0048(0x0010)(ExportObject, ZeroConstructor, ContainsInstancedReference, NativeAccessSpecifierPrivate)
	TMap<class AActor*, struct FBFGInterpolationAttachmentEntry> M_aAttachmentTable;                                // 0x0058(0x0050)(ZeroConstructor, Transient, NativeAccessSpecifierPrivate)
	TMap<int32, class AActor*>                    M_aVirtualHandleLookup;                            // 0x00A8(0x0050)(ZeroConstructor, Transient, NativeAccessSpecifierPrivate)
	struct FWidgetPool                            M_DebugWidgetPool;                                 // 0x00F8(0x0070)(ContainsInstancedReference, NativeAccessSpecifierPrivate)
	class UCanvasPanel*                           M_pDebugCanvasPanel;                               // 0x0168(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	TArray<struct FRadarWidgetPair>               M_aDebugWidgetsInUse;                              // 0x0170(0x0010)(ZeroConstructor, ContainsInstancedReference, NativeAccessSpecifierPrivate)
	uint8                                         Pad_180[0x8];                                      // 0x0180(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	class ABFGVirtualCrowd*                       M_pVirtualCrowd;                                   // 0x0188(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"BFGInterpolationManager">();
	}
	static class UBFGInterpolationManager* GetDefaultObj()
	{
		return GetDefaultObjImpl<UBFGInterpolationManager>();
	}
};
static_assert(alignof(UBFGInterpolationManager) == 0x000008, "Wrong alignment on UBFGInterpolationManager");
static_assert(sizeof(UBFGInterpolationManager) == 0x000190, "Wrong size on UBFGInterpolationManager");
static_assert(offsetof(UBFGInterpolationManager, M_pGameState) == 0x000030, "Member 'UBFGInterpolationManager::M_pGameState' has a wrong offset!");
static_assert(offsetof(UBFGInterpolationManager, M_aInterpolationRequests_Transform) == 0x000038, "Member 'UBFGInterpolationManager::M_aInterpolationRequests_Transform' has a wrong offset!");
static_assert(offsetof(UBFGInterpolationManager, M_aInterpolationRequests_Animation) == 0x000048, "Member 'UBFGInterpolationManager::M_aInterpolationRequests_Animation' has a wrong offset!");
static_assert(offsetof(UBFGInterpolationManager, M_aAttachmentTable) == 0x000058, "Member 'UBFGInterpolationManager::M_aAttachmentTable' has a wrong offset!");
static_assert(offsetof(UBFGInterpolationManager, M_aVirtualHandleLookup) == 0x0000A8, "Member 'UBFGInterpolationManager::M_aVirtualHandleLookup' has a wrong offset!");
static_assert(offsetof(UBFGInterpolationManager, M_DebugWidgetPool) == 0x0000F8, "Member 'UBFGInterpolationManager::M_DebugWidgetPool' has a wrong offset!");
static_assert(offsetof(UBFGInterpolationManager, M_pDebugCanvasPanel) == 0x000168, "Member 'UBFGInterpolationManager::M_pDebugCanvasPanel' has a wrong offset!");
static_assert(offsetof(UBFGInterpolationManager, M_aDebugWidgetsInUse) == 0x000170, "Member 'UBFGInterpolationManager::M_aDebugWidgetsInUse' has a wrong offset!");
static_assert(offsetof(UBFGInterpolationManager, M_pVirtualCrowd) == 0x000188, "Member 'UBFGInterpolationManager::M_pVirtualCrowd' has a wrong offset!");

// Class BFGCore.BFGEventAction_CallDelegate_Ability
// 0x0028 (0x0058 - 0x0030)
class UBFGEventAction_CallDelegate_Ability final : public UBFGEventAction
{
public:
	UMulticastDelegateProperty_                   M_delegate;                                        // 0x0030(0x0018)(ZeroConstructor, Transient, InstancedReference, Protected, NativeAccessSpecifierProtected)
	TWeakObjectPtr<class UBFGQuest_Element>       M_pElement;                                        // 0x0048(0x0008)(ExportObject, ZeroConstructor, Transient, InstancedReference, IsPlainOldData, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_50[0x8];                                       // 0x0050(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"BFGEventAction_CallDelegate_Ability">();
	}
	static class UBFGEventAction_CallDelegate_Ability* GetDefaultObj()
	{
		return GetDefaultObjImpl<UBFGEventAction_CallDelegate_Ability>();
	}
};
static_assert(alignof(UBFGEventAction_CallDelegate_Ability) == 0x000008, "Wrong alignment on UBFGEventAction_CallDelegate_Ability");
static_assert(sizeof(UBFGEventAction_CallDelegate_Ability) == 0x000058, "Wrong size on UBFGEventAction_CallDelegate_Ability");
static_assert(offsetof(UBFGEventAction_CallDelegate_Ability, M_delegate) == 0x000030, "Member 'UBFGEventAction_CallDelegate_Ability::M_delegate' has a wrong offset!");
static_assert(offsetof(UBFGEventAction_CallDelegate_Ability, M_pElement) == 0x000048, "Member 'UBFGEventAction_CallDelegate_Ability::M_pElement' has a wrong offset!");

// Class BFGCore.BFGWidget_HUD_QuestTracker
// 0x0090 (0x0388 - 0x02F8)
class UBFGWidget_HUD_QuestTracker : public UBFGWidget_HUD
{
public:
	uint8                                         Pad_2F8[0x8];                                      // 0x02F8(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	TSoftClassPtr<class UClass>                   M_pClassSubquestEntry;                             // 0x0300(0x0028)(Edit, DisableEditOnInstance, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TSoftClassPtr<class UClass>                   M_pClassQuestEntry;                                // 0x0328(0x0028)(Edit, DisableEditOnInstance, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TArray<class UBFGWidget_QuestEntry*>          M_apQuestEntriesToCleanup;                         // 0x0350(0x0010)(ExportObject, ZeroConstructor, ContainsInstancedReference, NativeAccessSpecifierPublic)
	TArray<class UBFGWidget_QuestEntry*>          M_apQuestEntries;                                  // 0x0360(0x0010)(ExportObject, ZeroConstructor, ContainsInstancedReference, NativeAccessSpecifierPublic)
	uint8                                         Pad_370[0x18];                                     // 0x0370(0x0018)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void BeforeQuestRemove(class UBFGWidget_QuestEntry* _pQuestEntry);
	class UCanvasPanel* GetContainer();
	void OnHide();
	void OnNewQuestAdded(class UBFGWidget_QuestEntry* _pQuestEntry);
	void OnQuestEntryHideAnimationFinished(class UBFGWidget_QuestEntry* _pQuestEntry);
	void OnShow();
	void OnSwap();
	void RebuildLayoutNative();
	void SetSpacerSize(const struct FVector2D& _vSize);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"BFGWidget_HUD_QuestTracker">();
	}
	static class UBFGWidget_HUD_QuestTracker* GetDefaultObj()
	{
		return GetDefaultObjImpl<UBFGWidget_HUD_QuestTracker>();
	}
};
static_assert(alignof(UBFGWidget_HUD_QuestTracker) == 0x000008, "Wrong alignment on UBFGWidget_HUD_QuestTracker");
static_assert(sizeof(UBFGWidget_HUD_QuestTracker) == 0x000388, "Wrong size on UBFGWidget_HUD_QuestTracker");
static_assert(offsetof(UBFGWidget_HUD_QuestTracker, M_pClassSubquestEntry) == 0x000300, "Member 'UBFGWidget_HUD_QuestTracker::M_pClassSubquestEntry' has a wrong offset!");
static_assert(offsetof(UBFGWidget_HUD_QuestTracker, M_pClassQuestEntry) == 0x000328, "Member 'UBFGWidget_HUD_QuestTracker::M_pClassQuestEntry' has a wrong offset!");
static_assert(offsetof(UBFGWidget_HUD_QuestTracker, M_apQuestEntriesToCleanup) == 0x000350, "Member 'UBFGWidget_HUD_QuestTracker::M_apQuestEntriesToCleanup' has a wrong offset!");
static_assert(offsetof(UBFGWidget_HUD_QuestTracker, M_apQuestEntries) == 0x000360, "Member 'UBFGWidget_HUD_QuestTracker::M_apQuestEntries' has a wrong offset!");

// Class BFGCore.BFGAchievementAwardActor
// 0x0000 (0x03D8 - 0x03D8)
class ABFGAchievementAwardActor : public AActor
{
public:
	void OnAchievementAwarded(class APlayerController* _pPlayerController, class FName _nAchievementID, float _fAchievementProgress, bool _bShouldSaved);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"BFGAchievementAwardActor">();
	}
	static class ABFGAchievementAwardActor* GetDefaultObj()
	{
		return GetDefaultObjImpl<ABFGAchievementAwardActor>();
	}
};
static_assert(alignof(ABFGAchievementAwardActor) == 0x000008, "Wrong alignment on ABFGAchievementAwardActor");
static_assert(sizeof(ABFGAchievementAwardActor) == 0x0003D8, "Wrong size on ABFGAchievementAwardActor");

// Class BFGCore.BFGInteractable
// 0x0050 (0x0428 - 0x03D8)
class ABFGInteractable : public AActor
{
public:
	uint8                                         Pad_3D8[0x10];                                     // 0x03D8(0x0010)(Fixing Size After Last Property [ Dumper-7 ])
	class USceneComponent*                        M_pCollisionComponent;                             // 0x03E8(0x0008)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, EditConst, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UBFGActorComponent_Objective*           M_pObjectiveComponent;                             // 0x03F0(0x0008)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, EditConst, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UBFGActorComponent_Effect*              M_pEffectComponent;                                // 0x03F8(0x0008)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, EditConst, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FGameplayTagContainer                  M_gameplayTags;                                    // 0x0400(0x0020)(Edit, BlueprintVisible, BlueprintReadOnly, NativeAccessSpecifierPublic)
	class USceneComponent*                        M_pObjectiveMarkerParentComponent;                 // 0x0420(0x0008)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, EditConst, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)

public:
	void OnInteract(class AActor* _pOtherActor);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"BFGInteractable">();
	}
	static class ABFGInteractable* GetDefaultObj()
	{
		return GetDefaultObjImpl<ABFGInteractable>();
	}
};
static_assert(alignof(ABFGInteractable) == 0x000008, "Wrong alignment on ABFGInteractable");
static_assert(sizeof(ABFGInteractable) == 0x000428, "Wrong size on ABFGInteractable");
static_assert(offsetof(ABFGInteractable, M_pCollisionComponent) == 0x0003E8, "Member 'ABFGInteractable::M_pCollisionComponent' has a wrong offset!");
static_assert(offsetof(ABFGInteractable, M_pObjectiveComponent) == 0x0003F0, "Member 'ABFGInteractable::M_pObjectiveComponent' has a wrong offset!");
static_assert(offsetof(ABFGInteractable, M_pEffectComponent) == 0x0003F8, "Member 'ABFGInteractable::M_pEffectComponent' has a wrong offset!");
static_assert(offsetof(ABFGInteractable, M_gameplayTags) == 0x000400, "Member 'ABFGInteractable::M_gameplayTags' has a wrong offset!");
static_assert(offsetof(ABFGInteractable, M_pObjectiveMarkerParentComponent) == 0x000420, "Member 'ABFGInteractable::M_pObjectiveMarkerParentComponent' has a wrong offset!");

// Class BFGCore.BFGInteractableMentalAbilityAble
// 0x0020 (0x0448 - 0x0428)
class ABFGInteractableMentalAbilityAble final : public ABFGInteractable
{
public:
	uint8                                         Pad_428[0x8];                                      // 0x0428(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	bool                                          M_bIsPKed;                                         // 0x0430(0x0001)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_431[0x3];                                      // 0x0431(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	struct FVector                                M_vLastDamageImpulse;                              // 0x0434(0x000C)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_440[0x8];                                      // 0x0440(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"BFGInteractableMentalAbilityAble">();
	}
	static class ABFGInteractableMentalAbilityAble* GetDefaultObj()
	{
		return GetDefaultObjImpl<ABFGInteractableMentalAbilityAble>();
	}
};
static_assert(alignof(ABFGInteractableMentalAbilityAble) == 0x000008, "Wrong alignment on ABFGInteractableMentalAbilityAble");
static_assert(sizeof(ABFGInteractableMentalAbilityAble) == 0x000448, "Wrong size on ABFGInteractableMentalAbilityAble");
static_assert(offsetof(ABFGInteractableMentalAbilityAble, M_bIsPKed) == 0x000430, "Member 'ABFGInteractableMentalAbilityAble::M_bIsPKed' has a wrong offset!");
static_assert(offsetof(ABFGInteractableMentalAbilityAble, M_vLastDamageImpulse) == 0x000434, "Member 'ABFGInteractableMentalAbilityAble::M_vLastDamageImpulse' has a wrong offset!");

// Class BFGCore.BFGQuest_Element
// 0x0248 (0x02F8 - 0x00B0)
class UBFGQuest_Element : public UGenericGraphNode
{
public:
	uint8                                         Pad_B0[0x8];                                       // 0x00B0(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	UMulticastDelegateProperty_                   M_OnEnterEvent;                                    // 0x00B8(0x0018)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	UMulticastDelegateProperty_                   M_OnExitEvent;                                     // 0x00D0(0x0018)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	struct FBFGQuest_UIProvider_Title             M_UItitle;                                         // 0x00E8(0x0020)(Edit, BlueprintVisible, BlueprintReadOnly, DisableEditOnInstance, Protected, NativeAccessSpecifierProtected)
	bool                                          M_bDebugSkip;                                      // 0x0108(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnTemplate, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          M_bWaitForVoiceovers;                              // 0x0109(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnTemplate, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          M_bWaitForVoiceoversAtEnd;                         // 0x010A(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnTemplate, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_10B[0x5];                                      // 0x010B(0x0005)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<TSoftObjectPtr<class UBFGVoiceoverGroup>> M_apWaitForVoiceoverGroups;                        // 0x0110(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnTemplate, Protected, UObjectWrapper, NativeAccessSpecifierProtected)
	struct FBFGQuest_StreamingRequester           M_enterStreamingRequests;                          // 0x0120(0x0038)(Edit, BlueprintVisible, BlueprintReadOnly, DisableEditOnInstance, ContainsInstancedReference, Protected, NativeAccessSpecifierProtected)
	struct FBFGQuest_StreamingRequester           M_exitStreamingRequests;                           // 0x0158(0x0038)(Edit, BlueprintVisible, BlueprintReadOnly, DisableEditOnInstance, ContainsInstancedReference, Protected, NativeAccessSpecifierProtected)
	bool                                          M_bIsPrimaryElement;                               // 0x0190(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_191[0x3];                                      // 0x0191(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	class FName                                   M_strSubQuestName;                                 // 0x0194(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          M_bIsCountingForCompletion;                        // 0x019C(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          M_bIsAdditionalCondition;                          // 0x019D(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, EditConst, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	EBFGQuestElement_AdditionalType               M_typeAdditional;                                  // 0x019E(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_19F[0x1];                                      // 0x019F(0x0001)(Fixing Size After Last Property [ Dumper-7 ])
	class FText                                   M_strRatingObjectiveTitle;                         // 0x01A0(0x0018)(Edit, DisableEditOnInstance, Protected, NativeAccessSpecifierProtected)
	int32                                         M_iRatingOrderPriority;                            // 0x01B8(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_1BC[0x4];                                      // 0x01BC(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	struct FGameplayTagContainer                  M_ratingRewardTags_FirstTime;                      // 0x01C0(0x0020)(Edit, DisableEditOnInstance, Protected, NativeAccessSpecifierProtected)
	struct FBFGQuest_Failure                      M_infoFailure;                                     // 0x01E0(0x0088)(Edit, DisableEditOnInstance, Protected, NativeAccessSpecifierProtected)
	bool                                          M_bInfoFailUpdated;                                // 0x0268(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_269[0x7];                                      // 0x0269(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	TSoftObjectPtr<class UBFGDataAsset_NewspaperInfo> M_softFailNewspaper;                               // 0x0270(0x0028)(Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class FText                                   M_strFailReason;                                   // 0x0298(0x0018)(Protected, NativeAccessSpecifierProtected)
	TSoftClassPtr<class UClass>                   M_softFailNarrativeSequence;                       // 0x02B0(0x0028)(Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UBFGQuest*                              M_pQuest;                                          // 0x02D8(0x0008)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          M_bShow_EnterStreamingRequests;                    // 0x02E0(0x0001)(Edit, ZeroConstructor, Transient, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          M_bShow_ExitStreamingRequests;                     // 0x02E1(0x0001)(Edit, ZeroConstructor, Transient, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          M_bShow_SubQuestProperties;                        // 0x02E2(0x0001)(Edit, ZeroConstructor, Transient, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          M_bShow_FailConditionProperties;                   // 0x02E3(0x0001)(Edit, ZeroConstructor, Transient, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          M_bShow_CountingForCompletion;                     // 0x02E4(0x0001)(Edit, ZeroConstructor, Transient, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          M_bShow_CountingForCompletionBasic;                // 0x02E5(0x0001)(Edit, ZeroConstructor, Transient, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          M_bShow_UIProperties;                              // 0x02E6(0x0001)(Edit, ZeroConstructor, Transient, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          M_bShow_WaitForVoiceoverAtEnd;                     // 0x02E7(0x0001)(Edit, ZeroConstructor, Transient, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_2E8[0x10];                                     // 0x02E8(0x0010)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	class UBFGQuest_Challenge* GetChallenge() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"BFGQuest_Element">();
	}
	static class UBFGQuest_Element* GetDefaultObj()
	{
		return GetDefaultObjImpl<UBFGQuest_Element>();
	}
};
static_assert(alignof(UBFGQuest_Element) == 0x000008, "Wrong alignment on UBFGQuest_Element");
static_assert(sizeof(UBFGQuest_Element) == 0x0002F8, "Wrong size on UBFGQuest_Element");
static_assert(offsetof(UBFGQuest_Element, M_OnEnterEvent) == 0x0000B8, "Member 'UBFGQuest_Element::M_OnEnterEvent' has a wrong offset!");
static_assert(offsetof(UBFGQuest_Element, M_OnExitEvent) == 0x0000D0, "Member 'UBFGQuest_Element::M_OnExitEvent' has a wrong offset!");
static_assert(offsetof(UBFGQuest_Element, M_UItitle) == 0x0000E8, "Member 'UBFGQuest_Element::M_UItitle' has a wrong offset!");
static_assert(offsetof(UBFGQuest_Element, M_bDebugSkip) == 0x000108, "Member 'UBFGQuest_Element::M_bDebugSkip' has a wrong offset!");
static_assert(offsetof(UBFGQuest_Element, M_bWaitForVoiceovers) == 0x000109, "Member 'UBFGQuest_Element::M_bWaitForVoiceovers' has a wrong offset!");
static_assert(offsetof(UBFGQuest_Element, M_bWaitForVoiceoversAtEnd) == 0x00010A, "Member 'UBFGQuest_Element::M_bWaitForVoiceoversAtEnd' has a wrong offset!");
static_assert(offsetof(UBFGQuest_Element, M_apWaitForVoiceoverGroups) == 0x000110, "Member 'UBFGQuest_Element::M_apWaitForVoiceoverGroups' has a wrong offset!");
static_assert(offsetof(UBFGQuest_Element, M_enterStreamingRequests) == 0x000120, "Member 'UBFGQuest_Element::M_enterStreamingRequests' has a wrong offset!");
static_assert(offsetof(UBFGQuest_Element, M_exitStreamingRequests) == 0x000158, "Member 'UBFGQuest_Element::M_exitStreamingRequests' has a wrong offset!");
static_assert(offsetof(UBFGQuest_Element, M_bIsPrimaryElement) == 0x000190, "Member 'UBFGQuest_Element::M_bIsPrimaryElement' has a wrong offset!");
static_assert(offsetof(UBFGQuest_Element, M_strSubQuestName) == 0x000194, "Member 'UBFGQuest_Element::M_strSubQuestName' has a wrong offset!");
static_assert(offsetof(UBFGQuest_Element, M_bIsCountingForCompletion) == 0x00019C, "Member 'UBFGQuest_Element::M_bIsCountingForCompletion' has a wrong offset!");
static_assert(offsetof(UBFGQuest_Element, M_bIsAdditionalCondition) == 0x00019D, "Member 'UBFGQuest_Element::M_bIsAdditionalCondition' has a wrong offset!");
static_assert(offsetof(UBFGQuest_Element, M_typeAdditional) == 0x00019E, "Member 'UBFGQuest_Element::M_typeAdditional' has a wrong offset!");
static_assert(offsetof(UBFGQuest_Element, M_strRatingObjectiveTitle) == 0x0001A0, "Member 'UBFGQuest_Element::M_strRatingObjectiveTitle' has a wrong offset!");
static_assert(offsetof(UBFGQuest_Element, M_iRatingOrderPriority) == 0x0001B8, "Member 'UBFGQuest_Element::M_iRatingOrderPriority' has a wrong offset!");
static_assert(offsetof(UBFGQuest_Element, M_ratingRewardTags_FirstTime) == 0x0001C0, "Member 'UBFGQuest_Element::M_ratingRewardTags_FirstTime' has a wrong offset!");
static_assert(offsetof(UBFGQuest_Element, M_infoFailure) == 0x0001E0, "Member 'UBFGQuest_Element::M_infoFailure' has a wrong offset!");
static_assert(offsetof(UBFGQuest_Element, M_bInfoFailUpdated) == 0x000268, "Member 'UBFGQuest_Element::M_bInfoFailUpdated' has a wrong offset!");
static_assert(offsetof(UBFGQuest_Element, M_softFailNewspaper) == 0x000270, "Member 'UBFGQuest_Element::M_softFailNewspaper' has a wrong offset!");
static_assert(offsetof(UBFGQuest_Element, M_strFailReason) == 0x000298, "Member 'UBFGQuest_Element::M_strFailReason' has a wrong offset!");
static_assert(offsetof(UBFGQuest_Element, M_softFailNarrativeSequence) == 0x0002B0, "Member 'UBFGQuest_Element::M_softFailNarrativeSequence' has a wrong offset!");
static_assert(offsetof(UBFGQuest_Element, M_pQuest) == 0x0002D8, "Member 'UBFGQuest_Element::M_pQuest' has a wrong offset!");
static_assert(offsetof(UBFGQuest_Element, M_bShow_EnterStreamingRequests) == 0x0002E0, "Member 'UBFGQuest_Element::M_bShow_EnterStreamingRequests' has a wrong offset!");
static_assert(offsetof(UBFGQuest_Element, M_bShow_ExitStreamingRequests) == 0x0002E1, "Member 'UBFGQuest_Element::M_bShow_ExitStreamingRequests' has a wrong offset!");
static_assert(offsetof(UBFGQuest_Element, M_bShow_SubQuestProperties) == 0x0002E2, "Member 'UBFGQuest_Element::M_bShow_SubQuestProperties' has a wrong offset!");
static_assert(offsetof(UBFGQuest_Element, M_bShow_FailConditionProperties) == 0x0002E3, "Member 'UBFGQuest_Element::M_bShow_FailConditionProperties' has a wrong offset!");
static_assert(offsetof(UBFGQuest_Element, M_bShow_CountingForCompletion) == 0x0002E4, "Member 'UBFGQuest_Element::M_bShow_CountingForCompletion' has a wrong offset!");
static_assert(offsetof(UBFGQuest_Element, M_bShow_CountingForCompletionBasic) == 0x0002E5, "Member 'UBFGQuest_Element::M_bShow_CountingForCompletionBasic' has a wrong offset!");
static_assert(offsetof(UBFGQuest_Element, M_bShow_UIProperties) == 0x0002E6, "Member 'UBFGQuest_Element::M_bShow_UIProperties' has a wrong offset!");
static_assert(offsetof(UBFGQuest_Element, M_bShow_WaitForVoiceoverAtEnd) == 0x0002E7, "Member 'UBFGQuest_Element::M_bShow_WaitForVoiceoverAtEnd' has a wrong offset!");

// Class BFGCore.BFGQuest_ElementCheckpoint
// 0x0088 (0x0380 - 0x02F8)
class UBFGQuest_ElementCheckpoint final : public UBFGQuest_Element
{
public:
	class FName                                   M_strIdentifier;                                   // 0x02F8(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TSoftObjectPtr<class ABFGLevelCheckpoint>     M_softCheckpoint;                                  // 0x0300(0x0028)(Edit, BlueprintVisible, BlueprintReadOnly, DisableEditOnInstance, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          M_bFadeInAfterLoadGame;                            // 0x0328(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_329[0x7];                                      // 0x0329(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<TSoftObjectPtr<class AActor>>          M_aSoftActors;                                     // 0x0330(0x0010)(ZeroConstructor, UObjectWrapper, NativeAccessSpecifierPublic)
	bool                                          M_bTeleportToCheckpoint;                           // 0x0340(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_341[0x7];                                      // 0x0341(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	UMulticastDelegateProperty_                   M_OnDebugEnterEvent;                               // 0x0348(0x0018)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	class UBFGVariable*                           M_pCheckpointVariable;                             // 0x0360(0x0008)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UBFGVariable*                           M_pForceTeleportVariable;                          // 0x0368(0x0008)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_370[0x10];                                     // 0x0370(0x0010)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void OnEnterdQuestStep(class UBFGQuest_Element* _pElement);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"BFGQuest_ElementCheckpoint">();
	}
	static class UBFGQuest_ElementCheckpoint* GetDefaultObj()
	{
		return GetDefaultObjImpl<UBFGQuest_ElementCheckpoint>();
	}
};
static_assert(alignof(UBFGQuest_ElementCheckpoint) == 0x000008, "Wrong alignment on UBFGQuest_ElementCheckpoint");
static_assert(sizeof(UBFGQuest_ElementCheckpoint) == 0x000380, "Wrong size on UBFGQuest_ElementCheckpoint");
static_assert(offsetof(UBFGQuest_ElementCheckpoint, M_strIdentifier) == 0x0002F8, "Member 'UBFGQuest_ElementCheckpoint::M_strIdentifier' has a wrong offset!");
static_assert(offsetof(UBFGQuest_ElementCheckpoint, M_softCheckpoint) == 0x000300, "Member 'UBFGQuest_ElementCheckpoint::M_softCheckpoint' has a wrong offset!");
static_assert(offsetof(UBFGQuest_ElementCheckpoint, M_bFadeInAfterLoadGame) == 0x000328, "Member 'UBFGQuest_ElementCheckpoint::M_bFadeInAfterLoadGame' has a wrong offset!");
static_assert(offsetof(UBFGQuest_ElementCheckpoint, M_aSoftActors) == 0x000330, "Member 'UBFGQuest_ElementCheckpoint::M_aSoftActors' has a wrong offset!");
static_assert(offsetof(UBFGQuest_ElementCheckpoint, M_bTeleportToCheckpoint) == 0x000340, "Member 'UBFGQuest_ElementCheckpoint::M_bTeleportToCheckpoint' has a wrong offset!");
static_assert(offsetof(UBFGQuest_ElementCheckpoint, M_OnDebugEnterEvent) == 0x000348, "Member 'UBFGQuest_ElementCheckpoint::M_OnDebugEnterEvent' has a wrong offset!");
static_assert(offsetof(UBFGQuest_ElementCheckpoint, M_pCheckpointVariable) == 0x000360, "Member 'UBFGQuest_ElementCheckpoint::M_pCheckpointVariable' has a wrong offset!");
static_assert(offsetof(UBFGQuest_ElementCheckpoint, M_pForceTeleportVariable) == 0x000368, "Member 'UBFGQuest_ElementCheckpoint::M_pForceTeleportVariable' has a wrong offset!");

// Class BFGCore.BFGAchievementManager
// 0x0038 (0x0068 - 0x0030)
class UBFGAchievementManager : public UBFGGameSystem
{
public:
	class UClass*                                 M_pAchievementAwardActor;                          // 0x0030(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TArray<struct FGameplayTag>                   Level3AchievementList;                             // 0x0038(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, NativeAccessSpecifierPublic)
	class ABFGGameState*                          M_pGameState;                                      // 0x0048(0x0008)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_50[0x8];                                       // 0x0050(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<struct FBFGAchievementsCache>          M_aCachedAchievements;                             // 0x0058(0x0010)(ZeroConstructor, NativeAccessSpecifierPrivate)

public:
	void AwardAchievement(class UWorld* _pWorldContext, class FName _nAchievementID, float _fAchievementProgress, bool _bShouldSave);
	void AwardAchievementsFailed(class UWorld* _pWorldContext, class FName _nAchievementID, float _fAchievementProgress, bool _bShouldSave);
	void AwardAchievementsSuccess(class UWorld* _pWorldContext, class FName _nAchievementID, float _fAchievementProgress, bool _bShouldSave);
	void ReApplyAchievements(class UWorld* _pWorldContext);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"BFGAchievementManager">();
	}
	static class UBFGAchievementManager* GetDefaultObj()
	{
		return GetDefaultObjImpl<UBFGAchievementManager>();
	}
};
static_assert(alignof(UBFGAchievementManager) == 0x000008, "Wrong alignment on UBFGAchievementManager");
static_assert(sizeof(UBFGAchievementManager) == 0x000068, "Wrong size on UBFGAchievementManager");
static_assert(offsetof(UBFGAchievementManager, M_pAchievementAwardActor) == 0x000030, "Member 'UBFGAchievementManager::M_pAchievementAwardActor' has a wrong offset!");
static_assert(offsetof(UBFGAchievementManager, Level3AchievementList) == 0x000038, "Member 'UBFGAchievementManager::Level3AchievementList' has a wrong offset!");
static_assert(offsetof(UBFGAchievementManager, M_pGameState) == 0x000048, "Member 'UBFGAchievementManager::M_pGameState' has a wrong offset!");
static_assert(offsetof(UBFGAchievementManager, M_aCachedAchievements) == 0x000058, "Member 'UBFGAchievementManager::M_aCachedAchievements' has a wrong offset!");

// Class BFGCore.BFGEventAction_LockInput
// 0x0008 (0x0038 - 0x0030)
class UBFGEventAction_LockInput final : public UBFGEventAction
{
public:
	uint8                                         Pad_30[0x8];                                       // 0x0030(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"BFGEventAction_LockInput">();
	}
	static class UBFGEventAction_LockInput* GetDefaultObj()
	{
		return GetDefaultObjImpl<UBFGEventAction_LockInput>();
	}
};
static_assert(alignof(UBFGEventAction_LockInput) == 0x000008, "Wrong alignment on UBFGEventAction_LockInput");
static_assert(sizeof(UBFGEventAction_LockInput) == 0x000038, "Wrong size on UBFGEventAction_LockInput");

// Class BFGCore.BFGScriptedSequence_TaskEnterVehicle
// 0x0060 (0x00B0 - 0x0050)
class UBFGScriptedSequence_TaskEnterVehicle final : public UBFGScriptedSequence_Task
{
public:
	struct FGameplayTagQuery                      M_gameplayTagQueryForVehicle;                      // 0x0050(0x0048)(Transient, Protected, NativeAccessSpecifierProtected)
	EBFGVehiclePassenger_Spot                     M_eSpot;                                           // 0x0098(0x0001)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_99[0x7];                                       // 0x0099(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	class UBFGNetworkPathAgent_Vehicle*           M_pVehicleAgent;                                   // 0x00A0(0x0008)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UBFGNetworkPathAgent_AIStateBase*       M_pStateInAI;                                      // 0x00A8(0x0008)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)

public:
	static bool CreateAndAddScriptedSequence_TaskEnterVehicle(class UBFGScriptedSequence* _pScriptedSequence, const struct FGameplayTagQuery& _vehicleTag, EBFGVehiclePassenger_Spot _eSpot);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"BFGScriptedSequence_TaskEnterVehicle">();
	}
	static class UBFGScriptedSequence_TaskEnterVehicle* GetDefaultObj()
	{
		return GetDefaultObjImpl<UBFGScriptedSequence_TaskEnterVehicle>();
	}
};
static_assert(alignof(UBFGScriptedSequence_TaskEnterVehicle) == 0x000008, "Wrong alignment on UBFGScriptedSequence_TaskEnterVehicle");
static_assert(sizeof(UBFGScriptedSequence_TaskEnterVehicle) == 0x0000B0, "Wrong size on UBFGScriptedSequence_TaskEnterVehicle");
static_assert(offsetof(UBFGScriptedSequence_TaskEnterVehicle, M_gameplayTagQueryForVehicle) == 0x000050, "Member 'UBFGScriptedSequence_TaskEnterVehicle::M_gameplayTagQueryForVehicle' has a wrong offset!");
static_assert(offsetof(UBFGScriptedSequence_TaskEnterVehicle, M_eSpot) == 0x000098, "Member 'UBFGScriptedSequence_TaskEnterVehicle::M_eSpot' has a wrong offset!");
static_assert(offsetof(UBFGScriptedSequence_TaskEnterVehicle, M_pVehicleAgent) == 0x0000A0, "Member 'UBFGScriptedSequence_TaskEnterVehicle::M_pVehicleAgent' has a wrong offset!");
static_assert(offsetof(UBFGScriptedSequence_TaskEnterVehicle, M_pStateInAI) == 0x0000A8, "Member 'UBFGScriptedSequence_TaskEnterVehicle::M_pStateInAI' has a wrong offset!");

// Class BFGCore.BFGActor_EnvironmentMonitor
// 0x0010 (0x03E8 - 0x03D8)
class ABFGActor_EnvironmentMonitor : public AActor
{
public:
	uint8                                         Pad_3D8[0x8];                                      // 0x03D8(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	class UBFGActorComponent_EnvironmentMonitor*  M_pMonitorComponent;                               // 0x03E0(0x0008)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, EditConst, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"BFGActor_EnvironmentMonitor">();
	}
	static class ABFGActor_EnvironmentMonitor* GetDefaultObj()
	{
		return GetDefaultObjImpl<ABFGActor_EnvironmentMonitor>();
	}
};
static_assert(alignof(ABFGActor_EnvironmentMonitor) == 0x000008, "Wrong alignment on ABFGActor_EnvironmentMonitor");
static_assert(sizeof(ABFGActor_EnvironmentMonitor) == 0x0003E8, "Wrong size on ABFGActor_EnvironmentMonitor");
static_assert(offsetof(ABFGActor_EnvironmentMonitor, M_pMonitorComponent) == 0x0003E0, "Member 'ABFGActor_EnvironmentMonitor::M_pMonitorComponent' has a wrong offset!");

// Class BFGCore.BFGActor_Silhouette_CoverSpot
// 0x0000 (0x03D8 - 0x03D8)
class ABFGActor_Silhouette_CoverSpot final : public AActor
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"BFGActor_Silhouette_CoverSpot">();
	}
	static class ABFGActor_Silhouette_CoverSpot* GetDefaultObj()
	{
		return GetDefaultObjImpl<ABFGActor_Silhouette_CoverSpot>();
	}
};
static_assert(alignof(ABFGActor_Silhouette_CoverSpot) == 0x000008, "Wrong alignment on ABFGActor_Silhouette_CoverSpot");
static_assert(sizeof(ABFGActor_Silhouette_CoverSpot) == 0x0003D8, "Wrong size on ABFGActor_Silhouette_CoverSpot");

// Class BFGCore.BFGEventAction_CompletionRating
// 0x0010 (0x0040 - 0x0030)
class UBFGEventAction_CompletionRating final : public UBFGEventAction
{
public:
	class UBFGQuest*                              M_pQuest;                                          // 0x0030(0x0008)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_38[0x8];                                       // 0x0038(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"BFGEventAction_CompletionRating">();
	}
	static class UBFGEventAction_CompletionRating* GetDefaultObj()
	{
		return GetDefaultObjImpl<UBFGEventAction_CompletionRating>();
	}
};
static_assert(alignof(UBFGEventAction_CompletionRating) == 0x000008, "Wrong alignment on UBFGEventAction_CompletionRating");
static_assert(sizeof(UBFGEventAction_CompletionRating) == 0x000040, "Wrong size on UBFGEventAction_CompletionRating");
static_assert(offsetof(UBFGEventAction_CompletionRating, M_pQuest) == 0x000030, "Member 'UBFGEventAction_CompletionRating::M_pQuest' has a wrong offset!");

// Class BFGCore.BFGScriptedSequence_TaskPlayAnim
// 0x0050 (0x00A0 - 0x0050)
class UBFGScriptedSequence_TaskPlayAnim : public UBFGScriptedSequence_Task
{
public:
	TSoftObjectPtr<class AActor>                  M_softDestination;                                 // 0x0050(0x0028)(Transient, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	struct FBFGInteractAnimationSequence          M_animSequence;                                    // 0x0078(0x0018)(Transient, Protected, NativeAccessSpecifierProtected)
	uint8                                         Pad_90[0x10];                                      // 0x0090(0x0010)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static bool CreateAndAddScriptedSequence_TaskPlayAnim(class UBFGScriptedSequence* _pScriptedSequence, TSoftObjectPtr<class AActor> _softDestination, const struct FBFGInteractAnimationSequence& _animSequenceData, bool _bLooping, float _fDuration, bool _bFinishTaskWhenAnimStarted);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"BFGScriptedSequence_TaskPlayAnim">();
	}
	static class UBFGScriptedSequence_TaskPlayAnim* GetDefaultObj()
	{
		return GetDefaultObjImpl<UBFGScriptedSequence_TaskPlayAnim>();
	}
};
static_assert(alignof(UBFGScriptedSequence_TaskPlayAnim) == 0x000008, "Wrong alignment on UBFGScriptedSequence_TaskPlayAnim");
static_assert(sizeof(UBFGScriptedSequence_TaskPlayAnim) == 0x0000A0, "Wrong size on UBFGScriptedSequence_TaskPlayAnim");
static_assert(offsetof(UBFGScriptedSequence_TaskPlayAnim, M_softDestination) == 0x000050, "Member 'UBFGScriptedSequence_TaskPlayAnim::M_softDestination' has a wrong offset!");
static_assert(offsetof(UBFGScriptedSequence_TaskPlayAnim, M_animSequence) == 0x000078, "Member 'UBFGScriptedSequence_TaskPlayAnim::M_animSequence' has a wrong offset!");

// Class BFGCore.BFGActor_Silhouette_SpinTornado
// 0x0020 (0x03F8 - 0x03D8)
class ABFGActor_Silhouette_SpinTornado final : public AActor
{
public:
	uint8                                         Pad_3D8[0x18];                                     // 0x03D8(0x0018)(Fixing Size After Last Property [ Dumper-7 ])
	class ABFGNPCCharacterBoss_Silhouette*        M_pOwnerCharacterBoss;                             // 0x03F0(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)

public:
	void ActivateTornadoVFX();
	void DeactivateTornadoVFX();
	void EndSpinning();
	void ShootBeam(const struct FVector& _vSpawnLocation, const struct FRotator& _vSpawnRotation, class ABFGProjectile_Object* _pOwnerProjectile);
	void StartSpinning();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"BFGActor_Silhouette_SpinTornado">();
	}
	static class ABFGActor_Silhouette_SpinTornado* GetDefaultObj()
	{
		return GetDefaultObjImpl<ABFGActor_Silhouette_SpinTornado>();
	}
};
static_assert(alignof(ABFGActor_Silhouette_SpinTornado) == 0x000008, "Wrong alignment on ABFGActor_Silhouette_SpinTornado");
static_assert(sizeof(ABFGActor_Silhouette_SpinTornado) == 0x0003F8, "Wrong size on ABFGActor_Silhouette_SpinTornado");
static_assert(offsetof(ABFGActor_Silhouette_SpinTornado, M_pOwnerCharacterBoss) == 0x0003F0, "Member 'ABFGActor_Silhouette_SpinTornado::M_pOwnerCharacterBoss' has a wrong offset!");

// Class BFGCore.BFGActor_SkyDome
// 0x0030 (0x0418 - 0x03E8)
class ABFGActor_SkyDome : public ABFGActor_EnvironmentMonitor
{
public:
	bool                                          M_bIsHiddenInGameDuringEnvironment;                // 0x03E8(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_3E9[0x7];                                      // 0x03E9(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<class UActorComponent*>                M_apComponentsToThaw_Register;                     // 0x03F0(0x0010)(ExportObject, ZeroConstructor, Transient, ContainsInstancedReference, Protected, NativeAccessSpecifierProtected)
	TArray<class UActorComponent*>                M_apComponentsToThaw_Ticking;                      // 0x0400(0x0010)(ExportObject, ZeroConstructor, Transient, ContainsInstancedReference, Protected, NativeAccessSpecifierProtected)
	uint8                                         Pad_410[0x8];                                      // 0x0410(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"BFGActor_SkyDome">();
	}
	static class ABFGActor_SkyDome* GetDefaultObj()
	{
		return GetDefaultObjImpl<ABFGActor_SkyDome>();
	}
};
static_assert(alignof(ABFGActor_SkyDome) == 0x000008, "Wrong alignment on ABFGActor_SkyDome");
static_assert(sizeof(ABFGActor_SkyDome) == 0x000418, "Wrong size on ABFGActor_SkyDome");
static_assert(offsetof(ABFGActor_SkyDome, M_bIsHiddenInGameDuringEnvironment) == 0x0003E8, "Member 'ABFGActor_SkyDome::M_bIsHiddenInGameDuringEnvironment' has a wrong offset!");
static_assert(offsetof(ABFGActor_SkyDome, M_apComponentsToThaw_Register) == 0x0003F0, "Member 'ABFGActor_SkyDome::M_apComponentsToThaw_Register' has a wrong offset!");
static_assert(offsetof(ABFGActor_SkyDome, M_apComponentsToThaw_Ticking) == 0x000400, "Member 'ABFGActor_SkyDome::M_apComponentsToThaw_Ticking' has a wrong offset!");

// Class BFGCore.BFGNetworkPathSpawner
// 0x0030 (0x0058 - 0x0028)
class UBFGNetworkPathSpawner final : public UObject
{
public:
	UMulticastDelegateProperty_                   M_onAgentSpawned;                                  // 0x0028(0x0018)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	class UBFGNetworkPath*                        M_pPath;                                           // 0x0040(0x0008)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UBFGSpawningComposition*                M_pSpawningComposition;                            // 0x0048(0x0008)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UBFGAICombatMediator_TargetTracker*     M_pTargetTracker;                                  // 0x0050(0x0008)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"BFGNetworkPathSpawner">();
	}
	static class UBFGNetworkPathSpawner* GetDefaultObj()
	{
		return GetDefaultObjImpl<UBFGNetworkPathSpawner>();
	}
};
static_assert(alignof(UBFGNetworkPathSpawner) == 0x000008, "Wrong alignment on UBFGNetworkPathSpawner");
static_assert(sizeof(UBFGNetworkPathSpawner) == 0x000058, "Wrong size on UBFGNetworkPathSpawner");
static_assert(offsetof(UBFGNetworkPathSpawner, M_onAgentSpawned) == 0x000028, "Member 'UBFGNetworkPathSpawner::M_onAgentSpawned' has a wrong offset!");
static_assert(offsetof(UBFGNetworkPathSpawner, M_pPath) == 0x000040, "Member 'UBFGNetworkPathSpawner::M_pPath' has a wrong offset!");
static_assert(offsetof(UBFGNetworkPathSpawner, M_pSpawningComposition) == 0x000048, "Member 'UBFGNetworkPathSpawner::M_pSpawningComposition' has a wrong offset!");
static_assert(offsetof(UBFGNetworkPathSpawner, M_pTargetTracker) == 0x000050, "Member 'UBFGNetworkPathSpawner::M_pTargetTracker' has a wrong offset!");

// Class BFGCore.BFGEventAction_AlertState_StealthWarning
// 0x0008 (0x0038 - 0x0030)
class UBFGEventAction_AlertState_StealthWarning final : public UBFGEventAction
{
public:
	uint8                                         Pad_30[0x8];                                       // 0x0030(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"BFGEventAction_AlertState_StealthWarning">();
	}
	static class UBFGEventAction_AlertState_StealthWarning* GetDefaultObj()
	{
		return GetDefaultObjImpl<UBFGEventAction_AlertState_StealthWarning>();
	}
};
static_assert(alignof(UBFGEventAction_AlertState_StealthWarning) == 0x000008, "Wrong alignment on UBFGEventAction_AlertState_StealthWarning");
static_assert(sizeof(UBFGEventAction_AlertState_StealthWarning) == 0x000038, "Wrong size on UBFGEventAction_AlertState_StealthWarning");

// Class BFGCore.BFGMentalAbilityBase
// 0x01A0 (0x01C8 - 0x0028)
class UBFGMentalAbilityBase : public UObject
{
public:
	uint8                                         Pad_28[0x8];                                       // 0x0028(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	class UBFGActorComponent_Effect*              M_pEffectComponent;                                // 0x0030(0x0008)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, EditConst, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          M_bCanBeCancledEvenWhileActive;                    // 0x0038(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_39[0x7];                                       // 0x0039(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	TSubclassOf<class UDamageType>                M_pDamageType;                                     // 0x0040(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         M_fCooldown;                                       // 0x0048(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         M_fMaxRange;                                       // 0x004C(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         M_fChannelMaxRange;                                // 0x0050(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_54[0x4];                                       // 0x0054(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<class UClass*>                         M_aPossibleTargetClasses;                          // 0x0058(0x0010)(ZeroConstructor, NativeAccessSpecifierPublic)
	float                                         M_fMentalLinkChannelTime;                          // 0x0068(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         M_fSmashMentalLinkDurationReduction;               // 0x006C(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         M_fSmashEffectDurationReduction;                   // 0x0070(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         M_fEffectDuration;                                 // 0x0074(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          M_bRequiresTarget;                                 // 0x0078(0x0001)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_79[0x7];                                       // 0x0079(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	class AActor*                                 M_pActiveTarget;                                   // 0x0080(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class AActor*                                 M_pCurrentAimTarget;                               // 0x0088(0x0008)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	UMulticastDelegateProperty_                   M_OnMentalAbilityEffect;                           // 0x0090(0x0018)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	UMulticastDelegateProperty_                   M_OnAbilityStop;                                   // 0x00A8(0x0018)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	struct FGameplayTagContainer                  M_gameplayTags;                                    // 0x00C0(0x0020)(Edit, BlueprintVisible, BlueprintReadOnly, DisableEditOnInstance, Protected, NativeAccessSpecifierProtected)
	struct FGameplayTagContainer                  M_oGrantedTags;                                    // 0x00E0(0x0020)(Edit, BlueprintVisible, BlueprintReadOnly, DisableEditOnInstance, Protected, NativeAccessSpecifierProtected)
	struct FGameplayTagContainer                  M_oPrerequisiteTags;                               // 0x0100(0x0020)(Edit, BlueprintVisible, BlueprintReadOnly, DisableEditOnInstance, Protected, NativeAccessSpecifierProtected)
	struct FGameplayTagContainer                  M_oForbiddenTags;                                  // 0x0120(0x0020)(Edit, BlueprintVisible, BlueprintReadOnly, DisableEditOnInstance, Protected, NativeAccessSpecifierProtected)
	bool                                          M_bInputSustainsActivity;                          // 0x0140(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	EBFGAnimation_MentalAbilityPosture            M_eAnimationPosture;                               // 0x0141(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_142[0x2];                                      // 0x0142(0x0002)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         M_fAlertFrequency;                                 // 0x0144(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	struct FGameplayTag                           M_oSourceMentalLinkEffectTag;                      // 0x0148(0x0008)(Edit, DisableEditOnInstance, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	struct FGameplayTag                           M_oTargetMentalLinkEffectTag;                      // 0x0150(0x0008)(Edit, DisableEditOnInstance, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TWeakObjectPtr<class UBFGActorComponent_MentalAbilities> M_pUserComponent;                                  // 0x0158(0x0008)(ExportObject, ZeroConstructor, Transient, InstancedReference, IsPlainOldData, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TWeakObjectPtr<class AActor>                  M_pUser;                                           // 0x0160(0x0008)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	struct FBFGPlayerSettingsMentalAbilityInfo    M_settings;                                        // 0x0168(0x0048)(Transient, Protected, NativeAccessSpecifierProtected)
	float                                         M_fTriggerAlertEvent;                              // 0x01B0(0x0004)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         M_fCurrentCooldown;                                // 0x01B4(0x0004)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         M_fMentalLinkTimer;                                // 0x01B8(0x0004)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         M_fEffectTimer;                                    // 0x01BC(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_1C0[0x2];                                      // 0x01C0(0x0002)(Fixing Size After Last Property [ Dumper-7 ])
	EAbilityState                                 M_eAbilityState;                                   // 0x01C2(0x0001)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_1C3[0x5];                                      // 0x01C3(0x0005)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void BoolEvent__DelegateSignature(class UBFGMentalAbilityBase* _pAbility, bool _bEnabled);
	void ForceStop();
	void MovedOutOfRange();
	void OnAbilityActivationFailed(EAbilityActivationResult _abilityFailReason);
	void OnAbilityEffect();
	void OnAbilityEnd();
	void OnCooldownFinished();
	void OnSmashedDuringEffect();
	void OnSmashedDuringLink();
	void OnTick(float _fDeltaTime);
	void SetState(EAbilityState _eState, bool _bForceBroadcast);
	void StartedMentalLink();
	void StoppedMentalLink(bool _wasSuccessfull);
	void UpdateAbilityDressing(float _fDeltaTime);

	bool CheckIsUpgradeUnlocked(const struct FGameplayTag& _rTag) const;
	class AActor* GetActiveTarget() const;
	EBFGAnimation_MentalAbilityPosture GetAnimationPosture() const;
	class ABFGGameState* GetBFGGameState() const;
	float GetCurrentChannelPercent() const;
	float GetCurrentEffectProgressPercent() const;
	EAbilityState GetState() const;
	class AActor* GetUser() const;
	bool IsAvailable() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"BFGMentalAbilityBase">();
	}
	static class UBFGMentalAbilityBase* GetDefaultObj()
	{
		return GetDefaultObjImpl<UBFGMentalAbilityBase>();
	}
};
static_assert(alignof(UBFGMentalAbilityBase) == 0x000008, "Wrong alignment on UBFGMentalAbilityBase");
static_assert(sizeof(UBFGMentalAbilityBase) == 0x0001C8, "Wrong size on UBFGMentalAbilityBase");
static_assert(offsetof(UBFGMentalAbilityBase, M_pEffectComponent) == 0x000030, "Member 'UBFGMentalAbilityBase::M_pEffectComponent' has a wrong offset!");
static_assert(offsetof(UBFGMentalAbilityBase, M_bCanBeCancledEvenWhileActive) == 0x000038, "Member 'UBFGMentalAbilityBase::M_bCanBeCancledEvenWhileActive' has a wrong offset!");
static_assert(offsetof(UBFGMentalAbilityBase, M_pDamageType) == 0x000040, "Member 'UBFGMentalAbilityBase::M_pDamageType' has a wrong offset!");
static_assert(offsetof(UBFGMentalAbilityBase, M_fCooldown) == 0x000048, "Member 'UBFGMentalAbilityBase::M_fCooldown' has a wrong offset!");
static_assert(offsetof(UBFGMentalAbilityBase, M_fMaxRange) == 0x00004C, "Member 'UBFGMentalAbilityBase::M_fMaxRange' has a wrong offset!");
static_assert(offsetof(UBFGMentalAbilityBase, M_fChannelMaxRange) == 0x000050, "Member 'UBFGMentalAbilityBase::M_fChannelMaxRange' has a wrong offset!");
static_assert(offsetof(UBFGMentalAbilityBase, M_aPossibleTargetClasses) == 0x000058, "Member 'UBFGMentalAbilityBase::M_aPossibleTargetClasses' has a wrong offset!");
static_assert(offsetof(UBFGMentalAbilityBase, M_fMentalLinkChannelTime) == 0x000068, "Member 'UBFGMentalAbilityBase::M_fMentalLinkChannelTime' has a wrong offset!");
static_assert(offsetof(UBFGMentalAbilityBase, M_fSmashMentalLinkDurationReduction) == 0x00006C, "Member 'UBFGMentalAbilityBase::M_fSmashMentalLinkDurationReduction' has a wrong offset!");
static_assert(offsetof(UBFGMentalAbilityBase, M_fSmashEffectDurationReduction) == 0x000070, "Member 'UBFGMentalAbilityBase::M_fSmashEffectDurationReduction' has a wrong offset!");
static_assert(offsetof(UBFGMentalAbilityBase, M_fEffectDuration) == 0x000074, "Member 'UBFGMentalAbilityBase::M_fEffectDuration' has a wrong offset!");
static_assert(offsetof(UBFGMentalAbilityBase, M_bRequiresTarget) == 0x000078, "Member 'UBFGMentalAbilityBase::M_bRequiresTarget' has a wrong offset!");
static_assert(offsetof(UBFGMentalAbilityBase, M_pActiveTarget) == 0x000080, "Member 'UBFGMentalAbilityBase::M_pActiveTarget' has a wrong offset!");
static_assert(offsetof(UBFGMentalAbilityBase, M_pCurrentAimTarget) == 0x000088, "Member 'UBFGMentalAbilityBase::M_pCurrentAimTarget' has a wrong offset!");
static_assert(offsetof(UBFGMentalAbilityBase, M_OnMentalAbilityEffect) == 0x000090, "Member 'UBFGMentalAbilityBase::M_OnMentalAbilityEffect' has a wrong offset!");
static_assert(offsetof(UBFGMentalAbilityBase, M_OnAbilityStop) == 0x0000A8, "Member 'UBFGMentalAbilityBase::M_OnAbilityStop' has a wrong offset!");
static_assert(offsetof(UBFGMentalAbilityBase, M_gameplayTags) == 0x0000C0, "Member 'UBFGMentalAbilityBase::M_gameplayTags' has a wrong offset!");
static_assert(offsetof(UBFGMentalAbilityBase, M_oGrantedTags) == 0x0000E0, "Member 'UBFGMentalAbilityBase::M_oGrantedTags' has a wrong offset!");
static_assert(offsetof(UBFGMentalAbilityBase, M_oPrerequisiteTags) == 0x000100, "Member 'UBFGMentalAbilityBase::M_oPrerequisiteTags' has a wrong offset!");
static_assert(offsetof(UBFGMentalAbilityBase, M_oForbiddenTags) == 0x000120, "Member 'UBFGMentalAbilityBase::M_oForbiddenTags' has a wrong offset!");
static_assert(offsetof(UBFGMentalAbilityBase, M_bInputSustainsActivity) == 0x000140, "Member 'UBFGMentalAbilityBase::M_bInputSustainsActivity' has a wrong offset!");
static_assert(offsetof(UBFGMentalAbilityBase, M_eAnimationPosture) == 0x000141, "Member 'UBFGMentalAbilityBase::M_eAnimationPosture' has a wrong offset!");
static_assert(offsetof(UBFGMentalAbilityBase, M_fAlertFrequency) == 0x000144, "Member 'UBFGMentalAbilityBase::M_fAlertFrequency' has a wrong offset!");
static_assert(offsetof(UBFGMentalAbilityBase, M_oSourceMentalLinkEffectTag) == 0x000148, "Member 'UBFGMentalAbilityBase::M_oSourceMentalLinkEffectTag' has a wrong offset!");
static_assert(offsetof(UBFGMentalAbilityBase, M_oTargetMentalLinkEffectTag) == 0x000150, "Member 'UBFGMentalAbilityBase::M_oTargetMentalLinkEffectTag' has a wrong offset!");
static_assert(offsetof(UBFGMentalAbilityBase, M_pUserComponent) == 0x000158, "Member 'UBFGMentalAbilityBase::M_pUserComponent' has a wrong offset!");
static_assert(offsetof(UBFGMentalAbilityBase, M_pUser) == 0x000160, "Member 'UBFGMentalAbilityBase::M_pUser' has a wrong offset!");
static_assert(offsetof(UBFGMentalAbilityBase, M_settings) == 0x000168, "Member 'UBFGMentalAbilityBase::M_settings' has a wrong offset!");
static_assert(offsetof(UBFGMentalAbilityBase, M_fTriggerAlertEvent) == 0x0001B0, "Member 'UBFGMentalAbilityBase::M_fTriggerAlertEvent' has a wrong offset!");
static_assert(offsetof(UBFGMentalAbilityBase, M_fCurrentCooldown) == 0x0001B4, "Member 'UBFGMentalAbilityBase::M_fCurrentCooldown' has a wrong offset!");
static_assert(offsetof(UBFGMentalAbilityBase, M_fMentalLinkTimer) == 0x0001B8, "Member 'UBFGMentalAbilityBase::M_fMentalLinkTimer' has a wrong offset!");
static_assert(offsetof(UBFGMentalAbilityBase, M_fEffectTimer) == 0x0001BC, "Member 'UBFGMentalAbilityBase::M_fEffectTimer' has a wrong offset!");
static_assert(offsetof(UBFGMentalAbilityBase, M_eAbilityState) == 0x0001C2, "Member 'UBFGMentalAbilityBase::M_eAbilityState' has a wrong offset!");

// Class BFGCore.BFGMentalAbility_Hypnotize
// 0x0038 (0x0200 - 0x01C8)
class UBFGMentalAbility_Hypnotize : public UBFGMentalAbilityBase
{
public:
	float                                         M_fHypnotizeDuration;                              // 0x01C8(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	int32                                         M_iMaxTargetCount;                                 // 0x01CC(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TArray<TSubclassOf<class UBFGMentalAbilityBase>> M_apRemoveAbilities;                               // 0x01D0(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Protected, UObjectWrapper, NativeAccessSpecifierProtected)
	TSubclassOf<class UBFGMentalAbilityBase>      M_pChainAbility;                                   // 0x01E0(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          M_bDeactivateOnDamage;                             // 0x01E8(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_1E9[0x7];                                      // 0x01E9(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<class UBFGHypnotizeTargetData*>        M_apTargets;                                       // 0x01F0(0x0010)(ZeroConstructor, Transient, Protected, NativeAccessSpecifierProtected)

public:
	void HandleTargetTakeDamage(class UBFGActorComponent_PawnDamage* _pPawnDamage, float _fDamage, class AActor* _pDamageCauser, class UBFGDamageType* _pDamageType, const struct FVector& _rShotDirection, const struct FHitResult& _oHitResult);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"BFGMentalAbility_Hypnotize">();
	}
	static class UBFGMentalAbility_Hypnotize* GetDefaultObj()
	{
		return GetDefaultObjImpl<UBFGMentalAbility_Hypnotize>();
	}
};
static_assert(alignof(UBFGMentalAbility_Hypnotize) == 0x000008, "Wrong alignment on UBFGMentalAbility_Hypnotize");
static_assert(sizeof(UBFGMentalAbility_Hypnotize) == 0x000200, "Wrong size on UBFGMentalAbility_Hypnotize");
static_assert(offsetof(UBFGMentalAbility_Hypnotize, M_fHypnotizeDuration) == 0x0001C8, "Member 'UBFGMentalAbility_Hypnotize::M_fHypnotizeDuration' has a wrong offset!");
static_assert(offsetof(UBFGMentalAbility_Hypnotize, M_iMaxTargetCount) == 0x0001CC, "Member 'UBFGMentalAbility_Hypnotize::M_iMaxTargetCount' has a wrong offset!");
static_assert(offsetof(UBFGMentalAbility_Hypnotize, M_apRemoveAbilities) == 0x0001D0, "Member 'UBFGMentalAbility_Hypnotize::M_apRemoveAbilities' has a wrong offset!");
static_assert(offsetof(UBFGMentalAbility_Hypnotize, M_pChainAbility) == 0x0001E0, "Member 'UBFGMentalAbility_Hypnotize::M_pChainAbility' has a wrong offset!");
static_assert(offsetof(UBFGMentalAbility_Hypnotize, M_bDeactivateOnDamage) == 0x0001E8, "Member 'UBFGMentalAbility_Hypnotize::M_bDeactivateOnDamage' has a wrong offset!");
static_assert(offsetof(UBFGMentalAbility_Hypnotize, M_apTargets) == 0x0001F0, "Member 'UBFGMentalAbility_Hypnotize::M_apTargets' has a wrong offset!");

// Class BFGCore.BFGWidget_IngameMainMenu
// 0x0000 (0x0428 - 0x0428)
class UBFGWidget_IngameMainMenu : public UBFGWidget_GenericDialog
{
public:
	void SetChallengeDisabled(EBFGChallengeType _eType, bool _bDisabled);
	void SetChallengeRating(EBFGChallengeType _eType, int32 _iRating);
	void SetDNAAmount(int32 _iDNAAmount);
	void SetDroneCount(int32 _iMax, int32 _iCurrent);
	void SetWorldInfoEnabled(bool _bEnabled);
	void UpdateWorldDescription(const class FText& _oDescription);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"BFGWidget_IngameMainMenu">();
	}
	static class UBFGWidget_IngameMainMenu* GetDefaultObj()
	{
		return GetDefaultObjImpl<UBFGWidget_IngameMainMenu>();
	}
};
static_assert(alignof(UBFGWidget_IngameMainMenu) == 0x000008, "Wrong alignment on UBFGWidget_IngameMainMenu");
static_assert(sizeof(UBFGWidget_IngameMainMenu) == 0x000428, "Wrong size on UBFGWidget_IngameMainMenu");

// Class BFGCore.BFGActorActivationManager
// 0x0108 (0x0138 - 0x0030)
class UBFGActorActivationManager final : public UBFGGameSystem
{
public:
	class ABFGGameState*                          M_pGameState;                                      // 0x0030(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_38[0x8];                                       // 0x0038(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	TMap<class AActor*, int32>                    M_aIndexTable;                                     // 0x0040(0x0050)(ZeroConstructor, NativeAccessSpecifierPrivate)
	uint8                                         Pad_90[0x10];                                      // 0x0090(0x0010)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<struct FBFGActivationEntry>            M_aEntries;                                        // 0x00A0(0x0010)(ZeroConstructor, ContainsInstancedReference, NativeAccessSpecifierPrivate)
	struct FWidgetPool                            M_DebugWidgetPool;                                 // 0x00B0(0x0070)(ContainsInstancedReference, NativeAccessSpecifierPrivate)
	class UCanvasPanel*                           M_pDebugCanvasPanel;                               // 0x0120(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	TArray<struct FRadarWidgetPair>               M_aDebugWidgetsInUse;                              // 0x0128(0x0010)(ZeroConstructor, ContainsInstancedReference, NativeAccessSpecifierPrivate)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"BFGActorActivationManager">();
	}
	static class UBFGActorActivationManager* GetDefaultObj()
	{
		return GetDefaultObjImpl<UBFGActorActivationManager>();
	}
};
static_assert(alignof(UBFGActorActivationManager) == 0x000008, "Wrong alignment on UBFGActorActivationManager");
static_assert(sizeof(UBFGActorActivationManager) == 0x000138, "Wrong size on UBFGActorActivationManager");
static_assert(offsetof(UBFGActorActivationManager, M_pGameState) == 0x000030, "Member 'UBFGActorActivationManager::M_pGameState' has a wrong offset!");
static_assert(offsetof(UBFGActorActivationManager, M_aIndexTable) == 0x000040, "Member 'UBFGActorActivationManager::M_aIndexTable' has a wrong offset!");
static_assert(offsetof(UBFGActorActivationManager, M_aEntries) == 0x0000A0, "Member 'UBFGActorActivationManager::M_aEntries' has a wrong offset!");
static_assert(offsetof(UBFGActorActivationManager, M_DebugWidgetPool) == 0x0000B0, "Member 'UBFGActorActivationManager::M_DebugWidgetPool' has a wrong offset!");
static_assert(offsetof(UBFGActorActivationManager, M_pDebugCanvasPanel) == 0x000120, "Member 'UBFGActorActivationManager::M_pDebugCanvasPanel' has a wrong offset!");
static_assert(offsetof(UBFGActorActivationManager, M_aDebugWidgetsInUse) == 0x000128, "Member 'UBFGActorActivationManager::M_aDebugWidgetsInUse' has a wrong offset!");

// Class BFGCore.BFGActorAlertSystem
// 0x0030 (0x0408 - 0x03D8)
class ABFGActorAlertSystem final : public AActor
{
public:
	bool                                          M_bAlertSystemEnabled;                             // 0x03D8(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_3D9[0x7];                                      // 0x03D9(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	TSoftObjectPtr<class UBFGAlertSystemDefinitionAsset> AlertSystemDefinitionAsset;                        // 0x03E0(0x0028)(Edit, BlueprintVisible, BlueprintReadOnly, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)

public:
	void EnableAlertSystem(bool Enable);

	bool IsAlertSystemEnabled() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"BFGActorAlertSystem">();
	}
	static class ABFGActorAlertSystem* GetDefaultObj()
	{
		return GetDefaultObjImpl<ABFGActorAlertSystem>();
	}
};
static_assert(alignof(ABFGActorAlertSystem) == 0x000008, "Wrong alignment on ABFGActorAlertSystem");
static_assert(sizeof(ABFGActorAlertSystem) == 0x000408, "Wrong size on ABFGActorAlertSystem");
static_assert(offsetof(ABFGActorAlertSystem, M_bAlertSystemEnabled) == 0x0003D8, "Member 'ABFGActorAlertSystem::M_bAlertSystemEnabled' has a wrong offset!");
static_assert(offsetof(ABFGActorAlertSystem, AlertSystemDefinitionAsset) == 0x0003E0, "Member 'ABFGActorAlertSystem::AlertSystemDefinitionAsset' has a wrong offset!");

// Class BFGCore.BFGLoadingScreenInfo
// 0x00F8 (0x0128 - 0x0030)
class UBFGLoadingScreenInfo final : public UDataAsset
{
public:
	struct FGuid                                  M_guid;                                            // 0x0030(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	EBFGLoadingScreenInfoType                     M_eType;                                           // 0x0040(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_41[0x7];                                       // 0x0041(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	TSoftObjectPtr<class UTexture2D>              M_pTexture;                                        // 0x0048(0x0028)(Edit, BlueprintVisible, BlueprintReadOnly, DisableEditOnInstance, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class FText                                   M_strTitle;                                        // 0x0070(0x0018)(Edit, BlueprintVisible, BlueprintReadOnly, DisableEditOnInstance, Protected, NativeAccessSpecifierProtected)
	struct FBFGLoadingScreenTextFontInfo          M_FontInfo;                                        // 0x0088(0x0040)(Edit, BlueprintVisible, BlueprintReadOnly, DisableEditOnInstance, Protected, NativeAccessSpecifierProtected)
	struct FVector2D                              M_vPaddingForTitle;                                // 0x00C8(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TArray<TSoftObjectPtr<class UDataTable>>      M_aspHints;                                        // 0x00D0(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, Protected, UObjectWrapper, NativeAccessSpecifierProtected)
	struct FBFGLoadingScreenTextFontInfo          M_FontInfoHint;                                    // 0x00E0(0x0040)(Edit, BlueprintVisible, BlueprintReadOnly, DisableEditOnInstance, Protected, NativeAccessSpecifierProtected)
	struct FVector2D                              M_vPaddingForHint;                                 // 0x0120(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"BFGLoadingScreenInfo">();
	}
	static class UBFGLoadingScreenInfo* GetDefaultObj()
	{
		return GetDefaultObjImpl<UBFGLoadingScreenInfo>();
	}
};
static_assert(alignof(UBFGLoadingScreenInfo) == 0x000008, "Wrong alignment on UBFGLoadingScreenInfo");
static_assert(sizeof(UBFGLoadingScreenInfo) == 0x000128, "Wrong size on UBFGLoadingScreenInfo");
static_assert(offsetof(UBFGLoadingScreenInfo, M_guid) == 0x000030, "Member 'UBFGLoadingScreenInfo::M_guid' has a wrong offset!");
static_assert(offsetof(UBFGLoadingScreenInfo, M_eType) == 0x000040, "Member 'UBFGLoadingScreenInfo::M_eType' has a wrong offset!");
static_assert(offsetof(UBFGLoadingScreenInfo, M_pTexture) == 0x000048, "Member 'UBFGLoadingScreenInfo::M_pTexture' has a wrong offset!");
static_assert(offsetof(UBFGLoadingScreenInfo, M_strTitle) == 0x000070, "Member 'UBFGLoadingScreenInfo::M_strTitle' has a wrong offset!");
static_assert(offsetof(UBFGLoadingScreenInfo, M_FontInfo) == 0x000088, "Member 'UBFGLoadingScreenInfo::M_FontInfo' has a wrong offset!");
static_assert(offsetof(UBFGLoadingScreenInfo, M_vPaddingForTitle) == 0x0000C8, "Member 'UBFGLoadingScreenInfo::M_vPaddingForTitle' has a wrong offset!");
static_assert(offsetof(UBFGLoadingScreenInfo, M_aspHints) == 0x0000D0, "Member 'UBFGLoadingScreenInfo::M_aspHints' has a wrong offset!");
static_assert(offsetof(UBFGLoadingScreenInfo, M_FontInfoHint) == 0x0000E0, "Member 'UBFGLoadingScreenInfo::M_FontInfoHint' has a wrong offset!");
static_assert(offsetof(UBFGLoadingScreenInfo, M_vPaddingForHint) == 0x000120, "Member 'UBFGLoadingScreenInfo::M_vPaddingForHint' has a wrong offset!");

// Class BFGCore.BFGEventAction_LocateLayer
// 0x0028 (0x0058 - 0x0030)
class UBFGEventAction_LocateLayer final : public UBFGEventAction
{
public:
	uint8                                         Pad_30[0x8];                                       // 0x0030(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	class UBFGQuest*                              M_pQuest;                                          // 0x0038(0x0008)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UBFGQuest_ElementLocateHint*            M_pLocateHint;                                     // 0x0040(0x0008)(ExportObject, ZeroConstructor, Transient, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_48[0x10];                                      // 0x0048(0x0010)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"BFGEventAction_LocateLayer">();
	}
	static class UBFGEventAction_LocateLayer* GetDefaultObj()
	{
		return GetDefaultObjImpl<UBFGEventAction_LocateLayer>();
	}
};
static_assert(alignof(UBFGEventAction_LocateLayer) == 0x000008, "Wrong alignment on UBFGEventAction_LocateLayer");
static_assert(sizeof(UBFGEventAction_LocateLayer) == 0x000058, "Wrong size on UBFGEventAction_LocateLayer");
static_assert(offsetof(UBFGEventAction_LocateLayer, M_pQuest) == 0x000038, "Member 'UBFGEventAction_LocateLayer::M_pQuest' has a wrong offset!");
static_assert(offsetof(UBFGEventAction_LocateLayer, M_pLocateHint) == 0x000040, "Member 'UBFGEventAction_LocateLayer::M_pLocateHint' has a wrong offset!");

// Class BFGCore.BFGWidget_HUD_TutorialIndicator
// 0x0040 (0x0338 - 0x02F8)
class UBFGWidget_HUD_TutorialIndicator final : public UBFGWidget_HUD
{
public:
	uint8                                         Pad_2F8[0x30];                                     // 0x02F8(0x0030)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         M_fVanishDuration;                                 // 0x0328(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_32C[0xC];                                      // 0x032C(0x000C)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void ActionTutorialIndictorAnimationState__DelegateSignature(EBFGTutorialIndicatorAnimationState _eCurrentState);
	float ComputeSpeedInterpolate();
	float ComputeSpeedPopup();
	float ComputeSpeedVanish();
	void PlayIndicatorHideAnimation();
	void PlayIndicatorShowAnimation();
	void SetIndicatorIcon(const struct FSlateBrush& _slateBrush);
	void SetIndicatorVisibility(bool _bVisible);
	void UpdateIndicatorPosition(const struct FVector2D& _vPosition);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"BFGWidget_HUD_TutorialIndicator">();
	}
	static class UBFGWidget_HUD_TutorialIndicator* GetDefaultObj()
	{
		return GetDefaultObjImpl<UBFGWidget_HUD_TutorialIndicator>();
	}
};
static_assert(alignof(UBFGWidget_HUD_TutorialIndicator) == 0x000008, "Wrong alignment on UBFGWidget_HUD_TutorialIndicator");
static_assert(sizeof(UBFGWidget_HUD_TutorialIndicator) == 0x000338, "Wrong size on UBFGWidget_HUD_TutorialIndicator");
static_assert(offsetof(UBFGWidget_HUD_TutorialIndicator, M_fVanishDuration) == 0x000328, "Member 'UBFGWidget_HUD_TutorialIndicator::M_fVanishDuration' has a wrong offset!");

// Class BFGCore.BFGActorBuilding
// 0x0328 (0x0700 - 0x03D8)
class ABFGActorBuilding : public AActor
{
public:
	uint8                                         Pad_3D8[0x20];                                     // 0x03D8(0x0020)(Fixing Size After Last Property [ Dumper-7 ])
	struct FGameplayTagContainer                  M_gameplayTags;                                    // 0x03F8(0x0020)(Edit, BlueprintVisible, BlueprintReadOnly, NativeAccessSpecifierPublic)
	float                                         M_fLinearDamping;                                  // 0x0418(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_41C[0x4];                                      // 0x041C(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<struct FBFGBuildingElement>            M_aElements;                                       // 0x0420(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, NativeAccessSpecifierPublic)
	class USceneComponent*                        M_pBuildingRoot;                                   // 0x0430(0x0008)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, EditConst, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UBFGActorComponent_PawnStats*           M_pStatsComponent;                                 // 0x0438(0x0008)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, EditConst, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UBFGActorComponent_ExplosiveItem*       M_pExplosiveComponent;                             // 0x0440(0x0008)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, EditConst, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EBFGFaction                                   M_faction;                                         // 0x0448(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_449[0x3];                                      // 0x0449(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         M_fDestructSimulateDuration;                       // 0x044C(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         M_fRadialDamage_0;                                 // 0x0450(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         M_fRadialDamage_1;                                 // 0x0454(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         M_fRadialDamage_2plus;                             // 0x0458(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         M_fRadialDamageScaleFactor_2plus;                  // 0x045C(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         M_fImpulseStrength_Hit;                            // 0x0460(0x0004)(BlueprintVisible, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         M_fImpulseStrength_Center;                         // 0x0464(0x0004)(BlueprintVisible, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         M_fImpulseStrength_Propagation;                    // 0x0468(0x0004)(BlueprintVisible, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_46C[0x4];                                      // 0x046C(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<class UBFGActorComponent_BuildingLevel*> M_aLevelComponents;                                // 0x0470(0x0010)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, ContainsInstancedReference, NativeAccessSpecifierPublic)
	int32                                         M_iDestructLevel;                                  // 0x0480(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         M_fBuildingRadius;                                 // 0x0484(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                M_vLastHitLocation;                                // 0x0488(0x000C)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                M_vLastHitNormal;                                  // 0x0494(0x000C)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         M_fSimulationTime;                                 // 0x04A0(0x0004)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_4A4[0x4];                                      // 0x04A4(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class UBFGActorComponent_PawnDamage*          M_pDamageComponent;                                // 0x04A8(0x0008)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, EditConst, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UBFGActorComponent_Objective*           M_pObjectiveComponent;                             // 0x04B0(0x0008)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, EditConst, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class USceneComponent*                        M_pObjectiveMarkerParentComponent;                 // 0x04B8(0x0008)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, EditConst, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UBFGActorComponent_MonetaryValue*       M_pMonetaryValueComponent;                         // 0x04C0(0x0008)(Edit, ExportObject, ZeroConstructor, EditConst, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UBlastMeshRecordedComponent*            M_pRecordedComponent;                              // 0x04C8(0x0008)(Edit, ExportObject, ZeroConstructor, EditConst, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UBFGActorComponent_Effect*              M_pEffectsComponent;                               // 0x04D0(0x0008)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, EditConst, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_4D8[0x90];                                     // 0x04D8(0x0090)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         M_fNotifyBuildingNotHitAfterDelay;                 // 0x0568(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_56C[0x1C];                                     // 0x056C(0x001C)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<struct FBFGBuildingDestructionCloudEffects> M_aEffects_CS;                                     // 0x0588(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, EditConst, Protected, NativeAccessSpecifierProtected)
	TArray<struct FBFGBuildingDestructionDetailEffects> M_aEffects_DS;                                     // 0x0598(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, EditConst, Protected, NativeAccessSpecifierProtected)
	TArray<struct FBFGBuildingDestructionPropagationEffects> M_aEffects_PS_Explosion;                           // 0x05A8(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, EditConst, Protected, NativeAccessSpecifierProtected)
	TArray<struct FBFGBuildingDestructionPropagationEffects> M_aEffects_PS_Implosion;                           // 0x05B8(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, EditConst, Protected, NativeAccessSpecifierProtected)
	TArray<struct FBFGBuildingFluffEffects>       M_aEffects_FS;                                     // 0x05C8(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, EditConst, Protected, NativeAccessSpecifierProtected)
	TArray<class ABFGDestructionEffect_BuildingFluff*> M_apRuntimeEffects_FS;                             // 0x05D8(0x0010)(ZeroConstructor, Transient, Protected, NativeAccessSpecifierProtected)
	TArray<class ABFGDestructionEffect*>          M_apRuntimeEffects_Detail;                         // 0x05E8(0x0010)(ZeroConstructor, Transient, Protected, NativeAccessSpecifierProtected)
	TArray<class ABFGDestructionEffect*>          M_apDisabledEffects;                               // 0x05F8(0x0010)(ZeroConstructor, Transient, Protected, NativeAccessSpecifierProtected)
	uint8                                         Pad_608[0x10];                                     // 0x0608(0x0010)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<class UStaticMeshComponent*>           M_apRuntimeRuins_Meshes;                           // 0x0618(0x0010)(ExportObject, ZeroConstructor, Transient, ContainsInstancedReference, Protected, NativeAccessSpecifierProtected)
	TArray<class UParticleSystemComponent*>       M_apRuntimeRuins_PFX;                              // 0x0628(0x0010)(ExportObject, ZeroConstructor, Transient, ContainsInstancedReference, Protected, NativeAccessSpecifierProtected)
	TArray<struct FBFGBuildingRuinElement>        M_aRuinElements;                                   // 0x0638(0x0010)(ZeroConstructor, Transient, Protected, NativeAccessSpecifierProtected)
	uint8                                         Pad_648[0x8];                                      // 0x0648(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<class UPrimitiveComponent*>            M_apExplosionMeshes;                               // 0x0650(0x0010)(Edit, BlueprintVisible, ExportObject, ZeroConstructor, Transient, EditConst, ContainsInstancedReference, Protected, NativeAccessSpecifierProtected)
	TArray<class UPrimitiveComponent*>            M_apImplosionMeshes;                               // 0x0660(0x0010)(Edit, BlueprintVisible, ExportObject, ZeroConstructor, Transient, EditConst, ContainsInstancedReference, Protected, NativeAccessSpecifierProtected)
	int32                                         M_iMaxDestructionMeshesSpawnedPerTick;             // 0x0670(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	int32                                         M_iDestructionPosChooser;                          // 0x0674(0x0004)(Edit, BlueprintVisible, ZeroConstructor, Transient, EditConst, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	int32                                         M_iDestructionPropagationIndex;                    // 0x0678(0x0004)(Edit, BlueprintVisible, ZeroConstructor, Transient, EditConst, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          M_bEnableDebugDamage;                              // 0x067C(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, ExposeOnSpawn, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_67D[0x3];                                      // 0x067D(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	int32                                         M_iMaxApplyDamageCallsPerTick;                     // 0x0680(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_684[0x4];                                      // 0x0684(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	TSoftClassPtr<class UClass>                   M_pBuildingHelperClass;                            // 0x0688(0x0028)(Edit, BlueprintVisible, BlueprintReadOnly, DisableEditOnInstance, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TSoftClassPtr<class UClass>                   M_pRuinsHelperClass;                               // 0x06B0(0x0028)(Edit, BlueprintVisible, BlueprintReadOnly, DisableEditOnInstance, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class ABFGBuildingHelper*                     M_pBuildingHelper;                                 // 0x06D8(0x0008)(Edit, BlueprintVisible, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class ABFGBuildingHelper*                     M_pRuinsHelper;                                    // 0x06E0(0x0008)(Edit, BlueprintVisible, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	struct FGuid                                  M_PropsLinkGUID;                                   // 0x06E8(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class ABFGGameState*                          M_pGameState;                                      // 0x06F8(0x0008)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)

public:
	void AddEffect_CS(const struct FBFGBuildingDestructionCloudEffects& _effect);
	void AddEffect_DS(const struct FBFGBuildingDestructionDetailEffects& _effect);
	void AddEffect_FS(const struct FBFGBuildingFluffEffects& _effect);
	void AddEffect_PS(EBFGBuilding_DestructionPhase _ePhase, const struct FBFGBuildingDestructionPropagationEffects& _effect);
	void AddRuinElement(const struct FTransform& _Transform, class UParticleSystem* _pPFX, class UStaticMesh* _pStaticMesh, const TArray<int32>& _aMaterialVariationKeys, const TArray<class UMaterialInterface*>& _aMaterialVariationValues);
	void ApplyMaterialVariation();
	void ApplyRadialDamageToBuilding(EBFGBuilding_DestructionPhase _ePhase, const struct FTransform& _effectTransform, const struct FLatentActionInfo& LatentInfo);
	bool BuildLevel(const struct FBFGBuilding_Level& _levelData);
	bool BuildLevelWithFloorHeight(float* _fFloorHeightInOut, const struct FBFGBuilding_Level& _levelData);
	void ClearAllEffects();
	void ClearDestructionPropagationIndexUseCounts();
	void ClearRuinElements();
	void DestroyAndClearAllSpawnedEffects();
	void DestroyAndClearAllSpawnedRuins();
	void GenerateBuilding();
	int32 IncDestructionPropagationIndexUseCount(int32 _iDPI);
	void InitializeRecording(float _fTime);
	bool IsRecording();
	void OnBuildingNotHitSinceElapsedTime(float _fElapsedTimeWithoutAHit);
	class UBlastMeshComponent* OnCreateBlastMeshComponent(const struct FTransform& _relativeTransform, class UBlastMesh* _pBlastMesh, const struct FBFGBuildingElement& _Element);
	class UGeometryCacheComponent* OnCreateGeometryCacheComponent(const struct FTransform& _relativeTransform, class UGeometryCache* _pGeometryCache, const struct FBFGBuildingElement& _Element);
	void OnTriggerExtraEffectsOnStateChange(EBFGBuilding_DestructionState _eNewState);
	void ResetBuildingForCheckpoint(bool _bDestroyed);
	void SetAttachedActorVisibilityState(bool _bVisible);
	void SetDestructionState(EBFGBuilding_DestructionState _eDestructionState);
	void SetupInitialEffects();
	void SortEffects_CS();
	void SortEffects_DS();
	void SortEffects_PS(EBFGBuilding_DestructionPhase _ePhase);
	void SortEffects_PS_RefLocation(EBFGBuilding_DestructionPhase _ePhase, const struct FVector& _vReferenceLocation);
	void SpawnDestructionEffect_Detail(int32 _iIndex);
	void SpawnDestructionEffects_Clouds();
	void SpawnDestructionEffects_Details();
	void SpawnDestructionEffects_Fluff();
	void SpawnDestructionEffects_Propagation(EBFGBuilding_DestructionPhase _eDestructionPhase);
	void SpawnDestructionMeshes(EBFGBuilding_DestructionPhase _ePhase);
	void SpawnDestructionMeshes_Latent(EBFGBuilding_DestructionPhase _ePhase, const struct FLatentActionInfo& LatentInfo);
	void SpawnRuins();
	void StartDamageEffects(const struct FVector& _vHitAt);
	void StartDisablingSpawnedEffects_Details();
	void StartDisablingSpawnedEffects_Fluff();
	void Stat_IsDeadChanged(class AActor* _pActor, class UBFGActorStat_Bool* _pStat);
	void UpdateDamageEffects(const struct FVector& _vHitAt);
	void UpdateRecordingComponent(float _fTimeDelta);
	void UpdateRuntimeDestructState(float _fDeltaTime);

	int32 CalcSumDestructionPropagationIndexUseCounts() const;
	int32 GetDestructionPropagationIndexUseCount(int32 _iDPI) const;
	EBFGBuilding_DestructionState GetDestructionState() const;
	const TArray<struct FBFGBuildingDestructionPropagationEffects> GetEffects_PS(EBFGBuilding_DestructionPhase _ePhase) const;
	struct FHitResult GetLastHitResult() const;
	TSubclassOf<class ABFGBuildingHelper> GetOrLoadBuildingHelperClass() const;
	TSubclassOf<class ABFGBuildingHelper> GetOrLoadRuinsHelperClass() const;
	bool HasEffectWithSocketName_CS(const class FName& _socketName) const;
	bool HasEffectWithSocketName_DS(const class FName& _socketName) const;
	bool HasEffectWithSocketName_FS(const class FName& _socketName) const;
	bool HasEffectWithSocketName_PS(EBFGBuilding_DestructionPhase _ePhase, const class FName& _socketName) const;
	bool IsDead() const;
	void SetPropsShouldBeVisible(bool _bShouldBeVisible) const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"BFGActorBuilding">();
	}
	static class ABFGActorBuilding* GetDefaultObj()
	{
		return GetDefaultObjImpl<ABFGActorBuilding>();
	}
};
static_assert(alignof(ABFGActorBuilding) == 0x000008, "Wrong alignment on ABFGActorBuilding");
static_assert(sizeof(ABFGActorBuilding) == 0x000700, "Wrong size on ABFGActorBuilding");
static_assert(offsetof(ABFGActorBuilding, M_gameplayTags) == 0x0003F8, "Member 'ABFGActorBuilding::M_gameplayTags' has a wrong offset!");
static_assert(offsetof(ABFGActorBuilding, M_fLinearDamping) == 0x000418, "Member 'ABFGActorBuilding::M_fLinearDamping' has a wrong offset!");
static_assert(offsetof(ABFGActorBuilding, M_aElements) == 0x000420, "Member 'ABFGActorBuilding::M_aElements' has a wrong offset!");
static_assert(offsetof(ABFGActorBuilding, M_pBuildingRoot) == 0x000430, "Member 'ABFGActorBuilding::M_pBuildingRoot' has a wrong offset!");
static_assert(offsetof(ABFGActorBuilding, M_pStatsComponent) == 0x000438, "Member 'ABFGActorBuilding::M_pStatsComponent' has a wrong offset!");
static_assert(offsetof(ABFGActorBuilding, M_pExplosiveComponent) == 0x000440, "Member 'ABFGActorBuilding::M_pExplosiveComponent' has a wrong offset!");
static_assert(offsetof(ABFGActorBuilding, M_faction) == 0x000448, "Member 'ABFGActorBuilding::M_faction' has a wrong offset!");
static_assert(offsetof(ABFGActorBuilding, M_fDestructSimulateDuration) == 0x00044C, "Member 'ABFGActorBuilding::M_fDestructSimulateDuration' has a wrong offset!");
static_assert(offsetof(ABFGActorBuilding, M_fRadialDamage_0) == 0x000450, "Member 'ABFGActorBuilding::M_fRadialDamage_0' has a wrong offset!");
static_assert(offsetof(ABFGActorBuilding, M_fRadialDamage_1) == 0x000454, "Member 'ABFGActorBuilding::M_fRadialDamage_1' has a wrong offset!");
static_assert(offsetof(ABFGActorBuilding, M_fRadialDamage_2plus) == 0x000458, "Member 'ABFGActorBuilding::M_fRadialDamage_2plus' has a wrong offset!");
static_assert(offsetof(ABFGActorBuilding, M_fRadialDamageScaleFactor_2plus) == 0x00045C, "Member 'ABFGActorBuilding::M_fRadialDamageScaleFactor_2plus' has a wrong offset!");
static_assert(offsetof(ABFGActorBuilding, M_fImpulseStrength_Hit) == 0x000460, "Member 'ABFGActorBuilding::M_fImpulseStrength_Hit' has a wrong offset!");
static_assert(offsetof(ABFGActorBuilding, M_fImpulseStrength_Center) == 0x000464, "Member 'ABFGActorBuilding::M_fImpulseStrength_Center' has a wrong offset!");
static_assert(offsetof(ABFGActorBuilding, M_fImpulseStrength_Propagation) == 0x000468, "Member 'ABFGActorBuilding::M_fImpulseStrength_Propagation' has a wrong offset!");
static_assert(offsetof(ABFGActorBuilding, M_aLevelComponents) == 0x000470, "Member 'ABFGActorBuilding::M_aLevelComponents' has a wrong offset!");
static_assert(offsetof(ABFGActorBuilding, M_iDestructLevel) == 0x000480, "Member 'ABFGActorBuilding::M_iDestructLevel' has a wrong offset!");
static_assert(offsetof(ABFGActorBuilding, M_fBuildingRadius) == 0x000484, "Member 'ABFGActorBuilding::M_fBuildingRadius' has a wrong offset!");
static_assert(offsetof(ABFGActorBuilding, M_vLastHitLocation) == 0x000488, "Member 'ABFGActorBuilding::M_vLastHitLocation' has a wrong offset!");
static_assert(offsetof(ABFGActorBuilding, M_vLastHitNormal) == 0x000494, "Member 'ABFGActorBuilding::M_vLastHitNormal' has a wrong offset!");
static_assert(offsetof(ABFGActorBuilding, M_fSimulationTime) == 0x0004A0, "Member 'ABFGActorBuilding::M_fSimulationTime' has a wrong offset!");
static_assert(offsetof(ABFGActorBuilding, M_pDamageComponent) == 0x0004A8, "Member 'ABFGActorBuilding::M_pDamageComponent' has a wrong offset!");
static_assert(offsetof(ABFGActorBuilding, M_pObjectiveComponent) == 0x0004B0, "Member 'ABFGActorBuilding::M_pObjectiveComponent' has a wrong offset!");
static_assert(offsetof(ABFGActorBuilding, M_pObjectiveMarkerParentComponent) == 0x0004B8, "Member 'ABFGActorBuilding::M_pObjectiveMarkerParentComponent' has a wrong offset!");
static_assert(offsetof(ABFGActorBuilding, M_pMonetaryValueComponent) == 0x0004C0, "Member 'ABFGActorBuilding::M_pMonetaryValueComponent' has a wrong offset!");
static_assert(offsetof(ABFGActorBuilding, M_pRecordedComponent) == 0x0004C8, "Member 'ABFGActorBuilding::M_pRecordedComponent' has a wrong offset!");
static_assert(offsetof(ABFGActorBuilding, M_pEffectsComponent) == 0x0004D0, "Member 'ABFGActorBuilding::M_pEffectsComponent' has a wrong offset!");
static_assert(offsetof(ABFGActorBuilding, M_fNotifyBuildingNotHitAfterDelay) == 0x000568, "Member 'ABFGActorBuilding::M_fNotifyBuildingNotHitAfterDelay' has a wrong offset!");
static_assert(offsetof(ABFGActorBuilding, M_aEffects_CS) == 0x000588, "Member 'ABFGActorBuilding::M_aEffects_CS' has a wrong offset!");
static_assert(offsetof(ABFGActorBuilding, M_aEffects_DS) == 0x000598, "Member 'ABFGActorBuilding::M_aEffects_DS' has a wrong offset!");
static_assert(offsetof(ABFGActorBuilding, M_aEffects_PS_Explosion) == 0x0005A8, "Member 'ABFGActorBuilding::M_aEffects_PS_Explosion' has a wrong offset!");
static_assert(offsetof(ABFGActorBuilding, M_aEffects_PS_Implosion) == 0x0005B8, "Member 'ABFGActorBuilding::M_aEffects_PS_Implosion' has a wrong offset!");
static_assert(offsetof(ABFGActorBuilding, M_aEffects_FS) == 0x0005C8, "Member 'ABFGActorBuilding::M_aEffects_FS' has a wrong offset!");
static_assert(offsetof(ABFGActorBuilding, M_apRuntimeEffects_FS) == 0x0005D8, "Member 'ABFGActorBuilding::M_apRuntimeEffects_FS' has a wrong offset!");
static_assert(offsetof(ABFGActorBuilding, M_apRuntimeEffects_Detail) == 0x0005E8, "Member 'ABFGActorBuilding::M_apRuntimeEffects_Detail' has a wrong offset!");
static_assert(offsetof(ABFGActorBuilding, M_apDisabledEffects) == 0x0005F8, "Member 'ABFGActorBuilding::M_apDisabledEffects' has a wrong offset!");
static_assert(offsetof(ABFGActorBuilding, M_apRuntimeRuins_Meshes) == 0x000618, "Member 'ABFGActorBuilding::M_apRuntimeRuins_Meshes' has a wrong offset!");
static_assert(offsetof(ABFGActorBuilding, M_apRuntimeRuins_PFX) == 0x000628, "Member 'ABFGActorBuilding::M_apRuntimeRuins_PFX' has a wrong offset!");
static_assert(offsetof(ABFGActorBuilding, M_aRuinElements) == 0x000638, "Member 'ABFGActorBuilding::M_aRuinElements' has a wrong offset!");
static_assert(offsetof(ABFGActorBuilding, M_apExplosionMeshes) == 0x000650, "Member 'ABFGActorBuilding::M_apExplosionMeshes' has a wrong offset!");
static_assert(offsetof(ABFGActorBuilding, M_apImplosionMeshes) == 0x000660, "Member 'ABFGActorBuilding::M_apImplosionMeshes' has a wrong offset!");
static_assert(offsetof(ABFGActorBuilding, M_iMaxDestructionMeshesSpawnedPerTick) == 0x000670, "Member 'ABFGActorBuilding::M_iMaxDestructionMeshesSpawnedPerTick' has a wrong offset!");
static_assert(offsetof(ABFGActorBuilding, M_iDestructionPosChooser) == 0x000674, "Member 'ABFGActorBuilding::M_iDestructionPosChooser' has a wrong offset!");
static_assert(offsetof(ABFGActorBuilding, M_iDestructionPropagationIndex) == 0x000678, "Member 'ABFGActorBuilding::M_iDestructionPropagationIndex' has a wrong offset!");
static_assert(offsetof(ABFGActorBuilding, M_bEnableDebugDamage) == 0x00067C, "Member 'ABFGActorBuilding::M_bEnableDebugDamage' has a wrong offset!");
static_assert(offsetof(ABFGActorBuilding, M_iMaxApplyDamageCallsPerTick) == 0x000680, "Member 'ABFGActorBuilding::M_iMaxApplyDamageCallsPerTick' has a wrong offset!");
static_assert(offsetof(ABFGActorBuilding, M_pBuildingHelperClass) == 0x000688, "Member 'ABFGActorBuilding::M_pBuildingHelperClass' has a wrong offset!");
static_assert(offsetof(ABFGActorBuilding, M_pRuinsHelperClass) == 0x0006B0, "Member 'ABFGActorBuilding::M_pRuinsHelperClass' has a wrong offset!");
static_assert(offsetof(ABFGActorBuilding, M_pBuildingHelper) == 0x0006D8, "Member 'ABFGActorBuilding::M_pBuildingHelper' has a wrong offset!");
static_assert(offsetof(ABFGActorBuilding, M_pRuinsHelper) == 0x0006E0, "Member 'ABFGActorBuilding::M_pRuinsHelper' has a wrong offset!");
static_assert(offsetof(ABFGActorBuilding, M_PropsLinkGUID) == 0x0006E8, "Member 'ABFGActorBuilding::M_PropsLinkGUID' has a wrong offset!");
static_assert(offsetof(ABFGActorBuilding, M_pGameState) == 0x0006F8, "Member 'ABFGActorBuilding::M_pGameState' has a wrong offset!");

// Class BFGCore.BFGAutoPickupItem
// 0x0090 (0x04B8 - 0x0428)
class ABFGAutoPickupItem : public ABFGInteractable
{
public:
	uint8                                         Pad_428[0x18];                                     // 0x0428(0x0018)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         M_fRadius;                                         // 0x0440(0x0004)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          M_bIsVisibleFromSaucer;                            // 0x0444(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          M_bIsVisibleFromGround;                            // 0x0445(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          M_bIsCollectionEnabled;                            // 0x0446(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          M_bCanBeCollectedWithAnalProbe;                    // 0x0447(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          M_bIgnoreChangeVisibilityOnPlayerPawnChanged;      // 0x0448(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          M_bRegisterWithPlayerState;                        // 0x0449(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_44A[0x2];                                      // 0x044A(0x0002)(Fixing Size After Last Property [ Dumper-7 ])
	bool                                          M_bFalling;                                        // 0x044C(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_44D[0x3];                                      // 0x044D(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         M_fFallTime;                                       // 0x0450(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_454[0x4];                                      // 0x0454(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         M_fFallHeight;                                     // 0x0458(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_45C[0x20];                                     // 0x045C(0x0020)(Fixing Size After Last Property [ Dumper-7 ])
	bool                                          M_bFlying;                                         // 0x047C(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_47D[0x3];                                      // 0x047D(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         M_fFlyTime;                                        // 0x0480(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_484[0x4];                                      // 0x0484(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         M_fFlyHeight;                                      // 0x0488(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_48C[0x24];                                     // 0x048C(0x0024)(Fixing Size After Last Property [ Dumper-7 ])
	class UBFGActorComponent_Magnet*              M_pCachedMagnet;                                   // 0x04B0(0x0008)(ExportObject, ZeroConstructor, Transient, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)

public:
	void OnCollected(class AActor* PCollectedBy);
	void OnInteractableBeginOverlap(class UPrimitiveComponent* _pOverlappedComponent, class AActor* _pOtherActor, class UPrimitiveComponent* _pOtherComponent, int32 _iOtherBodyIndex, bool _bFromSweep, const struct FHitResult& _sweepResult);
	void OnPlayerPawnChanged(class APawn* _pPawn);
	void SetFalling(bool _bFalling, const TArray<class AActor*>& _apFallIgnoreActors, float _fFallDelay, float _fHeightOffset);
	void SetFlying(bool _bFlying, float _fFlyHeight, float _fFlyDelay);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"BFGAutoPickupItem">();
	}
	static class ABFGAutoPickupItem* GetDefaultObj()
	{
		return GetDefaultObjImpl<ABFGAutoPickupItem>();
	}
};
static_assert(alignof(ABFGAutoPickupItem) == 0x000008, "Wrong alignment on ABFGAutoPickupItem");
static_assert(sizeof(ABFGAutoPickupItem) == 0x0004B8, "Wrong size on ABFGAutoPickupItem");
static_assert(offsetof(ABFGAutoPickupItem, M_fRadius) == 0x000440, "Member 'ABFGAutoPickupItem::M_fRadius' has a wrong offset!");
static_assert(offsetof(ABFGAutoPickupItem, M_bIsVisibleFromSaucer) == 0x000444, "Member 'ABFGAutoPickupItem::M_bIsVisibleFromSaucer' has a wrong offset!");
static_assert(offsetof(ABFGAutoPickupItem, M_bIsVisibleFromGround) == 0x000445, "Member 'ABFGAutoPickupItem::M_bIsVisibleFromGround' has a wrong offset!");
static_assert(offsetof(ABFGAutoPickupItem, M_bIsCollectionEnabled) == 0x000446, "Member 'ABFGAutoPickupItem::M_bIsCollectionEnabled' has a wrong offset!");
static_assert(offsetof(ABFGAutoPickupItem, M_bCanBeCollectedWithAnalProbe) == 0x000447, "Member 'ABFGAutoPickupItem::M_bCanBeCollectedWithAnalProbe' has a wrong offset!");
static_assert(offsetof(ABFGAutoPickupItem, M_bIgnoreChangeVisibilityOnPlayerPawnChanged) == 0x000448, "Member 'ABFGAutoPickupItem::M_bIgnoreChangeVisibilityOnPlayerPawnChanged' has a wrong offset!");
static_assert(offsetof(ABFGAutoPickupItem, M_bRegisterWithPlayerState) == 0x000449, "Member 'ABFGAutoPickupItem::M_bRegisterWithPlayerState' has a wrong offset!");
static_assert(offsetof(ABFGAutoPickupItem, M_bFalling) == 0x00044C, "Member 'ABFGAutoPickupItem::M_bFalling' has a wrong offset!");
static_assert(offsetof(ABFGAutoPickupItem, M_fFallTime) == 0x000450, "Member 'ABFGAutoPickupItem::M_fFallTime' has a wrong offset!");
static_assert(offsetof(ABFGAutoPickupItem, M_fFallHeight) == 0x000458, "Member 'ABFGAutoPickupItem::M_fFallHeight' has a wrong offset!");
static_assert(offsetof(ABFGAutoPickupItem, M_bFlying) == 0x00047C, "Member 'ABFGAutoPickupItem::M_bFlying' has a wrong offset!");
static_assert(offsetof(ABFGAutoPickupItem, M_fFlyTime) == 0x000480, "Member 'ABFGAutoPickupItem::M_fFlyTime' has a wrong offset!");
static_assert(offsetof(ABFGAutoPickupItem, M_fFlyHeight) == 0x000488, "Member 'ABFGAutoPickupItem::M_fFlyHeight' has a wrong offset!");
static_assert(offsetof(ABFGAutoPickupItem, M_pCachedMagnet) == 0x0004B0, "Member 'ABFGAutoPickupItem::M_pCachedMagnet' has a wrong offset!");

// Class BFGCore.BFGItemValuePack
// 0x0010 (0x04C8 - 0x04B8)
class ABFGItemValuePack : public ABFGAutoPickupItem
{
public:
	EItemValueTypeEnum                            M_eValueType;                                      // 0x04B8(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          M_bCanAlwaysBeCollected;                           // 0x04B9(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_4BA[0x2];                                      // 0x04BA(0x0002)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         M_fValueAmount;                                    // 0x04BC(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class ABFGActorProxyCollect*                  M_pOwningProxy;                                    // 0x04C0(0x0008)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"BFGItemValuePack">();
	}
	static class ABFGItemValuePack* GetDefaultObj()
	{
		return GetDefaultObjImpl<ABFGItemValuePack>();
	}
};
static_assert(alignof(ABFGItemValuePack) == 0x000008, "Wrong alignment on ABFGItemValuePack");
static_assert(sizeof(ABFGItemValuePack) == 0x0004C8, "Wrong size on ABFGItemValuePack");
static_assert(offsetof(ABFGItemValuePack, M_eValueType) == 0x0004B8, "Member 'ABFGItemValuePack::M_eValueType' has a wrong offset!");
static_assert(offsetof(ABFGItemValuePack, M_bCanAlwaysBeCollected) == 0x0004B9, "Member 'ABFGItemValuePack::M_bCanAlwaysBeCollected' has a wrong offset!");
static_assert(offsetof(ABFGItemValuePack, M_fValueAmount) == 0x0004BC, "Member 'ABFGItemValuePack::M_fValueAmount' has a wrong offset!");
static_assert(offsetof(ABFGItemValuePack, M_pOwningProxy) == 0x0004C0, "Member 'ABFGItemValuePack::M_pOwningProxy' has a wrong offset!");

// Class BFGCore.BFGPickUpSpawner
// 0x0020 (0x03F8 - 0x03D8)
class ABFGPickUpSpawner final : public AActor
{
public:
	int32                                         M_iPhaseRelated;                                   // 0x03D8(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_3DC[0x4];                                      // 0x03DC(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<class ABFGItemValuePack*>              M_apPickUps;                                       // 0x03E0(0x0010)(Edit, ZeroConstructor, NativeAccessSpecifierPublic)
	TSubclassOf<class ABFGEffectActor>            M_pEffectActorClass;                               // 0x03F0(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"BFGPickUpSpawner">();
	}
	static class ABFGPickUpSpawner* GetDefaultObj()
	{
		return GetDefaultObjImpl<ABFGPickUpSpawner>();
	}
};
static_assert(alignof(ABFGPickUpSpawner) == 0x000008, "Wrong alignment on ABFGPickUpSpawner");
static_assert(sizeof(ABFGPickUpSpawner) == 0x0003F8, "Wrong size on ABFGPickUpSpawner");
static_assert(offsetof(ABFGPickUpSpawner, M_iPhaseRelated) == 0x0003D8, "Member 'ABFGPickUpSpawner::M_iPhaseRelated' has a wrong offset!");
static_assert(offsetof(ABFGPickUpSpawner, M_apPickUps) == 0x0003E0, "Member 'ABFGPickUpSpawner::M_apPickUps' has a wrong offset!");
static_assert(offsetof(ABFGPickUpSpawner, M_pEffectActorClass) == 0x0003F0, "Member 'ABFGPickUpSpawner::M_pEffectActorClass' has a wrong offset!");

// Class BFGCore.BFGActorComponent_AIAnimations
// 0x0010 (0x0138 - 0x0128)
class UBFGActorComponent_AIAnimations final : public UActorComponent
{
public:
	struct FGameplayTag                           M_activeFullbodyAnimation;                         // 0x0128(0x0008)(Net, RepNotify, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_130[0x8];                                      // 0x0130(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void OnRep_ActiveFullbodyAnimation();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"BFGActorComponent_AIAnimations">();
	}
	static class UBFGActorComponent_AIAnimations* GetDefaultObj()
	{
		return GetDefaultObjImpl<UBFGActorComponent_AIAnimations>();
	}
};
static_assert(alignof(UBFGActorComponent_AIAnimations) == 0x000008, "Wrong alignment on UBFGActorComponent_AIAnimations");
static_assert(sizeof(UBFGActorComponent_AIAnimations) == 0x000138, "Wrong size on UBFGActorComponent_AIAnimations");
static_assert(offsetof(UBFGActorComponent_AIAnimations, M_activeFullbodyAnimation) == 0x000128, "Member 'UBFGActorComponent_AIAnimations::M_activeFullbodyAnimation' has a wrong offset!");

// Class BFGCore.BFGEventAction_PlaySequence
// 0x00A8 (0x00D8 - 0x0030)
class UBFGEventAction_PlaySequence final : public UBFGEventAction
{
public:
	uint8                                         Pad_30[0x80];                                      // 0x0030(0x0080)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<struct FBFGSequence_DynamicActorBinding> M_aBindings;                                       // 0x00B0(0x0010)(ZeroConstructor, Transient, Protected, NativeAccessSpecifierProtected)
	class UBFGSequenceRequest*                    M_pSequenceRequest;                                // 0x00C0(0x0008)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UBFGNarrativeSequence*                  M_pNarrativeSequence;                              // 0x00C8(0x0008)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_D0[0x8];                                       // 0x00D0(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"BFGEventAction_PlaySequence">();
	}
	static class UBFGEventAction_PlaySequence* GetDefaultObj()
	{
		return GetDefaultObjImpl<UBFGEventAction_PlaySequence>();
	}
};
static_assert(alignof(UBFGEventAction_PlaySequence) == 0x000008, "Wrong alignment on UBFGEventAction_PlaySequence");
static_assert(sizeof(UBFGEventAction_PlaySequence) == 0x0000D8, "Wrong size on UBFGEventAction_PlaySequence");
static_assert(offsetof(UBFGEventAction_PlaySequence, M_aBindings) == 0x0000B0, "Member 'UBFGEventAction_PlaySequence::M_aBindings' has a wrong offset!");
static_assert(offsetof(UBFGEventAction_PlaySequence, M_pSequenceRequest) == 0x0000C0, "Member 'UBFGEventAction_PlaySequence::M_pSequenceRequest' has a wrong offset!");
static_assert(offsetof(UBFGEventAction_PlaySequence, M_pNarrativeSequence) == 0x0000C8, "Member 'UBFGEventAction_PlaySequence::M_pNarrativeSequence' has a wrong offset!");

// Class BFGCore.BFGSensor
// 0x0018 (0x0040 - 0x0028)
class UBFGSensor : public UObject
{
public:
	TArray<EBFGBehaviourState_NPC>                M_aActivateStates;                                 // 0x0028(0x0010)(Edit, ZeroConstructor, Protected, NativeAccessSpecifierProtected)
	bool                                          M_bInverseStates;                                  // 0x0038(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          M_bRequiresHiresActor;                             // 0x0039(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_3A[0x6];                                       // 0x003A(0x0006)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"BFGSensor">();
	}
	static class UBFGSensor* GetDefaultObj()
	{
		return GetDefaultObjImpl<UBFGSensor>();
	}
};
static_assert(alignof(UBFGSensor) == 0x000008, "Wrong alignment on UBFGSensor");
static_assert(sizeof(UBFGSensor) == 0x000040, "Wrong size on UBFGSensor");
static_assert(offsetof(UBFGSensor, M_aActivateStates) == 0x000028, "Member 'UBFGSensor::M_aActivateStates' has a wrong offset!");
static_assert(offsetof(UBFGSensor, M_bInverseStates) == 0x000038, "Member 'UBFGSensor::M_bInverseStates' has a wrong offset!");
static_assert(offsetof(UBFGSensor, M_bRequiresHiresActor) == 0x000039, "Member 'UBFGSensor::M_bRequiresHiresActor' has a wrong offset!");

// Class BFGCore.BFGSensor_Aggression
// 0x0008 (0x0048 - 0x0040)
class UBFGSensor_Aggression final : public UBFGSensor
{
public:
	float                                         M_fMaxDistToNPC;                                   // 0x0040(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_44[0x4];                                       // 0x0044(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"BFGSensor_Aggression">();
	}
	static class UBFGSensor_Aggression* GetDefaultObj()
	{
		return GetDefaultObjImpl<UBFGSensor_Aggression>();
	}
};
static_assert(alignof(UBFGSensor_Aggression) == 0x000008, "Wrong alignment on UBFGSensor_Aggression");
static_assert(sizeof(UBFGSensor_Aggression) == 0x000048, "Wrong size on UBFGSensor_Aggression");
static_assert(offsetof(UBFGSensor_Aggression, M_fMaxDistToNPC) == 0x000040, "Member 'UBFGSensor_Aggression::M_fMaxDistToNPC' has a wrong offset!");

// Class BFGCore.BFGActorComponent_AimAssistTarget
// 0x0010 (0x0138 - 0x0128)
class UBFGActorComponent_AimAssistTarget final : public UActorComponent
{
public:
	class UBFGAimAssistManager*                   M_pManager;                                        // 0x0128(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class USceneComponent*                        M_pComponentOverride;                              // 0x0130(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"BFGActorComponent_AimAssistTarget">();
	}
	static class UBFGActorComponent_AimAssistTarget* GetDefaultObj()
	{
		return GetDefaultObjImpl<UBFGActorComponent_AimAssistTarget>();
	}
};
static_assert(alignof(UBFGActorComponent_AimAssistTarget) == 0x000008, "Wrong alignment on UBFGActorComponent_AimAssistTarget");
static_assert(sizeof(UBFGActorComponent_AimAssistTarget) == 0x000138, "Wrong size on UBFGActorComponent_AimAssistTarget");
static_assert(offsetof(UBFGActorComponent_AimAssistTarget, M_pManager) == 0x000128, "Member 'UBFGActorComponent_AimAssistTarget::M_pManager' has a wrong offset!");
static_assert(offsetof(UBFGActorComponent_AimAssistTarget, M_pComponentOverride) == 0x000130, "Member 'UBFGActorComponent_AimAssistTarget::M_pComponentOverride' has a wrong offset!");

// Class BFGCore.BFGActorComponent_AIReactions
// 0x0078 (0x01A0 - 0x0128)
class UBFGActorComponent_AIReactions final : public UActorComponent
{
public:
	class FName                                   M_bbKeyOverlappingCrypto;                          // 0x0128(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   M_bbKeyOverlappingBlockingHit;                     // 0x0130(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   M_bbKeyStunned;                                    // 0x0138(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FGameplayTagContainer                  M_aStunTags;                                       // 0x0140(0x0020)(Edit, NativeAccessSpecifierPublic)
	bool                                          M_bCheckOverlappingCrypto;                         // 0x0160(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          M_bCheckOverlappingBlockingHit;                    // 0x0161(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_162[0x6];                                      // 0x0162(0x0006)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<TSubclassOf<class AActor>>             M_apOverlappingHitCheckClasses;                    // 0x0168(0x0010)(Edit, ZeroConstructor, UObjectWrapper, NativeAccessSpecifierPublic)
	bool                                          M_bDrawDebug;                                      // 0x0178(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_179[0x7];                                      // 0x0179(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	class UBlackboardComponent*                   M_pBlackboardComponent;                            // 0x0180(0x0008)(ExportObject, ZeroConstructor, Transient, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UBFGActorComponent_NPCCharacterMovement* M_pCharacterMovementComponent;                     // 0x0188(0x0008)(ExportObject, ZeroConstructor, Transient, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UBFGActorComponent_GameplayEffectTags*  M_pGameplayEffectTags;                             // 0x0190(0x0008)(ExportObject, ZeroConstructor, Transient, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_198[0x8];                                      // 0x0198(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void OnActorHit(class AActor* _pSelfActor, class AActor* _pOtherActor, const struct FVector& _vNormalImpulse, const struct FHitResult& _hitResult);
	void OnTagsChanged(const struct FGameplayTag& _rTag);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"BFGActorComponent_AIReactions">();
	}
	static class UBFGActorComponent_AIReactions* GetDefaultObj()
	{
		return GetDefaultObjImpl<UBFGActorComponent_AIReactions>();
	}
};
static_assert(alignof(UBFGActorComponent_AIReactions) == 0x000008, "Wrong alignment on UBFGActorComponent_AIReactions");
static_assert(sizeof(UBFGActorComponent_AIReactions) == 0x0001A0, "Wrong size on UBFGActorComponent_AIReactions");
static_assert(offsetof(UBFGActorComponent_AIReactions, M_bbKeyOverlappingCrypto) == 0x000128, "Member 'UBFGActorComponent_AIReactions::M_bbKeyOverlappingCrypto' has a wrong offset!");
static_assert(offsetof(UBFGActorComponent_AIReactions, M_bbKeyOverlappingBlockingHit) == 0x000130, "Member 'UBFGActorComponent_AIReactions::M_bbKeyOverlappingBlockingHit' has a wrong offset!");
static_assert(offsetof(UBFGActorComponent_AIReactions, M_bbKeyStunned) == 0x000138, "Member 'UBFGActorComponent_AIReactions::M_bbKeyStunned' has a wrong offset!");
static_assert(offsetof(UBFGActorComponent_AIReactions, M_aStunTags) == 0x000140, "Member 'UBFGActorComponent_AIReactions::M_aStunTags' has a wrong offset!");
static_assert(offsetof(UBFGActorComponent_AIReactions, M_bCheckOverlappingCrypto) == 0x000160, "Member 'UBFGActorComponent_AIReactions::M_bCheckOverlappingCrypto' has a wrong offset!");
static_assert(offsetof(UBFGActorComponent_AIReactions, M_bCheckOverlappingBlockingHit) == 0x000161, "Member 'UBFGActorComponent_AIReactions::M_bCheckOverlappingBlockingHit' has a wrong offset!");
static_assert(offsetof(UBFGActorComponent_AIReactions, M_apOverlappingHitCheckClasses) == 0x000168, "Member 'UBFGActorComponent_AIReactions::M_apOverlappingHitCheckClasses' has a wrong offset!");
static_assert(offsetof(UBFGActorComponent_AIReactions, M_bDrawDebug) == 0x000178, "Member 'UBFGActorComponent_AIReactions::M_bDrawDebug' has a wrong offset!");
static_assert(offsetof(UBFGActorComponent_AIReactions, M_pBlackboardComponent) == 0x000180, "Member 'UBFGActorComponent_AIReactions::M_pBlackboardComponent' has a wrong offset!");
static_assert(offsetof(UBFGActorComponent_AIReactions, M_pCharacterMovementComponent) == 0x000188, "Member 'UBFGActorComponent_AIReactions::M_pCharacterMovementComponent' has a wrong offset!");
static_assert(offsetof(UBFGActorComponent_AIReactions, M_pGameplayEffectTags) == 0x000190, "Member 'UBFGActorComponent_AIReactions::M_pGameplayEffectTags' has a wrong offset!");

// Class BFGCore.BFGEventAction_MakeMentallyInteractable
// 0x0098 (0x00C8 - 0x0030)
class UBFGEventAction_MakeMentallyInteractable final : public UBFGEventAction
{
public:
	uint8                                         Pad_30[0x98];                                      // 0x0030(0x0098)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"BFGEventAction_MakeMentallyInteractable">();
	}
	static class UBFGEventAction_MakeMentallyInteractable* GetDefaultObj()
	{
		return GetDefaultObjImpl<UBFGEventAction_MakeMentallyInteractable>();
	}
};
static_assert(alignof(UBFGEventAction_MakeMentallyInteractable) == 0x000008, "Wrong alignment on UBFGEventAction_MakeMentallyInteractable");
static_assert(sizeof(UBFGEventAction_MakeMentallyInteractable) == 0x0000C8, "Wrong size on UBFGEventAction_MakeMentallyInteractable");

// Class BFGCore.BFGSensor_Alerted_CombatReachability
// 0x0030 (0x0070 - 0x0040)
class UBFGSensor_Alerted_CombatReachability final : public UBFGSensor
{
public:
	struct FBlackboardKeySelector                 M_BBKeyCombatState;                                // 0x0040(0x0028)(Edit, NativeAccessSpecifierPublic)
	float                                         M_fStuckTimeout;                                   // 0x0068(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_6C[0x4];                                       // 0x006C(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"BFGSensor_Alerted_CombatReachability">();
	}
	static class UBFGSensor_Alerted_CombatReachability* GetDefaultObj()
	{
		return GetDefaultObjImpl<UBFGSensor_Alerted_CombatReachability>();
	}
};
static_assert(alignof(UBFGSensor_Alerted_CombatReachability) == 0x000008, "Wrong alignment on UBFGSensor_Alerted_CombatReachability");
static_assert(sizeof(UBFGSensor_Alerted_CombatReachability) == 0x000070, "Wrong size on UBFGSensor_Alerted_CombatReachability");
static_assert(offsetof(UBFGSensor_Alerted_CombatReachability, M_BBKeyCombatState) == 0x000040, "Member 'UBFGSensor_Alerted_CombatReachability::M_BBKeyCombatState' has a wrong offset!");
static_assert(offsetof(UBFGSensor_Alerted_CombatReachability, M_fStuckTimeout) == 0x000068, "Member 'UBFGSensor_Alerted_CombatReachability::M_fStuckTimeout' has a wrong offset!");

// Class BFGCore.BFGActorComponent_AITarget
// 0x0038 (0x0160 - 0x0128)
class UBFGActorComponent_AITarget final : public UActorComponent
{
public:
	uint8                                         Pad_128[0x8];                                      // 0x0128(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	class UBFGActorComponent_GameplayEffectTags*  M_pGameplayEffectTags;                             // 0x0130(0x0008)(ExportObject, ZeroConstructor, Transient, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UBFGActorComponent_MissionGameplay*     M_pMissionGameplayComponent;                       // 0x0138(0x0008)(ExportObject, ZeroConstructor, Transient, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UBFGMentalAbility_Holobob*              M_pHolobobAbility;                                 // 0x0140(0x0008)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UBFGActorComponent_PawnStats*           M_pPawnStats;                                      // 0x0148(0x0008)(ExportObject, ZeroConstructor, Transient, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UBFGAITagQueries*                       M_pTagQueries;                                     // 0x0150(0x0008)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	struct FGameplayTag                           M_mainGameplayTag;                                 // 0x0158(0x0008)(Transient, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)

public:
	void OnDeadStatChanged(class AActor* _pActor, class UBFGActorStat_Bool* _pStat);
	void OnHolobobDisrupted(class UBFGMentalAbilityBase* _pAbility, bool _bDisrupted);
	void OnInvisibleStatChanged(class AActor* _pActor, class UBFGActorStat_Bool* _pStat);
	void OnTagsChanged(const struct FGameplayTag& _rTag);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"BFGActorComponent_AITarget">();
	}
	static class UBFGActorComponent_AITarget* GetDefaultObj()
	{
		return GetDefaultObjImpl<UBFGActorComponent_AITarget>();
	}
};
static_assert(alignof(UBFGActorComponent_AITarget) == 0x000008, "Wrong alignment on UBFGActorComponent_AITarget");
static_assert(sizeof(UBFGActorComponent_AITarget) == 0x000160, "Wrong size on UBFGActorComponent_AITarget");
static_assert(offsetof(UBFGActorComponent_AITarget, M_pGameplayEffectTags) == 0x000130, "Member 'UBFGActorComponent_AITarget::M_pGameplayEffectTags' has a wrong offset!");
static_assert(offsetof(UBFGActorComponent_AITarget, M_pMissionGameplayComponent) == 0x000138, "Member 'UBFGActorComponent_AITarget::M_pMissionGameplayComponent' has a wrong offset!");
static_assert(offsetof(UBFGActorComponent_AITarget, M_pHolobobAbility) == 0x000140, "Member 'UBFGActorComponent_AITarget::M_pHolobobAbility' has a wrong offset!");
static_assert(offsetof(UBFGActorComponent_AITarget, M_pPawnStats) == 0x000148, "Member 'UBFGActorComponent_AITarget::M_pPawnStats' has a wrong offset!");
static_assert(offsetof(UBFGActorComponent_AITarget, M_pTagQueries) == 0x000150, "Member 'UBFGActorComponent_AITarget::M_pTagQueries' has a wrong offset!");
static_assert(offsetof(UBFGActorComponent_AITarget, M_mainGameplayTag) == 0x000158, "Member 'UBFGActorComponent_AITarget::M_mainGameplayTag' has a wrong offset!");

// Class BFGCore.BFGActorComponent_Alert
// 0x0028 (0x0150 - 0x0128)
class UBFGActorComponent_Alert final : public UActorComponent
{
public:
	bool                                          M_bEnabled;                                        // 0x0128(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_129[0x7];                                      // 0x0129(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<struct FBFGQueuedAlertEventInstance>   M_aQueuedTriggers;                                 // 0x0130(0x0010)(ZeroConstructor, Transient, Protected, NativeAccessSpecifierProtected)
	class UBFGActorComponent_DetectionHelper*     M_pDetectionHelper;                                // 0x0140(0x0008)(ExportObject, ZeroConstructor, Transient, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UBFGAICombatMediator_TargetTracker*     M_pTargetTracker;                                  // 0x0148(0x0008)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"BFGActorComponent_Alert">();
	}
	static class UBFGActorComponent_Alert* GetDefaultObj()
	{
		return GetDefaultObjImpl<UBFGActorComponent_Alert>();
	}
};
static_assert(alignof(UBFGActorComponent_Alert) == 0x000008, "Wrong alignment on UBFGActorComponent_Alert");
static_assert(sizeof(UBFGActorComponent_Alert) == 0x000150, "Wrong size on UBFGActorComponent_Alert");
static_assert(offsetof(UBFGActorComponent_Alert, M_bEnabled) == 0x000128, "Member 'UBFGActorComponent_Alert::M_bEnabled' has a wrong offset!");
static_assert(offsetof(UBFGActorComponent_Alert, M_aQueuedTriggers) == 0x000130, "Member 'UBFGActorComponent_Alert::M_aQueuedTriggers' has a wrong offset!");
static_assert(offsetof(UBFGActorComponent_Alert, M_pDetectionHelper) == 0x000140, "Member 'UBFGActorComponent_Alert::M_pDetectionHelper' has a wrong offset!");
static_assert(offsetof(UBFGActorComponent_Alert, M_pTargetTracker) == 0x000148, "Member 'UBFGActorComponent_Alert::M_pTargetTracker' has a wrong offset!");

// Class BFGCore.BFGProjectile
// 0x0100 (0x04D8 - 0x03D8)
class ABFGProjectile : public AActor
{
public:
	uint8                                         Pad_3D8[0x30];                                     // 0x03D8(0x0030)(Fixing Size After Last Property [ Dumper-7 ])
	TSubclassOf<class UDamageType>                M_pDamageType;                                     // 0x0408(0x0008)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         M_fAoeRadius;                                      // 0x0410(0x0004)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         M_fImpactImpluseStrength;                          // 0x0414(0x0004)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          M_bCanDestroyEnvironment;                          // 0x0418(0x0001)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          M_bDestroyInsteadOfDynamicSwap;                    // 0x0419(0x0001)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_41A[0x2];                                      // 0x041A(0x0002)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         M_fEnvironmentImpluseStrength;                     // 0x041C(0x0004)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FGameplayTagContainer                  M_oOnTargetDeathGameplayEffectTags;                // 0x0420(0x0020)(Edit, BlueprintVisible, DisableEditOnInstance, NativeAccessSpecifierPublic)
	class UBFGActorComponent_Effect*              M_pEffectComponent;                                // 0x0440(0x0008)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, EditConst, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class ABFGWeapon*                             M_pWeapon;                                         // 0x0448(0x0008)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	struct FGameplayTagContainer                  M_oGrantedTags;                                    // 0x0450(0x0020)(Edit, BlueprintVisible, BlueprintReadOnly, DisableEditOnInstance, Protected, NativeAccessSpecifierProtected)
	struct FGameplayTagContainer                  M_oForbiddenTags;                                  // 0x0470(0x0020)(Edit, BlueprintVisible, BlueprintReadOnly, DisableEditOnInstance, Protected, NativeAccessSpecifierProtected)
	struct FGameplayTagContainer                  M_gameplayTags;                                    // 0x0490(0x0020)(Edit, DisableEditOnInstance, Protected, NativeAccessSpecifierProtected)
	EBFGEffect_Identifier                         M_eImpactEffectIdentifier;                         // 0x04B0(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	EBFGFaction                                   M_eFaction;                                        // 0x04B1(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_4B2[0x6];                                      // 0x04B2(0x0006)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<class AActor*>                         M_aIgnoreHitActors;                                // 0x04B8(0x0010)(ZeroConstructor, Transient, Protected, NativeAccessSpecifierProtected)
	TSubclassOf<class ABFGWeapon>                 M_pWeaponClass;                                    // 0x04C8(0x0008)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class AActor*                                 M_pHolder;                                         // 0x04D0(0x0008)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)

public:
	void DestroyFromExternalSource();
	void OnImpact(const struct FVector& _vLocation, const struct FVector& _vDirection, const struct FVector& _vNormal, class UPhysicalMaterial* _pMaterial);
	void SetWeapon(class ABFGWeapon* _pWeapon);

	class AActor* GetHolderSafe() const;
	class ABFGWeapon* GetWeaponSafe() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"BFGProjectile">();
	}
	static class ABFGProjectile* GetDefaultObj()
	{
		return GetDefaultObjImpl<ABFGProjectile>();
	}
};
static_assert(alignof(ABFGProjectile) == 0x000008, "Wrong alignment on ABFGProjectile");
static_assert(sizeof(ABFGProjectile) == 0x0004D8, "Wrong size on ABFGProjectile");
static_assert(offsetof(ABFGProjectile, M_pDamageType) == 0x000408, "Member 'ABFGProjectile::M_pDamageType' has a wrong offset!");
static_assert(offsetof(ABFGProjectile, M_fAoeRadius) == 0x000410, "Member 'ABFGProjectile::M_fAoeRadius' has a wrong offset!");
static_assert(offsetof(ABFGProjectile, M_fImpactImpluseStrength) == 0x000414, "Member 'ABFGProjectile::M_fImpactImpluseStrength' has a wrong offset!");
static_assert(offsetof(ABFGProjectile, M_bCanDestroyEnvironment) == 0x000418, "Member 'ABFGProjectile::M_bCanDestroyEnvironment' has a wrong offset!");
static_assert(offsetof(ABFGProjectile, M_bDestroyInsteadOfDynamicSwap) == 0x000419, "Member 'ABFGProjectile::M_bDestroyInsteadOfDynamicSwap' has a wrong offset!");
static_assert(offsetof(ABFGProjectile, M_fEnvironmentImpluseStrength) == 0x00041C, "Member 'ABFGProjectile::M_fEnvironmentImpluseStrength' has a wrong offset!");
static_assert(offsetof(ABFGProjectile, M_oOnTargetDeathGameplayEffectTags) == 0x000420, "Member 'ABFGProjectile::M_oOnTargetDeathGameplayEffectTags' has a wrong offset!");
static_assert(offsetof(ABFGProjectile, M_pEffectComponent) == 0x000440, "Member 'ABFGProjectile::M_pEffectComponent' has a wrong offset!");
static_assert(offsetof(ABFGProjectile, M_pWeapon) == 0x000448, "Member 'ABFGProjectile::M_pWeapon' has a wrong offset!");
static_assert(offsetof(ABFGProjectile, M_oGrantedTags) == 0x000450, "Member 'ABFGProjectile::M_oGrantedTags' has a wrong offset!");
static_assert(offsetof(ABFGProjectile, M_oForbiddenTags) == 0x000470, "Member 'ABFGProjectile::M_oForbiddenTags' has a wrong offset!");
static_assert(offsetof(ABFGProjectile, M_gameplayTags) == 0x000490, "Member 'ABFGProjectile::M_gameplayTags' has a wrong offset!");
static_assert(offsetof(ABFGProjectile, M_eImpactEffectIdentifier) == 0x0004B0, "Member 'ABFGProjectile::M_eImpactEffectIdentifier' has a wrong offset!");
static_assert(offsetof(ABFGProjectile, M_eFaction) == 0x0004B1, "Member 'ABFGProjectile::M_eFaction' has a wrong offset!");
static_assert(offsetof(ABFGProjectile, M_aIgnoreHitActors) == 0x0004B8, "Member 'ABFGProjectile::M_aIgnoreHitActors' has a wrong offset!");
static_assert(offsetof(ABFGProjectile, M_pWeaponClass) == 0x0004C8, "Member 'ABFGProjectile::M_pWeaponClass' has a wrong offset!");
static_assert(offsetof(ABFGProjectile, M_pHolder) == 0x0004D0, "Member 'ABFGProjectile::M_pHolder' has a wrong offset!");

// Class BFGCore.BFGProjectile_Object
// 0x01A0 (0x0678 - 0x04D8)
class ABFGProjectile_Object : public ABFGProjectile
{
public:
	uint8                                         Pad_4D8[0x8];                                      // 0x04D8(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	class UProjectileMovementComponent*           M_pMovementComponent;                              // 0x04E0(0x0008)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, EditConst, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         M_fDamage;                                         // 0x04E8(0x0004)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          M_bIgnorePreTargetCollision;                       // 0x04EC(0x0001)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_4ED[0x3];                                      // 0x04ED(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         M_fCheckImpactOffset;                              // 0x04F0(0x0004)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          M_bDestroyOnImpact;                                // 0x04F4(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_4F5[0x3];                                      // 0x04F5(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	struct FBFGTimer                              M_oFireDelayTimer;                                 // 0x04F8(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, DisableEditOnInstance, NoDestructor, NativeAccessSpecifierPublic)
	bool                                          M_bIsHoming;                                       // 0x0508(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_509[0x3];                                      // 0x0509(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         M_fCancelHomingDistance;                           // 0x050C(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          M_bOnlyImpactTarget;                               // 0x0510(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          M_bCanBounce;                                      // 0x0511(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_512[0x2];                                      // 0x0512(0x0002)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         M_fMinFloorBounceAngle;                            // 0x0514(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         M_fBouncinessPawnOverride;                         // 0x0518(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         M_fBounceFrictionPawnOverride;                     // 0x051C(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         M_iMaxBounceCount;                                 // 0x0520(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          M_bFriendFireAOECheck;                             // 0x0524(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          M_bIsFlying;                                       // 0x0525(0x0001)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_526[0x2];                                      // 0x0526(0x0002)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         M_fMaxDistance;                                    // 0x0528(0x0004)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         M_fDistanceLeft;                                   // 0x052C(0x0004)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	struct FVector                                M_vOldLocation;                                    // 0x0530(0x000C)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	struct FVector                                M_vLastOldLocation;                                // 0x053C(0x000C)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	struct FHitResult                             M_HitResult;                                       // 0x0548(0x0088)(Transient, IsPlainOldData, NoDestructor, ContainsInstancedReference, Protected, NativeAccessSpecifierProtected)
	bool                                          M_bDealsImpactDamage;                              // 0x05D0(0x0001)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          M_bValidateImpactsWithTargets;                     // 0x05D1(0x0001)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_5D2[0x6];                                      // 0x05D2(0x0006)(Fixing Size After Last Property [ Dumper-7 ])
	class AActor*                                 M_pHomingTarget;                                   // 0x05D8(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_5E0[0x4];                                      // 0x05E0(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         M_fExplodeDamage;                                  // 0x05E4(0x0004)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         M_fExplodeDamageToPlayer;                          // 0x05E8(0x0004)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          M_bExplodeOnStop;                                  // 0x05EC(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_5ED[0x3];                                      // 0x05ED(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	TMap<EBFGGameplayScaling, struct FVector>     M_aMeshGameplayScale;                              // 0x05F0(0x0050)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, Protected, NativeAccessSpecifierProtected)
	bool                                          M_bCanPK;                                          // 0x0640(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_641[0x7];                                      // 0x0641(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	class UPrimitiveComponent*                    M_pPhysicsRoot;                                    // 0x0648(0x0008)(ExportObject, ZeroConstructor, Transient, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class USceneComponent*                        M_pPhysicsRootParent;                              // 0x0650(0x0008)(ExportObject, ZeroConstructor, Transient, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_658[0x8];                                      // 0x0658(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	class USceneComponent*                        M_pDelayed_HomingTargetComponent;                  // 0x0660(0x0008)(ExportObject, ZeroConstructor, Transient, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_668[0x10];                                     // 0x0668(0x0010)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void FireProjectile(float _fMaximumTravelDistance, class USceneComponent* _pHomingTargetComponent, const struct FVector& _rInitialDirection);
	void OnHomingCanceled();
	void OnPKHit(class UPrimitiveComponent* _pHitComponent, class AActor* _pOtherActor, class UPrimitiveComponent* _pOtherComp, const struct FVector& _vNormalImpulse, const struct FHitResult& _rHit);
	void OnProjectileBounce(const struct FHitResult& _vHitResult);
	void OnProjectileExplosion(const struct FVector& _vLocation, float _fRadius);
	void OnProjectileFinishedFlying();
	void OnProjectileFireDelayStarted(float _fDelayDuration);
	void OnProjectileSimulationStop(const struct FHitResult& HitRes);
	void OnProjectileStartedFlying();

	bool IsTargetPlayer() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"BFGProjectile_Object">();
	}
	static class ABFGProjectile_Object* GetDefaultObj()
	{
		return GetDefaultObjImpl<ABFGProjectile_Object>();
	}
};
static_assert(alignof(ABFGProjectile_Object) == 0x000008, "Wrong alignment on ABFGProjectile_Object");
static_assert(sizeof(ABFGProjectile_Object) == 0x000678, "Wrong size on ABFGProjectile_Object");
static_assert(offsetof(ABFGProjectile_Object, M_pMovementComponent) == 0x0004E0, "Member 'ABFGProjectile_Object::M_pMovementComponent' has a wrong offset!");
static_assert(offsetof(ABFGProjectile_Object, M_fDamage) == 0x0004E8, "Member 'ABFGProjectile_Object::M_fDamage' has a wrong offset!");
static_assert(offsetof(ABFGProjectile_Object, M_bIgnorePreTargetCollision) == 0x0004EC, "Member 'ABFGProjectile_Object::M_bIgnorePreTargetCollision' has a wrong offset!");
static_assert(offsetof(ABFGProjectile_Object, M_fCheckImpactOffset) == 0x0004F0, "Member 'ABFGProjectile_Object::M_fCheckImpactOffset' has a wrong offset!");
static_assert(offsetof(ABFGProjectile_Object, M_bDestroyOnImpact) == 0x0004F4, "Member 'ABFGProjectile_Object::M_bDestroyOnImpact' has a wrong offset!");
static_assert(offsetof(ABFGProjectile_Object, M_oFireDelayTimer) == 0x0004F8, "Member 'ABFGProjectile_Object::M_oFireDelayTimer' has a wrong offset!");
static_assert(offsetof(ABFGProjectile_Object, M_bIsHoming) == 0x000508, "Member 'ABFGProjectile_Object::M_bIsHoming' has a wrong offset!");
static_assert(offsetof(ABFGProjectile_Object, M_fCancelHomingDistance) == 0x00050C, "Member 'ABFGProjectile_Object::M_fCancelHomingDistance' has a wrong offset!");
static_assert(offsetof(ABFGProjectile_Object, M_bOnlyImpactTarget) == 0x000510, "Member 'ABFGProjectile_Object::M_bOnlyImpactTarget' has a wrong offset!");
static_assert(offsetof(ABFGProjectile_Object, M_bCanBounce) == 0x000511, "Member 'ABFGProjectile_Object::M_bCanBounce' has a wrong offset!");
static_assert(offsetof(ABFGProjectile_Object, M_fMinFloorBounceAngle) == 0x000514, "Member 'ABFGProjectile_Object::M_fMinFloorBounceAngle' has a wrong offset!");
static_assert(offsetof(ABFGProjectile_Object, M_fBouncinessPawnOverride) == 0x000518, "Member 'ABFGProjectile_Object::M_fBouncinessPawnOverride' has a wrong offset!");
static_assert(offsetof(ABFGProjectile_Object, M_fBounceFrictionPawnOverride) == 0x00051C, "Member 'ABFGProjectile_Object::M_fBounceFrictionPawnOverride' has a wrong offset!");
static_assert(offsetof(ABFGProjectile_Object, M_iMaxBounceCount) == 0x000520, "Member 'ABFGProjectile_Object::M_iMaxBounceCount' has a wrong offset!");
static_assert(offsetof(ABFGProjectile_Object, M_bFriendFireAOECheck) == 0x000524, "Member 'ABFGProjectile_Object::M_bFriendFireAOECheck' has a wrong offset!");
static_assert(offsetof(ABFGProjectile_Object, M_bIsFlying) == 0x000525, "Member 'ABFGProjectile_Object::M_bIsFlying' has a wrong offset!");
static_assert(offsetof(ABFGProjectile_Object, M_fMaxDistance) == 0x000528, "Member 'ABFGProjectile_Object::M_fMaxDistance' has a wrong offset!");
static_assert(offsetof(ABFGProjectile_Object, M_fDistanceLeft) == 0x00052C, "Member 'ABFGProjectile_Object::M_fDistanceLeft' has a wrong offset!");
static_assert(offsetof(ABFGProjectile_Object, M_vOldLocation) == 0x000530, "Member 'ABFGProjectile_Object::M_vOldLocation' has a wrong offset!");
static_assert(offsetof(ABFGProjectile_Object, M_vLastOldLocation) == 0x00053C, "Member 'ABFGProjectile_Object::M_vLastOldLocation' has a wrong offset!");
static_assert(offsetof(ABFGProjectile_Object, M_HitResult) == 0x000548, "Member 'ABFGProjectile_Object::M_HitResult' has a wrong offset!");
static_assert(offsetof(ABFGProjectile_Object, M_bDealsImpactDamage) == 0x0005D0, "Member 'ABFGProjectile_Object::M_bDealsImpactDamage' has a wrong offset!");
static_assert(offsetof(ABFGProjectile_Object, M_bValidateImpactsWithTargets) == 0x0005D1, "Member 'ABFGProjectile_Object::M_bValidateImpactsWithTargets' has a wrong offset!");
static_assert(offsetof(ABFGProjectile_Object, M_pHomingTarget) == 0x0005D8, "Member 'ABFGProjectile_Object::M_pHomingTarget' has a wrong offset!");
static_assert(offsetof(ABFGProjectile_Object, M_fExplodeDamage) == 0x0005E4, "Member 'ABFGProjectile_Object::M_fExplodeDamage' has a wrong offset!");
static_assert(offsetof(ABFGProjectile_Object, M_fExplodeDamageToPlayer) == 0x0005E8, "Member 'ABFGProjectile_Object::M_fExplodeDamageToPlayer' has a wrong offset!");
static_assert(offsetof(ABFGProjectile_Object, M_bExplodeOnStop) == 0x0005EC, "Member 'ABFGProjectile_Object::M_bExplodeOnStop' has a wrong offset!");
static_assert(offsetof(ABFGProjectile_Object, M_aMeshGameplayScale) == 0x0005F0, "Member 'ABFGProjectile_Object::M_aMeshGameplayScale' has a wrong offset!");
static_assert(offsetof(ABFGProjectile_Object, M_bCanPK) == 0x000640, "Member 'ABFGProjectile_Object::M_bCanPK' has a wrong offset!");
static_assert(offsetof(ABFGProjectile_Object, M_pPhysicsRoot) == 0x000648, "Member 'ABFGProjectile_Object::M_pPhysicsRoot' has a wrong offset!");
static_assert(offsetof(ABFGProjectile_Object, M_pPhysicsRootParent) == 0x000650, "Member 'ABFGProjectile_Object::M_pPhysicsRootParent' has a wrong offset!");
static_assert(offsetof(ABFGProjectile_Object, M_pDelayed_HomingTargetComponent) == 0x000660, "Member 'ABFGProjectile_Object::M_pDelayed_HomingTargetComponent' has a wrong offset!");

// Class BFGCore.BFGProjectile_EnemyMortar
// 0x0018 (0x0690 - 0x0678)
class ABFGProjectile_EnemyMortar final : public ABFGProjectile_Object
{
public:
	float                                         M_fRiseTime;                                       // 0x0678(0x0004)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_67C[0x14];                                     // 0x067C(0x0014)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"BFGProjectile_EnemyMortar">();
	}
	static class ABFGProjectile_EnemyMortar* GetDefaultObj()
	{
		return GetDefaultObjImpl<ABFGProjectile_EnemyMortar>();
	}
};
static_assert(alignof(ABFGProjectile_EnemyMortar) == 0x000008, "Wrong alignment on ABFGProjectile_EnemyMortar");
static_assert(sizeof(ABFGProjectile_EnemyMortar) == 0x000690, "Wrong size on ABFGProjectile_EnemyMortar");
static_assert(offsetof(ABFGProjectile_EnemyMortar, M_fRiseTime) == 0x000678, "Member 'ABFGProjectile_EnemyMortar::M_fRiseTime' has a wrong offset!");

// Class BFGCore.BFGEventAction_TrackCortexScanVO
// 0x0008 (0x0038 - 0x0030)
class UBFGEventAction_TrackCortexScanVO final : public UBFGEventAction
{
public:
	class UBFGQuest_CortexScanObjectiveTracker*   M_pTracker;                                        // 0x0030(0x0008)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"BFGEventAction_TrackCortexScanVO">();
	}
	static class UBFGEventAction_TrackCortexScanVO* GetDefaultObj()
	{
		return GetDefaultObjImpl<UBFGEventAction_TrackCortexScanVO>();
	}
};
static_assert(alignof(UBFGEventAction_TrackCortexScanVO) == 0x000008, "Wrong alignment on UBFGEventAction_TrackCortexScanVO");
static_assert(sizeof(UBFGEventAction_TrackCortexScanVO) == 0x000038, "Wrong size on UBFGEventAction_TrackCortexScanVO");
static_assert(offsetof(UBFGEventAction_TrackCortexScanVO, M_pTracker) == 0x000030, "Member 'UBFGEventAction_TrackCortexScanVO::M_pTracker' has a wrong offset!");

// Class BFGCore.BFGActorComponent_Animation
// 0x0108 (0x0230 - 0x0128)
class UBFGActorComponent_Animation : public UActorComponent
{
public:
	TMap<EBFGAnimation_Sequence, int32>           M_SequenceVariationsCount;                         // 0x0128(0x0050)(Edit, BlueprintVisible, ZeroConstructor, NativeAccessSpecifierPublic)
	TArray<struct FBFG_AnimationMoveSpeedVariation> M_aAnimationMoveSpeedVariations;                   // 0x0178(0x0010)(Edit, BlueprintVisible, ZeroConstructor, NativeAccessSpecifierPublic)
	TMap<EBFGNPCCharacter_MoveSpeed, int32>       M_ActiveMotionSpeedIndex;                          // 0x0188(0x0050)(Edit, BlueprintVisible, ZeroConstructor, NativeAccessSpecifierPublic)
	uint8                                         Pad_1D8[0x10];                                     // 0x01D8(0x0010)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<class UBFGAnimation_Variables*>        M_aVariableList;                                   // 0x01E8(0x0010)(ZeroConstructor, Protected, NativeAccessSpecifierProtected)
	TArray<class UBFGAnimation_Events*>           M_aEventList;                                      // 0x01F8(0x0010)(ZeroConstructor, Protected, NativeAccessSpecifierProtected)
	TArray<class UBFGAnimationInstance*>          M_aInstanceList;                                   // 0x0208(0x0010)(ZeroConstructor, Protected, NativeAccessSpecifierProtected)
	class UBFGActorComponent_StatsBase*           M_pBaseStats;                                      // 0x0218(0x0008)(ExportObject, ZeroConstructor, Transient, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UBFGActorComponent_EquipmentManager*    M_pEquipment;                                      // 0x0220(0x0008)(ExportObject, ZeroConstructor, Transient, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UBFGActorComponent_GameplayEffectTags*  M_pEffects;                                        // 0x0228(0x0008)(ExportObject, ZeroConstructor, Transient, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)

public:
	void BindEventsAndVariables(class USkeletalMeshComponent* _pCustomMesh);
	const TArray<class UBFGAnimation_Events*> GetAnimationEvents();
	void OnAnimInitialized();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"BFGActorComponent_Animation">();
	}
	static class UBFGActorComponent_Animation* GetDefaultObj()
	{
		return GetDefaultObjImpl<UBFGActorComponent_Animation>();
	}
};
static_assert(alignof(UBFGActorComponent_Animation) == 0x000008, "Wrong alignment on UBFGActorComponent_Animation");
static_assert(sizeof(UBFGActorComponent_Animation) == 0x000230, "Wrong size on UBFGActorComponent_Animation");
static_assert(offsetof(UBFGActorComponent_Animation, M_SequenceVariationsCount) == 0x000128, "Member 'UBFGActorComponent_Animation::M_SequenceVariationsCount' has a wrong offset!");
static_assert(offsetof(UBFGActorComponent_Animation, M_aAnimationMoveSpeedVariations) == 0x000178, "Member 'UBFGActorComponent_Animation::M_aAnimationMoveSpeedVariations' has a wrong offset!");
static_assert(offsetof(UBFGActorComponent_Animation, M_ActiveMotionSpeedIndex) == 0x000188, "Member 'UBFGActorComponent_Animation::M_ActiveMotionSpeedIndex' has a wrong offset!");
static_assert(offsetof(UBFGActorComponent_Animation, M_aVariableList) == 0x0001E8, "Member 'UBFGActorComponent_Animation::M_aVariableList' has a wrong offset!");
static_assert(offsetof(UBFGActorComponent_Animation, M_aEventList) == 0x0001F8, "Member 'UBFGActorComponent_Animation::M_aEventList' has a wrong offset!");
static_assert(offsetof(UBFGActorComponent_Animation, M_aInstanceList) == 0x000208, "Member 'UBFGActorComponent_Animation::M_aInstanceList' has a wrong offset!");
static_assert(offsetof(UBFGActorComponent_Animation, M_pBaseStats) == 0x000218, "Member 'UBFGActorComponent_Animation::M_pBaseStats' has a wrong offset!");
static_assert(offsetof(UBFGActorComponent_Animation, M_pEquipment) == 0x000220, "Member 'UBFGActorComponent_Animation::M_pEquipment' has a wrong offset!");
static_assert(offsetof(UBFGActorComponent_Animation, M_pEffects) == 0x000228, "Member 'UBFGActorComponent_Animation::M_pEffects' has a wrong offset!");

// Class BFGCore.BFGActorComponent_Animation_Npc
// 0x0028 (0x0258 - 0x0230)
class UBFGActorComponent_Animation_Npc : public UBFGActorComponent_Animation
{
public:
	class UBFGActorComponent_GameplayEffectResponses* M_pResponses;                                      // 0x0230(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UBFGActorComponent_CharacterStats*      M_pStats;                                          // 0x0238(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class ABFGNPCCharacterGameplay*               M_pCharacter;                                      // 0x0240(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UBFGActorComponent_EquipmentManager*    M_pEquipmentManager;                               // 0x0248(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UBFGActorComponent_NPCCharacterMovement* M_pMovementComponent;                              // 0x0250(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"BFGActorComponent_Animation_Npc">();
	}
	static class UBFGActorComponent_Animation_Npc* GetDefaultObj()
	{
		return GetDefaultObjImpl<UBFGActorComponent_Animation_Npc>();
	}
};
static_assert(alignof(UBFGActorComponent_Animation_Npc) == 0x000008, "Wrong alignment on UBFGActorComponent_Animation_Npc");
static_assert(sizeof(UBFGActorComponent_Animation_Npc) == 0x000258, "Wrong size on UBFGActorComponent_Animation_Npc");
static_assert(offsetof(UBFGActorComponent_Animation_Npc, M_pResponses) == 0x000230, "Member 'UBFGActorComponent_Animation_Npc::M_pResponses' has a wrong offset!");
static_assert(offsetof(UBFGActorComponent_Animation_Npc, M_pStats) == 0x000238, "Member 'UBFGActorComponent_Animation_Npc::M_pStats' has a wrong offset!");
static_assert(offsetof(UBFGActorComponent_Animation_Npc, M_pCharacter) == 0x000240, "Member 'UBFGActorComponent_Animation_Npc::M_pCharacter' has a wrong offset!");
static_assert(offsetof(UBFGActorComponent_Animation_Npc, M_pEquipmentManager) == 0x000248, "Member 'UBFGActorComponent_Animation_Npc::M_pEquipmentManager' has a wrong offset!");
static_assert(offsetof(UBFGActorComponent_Animation_Npc, M_pMovementComponent) == 0x000250, "Member 'UBFGActorComponent_Animation_Npc::M_pMovementComponent' has a wrong offset!");

// Class BFGCore.BFGMentalAbility_ExtractBrain
// 0x00D8 (0x02A0 - 0x01C8)
class UBFGMentalAbility_ExtractBrain : public UBFGMentalAbilityBase
{
public:
	float                                         M_fDamage;                                         // 0x01C8(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1CC[0x4];                                      // 0x01CC(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	UMulticastDelegateProperty_                   M_OnBrainExtracted;                                // 0x01D0(0x0018)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	struct FGameplayTag                           M_tUpgradeTagCognitohazardPatternAlpha;            // 0x01E8(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, DisableEditOnInstance, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FGameplayTag                           M_tUpgradeTagCognitohazardPatternBeta;             // 0x01F0(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, DisableEditOnInstance, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FGameplayTag                           M_tUpgradeTagCompulsionMatrixOmega;                // 0x01F8(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, DisableEditOnInstance, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         M_fDebilitatorDataPack_SlowdownFactor;             // 0x0200(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         M_fDebilitatorDataSurge_SlowdownFactor;            // 0x0204(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TArray<struct FBFGBrainExtractInfectionData>  M_aInfectedTargets;                                // 0x0208(0x0010)(ZeroConstructor, Transient, Protected, NativeAccessSpecifierProtected)
	struct FGameplayTag                           M_oInfectedGameplayTag;                            // 0x0218(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, DisableEditOnInstance, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	struct FGameplayTag                           M_oFollowTag;                                      // 0x0220(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, DisableEditOnInstance, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	struct FBFGBrainExtractInfectionParams        M_oCognitohazardPatternAlphaParams;                // 0x0228(0x001C)(Edit, BlueprintVisible, BlueprintReadOnly, DisableEditOnInstance, NoDestructor, Protected, NativeAccessSpecifierProtected)
	struct FBFGBrainExtractInfectionParams        M_oCognitohazardPatternBetaParams;                 // 0x0244(0x001C)(Edit, BlueprintVisible, BlueprintReadOnly, DisableEditOnInstance, NoDestructor, Protected, NativeAccessSpecifierProtected)
	struct FBFGBrainExtractInfectionParams        M_oCompulsionMatrixOmegaParams;                    // 0x0260(0x001C)(Edit, BlueprintVisible, BlueprintReadOnly, DisableEditOnInstance, NoDestructor, Protected, NativeAccessSpecifierProtected)
	uint8                                         Pad_27C[0x4];                                      // 0x027C(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	struct FGameplayTagContainer                  M_oInfectionForbiddenTags;                         // 0x0280(0x0020)(Edit, BlueprintVisible, BlueprintReadOnly, DisableEditOnInstance, Protected, NativeAccessSpecifierProtected)

public:
	void OnBrainWasExtracted(class AActor* _pTarget, class AActor* PBrain);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"BFGMentalAbility_ExtractBrain">();
	}
	static class UBFGMentalAbility_ExtractBrain* GetDefaultObj()
	{
		return GetDefaultObjImpl<UBFGMentalAbility_ExtractBrain>();
	}
};
static_assert(alignof(UBFGMentalAbility_ExtractBrain) == 0x000008, "Wrong alignment on UBFGMentalAbility_ExtractBrain");
static_assert(sizeof(UBFGMentalAbility_ExtractBrain) == 0x0002A0, "Wrong size on UBFGMentalAbility_ExtractBrain");
static_assert(offsetof(UBFGMentalAbility_ExtractBrain, M_fDamage) == 0x0001C8, "Member 'UBFGMentalAbility_ExtractBrain::M_fDamage' has a wrong offset!");
static_assert(offsetof(UBFGMentalAbility_ExtractBrain, M_OnBrainExtracted) == 0x0001D0, "Member 'UBFGMentalAbility_ExtractBrain::M_OnBrainExtracted' has a wrong offset!");
static_assert(offsetof(UBFGMentalAbility_ExtractBrain, M_tUpgradeTagCognitohazardPatternAlpha) == 0x0001E8, "Member 'UBFGMentalAbility_ExtractBrain::M_tUpgradeTagCognitohazardPatternAlpha' has a wrong offset!");
static_assert(offsetof(UBFGMentalAbility_ExtractBrain, M_tUpgradeTagCognitohazardPatternBeta) == 0x0001F0, "Member 'UBFGMentalAbility_ExtractBrain::M_tUpgradeTagCognitohazardPatternBeta' has a wrong offset!");
static_assert(offsetof(UBFGMentalAbility_ExtractBrain, M_tUpgradeTagCompulsionMatrixOmega) == 0x0001F8, "Member 'UBFGMentalAbility_ExtractBrain::M_tUpgradeTagCompulsionMatrixOmega' has a wrong offset!");
static_assert(offsetof(UBFGMentalAbility_ExtractBrain, M_fDebilitatorDataPack_SlowdownFactor) == 0x000200, "Member 'UBFGMentalAbility_ExtractBrain::M_fDebilitatorDataPack_SlowdownFactor' has a wrong offset!");
static_assert(offsetof(UBFGMentalAbility_ExtractBrain, M_fDebilitatorDataSurge_SlowdownFactor) == 0x000204, "Member 'UBFGMentalAbility_ExtractBrain::M_fDebilitatorDataSurge_SlowdownFactor' has a wrong offset!");
static_assert(offsetof(UBFGMentalAbility_ExtractBrain, M_aInfectedTargets) == 0x000208, "Member 'UBFGMentalAbility_ExtractBrain::M_aInfectedTargets' has a wrong offset!");
static_assert(offsetof(UBFGMentalAbility_ExtractBrain, M_oInfectedGameplayTag) == 0x000218, "Member 'UBFGMentalAbility_ExtractBrain::M_oInfectedGameplayTag' has a wrong offset!");
static_assert(offsetof(UBFGMentalAbility_ExtractBrain, M_oFollowTag) == 0x000220, "Member 'UBFGMentalAbility_ExtractBrain::M_oFollowTag' has a wrong offset!");
static_assert(offsetof(UBFGMentalAbility_ExtractBrain, M_oCognitohazardPatternAlphaParams) == 0x000228, "Member 'UBFGMentalAbility_ExtractBrain::M_oCognitohazardPatternAlphaParams' has a wrong offset!");
static_assert(offsetof(UBFGMentalAbility_ExtractBrain, M_oCognitohazardPatternBetaParams) == 0x000244, "Member 'UBFGMentalAbility_ExtractBrain::M_oCognitohazardPatternBetaParams' has a wrong offset!");
static_assert(offsetof(UBFGMentalAbility_ExtractBrain, M_oCompulsionMatrixOmegaParams) == 0x000260, "Member 'UBFGMentalAbility_ExtractBrain::M_oCompulsionMatrixOmegaParams' has a wrong offset!");
static_assert(offsetof(UBFGMentalAbility_ExtractBrain, M_oInfectionForbiddenTags) == 0x000280, "Member 'UBFGMentalAbility_ExtractBrain::M_oInfectionForbiddenTags' has a wrong offset!");

// Class BFGCore.BFGEventAction_NextEnvironment
// 0x0028 (0x0058 - 0x0030)
class UBFGEventAction_NextEnvironment final : public UBFGEventAction
{
public:
	TSoftObjectPtr<class UBFGEnvironment>         M_softEnvironment;                                 // 0x0030(0x0028)(Transient, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"BFGEventAction_NextEnvironment">();
	}
	static class UBFGEventAction_NextEnvironment* GetDefaultObj()
	{
		return GetDefaultObjImpl<UBFGEventAction_NextEnvironment>();
	}
};
static_assert(alignof(UBFGEventAction_NextEnvironment) == 0x000008, "Wrong alignment on UBFGEventAction_NextEnvironment");
static_assert(sizeof(UBFGEventAction_NextEnvironment) == 0x000058, "Wrong size on UBFGEventAction_NextEnvironment");
static_assert(offsetof(UBFGEventAction_NextEnvironment, M_softEnvironment) == 0x000030, "Member 'UBFGEventAction_NextEnvironment::M_softEnvironment' has a wrong offset!");

// Class BFGCore.BFGActorComponent_Animation_Animal
// 0x0000 (0x0258 - 0x0258)
class UBFGActorComponent_Animation_Animal final : public UBFGActorComponent_Animation_Npc
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"BFGActorComponent_Animation_Animal">();
	}
	static class UBFGActorComponent_Animation_Animal* GetDefaultObj()
	{
		return GetDefaultObjImpl<UBFGActorComponent_Animation_Animal>();
	}
};
static_assert(alignof(UBFGActorComponent_Animation_Animal) == 0x000008, "Wrong alignment on UBFGActorComponent_Animation_Animal");
static_assert(sizeof(UBFGActorComponent_Animation_Animal) == 0x000258, "Wrong size on UBFGActorComponent_Animation_Animal");

// Class BFGCore.BFGLockOnManager
// 0x0018 (0x0048 - 0x0030)
class UBFGLockOnManager : public UBFGGameSystem
{
public:
	class ABFGGameState*                          M_pGameState;                                      // 0x0030(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TArray<class UBFGActorComponent_LockOnTarget*> M_apTargetRegistry;                                // 0x0038(0x0010)(ExportObject, ZeroConstructor, ContainsInstancedReference, Protected, NativeAccessSpecifierProtected)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"BFGLockOnManager">();
	}
	static class UBFGLockOnManager* GetDefaultObj()
	{
		return GetDefaultObjImpl<UBFGLockOnManager>();
	}
};
static_assert(alignof(UBFGLockOnManager) == 0x000008, "Wrong alignment on UBFGLockOnManager");
static_assert(sizeof(UBFGLockOnManager) == 0x000048, "Wrong size on UBFGLockOnManager");
static_assert(offsetof(UBFGLockOnManager, M_pGameState) == 0x000030, "Member 'UBFGLockOnManager::M_pGameState' has a wrong offset!");
static_assert(offsetof(UBFGLockOnManager, M_apTargetRegistry) == 0x000038, "Member 'UBFGLockOnManager::M_apTargetRegistry' has a wrong offset!");

// Class BFGCore.BFGActorComponent_Animation_Boss
// 0x0000 (0x0258 - 0x0258)
class UBFGActorComponent_Animation_Boss final : public UBFGActorComponent_Animation_Npc
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"BFGActorComponent_Animation_Boss">();
	}
	static class UBFGActorComponent_Animation_Boss* GetDefaultObj()
	{
		return GetDefaultObjImpl<UBFGActorComponent_Animation_Boss>();
	}
};
static_assert(alignof(UBFGActorComponent_Animation_Boss) == 0x000008, "Wrong alignment on UBFGActorComponent_Animation_Boss");
static_assert(sizeof(UBFGActorComponent_Animation_Boss) == 0x000258, "Wrong size on UBFGActorComponent_Animation_Boss");

// Class BFGCore.BFGEffectBank_DataProvider
// 0x00B8 (0x00E0 - 0x0028)
class UBFGEffectBank_DataProvider final : public UObject
{
public:
	class ABFGGameState*                          M_pGameState;                                      // 0x0028(0x0008)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_30[0x8];                                       // 0x0030(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	class UBFGVariable*                           M_pVariable;                                       // 0x0038(0x0008)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	struct FBFGActorBinding                       M_actorBinding;                                    // 0x0040(0x0090)(Transient, Protected, NativeAccessSpecifierProtected)
	TArray<class UBFGEffectBank*>                 M_apEffectBanks;                                   // 0x00D0(0x0010)(ZeroConstructor, Transient, Protected, NativeAccessSpecifierProtected)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"BFGEffectBank_DataProvider">();
	}
	static class UBFGEffectBank_DataProvider* GetDefaultObj()
	{
		return GetDefaultObjImpl<UBFGEffectBank_DataProvider>();
	}
};
static_assert(alignof(UBFGEffectBank_DataProvider) == 0x000008, "Wrong alignment on UBFGEffectBank_DataProvider");
static_assert(sizeof(UBFGEffectBank_DataProvider) == 0x0000E0, "Wrong size on UBFGEffectBank_DataProvider");
static_assert(offsetof(UBFGEffectBank_DataProvider, M_pGameState) == 0x000028, "Member 'UBFGEffectBank_DataProvider::M_pGameState' has a wrong offset!");
static_assert(offsetof(UBFGEffectBank_DataProvider, M_pVariable) == 0x000038, "Member 'UBFGEffectBank_DataProvider::M_pVariable' has a wrong offset!");
static_assert(offsetof(UBFGEffectBank_DataProvider, M_actorBinding) == 0x000040, "Member 'UBFGEffectBank_DataProvider::M_actorBinding' has a wrong offset!");
static_assert(offsetof(UBFGEffectBank_DataProvider, M_apEffectBanks) == 0x0000D0, "Member 'UBFGEffectBank_DataProvider::M_apEffectBanks' has a wrong offset!");

// Class BFGCore.BFGSensor_ExternalStateChangeRequest
// 0x0000 (0x0040 - 0x0040)
class UBFGSensor_ExternalStateChangeRequest final : public UBFGSensor
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"BFGSensor_ExternalStateChangeRequest">();
	}
	static class UBFGSensor_ExternalStateChangeRequest* GetDefaultObj()
	{
		return GetDefaultObjImpl<UBFGSensor_ExternalStateChangeRequest>();
	}
};
static_assert(alignof(UBFGSensor_ExternalStateChangeRequest) == 0x000008, "Wrong alignment on UBFGSensor_ExternalStateChangeRequest");
static_assert(sizeof(UBFGSensor_ExternalStateChangeRequest) == 0x000040, "Wrong size on UBFGSensor_ExternalStateChangeRequest");

// Class BFGCore.BFGActorComponent_Animation_Crypto
// 0x0000 (0x0230 - 0x0230)
class UBFGActorComponent_Animation_Crypto final : public UBFGActorComponent_Animation
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"BFGActorComponent_Animation_Crypto">();
	}
	static class UBFGActorComponent_Animation_Crypto* GetDefaultObj()
	{
		return GetDefaultObjImpl<UBFGActorComponent_Animation_Crypto>();
	}
};
static_assert(alignof(UBFGActorComponent_Animation_Crypto) == 0x000008, "Wrong alignment on UBFGActorComponent_Animation_Crypto");
static_assert(sizeof(UBFGActorComponent_Animation_Crypto) == 0x000230, "Wrong size on UBFGActorComponent_Animation_Crypto");

// Class BFGCore.BFGActorComponent_Animation_Human
// 0x0000 (0x0258 - 0x0258)
class UBFGActorComponent_Animation_Human final : public UBFGActorComponent_Animation_Npc
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"BFGActorComponent_Animation_Human">();
	}
	static class UBFGActorComponent_Animation_Human* GetDefaultObj()
	{
		return GetDefaultObjImpl<UBFGActorComponent_Animation_Human>();
	}
};
static_assert(alignof(UBFGActorComponent_Animation_Human) == 0x000008, "Wrong alignment on UBFGActorComponent_Animation_Human");
static_assert(sizeof(UBFGActorComponent_Animation_Human) == 0x000258, "Wrong size on UBFGActorComponent_Animation_Human");

// Class BFGCore.BFGEffectActor
// 0x0070 (0x0448 - 0x03D8)
class ABFGEffectActor : public AActor
{
public:
	uint8                                         Pad_3D8[0x18];                                     // 0x03D8(0x0018)(Fixing Size After Last Property [ Dumper-7 ])
	UMulticastDelegateProperty_                   M_EffectStopped;                                   // 0x03F0(0x0018)(ZeroConstructor, InstancedReference, BlueprintAssignable, BlueprintCallable, NativeAccessSpecifierPublic)
	UMulticastDelegateProperty_                   M_EffectFinished;                                  // 0x0408(0x0018)(ZeroConstructor, InstancedReference, BlueprintAssignable, BlueprintCallable, NativeAccessSpecifierPublic)
	uint8                                         Pad_420[0x8];                                      // 0x0420(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         M_fEffectStopTimeout;                              // 0x0428(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_42C[0x4];                                      // 0x042C(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class UBFGEffectBlackboard*                   M_pBlackboard;                                     // 0x0430(0x0008)(ExportObject, ZeroConstructor, Transient, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UBFGEffectContainer*                    M_pContainer;                                      // 0x0438(0x0008)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_440[0x8];                                      // 0x0440(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void HandleActorChanged(const class FName _rName, class AActor* _iValue);
	void HandleBoolChanged(const class FName _rName, bool _bValue);
	void HandleColorChanged(const class FName _rName, const struct FColor& _rValue);
	void HandleDataTableChanged(const class FName _rName, class UDataTable* _pValue);
	void HandleFloatChanged(const class FName _rName, float _fValue);
	void HandleIntChanged(const class FName _rName, int32 _iValue);
	void HandleNameChanged(const class FName _rName, class FName _iValue);
	void HandleObjectChanged(const class FName _rName, class UObject* _pValue);
	void HandleRotatorChanged(const class FName _rName, const struct FRotator& _rValue);
	void HandleVectorChanged(const class FName _rName, const struct FVector& _rValue);
	bool IsEffectActive();
	bool IsEffectFinished();
	void OnStopEffect();
	void OnTriggerEffect();
	void SetBlackboard(class UBFGEffectBlackboard* _pBlackboard);
	void StopEffect();
	void TriggerEffect();

	class UBFGEffectBlackboard* GetBlackboard() const;
	struct FBFGEffectContainerDescriptor GetContainerDescriptor() const;
	class UBFGActorComponent_Effect* GetEffectComponent() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"BFGEffectActor">();
	}
	static class ABFGEffectActor* GetDefaultObj()
	{
		return GetDefaultObjImpl<ABFGEffectActor>();
	}
};
static_assert(alignof(ABFGEffectActor) == 0x000008, "Wrong alignment on ABFGEffectActor");
static_assert(sizeof(ABFGEffectActor) == 0x000448, "Wrong size on ABFGEffectActor");
static_assert(offsetof(ABFGEffectActor, M_EffectStopped) == 0x0003F0, "Member 'ABFGEffectActor::M_EffectStopped' has a wrong offset!");
static_assert(offsetof(ABFGEffectActor, M_EffectFinished) == 0x000408, "Member 'ABFGEffectActor::M_EffectFinished' has a wrong offset!");
static_assert(offsetof(ABFGEffectActor, M_fEffectStopTimeout) == 0x000428, "Member 'ABFGEffectActor::M_fEffectStopTimeout' has a wrong offset!");
static_assert(offsetof(ABFGEffectActor, M_pBlackboard) == 0x000430, "Member 'ABFGEffectActor::M_pBlackboard' has a wrong offset!");
static_assert(offsetof(ABFGEffectActor, M_pContainer) == 0x000438, "Member 'ABFGEffectActor::M_pContainer' has a wrong offset!");

// Class BFGCore.BFGEffectActor_Beam
// 0x0028 (0x0470 - 0x0448)
class ABFGEffectActor_Beam : public ABFGEffectActor
{
public:
	bool                                          M_bIsBeamActive;                                   // 0x0448(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_449[0x7];                                      // 0x0449(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	class AActor*                                 M_pTargetActor;                                    // 0x0450(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_458[0x18];                                     // 0x0458(0x0018)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void ForceBeamUpdate();
	void SetTargetActor(class AActor* _TargetActor);
	void SetTargetLocation(const struct FVector& _vTargetLocation, const struct FVector& _vTargetNormal);
	void StartBeam();
	void StopBeam();
	void UpdateBeam(class AActor* _pTargetActor, const struct FVector& _vTargetLocation, const struct FVector& _vTargetNormal);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"BFGEffectActor_Beam">();
	}
	static class ABFGEffectActor_Beam* GetDefaultObj()
	{
		return GetDefaultObjImpl<ABFGEffectActor_Beam>();
	}
};
static_assert(alignof(ABFGEffectActor_Beam) == 0x000008, "Wrong alignment on ABFGEffectActor_Beam");
static_assert(sizeof(ABFGEffectActor_Beam) == 0x000470, "Wrong size on ABFGEffectActor_Beam");
static_assert(offsetof(ABFGEffectActor_Beam, M_bIsBeamActive) == 0x000448, "Member 'ABFGEffectActor_Beam::M_bIsBeamActive' has a wrong offset!");
static_assert(offsetof(ABFGEffectActor_Beam, M_pTargetActor) == 0x000450, "Member 'ABFGEffectActor_Beam::M_pTargetActor' has a wrong offset!");

// Class BFGCore.BFGSensor_HolobobForgetTarget
// 0x0000 (0x0040 - 0x0040)
class UBFGSensor_HolobobForgetTarget final : public UBFGSensor
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"BFGSensor_HolobobForgetTarget">();
	}
	static class UBFGSensor_HolobobForgetTarget* GetDefaultObj()
	{
		return GetDefaultObjImpl<UBFGSensor_HolobobForgetTarget>();
	}
};
static_assert(alignof(UBFGSensor_HolobobForgetTarget) == 0x000008, "Wrong alignment on UBFGSensor_HolobobForgetTarget");
static_assert(sizeof(UBFGSensor_HolobobForgetTarget) == 0x000040, "Wrong size on UBFGSensor_HolobobForgetTarget");

// Class BFGCore.BFGActorComponent_Animation_Pox
// 0x0000 (0x0258 - 0x0258)
class UBFGActorComponent_Animation_Pox final : public UBFGActorComponent_Animation_Npc
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"BFGActorComponent_Animation_Pox">();
	}
	static class UBFGActorComponent_Animation_Pox* GetDefaultObj()
	{
		return GetDefaultObjImpl<UBFGActorComponent_Animation_Pox>();
	}
};
static_assert(alignof(UBFGActorComponent_Animation_Pox) == 0x000008, "Wrong alignment on UBFGActorComponent_Animation_Pox");
static_assert(sizeof(UBFGActorComponent_Animation_Pox) == 0x000258, "Wrong size on UBFGActorComponent_Animation_Pox");

// Class BFGCore.BFGActorComponent_AOEWarningMarker
// 0x00A8 (0x01D0 - 0x0128)
class UBFGActorComponent_AOEWarningMarker final : public UActorComponent
{
public:
	class UPaperSprite*                           M_pSizeMarkerSprite;                               // 0x0128(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UPaperSprite*                           M_pSizeWarningSprite;                              // 0x0130(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UCurveFloat*                            M_pWarningMarkerCurve;                             // 0x0138(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	UMulticastDelegateProperty_                   M_dOnWarningMarkerComplete;                        // 0x0140(0x0018)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	float                                         M_fHeightOffset_SizeMarker;                        // 0x0158(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         M_fHeightOffset_TimingMarker;                      // 0x015C(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          M_fFollowParentLocation;                           // 0x0160(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_161[0x6F];                                     // 0x0161(0x006F)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void BeginWarningTimeline();
	void SetMarkersHidden(bool _bHidden);
	void SetupWarningMarkerComponents(float _fWarningMarkerRadius, float _fWarningMarkerDuration, const struct FVector& _vWarningMarkerLocation, const struct FRotator& _rWarningMarkerRotation);
	void WarningTimeline_FinishedCallback();
	void WarningTimeline_Interpolation(float _fAlpha);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"BFGActorComponent_AOEWarningMarker">();
	}
	static class UBFGActorComponent_AOEWarningMarker* GetDefaultObj()
	{
		return GetDefaultObjImpl<UBFGActorComponent_AOEWarningMarker>();
	}
};
static_assert(alignof(UBFGActorComponent_AOEWarningMarker) == 0x000008, "Wrong alignment on UBFGActorComponent_AOEWarningMarker");
static_assert(sizeof(UBFGActorComponent_AOEWarningMarker) == 0x0001D0, "Wrong size on UBFGActorComponent_AOEWarningMarker");
static_assert(offsetof(UBFGActorComponent_AOEWarningMarker, M_pSizeMarkerSprite) == 0x000128, "Member 'UBFGActorComponent_AOEWarningMarker::M_pSizeMarkerSprite' has a wrong offset!");
static_assert(offsetof(UBFGActorComponent_AOEWarningMarker, M_pSizeWarningSprite) == 0x000130, "Member 'UBFGActorComponent_AOEWarningMarker::M_pSizeWarningSprite' has a wrong offset!");
static_assert(offsetof(UBFGActorComponent_AOEWarningMarker, M_pWarningMarkerCurve) == 0x000138, "Member 'UBFGActorComponent_AOEWarningMarker::M_pWarningMarkerCurve' has a wrong offset!");
static_assert(offsetof(UBFGActorComponent_AOEWarningMarker, M_dOnWarningMarkerComplete) == 0x000140, "Member 'UBFGActorComponent_AOEWarningMarker::M_dOnWarningMarkerComplete' has a wrong offset!");
static_assert(offsetof(UBFGActorComponent_AOEWarningMarker, M_fHeightOffset_SizeMarker) == 0x000158, "Member 'UBFGActorComponent_AOEWarningMarker::M_fHeightOffset_SizeMarker' has a wrong offset!");
static_assert(offsetof(UBFGActorComponent_AOEWarningMarker, M_fHeightOffset_TimingMarker) == 0x00015C, "Member 'UBFGActorComponent_AOEWarningMarker::M_fHeightOffset_TimingMarker' has a wrong offset!");
static_assert(offsetof(UBFGActorComponent_AOEWarningMarker, M_fFollowParentLocation) == 0x000160, "Member 'UBFGActorComponent_AOEWarningMarker::M_fFollowParentLocation' has a wrong offset!");

// Class BFGCore.BFGProjectile_ProximityMine
// 0x0018 (0x0690 - 0x0678)
class ABFGProjectile_ProximityMine final : public ABFGProjectile_Object
{
public:
	float                                         M_fFuseTime;                                       // 0x0678(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         M_fFuseTimer;                                      // 0x067C(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         M_fProximityRadius;                                // 0x0680(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_684[0x4];                                      // 0x0684(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class AActor*                                 M_pProximityTarget;                                // 0x0688(0x0008)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)

public:
	void OnFuseDone();
	void OnFuseUpdated();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"BFGProjectile_ProximityMine">();
	}
	static class ABFGProjectile_ProximityMine* GetDefaultObj()
	{
		return GetDefaultObjImpl<ABFGProjectile_ProximityMine>();
	}
};
static_assert(alignof(ABFGProjectile_ProximityMine) == 0x000008, "Wrong alignment on ABFGProjectile_ProximityMine");
static_assert(sizeof(ABFGProjectile_ProximityMine) == 0x000690, "Wrong size on ABFGProjectile_ProximityMine");
static_assert(offsetof(ABFGProjectile_ProximityMine, M_fFuseTime) == 0x000678, "Member 'ABFGProjectile_ProximityMine::M_fFuseTime' has a wrong offset!");
static_assert(offsetof(ABFGProjectile_ProximityMine, M_fFuseTimer) == 0x00067C, "Member 'ABFGProjectile_ProximityMine::M_fFuseTimer' has a wrong offset!");
static_assert(offsetof(ABFGProjectile_ProximityMine, M_fProximityRadius) == 0x000680, "Member 'ABFGProjectile_ProximityMine::M_fProximityRadius' has a wrong offset!");
static_assert(offsetof(ABFGProjectile_ProximityMine, M_pProximityTarget) == 0x000688, "Member 'ABFGProjectile_ProximityMine::M_pProximityTarget' has a wrong offset!");

// Class BFGCore.BFGSensor_Timeout
// 0x0008 (0x0048 - 0x0040)
class UBFGSensor_Timeout final : public UBFGSensor
{
public:
	EBFGBehaviourState_NPC                        M_stateAfterTimeout;                               // 0x0040(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_41[0x3];                                       // 0x0041(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         M_fDurationForTimeout;                             // 0x0044(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"BFGSensor_Timeout">();
	}
	static class UBFGSensor_Timeout* GetDefaultObj()
	{
		return GetDefaultObjImpl<UBFGSensor_Timeout>();
	}
};
static_assert(alignof(UBFGSensor_Timeout) == 0x000008, "Wrong alignment on UBFGSensor_Timeout");
static_assert(sizeof(UBFGSensor_Timeout) == 0x000048, "Wrong size on UBFGSensor_Timeout");
static_assert(offsetof(UBFGSensor_Timeout, M_stateAfterTimeout) == 0x000040, "Member 'UBFGSensor_Timeout::M_stateAfterTimeout' has a wrong offset!");
static_assert(offsetof(UBFGSensor_Timeout, M_fDurationForTimeout) == 0x000044, "Member 'UBFGSensor_Timeout::M_fDurationForTimeout' has a wrong offset!");

// Class BFGCore.BFGEventAction_MissionResults
// 0x0198 (0x01C8 - 0x0030)
class UBFGEventAction_MissionResults final : public UBFGEventAction
{
public:
	class UBFGQuest*                              M_pQuest;                                          // 0x0030(0x0008)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	struct FBFGGameplayEndSequence_Data           M_Data;                                            // 0x0038(0x0190)(Protected, NativeAccessSpecifierProtected)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"BFGEventAction_MissionResults">();
	}
	static class UBFGEventAction_MissionResults* GetDefaultObj()
	{
		return GetDefaultObjImpl<UBFGEventAction_MissionResults>();
	}
};
static_assert(alignof(UBFGEventAction_MissionResults) == 0x000008, "Wrong alignment on UBFGEventAction_MissionResults");
static_assert(sizeof(UBFGEventAction_MissionResults) == 0x0001C8, "Wrong size on UBFGEventAction_MissionResults");
static_assert(offsetof(UBFGEventAction_MissionResults, M_pQuest) == 0x000030, "Member 'UBFGEventAction_MissionResults::M_pQuest' has a wrong offset!");
static_assert(offsetof(UBFGEventAction_MissionResults, M_Data) == 0x000038, "Member 'UBFGEventAction_MissionResults::M_Data' has a wrong offset!");

// Class BFGCore.BFGActorComponent_Armor
// 0x0000 (0x0128 - 0x0128)
class UBFGActorComponent_Armor : public UActorComponent
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"BFGActorComponent_Armor">();
	}
	static class UBFGActorComponent_Armor* GetDefaultObj()
	{
		return GetDefaultObjImpl<UBFGActorComponent_Armor>();
	}
};
static_assert(alignof(UBFGActorComponent_Armor) == 0x000008, "Wrong alignment on UBFGActorComponent_Armor");
static_assert(sizeof(UBFGActorComponent_Armor) == 0x000128, "Wrong size on UBFGActorComponent_Armor");

// Class BFGCore.BFGActorComponent_Buffs
// 0x0000 (0x0128 - 0x0128)
class UBFGActorComponent_Buffs final : public UActorComponent
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"BFGActorComponent_Buffs">();
	}
	static class UBFGActorComponent_Buffs* GetDefaultObj()
	{
		return GetDefaultObjImpl<UBFGActorComponent_Buffs>();
	}
};
static_assert(alignof(UBFGActorComponent_Buffs) == 0x000008, "Wrong alignment on UBFGActorComponent_Buffs");
static_assert(sizeof(UBFGActorComponent_Buffs) == 0x000128, "Wrong size on UBFGActorComponent_Buffs");

// Class BFGCore.BFGHypnotizeTargetData
// 0x0010 (0x0038 - 0x0028)
class UBFGHypnotizeTargetData : public UObject
{
public:
	class AActor*                                 M_pTarget;                                         // 0x0028(0x0008)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_30[0x8];                                       // 0x0030(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"BFGHypnotizeTargetData">();
	}
	static class UBFGHypnotizeTargetData* GetDefaultObj()
	{
		return GetDefaultObjImpl<UBFGHypnotizeTargetData>();
	}
};
static_assert(alignof(UBFGHypnotizeTargetData) == 0x000008, "Wrong alignment on UBFGHypnotizeTargetData");
static_assert(sizeof(UBFGHypnotizeTargetData) == 0x000038, "Wrong size on UBFGHypnotizeTargetData");
static_assert(offsetof(UBFGHypnotizeTargetData, M_pTarget) == 0x000028, "Member 'UBFGHypnotizeTargetData::M_pTarget' has a wrong offset!");

// Class BFGCore.BFGHypnotizeTargetData_Forget
// 0x0000 (0x0038 - 0x0038)
class UBFGHypnotizeTargetData_Forget final : public UBFGHypnotizeTargetData
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"BFGHypnotizeTargetData_Forget">();
	}
	static class UBFGHypnotizeTargetData_Forget* GetDefaultObj()
	{
		return GetDefaultObjImpl<UBFGHypnotizeTargetData_Forget>();
	}
};
static_assert(alignof(UBFGHypnotizeTargetData_Forget) == 0x000008, "Wrong alignment on UBFGHypnotizeTargetData_Forget");
static_assert(sizeof(UBFGHypnotizeTargetData_Forget) == 0x000038, "Wrong size on UBFGHypnotizeTargetData_Forget");

// Class BFGCore.BFGSensor_WeaponNoise
// 0x0008 (0x0048 - 0x0040)
class UBFGSensor_WeaponNoise final : public UBFGSensor
{
public:
	EBFGBehaviourState_NPC                        M_targetState;                                     // 0x0040(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_41[0x7];                                       // 0x0041(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"BFGSensor_WeaponNoise">();
	}
	static class UBFGSensor_WeaponNoise* GetDefaultObj()
	{
		return GetDefaultObjImpl<UBFGSensor_WeaponNoise>();
	}
};
static_assert(alignof(UBFGSensor_WeaponNoise) == 0x000008, "Wrong alignment on UBFGSensor_WeaponNoise");
static_assert(sizeof(UBFGSensor_WeaponNoise) == 0x000048, "Wrong size on UBFGSensor_WeaponNoise");
static_assert(offsetof(UBFGSensor_WeaponNoise, M_targetState) == 0x000040, "Member 'UBFGSensor_WeaponNoise::M_targetState' has a wrong offset!");

// Class BFGCore.BFGEffectActor_RBPWreckBeam
// 0x0000 (0x0448 - 0x0448)
class ABFGEffectActor_RBPWreckBeam final : public ABFGEffectActor
{
public:
	void OnActivateBeamFiring();
	void OnActivateTelegraph();
	void OnStopBeamFiring();
	void OnStopTelegraph(bool _bAborted);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"BFGEffectActor_RBPWreckBeam">();
	}
	static class ABFGEffectActor_RBPWreckBeam* GetDefaultObj()
	{
		return GetDefaultObjImpl<ABFGEffectActor_RBPWreckBeam>();
	}
};
static_assert(alignof(ABFGEffectActor_RBPWreckBeam) == 0x000008, "Wrong alignment on ABFGEffectActor_RBPWreckBeam");
static_assert(sizeof(ABFGEffectActor_RBPWreckBeam) == 0x000448, "Wrong size on ABFGEffectActor_RBPWreckBeam");

// Class BFGCore.BFGActorComponent_BuildingLevel
// 0x0108 (0x03A0 - 0x0298)
class UBFGActorComponent_BuildingLevel final : public USceneComponent
{
public:
	TArray<int32>                                 M_aDecorIndices;                                   // 0x0298(0x0010)(ZeroConstructor, Protected, NativeAccessSpecifierProtected)
	struct FBFGBuilding_FloorData                 M_floorData;                                       // 0x02A8(0x0068)(Protected, NativeAccessSpecifierProtected)
	class UStaticMeshComponent*                   M_pMainMesh;                                       // 0x0310(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UBlastMeshComponent*                    M_pDestructMainMesh;                               // 0x0318(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TArray<class UStaticMeshComponent*>           M_apDecor;                                         // 0x0320(0x0010)(ExportObject, ZeroConstructor, ContainsInstancedReference, Protected, NativeAccessSpecifierProtected)
	TArray<class UBlastMeshComponent*>            M_apDestructDecor;                                 // 0x0330(0x0010)(ExportObject, ZeroConstructor, ContainsInstancedReference, Protected, NativeAccessSpecifierProtected)
	struct FBFGBuildingElement                    M_element;                                         // 0x0340(0x0050)(Protected, NativeAccessSpecifierProtected)
	TArray<class ABFGTargetableBuildingPart*>     M_apTargetableBuildingParts;                       // 0x0390(0x0010)(ZeroConstructor, Protected, NativeAccessSpecifierProtected)

public:
	void BuildDecor(const struct FBFGBuilding_LevelDecor& CurrDecorLayout);
	float BuildLevel(class USceneComponent* _pParent, const struct FTransform& _relativeTranform, const struct FBFGBuilding_FloorData& _floorData, const TArray<struct FBFGBuilding_LevelDecor>& _aDecorLayouts);
	bool BuildLevelFromElement(const struct FBFGBuildingElement& _Element, class USceneComponent* _pParent);
	void DestroyMainMeshComponent();
	void MoveRubble(float _fRubbleSinkRate);
	void Reset();
	void SwapDecorForDestruct(EBFGBuilding_DestructionPhase _ePhase);
	void SwapMainForDestruct(EBFGBuilding_DestructionPhase _ePhase);
	void TurnIntoRubble();

	TArray<class UBlastMeshComponent*> GetDecorDestructionComponent(int32 _iDecorIndex) const;
	TArray<class UStaticMeshComponent*> GetDecorMeshComponent(int32 _iDecorIndex) const;
	class UBlastMeshComponent* GetMainDestructionComponent() const;
	class UStaticMeshComponent* GetMainMeshComponent() const;
	int32 GetNumDecorMeshComponents(bool _bDestruction) const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"BFGActorComponent_BuildingLevel">();
	}
	static class UBFGActorComponent_BuildingLevel* GetDefaultObj()
	{
		return GetDefaultObjImpl<UBFGActorComponent_BuildingLevel>();
	}
};
static_assert(alignof(UBFGActorComponent_BuildingLevel) == 0x000010, "Wrong alignment on UBFGActorComponent_BuildingLevel");
static_assert(sizeof(UBFGActorComponent_BuildingLevel) == 0x0003A0, "Wrong size on UBFGActorComponent_BuildingLevel");
static_assert(offsetof(UBFGActorComponent_BuildingLevel, M_aDecorIndices) == 0x000298, "Member 'UBFGActorComponent_BuildingLevel::M_aDecorIndices' has a wrong offset!");
static_assert(offsetof(UBFGActorComponent_BuildingLevel, M_floorData) == 0x0002A8, "Member 'UBFGActorComponent_BuildingLevel::M_floorData' has a wrong offset!");
static_assert(offsetof(UBFGActorComponent_BuildingLevel, M_pMainMesh) == 0x000310, "Member 'UBFGActorComponent_BuildingLevel::M_pMainMesh' has a wrong offset!");
static_assert(offsetof(UBFGActorComponent_BuildingLevel, M_pDestructMainMesh) == 0x000318, "Member 'UBFGActorComponent_BuildingLevel::M_pDestructMainMesh' has a wrong offset!");
static_assert(offsetof(UBFGActorComponent_BuildingLevel, M_apDecor) == 0x000320, "Member 'UBFGActorComponent_BuildingLevel::M_apDecor' has a wrong offset!");
static_assert(offsetof(UBFGActorComponent_BuildingLevel, M_apDestructDecor) == 0x000330, "Member 'UBFGActorComponent_BuildingLevel::M_apDestructDecor' has a wrong offset!");
static_assert(offsetof(UBFGActorComponent_BuildingLevel, M_element) == 0x000340, "Member 'UBFGActorComponent_BuildingLevel::M_element' has a wrong offset!");
static_assert(offsetof(UBFGActorComponent_BuildingLevel, M_apTargetableBuildingParts) == 0x000390, "Member 'UBFGActorComponent_BuildingLevel::M_apTargetableBuildingParts' has a wrong offset!");

// Class BFGCore.BFGMentalAbility_Holobob
// 0x0148 (0x0310 - 0x01C8)
class UBFGMentalAbility_Holobob : public UBFGMentalAbilityBase
{
public:
	UMulticastDelegateProperty_                   M_oOnStartedCancel;                                // 0x01C8(0x0018)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	UMulticastDelegateProperty_                   M_oOnStoppedCancel;                                // 0x01E0(0x0018)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	float                                         M_fMaxConcentration;                               // 0x01F8(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         M_fMaxConcentration_SuppressionAura;               // 0x01FC(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         M_fConcentrationDrainPerSecond;                    // 0x0200(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         M_fConcentrationDrainPerSecond_SuppressionAura;    // 0x0204(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         M_fConcentrationDrainPerSecond_Disrupted;          // 0x0208(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          M_bCryptoVisible;                                  // 0x020C(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          M_bIsHoloCryptoUpdated;                            // 0x020D(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_20E[0x2];                                      // 0x020E(0x0002)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         M_fConcentrationRestoredPerCortexScan;             // 0x0210(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         M_fDecayDelay;                                     // 0x0214(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         M_fInitialDecayDelayModifier;                      // 0x0218(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         M_fMaxDisruptionTime;                              // 0x021C(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         M_fConcentrationPctOffsetSpeedWhileDisrupted;      // 0x0220(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_224[0x4];                                      // 0x0224(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class UDataTable*                             M_pHolobobabbleTagsTable;                          // 0x0228(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FGameplayTag                           M_tagAbilityHolobob;                               // 0x0230(0x0008)(Edit, DisableEditOnInstance, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FGameplayTag                           M_tagAbilityHolobobDisrupted;                      // 0x0238(0x0008)(Edit, DisableEditOnInstance, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	UMulticastDelegateProperty_                   M_onDisruptedEvent;                                // 0x0240(0x0018)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	uint8                                         Pad_258[0x10];                                     // 0x0258(0x0010)(Fixing Size After Last Property [ Dumper-7 ])
	class AActor*                                 M_pLastTarget;                                     // 0x0268(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UBFGCrowdLifeStationComponent*          M_pTargetCrowdLifeStation;                         // 0x0270(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class USkeletalMeshComponent*                 M_pFakeCharacterMesh;                              // 0x0278(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          M_bBlueprintWantsFakeMeshHidden;                   // 0x0280(0x0001)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_281[0x7];                                      // 0x0281(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	class UBFGActorComponent_Animation*           M_pFakeAnimationComp;                              // 0x0288(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UPoseableMeshComponent*                 M_pHoloPoseableSkelMesh;                           // 0x0290(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TArray<class UStaticMeshComponent*>           M_aTargetAccessories;                              // 0x0298(0x0010)(ExportObject, ZeroConstructor, ContainsInstancedReference, Protected, NativeAccessSpecifierProtected)
	TArray<class UStaticMeshComponent*>           M_aFakeAccessories;                                // 0x02A8(0x0010)(ExportObject, ZeroConstructor, ContainsInstancedReference, Protected, NativeAccessSpecifierProtected)
	TArray<struct FGameplayTag>                   M_aCopiedGameplayTags;                             // 0x02B8(0x0010)(ZeroConstructor, Transient, Protected, NativeAccessSpecifierProtected)
	uint8                                         Pad_2C8[0x8];                                      // 0x02C8(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<class UBFGActorComponent_HolobobSuppressionAura*> M_apHolobobSuppressionAuras;                       // 0x02D0(0x0010)(ExportObject, ZeroConstructor, Transient, ContainsInstancedReference, Protected, NativeAccessSpecifierProtected)
	uint8                                         Pad_2E0[0x8];                                      // 0x02E0(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	class UBFGSaveGame*                           M_pSaveGame;                                       // 0x02E8(0x0008)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class USkeletalMesh*                          M_pSavedSkeletalMesh;                              // 0x02F0(0x0008)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UClass*                                 M_pSavedAnimationComponentClass;                   // 0x02F8(0x0008)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          M_bIsCorrupted;                                    // 0x0300(0x0001)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_301[0x3];                                      // 0x0301(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         M_fCorruptionResetDelay;                           // 0x0304(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_308[0x8];                                      // 0x0308(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void ApplyFX_StartDisruptingAbility();
	void ApplyFX_StopDisruptingAbility();
	void ClearFakeAccessoryList();
	void ClearTargetAccessoryList();
	void HandleInputPackChanged(int32 _iInputPackIndex);
	void HideHoloPlayerVisibility();
	void OnActorAttachedToPK(class AActor* _pTarget);
	void OnActorReleasedFromPK(class AActor* _pActor, bool _bThrownOrDropped);
	void OnBrainExtracted(class AActor* _pTarget, class AActor* _pBrain, bool _bIsFromInfection);
	void OnRefreshByCortexScan();
	void OnTransmogAbilityEffect(class UBFGMentalAbilityBase* _pMentalAbility);
	void ReceiveOnSuppressionAuraStateChanged();
	void RemoveFakeHolobobMesh();
	void RemoveHoloPlayerMesh();
	void ShowHoloPlayerVisibility();

	float GetConcentrationDrainedPerSecond() const;
	float GetCurrentConcentrationPercent(bool _bAnimateWhenDisrupted) const;
	TArray<class UStaticMeshComponent*> GetFakeAccessories() const;
	class USkeletalMeshComponent* GetFakeMesh() const;
	class UPoseableMeshComponent* GetHoloPlayerMesh() const;
	bool GetIsCorrupted() const;
	class AActor* GetLastTarget() const;
	float GetMaxConcentration() const;
	TArray<class UStaticMeshComponent*> GetTargetAccessories() const;
	bool IsAbilityDisrupted() const;
	bool IsHolobobSuppressionAuraActive() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"BFGMentalAbility_Holobob">();
	}
	static class UBFGMentalAbility_Holobob* GetDefaultObj()
	{
		return GetDefaultObjImpl<UBFGMentalAbility_Holobob>();
	}
};
static_assert(alignof(UBFGMentalAbility_Holobob) == 0x000008, "Wrong alignment on UBFGMentalAbility_Holobob");
static_assert(sizeof(UBFGMentalAbility_Holobob) == 0x000310, "Wrong size on UBFGMentalAbility_Holobob");
static_assert(offsetof(UBFGMentalAbility_Holobob, M_oOnStartedCancel) == 0x0001C8, "Member 'UBFGMentalAbility_Holobob::M_oOnStartedCancel' has a wrong offset!");
static_assert(offsetof(UBFGMentalAbility_Holobob, M_oOnStoppedCancel) == 0x0001E0, "Member 'UBFGMentalAbility_Holobob::M_oOnStoppedCancel' has a wrong offset!");
static_assert(offsetof(UBFGMentalAbility_Holobob, M_fMaxConcentration) == 0x0001F8, "Member 'UBFGMentalAbility_Holobob::M_fMaxConcentration' has a wrong offset!");
static_assert(offsetof(UBFGMentalAbility_Holobob, M_fMaxConcentration_SuppressionAura) == 0x0001FC, "Member 'UBFGMentalAbility_Holobob::M_fMaxConcentration_SuppressionAura' has a wrong offset!");
static_assert(offsetof(UBFGMentalAbility_Holobob, M_fConcentrationDrainPerSecond) == 0x000200, "Member 'UBFGMentalAbility_Holobob::M_fConcentrationDrainPerSecond' has a wrong offset!");
static_assert(offsetof(UBFGMentalAbility_Holobob, M_fConcentrationDrainPerSecond_SuppressionAura) == 0x000204, "Member 'UBFGMentalAbility_Holobob::M_fConcentrationDrainPerSecond_SuppressionAura' has a wrong offset!");
static_assert(offsetof(UBFGMentalAbility_Holobob, M_fConcentrationDrainPerSecond_Disrupted) == 0x000208, "Member 'UBFGMentalAbility_Holobob::M_fConcentrationDrainPerSecond_Disrupted' has a wrong offset!");
static_assert(offsetof(UBFGMentalAbility_Holobob, M_bCryptoVisible) == 0x00020C, "Member 'UBFGMentalAbility_Holobob::M_bCryptoVisible' has a wrong offset!");
static_assert(offsetof(UBFGMentalAbility_Holobob, M_bIsHoloCryptoUpdated) == 0x00020D, "Member 'UBFGMentalAbility_Holobob::M_bIsHoloCryptoUpdated' has a wrong offset!");
static_assert(offsetof(UBFGMentalAbility_Holobob, M_fConcentrationRestoredPerCortexScan) == 0x000210, "Member 'UBFGMentalAbility_Holobob::M_fConcentrationRestoredPerCortexScan' has a wrong offset!");
static_assert(offsetof(UBFGMentalAbility_Holobob, M_fDecayDelay) == 0x000214, "Member 'UBFGMentalAbility_Holobob::M_fDecayDelay' has a wrong offset!");
static_assert(offsetof(UBFGMentalAbility_Holobob, M_fInitialDecayDelayModifier) == 0x000218, "Member 'UBFGMentalAbility_Holobob::M_fInitialDecayDelayModifier' has a wrong offset!");
static_assert(offsetof(UBFGMentalAbility_Holobob, M_fMaxDisruptionTime) == 0x00021C, "Member 'UBFGMentalAbility_Holobob::M_fMaxDisruptionTime' has a wrong offset!");
static_assert(offsetof(UBFGMentalAbility_Holobob, M_fConcentrationPctOffsetSpeedWhileDisrupted) == 0x000220, "Member 'UBFGMentalAbility_Holobob::M_fConcentrationPctOffsetSpeedWhileDisrupted' has a wrong offset!");
static_assert(offsetof(UBFGMentalAbility_Holobob, M_pHolobobabbleTagsTable) == 0x000228, "Member 'UBFGMentalAbility_Holobob::M_pHolobobabbleTagsTable' has a wrong offset!");
static_assert(offsetof(UBFGMentalAbility_Holobob, M_tagAbilityHolobob) == 0x000230, "Member 'UBFGMentalAbility_Holobob::M_tagAbilityHolobob' has a wrong offset!");
static_assert(offsetof(UBFGMentalAbility_Holobob, M_tagAbilityHolobobDisrupted) == 0x000238, "Member 'UBFGMentalAbility_Holobob::M_tagAbilityHolobobDisrupted' has a wrong offset!");
static_assert(offsetof(UBFGMentalAbility_Holobob, M_onDisruptedEvent) == 0x000240, "Member 'UBFGMentalAbility_Holobob::M_onDisruptedEvent' has a wrong offset!");
static_assert(offsetof(UBFGMentalAbility_Holobob, M_pLastTarget) == 0x000268, "Member 'UBFGMentalAbility_Holobob::M_pLastTarget' has a wrong offset!");
static_assert(offsetof(UBFGMentalAbility_Holobob, M_pTargetCrowdLifeStation) == 0x000270, "Member 'UBFGMentalAbility_Holobob::M_pTargetCrowdLifeStation' has a wrong offset!");
static_assert(offsetof(UBFGMentalAbility_Holobob, M_pFakeCharacterMesh) == 0x000278, "Member 'UBFGMentalAbility_Holobob::M_pFakeCharacterMesh' has a wrong offset!");
static_assert(offsetof(UBFGMentalAbility_Holobob, M_bBlueprintWantsFakeMeshHidden) == 0x000280, "Member 'UBFGMentalAbility_Holobob::M_bBlueprintWantsFakeMeshHidden' has a wrong offset!");
static_assert(offsetof(UBFGMentalAbility_Holobob, M_pFakeAnimationComp) == 0x000288, "Member 'UBFGMentalAbility_Holobob::M_pFakeAnimationComp' has a wrong offset!");
static_assert(offsetof(UBFGMentalAbility_Holobob, M_pHoloPoseableSkelMesh) == 0x000290, "Member 'UBFGMentalAbility_Holobob::M_pHoloPoseableSkelMesh' has a wrong offset!");
static_assert(offsetof(UBFGMentalAbility_Holobob, M_aTargetAccessories) == 0x000298, "Member 'UBFGMentalAbility_Holobob::M_aTargetAccessories' has a wrong offset!");
static_assert(offsetof(UBFGMentalAbility_Holobob, M_aFakeAccessories) == 0x0002A8, "Member 'UBFGMentalAbility_Holobob::M_aFakeAccessories' has a wrong offset!");
static_assert(offsetof(UBFGMentalAbility_Holobob, M_aCopiedGameplayTags) == 0x0002B8, "Member 'UBFGMentalAbility_Holobob::M_aCopiedGameplayTags' has a wrong offset!");
static_assert(offsetof(UBFGMentalAbility_Holobob, M_apHolobobSuppressionAuras) == 0x0002D0, "Member 'UBFGMentalAbility_Holobob::M_apHolobobSuppressionAuras' has a wrong offset!");
static_assert(offsetof(UBFGMentalAbility_Holobob, M_pSaveGame) == 0x0002E8, "Member 'UBFGMentalAbility_Holobob::M_pSaveGame' has a wrong offset!");
static_assert(offsetof(UBFGMentalAbility_Holobob, M_pSavedSkeletalMesh) == 0x0002F0, "Member 'UBFGMentalAbility_Holobob::M_pSavedSkeletalMesh' has a wrong offset!");
static_assert(offsetof(UBFGMentalAbility_Holobob, M_pSavedAnimationComponentClass) == 0x0002F8, "Member 'UBFGMentalAbility_Holobob::M_pSavedAnimationComponentClass' has a wrong offset!");
static_assert(offsetof(UBFGMentalAbility_Holobob, M_bIsCorrupted) == 0x000300, "Member 'UBFGMentalAbility_Holobob::M_bIsCorrupted' has a wrong offset!");
static_assert(offsetof(UBFGMentalAbility_Holobob, M_fCorruptionResetDelay) == 0x000304, "Member 'UBFGMentalAbility_Holobob::M_fCorruptionResetDelay' has a wrong offset!");

// Class BFGCore.BFGActorComponent_CameraHandle
// 0x0328 (0x05C0 - 0x0298)
class UBFGActorComponent_CameraHandle final : public USceneComponent
{
public:
	uint8                                         Pad_298[0x8];                                      // 0x0298(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	struct FBFGAngleDamper                        M_oNormalYawDamper;                                // 0x02A0(0x0018)(Edit, Protected, NativeAccessSpecifierProtected)
	struct FBFGAngleDamper                        M_oNormalPitchDamper;                              // 0x02B8(0x0018)(Edit, Protected, NativeAccessSpecifierProtected)
	float                                         M_fNormalFOV;                                      // 0x02D0(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_2D4[0x3C];                                     // 0x02D4(0x003C)(Fixing Size After Last Property [ Dumper-7 ])
	class UCameraComponent*                       M_pCamera;                                         // 0x0310(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_318[0x8];                                      // 0x0318(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	class UCurveFloat*                            M_pTargetArmLengthCurve;                           // 0x0320(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	struct FVector                                M_vSocketOffset;                                   // 0x0328(0x000C)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_334[0x4];                                      // 0x0334(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class UCurveVector*                           M_pArmOriginOffsetCurve;                           // 0x0338(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         M_fProbeSize;                                      // 0x0340(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	ECollisionChannel                             M_eProbeChannel;                                   // 0x0344(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          M_bDoCollisionTest;                                // 0x0345(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_346[0x2];                                      // 0x0346(0x0002)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         M_fCameraInSpeed;                                  // 0x0348(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         M_fCameraOutSpeed;                                 // 0x034C(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_350[0x70];                                     // 0x0350(0x0070)(Fixing Size After Last Property [ Dumper-7 ])
	class UBFGActorComponent_TargetSystem*        M_pTargetSystemComponent;                          // 0x03C0(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         M_fSnapToInterpTime;                               // 0x03C8(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	int32                                         M_iSnapToMaxIterations;                            // 0x03CC(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         M_fSnapToPrecision;                                // 0x03D0(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_3D4[0x4];                                      // 0x03D4(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class AActor*                                 M_pSnapToTarget;                                   // 0x03D8(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_3E0[0xC];                                      // 0x03E0(0x000C)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         M_fViewPitchMin;                                   // 0x03EC(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         M_fViewPitchMax;                                   // 0x03F0(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         M_fViewYawMin;                                     // 0x03F4(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         M_fViewYawMax;                                     // 0x03F8(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         M_fViewRollMin;                                    // 0x03FC(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         M_fViewRollMax;                                    // 0x0400(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	struct FVector                                M_vDefaultLocation;                                // 0x0404(0x000C)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_410[0xC];                                      // 0x0410(0x000C)(Fixing Size After Last Property [ Dumper-7 ])
	struct FRotator                               M_oDefaultRotation;                                // 0x041C(0x000C)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, NativeAccessSpecifierProtected)
	float                                         M_fDefaultRotationBlendSpeed;                      // 0x0428(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_42C[0xC];                                      // 0x042C(0x000C)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         M_fDefaultRotationMaxBlendTime;                    // 0x0438(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_43C[0x8];                                      // 0x043C(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	bool                                          M_bUseExplorationCamera;                           // 0x0444(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_445[0x3];                                      // 0x0445(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         M_fExplorationCameraTriggerTime;                   // 0x0448(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         M_fExplorationCameraBlendSpeed;                    // 0x044C(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         M_fExplorationCameraBlendInTime;                   // 0x0450(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_454[0x10];                                     // 0x0454(0x0010)(Fixing Size After Last Property [ Dumper-7 ])
	bool                                          M_bCameraLocationLagEnabled;                       // 0x0464(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_465[0x3];                                      // 0x0465(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	struct FVector                                M_vCameraLocationLagSpeed;                         // 0x0468(0x000C)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         M_vCameraLagMaxDistance;                           // 0x0474(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          M_bUseCameraLagSubstepping;                        // 0x0478(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_479[0x7];                                      // 0x0479(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         M_fBlendToCameraHandlePhase1AngleThreshold;        // 0x0480(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_484[0x4];                                      // 0x0484(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class UBFGActorComponent_CameraHandle*        M_pBlendCameraHandleSource;                        // 0x0488(0x0008)(ExportObject, ZeroConstructor, Transient, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_490[0x60];                                     // 0x0490(0x0060)(Fixing Size After Last Property [ Dumper-7 ])
	class UBFGActorComponent_LockOnTarget*        M_pCurrentLockOnTarget;                            // 0x04F0(0x0008)(ExportObject, ZeroConstructor, Transient, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UBFGActorComponent_LockOnTarget*        M_pLastLockOnTarget;                               // 0x04F8(0x0008)(ExportObject, ZeroConstructor, Transient, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_500[0x10];                                     // 0x0500(0x0010)(Fixing Size After Last Property [ Dumper-7 ])
	class UCurveFloat*                            M_pLockOnTargetLagCurve;                           // 0x0510(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         M_fLockOnTargetLagMinDistance;                     // 0x0518(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         M_fLockOnTargetLagMinDistanceStop;                 // 0x051C(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UCurveFloat*                            M_pInterpolationSpeedCurve;                        // 0x0520(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         M_fLockOnArmLengthOverride;                        // 0x0528(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         M_fLockOnBlendInTime;                              // 0x052C(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         M_fLockOnBlendOutTime;                             // 0x0530(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_534[0x4];                                      // 0x0534(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         M_fPitchClamp;                                     // 0x0538(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         M_fLockOnSnapTime;                                 // 0x053C(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         M_fLockOnSnapTimeInterpolation;                    // 0x0540(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	int32                                         M_iPitchSmootingValueCount;                        // 0x0544(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_548[0x28];                                     // 0x0548(0x0028)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<struct FBFGCameraHandleModeData>       M_aCurrentModeOverrides;                           // 0x0570(0x0010)(Edit, ZeroConstructor, Protected, NativeAccessSpecifierProtected)
	float                                         M_fChangeModeTime;                                 // 0x0580(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_584[0x4];                                      // 0x0584(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         M_fHideCharactersSphereRadius;                     // 0x0588(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_58C[0x4];                                      // 0x058C(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<class AActor*>                         M_apHiddenCharacters;                              // 0x0590(0x0010)(ZeroConstructor, Transient, Protected, NativeAccessSpecifierProtected)
	int32                                         M_iFeelerCount;                                    // 0x05A0(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         M_fFeelerMaxAngle;                                 // 0x05A4(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         M_fOffsetInterpolationSpeed;                       // 0x05A8(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         M_fFeelerCameraOverlapSphereRadius;                // 0x05AC(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_5B0[0x10];                                     // 0x05B0(0x0010)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void AddTimeCurve(EBFGCameraTimeCurveFunction _eFunction, class UCurveFloat* _pCurve, float _fStartTime, float _fDuration, bool _bKeepLastValue);
	void ClearTimeCurves();
	void ClearTimeCurvesByFunction(EBFGCameraTimeCurveFunction _eFunction);
	void ReplaceTimeCurve(EBFGCameraTimeCurveFunction _eFunction, class UCurveFloat* _pCurve, float _fStartTime, float _fDuration, bool _bKeepLastValue);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"BFGActorComponent_CameraHandle">();
	}
	static class UBFGActorComponent_CameraHandle* GetDefaultObj()
	{
		return GetDefaultObjImpl<UBFGActorComponent_CameraHandle>();
	}
};
static_assert(alignof(UBFGActorComponent_CameraHandle) == 0x000008, "Wrong alignment on UBFGActorComponent_CameraHandle");
static_assert(sizeof(UBFGActorComponent_CameraHandle) == 0x0005C0, "Wrong size on UBFGActorComponent_CameraHandle");
static_assert(offsetof(UBFGActorComponent_CameraHandle, M_oNormalYawDamper) == 0x0002A0, "Member 'UBFGActorComponent_CameraHandle::M_oNormalYawDamper' has a wrong offset!");
static_assert(offsetof(UBFGActorComponent_CameraHandle, M_oNormalPitchDamper) == 0x0002B8, "Member 'UBFGActorComponent_CameraHandle::M_oNormalPitchDamper' has a wrong offset!");
static_assert(offsetof(UBFGActorComponent_CameraHandle, M_fNormalFOV) == 0x0002D0, "Member 'UBFGActorComponent_CameraHandle::M_fNormalFOV' has a wrong offset!");
static_assert(offsetof(UBFGActorComponent_CameraHandle, M_pCamera) == 0x000310, "Member 'UBFGActorComponent_CameraHandle::M_pCamera' has a wrong offset!");
static_assert(offsetof(UBFGActorComponent_CameraHandle, M_pTargetArmLengthCurve) == 0x000320, "Member 'UBFGActorComponent_CameraHandle::M_pTargetArmLengthCurve' has a wrong offset!");
static_assert(offsetof(UBFGActorComponent_CameraHandle, M_vSocketOffset) == 0x000328, "Member 'UBFGActorComponent_CameraHandle::M_vSocketOffset' has a wrong offset!");
static_assert(offsetof(UBFGActorComponent_CameraHandle, M_pArmOriginOffsetCurve) == 0x000338, "Member 'UBFGActorComponent_CameraHandle::M_pArmOriginOffsetCurve' has a wrong offset!");
static_assert(offsetof(UBFGActorComponent_CameraHandle, M_fProbeSize) == 0x000340, "Member 'UBFGActorComponent_CameraHandle::M_fProbeSize' has a wrong offset!");
static_assert(offsetof(UBFGActorComponent_CameraHandle, M_eProbeChannel) == 0x000344, "Member 'UBFGActorComponent_CameraHandle::M_eProbeChannel' has a wrong offset!");
static_assert(offsetof(UBFGActorComponent_CameraHandle, M_bDoCollisionTest) == 0x000345, "Member 'UBFGActorComponent_CameraHandle::M_bDoCollisionTest' has a wrong offset!");
static_assert(offsetof(UBFGActorComponent_CameraHandle, M_fCameraInSpeed) == 0x000348, "Member 'UBFGActorComponent_CameraHandle::M_fCameraInSpeed' has a wrong offset!");
static_assert(offsetof(UBFGActorComponent_CameraHandle, M_fCameraOutSpeed) == 0x00034C, "Member 'UBFGActorComponent_CameraHandle::M_fCameraOutSpeed' has a wrong offset!");
static_assert(offsetof(UBFGActorComponent_CameraHandle, M_pTargetSystemComponent) == 0x0003C0, "Member 'UBFGActorComponent_CameraHandle::M_pTargetSystemComponent' has a wrong offset!");
static_assert(offsetof(UBFGActorComponent_CameraHandle, M_fSnapToInterpTime) == 0x0003C8, "Member 'UBFGActorComponent_CameraHandle::M_fSnapToInterpTime' has a wrong offset!");
static_assert(offsetof(UBFGActorComponent_CameraHandle, M_iSnapToMaxIterations) == 0x0003CC, "Member 'UBFGActorComponent_CameraHandle::M_iSnapToMaxIterations' has a wrong offset!");
static_assert(offsetof(UBFGActorComponent_CameraHandle, M_fSnapToPrecision) == 0x0003D0, "Member 'UBFGActorComponent_CameraHandle::M_fSnapToPrecision' has a wrong offset!");
static_assert(offsetof(UBFGActorComponent_CameraHandle, M_pSnapToTarget) == 0x0003D8, "Member 'UBFGActorComponent_CameraHandle::M_pSnapToTarget' has a wrong offset!");
static_assert(offsetof(UBFGActorComponent_CameraHandle, M_fViewPitchMin) == 0x0003EC, "Member 'UBFGActorComponent_CameraHandle::M_fViewPitchMin' has a wrong offset!");
static_assert(offsetof(UBFGActorComponent_CameraHandle, M_fViewPitchMax) == 0x0003F0, "Member 'UBFGActorComponent_CameraHandle::M_fViewPitchMax' has a wrong offset!");
static_assert(offsetof(UBFGActorComponent_CameraHandle, M_fViewYawMin) == 0x0003F4, "Member 'UBFGActorComponent_CameraHandle::M_fViewYawMin' has a wrong offset!");
static_assert(offsetof(UBFGActorComponent_CameraHandle, M_fViewYawMax) == 0x0003F8, "Member 'UBFGActorComponent_CameraHandle::M_fViewYawMax' has a wrong offset!");
static_assert(offsetof(UBFGActorComponent_CameraHandle, M_fViewRollMin) == 0x0003FC, "Member 'UBFGActorComponent_CameraHandle::M_fViewRollMin' has a wrong offset!");
static_assert(offsetof(UBFGActorComponent_CameraHandle, M_fViewRollMax) == 0x000400, "Member 'UBFGActorComponent_CameraHandle::M_fViewRollMax' has a wrong offset!");
static_assert(offsetof(UBFGActorComponent_CameraHandle, M_vDefaultLocation) == 0x000404, "Member 'UBFGActorComponent_CameraHandle::M_vDefaultLocation' has a wrong offset!");
static_assert(offsetof(UBFGActorComponent_CameraHandle, M_oDefaultRotation) == 0x00041C, "Member 'UBFGActorComponent_CameraHandle::M_oDefaultRotation' has a wrong offset!");
static_assert(offsetof(UBFGActorComponent_CameraHandle, M_fDefaultRotationBlendSpeed) == 0x000428, "Member 'UBFGActorComponent_CameraHandle::M_fDefaultRotationBlendSpeed' has a wrong offset!");
static_assert(offsetof(UBFGActorComponent_CameraHandle, M_fDefaultRotationMaxBlendTime) == 0x000438, "Member 'UBFGActorComponent_CameraHandle::M_fDefaultRotationMaxBlendTime' has a wrong offset!");
static_assert(offsetof(UBFGActorComponent_CameraHandle, M_bUseExplorationCamera) == 0x000444, "Member 'UBFGActorComponent_CameraHandle::M_bUseExplorationCamera' has a wrong offset!");
static_assert(offsetof(UBFGActorComponent_CameraHandle, M_fExplorationCameraTriggerTime) == 0x000448, "Member 'UBFGActorComponent_CameraHandle::M_fExplorationCameraTriggerTime' has a wrong offset!");
static_assert(offsetof(UBFGActorComponent_CameraHandle, M_fExplorationCameraBlendSpeed) == 0x00044C, "Member 'UBFGActorComponent_CameraHandle::M_fExplorationCameraBlendSpeed' has a wrong offset!");
static_assert(offsetof(UBFGActorComponent_CameraHandle, M_fExplorationCameraBlendInTime) == 0x000450, "Member 'UBFGActorComponent_CameraHandle::M_fExplorationCameraBlendInTime' has a wrong offset!");
static_assert(offsetof(UBFGActorComponent_CameraHandle, M_bCameraLocationLagEnabled) == 0x000464, "Member 'UBFGActorComponent_CameraHandle::M_bCameraLocationLagEnabled' has a wrong offset!");
static_assert(offsetof(UBFGActorComponent_CameraHandle, M_vCameraLocationLagSpeed) == 0x000468, "Member 'UBFGActorComponent_CameraHandle::M_vCameraLocationLagSpeed' has a wrong offset!");
static_assert(offsetof(UBFGActorComponent_CameraHandle, M_vCameraLagMaxDistance) == 0x000474, "Member 'UBFGActorComponent_CameraHandle::M_vCameraLagMaxDistance' has a wrong offset!");
static_assert(offsetof(UBFGActorComponent_CameraHandle, M_bUseCameraLagSubstepping) == 0x000478, "Member 'UBFGActorComponent_CameraHandle::M_bUseCameraLagSubstepping' has a wrong offset!");
static_assert(offsetof(UBFGActorComponent_CameraHandle, M_fBlendToCameraHandlePhase1AngleThreshold) == 0x000480, "Member 'UBFGActorComponent_CameraHandle::M_fBlendToCameraHandlePhase1AngleThreshold' has a wrong offset!");
static_assert(offsetof(UBFGActorComponent_CameraHandle, M_pBlendCameraHandleSource) == 0x000488, "Member 'UBFGActorComponent_CameraHandle::M_pBlendCameraHandleSource' has a wrong offset!");
static_assert(offsetof(UBFGActorComponent_CameraHandle, M_pCurrentLockOnTarget) == 0x0004F0, "Member 'UBFGActorComponent_CameraHandle::M_pCurrentLockOnTarget' has a wrong offset!");
static_assert(offsetof(UBFGActorComponent_CameraHandle, M_pLastLockOnTarget) == 0x0004F8, "Member 'UBFGActorComponent_CameraHandle::M_pLastLockOnTarget' has a wrong offset!");
static_assert(offsetof(UBFGActorComponent_CameraHandle, M_pLockOnTargetLagCurve) == 0x000510, "Member 'UBFGActorComponent_CameraHandle::M_pLockOnTargetLagCurve' has a wrong offset!");
static_assert(offsetof(UBFGActorComponent_CameraHandle, M_fLockOnTargetLagMinDistance) == 0x000518, "Member 'UBFGActorComponent_CameraHandle::M_fLockOnTargetLagMinDistance' has a wrong offset!");
static_assert(offsetof(UBFGActorComponent_CameraHandle, M_fLockOnTargetLagMinDistanceStop) == 0x00051C, "Member 'UBFGActorComponent_CameraHandle::M_fLockOnTargetLagMinDistanceStop' has a wrong offset!");
static_assert(offsetof(UBFGActorComponent_CameraHandle, M_pInterpolationSpeedCurve) == 0x000520, "Member 'UBFGActorComponent_CameraHandle::M_pInterpolationSpeedCurve' has a wrong offset!");
static_assert(offsetof(UBFGActorComponent_CameraHandle, M_fLockOnArmLengthOverride) == 0x000528, "Member 'UBFGActorComponent_CameraHandle::M_fLockOnArmLengthOverride' has a wrong offset!");
static_assert(offsetof(UBFGActorComponent_CameraHandle, M_fLockOnBlendInTime) == 0x00052C, "Member 'UBFGActorComponent_CameraHandle::M_fLockOnBlendInTime' has a wrong offset!");
static_assert(offsetof(UBFGActorComponent_CameraHandle, M_fLockOnBlendOutTime) == 0x000530, "Member 'UBFGActorComponent_CameraHandle::M_fLockOnBlendOutTime' has a wrong offset!");
static_assert(offsetof(UBFGActorComponent_CameraHandle, M_fPitchClamp) == 0x000538, "Member 'UBFGActorComponent_CameraHandle::M_fPitchClamp' has a wrong offset!");
static_assert(offsetof(UBFGActorComponent_CameraHandle, M_fLockOnSnapTime) == 0x00053C, "Member 'UBFGActorComponent_CameraHandle::M_fLockOnSnapTime' has a wrong offset!");
static_assert(offsetof(UBFGActorComponent_CameraHandle, M_fLockOnSnapTimeInterpolation) == 0x000540, "Member 'UBFGActorComponent_CameraHandle::M_fLockOnSnapTimeInterpolation' has a wrong offset!");
static_assert(offsetof(UBFGActorComponent_CameraHandle, M_iPitchSmootingValueCount) == 0x000544, "Member 'UBFGActorComponent_CameraHandle::M_iPitchSmootingValueCount' has a wrong offset!");
static_assert(offsetof(UBFGActorComponent_CameraHandle, M_aCurrentModeOverrides) == 0x000570, "Member 'UBFGActorComponent_CameraHandle::M_aCurrentModeOverrides' has a wrong offset!");
static_assert(offsetof(UBFGActorComponent_CameraHandle, M_fChangeModeTime) == 0x000580, "Member 'UBFGActorComponent_CameraHandle::M_fChangeModeTime' has a wrong offset!");
static_assert(offsetof(UBFGActorComponent_CameraHandle, M_fHideCharactersSphereRadius) == 0x000588, "Member 'UBFGActorComponent_CameraHandle::M_fHideCharactersSphereRadius' has a wrong offset!");
static_assert(offsetof(UBFGActorComponent_CameraHandle, M_apHiddenCharacters) == 0x000590, "Member 'UBFGActorComponent_CameraHandle::M_apHiddenCharacters' has a wrong offset!");
static_assert(offsetof(UBFGActorComponent_CameraHandle, M_iFeelerCount) == 0x0005A0, "Member 'UBFGActorComponent_CameraHandle::M_iFeelerCount' has a wrong offset!");
static_assert(offsetof(UBFGActorComponent_CameraHandle, M_fFeelerMaxAngle) == 0x0005A4, "Member 'UBFGActorComponent_CameraHandle::M_fFeelerMaxAngle' has a wrong offset!");
static_assert(offsetof(UBFGActorComponent_CameraHandle, M_fOffsetInterpolationSpeed) == 0x0005A8, "Member 'UBFGActorComponent_CameraHandle::M_fOffsetInterpolationSpeed' has a wrong offset!");
static_assert(offsetof(UBFGActorComponent_CameraHandle, M_fFeelerCameraOverlapSphereRadius) == 0x0005AC, "Member 'UBFGActorComponent_CameraHandle::M_fFeelerCameraOverlapSphereRadius' has a wrong offset!");

// Class BFGCore.BFGTaskNode_EnemyIdle
// 0x0000 (0x0070 - 0x0070)
class UBFGTaskNode_EnemyIdle final : public UBTTaskNode
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"BFGTaskNode_EnemyIdle">();
	}
	static class UBFGTaskNode_EnemyIdle* GetDefaultObj()
	{
		return GetDefaultObjImpl<UBFGTaskNode_EnemyIdle>();
	}
};
static_assert(alignof(UBFGTaskNode_EnemyIdle) == 0x000008, "Wrong alignment on UBFGTaskNode_EnemyIdle");
static_assert(sizeof(UBFGTaskNode_EnemyIdle) == 0x000070, "Wrong size on UBFGTaskNode_EnemyIdle");

// Class BFGCore.BFGEventAction_VariableToDefault
// 0x0008 (0x0038 - 0x0030)
class UBFGEventAction_VariableToDefault final : public UBFGEventAction
{
public:
	uint8                                         Pad_30[0x8];                                       // 0x0030(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"BFGEventAction_VariableToDefault">();
	}
	static class UBFGEventAction_VariableToDefault* GetDefaultObj()
	{
		return GetDefaultObjImpl<UBFGEventAction_VariableToDefault>();
	}
};
static_assert(alignof(UBFGEventAction_VariableToDefault) == 0x000008, "Wrong alignment on UBFGEventAction_VariableToDefault");
static_assert(sizeof(UBFGEventAction_VariableToDefault) == 0x000038, "Wrong size on UBFGEventAction_VariableToDefault");

// Class BFGCore.BFGNetworkPathAgent_AIStateFollowPath
// 0x00A8 (0x0100 - 0x0058)
class UBFGNetworkPathAgent_AIStateFollowPath final : public UBFGNetworkPathAgent_AIStateBase
{
public:
	uint8                                         Pad_58[0x8];                                       // 0x0058(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	struct FTransform                             M_Transform;                                       // 0x0060(0x0030)(Transient, IsPlainOldData, NoDestructor, Protected, NativeAccessSpecifierProtected)
	struct FSplineCurves                          M_path;                                            // 0x0090(0x0060)(Transient, Protected, NativeAccessSpecifierProtected)
	bool                                          M_bStopAtEnd;                                      // 0x00F0(0x0001)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_F1[0xF];                                       // 0x00F1(0x000F)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"BFGNetworkPathAgent_AIStateFollowPath">();
	}
	static class UBFGNetworkPathAgent_AIStateFollowPath* GetDefaultObj()
	{
		return GetDefaultObjImpl<UBFGNetworkPathAgent_AIStateFollowPath>();
	}
};
static_assert(alignof(UBFGNetworkPathAgent_AIStateFollowPath) == 0x000010, "Wrong alignment on UBFGNetworkPathAgent_AIStateFollowPath");
static_assert(sizeof(UBFGNetworkPathAgent_AIStateFollowPath) == 0x000100, "Wrong size on UBFGNetworkPathAgent_AIStateFollowPath");
static_assert(offsetof(UBFGNetworkPathAgent_AIStateFollowPath, M_Transform) == 0x000060, "Member 'UBFGNetworkPathAgent_AIStateFollowPath::M_Transform' has a wrong offset!");
static_assert(offsetof(UBFGNetworkPathAgent_AIStateFollowPath, M_path) == 0x000090, "Member 'UBFGNetworkPathAgent_AIStateFollowPath::M_path' has a wrong offset!");
static_assert(offsetof(UBFGNetworkPathAgent_AIStateFollowPath, M_bStopAtEnd) == 0x0000F0, "Member 'UBFGNetworkPathAgent_AIStateFollowPath::M_bStopAtEnd' has a wrong offset!");

// Class BFGCore.BFGActorComponent_CharacterMovement
// 0x0160 (0x08F0 - 0x0790)
#pragma pack(push, 0x1)
class alignas(0x10) UBFGActorComponent_CharacterMovement : public UCharacterMovementComponent
{
public:
	uint8                                         Pad_790[0x88];                                     // 0x0790(0x0088)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         M_fStartRotation90DegreeThreshold;                 // 0x0818(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         M_fStartRotation180DegreeThreshold;                // 0x081C(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         M_fCancelStartTurnThreshold;                       // 0x0820(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         M_fStartTargetDirectionCaptureWindow;              // 0x0824(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         M_fStartTurn90DeltaAngleCaptueWindow;              // 0x0828(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         M_fStartTurn180DeltaAngleCaptueWindow;             // 0x082C(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_830[0x20];                                     // 0x0830(0x0020)(Fixing Size After Last Property [ Dumper-7 ])
	bool                                          M_bSweepStopPredictions;                           // 0x0850(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_851[0x1B];                                     // 0x0851(0x001B)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         M_fPivotMinInputSize;                              // 0x086C(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         M_fPivotDetectionTime;                             // 0x0870(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         M_fPrePivotDistanceCutoff;                         // 0x0874(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         M_fHolobobJumpAcceleration;                        // 0x0878(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_87C[0x64];                                     // 0x087C(0x0064)(Fixing Size After Last Property [ Dumper-7 ])
	class UBFGActorComponent_CharacterPhysics*    M_pCachedPhysicsComponent;                         // 0x08E0(0x0008)(ExportObject, ZeroConstructor, Transient, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"BFGActorComponent_CharacterMovement">();
	}
	static class UBFGActorComponent_CharacterMovement* GetDefaultObj()
	{
		return GetDefaultObjImpl<UBFGActorComponent_CharacterMovement>();
	}
};
#pragma pack(pop)
static_assert(alignof(UBFGActorComponent_CharacterMovement) == 0x000010, "Wrong alignment on UBFGActorComponent_CharacterMovement");
static_assert(sizeof(UBFGActorComponent_CharacterMovement) == 0x0008F0, "Wrong size on UBFGActorComponent_CharacterMovement");
static_assert(offsetof(UBFGActorComponent_CharacterMovement, M_fStartRotation90DegreeThreshold) == 0x000818, "Member 'UBFGActorComponent_CharacterMovement::M_fStartRotation90DegreeThreshold' has a wrong offset!");
static_assert(offsetof(UBFGActorComponent_CharacterMovement, M_fStartRotation180DegreeThreshold) == 0x00081C, "Member 'UBFGActorComponent_CharacterMovement::M_fStartRotation180DegreeThreshold' has a wrong offset!");
static_assert(offsetof(UBFGActorComponent_CharacterMovement, M_fCancelStartTurnThreshold) == 0x000820, "Member 'UBFGActorComponent_CharacterMovement::M_fCancelStartTurnThreshold' has a wrong offset!");
static_assert(offsetof(UBFGActorComponent_CharacterMovement, M_fStartTargetDirectionCaptureWindow) == 0x000824, "Member 'UBFGActorComponent_CharacterMovement::M_fStartTargetDirectionCaptureWindow' has a wrong offset!");
static_assert(offsetof(UBFGActorComponent_CharacterMovement, M_fStartTurn90DeltaAngleCaptueWindow) == 0x000828, "Member 'UBFGActorComponent_CharacterMovement::M_fStartTurn90DeltaAngleCaptueWindow' has a wrong offset!");
static_assert(offsetof(UBFGActorComponent_CharacterMovement, M_fStartTurn180DeltaAngleCaptueWindow) == 0x00082C, "Member 'UBFGActorComponent_CharacterMovement::M_fStartTurn180DeltaAngleCaptueWindow' has a wrong offset!");
static_assert(offsetof(UBFGActorComponent_CharacterMovement, M_bSweepStopPredictions) == 0x000850, "Member 'UBFGActorComponent_CharacterMovement::M_bSweepStopPredictions' has a wrong offset!");
static_assert(offsetof(UBFGActorComponent_CharacterMovement, M_fPivotMinInputSize) == 0x00086C, "Member 'UBFGActorComponent_CharacterMovement::M_fPivotMinInputSize' has a wrong offset!");
static_assert(offsetof(UBFGActorComponent_CharacterMovement, M_fPivotDetectionTime) == 0x000870, "Member 'UBFGActorComponent_CharacterMovement::M_fPivotDetectionTime' has a wrong offset!");
static_assert(offsetof(UBFGActorComponent_CharacterMovement, M_fPrePivotDistanceCutoff) == 0x000874, "Member 'UBFGActorComponent_CharacterMovement::M_fPrePivotDistanceCutoff' has a wrong offset!");
static_assert(offsetof(UBFGActorComponent_CharacterMovement, M_fHolobobJumpAcceleration) == 0x000878, "Member 'UBFGActorComponent_CharacterMovement::M_fHolobobJumpAcceleration' has a wrong offset!");
static_assert(offsetof(UBFGActorComponent_CharacterMovement, M_pCachedPhysicsComponent) == 0x0008E0, "Member 'UBFGActorComponent_CharacterMovement::M_pCachedPhysicsComponent' has a wrong offset!");

// Class BFGCore.BFGActorComponent_CharacterPhysics
// 0x0138 (0x0260 - 0x0128)
class UBFGActorComponent_CharacterPhysics final : public UActorComponent
{
public:
	float                                         M_fSimulationTimeout;                              // 0x0128(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         M_fVelocityTolerance;                              // 0x012C(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   M_strMeshSimulationRootBone;                       // 0x0130(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         M_fStandUpTime;                                    // 0x0138(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          M_bCanStandUp;                                     // 0x013C(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_13D[0x3];                                      // 0x013D(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         M_fWaitForStandupAfterHittingGroundTime;           // 0x0140(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   M_oRagdollFaceupCheckBone;                         // 0x0144(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   M_oChestBoneName;                                  // 0x014C(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_154[0x40];                                     // 0x0154(0x0040)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         M_fSimulationRestTime;                             // 0x0194(0x0004)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          M_bAllowAutoTurnOff;                               // 0x0198(0x0001)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_199[0x3];                                      // 0x0199(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	TWeakObjectPtr<class UPrimitiveComponent>     M_pSimulatingComponent;                            // 0x019C(0x0008)(ExportObject, ZeroConstructor, Transient, InstancedReference, IsPlainOldData, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_1A4[0x4];                                      // 0x01A4(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<struct FVector>                        M_aBoneTransformCache;                             // 0x01A8(0x0010)(ZeroConstructor, Protected, NativeAccessSpecifierProtected)
	uint8                                         Pad_1B8[0xA8];                                     // 0x01B8(0x00A8)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	bool AddImpulse(const struct FVector& _vVector, class FName _strBoneName, bool _bVelChange);
	bool AddImpulseDefault(const struct FVector& _vVector);
	void DropAccessories();
	void FreezeCharacterAndDisableComponent();
	void SetPhysicsSimulationState(bool _bEnabled, bool _bResetToNonPhysicsActorWhenDone);

	struct FVector GetEstimatedCapsuleVelocity() const;
	class UPrimitiveComponent* GetSimulatingComponent() const;
	bool IsSimulatingPhysics() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"BFGActorComponent_CharacterPhysics">();
	}
	static class UBFGActorComponent_CharacterPhysics* GetDefaultObj()
	{
		return GetDefaultObjImpl<UBFGActorComponent_CharacterPhysics>();
	}
};
static_assert(alignof(UBFGActorComponent_CharacterPhysics) == 0x000008, "Wrong alignment on UBFGActorComponent_CharacterPhysics");
static_assert(sizeof(UBFGActorComponent_CharacterPhysics) == 0x000260, "Wrong size on UBFGActorComponent_CharacterPhysics");
static_assert(offsetof(UBFGActorComponent_CharacterPhysics, M_fSimulationTimeout) == 0x000128, "Member 'UBFGActorComponent_CharacterPhysics::M_fSimulationTimeout' has a wrong offset!");
static_assert(offsetof(UBFGActorComponent_CharacterPhysics, M_fVelocityTolerance) == 0x00012C, "Member 'UBFGActorComponent_CharacterPhysics::M_fVelocityTolerance' has a wrong offset!");
static_assert(offsetof(UBFGActorComponent_CharacterPhysics, M_strMeshSimulationRootBone) == 0x000130, "Member 'UBFGActorComponent_CharacterPhysics::M_strMeshSimulationRootBone' has a wrong offset!");
static_assert(offsetof(UBFGActorComponent_CharacterPhysics, M_fStandUpTime) == 0x000138, "Member 'UBFGActorComponent_CharacterPhysics::M_fStandUpTime' has a wrong offset!");
static_assert(offsetof(UBFGActorComponent_CharacterPhysics, M_bCanStandUp) == 0x00013C, "Member 'UBFGActorComponent_CharacterPhysics::M_bCanStandUp' has a wrong offset!");
static_assert(offsetof(UBFGActorComponent_CharacterPhysics, M_fWaitForStandupAfterHittingGroundTime) == 0x000140, "Member 'UBFGActorComponent_CharacterPhysics::M_fWaitForStandupAfterHittingGroundTime' has a wrong offset!");
static_assert(offsetof(UBFGActorComponent_CharacterPhysics, M_oRagdollFaceupCheckBone) == 0x000144, "Member 'UBFGActorComponent_CharacterPhysics::M_oRagdollFaceupCheckBone' has a wrong offset!");
static_assert(offsetof(UBFGActorComponent_CharacterPhysics, M_oChestBoneName) == 0x00014C, "Member 'UBFGActorComponent_CharacterPhysics::M_oChestBoneName' has a wrong offset!");
static_assert(offsetof(UBFGActorComponent_CharacterPhysics, M_fSimulationRestTime) == 0x000194, "Member 'UBFGActorComponent_CharacterPhysics::M_fSimulationRestTime' has a wrong offset!");
static_assert(offsetof(UBFGActorComponent_CharacterPhysics, M_bAllowAutoTurnOff) == 0x000198, "Member 'UBFGActorComponent_CharacterPhysics::M_bAllowAutoTurnOff' has a wrong offset!");
static_assert(offsetof(UBFGActorComponent_CharacterPhysics, M_pSimulatingComponent) == 0x00019C, "Member 'UBFGActorComponent_CharacterPhysics::M_pSimulatingComponent' has a wrong offset!");
static_assert(offsetof(UBFGActorComponent_CharacterPhysics, M_aBoneTransformCache) == 0x0001A8, "Member 'UBFGActorComponent_CharacterPhysics::M_aBoneTransformCache' has a wrong offset!");

// Class BFGCore.BFGTaskNode_FinishExitCar
// 0x0000 (0x0078 - 0x0078)
class UBFGTaskNode_FinishExitCar final : public UBFGBTBaseTaskNode
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"BFGTaskNode_FinishExitCar">();
	}
	static class UBFGTaskNode_FinishExitCar* GetDefaultObj()
	{
		return GetDefaultObjImpl<UBFGTaskNode_FinishExitCar>();
	}
};
static_assert(alignof(UBFGTaskNode_FinishExitCar) == 0x000008, "Wrong alignment on UBFGTaskNode_FinishExitCar");
static_assert(sizeof(UBFGTaskNode_FinishExitCar) == 0x000078, "Wrong size on UBFGTaskNode_FinishExitCar");

// Class BFGCore.BFGEventAction_StopSequence
// 0x0028 (0x0058 - 0x0030)
class UBFGEventAction_StopSequence final : public UBFGEventAction
{
public:
	class UBFGNarrativeSequence*                  M_pNarrativeSequence;                              // 0x0030(0x0008)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_38[0x18];                                      // 0x0038(0x0018)(Fixing Size After Last Property [ Dumper-7 ])
	class UBFGSequenceRequest*                    M_pSequenceRequest;                                // 0x0050(0x0008)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"BFGEventAction_StopSequence">();
	}
	static class UBFGEventAction_StopSequence* GetDefaultObj()
	{
		return GetDefaultObjImpl<UBFGEventAction_StopSequence>();
	}
};
static_assert(alignof(UBFGEventAction_StopSequence) == 0x000008, "Wrong alignment on UBFGEventAction_StopSequence");
static_assert(sizeof(UBFGEventAction_StopSequence) == 0x000058, "Wrong size on UBFGEventAction_StopSequence");
static_assert(offsetof(UBFGEventAction_StopSequence, M_pNarrativeSequence) == 0x000030, "Member 'UBFGEventAction_StopSequence::M_pNarrativeSequence' has a wrong offset!");
static_assert(offsetof(UBFGEventAction_StopSequence, M_pSequenceRequest) == 0x000050, "Member 'UBFGEventAction_StopSequence::M_pSequenceRequest' has a wrong offset!");

// Class BFGCore.BFGActorComponent_StatsBase
// 0x0020 (0x0148 - 0x0128)
class UBFGActorComponent_StatsBase : public UActorComponent
{
public:
	uint8                                         Pad_128[0x8];                                      // 0x0128(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<class UBFGActorStat*>                  M_aStatsCache;                                     // 0x0130(0x0010)(ExportObject, ZeroConstructor, Transient, ContainsInstancedReference, Protected, NativeAccessSpecifierProtected)
	uint8                                         Pad_140[0x8];                                      // 0x0140(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	class FString ToString() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"BFGActorComponent_StatsBase">();
	}
	static class UBFGActorComponent_StatsBase* GetDefaultObj()
	{
		return GetDefaultObjImpl<UBFGActorComponent_StatsBase>();
	}
};
static_assert(alignof(UBFGActorComponent_StatsBase) == 0x000008, "Wrong alignment on UBFGActorComponent_StatsBase");
static_assert(sizeof(UBFGActorComponent_StatsBase) == 0x000148, "Wrong size on UBFGActorComponent_StatsBase");
static_assert(offsetof(UBFGActorComponent_StatsBase, M_aStatsCache) == 0x000130, "Member 'UBFGActorComponent_StatsBase::M_aStatsCache' has a wrong offset!");

// Class BFGCore.BFGActorComponent_PawnStats
// 0x0038 (0x0180 - 0x0148)
class UBFGActorComponent_PawnStats : public UBFGActorComponent_StatsBase
{
public:
	class UBFGActorStat_Float*                    M_pHealthStat;                                     // 0x0148(0x0008)(Edit, ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UBFGActorStat_Float*                    M_pShieldStat;                                     // 0x0150(0x0008)(Edit, ExportObject, ZeroConstructor, DisableEditOnInstance, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UBFGActorStat_Bool*                     M_pIsDeadStat;                                     // 0x0158(0x0008)(Edit, ExportObject, ZeroConstructor, DisableEditOnInstance, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UBFGActorStat_Bool*                     M_pIsInvisibleStat;                                // 0x0160(0x0008)(Edit, ExportObject, ZeroConstructor, DisableEditOnInstance, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UBFGActorStat_Bool*                     M_pIsInWaterStat;                                  // 0x0168(0x0008)(Edit, ExportObject, ZeroConstructor, DisableEditOnInstance, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class ABFGGameState*                          M_pGameState;                                      // 0x0170(0x0008)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UBFGActorStat_EnumBehaviourState_NPC*   M_pCurrentAIAlertStateStat;                        // 0x0178(0x0008)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)

public:
	void OnAIAlertStateStatChanged(class AActor* _pOwner, class UBFGActorStat_uint8* _pStat);
	void OnHealthChanged(class AActor* _pOwner, class UBFGActorStat_Float* _pStat);
	void OnShieldChanged(class AActor* _pOwner, class UBFGActorStat_Float* _pStat);

	class UBFGActorStat_EnumBehaviourState_NPC* GetCurrentAIAlertState() const;
	class UBFGActorStat_Float* GetHealthStat() const;
	class UBFGActorStat_Bool* GetIsDeadStat() const;
	class UBFGActorStat_Bool* GetIsInvisibleStat() const;
	class UBFGActorStat_Bool* GetIsInWaterStat() const;
	class UBFGActorStat_Float* GetShieldStat() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"BFGActorComponent_PawnStats">();
	}
	static class UBFGActorComponent_PawnStats* GetDefaultObj()
	{
		return GetDefaultObjImpl<UBFGActorComponent_PawnStats>();
	}
};
static_assert(alignof(UBFGActorComponent_PawnStats) == 0x000008, "Wrong alignment on UBFGActorComponent_PawnStats");
static_assert(sizeof(UBFGActorComponent_PawnStats) == 0x000180, "Wrong size on UBFGActorComponent_PawnStats");
static_assert(offsetof(UBFGActorComponent_PawnStats, M_pHealthStat) == 0x000148, "Member 'UBFGActorComponent_PawnStats::M_pHealthStat' has a wrong offset!");
static_assert(offsetof(UBFGActorComponent_PawnStats, M_pShieldStat) == 0x000150, "Member 'UBFGActorComponent_PawnStats::M_pShieldStat' has a wrong offset!");
static_assert(offsetof(UBFGActorComponent_PawnStats, M_pIsDeadStat) == 0x000158, "Member 'UBFGActorComponent_PawnStats::M_pIsDeadStat' has a wrong offset!");
static_assert(offsetof(UBFGActorComponent_PawnStats, M_pIsInvisibleStat) == 0x000160, "Member 'UBFGActorComponent_PawnStats::M_pIsInvisibleStat' has a wrong offset!");
static_assert(offsetof(UBFGActorComponent_PawnStats, M_pIsInWaterStat) == 0x000168, "Member 'UBFGActorComponent_PawnStats::M_pIsInWaterStat' has a wrong offset!");
static_assert(offsetof(UBFGActorComponent_PawnStats, M_pGameState) == 0x000170, "Member 'UBFGActorComponent_PawnStats::M_pGameState' has a wrong offset!");
static_assert(offsetof(UBFGActorComponent_PawnStats, M_pCurrentAIAlertStateStat) == 0x000178, "Member 'UBFGActorComponent_PawnStats::M_pCurrentAIAlertStateStat' has a wrong offset!");

// Class BFGCore.BFGEventAction_ShowTextOnHUD
// 0x0020 (0x0050 - 0x0030)
class UBFGEventAction_ShowTextOnHUD final : public UBFGEventAction
{
public:
	uint8                                         Pad_30[0x20];                                      // 0x0030(0x0020)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"BFGEventAction_ShowTextOnHUD">();
	}
	static class UBFGEventAction_ShowTextOnHUD* GetDefaultObj()
	{
		return GetDefaultObjImpl<UBFGEventAction_ShowTextOnHUD>();
	}
};
static_assert(alignof(UBFGEventAction_ShowTextOnHUD) == 0x000008, "Wrong alignment on UBFGEventAction_ShowTextOnHUD");
static_assert(sizeof(UBFGEventAction_ShowTextOnHUD) == 0x000050, "Wrong size on UBFGEventAction_ShowTextOnHUD");

// Class BFGCore.BFGActorComponent_CharacterStats
// 0x0008 (0x0188 - 0x0180)
class UBFGActorComponent_CharacterStats : public UBFGActorComponent_PawnStats
{
public:
	class UBFGActorStat_Float*                    M_pWillpowerStat;                                  // 0x0180(0x0008)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)

public:
	class UBFGActorStat_Float* GetWillpowerStat() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"BFGActorComponent_CharacterStats">();
	}
	static class UBFGActorComponent_CharacterStats* GetDefaultObj()
	{
		return GetDefaultObjImpl<UBFGActorComponent_CharacterStats>();
	}
};
static_assert(alignof(UBFGActorComponent_CharacterStats) == 0x000008, "Wrong alignment on UBFGActorComponent_CharacterStats");
static_assert(sizeof(UBFGActorComponent_CharacterStats) == 0x000188, "Wrong size on UBFGActorComponent_CharacterStats");
static_assert(offsetof(UBFGActorComponent_CharacterStats, M_pWillpowerStat) == 0x000180, "Member 'UBFGActorComponent_CharacterStats::M_pWillpowerStat' has a wrong offset!");

// Class BFGCore.BFGQuest_UIUpdateRequest
// 0x0038 (0x0060 - 0x0028)
class UBFGQuest_UIUpdateRequest final : public UObject
{
public:
	uint8                                         Pad_28[0x28];                                      // 0x0028(0x0028)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<struct FBFGQuest_UIData_Description>   M_aDescriptions;                                   // 0x0050(0x0010)(ZeroConstructor, Transient, Protected, NativeAccessSpecifierProtected)

public:
	const TArray<struct FBFGQuest_UIData_Description> GetDescriptions() const;
	const class FName GetIdentifier() const;
	const class FText GetTitle() const;
	bool IsEmptyOrWhitespace() const;
	bool IsMainQuest() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"BFGQuest_UIUpdateRequest">();
	}
	static class UBFGQuest_UIUpdateRequest* GetDefaultObj()
	{
		return GetDefaultObjImpl<UBFGQuest_UIUpdateRequest>();
	}
};
static_assert(alignof(UBFGQuest_UIUpdateRequest) == 0x000008, "Wrong alignment on UBFGQuest_UIUpdateRequest");
static_assert(sizeof(UBFGQuest_UIUpdateRequest) == 0x000060, "Wrong size on UBFGQuest_UIUpdateRequest");
static_assert(offsetof(UBFGQuest_UIUpdateRequest, M_aDescriptions) == 0x000050, "Member 'UBFGQuest_UIUpdateRequest::M_aDescriptions' has a wrong offset!");

// Class BFGCore.BFGPlayerController
// 0x0148 (0x0878 - 0x0730)
class ABFGPlayerController : public APlayerController
{
public:
	uint8                                         Pad_730[0x8];                                      // 0x0730(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	TSubclassOf<class UBFGCheatManager>           M_CheatClass;                                      // 0x0738(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UBFGActorComponent_CheatHelper*         M_pCheatHelperComponent;                           // 0x0740(0x0008)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, EditConst, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	UMulticastDelegateProperty_                   M_OnSwitchedToGroundMode;                          // 0x0748(0x0018)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	UMulticastDelegateProperty_                   M_OnSwitchedToUFOMode;                             // 0x0760(0x0018)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	float                                         M_fUpdateTimer;                                    // 0x0778(0x0004)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TWeakObjectPtr<class ABFGUFOLandingSite>      M_spClosestLandingSite;                            // 0x077C(0x0008)(Edit, BlueprintVisible, ZeroConstructor, Transient, EditConst, IsPlainOldData, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	EBFGUFO_InteractState                         M_eUFOInteractState;                               // 0x0784(0x0001)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_785[0x3];                                      // 0x0785(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	TWeakObjectPtr<class APawn>                   M_pLastPossessedPawn;                              // 0x0788(0x0008)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TWeakObjectPtr<class ABFGPlayerUFO>           M_pLastPossessedUFO;                               // 0x0790(0x0008)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TWeakObjectPtr<class ABFGPlayerCharacter>     M_pLastPossessedCharacter;                         // 0x0798(0x0008)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UBFGCheatManager*                       M_pCheatManager;                                   // 0x07A0(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_7A8[0x14];                                     // 0x07A8(0x0014)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         M_fMaxHorizontalSpeed;                             // 0x07BC(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         M_fMaxVerticalSpeed;                               // 0x07C0(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_7C4[0x4];                                      // 0x07C4(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class UCurveFloat*                            M_pInputSpeedModifierCurve;                        // 0x07C8(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         M_fMagnetismStrength;                              // 0x07D0(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         M_fCenteringStrength;                              // 0x07D4(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UCurveFloat*                            M_pTargetTimeAimAssistCurve;                       // 0x07D8(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_7E0[0x8];                                      // 0x07E0(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         M_fHighInputThreshold;                             // 0x07E8(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_7EC[0x30];                                     // 0x07EC(0x0030)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         M_fUFOEnteringDuration;                            // 0x081C(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_820[0x4];                                      // 0x0820(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         M_fUFOLeavingDuration;                             // 0x0824(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_828[0x4];                                      // 0x0828(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         M_fUFOCallHeight;                                  // 0x082C(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	struct FBFGPlayerCharacterMovementSettings    M_oPlayerMovementSettingsWhileInUFO;               // 0x0830(0x001C)(Edit, NoDestructor, Protected, NativeAccessSpecifierProtected)
	uint8                                         Pad_84C[0x1C];                                     // 0x084C(0x001C)(Fixing Size After Last Property [ Dumper-7 ])
	class UBFGActorComponent_GameplayToHud*       M_pGameplayToHud;                                  // 0x0868(0x0008)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, EditConst, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_870[0x8];                                      // 0x0870(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void ABFGVoiceoverPlaybackActor_OnItemPlaybackStopped_Server(class ABFGVoiceoverPlaybackActor* _pCallback);
	class UBFGCheatManager* GetCheatManager();
	bool SwitchToGroundMode();
	bool SwitchToUFOMode();
	void Test_SwitchToGroundMode();
	void Test_SwitchToUFOMode();

	struct FKey GetLastPressedKey() const;
	class UBFGPlayerCharacter_Settings* GetSettings() const;
	bool IsAnyKeyPressed() const;
	bool IsGameplayController() const;
	bool IsGroundMode() const;
	bool IsUsingGamepad() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"BFGPlayerController">();
	}
	static class ABFGPlayerController* GetDefaultObj()
	{
		return GetDefaultObjImpl<ABFGPlayerController>();
	}
};
static_assert(alignof(ABFGPlayerController) == 0x000008, "Wrong alignment on ABFGPlayerController");
static_assert(sizeof(ABFGPlayerController) == 0x000878, "Wrong size on ABFGPlayerController");
static_assert(offsetof(ABFGPlayerController, M_CheatClass) == 0x000738, "Member 'ABFGPlayerController::M_CheatClass' has a wrong offset!");
static_assert(offsetof(ABFGPlayerController, M_pCheatHelperComponent) == 0x000740, "Member 'ABFGPlayerController::M_pCheatHelperComponent' has a wrong offset!");
static_assert(offsetof(ABFGPlayerController, M_OnSwitchedToGroundMode) == 0x000748, "Member 'ABFGPlayerController::M_OnSwitchedToGroundMode' has a wrong offset!");
static_assert(offsetof(ABFGPlayerController, M_OnSwitchedToUFOMode) == 0x000760, "Member 'ABFGPlayerController::M_OnSwitchedToUFOMode' has a wrong offset!");
static_assert(offsetof(ABFGPlayerController, M_fUpdateTimer) == 0x000778, "Member 'ABFGPlayerController::M_fUpdateTimer' has a wrong offset!");
static_assert(offsetof(ABFGPlayerController, M_spClosestLandingSite) == 0x00077C, "Member 'ABFGPlayerController::M_spClosestLandingSite' has a wrong offset!");
static_assert(offsetof(ABFGPlayerController, M_eUFOInteractState) == 0x000784, "Member 'ABFGPlayerController::M_eUFOInteractState' has a wrong offset!");
static_assert(offsetof(ABFGPlayerController, M_pLastPossessedPawn) == 0x000788, "Member 'ABFGPlayerController::M_pLastPossessedPawn' has a wrong offset!");
static_assert(offsetof(ABFGPlayerController, M_pLastPossessedUFO) == 0x000790, "Member 'ABFGPlayerController::M_pLastPossessedUFO' has a wrong offset!");
static_assert(offsetof(ABFGPlayerController, M_pLastPossessedCharacter) == 0x000798, "Member 'ABFGPlayerController::M_pLastPossessedCharacter' has a wrong offset!");
static_assert(offsetof(ABFGPlayerController, M_pCheatManager) == 0x0007A0, "Member 'ABFGPlayerController::M_pCheatManager' has a wrong offset!");
static_assert(offsetof(ABFGPlayerController, M_fMaxHorizontalSpeed) == 0x0007BC, "Member 'ABFGPlayerController::M_fMaxHorizontalSpeed' has a wrong offset!");
static_assert(offsetof(ABFGPlayerController, M_fMaxVerticalSpeed) == 0x0007C0, "Member 'ABFGPlayerController::M_fMaxVerticalSpeed' has a wrong offset!");
static_assert(offsetof(ABFGPlayerController, M_pInputSpeedModifierCurve) == 0x0007C8, "Member 'ABFGPlayerController::M_pInputSpeedModifierCurve' has a wrong offset!");
static_assert(offsetof(ABFGPlayerController, M_fMagnetismStrength) == 0x0007D0, "Member 'ABFGPlayerController::M_fMagnetismStrength' has a wrong offset!");
static_assert(offsetof(ABFGPlayerController, M_fCenteringStrength) == 0x0007D4, "Member 'ABFGPlayerController::M_fCenteringStrength' has a wrong offset!");
static_assert(offsetof(ABFGPlayerController, M_pTargetTimeAimAssistCurve) == 0x0007D8, "Member 'ABFGPlayerController::M_pTargetTimeAimAssistCurve' has a wrong offset!");
static_assert(offsetof(ABFGPlayerController, M_fHighInputThreshold) == 0x0007E8, "Member 'ABFGPlayerController::M_fHighInputThreshold' has a wrong offset!");
static_assert(offsetof(ABFGPlayerController, M_fUFOEnteringDuration) == 0x00081C, "Member 'ABFGPlayerController::M_fUFOEnteringDuration' has a wrong offset!");
static_assert(offsetof(ABFGPlayerController, M_fUFOLeavingDuration) == 0x000824, "Member 'ABFGPlayerController::M_fUFOLeavingDuration' has a wrong offset!");
static_assert(offsetof(ABFGPlayerController, M_fUFOCallHeight) == 0x00082C, "Member 'ABFGPlayerController::M_fUFOCallHeight' has a wrong offset!");
static_assert(offsetof(ABFGPlayerController, M_oPlayerMovementSettingsWhileInUFO) == 0x000830, "Member 'ABFGPlayerController::M_oPlayerMovementSettingsWhileInUFO' has a wrong offset!");
static_assert(offsetof(ABFGPlayerController, M_pGameplayToHud) == 0x000868, "Member 'ABFGPlayerController::M_pGameplayToHud' has a wrong offset!");

// Class BFGCore.BFGUI_RadialMenu_Option
// 0x01B8 (0x03F8 - 0x0240)
class UBFGUI_RadialMenu_Option : public UUserWidget
{
public:
	UMulticastDelegateProperty_                   M_action;                                          // 0x0240(0x0018)(ZeroConstructor, Transient, InstancedReference, NativeAccessSpecifierPublic)
	class FText                                   OptionText;                                        // 0x0258(0x0018)(Edit, BlueprintVisible, EditConst, NativeAccessSpecifierPublic)
	class FText                                   OptionToolTip;                                     // 0x0270(0x0018)(Edit, BlueprintVisible, EditConst, NativeAccessSpecifierPublic)
	class FText                                   DescriptionText;                                   // 0x0288(0x0018)(Edit, BlueprintVisible, EditConst, NativeAccessSpecifierPublic)
	class UBFGRadialMenuUserWidget*               M_pMenuWidget;                                     // 0x02A0(0x0008)(ExportObject, ZeroConstructor, Transient, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          M_bIsHighlighted;                                  // 0x02A8(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_2A9[0x7];                                      // 0x02A9(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	class UTexture2D*                             M_pIcon;                                           // 0x02B0(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UTexture2D*                             M_pIconHighlighted;                                // 0x02B8(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UBFGWidget_RadialMenu_OptionIcon*       M_pOptionIconWidget;                               // 0x02C0(0x0008)(ExportObject, ZeroConstructor, Transient, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          M_bWidgetsAdded;                                   // 0x02C8(0x0001)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_2C9[0x7];                                      // 0x02C9(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	struct FSlateBrush                            M_defaultBrush;                                    // 0x02D0(0x0088)(Transient, Protected, NativeAccessSpecifierProtected)
	struct FSlateBrush                            M_highlightedBrush;                                // 0x0358(0x0088)(Transient, Protected, NativeAccessSpecifierProtected)
	class UImage*                                 M_pImageIcon;                                      // 0x03E0(0x0008)(BlueprintVisible, ExportObject, ZeroConstructor, Transient, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UVerticalBox*                           M_pOptionWidgetPanel;                              // 0x03E8(0x0008)(BlueprintVisible, ExportObject, ZeroConstructor, Transient, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UObject*                                M_pTagObject;                                      // 0x03F0(0x0008)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)

public:
	void Action__DelegateSignature(class UBFGUI_RadialMenu_Option* _pOption);
	class UBFGRadialMenuUserWidget* GetMenuWidget();
	void Highlight(bool _bEnabled);
	void InitializeOption(const class FText& _strText, const class FText& _strTooltip, const class FText& _strDescription, class UObject* _pObject);
	void InvokeAction();
	void SetIconTextures(class UTexture2D* _pDefault, class UTexture2D* _pHighlighted);
	void SetOptionWidgets(class UBFGWidget_RadialMenu_OptionIcon* _pWidget);

	class UBFGWidget_RadialMenu_OptionIcon* GetOptionWidget() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"BFGUI_RadialMenu_Option">();
	}
	static class UBFGUI_RadialMenu_Option* GetDefaultObj()
	{
		return GetDefaultObjImpl<UBFGUI_RadialMenu_Option>();
	}
};
static_assert(alignof(UBFGUI_RadialMenu_Option) == 0x000008, "Wrong alignment on UBFGUI_RadialMenu_Option");
static_assert(sizeof(UBFGUI_RadialMenu_Option) == 0x0003F8, "Wrong size on UBFGUI_RadialMenu_Option");
static_assert(offsetof(UBFGUI_RadialMenu_Option, M_action) == 0x000240, "Member 'UBFGUI_RadialMenu_Option::M_action' has a wrong offset!");
static_assert(offsetof(UBFGUI_RadialMenu_Option, OptionText) == 0x000258, "Member 'UBFGUI_RadialMenu_Option::OptionText' has a wrong offset!");
static_assert(offsetof(UBFGUI_RadialMenu_Option, OptionToolTip) == 0x000270, "Member 'UBFGUI_RadialMenu_Option::OptionToolTip' has a wrong offset!");
static_assert(offsetof(UBFGUI_RadialMenu_Option, DescriptionText) == 0x000288, "Member 'UBFGUI_RadialMenu_Option::DescriptionText' has a wrong offset!");
static_assert(offsetof(UBFGUI_RadialMenu_Option, M_pMenuWidget) == 0x0002A0, "Member 'UBFGUI_RadialMenu_Option::M_pMenuWidget' has a wrong offset!");
static_assert(offsetof(UBFGUI_RadialMenu_Option, M_bIsHighlighted) == 0x0002A8, "Member 'UBFGUI_RadialMenu_Option::M_bIsHighlighted' has a wrong offset!");
static_assert(offsetof(UBFGUI_RadialMenu_Option, M_pIcon) == 0x0002B0, "Member 'UBFGUI_RadialMenu_Option::M_pIcon' has a wrong offset!");
static_assert(offsetof(UBFGUI_RadialMenu_Option, M_pIconHighlighted) == 0x0002B8, "Member 'UBFGUI_RadialMenu_Option::M_pIconHighlighted' has a wrong offset!");
static_assert(offsetof(UBFGUI_RadialMenu_Option, M_pOptionIconWidget) == 0x0002C0, "Member 'UBFGUI_RadialMenu_Option::M_pOptionIconWidget' has a wrong offset!");
static_assert(offsetof(UBFGUI_RadialMenu_Option, M_bWidgetsAdded) == 0x0002C8, "Member 'UBFGUI_RadialMenu_Option::M_bWidgetsAdded' has a wrong offset!");
static_assert(offsetof(UBFGUI_RadialMenu_Option, M_defaultBrush) == 0x0002D0, "Member 'UBFGUI_RadialMenu_Option::M_defaultBrush' has a wrong offset!");
static_assert(offsetof(UBFGUI_RadialMenu_Option, M_highlightedBrush) == 0x000358, "Member 'UBFGUI_RadialMenu_Option::M_highlightedBrush' has a wrong offset!");
static_assert(offsetof(UBFGUI_RadialMenu_Option, M_pImageIcon) == 0x0003E0, "Member 'UBFGUI_RadialMenu_Option::M_pImageIcon' has a wrong offset!");
static_assert(offsetof(UBFGUI_RadialMenu_Option, M_pOptionWidgetPanel) == 0x0003E8, "Member 'UBFGUI_RadialMenu_Option::M_pOptionWidgetPanel' has a wrong offset!");
static_assert(offsetof(UBFGUI_RadialMenu_Option, M_pTagObject) == 0x0003F0, "Member 'UBFGUI_RadialMenu_Option::M_pTagObject' has a wrong offset!");

// Class BFGCore.BFGEventTest_CutsceneCanPlay
// 0x0028 (0x0050 - 0x0028)
class UBFGEventTest_CutsceneCanPlay final : public UBFGEventTest
{
public:
	uint8                                         Pad_28[0x18];                                      // 0x0028(0x0018)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<struct FBFGSequence_DynamicActorBinding> M_aBinding;                                        // 0x0040(0x0010)(ZeroConstructor, Transient, Protected, NativeAccessSpecifierProtected)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"BFGEventTest_CutsceneCanPlay">();
	}
	static class UBFGEventTest_CutsceneCanPlay* GetDefaultObj()
	{
		return GetDefaultObjImpl<UBFGEventTest_CutsceneCanPlay>();
	}
};
static_assert(alignof(UBFGEventTest_CutsceneCanPlay) == 0x000008, "Wrong alignment on UBFGEventTest_CutsceneCanPlay");
static_assert(sizeof(UBFGEventTest_CutsceneCanPlay) == 0x000050, "Wrong size on UBFGEventTest_CutsceneCanPlay");
static_assert(offsetof(UBFGEventTest_CutsceneCanPlay, M_aBinding) == 0x000040, "Member 'UBFGEventTest_CutsceneCanPlay::M_aBinding' has a wrong offset!");

// Class BFGCore.BFGNetworkPathAgent_AIStateReleasePassengers
// 0x0020 (0x0078 - 0x0058)
class UBFGNetworkPathAgent_AIStateReleasePassengers final : public UBFGNetworkPathAgent_AIStateBase
{
public:
	bool                                          M_bPanicMode;                                      // 0x0058(0x0001)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_59[0x3];                                       // 0x0059(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	struct FBFGVehicleStop_Param                  M_stopMode;                                        // 0x005C(0x000C)(Transient, NoDestructor, Protected, NativeAccessSpecifierProtected)
	EBFGAIVehicleReleasePassengersPhase           M_ePhase;                                          // 0x0068(0x0001)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_69[0x7];                                       // 0x0069(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	class ANavModifierVolume*                     M_pVolume;                                         // 0x0070(0x0008)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"BFGNetworkPathAgent_AIStateReleasePassengers">();
	}
	static class UBFGNetworkPathAgent_AIStateReleasePassengers* GetDefaultObj()
	{
		return GetDefaultObjImpl<UBFGNetworkPathAgent_AIStateReleasePassengers>();
	}
};
static_assert(alignof(UBFGNetworkPathAgent_AIStateReleasePassengers) == 0x000008, "Wrong alignment on UBFGNetworkPathAgent_AIStateReleasePassengers");
static_assert(sizeof(UBFGNetworkPathAgent_AIStateReleasePassengers) == 0x000078, "Wrong size on UBFGNetworkPathAgent_AIStateReleasePassengers");
static_assert(offsetof(UBFGNetworkPathAgent_AIStateReleasePassengers, M_bPanicMode) == 0x000058, "Member 'UBFGNetworkPathAgent_AIStateReleasePassengers::M_bPanicMode' has a wrong offset!");
static_assert(offsetof(UBFGNetworkPathAgent_AIStateReleasePassengers, M_stopMode) == 0x00005C, "Member 'UBFGNetworkPathAgent_AIStateReleasePassengers::M_stopMode' has a wrong offset!");
static_assert(offsetof(UBFGNetworkPathAgent_AIStateReleasePassengers, M_ePhase) == 0x000068, "Member 'UBFGNetworkPathAgent_AIStateReleasePassengers::M_ePhase' has a wrong offset!");
static_assert(offsetof(UBFGNetworkPathAgent_AIStateReleasePassengers, M_pVolume) == 0x000070, "Member 'UBFGNetworkPathAgent_AIStateReleasePassengers::M_pVolume' has a wrong offset!");

// Class BFGCore.BFGActorComponent_CheatHelper
// 0x0030 (0x0158 - 0x0128)
class UBFGActorComponent_CheatHelper final : public UActorComponent
{
public:
	float                                         M_bFreeCamSpeedMultiplier;                         // 0x0128(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         M_bFreeCamHighSpeedMultiplier;                     // 0x012C(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UDataTable*                             M_pCheatDataTable;                                 // 0x0130(0x0008)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class ABFGFreeCamPawn*                        M_pFreeCamPawn;                                    // 0x0138(0x0008)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UUserWidget*                            M_pCheatMenuWidget;                                // 0x0140(0x0008)(ExportObject, ZeroConstructor, Transient, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UUserWidget*                            M_pFreeCamWidget;                                  // 0x0148(0x0008)(ExportObject, ZeroConstructor, Transient, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UUserWidget*                            M_PTEST;                                           // 0x0150(0x0008)(ExportObject, ZeroConstructor, Transient, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)

public:
	void CheckCheatCommandInput(struct FBFGCheatTableEntry* _pEntry);
	void HideUI();
	void KillPlayer();
	void NukeAll();
	void NukeBuilding();
	void NukeEnemies();
	void ShowUI();
	void ToggleFlyMode();
	void ToggleInfiniteConcentration();
	void ToggleInfiniteHover();
	void ToggleUFO();
	void ToggleUI();
	bool UIISShown();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"BFGActorComponent_CheatHelper">();
	}
	static class UBFGActorComponent_CheatHelper* GetDefaultObj()
	{
		return GetDefaultObjImpl<UBFGActorComponent_CheatHelper>();
	}
};
static_assert(alignof(UBFGActorComponent_CheatHelper) == 0x000008, "Wrong alignment on UBFGActorComponent_CheatHelper");
static_assert(sizeof(UBFGActorComponent_CheatHelper) == 0x000158, "Wrong size on UBFGActorComponent_CheatHelper");
static_assert(offsetof(UBFGActorComponent_CheatHelper, M_bFreeCamSpeedMultiplier) == 0x000128, "Member 'UBFGActorComponent_CheatHelper::M_bFreeCamSpeedMultiplier' has a wrong offset!");
static_assert(offsetof(UBFGActorComponent_CheatHelper, M_bFreeCamHighSpeedMultiplier) == 0x00012C, "Member 'UBFGActorComponent_CheatHelper::M_bFreeCamHighSpeedMultiplier' has a wrong offset!");
static_assert(offsetof(UBFGActorComponent_CheatHelper, M_pCheatDataTable) == 0x000130, "Member 'UBFGActorComponent_CheatHelper::M_pCheatDataTable' has a wrong offset!");
static_assert(offsetof(UBFGActorComponent_CheatHelper, M_pFreeCamPawn) == 0x000138, "Member 'UBFGActorComponent_CheatHelper::M_pFreeCamPawn' has a wrong offset!");
static_assert(offsetof(UBFGActorComponent_CheatHelper, M_pCheatMenuWidget) == 0x000140, "Member 'UBFGActorComponent_CheatHelper::M_pCheatMenuWidget' has a wrong offset!");
static_assert(offsetof(UBFGActorComponent_CheatHelper, M_pFreeCamWidget) == 0x000148, "Member 'UBFGActorComponent_CheatHelper::M_pFreeCamWidget' has a wrong offset!");
static_assert(offsetof(UBFGActorComponent_CheatHelper, M_PTEST) == 0x000150, "Member 'UBFGActorComponent_CheatHelper::M_PTEST' has a wrong offset!");

// Class BFGCore.BFGActorComponent_CortexScanResponse
// 0x00F8 (0x0220 - 0x0128)
class UBFGActorComponent_CortexScanResponse final : public UActorComponent
{
public:
	TSoftObjectPtr<class UBFGDataAsset_CortexScan> M_softData;                                        // 0x0128(0x0028)(Edit, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TMap<TSoftClassPtr<class UClass>, TSoftObjectPtr<class UBFGDataAsset_CortexScan>> M_apCortexScanOverrides;                           // 0x0150(0x0050)(Edit, ZeroConstructor, Protected, UObjectWrapper, NativeAccessSpecifierProtected)
	class UBFGCortexScanResponseSet*              M_pDefaultSet;                                     // 0x01A0(0x0008)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TMap<class UBFGCortexScanOverrideRule*, class UBFGCortexScanResponseSet*> M_apCortexScanOverrideInstances;                   // 0x01A8(0x0050)(ZeroConstructor, Transient, Protected, NativeAccessSpecifierProtected)
	struct FGuid                                  M_lastPlayedRepsonseId;                            // 0x01F8(0x0010)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class FText                                   M_strLastPlayedResponseText;                       // 0x0208(0x0018)(Transient, Protected, NativeAccessSpecifierProtected)

public:
	void OnOwnerDead(class AActor* _pActor, class UBFGActorStat_Bool* _pStat);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"BFGActorComponent_CortexScanResponse">();
	}
	static class UBFGActorComponent_CortexScanResponse* GetDefaultObj()
	{
		return GetDefaultObjImpl<UBFGActorComponent_CortexScanResponse>();
	}
};
static_assert(alignof(UBFGActorComponent_CortexScanResponse) == 0x000008, "Wrong alignment on UBFGActorComponent_CortexScanResponse");
static_assert(sizeof(UBFGActorComponent_CortexScanResponse) == 0x000220, "Wrong size on UBFGActorComponent_CortexScanResponse");
static_assert(offsetof(UBFGActorComponent_CortexScanResponse, M_softData) == 0x000128, "Member 'UBFGActorComponent_CortexScanResponse::M_softData' has a wrong offset!");
static_assert(offsetof(UBFGActorComponent_CortexScanResponse, M_apCortexScanOverrides) == 0x000150, "Member 'UBFGActorComponent_CortexScanResponse::M_apCortexScanOverrides' has a wrong offset!");
static_assert(offsetof(UBFGActorComponent_CortexScanResponse, M_pDefaultSet) == 0x0001A0, "Member 'UBFGActorComponent_CortexScanResponse::M_pDefaultSet' has a wrong offset!");
static_assert(offsetof(UBFGActorComponent_CortexScanResponse, M_apCortexScanOverrideInstances) == 0x0001A8, "Member 'UBFGActorComponent_CortexScanResponse::M_apCortexScanOverrideInstances' has a wrong offset!");
static_assert(offsetof(UBFGActorComponent_CortexScanResponse, M_lastPlayedRepsonseId) == 0x0001F8, "Member 'UBFGActorComponent_CortexScanResponse::M_lastPlayedRepsonseId' has a wrong offset!");
static_assert(offsetof(UBFGActorComponent_CortexScanResponse, M_strLastPlayedResponseText) == 0x000208, "Member 'UBFGActorComponent_CortexScanResponse::M_strLastPlayedResponseText' has a wrong offset!");

// Class BFGCore.BFGUserSignInManager
// 0x0090 (0x00B8 - 0x0028)
class UBFGUserSignInManager final : public UObject
{
public:
	UMulticastDelegateProperty_                   M_onActiveUserChangedEvent;                        // 0x0028(0x0018)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	UMulticastDelegateProperty_                   M_onActiveUserSignedOutEvent;                      // 0x0040(0x0018)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	UMulticastDelegateProperty_                   M_onBusyStateChange;                               // 0x0058(0x0018)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	class UBFGGameInstance*                       M_pGameInstance;                                   // 0x0070(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_78[0x40];                                      // 0x0078(0x0040)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void BFGUserSignInManagerEvent__DelegateSignature();
	void BFGUserSignInManagerEvent_Busy__DelegateSignature(bool _bIsBusy);
	bool HandleGameFlowChanges(bool _bIsGameplay);
	void OnControllerDisconnectedButtonPressed(int32 _iStableUserIndex);
	void OnSwitchProfileButtonPressed();
	void OnUserSignedOutButtonPressed(bool _bAcceptSignOut);
	void SetControllerConnected(bool _bDisconnected);
	void SetNeedIIS(bool _bForceIIS);
	void SetUserSignedIn(bool _bLoggedOut);
	bool ShouldShowControllerDisconnectedPopup();
	bool ShouldShowSwitchProfileButton();
	bool ShouldShowUserSignedOutPopup();
	void ShowMessageBox(const class FString& _strParam);

	bool IsBusyWithSignIn() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"BFGUserSignInManager">();
	}
	static class UBFGUserSignInManager* GetDefaultObj()
	{
		return GetDefaultObjImpl<UBFGUserSignInManager>();
	}
};
static_assert(alignof(UBFGUserSignInManager) == 0x000008, "Wrong alignment on UBFGUserSignInManager");
static_assert(sizeof(UBFGUserSignInManager) == 0x0000B8, "Wrong size on UBFGUserSignInManager");
static_assert(offsetof(UBFGUserSignInManager, M_onActiveUserChangedEvent) == 0x000028, "Member 'UBFGUserSignInManager::M_onActiveUserChangedEvent' has a wrong offset!");
static_assert(offsetof(UBFGUserSignInManager, M_onActiveUserSignedOutEvent) == 0x000040, "Member 'UBFGUserSignInManager::M_onActiveUserSignedOutEvent' has a wrong offset!");
static_assert(offsetof(UBFGUserSignInManager, M_onBusyStateChange) == 0x000058, "Member 'UBFGUserSignInManager::M_onBusyStateChange' has a wrong offset!");
static_assert(offsetof(UBFGUserSignInManager, M_pGameInstance) == 0x000070, "Member 'UBFGUserSignInManager::M_pGameInstance' has a wrong offset!");

// Class BFGCore.BFGActorComponent_CrowdAgent
// 0x0008 (0x0130 - 0x0128)
class UBFGActorComponent_CrowdAgent final : public UActorComponent
{
public:
	uint8                                         Pad_128[0x8];                                      // 0x0128(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"BFGActorComponent_CrowdAgent">();
	}
	static class UBFGActorComponent_CrowdAgent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UBFGActorComponent_CrowdAgent>();
	}
};
static_assert(alignof(UBFGActorComponent_CrowdAgent) == 0x000008, "Wrong alignment on UBFGActorComponent_CrowdAgent");
static_assert(sizeof(UBFGActorComponent_CrowdAgent) == 0x000130, "Wrong size on UBFGActorComponent_CrowdAgent");

// Class BFGCore.BFGActorComponent_CrowdAgentVehicle
// 0x0010 (0x0138 - 0x0128)
class UBFGActorComponent_CrowdAgentVehicle final : public UActorComponent
{
public:
	uint8                                         Pad_128[0x8];                                      // 0x0128(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	bool                                          M_bRegistered;                                     // 0x0130(0x0001)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_131[0x7];                                      // 0x0131(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"BFGActorComponent_CrowdAgentVehicle">();
	}
	static class UBFGActorComponent_CrowdAgentVehicle* GetDefaultObj()
	{
		return GetDefaultObjImpl<UBFGActorComponent_CrowdAgentVehicle>();
	}
};
static_assert(alignof(UBFGActorComponent_CrowdAgentVehicle) == 0x000008, "Wrong alignment on UBFGActorComponent_CrowdAgentVehicle");
static_assert(sizeof(UBFGActorComponent_CrowdAgentVehicle) == 0x000138, "Wrong size on UBFGActorComponent_CrowdAgentVehicle");
static_assert(offsetof(UBFGActorComponent_CrowdAgentVehicle, M_bRegistered) == 0x000130, "Member 'UBFGActorComponent_CrowdAgentVehicle::M_bRegistered' has a wrong offset!");

// Class BFGCore.BFGSaveSystem_Action
// 0x0018 (0x0040 - 0x0028)
class UBFGSaveSystem_Action : public UObject
{
public:
	class UBFGGameInstance*                       M_pGameInstance;                                   // 0x0028(0x0008)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UBFGSaveSystem*                         M_pSaveSystem;                                     // 0x0030(0x0008)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          M_bIsFinished;                                     // 0x0038(0x0001)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_39[0x7];                                       // 0x0039(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"BFGSaveSystem_Action">();
	}
	static class UBFGSaveSystem_Action* GetDefaultObj()
	{
		return GetDefaultObjImpl<UBFGSaveSystem_Action>();
	}
};
static_assert(alignof(UBFGSaveSystem_Action) == 0x000008, "Wrong alignment on UBFGSaveSystem_Action");
static_assert(sizeof(UBFGSaveSystem_Action) == 0x000040, "Wrong size on UBFGSaveSystem_Action");
static_assert(offsetof(UBFGSaveSystem_Action, M_pGameInstance) == 0x000028, "Member 'UBFGSaveSystem_Action::M_pGameInstance' has a wrong offset!");
static_assert(offsetof(UBFGSaveSystem_Action, M_pSaveSystem) == 0x000030, "Member 'UBFGSaveSystem_Action::M_pSaveSystem' has a wrong offset!");
static_assert(offsetof(UBFGSaveSystem_Action, M_bIsFinished) == 0x000038, "Member 'UBFGSaveSystem_Action::M_bIsFinished' has a wrong offset!");

// Class BFGCore.BFGSaveSystem_AsyncAction
// 0x0008 (0x0048 - 0x0040)
class UBFGSaveSystem_AsyncAction : public UBFGSaveSystem_Action
{
public:
	uint8                                         Pad_40[0x8];                                       // 0x0040(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"BFGSaveSystem_AsyncAction">();
	}
	static class UBFGSaveSystem_AsyncAction* GetDefaultObj()
	{
		return GetDefaultObjImpl<UBFGSaveSystem_AsyncAction>();
	}
};
static_assert(alignof(UBFGSaveSystem_AsyncAction) == 0x000008, "Wrong alignment on UBFGSaveSystem_AsyncAction");
static_assert(sizeof(UBFGSaveSystem_AsyncAction) == 0x000048, "Wrong size on UBFGSaveSystem_AsyncAction");

// Class BFGCore.BFGSaveSystem_LoadGameAction
// 0x0030 (0x0078 - 0x0048)
class UBFGSaveSystem_LoadGameAction final : public UBFGSaveSystem_AsyncAction
{
public:
	uint8                                         Pad_48[0x20];                                      // 0x0048(0x0020)(Fixing Size After Last Property [ Dumper-7 ])
	class UBFGSaveDataCache*                      M_pSaveCache;                                      // 0x0068(0x0008)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_70[0x8];                                       // 0x0070(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"BFGSaveSystem_LoadGameAction">();
	}
	static class UBFGSaveSystem_LoadGameAction* GetDefaultObj()
	{
		return GetDefaultObjImpl<UBFGSaveSystem_LoadGameAction>();
	}
};
static_assert(alignof(UBFGSaveSystem_LoadGameAction) == 0x000008, "Wrong alignment on UBFGSaveSystem_LoadGameAction");
static_assert(sizeof(UBFGSaveSystem_LoadGameAction) == 0x000078, "Wrong size on UBFGSaveSystem_LoadGameAction");
static_assert(offsetof(UBFGSaveSystem_LoadGameAction, M_pSaveCache) == 0x000068, "Member 'UBFGSaveSystem_LoadGameAction::M_pSaveCache' has a wrong offset!");

// Class BFGCore.BFGEventAction_UnlocksCommit
// 0x0000 (0x0030 - 0x0030)
class UBFGEventAction_UnlocksCommit final : public UBFGEventAction
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"BFGEventAction_UnlocksCommit">();
	}
	static class UBFGEventAction_UnlocksCommit* GetDefaultObj()
	{
		return GetDefaultObjImpl<UBFGEventAction_UnlocksCommit>();
	}
};
static_assert(alignof(UBFGEventAction_UnlocksCommit) == 0x000008, "Wrong alignment on UBFGEventAction_UnlocksCommit");
static_assert(sizeof(UBFGEventAction_UnlocksCommit) == 0x000030, "Wrong size on UBFGEventAction_UnlocksCommit");

// Class BFGCore.BFGActorComponent_DamageListener
// 0x0018 (0x0140 - 0x0128)
class UBFGActorComponent_DamageListener final : public UActorComponent
{
public:
	float                                         M_fTimeFrame;                                      // 0x0128(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         M_fDamageThreshold;                                // 0x012C(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          M_bShowStatus;                                     // 0x0130(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_131[0xF];                                      // 0x0131(0x000F)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"BFGActorComponent_DamageListener">();
	}
	static class UBFGActorComponent_DamageListener* GetDefaultObj()
	{
		return GetDefaultObjImpl<UBFGActorComponent_DamageListener>();
	}
};
static_assert(alignof(UBFGActorComponent_DamageListener) == 0x000008, "Wrong alignment on UBFGActorComponent_DamageListener");
static_assert(sizeof(UBFGActorComponent_DamageListener) == 0x000140, "Wrong size on UBFGActorComponent_DamageListener");
static_assert(offsetof(UBFGActorComponent_DamageListener, M_fTimeFrame) == 0x000128, "Member 'UBFGActorComponent_DamageListener::M_fTimeFrame' has a wrong offset!");
static_assert(offsetof(UBFGActorComponent_DamageListener, M_fDamageThreshold) == 0x00012C, "Member 'UBFGActorComponent_DamageListener::M_fDamageThreshold' has a wrong offset!");
static_assert(offsetof(UBFGActorComponent_DamageListener, M_bShowStatus) == 0x000130, "Member 'UBFGActorComponent_DamageListener::M_bShowStatus' has a wrong offset!");

// Class BFGCore.BFGActorComponent_Dash
// 0x00D8 (0x0200 - 0x0128)
class UBFGActorComponent_Dash final : public UActorComponent
{
public:
	UMulticastDelegateProperty_                   M_onDashTriggered;                                 // 0x0128(0x0018)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	UMulticastDelegateProperty_                   M_onDashPhase;                                     // 0x0140(0x0018)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	UMulticastDelegateProperty_                   M_onDashStopped;                                   // 0x0158(0x0018)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	class ACharacter*                             M_pOwningCharacter;                                // 0x0170(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UBFGActorComponent_PlayerCharacterMovement* M_pPlayerMovementComponent;                        // 0x0178(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UBFGDataAsset_DashParams*               M_pDashParams;                                     // 0x0180(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_188[0x20];                                     // 0x0188(0x0020)(Fixing Size After Last Property [ Dumper-7 ])
	struct FVector                                M_vLastDashDirection;                              // 0x01A8(0x000C)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	struct FGameplayTag                           M_tUpgradeTagThrustATron2000;                      // 0x01B4(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, DisableEditOnInstance, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         M_fThrustATron2000Radius;                          // 0x01BC(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	struct FGameplayTag                           M_tUpgradeTagThrustATron5000;                      // 0x01C0(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, DisableEditOnInstance, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         M_fThrustATron5000Radius;                          // 0x01C8(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         M_fThrustATron2000Impulse;                         // 0x01CC(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         M_fThrustATron2000ProjectileDeflectFriction;       // 0x01D0(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         M_fThrustATron2000ProjectileDeflectRestitution;    // 0x01D4(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	struct FGameplayTag                           M_tUpgradeTagEchotronRamjets;                      // 0x01D8(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, DisableEditOnInstance, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	struct FSoftClassPath                         M_oEchotronRamjetsShockwaveClassPath;              // 0x01E0(0x0018)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, Protected, NativeAccessSpecifierProtected)
	class UClass*                                 M_pCachedEchotronRamjetsShockwaveClass;            // 0x01F8(0x0008)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)

public:
	void BFGActorComponent_Dash_Event__DelegateSignature(class UBFGActorComponent_Dash* _pDashComponent);
	void BFGActorComponent_DashPhase_Event__DelegateSignature(class UBFGActorComponent_Dash* _pDashComponent, int32 _iPhase);
	void BlockAirDash();
	void DisableDash();
	void EnableDash();
	void OnOwnerDamage(class AActor* _DamagedActor, float _fDamage, const class UDamageType* _pDamageType, class AController* _pInstigatedBy, class AActor* _pDamageCauser);
	void ResetAirDashCount();
	void TriggerDash();
	void UnblockAirDash();

	bool IsDashEnabled() const;
	bool IsEchotronRamjetsUnlocked() const;
	bool IsThrustATron2000Unlocked() const;
	bool IsThrustATron5000Unlocked() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"BFGActorComponent_Dash">();
	}
	static class UBFGActorComponent_Dash* GetDefaultObj()
	{
		return GetDefaultObjImpl<UBFGActorComponent_Dash>();
	}
};
static_assert(alignof(UBFGActorComponent_Dash) == 0x000008, "Wrong alignment on UBFGActorComponent_Dash");
static_assert(sizeof(UBFGActorComponent_Dash) == 0x000200, "Wrong size on UBFGActorComponent_Dash");
static_assert(offsetof(UBFGActorComponent_Dash, M_onDashTriggered) == 0x000128, "Member 'UBFGActorComponent_Dash::M_onDashTriggered' has a wrong offset!");
static_assert(offsetof(UBFGActorComponent_Dash, M_onDashPhase) == 0x000140, "Member 'UBFGActorComponent_Dash::M_onDashPhase' has a wrong offset!");
static_assert(offsetof(UBFGActorComponent_Dash, M_onDashStopped) == 0x000158, "Member 'UBFGActorComponent_Dash::M_onDashStopped' has a wrong offset!");
static_assert(offsetof(UBFGActorComponent_Dash, M_pOwningCharacter) == 0x000170, "Member 'UBFGActorComponent_Dash::M_pOwningCharacter' has a wrong offset!");
static_assert(offsetof(UBFGActorComponent_Dash, M_pPlayerMovementComponent) == 0x000178, "Member 'UBFGActorComponent_Dash::M_pPlayerMovementComponent' has a wrong offset!");
static_assert(offsetof(UBFGActorComponent_Dash, M_pDashParams) == 0x000180, "Member 'UBFGActorComponent_Dash::M_pDashParams' has a wrong offset!");
static_assert(offsetof(UBFGActorComponent_Dash, M_vLastDashDirection) == 0x0001A8, "Member 'UBFGActorComponent_Dash::M_vLastDashDirection' has a wrong offset!");
static_assert(offsetof(UBFGActorComponent_Dash, M_tUpgradeTagThrustATron2000) == 0x0001B4, "Member 'UBFGActorComponent_Dash::M_tUpgradeTagThrustATron2000' has a wrong offset!");
static_assert(offsetof(UBFGActorComponent_Dash, M_fThrustATron2000Radius) == 0x0001BC, "Member 'UBFGActorComponent_Dash::M_fThrustATron2000Radius' has a wrong offset!");
static_assert(offsetof(UBFGActorComponent_Dash, M_tUpgradeTagThrustATron5000) == 0x0001C0, "Member 'UBFGActorComponent_Dash::M_tUpgradeTagThrustATron5000' has a wrong offset!");
static_assert(offsetof(UBFGActorComponent_Dash, M_fThrustATron5000Radius) == 0x0001C8, "Member 'UBFGActorComponent_Dash::M_fThrustATron5000Radius' has a wrong offset!");
static_assert(offsetof(UBFGActorComponent_Dash, M_fThrustATron2000Impulse) == 0x0001CC, "Member 'UBFGActorComponent_Dash::M_fThrustATron2000Impulse' has a wrong offset!");
static_assert(offsetof(UBFGActorComponent_Dash, M_fThrustATron2000ProjectileDeflectFriction) == 0x0001D0, "Member 'UBFGActorComponent_Dash::M_fThrustATron2000ProjectileDeflectFriction' has a wrong offset!");
static_assert(offsetof(UBFGActorComponent_Dash, M_fThrustATron2000ProjectileDeflectRestitution) == 0x0001D4, "Member 'UBFGActorComponent_Dash::M_fThrustATron2000ProjectileDeflectRestitution' has a wrong offset!");
static_assert(offsetof(UBFGActorComponent_Dash, M_tUpgradeTagEchotronRamjets) == 0x0001D8, "Member 'UBFGActorComponent_Dash::M_tUpgradeTagEchotronRamjets' has a wrong offset!");
static_assert(offsetof(UBFGActorComponent_Dash, M_oEchotronRamjetsShockwaveClassPath) == 0x0001E0, "Member 'UBFGActorComponent_Dash::M_oEchotronRamjetsShockwaveClassPath' has a wrong offset!");
static_assert(offsetof(UBFGActorComponent_Dash, M_pCachedEchotronRamjetsShockwaveClass) == 0x0001F8, "Member 'UBFGActorComponent_Dash::M_pCachedEchotronRamjetsShockwaveClass' has a wrong offset!");

// Class BFGCore.BFGEventTest_CheckAlertLevelReached
// 0x0008 (0x0030 - 0x0028)
class UBFGEventTest_CheckAlertLevelReached final : public UBFGEventTest
{
public:
	uint8                                         Pad_28[0x8];                                       // 0x0028(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"BFGEventTest_CheckAlertLevelReached">();
	}
	static class UBFGEventTest_CheckAlertLevelReached* GetDefaultObj()
	{
		return GetDefaultObjImpl<UBFGEventTest_CheckAlertLevelReached>();
	}
};
static_assert(alignof(UBFGEventTest_CheckAlertLevelReached) == 0x000008, "Wrong alignment on UBFGEventTest_CheckAlertLevelReached");
static_assert(sizeof(UBFGEventTest_CheckAlertLevelReached) == 0x000030, "Wrong size on UBFGEventTest_CheckAlertLevelReached");

// Class BFGCore.BFGActorComponent_DetectionHelper
// 0x0150 (0x0278 - 0x0128)
class UBFGActorComponent_DetectionHelper final : public UActorComponent
{
public:
	TMap<class AActor*, struct FVector>           M_avLastKnownPositions;                            // 0x0128(0x0050)(ZeroConstructor, Transient, Protected, NativeAccessSpecifierProtected)
	TMap<class AActor*, float>                    M_afLastKnownSeenUpdates;                          // 0x0178(0x0050)(ZeroConstructor, Transient, Protected, NativeAccessSpecifierProtected)
	TSet<class AActor*>                           M_apChangingDisguise;                              // 0x01C8(0x0050)(ZeroConstructor, Transient, Protected, NativeAccessSpecifierProtected)
	class FName                                   M_bbKeyStunned;                                    // 0x0218(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         M_bShareKnowledge : 1;                             // 0x0220(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (Edit, Transient, EditConst, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected))
	uint8                                         Pad_221[0x7];                                      // 0x0221(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	class APawn*                                  M_pPawn;                                           // 0x0228(0x0008)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_230[0x8];                                      // 0x0230(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	class UBFGActorComponent_Alert*               M_pAlertComponent;                                 // 0x0238(0x0008)(ExportObject, ZeroConstructor, Transient, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UBFGAICombatMediator_TargetTracker*     M_pTargetTracker;                                  // 0x0240(0x0008)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UBlackboardComponent*                   M_pBlackboardComponent;                            // 0x0248(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UBFG_AISettings*                        M_pSettings;                                       // 0x0250(0x0008)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_258[0x18];                                     // 0x0258(0x0018)(Fixing Size After Last Property [ Dumper-7 ])
	class AActor*                                 M_pLastFriendlyLineOfSightTarget;                  // 0x0270(0x0008)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)

public:
	bool IsDisguised(class AActor* _pDisguisedActor, bool _bHandleConsequences, bool _bIgnoreChangingDisguiseFlag);
	void OnAIAlertStateChanged(EBFGBehaviourState_NPC _eState);
	void SetLastSensorUpdateTime(float _fLastSensorUpdateTime);

	bool GetShareKnowledge() const;
	bool IsDetectable(class AActor* _pTargetActor) const;
	bool IsHypnotized(class AActor* _pTargetActor) const;
	bool IsInProtectiveBubble(class AActor* _pTargetActor) const;
	bool IsStunned() const;
	bool IsTargetable(class AActor* _pTargetActor) const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"BFGActorComponent_DetectionHelper">();
	}
	static class UBFGActorComponent_DetectionHelper* GetDefaultObj()
	{
		return GetDefaultObjImpl<UBFGActorComponent_DetectionHelper>();
	}
};
static_assert(alignof(UBFGActorComponent_DetectionHelper) == 0x000008, "Wrong alignment on UBFGActorComponent_DetectionHelper");
static_assert(sizeof(UBFGActorComponent_DetectionHelper) == 0x000278, "Wrong size on UBFGActorComponent_DetectionHelper");
static_assert(offsetof(UBFGActorComponent_DetectionHelper, M_avLastKnownPositions) == 0x000128, "Member 'UBFGActorComponent_DetectionHelper::M_avLastKnownPositions' has a wrong offset!");
static_assert(offsetof(UBFGActorComponent_DetectionHelper, M_afLastKnownSeenUpdates) == 0x000178, "Member 'UBFGActorComponent_DetectionHelper::M_afLastKnownSeenUpdates' has a wrong offset!");
static_assert(offsetof(UBFGActorComponent_DetectionHelper, M_apChangingDisguise) == 0x0001C8, "Member 'UBFGActorComponent_DetectionHelper::M_apChangingDisguise' has a wrong offset!");
static_assert(offsetof(UBFGActorComponent_DetectionHelper, M_bbKeyStunned) == 0x000218, "Member 'UBFGActorComponent_DetectionHelper::M_bbKeyStunned' has a wrong offset!");
static_assert(offsetof(UBFGActorComponent_DetectionHelper, M_pPawn) == 0x000228, "Member 'UBFGActorComponent_DetectionHelper::M_pPawn' has a wrong offset!");
static_assert(offsetof(UBFGActorComponent_DetectionHelper, M_pAlertComponent) == 0x000238, "Member 'UBFGActorComponent_DetectionHelper::M_pAlertComponent' has a wrong offset!");
static_assert(offsetof(UBFGActorComponent_DetectionHelper, M_pTargetTracker) == 0x000240, "Member 'UBFGActorComponent_DetectionHelper::M_pTargetTracker' has a wrong offset!");
static_assert(offsetof(UBFGActorComponent_DetectionHelper, M_pBlackboardComponent) == 0x000248, "Member 'UBFGActorComponent_DetectionHelper::M_pBlackboardComponent' has a wrong offset!");
static_assert(offsetof(UBFGActorComponent_DetectionHelper, M_pSettings) == 0x000250, "Member 'UBFGActorComponent_DetectionHelper::M_pSettings' has a wrong offset!");
static_assert(offsetof(UBFGActorComponent_DetectionHelper, M_pLastFriendlyLineOfSightTarget) == 0x000270, "Member 'UBFGActorComponent_DetectionHelper::M_pLastFriendlyLineOfSightTarget' has a wrong offset!");

// Class BFGCore.BFGActorComponent_Effect
// 0x0038 (0x0160 - 0x0128)
class UBFGActorComponent_Effect final : public UActorComponent
{
public:
	TArray<class UBFGEffectBank*>                 M_apEffectBanks;                                   // 0x0128(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Protected, NativeAccessSpecifierProtected)
	TArray<class UBFGEffectContainer*>            M_apPersistentContainers;                          // 0x0138(0x0010)(ZeroConstructor, Transient, Protected, NativeAccessSpecifierProtected)
	TArray<class UBFGEffectContainer*>            M_apNonPersistentContainers;                       // 0x0148(0x0010)(ZeroConstructor, Transient, Protected, NativeAccessSpecifierProtected)
	class UBFGEffectBlackboard*                   M_pBlackboard;                                     // 0x0158(0x0008)(ExportObject, ZeroConstructor, Transient, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)

public:
	TArray<class UBFGEffectContainer*> ActivateEffectAttachToActor(EBFGEffect_Identifier _eIdentifier, class AActor* _pAttachTo, const class FName _oSocketName, EAttachmentRule _eLocationAttachRule, EAttachmentRule _eRotationAttachRule, EAttachmentRule _eScaleAttachRule, class ABFGPlayerController* _pPlayerController, const struct FVector& _rRelativeLocation, const struct FRotator& _rRelativeRotation, bool _bAbsoluteLocation, bool _bAbsoluteRotation);
	TArray<class UBFGEffectContainer*> ActivateEffectAttachToComponent(EBFGEffect_Identifier _eIdentifier, class USceneComponent* _pAttachTo, const class FName _oSocketName, EAttachmentRule _eLocationAttachRule, EAttachmentRule _eRotationAttachRule, EAttachmentRule _eScaleAttachRule, class ABFGPlayerController* _pPlayerController, const struct FVector& _rRelativeLocation, const struct FRotator& _rRelativeRotation, bool _bAbsoluteLocation, bool _bAbsoluteRotation);
	TArray<class UBFGEffectContainer*> ActivateEffectWithTransform(EBFGEffect_Identifier _eIdentifier, const struct FTransform& _rTransform, class ABFGPlayerController* _pPlayerController);
	TArray<class UBFGEffectContainer*> ActivateSlotEffectAttachToActor(EBFGEffect_Identifier _eIdentifier, int32 _iSlot, class AActor* _pAttachTo, const class FName _oSocketName, EAttachmentRule _eLocationAttachRule, EAttachmentRule _eRotationAttachRule, EAttachmentRule _eScaleAttachRule, class ABFGPlayerController* _pPlayerController, const struct FVector& _rRelativeLocation, const struct FRotator& _rRelativeRotation, bool _bAbsoluteLocation, bool _bAbsoluteRotation);
	TArray<class UBFGEffectContainer*> ActivateSlotEffectAttachToComponent(EBFGEffect_Identifier _eIdentifier, int32 _iSlot, class USceneComponent* _pAttachTo, const class FName _oSocketName, EAttachmentRule _eLocationAttachRule, EAttachmentRule _eRotationAttachRule, EAttachmentRule _eScaleAttachRule, class ABFGPlayerController* _pPlayerController, const struct FVector& _rRelativeLocation, const struct FRotator& _rRelativeRotation, bool _bAbsoluteLocation, bool _bAbsoluteRotation);
	TArray<class UBFGEffectContainer*> ActivateSlotEffectWithTransform(EBFGEffect_Identifier _eIdentifier, int32 _iSlot, const struct FTransform& _rTransform, class ABFGPlayerController* _pPlayerController);
	void AddEffectBank(class UBFGEffectBank* _pEffectBank);
	int32 ComputeFreeSlot();
	void DeactivateAllEffects(bool _bIncludeNonPersistent);
	void DeactivateEffect(EBFGEffect_Identifier _eIdentifier, bool _bIncludeNonPersistent);
	void DeactivateSlotEffect(EBFGEffect_Identifier _eIdentifier, int32 _iSlot, bool _bIncludeNonPersistent);
	void DestroyAllEffects(bool _bIncludeNonPersistent);
	void DestroyEffect(EBFGEffect_Identifier _eIdentifier, bool _bIncludeNonPersistent);
	void DestroySlotEffect(EBFGEffect_Identifier _eIdentifier, int32 _iSlot, bool _bIncludeNonPersistent);
	void HandleActorChanged(const class FName _rName, class AActor* _iValue, int32 _iSlot);
	void HandleBoolChanged(const class FName _rName, bool _bValue, int32 _iSlot);
	void HandleColorChanged(const class FName _rName, const struct FColor& _rValue, int32 _iSlot);
	void HandleContainerDeath(class UBFGEffectContainer* _pContainer);
	void HandleDataTableChanged(const class FName _rName, class UDataTable* _pValue, int32 _iSlot);
	void HandleFloatChanged(const class FName _rName, float _fValue, int32 _iSlot);
	void HandleIntChanged(const class FName _rName, int32 _iValue, int32 _iSlot);
	void HandleNameChanged(const class FName _rName, class FName _iValue, int32 _iSlot);
	void HandleObjectChanged(const class FName _rName, class UObject* _pValue, int32 _iSlot);
	void HandleRandFloatChanged(const class FName _rName, const struct FBFGEffectBlackboardParameter_RandFloat& _rValue, int32 _iSlot);
	void HandleRandVectorChanged(const class FName _rName, const struct FBFGEffectBlackboardParameter_RandVector& _rValue, int32 _iSlot);
	void HandleRotatorChanged(const class FName _rName, const struct FRotator& _rValue, int32 _iSlot);
	void HandleVectorChanged(const class FName _rName, const struct FVector& _rValue, int32 _iSlot);
	void RemoveEffectBank(class UBFGEffectBank* _pEffectBank);

	class UBFGEffectBlackboard* GetBlackboard() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"BFGActorComponent_Effect">();
	}
	static class UBFGActorComponent_Effect* GetDefaultObj()
	{
		return GetDefaultObjImpl<UBFGActorComponent_Effect>();
	}
};
static_assert(alignof(UBFGActorComponent_Effect) == 0x000008, "Wrong alignment on UBFGActorComponent_Effect");
static_assert(sizeof(UBFGActorComponent_Effect) == 0x000160, "Wrong size on UBFGActorComponent_Effect");
static_assert(offsetof(UBFGActorComponent_Effect, M_apEffectBanks) == 0x000128, "Member 'UBFGActorComponent_Effect::M_apEffectBanks' has a wrong offset!");
static_assert(offsetof(UBFGActorComponent_Effect, M_apPersistentContainers) == 0x000138, "Member 'UBFGActorComponent_Effect::M_apPersistentContainers' has a wrong offset!");
static_assert(offsetof(UBFGActorComponent_Effect, M_apNonPersistentContainers) == 0x000148, "Member 'UBFGActorComponent_Effect::M_apNonPersistentContainers' has a wrong offset!");
static_assert(offsetof(UBFGActorComponent_Effect, M_pBlackboard) == 0x000158, "Member 'UBFGActorComponent_Effect::M_pBlackboard' has a wrong offset!");

// Class BFGCore.BFGVariableAction
// 0x00C8 (0x00F0 - 0x0028)
class UBFGVariableAction : public UObject
{
public:
	struct FGuid                                  M_guid;                                            // 0x0028(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   M_strActionName;                                   // 0x0038(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   M_strVariableTypeName;                             // 0x0040(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TMap<class FName, class FName>                M_aValueNameMapping;                               // 0x0048(0x0050)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, NativeAccessSpecifierPublic)
	uint8                                         Pad_98[0x50];                                      // 0x0098(0x0050)(Fixing Size After Last Property [ Dumper-7 ])
	class UBFGVariableType*                       M_pVariableType;                                   // 0x00E8(0x0008)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"BFGVariableAction">();
	}
	static class UBFGVariableAction* GetDefaultObj()
	{
		return GetDefaultObjImpl<UBFGVariableAction>();
	}
};
static_assert(alignof(UBFGVariableAction) == 0x000008, "Wrong alignment on UBFGVariableAction");
static_assert(sizeof(UBFGVariableAction) == 0x0000F0, "Wrong size on UBFGVariableAction");
static_assert(offsetof(UBFGVariableAction, M_guid) == 0x000028, "Member 'UBFGVariableAction::M_guid' has a wrong offset!");
static_assert(offsetof(UBFGVariableAction, M_strActionName) == 0x000038, "Member 'UBFGVariableAction::M_strActionName' has a wrong offset!");
static_assert(offsetof(UBFGVariableAction, M_strVariableTypeName) == 0x000040, "Member 'UBFGVariableAction::M_strVariableTypeName' has a wrong offset!");
static_assert(offsetof(UBFGVariableAction, M_aValueNameMapping) == 0x000048, "Member 'UBFGVariableAction::M_aValueNameMapping' has a wrong offset!");
static_assert(offsetof(UBFGVariableAction, M_pVariableType) == 0x0000E8, "Member 'UBFGVariableAction::M_pVariableType' has a wrong offset!");

// Class BFGCore.BFGVariableAction_Boolean_SetFalse
// 0x0000 (0x00F0 - 0x00F0)
class UBFGVariableAction_Boolean_SetFalse final : public UBFGVariableAction
{
public:
	static const class FName GetActionName_BooleanSetFalse();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"BFGVariableAction_Boolean_SetFalse">();
	}
	static class UBFGVariableAction_Boolean_SetFalse* GetDefaultObj()
	{
		return GetDefaultObjImpl<UBFGVariableAction_Boolean_SetFalse>();
	}
};
static_assert(alignof(UBFGVariableAction_Boolean_SetFalse) == 0x000008, "Wrong alignment on UBFGVariableAction_Boolean_SetFalse");
static_assert(sizeof(UBFGVariableAction_Boolean_SetFalse) == 0x0000F0, "Wrong size on UBFGVariableAction_Boolean_SetFalse");

// Class BFGCore.BFGEventTest_VoiceoverSystemIdle
// 0x0010 (0x0038 - 0x0028)
class UBFGEventTest_VoiceoverSystemIdle final : public UBFGEventTest
{
public:
	TArray<TSoftObjectPtr<class UBFGVoiceoverGroup>> M_apGroups;                                        // 0x0028(0x0010)(ZeroConstructor, Transient, Protected, UObjectWrapper, NativeAccessSpecifierProtected)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"BFGEventTest_VoiceoverSystemIdle">();
	}
	static class UBFGEventTest_VoiceoverSystemIdle* GetDefaultObj()
	{
		return GetDefaultObjImpl<UBFGEventTest_VoiceoverSystemIdle>();
	}
};
static_assert(alignof(UBFGEventTest_VoiceoverSystemIdle) == 0x000008, "Wrong alignment on UBFGEventTest_VoiceoverSystemIdle");
static_assert(sizeof(UBFGEventTest_VoiceoverSystemIdle) == 0x000038, "Wrong size on UBFGEventTest_VoiceoverSystemIdle");
static_assert(offsetof(UBFGEventTest_VoiceoverSystemIdle, M_apGroups) == 0x000028, "Member 'UBFGEventTest_VoiceoverSystemIdle::M_apGroups' has a wrong offset!");

// Class BFGCore.BFGNetworkPathAgent_AIStateVehicleGotoLocation
// 0x0020 (0x0078 - 0x0058)
class UBFGNetworkPathAgent_AIStateVehicleGotoLocation final : public UBFGNetworkPathAgent_AIStateBase
{
public:
	struct FBFGAIStateVehicleGotoLocationParameter M_GotoLocationParam;                               // 0x0058(0x0018)(Transient, NoDestructor, Protected, NativeAccessSpecifierProtected)
	EBFGAIVehicleVehicleGotoLocation              M_ePhase;                                          // 0x0070(0x0001)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          M_bLocationDirty;                                  // 0x0071(0x0001)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          M_bRecheckStartPath;                               // 0x0072(0x0001)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_73[0x5];                                       // 0x0073(0x0005)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"BFGNetworkPathAgent_AIStateVehicleGotoLocation">();
	}
	static class UBFGNetworkPathAgent_AIStateVehicleGotoLocation* GetDefaultObj()
	{
		return GetDefaultObjImpl<UBFGNetworkPathAgent_AIStateVehicleGotoLocation>();
	}
};
static_assert(alignof(UBFGNetworkPathAgent_AIStateVehicleGotoLocation) == 0x000008, "Wrong alignment on UBFGNetworkPathAgent_AIStateVehicleGotoLocation");
static_assert(sizeof(UBFGNetworkPathAgent_AIStateVehicleGotoLocation) == 0x000078, "Wrong size on UBFGNetworkPathAgent_AIStateVehicleGotoLocation");
static_assert(offsetof(UBFGNetworkPathAgent_AIStateVehicleGotoLocation, M_GotoLocationParam) == 0x000058, "Member 'UBFGNetworkPathAgent_AIStateVehicleGotoLocation::M_GotoLocationParam' has a wrong offset!");
static_assert(offsetof(UBFGNetworkPathAgent_AIStateVehicleGotoLocation, M_ePhase) == 0x000070, "Member 'UBFGNetworkPathAgent_AIStateVehicleGotoLocation::M_ePhase' has a wrong offset!");
static_assert(offsetof(UBFGNetworkPathAgent_AIStateVehicleGotoLocation, M_bLocationDirty) == 0x000071, "Member 'UBFGNetworkPathAgent_AIStateVehicleGotoLocation::M_bLocationDirty' has a wrong offset!");
static_assert(offsetof(UBFGNetworkPathAgent_AIStateVehicleGotoLocation, M_bRecheckStartPath) == 0x000072, "Member 'UBFGNetworkPathAgent_AIStateVehicleGotoLocation::M_bRecheckStartPath' has a wrong offset!");

// Class BFGCore.BFGActorComponent_EnvironmentMonitor
// 0x0008 (0x0130 - 0x0128)
class UBFGActorComponent_EnvironmentMonitor final : public UActorComponent
{
public:
	uint8                                         Pad_128[0x8];                                      // 0x0128(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"BFGActorComponent_EnvironmentMonitor">();
	}
	static class UBFGActorComponent_EnvironmentMonitor* GetDefaultObj()
	{
		return GetDefaultObjImpl<UBFGActorComponent_EnvironmentMonitor>();
	}
};
static_assert(alignof(UBFGActorComponent_EnvironmentMonitor) == 0x000008, "Wrong alignment on UBFGActorComponent_EnvironmentMonitor");
static_assert(sizeof(UBFGActorComponent_EnvironmentMonitor) == 0x000130, "Wrong size on UBFGActorComponent_EnvironmentMonitor");

// Class BFGCore.BFGWidget_DialogOption
// 0x0020 (0x0260 - 0x0240)
class UBFGWidget_DialogOption : public UUserWidget
{
public:
	TWeakObjectPtr<class UBFGWidget_GenericDialog> M_pDialog;                                         // 0x0240(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class FName                                   M_targetHandlerName;                               // 0x0248(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          M_bMouseHovered;                                   // 0x0250(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          M_bMousePressed;                                   // 0x0251(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          M_bIsDisabled;                                     // 0x0252(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_253[0x1];                                      // 0x0253(0x0001)(Fixing Size After Last Property [ Dumper-7 ])
	int32                                         M_iIndex;                                          // 0x0254(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          M_bHasNotification;                                // 0x0258(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_259[0x7];                                      // 0x0259(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void Accept();
	void Cancel();
	void HandleMouseHover();
	void HandleMousePress();
	void HandleMouseRelease();
	void HandleMouseUnhover();
	void HandleSecondaryAxisChange(bool _bToRight);
	void OnHasNotification(bool _bShow);
	void OnNativeAccept();
	void OnNativeCancel();
	void OnOptionStateChanged(EBFGDialogOptionSelectionState _eState);
	void SetNotificationFlag(bool _bValue);
	void SetTargetHandlerName(class FName _targetHandlerName);
	void UpdateTimescaledSecondaryAxisValue(float _fAxis);
	void UpdateValueBool(bool _bValue);

	bool HasNotificationFlag() const;
	bool SupportsAccept() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"BFGWidget_DialogOption">();
	}
	static class UBFGWidget_DialogOption* GetDefaultObj()
	{
		return GetDefaultObjImpl<UBFGWidget_DialogOption>();
	}
};
static_assert(alignof(UBFGWidget_DialogOption) == 0x000008, "Wrong alignment on UBFGWidget_DialogOption");
static_assert(sizeof(UBFGWidget_DialogOption) == 0x000260, "Wrong size on UBFGWidget_DialogOption");
static_assert(offsetof(UBFGWidget_DialogOption, M_pDialog) == 0x000240, "Member 'UBFGWidget_DialogOption::M_pDialog' has a wrong offset!");
static_assert(offsetof(UBFGWidget_DialogOption, M_targetHandlerName) == 0x000248, "Member 'UBFGWidget_DialogOption::M_targetHandlerName' has a wrong offset!");
static_assert(offsetof(UBFGWidget_DialogOption, M_bMouseHovered) == 0x000250, "Member 'UBFGWidget_DialogOption::M_bMouseHovered' has a wrong offset!");
static_assert(offsetof(UBFGWidget_DialogOption, M_bMousePressed) == 0x000251, "Member 'UBFGWidget_DialogOption::M_bMousePressed' has a wrong offset!");
static_assert(offsetof(UBFGWidget_DialogOption, M_bIsDisabled) == 0x000252, "Member 'UBFGWidget_DialogOption::M_bIsDisabled' has a wrong offset!");
static_assert(offsetof(UBFGWidget_DialogOption, M_iIndex) == 0x000254, "Member 'UBFGWidget_DialogOption::M_iIndex' has a wrong offset!");
static_assert(offsetof(UBFGWidget_DialogOption, M_bHasNotification) == 0x000258, "Member 'UBFGWidget_DialogOption::M_bHasNotification' has a wrong offset!");

// Class BFGCore.BFGWidget_DialogOption_Customizable
// 0x0018 (0x0278 - 0x0260)
class UBFGWidget_DialogOption_Customizable : public UBFGWidget_DialogOption
{
public:
	class FText                                   M_strCustomizedText;                               // 0x0260(0x0018)(BlueprintVisible, BlueprintReadOnly, NativeAccessSpecifierPublic)

public:
	void OnUpdateDialogText();
	void SetDialogOptionText(const class FText& _strText, bool _isDirty);

	const class FText GetDialogOptionText() const;
	bool IsDialogOptionTextCustomized() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"BFGWidget_DialogOption_Customizable">();
	}
	static class UBFGWidget_DialogOption_Customizable* GetDefaultObj()
	{
		return GetDefaultObjImpl<UBFGWidget_DialogOption_Customizable>();
	}
};
static_assert(alignof(UBFGWidget_DialogOption_Customizable) == 0x000008, "Wrong alignment on UBFGWidget_DialogOption_Customizable");
static_assert(sizeof(UBFGWidget_DialogOption_Customizable) == 0x000278, "Wrong size on UBFGWidget_DialogOption_Customizable");
static_assert(offsetof(UBFGWidget_DialogOption_Customizable, M_strCustomizedText) == 0x000260, "Member 'UBFGWidget_DialogOption_Customizable::M_strCustomizedText' has a wrong offset!");

// Class BFGCore.BFGWidget_DialogOption_HoloPoxEntry
// 0x0130 (0x03A8 - 0x0278)
class UBFGWidget_DialogOption_HoloPoxEntry final : public UBFGWidget_DialogOption_Customizable
{
public:
	struct FBFGHolobobDeckSelectionInfo           ODataInfo;                                         // 0x0278(0x0130)(NativeAccessSpecifierPublic)

public:
	void OnSetupData(const struct FBFGHolobobDeckSelectionInfo& _oOptionData);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"BFGWidget_DialogOption_HoloPoxEntry">();
	}
	static class UBFGWidget_DialogOption_HoloPoxEntry* GetDefaultObj()
	{
		return GetDefaultObjImpl<UBFGWidget_DialogOption_HoloPoxEntry>();
	}
};
static_assert(alignof(UBFGWidget_DialogOption_HoloPoxEntry) == 0x000008, "Wrong alignment on UBFGWidget_DialogOption_HoloPoxEntry");
static_assert(sizeof(UBFGWidget_DialogOption_HoloPoxEntry) == 0x0003A8, "Wrong size on UBFGWidget_DialogOption_HoloPoxEntry");
static_assert(offsetof(UBFGWidget_DialogOption_HoloPoxEntry, ODataInfo) == 0x000278, "Member 'UBFGWidget_DialogOption_HoloPoxEntry::ODataInfo' has a wrong offset!");

// Class BFGCore.BFGActorComponent_EquipmentManager
// 0x00E0 (0x0208 - 0x0128)
class UBFGActorComponent_EquipmentManager final : public UActorComponent
{
public:
	UMulticastDelegateProperty_                   M_OnWeaponChanged;                                 // 0x0128(0x0018)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	UMulticastDelegateProperty_                   M_OnWeaponFireRequestedChanged;                    // 0x0140(0x0018)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	UMulticastDelegateProperty_                   M_OnWeaponAmmoChanged;                             // 0x0158(0x0018)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	uint8                                         Pad_170[0x18];                                     // 0x0170(0x0018)(Fixing Size After Last Property [ Dumper-7 ])
	class UBFGActorComponent_Animation*           M_pOwnerAnimationComponent;                        // 0x0188(0x0008)(ExportObject, ZeroConstructor, Transient, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TArray<struct FBFGEquipableWeaponInfo>        M_aWeaponInfo;                                     // 0x0190(0x0010)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, ContainsInstancedReference, Protected, NativeAccessSpecifierProtected)
	TArray<class ABFGWeapon*>                     M_aWeaponList;                                     // 0x01A0(0x0010)(ZeroConstructor, Transient, Protected, NativeAccessSpecifierProtected)
	TArray<class ABFGWeapon*>                     M_aPrespawnedWeaponList;                           // 0x01B0(0x0010)(ZeroConstructor, Transient, Protected, NativeAccessSpecifierProtected)
	TArray<class ABFGWeapon*>                     M_apCurrentlyEquipWeapons;                         // 0x01C0(0x0010)(ZeroConstructor, Transient, Protected, NativeAccessSpecifierProtected)
	int32                                         M_iMaxEquipmentSlots;                              // 0x01D0(0x0004)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	int32                                         M_iNextWeaponID;                                   // 0x01D4(0x0004)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          M_bAnimationControlledEquip;                       // 0x01D8(0x0001)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_1D9[0x3];                                      // 0x01D9(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         M_fAnimationEquipFallbackDelay;                    // 0x01DC(0x0004)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_1E0[0x8];                                      // 0x01E0(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<struct FBFGLatentEquipData>            M_aLatentEquipData;                                // 0x01E8(0x0010)(ZeroConstructor, Transient, Protected, NativeAccessSpecifierProtected)
	TArray<struct FBFGLatentEquipData>            M_aLatentUnequipData;                              // 0x01F8(0x0010)(ZeroConstructor, Transient, Protected, NativeAccessSpecifierProtected)

public:
	int32 GetCurrentWeaponAmmo(const TSubclassOf<class ABFGWeapon>& _rWeaponClass);
	int32 GetCurrentWeaponMaxAmmo(const TSubclassOf<class ABFGWeapon>& _rWeaponClass);
	bool GetCurrentWeaponOverheated(const TSubclassOf<class ABFGWeapon>& _rWeaponClass);
	void OnWeaponAmmoChanged(class ABFGWeapon* _pWeapon);
	void OnWeaponNotReady(class UClass* _pWeaponClass);
	void OnWeaponNotVisibile(class UClass* _pWeaponClass);
	void OnWeaponReady(class UClass* _pWeaponClass);
	void OnWeaponVisibile(class UClass* _pWeaponClass);
	bool RequestFirstWeaponEquipped(int32 _iStartIndex, bool _bSwapDirection);
	bool RequestWeaponEquipped(class ABFGWeapon* _pWeaponClass);
	bool RequestWeaponEquippedByClass(const TSubclassOf<class ABFGWeapon>& _rWeaponClass);
	void SetWidgetVisibility(ESlateVisibility _eVisibility);

	class ABFGWeapon* GetCurrentWeapon(class UClass* _pClass) const;
	const TArray<class ABFGWeapon*> GetCurrentWeapons() const;
	class ABFGWeapon* GetWeapon(int32 _iWeaponID) const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"BFGActorComponent_EquipmentManager">();
	}
	static class UBFGActorComponent_EquipmentManager* GetDefaultObj()
	{
		return GetDefaultObjImpl<UBFGActorComponent_EquipmentManager>();
	}
};
static_assert(alignof(UBFGActorComponent_EquipmentManager) == 0x000008, "Wrong alignment on UBFGActorComponent_EquipmentManager");
static_assert(sizeof(UBFGActorComponent_EquipmentManager) == 0x000208, "Wrong size on UBFGActorComponent_EquipmentManager");
static_assert(offsetof(UBFGActorComponent_EquipmentManager, M_OnWeaponChanged) == 0x000128, "Member 'UBFGActorComponent_EquipmentManager::M_OnWeaponChanged' has a wrong offset!");
static_assert(offsetof(UBFGActorComponent_EquipmentManager, M_OnWeaponFireRequestedChanged) == 0x000140, "Member 'UBFGActorComponent_EquipmentManager::M_OnWeaponFireRequestedChanged' has a wrong offset!");
static_assert(offsetof(UBFGActorComponent_EquipmentManager, M_OnWeaponAmmoChanged) == 0x000158, "Member 'UBFGActorComponent_EquipmentManager::M_OnWeaponAmmoChanged' has a wrong offset!");
static_assert(offsetof(UBFGActorComponent_EquipmentManager, M_pOwnerAnimationComponent) == 0x000188, "Member 'UBFGActorComponent_EquipmentManager::M_pOwnerAnimationComponent' has a wrong offset!");
static_assert(offsetof(UBFGActorComponent_EquipmentManager, M_aWeaponInfo) == 0x000190, "Member 'UBFGActorComponent_EquipmentManager::M_aWeaponInfo' has a wrong offset!");
static_assert(offsetof(UBFGActorComponent_EquipmentManager, M_aWeaponList) == 0x0001A0, "Member 'UBFGActorComponent_EquipmentManager::M_aWeaponList' has a wrong offset!");
static_assert(offsetof(UBFGActorComponent_EquipmentManager, M_aPrespawnedWeaponList) == 0x0001B0, "Member 'UBFGActorComponent_EquipmentManager::M_aPrespawnedWeaponList' has a wrong offset!");
static_assert(offsetof(UBFGActorComponent_EquipmentManager, M_apCurrentlyEquipWeapons) == 0x0001C0, "Member 'UBFGActorComponent_EquipmentManager::M_apCurrentlyEquipWeapons' has a wrong offset!");
static_assert(offsetof(UBFGActorComponent_EquipmentManager, M_iMaxEquipmentSlots) == 0x0001D0, "Member 'UBFGActorComponent_EquipmentManager::M_iMaxEquipmentSlots' has a wrong offset!");
static_assert(offsetof(UBFGActorComponent_EquipmentManager, M_iNextWeaponID) == 0x0001D4, "Member 'UBFGActorComponent_EquipmentManager::M_iNextWeaponID' has a wrong offset!");
static_assert(offsetof(UBFGActorComponent_EquipmentManager, M_bAnimationControlledEquip) == 0x0001D8, "Member 'UBFGActorComponent_EquipmentManager::M_bAnimationControlledEquip' has a wrong offset!");
static_assert(offsetof(UBFGActorComponent_EquipmentManager, M_fAnimationEquipFallbackDelay) == 0x0001DC, "Member 'UBFGActorComponent_EquipmentManager::M_fAnimationEquipFallbackDelay' has a wrong offset!");
static_assert(offsetof(UBFGActorComponent_EquipmentManager, M_aLatentEquipData) == 0x0001E8, "Member 'UBFGActorComponent_EquipmentManager::M_aLatentEquipData' has a wrong offset!");
static_assert(offsetof(UBFGActorComponent_EquipmentManager, M_aLatentUnequipData) == 0x0001F8, "Member 'UBFGActorComponent_EquipmentManager::M_aLatentUnequipData' has a wrong offset!");

// Class BFGCore.BFGVariableAction_MissionGroup_MakeAvailable
// 0x0000 (0x00F0 - 0x00F0)
class UBFGVariableAction_MissionGroup_MakeAvailable final : public UBFGVariableAction
{
public:
	static const class FName GetActionName_MissionGroupMakeAvailble();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"BFGVariableAction_MissionGroup_MakeAvailable">();
	}
	static class UBFGVariableAction_MissionGroup_MakeAvailable* GetDefaultObj()
	{
		return GetDefaultObjImpl<UBFGVariableAction_MissionGroup_MakeAvailable>();
	}
};
static_assert(alignof(UBFGVariableAction_MissionGroup_MakeAvailable) == 0x000008, "Wrong alignment on UBFGVariableAction_MissionGroup_MakeAvailable");
static_assert(sizeof(UBFGVariableAction_MissionGroup_MakeAvailable) == 0x0000F0, "Wrong size on UBFGVariableAction_MissionGroup_MakeAvailable");

// Class BFGCore.BFGEventTest_Operation
// 0x0018 (0x0040 - 0x0028)
class UBFGEventTest_Operation final : public UBFGEventTest
{
public:
	uint8                                         Pad_28[0x8];                                       // 0x0028(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<class UBFGEventTest*>                  M_aOperands;                                       // 0x0030(0x0010)(ExportObject, ZeroConstructor, Transient, ContainsInstancedReference, Protected, NativeAccessSpecifierProtected)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"BFGEventTest_Operation">();
	}
	static class UBFGEventTest_Operation* GetDefaultObj()
	{
		return GetDefaultObjImpl<UBFGEventTest_Operation>();
	}
};
static_assert(alignof(UBFGEventTest_Operation) == 0x000008, "Wrong alignment on UBFGEventTest_Operation");
static_assert(sizeof(UBFGEventTest_Operation) == 0x000040, "Wrong size on UBFGEventTest_Operation");
static_assert(offsetof(UBFGEventTest_Operation, M_aOperands) == 0x000030, "Member 'UBFGEventTest_Operation::M_aOperands' has a wrong offset!");

// Class BFGCore.BFGActorComponent_ExplosiveItem
// 0x0058 (0x0180 - 0x0128)
class UBFGActorComponent_ExplosiveItem final : public UActorComponent
{
public:
	uint8                                         Pad_128[0x8];                                      // 0x0128(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	UMulticastDelegateProperty_                   OnItemExploded;                                    // 0x0130(0x0018)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	TSubclassOf<class UDamageType>                M_pDamageType;                                     // 0x0148(0x0008)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         M_fSoundRangeMultiplier;                           // 0x0150(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         M_fDamage;                                         // 0x0154(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         M_fPlayerDamage;                                   // 0x0158(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         M_fExplosionImpulse;                               // 0x015C(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         M_fExplosionRadius;                                // 0x0160(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         M_fMinRandomExplosionDelay;                        // 0x0164(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         M_fMaxRandomExplosionDelay;                        // 0x0168(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_16C[0x4];                                      // 0x016C(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class UStaticMeshComponent*                   M_pStaticMeshComponent;                            // 0x0170(0x0008)(ExportObject, ZeroConstructor, Transient, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_178[0x8];                                      // 0x0178(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void ActorComponent_ExplosiveItemExplosion__DelegateSignature(const TArray<class AActor*>& _aHitActorList);
	void OnEventExplosion(bool _bWithDelay);
	void ResetExplodedState();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"BFGActorComponent_ExplosiveItem">();
	}
	static class UBFGActorComponent_ExplosiveItem* GetDefaultObj()
	{
		return GetDefaultObjImpl<UBFGActorComponent_ExplosiveItem>();
	}
};
static_assert(alignof(UBFGActorComponent_ExplosiveItem) == 0x000008, "Wrong alignment on UBFGActorComponent_ExplosiveItem");
static_assert(sizeof(UBFGActorComponent_ExplosiveItem) == 0x000180, "Wrong size on UBFGActorComponent_ExplosiveItem");
static_assert(offsetof(UBFGActorComponent_ExplosiveItem, OnItemExploded) == 0x000130, "Member 'UBFGActorComponent_ExplosiveItem::OnItemExploded' has a wrong offset!");
static_assert(offsetof(UBFGActorComponent_ExplosiveItem, M_pDamageType) == 0x000148, "Member 'UBFGActorComponent_ExplosiveItem::M_pDamageType' has a wrong offset!");
static_assert(offsetof(UBFGActorComponent_ExplosiveItem, M_fSoundRangeMultiplier) == 0x000150, "Member 'UBFGActorComponent_ExplosiveItem::M_fSoundRangeMultiplier' has a wrong offset!");
static_assert(offsetof(UBFGActorComponent_ExplosiveItem, M_fDamage) == 0x000154, "Member 'UBFGActorComponent_ExplosiveItem::M_fDamage' has a wrong offset!");
static_assert(offsetof(UBFGActorComponent_ExplosiveItem, M_fPlayerDamage) == 0x000158, "Member 'UBFGActorComponent_ExplosiveItem::M_fPlayerDamage' has a wrong offset!");
static_assert(offsetof(UBFGActorComponent_ExplosiveItem, M_fExplosionImpulse) == 0x00015C, "Member 'UBFGActorComponent_ExplosiveItem::M_fExplosionImpulse' has a wrong offset!");
static_assert(offsetof(UBFGActorComponent_ExplosiveItem, M_fExplosionRadius) == 0x000160, "Member 'UBFGActorComponent_ExplosiveItem::M_fExplosionRadius' has a wrong offset!");
static_assert(offsetof(UBFGActorComponent_ExplosiveItem, M_fMinRandomExplosionDelay) == 0x000164, "Member 'UBFGActorComponent_ExplosiveItem::M_fMinRandomExplosionDelay' has a wrong offset!");
static_assert(offsetof(UBFGActorComponent_ExplosiveItem, M_fMaxRandomExplosionDelay) == 0x000168, "Member 'UBFGActorComponent_ExplosiveItem::M_fMaxRandomExplosionDelay' has a wrong offset!");
static_assert(offsetof(UBFGActorComponent_ExplosiveItem, M_pStaticMeshComponent) == 0x000170, "Member 'UBFGActorComponent_ExplosiveItem::M_pStaticMeshComponent' has a wrong offset!");

// Class BFGCore.BFGNetworkPath_RelativeDistanceCalculator_Base
// 0x0028 (0x0050 - 0x0028)
class UBFGNetworkPath_RelativeDistanceCalculator_Base : public UObject
{
public:
	class UBFGNetworkPath_RelativeDistanceCalculator_Base* M_pNext;                                           // 0x0028(0x0008)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UBFGNetworkPathAgent_Navigation*        M_pNavigation;                                     // 0x0030(0x0008)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         M_fCurrentDistance;                                // 0x0038(0x0004)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         M_fPathLength;                                     // 0x003C(0x0004)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         M_fComputedDistanceContribution;                   // 0x0040(0x0004)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         M_fRelativeDistance;                               // 0x0044(0x0004)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	EBFGNetworkPath_RelativeDistanceCalculatorType M_eType;                                           // 0x0048(0x0001)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          M_bIsReversed;                                     // 0x0049(0x0001)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          M_bUseRemainingDistance;                           // 0x004A(0x0001)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_4B[0x5];                                       // 0x004B(0x0005)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"BFGNetworkPath_RelativeDistanceCalculator_Base">();
	}
	static class UBFGNetworkPath_RelativeDistanceCalculator_Base* GetDefaultObj()
	{
		return GetDefaultObjImpl<UBFGNetworkPath_RelativeDistanceCalculator_Base>();
	}
};
static_assert(alignof(UBFGNetworkPath_RelativeDistanceCalculator_Base) == 0x000008, "Wrong alignment on UBFGNetworkPath_RelativeDistanceCalculator_Base");
static_assert(sizeof(UBFGNetworkPath_RelativeDistanceCalculator_Base) == 0x000050, "Wrong size on UBFGNetworkPath_RelativeDistanceCalculator_Base");
static_assert(offsetof(UBFGNetworkPath_RelativeDistanceCalculator_Base, M_pNext) == 0x000028, "Member 'UBFGNetworkPath_RelativeDistanceCalculator_Base::M_pNext' has a wrong offset!");
static_assert(offsetof(UBFGNetworkPath_RelativeDistanceCalculator_Base, M_pNavigation) == 0x000030, "Member 'UBFGNetworkPath_RelativeDistanceCalculator_Base::M_pNavigation' has a wrong offset!");
static_assert(offsetof(UBFGNetworkPath_RelativeDistanceCalculator_Base, M_fCurrentDistance) == 0x000038, "Member 'UBFGNetworkPath_RelativeDistanceCalculator_Base::M_fCurrentDistance' has a wrong offset!");
static_assert(offsetof(UBFGNetworkPath_RelativeDistanceCalculator_Base, M_fPathLength) == 0x00003C, "Member 'UBFGNetworkPath_RelativeDistanceCalculator_Base::M_fPathLength' has a wrong offset!");
static_assert(offsetof(UBFGNetworkPath_RelativeDistanceCalculator_Base, M_fComputedDistanceContribution) == 0x000040, "Member 'UBFGNetworkPath_RelativeDistanceCalculator_Base::M_fComputedDistanceContribution' has a wrong offset!");
static_assert(offsetof(UBFGNetworkPath_RelativeDistanceCalculator_Base, M_fRelativeDistance) == 0x000044, "Member 'UBFGNetworkPath_RelativeDistanceCalculator_Base::M_fRelativeDistance' has a wrong offset!");
static_assert(offsetof(UBFGNetworkPath_RelativeDistanceCalculator_Base, M_eType) == 0x000048, "Member 'UBFGNetworkPath_RelativeDistanceCalculator_Base::M_eType' has a wrong offset!");
static_assert(offsetof(UBFGNetworkPath_RelativeDistanceCalculator_Base, M_bIsReversed) == 0x000049, "Member 'UBFGNetworkPath_RelativeDistanceCalculator_Base::M_bIsReversed' has a wrong offset!");
static_assert(offsetof(UBFGNetworkPath_RelativeDistanceCalculator_Base, M_bUseRemainingDistance) == 0x00004A, "Member 'UBFGNetworkPath_RelativeDistanceCalculator_Base::M_bUseRemainingDistance' has a wrong offset!");

// Class BFGCore.BFGNetworkPath_RelativeDistanceCalculator_Segment
// 0x0020 (0x0070 - 0x0050)
class UBFGNetworkPath_RelativeDistanceCalculator_Segment : public UBFGNetworkPath_RelativeDistanceCalculator_Base
{
public:
	class UBFGNetworkPath*                        M_pCurrentPath;                                    // 0x0050(0x0008)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	int32                                         M_iDirection;                                      // 0x0058(0x0004)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_5C[0x4];                                       // 0x005C(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class UBFGNetworkPath*                        M_pNextPath;                                       // 0x0060(0x0008)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	int32                                         M_iNextDirection;                                  // 0x0068(0x0004)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_6C[0x4];                                       // 0x006C(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"BFGNetworkPath_RelativeDistanceCalculator_Segment">();
	}
	static class UBFGNetworkPath_RelativeDistanceCalculator_Segment* GetDefaultObj()
	{
		return GetDefaultObjImpl<UBFGNetworkPath_RelativeDistanceCalculator_Segment>();
	}
};
static_assert(alignof(UBFGNetworkPath_RelativeDistanceCalculator_Segment) == 0x000008, "Wrong alignment on UBFGNetworkPath_RelativeDistanceCalculator_Segment");
static_assert(sizeof(UBFGNetworkPath_RelativeDistanceCalculator_Segment) == 0x000070, "Wrong size on UBFGNetworkPath_RelativeDistanceCalculator_Segment");
static_assert(offsetof(UBFGNetworkPath_RelativeDistanceCalculator_Segment, M_pCurrentPath) == 0x000050, "Member 'UBFGNetworkPath_RelativeDistanceCalculator_Segment::M_pCurrentPath' has a wrong offset!");
static_assert(offsetof(UBFGNetworkPath_RelativeDistanceCalculator_Segment, M_iDirection) == 0x000058, "Member 'UBFGNetworkPath_RelativeDistanceCalculator_Segment::M_iDirection' has a wrong offset!");
static_assert(offsetof(UBFGNetworkPath_RelativeDistanceCalculator_Segment, M_pNextPath) == 0x000060, "Member 'UBFGNetworkPath_RelativeDistanceCalculator_Segment::M_pNextPath' has a wrong offset!");
static_assert(offsetof(UBFGNetworkPath_RelativeDistanceCalculator_Segment, M_iNextDirection) == 0x000068, "Member 'UBFGNetworkPath_RelativeDistanceCalculator_Segment::M_iNextDirection' has a wrong offset!");

// Class BFGCore.BFGNetworkPath_RelativeDistanceCalculator_StartSegment
// 0x0000 (0x0070 - 0x0070)
class UBFGNetworkPath_RelativeDistanceCalculator_StartSegment final : public UBFGNetworkPath_RelativeDistanceCalculator_Segment
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"BFGNetworkPath_RelativeDistanceCalculator_StartSegment">();
	}
	static class UBFGNetworkPath_RelativeDistanceCalculator_StartSegment* GetDefaultObj()
	{
		return GetDefaultObjImpl<UBFGNetworkPath_RelativeDistanceCalculator_StartSegment>();
	}
};
static_assert(alignof(UBFGNetworkPath_RelativeDistanceCalculator_StartSegment) == 0x000008, "Wrong alignment on UBFGNetworkPath_RelativeDistanceCalculator_StartSegment");
static_assert(sizeof(UBFGNetworkPath_RelativeDistanceCalculator_StartSegment) == 0x000070, "Wrong size on UBFGNetworkPath_RelativeDistanceCalculator_StartSegment");

// Class BFGCore.BFGActorComponent_FallDamage
// 0x0058 (0x0180 - 0x0128)
class UBFGActorComponent_FallDamage final : public UActorComponent
{
public:
	UMulticastDelegateProperty_                   OnTakeFallDamage;                                  // 0x0128(0x0018)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	float                                         M_fFallDamageMinimumSpeed;                         // 0x0140(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         M_fFallDamageLethalHeight;                         // 0x0144(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         M_fFallDamageMinimumHeight;                        // 0x0148(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_14C[0xC];                                      // 0x014C(0x000C)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<class AActor*>                         M_aListOfHitActorsDuringFall;                      // 0x0158(0x0010)(ZeroConstructor, Protected, NativeAccessSpecifierProtected)
	class UBFGActorComponent_CharacterPhysics*    M_pCharacterPhysics;                               // 0x0168(0x0008)(ExportObject, ZeroConstructor, Transient, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class USkeletalMeshComponent*                 M_pSkeletalMesh;                                   // 0x0170(0x0008)(ExportObject, ZeroConstructor, Transient, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class ABFGGameState*                          M_pGameState;                                      // 0x0178(0x0008)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)

public:
	void Actor_OnHit(class AActor* _pSelfActor, class AActor* _pOtherActor, const struct FVector& _vNormalImpulse, const struct FHitResult& _hit);

	bool GetIsFalling() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"BFGActorComponent_FallDamage">();
	}
	static class UBFGActorComponent_FallDamage* GetDefaultObj()
	{
		return GetDefaultObjImpl<UBFGActorComponent_FallDamage>();
	}
};
static_assert(alignof(UBFGActorComponent_FallDamage) == 0x000008, "Wrong alignment on UBFGActorComponent_FallDamage");
static_assert(sizeof(UBFGActorComponent_FallDamage) == 0x000180, "Wrong size on UBFGActorComponent_FallDamage");
static_assert(offsetof(UBFGActorComponent_FallDamage, OnTakeFallDamage) == 0x000128, "Member 'UBFGActorComponent_FallDamage::OnTakeFallDamage' has a wrong offset!");
static_assert(offsetof(UBFGActorComponent_FallDamage, M_fFallDamageMinimumSpeed) == 0x000140, "Member 'UBFGActorComponent_FallDamage::M_fFallDamageMinimumSpeed' has a wrong offset!");
static_assert(offsetof(UBFGActorComponent_FallDamage, M_fFallDamageLethalHeight) == 0x000144, "Member 'UBFGActorComponent_FallDamage::M_fFallDamageLethalHeight' has a wrong offset!");
static_assert(offsetof(UBFGActorComponent_FallDamage, M_fFallDamageMinimumHeight) == 0x000148, "Member 'UBFGActorComponent_FallDamage::M_fFallDamageMinimumHeight' has a wrong offset!");
static_assert(offsetof(UBFGActorComponent_FallDamage, M_aListOfHitActorsDuringFall) == 0x000158, "Member 'UBFGActorComponent_FallDamage::M_aListOfHitActorsDuringFall' has a wrong offset!");
static_assert(offsetof(UBFGActorComponent_FallDamage, M_pCharacterPhysics) == 0x000168, "Member 'UBFGActorComponent_FallDamage::M_pCharacterPhysics' has a wrong offset!");
static_assert(offsetof(UBFGActorComponent_FallDamage, M_pSkeletalMesh) == 0x000170, "Member 'UBFGActorComponent_FallDamage::M_pSkeletalMesh' has a wrong offset!");
static_assert(offsetof(UBFGActorComponent_FallDamage, M_pGameState) == 0x000178, "Member 'UBFGActorComponent_FallDamage::M_pGameState' has a wrong offset!");

// Class BFGCore.BFGQuest_ElementObjectiveCustom
// 0x0008 (0x0300 - 0x02F8)
class UBFGQuest_ElementObjectiveCustom : public UBFGQuest_Element
{
public:
	uint8                                         Pad_2F8[0x8];                                      // 0x02F8(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"BFGQuest_ElementObjectiveCustom">();
	}
	static class UBFGQuest_ElementObjectiveCustom* GetDefaultObj()
	{
		return GetDefaultObjImpl<UBFGQuest_ElementObjectiveCustom>();
	}
};
static_assert(alignof(UBFGQuest_ElementObjectiveCustom) == 0x000008, "Wrong alignment on UBFGQuest_ElementObjectiveCustom");
static_assert(sizeof(UBFGQuest_ElementObjectiveCustom) == 0x000300, "Wrong size on UBFGQuest_ElementObjectiveCustom");

// Class BFGCore.BFGQuest_ElementDefend
// 0x01E8 (0x04E8 - 0x0300)
class UBFGQuest_ElementDefend final : public UBFGQuest_ElementObjectiveCustom
{
public:
	UMulticastDelegateProperty_                   M_OnWaveStartedEvent;                              // 0x0300(0x0018)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	UMulticastDelegateProperty_                   M_OnHealthChangedEvent;                            // 0x0318(0x0018)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	TArray<struct FBFGQuest_ElementDefend_Defendee> M_aDefendees;                                      // 0x0330(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, ContainsInstancedReference, Protected, NativeAccessSpecifierProtected)
	struct FBFGQuest_ElementDefend_Attackers      M_attackers;                                       // 0x0340(0x0088)(Edit, BlueprintVisible, BlueprintReadOnly, DisableEditOnInstance, Protected, NativeAccessSpecifierProtected)
	EBFGQuest_ElementDefend_Type                  M_eVictoryCondition;                               // 0x03C8(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_3C9[0x7];                                      // 0x03C9(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	struct FTimespan                              M_timerDuration;                                   // 0x03D0(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	struct FBFGQuest_Failure                      M_infoDefendFail;                                  // 0x03D8(0x0088)(Edit, DisableEditOnInstance, Protected, NativeAccessSpecifierProtected)
	bool                                          M_bInfoDefendFailUpdated;                          // 0x0460(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_461[0x7];                                      // 0x0461(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	TSoftObjectPtr<class UBFGDataAsset_NewspaperInfo> M_softDefendFailNewspaper;                         // 0x0468(0x0028)(Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class FText                                   M_strDefendFailReason;                             // 0x0490(0x0018)(Protected, NativeAccessSpecifierProtected)
	TSoftClassPtr<class UClass>                   M_softDefendFailNarrativeSequence;                 // 0x04A8(0x0028)(Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_4D0[0x8];                                      // 0x04D0(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	class UBFGQuest_Timer*                        M_pQuestTimer;                                     // 0x04D8(0x0008)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UBFGVariable*                           M_pWaveCounterVariable;                            // 0x04E0(0x0008)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"BFGQuest_ElementDefend">();
	}
	static class UBFGQuest_ElementDefend* GetDefaultObj()
	{
		return GetDefaultObjImpl<UBFGQuest_ElementDefend>();
	}
};
static_assert(alignof(UBFGQuest_ElementDefend) == 0x000008, "Wrong alignment on UBFGQuest_ElementDefend");
static_assert(sizeof(UBFGQuest_ElementDefend) == 0x0004E8, "Wrong size on UBFGQuest_ElementDefend");
static_assert(offsetof(UBFGQuest_ElementDefend, M_OnWaveStartedEvent) == 0x000300, "Member 'UBFGQuest_ElementDefend::M_OnWaveStartedEvent' has a wrong offset!");
static_assert(offsetof(UBFGQuest_ElementDefend, M_OnHealthChangedEvent) == 0x000318, "Member 'UBFGQuest_ElementDefend::M_OnHealthChangedEvent' has a wrong offset!");
static_assert(offsetof(UBFGQuest_ElementDefend, M_aDefendees) == 0x000330, "Member 'UBFGQuest_ElementDefend::M_aDefendees' has a wrong offset!");
static_assert(offsetof(UBFGQuest_ElementDefend, M_attackers) == 0x000340, "Member 'UBFGQuest_ElementDefend::M_attackers' has a wrong offset!");
static_assert(offsetof(UBFGQuest_ElementDefend, M_eVictoryCondition) == 0x0003C8, "Member 'UBFGQuest_ElementDefend::M_eVictoryCondition' has a wrong offset!");
static_assert(offsetof(UBFGQuest_ElementDefend, M_timerDuration) == 0x0003D0, "Member 'UBFGQuest_ElementDefend::M_timerDuration' has a wrong offset!");
static_assert(offsetof(UBFGQuest_ElementDefend, M_infoDefendFail) == 0x0003D8, "Member 'UBFGQuest_ElementDefend::M_infoDefendFail' has a wrong offset!");
static_assert(offsetof(UBFGQuest_ElementDefend, M_bInfoDefendFailUpdated) == 0x000460, "Member 'UBFGQuest_ElementDefend::M_bInfoDefendFailUpdated' has a wrong offset!");
static_assert(offsetof(UBFGQuest_ElementDefend, M_softDefendFailNewspaper) == 0x000468, "Member 'UBFGQuest_ElementDefend::M_softDefendFailNewspaper' has a wrong offset!");
static_assert(offsetof(UBFGQuest_ElementDefend, M_strDefendFailReason) == 0x000490, "Member 'UBFGQuest_ElementDefend::M_strDefendFailReason' has a wrong offset!");
static_assert(offsetof(UBFGQuest_ElementDefend, M_softDefendFailNarrativeSequence) == 0x0004A8, "Member 'UBFGQuest_ElementDefend::M_softDefendFailNarrativeSequence' has a wrong offset!");
static_assert(offsetof(UBFGQuest_ElementDefend, M_pQuestTimer) == 0x0004D8, "Member 'UBFGQuest_ElementDefend::M_pQuestTimer' has a wrong offset!");
static_assert(offsetof(UBFGQuest_ElementDefend, M_pWaveCounterVariable) == 0x0004E0, "Member 'UBFGQuest_ElementDefend::M_pWaveCounterVariable' has a wrong offset!");

// Class BFGCore.BFGEventTest_CanAcceptMainMissionOrChallengeQuest
// 0x0000 (0x0028 - 0x0028)
class UBFGEventTest_CanAcceptMainMissionOrChallengeQuest final : public UBFGEventTest
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"BFGEventTest_CanAcceptMainMissionOrChallengeQuest">();
	}
	static class UBFGEventTest_CanAcceptMainMissionOrChallengeQuest* GetDefaultObj()
	{
		return GetDefaultObjImpl<UBFGEventTest_CanAcceptMainMissionOrChallengeQuest>();
	}
};
static_assert(alignof(UBFGEventTest_CanAcceptMainMissionOrChallengeQuest) == 0x000008, "Wrong alignment on UBFGEventTest_CanAcceptMainMissionOrChallengeQuest");
static_assert(sizeof(UBFGEventTest_CanAcceptMainMissionOrChallengeQuest) == 0x000028, "Wrong size on UBFGEventTest_CanAcceptMainMissionOrChallengeQuest");

// Class BFGCore.BFGActorComponent_FocusMode
// 0x0090 (0x01B8 - 0x0128)
class UBFGActorComponent_FocusMode final : public UActorComponent
{
public:
	class ACharacter*                             M_pOwningCharacter;                                // 0x0128(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class ABFGPlayerCharacter*                    M_pPlayerCharacter;                                // 0x0130(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UBFGActorComponent_TargetSystem*        M_pTargetSystemComponent;                          // 0x0138(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UBFGActorComponent_EquipmentManager*    M_pEquipmentManager;                               // 0x0140(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UBFGActorComponent_MentalAbilities*     M_pMentalAbilities;                                // 0x0148(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UBFGActorComponent_JetpackPilot*        M_pJetpackPilotComponent;                          // 0x0150(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UBFGActorComponent_CameraHandle*        M_pCameraHandle;                                   // 0x0158(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_160[0x8];                                      // 0x0160(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	class AActor*                                 M_pSnapToTarget;                                   // 0x0168(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UCurveFloat*                            M_pFocusFOVInCurve;                                // 0x0170(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UCurveFloat*                            M_pFocusFOVOutCurve;                               // 0x0178(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UCurveFloat*                            M_pCameraSpeedCoefCurveOverride;                   // 0x0180(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          M_bResetCameraOnExit;                              // 0x0188(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_189[0x3];                                      // 0x0189(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         M_fAutoLockRadius;                                 // 0x018C(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         M_fAutoLockMaxAngleToTestDistance;                 // 0x0190(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         M_fAutoLockChangeTargetCooldown;                   // 0x0194(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         M_fAutoLockChangeTargetThreshold;                  // 0x0198(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         M_fFirstAutoLockMaxAngle;                          // 0x019C(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_1A0[0x8];                                      // 0x01A0(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	class UBFGActorComponent_LockOnTarget*        M_pCurrentAutoLockTarget;                          // 0x01A8(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_1B0[0x8];                                      // 0x01B0(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"BFGActorComponent_FocusMode">();
	}
	static class UBFGActorComponent_FocusMode* GetDefaultObj()
	{
		return GetDefaultObjImpl<UBFGActorComponent_FocusMode>();
	}
};
static_assert(alignof(UBFGActorComponent_FocusMode) == 0x000008, "Wrong alignment on UBFGActorComponent_FocusMode");
static_assert(sizeof(UBFGActorComponent_FocusMode) == 0x0001B8, "Wrong size on UBFGActorComponent_FocusMode");
static_assert(offsetof(UBFGActorComponent_FocusMode, M_pOwningCharacter) == 0x000128, "Member 'UBFGActorComponent_FocusMode::M_pOwningCharacter' has a wrong offset!");
static_assert(offsetof(UBFGActorComponent_FocusMode, M_pPlayerCharacter) == 0x000130, "Member 'UBFGActorComponent_FocusMode::M_pPlayerCharacter' has a wrong offset!");
static_assert(offsetof(UBFGActorComponent_FocusMode, M_pTargetSystemComponent) == 0x000138, "Member 'UBFGActorComponent_FocusMode::M_pTargetSystemComponent' has a wrong offset!");
static_assert(offsetof(UBFGActorComponent_FocusMode, M_pEquipmentManager) == 0x000140, "Member 'UBFGActorComponent_FocusMode::M_pEquipmentManager' has a wrong offset!");
static_assert(offsetof(UBFGActorComponent_FocusMode, M_pMentalAbilities) == 0x000148, "Member 'UBFGActorComponent_FocusMode::M_pMentalAbilities' has a wrong offset!");
static_assert(offsetof(UBFGActorComponent_FocusMode, M_pJetpackPilotComponent) == 0x000150, "Member 'UBFGActorComponent_FocusMode::M_pJetpackPilotComponent' has a wrong offset!");
static_assert(offsetof(UBFGActorComponent_FocusMode, M_pCameraHandle) == 0x000158, "Member 'UBFGActorComponent_FocusMode::M_pCameraHandle' has a wrong offset!");
static_assert(offsetof(UBFGActorComponent_FocusMode, M_pSnapToTarget) == 0x000168, "Member 'UBFGActorComponent_FocusMode::M_pSnapToTarget' has a wrong offset!");
static_assert(offsetof(UBFGActorComponent_FocusMode, M_pFocusFOVInCurve) == 0x000170, "Member 'UBFGActorComponent_FocusMode::M_pFocusFOVInCurve' has a wrong offset!");
static_assert(offsetof(UBFGActorComponent_FocusMode, M_pFocusFOVOutCurve) == 0x000178, "Member 'UBFGActorComponent_FocusMode::M_pFocusFOVOutCurve' has a wrong offset!");
static_assert(offsetof(UBFGActorComponent_FocusMode, M_pCameraSpeedCoefCurveOverride) == 0x000180, "Member 'UBFGActorComponent_FocusMode::M_pCameraSpeedCoefCurveOverride' has a wrong offset!");
static_assert(offsetof(UBFGActorComponent_FocusMode, M_bResetCameraOnExit) == 0x000188, "Member 'UBFGActorComponent_FocusMode::M_bResetCameraOnExit' has a wrong offset!");
static_assert(offsetof(UBFGActorComponent_FocusMode, M_fAutoLockRadius) == 0x00018C, "Member 'UBFGActorComponent_FocusMode::M_fAutoLockRadius' has a wrong offset!");
static_assert(offsetof(UBFGActorComponent_FocusMode, M_fAutoLockMaxAngleToTestDistance) == 0x000190, "Member 'UBFGActorComponent_FocusMode::M_fAutoLockMaxAngleToTestDistance' has a wrong offset!");
static_assert(offsetof(UBFGActorComponent_FocusMode, M_fAutoLockChangeTargetCooldown) == 0x000194, "Member 'UBFGActorComponent_FocusMode::M_fAutoLockChangeTargetCooldown' has a wrong offset!");
static_assert(offsetof(UBFGActorComponent_FocusMode, M_fAutoLockChangeTargetThreshold) == 0x000198, "Member 'UBFGActorComponent_FocusMode::M_fAutoLockChangeTargetThreshold' has a wrong offset!");
static_assert(offsetof(UBFGActorComponent_FocusMode, M_fFirstAutoLockMaxAngle) == 0x00019C, "Member 'UBFGActorComponent_FocusMode::M_fFirstAutoLockMaxAngle' has a wrong offset!");
static_assert(offsetof(UBFGActorComponent_FocusMode, M_pCurrentAutoLockTarget) == 0x0001A8, "Member 'UBFGActorComponent_FocusMode::M_pCurrentAutoLockTarget' has a wrong offset!");

// Class BFGCore.BFGActorComponent_GameplayEffectResponses
// 0x0028 (0x0150 - 0x0128)
class UBFGActorComponent_GameplayEffectResponses final : public UActorComponent
{
public:
	TArray<struct FSoftClassPath>                 M_aEffectResponseClasses;                          // 0x0128(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Protected, NativeAccessSpecifierProtected)
	TArray<class UBFGGameplayEffectResponse*>     M_apEffectResponses;                               // 0x0138(0x0010)(ZeroConstructor, Transient, Protected, NativeAccessSpecifierProtected)
	class UBFGActorComponent_GameplayEffectTags*  M_pOwnerEffectTags;                                // 0x0148(0x0008)(ExportObject, ZeroConstructor, Transient, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)

public:
	bool HasActiveResponseOfType(TSubclassOf<class UBFGGameplayEffectResponse> _pClass) const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"BFGActorComponent_GameplayEffectResponses">();
	}
	static class UBFGActorComponent_GameplayEffectResponses* GetDefaultObj()
	{
		return GetDefaultObjImpl<UBFGActorComponent_GameplayEffectResponses>();
	}
};
static_assert(alignof(UBFGActorComponent_GameplayEffectResponses) == 0x000008, "Wrong alignment on UBFGActorComponent_GameplayEffectResponses");
static_assert(sizeof(UBFGActorComponent_GameplayEffectResponses) == 0x000150, "Wrong size on UBFGActorComponent_GameplayEffectResponses");
static_assert(offsetof(UBFGActorComponent_GameplayEffectResponses, M_aEffectResponseClasses) == 0x000128, "Member 'UBFGActorComponent_GameplayEffectResponses::M_aEffectResponseClasses' has a wrong offset!");
static_assert(offsetof(UBFGActorComponent_GameplayEffectResponses, M_apEffectResponses) == 0x000138, "Member 'UBFGActorComponent_GameplayEffectResponses::M_apEffectResponses' has a wrong offset!");
static_assert(offsetof(UBFGActorComponent_GameplayEffectResponses, M_pOwnerEffectTags) == 0x000148, "Member 'UBFGActorComponent_GameplayEffectResponses::M_pOwnerEffectTags' has a wrong offset!");

// Class BFGCore.BFGActorComponent_HumanoidStats
// 0x0008 (0x0190 - 0x0188)
class UBFGActorComponent_HumanoidStats final : public UBFGActorComponent_CharacterStats
{
public:
	class UBFGActorStat_Bool*                     M_pHasBrain;                                       // 0x0188(0x0008)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)

public:
	class UBFGActorStat_Bool* GetHasBrainStat() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"BFGActorComponent_HumanoidStats">();
	}
	static class UBFGActorComponent_HumanoidStats* GetDefaultObj()
	{
		return GetDefaultObjImpl<UBFGActorComponent_HumanoidStats>();
	}
};
static_assert(alignof(UBFGActorComponent_HumanoidStats) == 0x000008, "Wrong alignment on UBFGActorComponent_HumanoidStats");
static_assert(sizeof(UBFGActorComponent_HumanoidStats) == 0x000190, "Wrong size on UBFGActorComponent_HumanoidStats");
static_assert(offsetof(UBFGActorComponent_HumanoidStats, M_pHasBrain) == 0x000188, "Member 'UBFGActorComponent_HumanoidStats::M_pHasBrain' has a wrong offset!");

// Class BFGCore.BFGQuest_ElementLocateHint
// 0x0048 (0x0340 - 0x02F8)
class UBFGQuest_ElementLocateHint final : public UBFGQuest_Element
{
public:
	UMulticastDelegateProperty_                   M_onHintUsed;                                      // 0x02F8(0x0018)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	TArray<struct FBFGQuest_ElementLocateHint_Layer> M_aHintLayers;                                     // 0x0310(0x0010)(Edit, ZeroConstructor, DisableEditOnInstance, ContainsInstancedReference, Protected, NativeAccessSpecifierProtected)
	EBFGQuest_ElementLocateHint_Mode              M_objectiveMode;                                   // 0x0320(0x0001)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_321[0x7];                                      // 0x0321(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<struct FBFGQuest_ElementLocateHint_LayerRuntime> M_aRuntimeLayers;                                  // 0x0328(0x0010)(ZeroConstructor, Transient, Protected, NativeAccessSpecifierProtected)
	class UBFGVariable*                           M_pProgressVariable;                               // 0x0338(0x0008)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"BFGQuest_ElementLocateHint">();
	}
	static class UBFGQuest_ElementLocateHint* GetDefaultObj()
	{
		return GetDefaultObjImpl<UBFGQuest_ElementLocateHint>();
	}
};
static_assert(alignof(UBFGQuest_ElementLocateHint) == 0x000008, "Wrong alignment on UBFGQuest_ElementLocateHint");
static_assert(sizeof(UBFGQuest_ElementLocateHint) == 0x000340, "Wrong size on UBFGQuest_ElementLocateHint");
static_assert(offsetof(UBFGQuest_ElementLocateHint, M_onHintUsed) == 0x0002F8, "Member 'UBFGQuest_ElementLocateHint::M_onHintUsed' has a wrong offset!");
static_assert(offsetof(UBFGQuest_ElementLocateHint, M_aHintLayers) == 0x000310, "Member 'UBFGQuest_ElementLocateHint::M_aHintLayers' has a wrong offset!");
static_assert(offsetof(UBFGQuest_ElementLocateHint, M_objectiveMode) == 0x000320, "Member 'UBFGQuest_ElementLocateHint::M_objectiveMode' has a wrong offset!");
static_assert(offsetof(UBFGQuest_ElementLocateHint, M_aRuntimeLayers) == 0x000328, "Member 'UBFGQuest_ElementLocateHint::M_aRuntimeLayers' has a wrong offset!");
static_assert(offsetof(UBFGQuest_ElementLocateHint, M_pProgressVariable) == 0x000338, "Member 'UBFGQuest_ElementLocateHint::M_pProgressVariable' has a wrong offset!");

// Class BFGCore.BFGTaskNode_Boss_ActivateRBPWreck
// 0x0010 (0x00B0 - 0x00A0)
class UBFGTaskNode_Boss_ActivateRBPWreck final : public UBFGTaskNode_BossBase
{
public:
	uint8                                         Pad_A0[0x10];                                      // 0x00A0(0x0010)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"BFGTaskNode_Boss_ActivateRBPWreck">();
	}
	static class UBFGTaskNode_Boss_ActivateRBPWreck* GetDefaultObj()
	{
		return GetDefaultObjImpl<UBFGTaskNode_Boss_ActivateRBPWreck>();
	}
};
static_assert(alignof(UBFGTaskNode_Boss_ActivateRBPWreck) == 0x000008, "Wrong alignment on UBFGTaskNode_Boss_ActivateRBPWreck");
static_assert(sizeof(UBFGTaskNode_Boss_ActivateRBPWreck) == 0x0000B0, "Wrong size on UBFGTaskNode_Boss_ActivateRBPWreck");

// Class BFGCore.BFGEventTest_SaveSystemIdle
// 0x0000 (0x0028 - 0x0028)
class UBFGEventTest_SaveSystemIdle final : public UBFGEventTest
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"BFGEventTest_SaveSystemIdle">();
	}
	static class UBFGEventTest_SaveSystemIdle* GetDefaultObj()
	{
		return GetDefaultObjImpl<UBFGEventTest_SaveSystemIdle>();
	}
};
static_assert(alignof(UBFGEventTest_SaveSystemIdle) == 0x000008, "Wrong alignment on UBFGEventTest_SaveSystemIdle");
static_assert(sizeof(UBFGEventTest_SaveSystemIdle) == 0x000028, "Wrong size on UBFGEventTest_SaveSystemIdle");

// Class BFGCore.BFGActorComponent_InputActions
// 0x0080 (0x01A8 - 0x0128)
class UBFGActorComponent_InputActions final : public UActorComponent
{
public:
	uint8                                         Pad_128[0x8];                                      // 0x0128(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	class UWorld*                                 M_pCustomWorldPointer;                             // 0x0130(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TArray<class UBFGInputAction*>                M_aCurrentActions;                                 // 0x0138(0x0010)(ZeroConstructor, Transient, Protected, NativeAccessSpecifierProtected)
	TArray<class UBFGInputAxis*>                  M_aCurrentAxes;                                    // 0x0148(0x0010)(ZeroConstructor, Transient, Protected, NativeAccessSpecifierProtected)
	EInputSchemeIdentifier                        M_eCurrentInputSchemeType;                         // 0x0158(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_159[0x7];                                      // 0x0159(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	class UBFGInputComponent*                     M_pProcessingInputComponent;                       // 0x0160(0x0008)(ExportObject, ZeroConstructor, Transient, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UBFGInputScheme*                        M_pNextInputSchemeOverride;                        // 0x0168(0x0008)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UBFGInputScheme*                        M_pInputSchemeOverride;                            // 0x0170(0x0008)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          M_bCacheRefreshValidated;                          // 0x0178(0x0001)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_179[0x3];                                      // 0x0179(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	int32                                         M_iInputDeviceType;                                // 0x017C(0x0004)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_180[0x18];                                     // 0x0180(0x0018)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<EBFGInputLockGroups>                   M_aLockedGroups;                                   // 0x0198(0x0010)(ZeroConstructor, Transient, Protected, NativeAccessSpecifierProtected)

public:
	void EnableInput(bool _bEnable);
	void IncrementScheme();
	bool IsLastInputGamepad();
	void RefreshCache();
	void RefreshCacheFromCallback(int32 _iDunnoWhat);
	void SetCurrentInputSchemeIdentifier(EInputSchemeIdentifier _eIdentifier);

	TArray<class UBFGInputAction*> FindInputActionsMatchingPattern(const struct FBFGInputPattern& _rPattern, bool _bOnlyKeyAndState) const;
	TArray<class UBFGInputAction*> FindInputActionsMatchingPatternByKey(const struct FBFGInputPattern& _rPattern, bool _bOnlyKey) const;
	TArray<class UBFGInputAction*> FindInputActionsMatchingPatternElement(const struct FBFGInputPatternElement& _rPatternElement, bool _bOnlyKeyAndState) const;
	class UBFGInputScheme* GetCurrentInputScheme() const;
	class ACharacter* TryGetCharacterOwner() const;
	class ABFGGameState* TryGetGameState() const;
	class APawn* TryGetPawnOwner() const;
	class ABFGPlayerController* TryGetPlayerControllerOwner() const;
	class ABFGPlayerCharacter* TryGetPlayerOwner() const;
	class ABFGPlayerUFO* TryGetUFOOwner() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"BFGActorComponent_InputActions">();
	}
	static class UBFGActorComponent_InputActions* GetDefaultObj()
	{
		return GetDefaultObjImpl<UBFGActorComponent_InputActions>();
	}
};
static_assert(alignof(UBFGActorComponent_InputActions) == 0x000008, "Wrong alignment on UBFGActorComponent_InputActions");
static_assert(sizeof(UBFGActorComponent_InputActions) == 0x0001A8, "Wrong size on UBFGActorComponent_InputActions");
static_assert(offsetof(UBFGActorComponent_InputActions, M_pCustomWorldPointer) == 0x000130, "Member 'UBFGActorComponent_InputActions::M_pCustomWorldPointer' has a wrong offset!");
static_assert(offsetof(UBFGActorComponent_InputActions, M_aCurrentActions) == 0x000138, "Member 'UBFGActorComponent_InputActions::M_aCurrentActions' has a wrong offset!");
static_assert(offsetof(UBFGActorComponent_InputActions, M_aCurrentAxes) == 0x000148, "Member 'UBFGActorComponent_InputActions::M_aCurrentAxes' has a wrong offset!");
static_assert(offsetof(UBFGActorComponent_InputActions, M_eCurrentInputSchemeType) == 0x000158, "Member 'UBFGActorComponent_InputActions::M_eCurrentInputSchemeType' has a wrong offset!");
static_assert(offsetof(UBFGActorComponent_InputActions, M_pProcessingInputComponent) == 0x000160, "Member 'UBFGActorComponent_InputActions::M_pProcessingInputComponent' has a wrong offset!");
static_assert(offsetof(UBFGActorComponent_InputActions, M_pNextInputSchemeOverride) == 0x000168, "Member 'UBFGActorComponent_InputActions::M_pNextInputSchemeOverride' has a wrong offset!");
static_assert(offsetof(UBFGActorComponent_InputActions, M_pInputSchemeOverride) == 0x000170, "Member 'UBFGActorComponent_InputActions::M_pInputSchemeOverride' has a wrong offset!");
static_assert(offsetof(UBFGActorComponent_InputActions, M_bCacheRefreshValidated) == 0x000178, "Member 'UBFGActorComponent_InputActions::M_bCacheRefreshValidated' has a wrong offset!");
static_assert(offsetof(UBFGActorComponent_InputActions, M_iInputDeviceType) == 0x00017C, "Member 'UBFGActorComponent_InputActions::M_iInputDeviceType' has a wrong offset!");
static_assert(offsetof(UBFGActorComponent_InputActions, M_aLockedGroups) == 0x000198, "Member 'UBFGActorComponent_InputActions::M_aLockedGroups' has a wrong offset!");

// Class BFGCore.BFGActorComponent_InteractableCharacterStats
// 0x0010 (0x0198 - 0x0188)
class UBFGActorComponent_InteractableCharacterStats final : public UBFGActorComponent_CharacterStats
{
public:
	class UBFGActorStat_Bool*                     M_pIsInteractedWith;                               // 0x0188(0x0008)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UBFGActorStat_Bool*                     M_pCanBeInteractedWith;                            // 0x0190(0x0008)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)

public:
	class UBFGActorStat_Bool* GetCanBeInteractedWith() const;
	class UBFGActorStat_Bool* GetIsInteractedWithStat() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"BFGActorComponent_InteractableCharacterStats">();
	}
	static class UBFGActorComponent_InteractableCharacterStats* GetDefaultObj()
	{
		return GetDefaultObjImpl<UBFGActorComponent_InteractableCharacterStats>();
	}
};
static_assert(alignof(UBFGActorComponent_InteractableCharacterStats) == 0x000008, "Wrong alignment on UBFGActorComponent_InteractableCharacterStats");
static_assert(sizeof(UBFGActorComponent_InteractableCharacterStats) == 0x000198, "Wrong size on UBFGActorComponent_InteractableCharacterStats");
static_assert(offsetof(UBFGActorComponent_InteractableCharacterStats, M_pIsInteractedWith) == 0x000188, "Member 'UBFGActorComponent_InteractableCharacterStats::M_pIsInteractedWith' has a wrong offset!");
static_assert(offsetof(UBFGActorComponent_InteractableCharacterStats, M_pCanBeInteractedWith) == 0x000190, "Member 'UBFGActorComponent_InteractableCharacterStats::M_pCanBeInteractedWith' has a wrong offset!");

// Class BFGCore.BFGActorComponent_JetpackPilot
// 0x0128 (0x0250 - 0x0128)
class UBFGActorComponent_JetpackPilot final : public UActorComponent
{
public:
	bool                                          M_bIsJetpackActive;                                // 0x0128(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_129[0xF];                                      // 0x0129(0x000F)(Fixing Size After Last Property [ Dumper-7 ])
	class UBFGDataAsset_JetpackParams*            M_pJetpackParams;                                  // 0x0138(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_140[0x8];                                      // 0x0140(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	class ACharacter*                             M_pOwningCharacter;                                // 0x0148(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UBFGActorComponent_PlayerCharacterMovement* M_pPlayerMovementComponent;                        // 0x0150(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UBFGActorComponent_CameraHandle*        M_pCameraHandleComponent;                          // 0x0158(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UBFGActorComponent_MentalAbilities*     M_pMentalAbilities;                                // 0x0160(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_168[0x20];                                     // 0x0168(0x0020)(Fixing Size After Last Property [ Dumper-7 ])
	UMulticastDelegateProperty_                   OnJetpackDeployed;                                 // 0x0188(0x0018)(ZeroConstructor, InstancedReference, BlueprintAssignable, Protected, NativeAccessSpecifierProtected)
	UMulticastDelegateProperty_                   OnJetpackOutOfFuel;                                // 0x01A0(0x0018)(ZeroConstructor, InstancedReference, BlueprintAssignable, Protected, NativeAccessSpecifierProtected)
	UMulticastDelegateProperty_                   OnThrottlePressed;                                 // 0x01B8(0x0018)(ZeroConstructor, InstancedReference, BlueprintAssignable, Protected, NativeAccessSpecifierProtected)
	UMulticastDelegateProperty_                   OnThrottleReleased;                                // 0x01D0(0x0018)(ZeroConstructor, InstancedReference, BlueprintAssignable, Protected, NativeAccessSpecifierProtected)
	UMulticastDelegateProperty_                   OnTickWhileThrottlePressed;                        // 0x01E8(0x0018)(ZeroConstructor, InstancedReference, BlueprintAssignable, Protected, NativeAccessSpecifierProtected)
	UMulticastDelegateProperty_                   OnSkateStart;                                      // 0x0200(0x0018)(ZeroConstructor, InstancedReference, BlueprintAssignable, Protected, NativeAccessSpecifierProtected)
	UMulticastDelegateProperty_                   OnSkateStop;                                       // 0x0218(0x0018)(ZeroConstructor, InstancedReference, BlueprintAssignable, Protected, NativeAccessSpecifierProtected)
	struct FGameplayTag                           M_tUpgradeTagSuprakineticAntigravThrustEnhancer;   // 0x0230(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, DisableEditOnInstance, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         M_fSuprakineticAntigravThrustEnhancerFuelConsumption; // 0x0238(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	struct FGameplayTag                           M_tUpgradeTagSuperchargedSuprakinetics;            // 0x023C(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, DisableEditOnInstance, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         M_fSuperchargedSuprakineticsFuelConsumption;       // 0x0244(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	struct FGameplayTag                           M_tUpgradeTagZeroFrictionThrustEnhancerEnhancer;   // 0x0248(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, DisableEditOnInstance, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)

public:
	void AddFuel(float _fAmount);
	void BFGActorComponent_Jetpack_Event__DelegateSignature(class UBFGActorComponent_JetpackPilot* _pJetpackComponent);
	void BlockFuel();
	void ConsumeFuel(float _fAmount);
	void DisableJetpack();
	void DisableSkate();
	void EnableJetpack();
	void EnableSkate();
	void PressHover();
	void PressSkate();
	void PressThrottle();
	void ReleaseHover();
	void ReleaseSkate();
	void ReleaseThrottle();
	void UnblockFuel();

	float GetCurrentFuel() const;
	float GetCurrentFuelRatio() const;
	bool GetHoverActive() const;
	bool GetJetpackDeployed() const;
	bool GetSkateActive() const;
	bool GetThrottleActive() const;
	bool IsJetpackEnabled() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"BFGActorComponent_JetpackPilot">();
	}
	static class UBFGActorComponent_JetpackPilot* GetDefaultObj()
	{
		return GetDefaultObjImpl<UBFGActorComponent_JetpackPilot>();
	}
};
static_assert(alignof(UBFGActorComponent_JetpackPilot) == 0x000008, "Wrong alignment on UBFGActorComponent_JetpackPilot");
static_assert(sizeof(UBFGActorComponent_JetpackPilot) == 0x000250, "Wrong size on UBFGActorComponent_JetpackPilot");
static_assert(offsetof(UBFGActorComponent_JetpackPilot, M_bIsJetpackActive) == 0x000128, "Member 'UBFGActorComponent_JetpackPilot::M_bIsJetpackActive' has a wrong offset!");
static_assert(offsetof(UBFGActorComponent_JetpackPilot, M_pJetpackParams) == 0x000138, "Member 'UBFGActorComponent_JetpackPilot::M_pJetpackParams' has a wrong offset!");
static_assert(offsetof(UBFGActorComponent_JetpackPilot, M_pOwningCharacter) == 0x000148, "Member 'UBFGActorComponent_JetpackPilot::M_pOwningCharacter' has a wrong offset!");
static_assert(offsetof(UBFGActorComponent_JetpackPilot, M_pPlayerMovementComponent) == 0x000150, "Member 'UBFGActorComponent_JetpackPilot::M_pPlayerMovementComponent' has a wrong offset!");
static_assert(offsetof(UBFGActorComponent_JetpackPilot, M_pCameraHandleComponent) == 0x000158, "Member 'UBFGActorComponent_JetpackPilot::M_pCameraHandleComponent' has a wrong offset!");
static_assert(offsetof(UBFGActorComponent_JetpackPilot, M_pMentalAbilities) == 0x000160, "Member 'UBFGActorComponent_JetpackPilot::M_pMentalAbilities' has a wrong offset!");
static_assert(offsetof(UBFGActorComponent_JetpackPilot, OnJetpackDeployed) == 0x000188, "Member 'UBFGActorComponent_JetpackPilot::OnJetpackDeployed' has a wrong offset!");
static_assert(offsetof(UBFGActorComponent_JetpackPilot, OnJetpackOutOfFuel) == 0x0001A0, "Member 'UBFGActorComponent_JetpackPilot::OnJetpackOutOfFuel' has a wrong offset!");
static_assert(offsetof(UBFGActorComponent_JetpackPilot, OnThrottlePressed) == 0x0001B8, "Member 'UBFGActorComponent_JetpackPilot::OnThrottlePressed' has a wrong offset!");
static_assert(offsetof(UBFGActorComponent_JetpackPilot, OnThrottleReleased) == 0x0001D0, "Member 'UBFGActorComponent_JetpackPilot::OnThrottleReleased' has a wrong offset!");
static_assert(offsetof(UBFGActorComponent_JetpackPilot, OnTickWhileThrottlePressed) == 0x0001E8, "Member 'UBFGActorComponent_JetpackPilot::OnTickWhileThrottlePressed' has a wrong offset!");
static_assert(offsetof(UBFGActorComponent_JetpackPilot, OnSkateStart) == 0x000200, "Member 'UBFGActorComponent_JetpackPilot::OnSkateStart' has a wrong offset!");
static_assert(offsetof(UBFGActorComponent_JetpackPilot, OnSkateStop) == 0x000218, "Member 'UBFGActorComponent_JetpackPilot::OnSkateStop' has a wrong offset!");
static_assert(offsetof(UBFGActorComponent_JetpackPilot, M_tUpgradeTagSuprakineticAntigravThrustEnhancer) == 0x000230, "Member 'UBFGActorComponent_JetpackPilot::M_tUpgradeTagSuprakineticAntigravThrustEnhancer' has a wrong offset!");
static_assert(offsetof(UBFGActorComponent_JetpackPilot, M_fSuprakineticAntigravThrustEnhancerFuelConsumption) == 0x000238, "Member 'UBFGActorComponent_JetpackPilot::M_fSuprakineticAntigravThrustEnhancerFuelConsumption' has a wrong offset!");
static_assert(offsetof(UBFGActorComponent_JetpackPilot, M_tUpgradeTagSuperchargedSuprakinetics) == 0x00023C, "Member 'UBFGActorComponent_JetpackPilot::M_tUpgradeTagSuperchargedSuprakinetics' has a wrong offset!");
static_assert(offsetof(UBFGActorComponent_JetpackPilot, M_fSuperchargedSuprakineticsFuelConsumption) == 0x000244, "Member 'UBFGActorComponent_JetpackPilot::M_fSuperchargedSuprakineticsFuelConsumption' has a wrong offset!");
static_assert(offsetof(UBFGActorComponent_JetpackPilot, M_tUpgradeTagZeroFrictionThrustEnhancerEnhancer) == 0x000248, "Member 'UBFGActorComponent_JetpackPilot::M_tUpgradeTagZeroFrictionThrustEnhancerEnhancer' has a wrong offset!");

// Class BFGCore.BFGWidget_ChallengeEnd
// 0x0058 (0x0480 - 0x0428)
class UBFGWidget_ChallengeEnd final : public UBFGWidget_GenericDialog
{
public:
	class UBFGQuest_Challenge*                    M_pChallenge;                                      // 0x0428(0x0008)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FBFGChallengeInfo                      M_oChallengeInfo;                                  // 0x0430(0x0040)(BlueprintVisible, BlueprintReadOnly, NativeAccessSpecifierPublic)
	class UBFGQuest_Manager*                      M_pQuestManager;                                   // 0x0470(0x0008)(ExportObject, ZeroConstructor, Transient, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UObject*                                M_pContext;                                        // 0x0478(0x0008)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)

public:
	class UBFGQuest_Challenge* GetChallengeObject();
	void OnShowFail();
	void OnUpdateChallengeUI();
	void SetContext(class UObject* _pContext);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"BFGWidget_ChallengeEnd">();
	}
	static class UBFGWidget_ChallengeEnd* GetDefaultObj()
	{
		return GetDefaultObjImpl<UBFGWidget_ChallengeEnd>();
	}
};
static_assert(alignof(UBFGWidget_ChallengeEnd) == 0x000008, "Wrong alignment on UBFGWidget_ChallengeEnd");
static_assert(sizeof(UBFGWidget_ChallengeEnd) == 0x000480, "Wrong size on UBFGWidget_ChallengeEnd");
static_assert(offsetof(UBFGWidget_ChallengeEnd, M_pChallenge) == 0x000428, "Member 'UBFGWidget_ChallengeEnd::M_pChallenge' has a wrong offset!");
static_assert(offsetof(UBFGWidget_ChallengeEnd, M_oChallengeInfo) == 0x000430, "Member 'UBFGWidget_ChallengeEnd::M_oChallengeInfo' has a wrong offset!");
static_assert(offsetof(UBFGWidget_ChallengeEnd, M_pQuestManager) == 0x000470, "Member 'UBFGWidget_ChallengeEnd::M_pQuestManager' has a wrong offset!");
static_assert(offsetof(UBFGWidget_ChallengeEnd, M_pContext) == 0x000478, "Member 'UBFGWidget_ChallengeEnd::M_pContext' has a wrong offset!");

// Class BFGCore.BFGActorComponent_Levitate
// 0x0088 (0x01B0 - 0x0128)
class UBFGActorComponent_Levitate final : public UActorComponent
{
public:
	uint8                                         Pad_128[0x38];                                     // 0x0128(0x0038)(Fixing Size After Last Property [ Dumper-7 ])
	class UTimelineComponent*                     M_tTimelineComponent_Levitation_UP;                // 0x0160(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UTimelineComponent*                     M_tTimelineComponent_Levitation_DOWN;              // 0x0168(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_170[0x40];                                     // 0x0170(0x0040)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void BeginLevitation();
	void EndLevitation(bool _bForced);
	void ForceStopLevitationTimeline();
	void Timeline_Levitate_DOWN_FinishedCallback();
	void Timeline_Levitate_DOWN_Interpolation(float Val);
	void Timeline_Levitate_UP_FinishedCallback();
	void Timeline_Levitate_UP_Interpolation(float Val);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"BFGActorComponent_Levitate">();
	}
	static class UBFGActorComponent_Levitate* GetDefaultObj()
	{
		return GetDefaultObjImpl<UBFGActorComponent_Levitate>();
	}
};
static_assert(alignof(UBFGActorComponent_Levitate) == 0x000008, "Wrong alignment on UBFGActorComponent_Levitate");
static_assert(sizeof(UBFGActorComponent_Levitate) == 0x0001B0, "Wrong size on UBFGActorComponent_Levitate");
static_assert(offsetof(UBFGActorComponent_Levitate, M_tTimelineComponent_Levitation_UP) == 0x000160, "Member 'UBFGActorComponent_Levitate::M_tTimelineComponent_Levitation_UP' has a wrong offset!");
static_assert(offsetof(UBFGActorComponent_Levitate, M_tTimelineComponent_Levitation_DOWN) == 0x000168, "Member 'UBFGActorComponent_Levitate::M_tTimelineComponent_Levitation_DOWN' has a wrong offset!");

// Class BFGCore.BFGTaskNode_TriggerWeapon
// 0x0088 (0x0100 - 0x0078)
class UBFGTaskNode_TriggerWeapon final : public UBFGBTBaseTaskNode
{
public:
	struct FBlackboardKeySelector                 M_BBKeyAttackTarget;                               // 0x0078(0x0028)(Edit, BlueprintVisible, NativeAccessSpecifierPublic)
	bool                                          M_bLineOfFireCheck;                                // 0x00A0(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          M_bWaitForFinishShoot;                             // 0x00A1(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          M_bFriendlyFireCheck;                              // 0x00A2(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_A3[0x5];                                       // 0x00A3(0x0005)(Fixing Size After Last Property [ Dumper-7 ])
	TSoftClassPtr<class UClass>                   M_pSpecificWeaponClass;                            // 0x00A8(0x0028)(Edit, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         M_iEquippedWeaponIndex;                            // 0x00D0(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_D4[0x4];                                       // 0x00D4(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	struct FBlackboardKeySelector                 M_BBKeyEstimatedAttackDelay;                       // 0x00D8(0x0028)(Edit, BlueprintVisible, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"BFGTaskNode_TriggerWeapon">();
	}
	static class UBFGTaskNode_TriggerWeapon* GetDefaultObj()
	{
		return GetDefaultObjImpl<UBFGTaskNode_TriggerWeapon>();
	}
};
static_assert(alignof(UBFGTaskNode_TriggerWeapon) == 0x000008, "Wrong alignment on UBFGTaskNode_TriggerWeapon");
static_assert(sizeof(UBFGTaskNode_TriggerWeapon) == 0x000100, "Wrong size on UBFGTaskNode_TriggerWeapon");
static_assert(offsetof(UBFGTaskNode_TriggerWeapon, M_BBKeyAttackTarget) == 0x000078, "Member 'UBFGTaskNode_TriggerWeapon::M_BBKeyAttackTarget' has a wrong offset!");
static_assert(offsetof(UBFGTaskNode_TriggerWeapon, M_bLineOfFireCheck) == 0x0000A0, "Member 'UBFGTaskNode_TriggerWeapon::M_bLineOfFireCheck' has a wrong offset!");
static_assert(offsetof(UBFGTaskNode_TriggerWeapon, M_bWaitForFinishShoot) == 0x0000A1, "Member 'UBFGTaskNode_TriggerWeapon::M_bWaitForFinishShoot' has a wrong offset!");
static_assert(offsetof(UBFGTaskNode_TriggerWeapon, M_bFriendlyFireCheck) == 0x0000A2, "Member 'UBFGTaskNode_TriggerWeapon::M_bFriendlyFireCheck' has a wrong offset!");
static_assert(offsetof(UBFGTaskNode_TriggerWeapon, M_pSpecificWeaponClass) == 0x0000A8, "Member 'UBFGTaskNode_TriggerWeapon::M_pSpecificWeaponClass' has a wrong offset!");
static_assert(offsetof(UBFGTaskNode_TriggerWeapon, M_iEquippedWeaponIndex) == 0x0000D0, "Member 'UBFGTaskNode_TriggerWeapon::M_iEquippedWeaponIndex' has a wrong offset!");
static_assert(offsetof(UBFGTaskNode_TriggerWeapon, M_BBKeyEstimatedAttackDelay) == 0x0000D8, "Member 'UBFGTaskNode_TriggerWeapon::M_BBKeyEstimatedAttackDelay' has a wrong offset!");

// Class BFGCore.BFGEventTrigger_MonetaryValue
// 0x0000 (0x0040 - 0x0040)
class UBFGEventTrigger_MonetaryValue final : public UBFGEventTrigger
{
public:
	void ValueChanged(class ABFGPlayerState* _pState);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"BFGEventTrigger_MonetaryValue">();
	}
	static class UBFGEventTrigger_MonetaryValue* GetDefaultObj()
	{
		return GetDefaultObjImpl<UBFGEventTrigger_MonetaryValue>();
	}
};
static_assert(alignof(UBFGEventTrigger_MonetaryValue) == 0x000008, "Wrong alignment on UBFGEventTrigger_MonetaryValue");
static_assert(sizeof(UBFGEventTrigger_MonetaryValue) == 0x000040, "Wrong size on UBFGEventTrigger_MonetaryValue");

// Class BFGCore.BFGActorComponent_LockOn
// 0x0018 (0x0140 - 0x0128)
class UBFGActorComponent_LockOn final : public UActorComponent
{
public:
	class UBFGActorComponent_LockOnTarget*        M_pLockOnTarget;                                   // 0x0128(0x0008)(ExportObject, ZeroConstructor, Transient, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_130[0x8];                                      // 0x0130(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         M_fOrientToOwnerTurnDelay;                         // 0x0138(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_13C[0x4];                                      // 0x013C(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	class UBFGActorComponent_LockOnTarget* GetLockOnTarget() const;
	bool HasValidLockOnTarget() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"BFGActorComponent_LockOn">();
	}
	static class UBFGActorComponent_LockOn* GetDefaultObj()
	{
		return GetDefaultObjImpl<UBFGActorComponent_LockOn>();
	}
};
static_assert(alignof(UBFGActorComponent_LockOn) == 0x000008, "Wrong alignment on UBFGActorComponent_LockOn");
static_assert(sizeof(UBFGActorComponent_LockOn) == 0x000140, "Wrong size on UBFGActorComponent_LockOn");
static_assert(offsetof(UBFGActorComponent_LockOn, M_pLockOnTarget) == 0x000128, "Member 'UBFGActorComponent_LockOn::M_pLockOnTarget' has a wrong offset!");
static_assert(offsetof(UBFGActorComponent_LockOn, M_fOrientToOwnerTurnDelay) == 0x000138, "Member 'UBFGActorComponent_LockOn::M_fOrientToOwnerTurnDelay' has a wrong offset!");

// Class BFGCore.BFGActorComponent_LockOnTarget
// 0x0030 (0x0158 - 0x0128)
class UBFGActorComponent_LockOnTarget final : public UActorComponent
{
public:
	class UBFGLockOnManager*                      M_pManager;                                        // 0x0128(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          M_bCanBeLockOnTarget;                              // 0x0130(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          M_bDoDeathCheck;                                   // 0x0131(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_132[0x6];                                      // 0x0132(0x0006)(Fixing Size After Last Property [ Dumper-7 ])
	struct FGameplayTagContainer                  M_oGameplayEffectTagsToCheck;                      // 0x0138(0x0020)(Edit, Protected, NativeAccessSpecifierProtected)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"BFGActorComponent_LockOnTarget">();
	}
	static class UBFGActorComponent_LockOnTarget* GetDefaultObj()
	{
		return GetDefaultObjImpl<UBFGActorComponent_LockOnTarget>();
	}
};
static_assert(alignof(UBFGActorComponent_LockOnTarget) == 0x000008, "Wrong alignment on UBFGActorComponent_LockOnTarget");
static_assert(sizeof(UBFGActorComponent_LockOnTarget) == 0x000158, "Wrong size on UBFGActorComponent_LockOnTarget");
static_assert(offsetof(UBFGActorComponent_LockOnTarget, M_pManager) == 0x000128, "Member 'UBFGActorComponent_LockOnTarget::M_pManager' has a wrong offset!");
static_assert(offsetof(UBFGActorComponent_LockOnTarget, M_bCanBeLockOnTarget) == 0x000130, "Member 'UBFGActorComponent_LockOnTarget::M_bCanBeLockOnTarget' has a wrong offset!");
static_assert(offsetof(UBFGActorComponent_LockOnTarget, M_bDoDeathCheck) == 0x000131, "Member 'UBFGActorComponent_LockOnTarget::M_bDoDeathCheck' has a wrong offset!");
static_assert(offsetof(UBFGActorComponent_LockOnTarget, M_oGameplayEffectTagsToCheck) == 0x000138, "Member 'UBFGActorComponent_LockOnTarget::M_oGameplayEffectTagsToCheck' has a wrong offset!");

// Class BFGCore.BFGTaskNode_VehicleBase
// 0x00C8 (0x0138 - 0x0070)
class UBFGTaskNode_VehicleBase : public UBTTaskNode
{
public:
	struct FBlackboardKeySelector                 M_BBKeyState;                                      // 0x0070(0x0028)(Edit, BlueprintVisible, NativeAccessSpecifierPublic)
	struct FBlackboardKeySelector                 M_BBKeyStateAge;                                   // 0x0098(0x0028)(Edit, BlueprintVisible, NativeAccessSpecifierPublic)
	struct FBlackboardKeySelector                 M_BBKeyDrivingMode;                                // 0x00C0(0x0028)(Edit, BlueprintVisible, NativeAccessSpecifierPublic)
	struct FBlackboardKeySelector                 M_BBKeyAttackTarget;                               // 0x00E8(0x0028)(Edit, BlueprintVisible, NativeAccessSpecifierPublic)
	struct FBlackboardKeySelector                 M_BBKey_CrowdFlowAgent;                            // 0x0110(0x0028)(Edit, BlueprintVisible, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"BFGTaskNode_VehicleBase">();
	}
	static class UBFGTaskNode_VehicleBase* GetDefaultObj()
	{
		return GetDefaultObjImpl<UBFGTaskNode_VehicleBase>();
	}
};
static_assert(alignof(UBFGTaskNode_VehicleBase) == 0x000008, "Wrong alignment on UBFGTaskNode_VehicleBase");
static_assert(sizeof(UBFGTaskNode_VehicleBase) == 0x000138, "Wrong size on UBFGTaskNode_VehicleBase");
static_assert(offsetof(UBFGTaskNode_VehicleBase, M_BBKeyState) == 0x000070, "Member 'UBFGTaskNode_VehicleBase::M_BBKeyState' has a wrong offset!");
static_assert(offsetof(UBFGTaskNode_VehicleBase, M_BBKeyStateAge) == 0x000098, "Member 'UBFGTaskNode_VehicleBase::M_BBKeyStateAge' has a wrong offset!");
static_assert(offsetof(UBFGTaskNode_VehicleBase, M_BBKeyDrivingMode) == 0x0000C0, "Member 'UBFGTaskNode_VehicleBase::M_BBKeyDrivingMode' has a wrong offset!");
static_assert(offsetof(UBFGTaskNode_VehicleBase, M_BBKeyAttackTarget) == 0x0000E8, "Member 'UBFGTaskNode_VehicleBase::M_BBKeyAttackTarget' has a wrong offset!");
static_assert(offsetof(UBFGTaskNode_VehicleBase, M_BBKey_CrowdFlowAgent) == 0x000110, "Member 'UBFGTaskNode_VehicleBase::M_BBKey_CrowdFlowAgent' has a wrong offset!");

// Class BFGCore.BFGTaskNode_VehicleChaseTarget
// 0x0008 (0x0140 - 0x0138)
class UBFGTaskNode_VehicleChaseTarget final : public UBFGTaskNode_VehicleBase
{
public:
	float                                         M_fStuckInTrafficTimeout;                          // 0x0138(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         M_fDistanceToStopFromTarget;                       // 0x013C(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"BFGTaskNode_VehicleChaseTarget">();
	}
	static class UBFGTaskNode_VehicleChaseTarget* GetDefaultObj()
	{
		return GetDefaultObjImpl<UBFGTaskNode_VehicleChaseTarget>();
	}
};
static_assert(alignof(UBFGTaskNode_VehicleChaseTarget) == 0x000008, "Wrong alignment on UBFGTaskNode_VehicleChaseTarget");
static_assert(sizeof(UBFGTaskNode_VehicleChaseTarget) == 0x000140, "Wrong size on UBFGTaskNode_VehicleChaseTarget");
static_assert(offsetof(UBFGTaskNode_VehicleChaseTarget, M_fStuckInTrafficTimeout) == 0x000138, "Member 'UBFGTaskNode_VehicleChaseTarget::M_fStuckInTrafficTimeout' has a wrong offset!");
static_assert(offsetof(UBFGTaskNode_VehicleChaseTarget, M_fDistanceToStopFromTarget) == 0x00013C, "Member 'UBFGTaskNode_VehicleChaseTarget::M_fDistanceToStopFromTarget' has a wrong offset!");

// Class BFGCore.BFGEventTrigger_HealthChanged
// 0x0098 (0x00D8 - 0x0040)
class UBFGEventTrigger_HealthChanged final : public UBFGEventTrigger
{
public:
	struct FBFGActorBinding                       M_actorBinding;                                    // 0x0040(0x0090)(Transient, Protected, NativeAccessSpecifierProtected)
	uint8                                         Pad_D0[0x8];                                       // 0x00D0(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void OnHealthChanged(class AActor* _pActor);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"BFGEventTrigger_HealthChanged">();
	}
	static class UBFGEventTrigger_HealthChanged* GetDefaultObj()
	{
		return GetDefaultObjImpl<UBFGEventTrigger_HealthChanged>();
	}
};
static_assert(alignof(UBFGEventTrigger_HealthChanged) == 0x000008, "Wrong alignment on UBFGEventTrigger_HealthChanged");
static_assert(sizeof(UBFGEventTrigger_HealthChanged) == 0x0000D8, "Wrong size on UBFGEventTrigger_HealthChanged");
static_assert(offsetof(UBFGEventTrigger_HealthChanged, M_actorBinding) == 0x000040, "Member 'UBFGEventTrigger_HealthChanged::M_actorBinding' has a wrong offset!");

// Class BFGCore.BFGActorComponent_Magnet
// 0x0070 (0x0198 - 0x0128)
class UBFGActorComponent_Magnet : public UActorComponent
{
public:
	bool                                          M_bEnabled;                                        // 0x0128(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_129[0x3];                                      // 0x0129(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	struct FBFGMagnetData                         M_oDefaultMagnetData;                              // 0x012C(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, NoDestructor, Protected, NativeAccessSpecifierProtected)
	uint8                                         Pad_134[0x4];                                      // 0x0134(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	TMap<EBFGGameplayScaling, struct FBFGMagnetData> M_aGameplayScaledData;                             // 0x0138(0x0050)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, Protected, NativeAccessSpecifierProtected)
	uint8                                         Pad_188[0x10];                                     // 0x0188(0x0010)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"BFGActorComponent_Magnet">();
	}
	static class UBFGActorComponent_Magnet* GetDefaultObj()
	{
		return GetDefaultObjImpl<UBFGActorComponent_Magnet>();
	}
};
static_assert(alignof(UBFGActorComponent_Magnet) == 0x000008, "Wrong alignment on UBFGActorComponent_Magnet");
static_assert(sizeof(UBFGActorComponent_Magnet) == 0x000198, "Wrong size on UBFGActorComponent_Magnet");
static_assert(offsetof(UBFGActorComponent_Magnet, M_bEnabled) == 0x000128, "Member 'UBFGActorComponent_Magnet::M_bEnabled' has a wrong offset!");
static_assert(offsetof(UBFGActorComponent_Magnet, M_oDefaultMagnetData) == 0x00012C, "Member 'UBFGActorComponent_Magnet::M_oDefaultMagnetData' has a wrong offset!");
static_assert(offsetof(UBFGActorComponent_Magnet, M_aGameplayScaledData) == 0x000138, "Member 'UBFGActorComponent_Magnet::M_aGameplayScaledData' has a wrong offset!");

// Class BFGCore.BFGActorComponent_MentalAbilities
// 0x0070 (0x0198 - 0x0128)
class UBFGActorComponent_MentalAbilities final : public UActorComponent
{
public:
	uint8                                         Pad_128[0x8];                                      // 0x0128(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<struct FBFGPlayerSettingsMentalAbilityInfo> M_aAbilityInfo;                                    // 0x0130(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, NativeAccessSpecifierPublic)
	float                                         M_fTargetWidgetMax;                                // 0x0140(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         M_fTargetWidgetMin;                                // 0x0144(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         M_fTargetDistanceScale;                            // 0x0148(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_14C[0x4];                                      // 0x014C(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	TSubclassOf<class UUserWidget>                M_TargetMarkerClass;                               // 0x0150(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UUserWidget*                            M_pTargetMarker;                                   // 0x0158(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         M_fMaxRangeAutoTargetPercent2D;                    // 0x0160(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         M_fGroundSphereTargetingRadius;                    // 0x0164(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          M_bGroundTargetSphereTargetsCrosshair;             // 0x0168(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_169[0x7];                                      // 0x0169(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<class UBFGMentalAbilityBase*>          M_aPlayerMentalAbilities;                          // 0x0170(0x0010)(ZeroConstructor, Transient, Protected, NativeAccessSpecifierProtected)
	bool                                          M_bIsMenuOption;                                   // 0x0180(0x0001)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_181[0x7];                                      // 0x0181(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	class AActor*                                 M_pCurrentAimTarget;                               // 0x0188(0x0008)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_190[0x8];                                      // 0x0190(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void ActivateAbilityEffectOnTarget(TSubclassOf<class UBFGMentalAbilityBase> _rClass, class AActor* _pTarget);
	void DeactivateAbilityEffectOnTarget(TSubclassOf<class UBFGMentalAbilityBase> _rClass, class AActor* _pTarget);
	bool Input_InteractState(bool _bPressed, TSubclassOf<class UBFGMentalAbilityBase> _rClass, bool _bPlayInvalidTargetEffects);
	bool IsAnyAbilityActive();
	bool IsAnyMentalLinkActive();
	void OnDataChanged();
	void SetWidgetVisibility(ESlateVisibility _eVisibility);

	class UBFGMentalAbilityBase* GetAbilityByClass(const TSubclassOf<class UBFGMentalAbilityBase>& _rClass) const;
	void GetAllAbilities(TArray<class UBFGMentalAbilityBase*>* _apAbilitiesOut) const;
	class AActor* GetCurrentAimTarget() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"BFGActorComponent_MentalAbilities">();
	}
	static class UBFGActorComponent_MentalAbilities* GetDefaultObj()
	{
		return GetDefaultObjImpl<UBFGActorComponent_MentalAbilities>();
	}
};
static_assert(alignof(UBFGActorComponent_MentalAbilities) == 0x000008, "Wrong alignment on UBFGActorComponent_MentalAbilities");
static_assert(sizeof(UBFGActorComponent_MentalAbilities) == 0x000198, "Wrong size on UBFGActorComponent_MentalAbilities");
static_assert(offsetof(UBFGActorComponent_MentalAbilities, M_aAbilityInfo) == 0x000130, "Member 'UBFGActorComponent_MentalAbilities::M_aAbilityInfo' has a wrong offset!");
static_assert(offsetof(UBFGActorComponent_MentalAbilities, M_fTargetWidgetMax) == 0x000140, "Member 'UBFGActorComponent_MentalAbilities::M_fTargetWidgetMax' has a wrong offset!");
static_assert(offsetof(UBFGActorComponent_MentalAbilities, M_fTargetWidgetMin) == 0x000144, "Member 'UBFGActorComponent_MentalAbilities::M_fTargetWidgetMin' has a wrong offset!");
static_assert(offsetof(UBFGActorComponent_MentalAbilities, M_fTargetDistanceScale) == 0x000148, "Member 'UBFGActorComponent_MentalAbilities::M_fTargetDistanceScale' has a wrong offset!");
static_assert(offsetof(UBFGActorComponent_MentalAbilities, M_TargetMarkerClass) == 0x000150, "Member 'UBFGActorComponent_MentalAbilities::M_TargetMarkerClass' has a wrong offset!");
static_assert(offsetof(UBFGActorComponent_MentalAbilities, M_pTargetMarker) == 0x000158, "Member 'UBFGActorComponent_MentalAbilities::M_pTargetMarker' has a wrong offset!");
static_assert(offsetof(UBFGActorComponent_MentalAbilities, M_fMaxRangeAutoTargetPercent2D) == 0x000160, "Member 'UBFGActorComponent_MentalAbilities::M_fMaxRangeAutoTargetPercent2D' has a wrong offset!");
static_assert(offsetof(UBFGActorComponent_MentalAbilities, M_fGroundSphereTargetingRadius) == 0x000164, "Member 'UBFGActorComponent_MentalAbilities::M_fGroundSphereTargetingRadius' has a wrong offset!");
static_assert(offsetof(UBFGActorComponent_MentalAbilities, M_bGroundTargetSphereTargetsCrosshair) == 0x000168, "Member 'UBFGActorComponent_MentalAbilities::M_bGroundTargetSphereTargetsCrosshair' has a wrong offset!");
static_assert(offsetof(UBFGActorComponent_MentalAbilities, M_aPlayerMentalAbilities) == 0x000170, "Member 'UBFGActorComponent_MentalAbilities::M_aPlayerMentalAbilities' has a wrong offset!");
static_assert(offsetof(UBFGActorComponent_MentalAbilities, M_bIsMenuOption) == 0x000180, "Member 'UBFGActorComponent_MentalAbilities::M_bIsMenuOption' has a wrong offset!");
static_assert(offsetof(UBFGActorComponent_MentalAbilities, M_pCurrentAimTarget) == 0x000188, "Member 'UBFGActorComponent_MentalAbilities::M_pCurrentAimTarget' has a wrong offset!");

// Class BFGCore.BFGPlayerBase
// 0x00F0 (0x0900 - 0x0810)
class ABFGPlayerBase : public ACharacter
{
public:
	uint8                                         Pad_808[0x40];                                     // 0x0808(0x0040)(Fixing Size After Last Property [ Dumper-7 ])
	struct FGameplayTagContainer                  M_oGameplayTags;                                   // 0x0848(0x0020)(Edit, BlueprintVisible, BlueprintReadOnly, DisableEditOnInstance, NativeAccessSpecifierPublic)
	class UBFGActorComponent_MentalAbilities*     M_pMentalAbilityComponent;                         // 0x0868(0x0008)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, EditConst, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class USpringArmComponent*                    M_pPKSpringArmComponent;                           // 0x0870(0x0008)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, EditConst, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UBFGActorComponent_TargetSystem*        M_pTargetComponent;                                // 0x0878(0x0008)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, EditConst, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UBFGActorComponent_CameraHandle*        M_pCameraHandle;                                   // 0x0880(0x0008)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, EditConst, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UBFGActorComponent_EquipmentManager*    M_pEquipmentManagerComponent;                      // 0x0888(0x0008)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, EditConst, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UBFGActorComponent_InputActions*        M_pInputActionsComponent;                          // 0x0890(0x0008)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, EditConst, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UBFGActorComponent_GameplayEffectTags*  M_pGameplayEffectTagsComponent;                    // 0x0898(0x0008)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, EditConst, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UBFGActorComponent_GameplayEffectResponses* M_pGameplayEffectResponse;                         // 0x08A0(0x0008)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, EditConst, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_8A8[0x18];                                     // 0x08A8(0x0018)(Fixing Size After Last Property [ Dumper-7 ])
	class APostProcessVolume*                     M_pPostProcessVolume;                              // 0x08C0(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UBFGActorComponent_MissionGameplay*     M_pMissionGameplayComponent;                       // 0x08C8(0x0008)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, EditConst, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UBFGActorComponent_AITarget*            M_pAITargetComponent;                              // 0x08D0(0x0008)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, EditConst, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UCurveFloat*                            M_pDefaultCameraSpeedCoefCurve;                    // 0x08D8(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         M_fGracePeriodDuration;                            // 0x08E0(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         M_fValidateProjectileImpactRadius;                 // 0x08E4(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class ABFGGameState*                          M_pGameState;                                      // 0x08E8(0x0008)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_8F0[0x10];                                     // 0x08F0(0x0010)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void BFGPlayerBase_DamageCausedEvent__DelegateSignature(class AActor* _pDamagedActor, float _fDamage, bool _bWasFatal, TSubclassOf<class UDamageType> _damageType);
	void BP_OnCutsceneStarted();
	void Callback_OnCutsceneStarted();
	void DeactivateAllActiveWeaponsAndAbilities(class UClass* _pKeepAbilityActiveByClass);
	void EnterGracePeriod(class FName _strFadeIdentifier, bool _bFadeOut);
	void VisibilityHiddenIngameChanged(bool _bValue);

	class UCurveFloat* GetDefaultCameraSpeedCoefCurve() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"BFGPlayerBase">();
	}
	static class ABFGPlayerBase* GetDefaultObj()
	{
		return GetDefaultObjImpl<ABFGPlayerBase>();
	}
};
static_assert(alignof(ABFGPlayerBase) == 0x000010, "Wrong alignment on ABFGPlayerBase");
static_assert(sizeof(ABFGPlayerBase) == 0x000900, "Wrong size on ABFGPlayerBase");
static_assert(offsetof(ABFGPlayerBase, M_oGameplayTags) == 0x000848, "Member 'ABFGPlayerBase::M_oGameplayTags' has a wrong offset!");
static_assert(offsetof(ABFGPlayerBase, M_pMentalAbilityComponent) == 0x000868, "Member 'ABFGPlayerBase::M_pMentalAbilityComponent' has a wrong offset!");
static_assert(offsetof(ABFGPlayerBase, M_pPKSpringArmComponent) == 0x000870, "Member 'ABFGPlayerBase::M_pPKSpringArmComponent' has a wrong offset!");
static_assert(offsetof(ABFGPlayerBase, M_pTargetComponent) == 0x000878, "Member 'ABFGPlayerBase::M_pTargetComponent' has a wrong offset!");
static_assert(offsetof(ABFGPlayerBase, M_pCameraHandle) == 0x000880, "Member 'ABFGPlayerBase::M_pCameraHandle' has a wrong offset!");
static_assert(offsetof(ABFGPlayerBase, M_pEquipmentManagerComponent) == 0x000888, "Member 'ABFGPlayerBase::M_pEquipmentManagerComponent' has a wrong offset!");
static_assert(offsetof(ABFGPlayerBase, M_pInputActionsComponent) == 0x000890, "Member 'ABFGPlayerBase::M_pInputActionsComponent' has a wrong offset!");
static_assert(offsetof(ABFGPlayerBase, M_pGameplayEffectTagsComponent) == 0x000898, "Member 'ABFGPlayerBase::M_pGameplayEffectTagsComponent' has a wrong offset!");
static_assert(offsetof(ABFGPlayerBase, M_pGameplayEffectResponse) == 0x0008A0, "Member 'ABFGPlayerBase::M_pGameplayEffectResponse' has a wrong offset!");
static_assert(offsetof(ABFGPlayerBase, M_pPostProcessVolume) == 0x0008C0, "Member 'ABFGPlayerBase::M_pPostProcessVolume' has a wrong offset!");
static_assert(offsetof(ABFGPlayerBase, M_pMissionGameplayComponent) == 0x0008C8, "Member 'ABFGPlayerBase::M_pMissionGameplayComponent' has a wrong offset!");
static_assert(offsetof(ABFGPlayerBase, M_pAITargetComponent) == 0x0008D0, "Member 'ABFGPlayerBase::M_pAITargetComponent' has a wrong offset!");
static_assert(offsetof(ABFGPlayerBase, M_pDefaultCameraSpeedCoefCurve) == 0x0008D8, "Member 'ABFGPlayerBase::M_pDefaultCameraSpeedCoefCurve' has a wrong offset!");
static_assert(offsetof(ABFGPlayerBase, M_fGracePeriodDuration) == 0x0008E0, "Member 'ABFGPlayerBase::M_fGracePeriodDuration' has a wrong offset!");
static_assert(offsetof(ABFGPlayerBase, M_fValidateProjectileImpactRadius) == 0x0008E4, "Member 'ABFGPlayerBase::M_fValidateProjectileImpactRadius' has a wrong offset!");
static_assert(offsetof(ABFGPlayerBase, M_pGameState) == 0x0008E8, "Member 'ABFGPlayerBase::M_pGameState' has a wrong offset!");

// Class BFGCore.BFGPlayerUFO
// 0x0140 (0x0A40 - 0x0900)
class ABFGPlayerUFO : public ABFGPlayerBase
{
public:
	float                                         M_fBaseTurnRate;                                   // 0x0900(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         M_fBaseLookUpRate;                                 // 0x0904(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UBFGActorComponent_PlayerWeapon*        M_pWeaponComponent;                                // 0x0908(0x0008)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, EditConst, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UBFGActorComponent_PlayerStats*         M_pStatsComponent;                                 // 0x0910(0x0008)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, EditConst, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UBFGActorComponent_Animation*           M_pAnimationComponent;                             // 0x0918(0x0008)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, EditConst, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UBFGActorComponent_PlayerWeaponAndAbilitySelector* M_pWeaponAndAbilitySelection;                      // 0x0920(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UCameraComponent*                       M_pFollowCam;                                      // 0x0928(0x0008)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, EditConst, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UBFGActorComponent_PlayerInteractionsUFO* M_pInteractionsComponent;                          // 0x0930(0x0008)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, EditConst, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UBFGActorComponent_FocusMode*           M_pFocusComponent;                                 // 0x0938(0x0008)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, EditConst, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class USceneComponent*                        M_pObjectiveMarkerParentComponent;                 // 0x0940(0x0008)(Edit, BlueprintVisible, ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UBFGActorComponent_Objective*           M_pObjectiveMarkerComponent;                       // 0x0948(0x0008)(Edit, BlueprintVisible, ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UBFGActorComponent_Effect*              M_pEffectComponent;                                // 0x0950(0x0008)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, EditConst, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          M_bIsGrounded;                                     // 0x0958(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_959[0x7];                                      // 0x0959(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	class UNavigationInvokerComponent*            M_pInvokerComponent;                               // 0x0960(0x0008)(Edit, ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UStaticMeshComponent*                   M_pTriggerZoneIndicator;                           // 0x0968(0x0008)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         M_fDelayBeforeDeathRespawn;                        // 0x0970(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_974[0x4];                                      // 0x0974(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class UBFGActorComponent_PawnDamage*          M_pDamageComponent;                                // 0x0978(0x0008)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, EditConst, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	EBFGFaction                                   M_faction;                                         // 0x0980(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          M_bIsPlayerControlled;                             // 0x0981(0x0001)(Edit, BlueprintVisible, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          M_bCanLand;                                        // 0x0982(0x0001)(Edit, BlueprintVisible, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_983[0x1];                                      // 0x0983(0x0001)(Fixing Size After Last Property [ Dumper-7 ])
	TWeakObjectPtr<class ABFGPlayerCharacter>     M_spPlayer;                                        // 0x0984(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TWeakObjectPtr<class ABFGUFOLandingSite>      M_spClosestLandingSite;                            // 0x098C(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         M_fClosestLandingSiteDistance;                     // 0x0994(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         M_fLowFrequencyUpdateInterval;                     // 0x0998(0x0004)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         M_fRollPitchSpeed;                                 // 0x099C(0x0004)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         M_fUFOMaxPitch;                                    // 0x09A0(0x0004)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         M_fUFOMaxRoll;                                     // 0x09A4(0x0004)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TSubclassOf<class UDamageType>                M_pTakeoffDamageType;                              // 0x09A8(0x0008)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         M_fTakeoffImpulseRadius;                           // 0x09B0(0x0004)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         M_fTakeoffImpulseDamage;                           // 0x09B4(0x0004)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         M_fTakeoffImpuleStrength;                          // 0x09B8(0x0004)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         M_fHeightAboveOcean;                               // 0x09BC(0x0004)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         M_fYawInterpSpeed;                                 // 0x09C0(0x0004)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         M_fYawMaxLagAngle;                                 // 0x09C4(0x0004)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_9C8[0x10];                                     // 0x09C8(0x0010)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         M_fCrosshairYOffsetOverride;                       // 0x09D8(0x0004)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	struct FGameplayTag                           M_tUpgradeTagShieldGeneratorAlpha;                 // 0x09DC(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, DisableEditOnInstance, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         M_fShieldGeneratorAlphaBoost;                      // 0x09E4(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_9E8[0x4];                                      // 0x09E8(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	struct FGameplayTag                           M_tUpgradeTagShieldGeneratorEpsilon;               // 0x09EC(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, DisableEditOnInstance, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         M_fShieldGeneratorEpsilonBoost;                    // 0x09F4(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_9F8[0x4];                                      // 0x09F8(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	struct FGameplayTag                           M_tUpgradeTagShieldHarmonicsOmicron;               // 0x09FC(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, DisableEditOnInstance, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         M_fShieldHarmonicsOmicronWindow;                   // 0x0A04(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         M_fShieldLastChanceHarmonicsOmicronWindow;         // 0x0A08(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_A0C[0x4];                                      // 0x0A0C(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	struct FVector                                M_vInputAxis;                                      // 0x0A10(0x000C)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	struct FRotator                               M_vOrientationOffset;                              // 0x0A1C(0x000C)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, NativeAccessSpecifierProtected)
	float                                         M_fLastUpdateTimer;                                // 0x0A28(0x0004)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_A2C[0x4];                                      // 0x0A2C(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class UBFGOceanManager*                       M_pOceanManager;                                   // 0x0A30(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class ABFGActorOcean*                         M_pOceanActor;                                     // 0x0A38(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)

public:
	void AssignPilotMesh(class USkeletalMeshComponent* _pSkeletalMeshComponent);
	bool IsAllowedToTriggerShieldImpact();
	void OnDeathStateChanged(class AActor* _pActor, class UBFGActorStat_Bool* _pStat);
	void OnShowTriggerZoneMessage(bool _bIsOutside);
	void OnStartedEnteringUFO();
	void TriggerBeamEffect(bool _bEnable);

	float ComputeCurrentHeight() const;
	class UBFGPlayerUFO_Settings* GetSettings() const;
	bool PlayerCanTakeControl(bool _bIgnoreDistance) const;
	bool PlayerHasControl() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"BFGPlayerUFO">();
	}
	static class ABFGPlayerUFO* GetDefaultObj()
	{
		return GetDefaultObjImpl<ABFGPlayerUFO>();
	}
};
static_assert(alignof(ABFGPlayerUFO) == 0x000010, "Wrong alignment on ABFGPlayerUFO");
static_assert(sizeof(ABFGPlayerUFO) == 0x000A40, "Wrong size on ABFGPlayerUFO");
static_assert(offsetof(ABFGPlayerUFO, M_fBaseTurnRate) == 0x000900, "Member 'ABFGPlayerUFO::M_fBaseTurnRate' has a wrong offset!");
static_assert(offsetof(ABFGPlayerUFO, M_fBaseLookUpRate) == 0x000904, "Member 'ABFGPlayerUFO::M_fBaseLookUpRate' has a wrong offset!");
static_assert(offsetof(ABFGPlayerUFO, M_pWeaponComponent) == 0x000908, "Member 'ABFGPlayerUFO::M_pWeaponComponent' has a wrong offset!");
static_assert(offsetof(ABFGPlayerUFO, M_pStatsComponent) == 0x000910, "Member 'ABFGPlayerUFO::M_pStatsComponent' has a wrong offset!");
static_assert(offsetof(ABFGPlayerUFO, M_pAnimationComponent) == 0x000918, "Member 'ABFGPlayerUFO::M_pAnimationComponent' has a wrong offset!");
static_assert(offsetof(ABFGPlayerUFO, M_pWeaponAndAbilitySelection) == 0x000920, "Member 'ABFGPlayerUFO::M_pWeaponAndAbilitySelection' has a wrong offset!");
static_assert(offsetof(ABFGPlayerUFO, M_pFollowCam) == 0x000928, "Member 'ABFGPlayerUFO::M_pFollowCam' has a wrong offset!");
static_assert(offsetof(ABFGPlayerUFO, M_pInteractionsComponent) == 0x000930, "Member 'ABFGPlayerUFO::M_pInteractionsComponent' has a wrong offset!");
static_assert(offsetof(ABFGPlayerUFO, M_pFocusComponent) == 0x000938, "Member 'ABFGPlayerUFO::M_pFocusComponent' has a wrong offset!");
static_assert(offsetof(ABFGPlayerUFO, M_pObjectiveMarkerParentComponent) == 0x000940, "Member 'ABFGPlayerUFO::M_pObjectiveMarkerParentComponent' has a wrong offset!");
static_assert(offsetof(ABFGPlayerUFO, M_pObjectiveMarkerComponent) == 0x000948, "Member 'ABFGPlayerUFO::M_pObjectiveMarkerComponent' has a wrong offset!");
static_assert(offsetof(ABFGPlayerUFO, M_pEffectComponent) == 0x000950, "Member 'ABFGPlayerUFO::M_pEffectComponent' has a wrong offset!");
static_assert(offsetof(ABFGPlayerUFO, M_bIsGrounded) == 0x000958, "Member 'ABFGPlayerUFO::M_bIsGrounded' has a wrong offset!");
static_assert(offsetof(ABFGPlayerUFO, M_pInvokerComponent) == 0x000960, "Member 'ABFGPlayerUFO::M_pInvokerComponent' has a wrong offset!");
static_assert(offsetof(ABFGPlayerUFO, M_pTriggerZoneIndicator) == 0x000968, "Member 'ABFGPlayerUFO::M_pTriggerZoneIndicator' has a wrong offset!");
static_assert(offsetof(ABFGPlayerUFO, M_fDelayBeforeDeathRespawn) == 0x000970, "Member 'ABFGPlayerUFO::M_fDelayBeforeDeathRespawn' has a wrong offset!");
static_assert(offsetof(ABFGPlayerUFO, M_pDamageComponent) == 0x000978, "Member 'ABFGPlayerUFO::M_pDamageComponent' has a wrong offset!");
static_assert(offsetof(ABFGPlayerUFO, M_faction) == 0x000980, "Member 'ABFGPlayerUFO::M_faction' has a wrong offset!");
static_assert(offsetof(ABFGPlayerUFO, M_bIsPlayerControlled) == 0x000981, "Member 'ABFGPlayerUFO::M_bIsPlayerControlled' has a wrong offset!");
static_assert(offsetof(ABFGPlayerUFO, M_bCanLand) == 0x000982, "Member 'ABFGPlayerUFO::M_bCanLand' has a wrong offset!");
static_assert(offsetof(ABFGPlayerUFO, M_spPlayer) == 0x000984, "Member 'ABFGPlayerUFO::M_spPlayer' has a wrong offset!");
static_assert(offsetof(ABFGPlayerUFO, M_spClosestLandingSite) == 0x00098C, "Member 'ABFGPlayerUFO::M_spClosestLandingSite' has a wrong offset!");
static_assert(offsetof(ABFGPlayerUFO, M_fClosestLandingSiteDistance) == 0x000994, "Member 'ABFGPlayerUFO::M_fClosestLandingSiteDistance' has a wrong offset!");
static_assert(offsetof(ABFGPlayerUFO, M_fLowFrequencyUpdateInterval) == 0x000998, "Member 'ABFGPlayerUFO::M_fLowFrequencyUpdateInterval' has a wrong offset!");
static_assert(offsetof(ABFGPlayerUFO, M_fRollPitchSpeed) == 0x00099C, "Member 'ABFGPlayerUFO::M_fRollPitchSpeed' has a wrong offset!");
static_assert(offsetof(ABFGPlayerUFO, M_fUFOMaxPitch) == 0x0009A0, "Member 'ABFGPlayerUFO::M_fUFOMaxPitch' has a wrong offset!");
static_assert(offsetof(ABFGPlayerUFO, M_fUFOMaxRoll) == 0x0009A4, "Member 'ABFGPlayerUFO::M_fUFOMaxRoll' has a wrong offset!");
static_assert(offsetof(ABFGPlayerUFO, M_pTakeoffDamageType) == 0x0009A8, "Member 'ABFGPlayerUFO::M_pTakeoffDamageType' has a wrong offset!");
static_assert(offsetof(ABFGPlayerUFO, M_fTakeoffImpulseRadius) == 0x0009B0, "Member 'ABFGPlayerUFO::M_fTakeoffImpulseRadius' has a wrong offset!");
static_assert(offsetof(ABFGPlayerUFO, M_fTakeoffImpulseDamage) == 0x0009B4, "Member 'ABFGPlayerUFO::M_fTakeoffImpulseDamage' has a wrong offset!");
static_assert(offsetof(ABFGPlayerUFO, M_fTakeoffImpuleStrength) == 0x0009B8, "Member 'ABFGPlayerUFO::M_fTakeoffImpuleStrength' has a wrong offset!");
static_assert(offsetof(ABFGPlayerUFO, M_fHeightAboveOcean) == 0x0009BC, "Member 'ABFGPlayerUFO::M_fHeightAboveOcean' has a wrong offset!");
static_assert(offsetof(ABFGPlayerUFO, M_fYawInterpSpeed) == 0x0009C0, "Member 'ABFGPlayerUFO::M_fYawInterpSpeed' has a wrong offset!");
static_assert(offsetof(ABFGPlayerUFO, M_fYawMaxLagAngle) == 0x0009C4, "Member 'ABFGPlayerUFO::M_fYawMaxLagAngle' has a wrong offset!");
static_assert(offsetof(ABFGPlayerUFO, M_fCrosshairYOffsetOverride) == 0x0009D8, "Member 'ABFGPlayerUFO::M_fCrosshairYOffsetOverride' has a wrong offset!");
static_assert(offsetof(ABFGPlayerUFO, M_tUpgradeTagShieldGeneratorAlpha) == 0x0009DC, "Member 'ABFGPlayerUFO::M_tUpgradeTagShieldGeneratorAlpha' has a wrong offset!");
static_assert(offsetof(ABFGPlayerUFO, M_fShieldGeneratorAlphaBoost) == 0x0009E4, "Member 'ABFGPlayerUFO::M_fShieldGeneratorAlphaBoost' has a wrong offset!");
static_assert(offsetof(ABFGPlayerUFO, M_tUpgradeTagShieldGeneratorEpsilon) == 0x0009EC, "Member 'ABFGPlayerUFO::M_tUpgradeTagShieldGeneratorEpsilon' has a wrong offset!");
static_assert(offsetof(ABFGPlayerUFO, M_fShieldGeneratorEpsilonBoost) == 0x0009F4, "Member 'ABFGPlayerUFO::M_fShieldGeneratorEpsilonBoost' has a wrong offset!");
static_assert(offsetof(ABFGPlayerUFO, M_tUpgradeTagShieldHarmonicsOmicron) == 0x0009FC, "Member 'ABFGPlayerUFO::M_tUpgradeTagShieldHarmonicsOmicron' has a wrong offset!");
static_assert(offsetof(ABFGPlayerUFO, M_fShieldHarmonicsOmicronWindow) == 0x000A04, "Member 'ABFGPlayerUFO::M_fShieldHarmonicsOmicronWindow' has a wrong offset!");
static_assert(offsetof(ABFGPlayerUFO, M_fShieldLastChanceHarmonicsOmicronWindow) == 0x000A08, "Member 'ABFGPlayerUFO::M_fShieldLastChanceHarmonicsOmicronWindow' has a wrong offset!");
static_assert(offsetof(ABFGPlayerUFO, M_vInputAxis) == 0x000A10, "Member 'ABFGPlayerUFO::M_vInputAxis' has a wrong offset!");
static_assert(offsetof(ABFGPlayerUFO, M_vOrientationOffset) == 0x000A1C, "Member 'ABFGPlayerUFO::M_vOrientationOffset' has a wrong offset!");
static_assert(offsetof(ABFGPlayerUFO, M_fLastUpdateTimer) == 0x000A28, "Member 'ABFGPlayerUFO::M_fLastUpdateTimer' has a wrong offset!");
static_assert(offsetof(ABFGPlayerUFO, M_pOceanManager) == 0x000A30, "Member 'ABFGPlayerUFO::M_pOceanManager' has a wrong offset!");
static_assert(offsetof(ABFGPlayerUFO, M_pOceanActor) == 0x000A38, "Member 'ABFGPlayerUFO::M_pOceanActor' has a wrong offset!");

// Class BFGCore.BFGScriptedSequence_TaskMoveTo
// 0x0040 (0x0090 - 0x0050)
class UBFGScriptedSequence_TaskMoveTo final : public UBFGScriptedSequence_Task
{
public:
	uint8                                         Pad_50[0x40];                                      // 0x0050(0x0040)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static bool CreateAndAddScriptedSequence_TaskMoveTo(class UBFGScriptedSequence* _pScriptedSequence, TSoftObjectPtr<class AActor> _pActorToReach, EBFGNPCCharacter_MoveSpeed _moveSpeed, float _fTolerance, bool _ShouldGoIntoStandby);
	static bool CreateAndAddScriptedSequence_TaskMoveToForVehicle(class UBFGScriptedSequence* _pScriptedSequence, TSoftObjectPtr<class AActor> _pActorToReach, bool _bShouldStopAtEnd, bool _bShouldReleasePassenger, float _fTolerance, bool _doWaitInStandby, bool _doIgnoreAvailabilityFlag, float _fOverrideSpeed);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"BFGScriptedSequence_TaskMoveTo">();
	}
	static class UBFGScriptedSequence_TaskMoveTo* GetDefaultObj()
	{
		return GetDefaultObjImpl<UBFGScriptedSequence_TaskMoveTo>();
	}
};
static_assert(alignof(UBFGScriptedSequence_TaskMoveTo) == 0x000008, "Wrong alignment on UBFGScriptedSequence_TaskMoveTo");
static_assert(sizeof(UBFGScriptedSequence_TaskMoveTo) == 0x000090, "Wrong size on UBFGScriptedSequence_TaskMoveTo");

// Class BFGCore.BFGEventTrigger_BossObjective
// 0x0098 (0x00D8 - 0x0040)
class UBFGEventTrigger_BossObjective final : public UBFGEventTrigger
{
public:
	struct FBFGActorBinding                       M_targetBinding;                                   // 0x0040(0x0090)(Transient, Protected, NativeAccessSpecifierProtected)
	uint8                                         Pad_D0[0x8];                                       // 0x00D0(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void OnBossObjectiveReached(class AActor* _pBoss, EBFGQuest_BossObjective _objective);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"BFGEventTrigger_BossObjective">();
	}
	static class UBFGEventTrigger_BossObjective* GetDefaultObj()
	{
		return GetDefaultObjImpl<UBFGEventTrigger_BossObjective>();
	}
};
static_assert(alignof(UBFGEventTrigger_BossObjective) == 0x000008, "Wrong alignment on UBFGEventTrigger_BossObjective");
static_assert(sizeof(UBFGEventTrigger_BossObjective) == 0x0000D8, "Wrong size on UBFGEventTrigger_BossObjective");
static_assert(offsetof(UBFGEventTrigger_BossObjective, M_targetBinding) == 0x000040, "Member 'UBFGEventTrigger_BossObjective::M_targetBinding' has a wrong offset!");

// Class BFGCore.BFGActorComponent_MentallyInteractable
// 0x00D8 (0x0200 - 0x0128)
class UBFGActorComponent_MentallyInteractable final : public UActorComponent
{
public:
	UMulticastDelegateProperty_                   M_action_InteractStart;                            // 0x0128(0x0018)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	UMulticastDelegateProperty_                   M_action_Used;                                     // 0x0140(0x0018)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	UMulticastDelegateProperty_                   M_action_InteractStop;                             // 0x0158(0x0018)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	UMulticastDelegateProperty_                   M_action_Focused;                                  // 0x0170(0x0018)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	UMulticastDelegateProperty_                   M_action_Unfocused;                                // 0x0188(0x0018)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	bool                                          M_bUseableFromSaucer;                              // 0x01A0(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          M_bEnabled;                                        // 0x01A1(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_1A2[0x2];                                      // 0x01A2(0x0002)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         M_fHoldTime;                                       // 0x01A4(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	EBFGAnimation_MentalAbilityPosture            M_eAnimationPosture;                               // 0x01A8(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_1A9[0x7];                                      // 0x01A9(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	struct FGameplayTagContainer                  M_oCompetentAbilities;                             // 0x01B0(0x0020)(Edit, BlueprintVisible, Protected, NativeAccessSpecifierProtected)
	TArray<class UBFGMentallyInteractableCheck*>  M_aChecks;                                         // 0x01D0(0x0010)(Edit, BlueprintVisible, ExportObject, ZeroConstructor, ContainsInstancedReference, Protected, NativeAccessSpecifierProtected)
	bool                                          M_bIsFocused;                                      // 0x01E0(0x0001)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_1E1[0x3];                                      // 0x01E1(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         M_fCurrentInteractTime;                            // 0x01E4(0x0004)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_1E8[0x18];                                     // 0x01E8(0x0018)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void Action_Focused__DelegateSignature(class UBFGActorComponent_MentallyInteractable* _pMentallyInteractable, class AController* _pController);
	void Action_InteractAction__DelegateSignature(class UBFGActorComponent_MentallyInteractable* _pMentallyInteractable, class AController* _pController);
	void Action_Unfocused__DelegateSignature(class UBFGActorComponent_MentallyInteractable* _pMentallyInteractable);
	bool IsInteractable(class ABFGPlayerCharacter* _pPlayer);
	void SetEnabled(bool _bEnabled);

	float GetHoldTime() const;
	float GetInteractTime() const;
	const class FText GetLastFailText() const;
	EBFGAnimation_MentalAbilityPosture GetPosture() const;
	bool IsEnabled() const;
	bool IsFocused() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"BFGActorComponent_MentallyInteractable">();
	}
	static class UBFGActorComponent_MentallyInteractable* GetDefaultObj()
	{
		return GetDefaultObjImpl<UBFGActorComponent_MentallyInteractable>();
	}
};
static_assert(alignof(UBFGActorComponent_MentallyInteractable) == 0x000008, "Wrong alignment on UBFGActorComponent_MentallyInteractable");
static_assert(sizeof(UBFGActorComponent_MentallyInteractable) == 0x000200, "Wrong size on UBFGActorComponent_MentallyInteractable");
static_assert(offsetof(UBFGActorComponent_MentallyInteractable, M_action_InteractStart) == 0x000128, "Member 'UBFGActorComponent_MentallyInteractable::M_action_InteractStart' has a wrong offset!");
static_assert(offsetof(UBFGActorComponent_MentallyInteractable, M_action_Used) == 0x000140, "Member 'UBFGActorComponent_MentallyInteractable::M_action_Used' has a wrong offset!");
static_assert(offsetof(UBFGActorComponent_MentallyInteractable, M_action_InteractStop) == 0x000158, "Member 'UBFGActorComponent_MentallyInteractable::M_action_InteractStop' has a wrong offset!");
static_assert(offsetof(UBFGActorComponent_MentallyInteractable, M_action_Focused) == 0x000170, "Member 'UBFGActorComponent_MentallyInteractable::M_action_Focused' has a wrong offset!");
static_assert(offsetof(UBFGActorComponent_MentallyInteractable, M_action_Unfocused) == 0x000188, "Member 'UBFGActorComponent_MentallyInteractable::M_action_Unfocused' has a wrong offset!");
static_assert(offsetof(UBFGActorComponent_MentallyInteractable, M_bUseableFromSaucer) == 0x0001A0, "Member 'UBFGActorComponent_MentallyInteractable::M_bUseableFromSaucer' has a wrong offset!");
static_assert(offsetof(UBFGActorComponent_MentallyInteractable, M_bEnabled) == 0x0001A1, "Member 'UBFGActorComponent_MentallyInteractable::M_bEnabled' has a wrong offset!");
static_assert(offsetof(UBFGActorComponent_MentallyInteractable, M_fHoldTime) == 0x0001A4, "Member 'UBFGActorComponent_MentallyInteractable::M_fHoldTime' has a wrong offset!");
static_assert(offsetof(UBFGActorComponent_MentallyInteractable, M_eAnimationPosture) == 0x0001A8, "Member 'UBFGActorComponent_MentallyInteractable::M_eAnimationPosture' has a wrong offset!");
static_assert(offsetof(UBFGActorComponent_MentallyInteractable, M_oCompetentAbilities) == 0x0001B0, "Member 'UBFGActorComponent_MentallyInteractable::M_oCompetentAbilities' has a wrong offset!");
static_assert(offsetof(UBFGActorComponent_MentallyInteractable, M_aChecks) == 0x0001D0, "Member 'UBFGActorComponent_MentallyInteractable::M_aChecks' has a wrong offset!");
static_assert(offsetof(UBFGActorComponent_MentallyInteractable, M_bIsFocused) == 0x0001E0, "Member 'UBFGActorComponent_MentallyInteractable::M_bIsFocused' has a wrong offset!");
static_assert(offsetof(UBFGActorComponent_MentallyInteractable, M_fCurrentInteractTime) == 0x0001E4, "Member 'UBFGActorComponent_MentallyInteractable::M_fCurrentInteractTime' has a wrong offset!");

// Class BFGCore.BFGActorComponent_MissionGameplay
// 0x0030 (0x0158 - 0x0128)
class UBFGActorComponent_MissionGameplay final : public UActorComponent
{
public:
	bool                                          M_bIsMissionTriggerZoneActivator;                  // 0x0128(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_129[0x7];                                      // 0x0129(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<class ABFGRestrictedArea*>             M_apViolatedRestrictedAreas;                       // 0x0130(0x0010)(ZeroConstructor, Transient, Protected, NativeAccessSpecifierProtected)
	TArray<class ABFGRestrictedArea*>             M_apVisitedRestrictedAreas;                        // 0x0140(0x0010)(ZeroConstructor, Transient, Protected, NativeAccessSpecifierProtected)
	uint8                                         Pad_150[0x8];                                      // 0x0150(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	const TArray<class ABFGRestrictedArea*> GetRestrictedAreaOverlapping() const;
	const TArray<class ABFGRestrictedArea*> GetRestrictedAreaViolated() const;
	bool IsVisitingAnyRestrictedArea() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"BFGActorComponent_MissionGameplay">();
	}
	static class UBFGActorComponent_MissionGameplay* GetDefaultObj()
	{
		return GetDefaultObjImpl<UBFGActorComponent_MissionGameplay>();
	}
};
static_assert(alignof(UBFGActorComponent_MissionGameplay) == 0x000008, "Wrong alignment on UBFGActorComponent_MissionGameplay");
static_assert(sizeof(UBFGActorComponent_MissionGameplay) == 0x000158, "Wrong size on UBFGActorComponent_MissionGameplay");
static_assert(offsetof(UBFGActorComponent_MissionGameplay, M_bIsMissionTriggerZoneActivator) == 0x000128, "Member 'UBFGActorComponent_MissionGameplay::M_bIsMissionTriggerZoneActivator' has a wrong offset!");
static_assert(offsetof(UBFGActorComponent_MissionGameplay, M_apViolatedRestrictedAreas) == 0x000130, "Member 'UBFGActorComponent_MissionGameplay::M_apViolatedRestrictedAreas' has a wrong offset!");
static_assert(offsetof(UBFGActorComponent_MissionGameplay, M_apVisitedRestrictedAreas) == 0x000140, "Member 'UBFGActorComponent_MissionGameplay::M_apVisitedRestrictedAreas' has a wrong offset!");

// Class BFGCore.BFGScriptedSequence
// 0x00B0 (0x00D8 - 0x0028)
class UBFGScriptedSequence : public UObject
{
public:
	uint8                                         Pad_28[0x8];                                       // 0x0028(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	class ABFGGameState*                          M_pGameState;                                      // 0x0030(0x0008)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UObject*                                M_pDebugContext;                                   // 0x0038(0x0008)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TArray<class UBFGScriptedSequence_Task*>      M_apTasks;                                         // 0x0040(0x0010)(ExportObject, ZeroConstructor, Transient, ContainsInstancedReference, Protected, NativeAccessSpecifierProtected)
	uint8                                         Pad_50[0x8];                                       // 0x0050(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	struct FGameplayTagQuery                      M_pawnGameplayTagQuery;                            // 0x0058(0x0048)(Transient, Protected, NativeAccessSpecifierProtected)
	TSoftObjectPtr<class AActor>                  M_softActorReference;                              // 0x00A0(0x0028)(Transient, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UBFGNetworkPathAgent*                   M_pAgent;                                          // 0x00C8(0x0008)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_D0[0x8];                                       // 0x00D0(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void OnAgentDestroyed(class UBFGNetworkPathAgent* _pAgent);
	void RequestAbortSequence();
	void RequestStartSequence();
	void SetActivationAction(EBFGScriptedSequence_ActivationAction _action);

	class UBFGNetworkPathAgent* GetAgent() const;
	int32 GetCurrentTaskIndex() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"BFGScriptedSequence">();
	}
	static class UBFGScriptedSequence* GetDefaultObj()
	{
		return GetDefaultObjImpl<UBFGScriptedSequence>();
	}
};
static_assert(alignof(UBFGScriptedSequence) == 0x000008, "Wrong alignment on UBFGScriptedSequence");
static_assert(sizeof(UBFGScriptedSequence) == 0x0000D8, "Wrong size on UBFGScriptedSequence");
static_assert(offsetof(UBFGScriptedSequence, M_pGameState) == 0x000030, "Member 'UBFGScriptedSequence::M_pGameState' has a wrong offset!");
static_assert(offsetof(UBFGScriptedSequence, M_pDebugContext) == 0x000038, "Member 'UBFGScriptedSequence::M_pDebugContext' has a wrong offset!");
static_assert(offsetof(UBFGScriptedSequence, M_apTasks) == 0x000040, "Member 'UBFGScriptedSequence::M_apTasks' has a wrong offset!");
static_assert(offsetof(UBFGScriptedSequence, M_pawnGameplayTagQuery) == 0x000058, "Member 'UBFGScriptedSequence::M_pawnGameplayTagQuery' has a wrong offset!");
static_assert(offsetof(UBFGScriptedSequence, M_softActorReference) == 0x0000A0, "Member 'UBFGScriptedSequence::M_softActorReference' has a wrong offset!");
static_assert(offsetof(UBFGScriptedSequence, M_pAgent) == 0x0000C8, "Member 'UBFGScriptedSequence::M_pAgent' has a wrong offset!");

// Class BFGCore.BFGScriptedSequence_Transient
// 0x0008 (0x00E0 - 0x00D8)
class UBFGScriptedSequence_Transient final : public UBFGScriptedSequence
{
public:
	uint8                                         Pad_D8[0x8];                                       // 0x00D8(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"BFGScriptedSequence_Transient">();
	}
	static class UBFGScriptedSequence_Transient* GetDefaultObj()
	{
		return GetDefaultObjImpl<UBFGScriptedSequence_Transient>();
	}
};
static_assert(alignof(UBFGScriptedSequence_Transient) == 0x000008, "Wrong alignment on UBFGScriptedSequence_Transient");
static_assert(sizeof(UBFGScriptedSequence_Transient) == 0x0000E0, "Wrong size on UBFGScriptedSequence_Transient");

// Class BFGCore.BFGEventTrigger_MainMissionOrChallengeQuestEnded
// 0x0000 (0x0040 - 0x0040)
class UBFGEventTrigger_MainMissionOrChallengeQuestEnded final : public UBFGEventTrigger
{
public:
	void OnMainMissionOrChallengeEnded();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"BFGEventTrigger_MainMissionOrChallengeQuestEnded">();
	}
	static class UBFGEventTrigger_MainMissionOrChallengeQuestEnded* GetDefaultObj()
	{
		return GetDefaultObjImpl<UBFGEventTrigger_MainMissionOrChallengeQuestEnded>();
	}
};
static_assert(alignof(UBFGEventTrigger_MainMissionOrChallengeQuestEnded) == 0x000008, "Wrong alignment on UBFGEventTrigger_MainMissionOrChallengeQuestEnded");
static_assert(sizeof(UBFGEventTrigger_MainMissionOrChallengeQuestEnded) == 0x000040, "Wrong size on UBFGEventTrigger_MainMissionOrChallengeQuestEnded");

// Class BFGCore.BFGDataSubscriberCollection
// 0x0010 (0x0038 - 0x0028)
class UBFGDataSubscriberCollection final : public UObject
{
public:
	TArray<TScriptInterface<class IBFGDataSubscriber>> M_aSubscribers;                                    // 0x0028(0x0010)(ZeroConstructor, UObjectWrapper, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"BFGDataSubscriberCollection">();
	}
	static class UBFGDataSubscriberCollection* GetDefaultObj()
	{
		return GetDefaultObjImpl<UBFGDataSubscriberCollection>();
	}
};
static_assert(alignof(UBFGDataSubscriberCollection) == 0x000008, "Wrong alignment on UBFGDataSubscriberCollection");
static_assert(sizeof(UBFGDataSubscriberCollection) == 0x000038, "Wrong size on UBFGDataSubscriberCollection");
static_assert(offsetof(UBFGDataSubscriberCollection, M_aSubscribers) == 0x000028, "Member 'UBFGDataSubscriberCollection::M_aSubscribers' has a wrong offset!");

// Class BFGCore.BFGActorComponent_MonetaryValue
// 0x0008 (0x0130 - 0x0128)
class UBFGActorComponent_MonetaryValue final : public UActorComponent
{
public:
	float                                         M_fMonetaryValue;                                  // 0x0128(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_12C[0x4];                                      // 0x012C(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void SetMonetaryValue(float _fValue);

	float GetMonetaryValue() const;
	bool HasMonetaryValue() const;
	void InitEffectComponent(class UBFGActorComponent_Effect* _pEffectComponent) const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"BFGActorComponent_MonetaryValue">();
	}
	static class UBFGActorComponent_MonetaryValue* GetDefaultObj()
	{
		return GetDefaultObjImpl<UBFGActorComponent_MonetaryValue>();
	}
};
static_assert(alignof(UBFGActorComponent_MonetaryValue) == 0x000008, "Wrong alignment on UBFGActorComponent_MonetaryValue");
static_assert(sizeof(UBFGActorComponent_MonetaryValue) == 0x000130, "Wrong size on UBFGActorComponent_MonetaryValue");
static_assert(offsetof(UBFGActorComponent_MonetaryValue, M_fMonetaryValue) == 0x000128, "Member 'UBFGActorComponent_MonetaryValue::M_fMonetaryValue' has a wrong offset!");

// Class BFGCore.BFGDataAsset_HighlightableSceneObject
// 0x0030 (0x0060 - 0x0030)
class UBFGDataAsset_HighlightableSceneObject final : public UDataAsset
{
public:
	TSoftClassPtr<class UClass>                   M_pHighlighterClass;                               // 0x0030(0x0028)(Edit, BlueprintVisible, BlueprintReadOnly, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EBFGHighlightableClippingStyle                M_eClippingStyle;                                  // 0x0058(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_59[0x7];                                       // 0x0059(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"BFGDataAsset_HighlightableSceneObject">();
	}
	static class UBFGDataAsset_HighlightableSceneObject* GetDefaultObj()
	{
		return GetDefaultObjImpl<UBFGDataAsset_HighlightableSceneObject>();
	}
};
static_assert(alignof(UBFGDataAsset_HighlightableSceneObject) == 0x000008, "Wrong alignment on UBFGDataAsset_HighlightableSceneObject");
static_assert(sizeof(UBFGDataAsset_HighlightableSceneObject) == 0x000060, "Wrong size on UBFGDataAsset_HighlightableSceneObject");
static_assert(offsetof(UBFGDataAsset_HighlightableSceneObject, M_pHighlighterClass) == 0x000030, "Member 'UBFGDataAsset_HighlightableSceneObject::M_pHighlighterClass' has a wrong offset!");
static_assert(offsetof(UBFGDataAsset_HighlightableSceneObject, M_eClippingStyle) == 0x000058, "Member 'UBFGDataAsset_HighlightableSceneObject::M_eClippingStyle' has a wrong offset!");

// Class BFGCore.BFGActorComponent_NPCBehaviorVO
// 0x0010 (0x0138 - 0x0128)
class UBFGActorComponent_NPCBehaviorVO : public UActorComponent
{
public:
	class ABFGNPCCharacterGameplay*               M_pCharacter;                                      // 0x0128(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	EBFGBehaviourState_NPC                        M_currentAIState;                                  // 0x0130(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	EBFGBehaviourState_NPC                        M_previousAIState;                                 // 0x0131(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_132[0x6];                                      // 0x0132(0x0006)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void Internal_OnAIAlertStateStatChanged(class AActor* _pOwner, class UBFGActorStat_uint8* _pStat);
	void Internal_OnPawnDamage(class UBFGActorComponent_PawnDamage* _pPawnDamage, float _fDamage, class AActor* _pDamageCauser, class UBFGDamageType* _pDamageType, const struct FVector& _rShotDirection, const struct FHitResult& _oHitResult);
	void OnAIStateChanged(EBFGBehaviourState_NPC _previousState, EBFGBehaviourState_NPC _newState, EBFGCuriosityReason_NPC _curiosityReason);
	void OnEvade(EBFGEvadeDirection _direction, class AActor* _pEvadeFromActor);
	void OnGameplayEffectTagActive(const struct FGameplayTag& _rTag);
	void OnGameplayEffectTagInactive(const struct FGameplayTag& _rTag);
	void OnHealthDamage(float _fDamage, class AActor* _pDamageCauser, const class UBFGDamageType* _pDamageType, const struct FVector& _rShotDirection, const struct FHitResult& _oHitResult, bool _bWasFriendlyFire);
	void OnPlayerBumped(const struct FVector& _vHitDirection, float _fVelocity, class AActor* _pHitByActor);
	void OnRanInFireline(class AActor* _pFirelineActor);
	void OnSawPlayerDisguise(class AActor* _pPlayerActor);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"BFGActorComponent_NPCBehaviorVO">();
	}
	static class UBFGActorComponent_NPCBehaviorVO* GetDefaultObj()
	{
		return GetDefaultObjImpl<UBFGActorComponent_NPCBehaviorVO>();
	}
};
static_assert(alignof(UBFGActorComponent_NPCBehaviorVO) == 0x000008, "Wrong alignment on UBFGActorComponent_NPCBehaviorVO");
static_assert(sizeof(UBFGActorComponent_NPCBehaviorVO) == 0x000138, "Wrong size on UBFGActorComponent_NPCBehaviorVO");
static_assert(offsetof(UBFGActorComponent_NPCBehaviorVO, M_pCharacter) == 0x000128, "Member 'UBFGActorComponent_NPCBehaviorVO::M_pCharacter' has a wrong offset!");
static_assert(offsetof(UBFGActorComponent_NPCBehaviorVO, M_currentAIState) == 0x000130, "Member 'UBFGActorComponent_NPCBehaviorVO::M_currentAIState' has a wrong offset!");
static_assert(offsetof(UBFGActorComponent_NPCBehaviorVO, M_previousAIState) == 0x000131, "Member 'UBFGActorComponent_NPCBehaviorVO::M_previousAIState' has a wrong offset!");

// Class BFGCore.BFGEventTrigger_SaveSystem
// 0x0008 (0x0048 - 0x0040)
class UBFGEventTrigger_SaveSystem final : public UBFGEventTrigger
{
public:
	uint8                                         Pad_40[0x8];                                       // 0x0040(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void OnLoadDone(class UBFGSaveSystem* _pSaveSystem, class UBFGSaveSystem_Action* _pAction);
	void OnSaveDone(class UBFGSaveSystem* _pSaveSystem, class UBFGSaveSystem_Action* _pAction);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"BFGEventTrigger_SaveSystem">();
	}
	static class UBFGEventTrigger_SaveSystem* GetDefaultObj()
	{
		return GetDefaultObjImpl<UBFGEventTrigger_SaveSystem>();
	}
};
static_assert(alignof(UBFGEventTrigger_SaveSystem) == 0x000008, "Wrong alignment on UBFGEventTrigger_SaveSystem");
static_assert(sizeof(UBFGEventTrigger_SaveSystem) == 0x000048, "Wrong size on UBFGEventTrigger_SaveSystem");

// Class BFGCore.BFGTaskNode_Boss_FireCloseSaucer
// 0x0030 (0x00D0 - 0x00A0)
class UBFGTaskNode_Boss_FireCloseSaucer final : public UBFGTaskNode_BossBase
{
public:
	struct FMetaPattern                           M_oMetaPattern;                                    // 0x00A0(0x0028)(NativeAccessSpecifierPublic)
	uint8                                         Pad_C8[0x8];                                       // 0x00C8(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"BFGTaskNode_Boss_FireCloseSaucer">();
	}
	static class UBFGTaskNode_Boss_FireCloseSaucer* GetDefaultObj()
	{
		return GetDefaultObjImpl<UBFGTaskNode_Boss_FireCloseSaucer>();
	}
};
static_assert(alignof(UBFGTaskNode_Boss_FireCloseSaucer) == 0x000008, "Wrong alignment on UBFGTaskNode_Boss_FireCloseSaucer");
static_assert(sizeof(UBFGTaskNode_Boss_FireCloseSaucer) == 0x0000D0, "Wrong size on UBFGTaskNode_Boss_FireCloseSaucer");
static_assert(offsetof(UBFGTaskNode_Boss_FireCloseSaucer, M_oMetaPattern) == 0x0000A0, "Member 'UBFGTaskNode_Boss_FireCloseSaucer::M_oMetaPattern' has a wrong offset!");

// Class BFGCore.BFGActorComponent_NPCCharacterMovement
// 0x01F0 (0x0AE0 - 0x08F0)
class UBFGActorComponent_NPCCharacterMovement : public UBFGActorComponent_CharacterMovement
{
public:
	TMap<EBFGNPCCharacter_MoveSpeed, float>       M_aMaxMoveSpeed;                                   // 0x08E8(0x0050)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, NativeAccessSpecifierPublic)
	TMap<EBFGNPCCharacter_MoveSpeed, float>       M_aMaxAcceleration;                                // 0x0938(0x0050)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, NativeAccessSpecifierPublic)
	uint8                                         Pad_988[0x18];                                     // 0x0988(0x0018)(Fixing Size After Last Property [ Dumper-7 ])
	bool                                          M_bForceNavWalking;                                // 0x09A0(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_9A1[0x3];                                      // 0x09A1(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         M_fEvadeDistance;                                  // 0x09A4(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         M_fEvadeDuration;                                  // 0x09A8(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         M_fBumpDistance;                                   // 0x09AC(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          M_bUseAimRotation;                                 // 0x09B0(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          M_bUseAutoFocusFromWeapon;                         // 0x09B1(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          M_bTurnOffCatchUpDuringMovement;                   // 0x09B2(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          M_bIsAimRotationCatchUpActive;                     // 0x09B3(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         M_fAimYawThreshold;                                // 0x09B4(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         M_fThreshold1RotationAngle;                        // 0x09B8(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         M_fAimYawThreshold2;                               // 0x09BC(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         M_fThreshold2RotationAngle;                        // 0x09C0(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         M_fAimRotationStartDelay;                          // 0x09C4(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_9C8[0x4];                                      // 0x09C8(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         M_fAimRotationCatchUpTime;                         // 0x09CC(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_9D0[0x42];                                     // 0x09D0(0x0042)(Fixing Size After Last Property [ Dumper-7 ])
	bool                                          M_bDisableNavWalkingCollisionSwap;                 // 0x0A12(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	EBFGNPCCharacter_MoveSpeed                    M_moveSpeed;                                       // 0x0A13(0x0001)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          M_bIsFourFeet;                                     // 0x0A14(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_A15[0x3];                                      // 0x0A15(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         M_fNPCHalfLength;                                  // 0x0A18(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         M_fMinTurnRadius;                                  // 0x0A1C(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         M_fDirectionToSpeedMaxAllowedDelta;                // 0x0A20(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         M_fStartRunDuration;                               // 0x0A24(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         M_fStartRunMinRadius;                              // 0x0A28(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         M_fSpeedModeTime;                                  // 0x0A2C(0x0004)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         M_fCurrentStoppingTime;                            // 0x0A30(0x0004)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         M_fStopDurationInUse;                              // 0x0A34(0x0004)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TSoftObjectPtr<class UCurveFloat>             M_decelerationCurve;                               // 0x0A38(0x0028)(Edit, BlueprintVisible, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          M_bIsStopping;                                     // 0x0A60(0x0001)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_A61[0x3];                                      // 0x0A61(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         M_fInitialSpeed;                                   // 0x0A64(0x0004)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         M_fStopDuration;                                   // 0x0A68(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         M_fStopMaxDeceleration;                            // 0x0A6C(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         M_fTurningRate;                                    // 0x0A70(0x0004)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         M_fNetworkAgentOverrideSpeed;                      // 0x0A74(0x0004)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	EBFGNPCCharacter_MoveSpeed                    M_eNetworkAgentOverrideMoveSpeed;                  // 0x0A78(0x0001)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_A79[0x7];                                      // 0x0A79(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	class UBFGActorComponent_EquipmentManager*    M_pOwnerEquipmentManager;                          // 0x0A80(0x0008)(ExportObject, ZeroConstructor, Transient, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UBFGActorComponent_Animation*           M_pOwnerAnimComponent;                             // 0x0A88(0x0008)(ExportObject, ZeroConstructor, Transient, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_A90[0x38];                                     // 0x0A90(0x0038)(Fixing Size After Last Property [ Dumper-7 ])
	class AActor*                                 M_pOverrideFocusActor;                             // 0x0AC8(0x0008)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_AD0[0x10];                                     // 0x0AD0(0x0010)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void MoveSpeedAutoFill();

	EBFGNPCCharacter_MoveSpeed GetMoveSpeed() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"BFGActorComponent_NPCCharacterMovement">();
	}
	static class UBFGActorComponent_NPCCharacterMovement* GetDefaultObj()
	{
		return GetDefaultObjImpl<UBFGActorComponent_NPCCharacterMovement>();
	}
};
static_assert(alignof(UBFGActorComponent_NPCCharacterMovement) == 0x000010, "Wrong alignment on UBFGActorComponent_NPCCharacterMovement");
static_assert(sizeof(UBFGActorComponent_NPCCharacterMovement) == 0x000AE0, "Wrong size on UBFGActorComponent_NPCCharacterMovement");
static_assert(offsetof(UBFGActorComponent_NPCCharacterMovement, M_aMaxMoveSpeed) == 0x0008E8, "Member 'UBFGActorComponent_NPCCharacterMovement::M_aMaxMoveSpeed' has a wrong offset!");
static_assert(offsetof(UBFGActorComponent_NPCCharacterMovement, M_aMaxAcceleration) == 0x000938, "Member 'UBFGActorComponent_NPCCharacterMovement::M_aMaxAcceleration' has a wrong offset!");
static_assert(offsetof(UBFGActorComponent_NPCCharacterMovement, M_bForceNavWalking) == 0x0009A0, "Member 'UBFGActorComponent_NPCCharacterMovement::M_bForceNavWalking' has a wrong offset!");
static_assert(offsetof(UBFGActorComponent_NPCCharacterMovement, M_fEvadeDistance) == 0x0009A4, "Member 'UBFGActorComponent_NPCCharacterMovement::M_fEvadeDistance' has a wrong offset!");
static_assert(offsetof(UBFGActorComponent_NPCCharacterMovement, M_fEvadeDuration) == 0x0009A8, "Member 'UBFGActorComponent_NPCCharacterMovement::M_fEvadeDuration' has a wrong offset!");
static_assert(offsetof(UBFGActorComponent_NPCCharacterMovement, M_fBumpDistance) == 0x0009AC, "Member 'UBFGActorComponent_NPCCharacterMovement::M_fBumpDistance' has a wrong offset!");
static_assert(offsetof(UBFGActorComponent_NPCCharacterMovement, M_bUseAimRotation) == 0x0009B0, "Member 'UBFGActorComponent_NPCCharacterMovement::M_bUseAimRotation' has a wrong offset!");
static_assert(offsetof(UBFGActorComponent_NPCCharacterMovement, M_bUseAutoFocusFromWeapon) == 0x0009B1, "Member 'UBFGActorComponent_NPCCharacterMovement::M_bUseAutoFocusFromWeapon' has a wrong offset!");
static_assert(offsetof(UBFGActorComponent_NPCCharacterMovement, M_bTurnOffCatchUpDuringMovement) == 0x0009B2, "Member 'UBFGActorComponent_NPCCharacterMovement::M_bTurnOffCatchUpDuringMovement' has a wrong offset!");
static_assert(offsetof(UBFGActorComponent_NPCCharacterMovement, M_bIsAimRotationCatchUpActive) == 0x0009B3, "Member 'UBFGActorComponent_NPCCharacterMovement::M_bIsAimRotationCatchUpActive' has a wrong offset!");
static_assert(offsetof(UBFGActorComponent_NPCCharacterMovement, M_fAimYawThreshold) == 0x0009B4, "Member 'UBFGActorComponent_NPCCharacterMovement::M_fAimYawThreshold' has a wrong offset!");
static_assert(offsetof(UBFGActorComponent_NPCCharacterMovement, M_fThreshold1RotationAngle) == 0x0009B8, "Member 'UBFGActorComponent_NPCCharacterMovement::M_fThreshold1RotationAngle' has a wrong offset!");
static_assert(offsetof(UBFGActorComponent_NPCCharacterMovement, M_fAimYawThreshold2) == 0x0009BC, "Member 'UBFGActorComponent_NPCCharacterMovement::M_fAimYawThreshold2' has a wrong offset!");
static_assert(offsetof(UBFGActorComponent_NPCCharacterMovement, M_fThreshold2RotationAngle) == 0x0009C0, "Member 'UBFGActorComponent_NPCCharacterMovement::M_fThreshold2RotationAngle' has a wrong offset!");
static_assert(offsetof(UBFGActorComponent_NPCCharacterMovement, M_fAimRotationStartDelay) == 0x0009C4, "Member 'UBFGActorComponent_NPCCharacterMovement::M_fAimRotationStartDelay' has a wrong offset!");
static_assert(offsetof(UBFGActorComponent_NPCCharacterMovement, M_fAimRotationCatchUpTime) == 0x0009CC, "Member 'UBFGActorComponent_NPCCharacterMovement::M_fAimRotationCatchUpTime' has a wrong offset!");
static_assert(offsetof(UBFGActorComponent_NPCCharacterMovement, M_bDisableNavWalkingCollisionSwap) == 0x000A12, "Member 'UBFGActorComponent_NPCCharacterMovement::M_bDisableNavWalkingCollisionSwap' has a wrong offset!");
static_assert(offsetof(UBFGActorComponent_NPCCharacterMovement, M_moveSpeed) == 0x000A13, "Member 'UBFGActorComponent_NPCCharacterMovement::M_moveSpeed' has a wrong offset!");
static_assert(offsetof(UBFGActorComponent_NPCCharacterMovement, M_bIsFourFeet) == 0x000A14, "Member 'UBFGActorComponent_NPCCharacterMovement::M_bIsFourFeet' has a wrong offset!");
static_assert(offsetof(UBFGActorComponent_NPCCharacterMovement, M_fNPCHalfLength) == 0x000A18, "Member 'UBFGActorComponent_NPCCharacterMovement::M_fNPCHalfLength' has a wrong offset!");
static_assert(offsetof(UBFGActorComponent_NPCCharacterMovement, M_fMinTurnRadius) == 0x000A1C, "Member 'UBFGActorComponent_NPCCharacterMovement::M_fMinTurnRadius' has a wrong offset!");
static_assert(offsetof(UBFGActorComponent_NPCCharacterMovement, M_fDirectionToSpeedMaxAllowedDelta) == 0x000A20, "Member 'UBFGActorComponent_NPCCharacterMovement::M_fDirectionToSpeedMaxAllowedDelta' has a wrong offset!");
static_assert(offsetof(UBFGActorComponent_NPCCharacterMovement, M_fStartRunDuration) == 0x000A24, "Member 'UBFGActorComponent_NPCCharacterMovement::M_fStartRunDuration' has a wrong offset!");
static_assert(offsetof(UBFGActorComponent_NPCCharacterMovement, M_fStartRunMinRadius) == 0x000A28, "Member 'UBFGActorComponent_NPCCharacterMovement::M_fStartRunMinRadius' has a wrong offset!");
static_assert(offsetof(UBFGActorComponent_NPCCharacterMovement, M_fSpeedModeTime) == 0x000A2C, "Member 'UBFGActorComponent_NPCCharacterMovement::M_fSpeedModeTime' has a wrong offset!");
static_assert(offsetof(UBFGActorComponent_NPCCharacterMovement, M_fCurrentStoppingTime) == 0x000A30, "Member 'UBFGActorComponent_NPCCharacterMovement::M_fCurrentStoppingTime' has a wrong offset!");
static_assert(offsetof(UBFGActorComponent_NPCCharacterMovement, M_fStopDurationInUse) == 0x000A34, "Member 'UBFGActorComponent_NPCCharacterMovement::M_fStopDurationInUse' has a wrong offset!");
static_assert(offsetof(UBFGActorComponent_NPCCharacterMovement, M_decelerationCurve) == 0x000A38, "Member 'UBFGActorComponent_NPCCharacterMovement::M_decelerationCurve' has a wrong offset!");
static_assert(offsetof(UBFGActorComponent_NPCCharacterMovement, M_bIsStopping) == 0x000A60, "Member 'UBFGActorComponent_NPCCharacterMovement::M_bIsStopping' has a wrong offset!");
static_assert(offsetof(UBFGActorComponent_NPCCharacterMovement, M_fInitialSpeed) == 0x000A64, "Member 'UBFGActorComponent_NPCCharacterMovement::M_fInitialSpeed' has a wrong offset!");
static_assert(offsetof(UBFGActorComponent_NPCCharacterMovement, M_fStopDuration) == 0x000A68, "Member 'UBFGActorComponent_NPCCharacterMovement::M_fStopDuration' has a wrong offset!");
static_assert(offsetof(UBFGActorComponent_NPCCharacterMovement, M_fStopMaxDeceleration) == 0x000A6C, "Member 'UBFGActorComponent_NPCCharacterMovement::M_fStopMaxDeceleration' has a wrong offset!");
static_assert(offsetof(UBFGActorComponent_NPCCharacterMovement, M_fTurningRate) == 0x000A70, "Member 'UBFGActorComponent_NPCCharacterMovement::M_fTurningRate' has a wrong offset!");
static_assert(offsetof(UBFGActorComponent_NPCCharacterMovement, M_fNetworkAgentOverrideSpeed) == 0x000A74, "Member 'UBFGActorComponent_NPCCharacterMovement::M_fNetworkAgentOverrideSpeed' has a wrong offset!");
static_assert(offsetof(UBFGActorComponent_NPCCharacterMovement, M_eNetworkAgentOverrideMoveSpeed) == 0x000A78, "Member 'UBFGActorComponent_NPCCharacterMovement::M_eNetworkAgentOverrideMoveSpeed' has a wrong offset!");
static_assert(offsetof(UBFGActorComponent_NPCCharacterMovement, M_pOwnerEquipmentManager) == 0x000A80, "Member 'UBFGActorComponent_NPCCharacterMovement::M_pOwnerEquipmentManager' has a wrong offset!");
static_assert(offsetof(UBFGActorComponent_NPCCharacterMovement, M_pOwnerAnimComponent) == 0x000A88, "Member 'UBFGActorComponent_NPCCharacterMovement::M_pOwnerAnimComponent' has a wrong offset!");
static_assert(offsetof(UBFGActorComponent_NPCCharacterMovement, M_pOverrideFocusActor) == 0x000AC8, "Member 'UBFGActorComponent_NPCCharacterMovement::M_pOverrideFocusActor' has a wrong offset!");

// Class BFGCore.BFGActorComponent_NPCCharacterMovement_Cluckthulhu
// 0x0000 (0x0AE0 - 0x0AE0)
class UBFGActorComponent_NPCCharacterMovement_Cluckthulhu final : public UBFGActorComponent_NPCCharacterMovement
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"BFGActorComponent_NPCCharacterMovement_Cluckthulhu">();
	}
	static class UBFGActorComponent_NPCCharacterMovement_Cluckthulhu* GetDefaultObj()
	{
		return GetDefaultObjImpl<UBFGActorComponent_NPCCharacterMovement_Cluckthulhu>();
	}
};
static_assert(alignof(UBFGActorComponent_NPCCharacterMovement_Cluckthulhu) == 0x000010, "Wrong alignment on UBFGActorComponent_NPCCharacterMovement_Cluckthulhu");
static_assert(sizeof(UBFGActorComponent_NPCCharacterMovement_Cluckthulhu) == 0x000AE0, "Wrong size on UBFGActorComponent_NPCCharacterMovement_Cluckthulhu");

// Class BFGCore.BFGEventTrigger_OverlapActor
// 0x0128 (0x0168 - 0x0040)
class UBFGEventTrigger_OverlapActor final : public UBFGEventTrigger
{
public:
	struct FBFGActorBinding                       M_pawnBinding;                                     // 0x0040(0x0090)(Transient, Protected, NativeAccessSpecifierProtected)
	struct FBFGActorBinding                       M_triggerBinding;                                  // 0x00D0(0x0090)(Transient, Protected, NativeAccessSpecifierProtected)
	uint8                                         Pad_160[0x8];                                      // 0x0160(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void OnOverlapActor(class AActor* _pActor, class AActor* _pOverlapsWith);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"BFGEventTrigger_OverlapActor">();
	}
	static class UBFGEventTrigger_OverlapActor* GetDefaultObj()
	{
		return GetDefaultObjImpl<UBFGEventTrigger_OverlapActor>();
	}
};
static_assert(alignof(UBFGEventTrigger_OverlapActor) == 0x000008, "Wrong alignment on UBFGEventTrigger_OverlapActor");
static_assert(sizeof(UBFGEventTrigger_OverlapActor) == 0x000168, "Wrong size on UBFGEventTrigger_OverlapActor");
static_assert(offsetof(UBFGEventTrigger_OverlapActor, M_pawnBinding) == 0x000040, "Member 'UBFGEventTrigger_OverlapActor::M_pawnBinding' has a wrong offset!");
static_assert(offsetof(UBFGEventTrigger_OverlapActor, M_triggerBinding) == 0x0000D0, "Member 'UBFGEventTrigger_OverlapActor::M_triggerBinding' has a wrong offset!");

// Class BFGCore.BFGTaskNode_Boss_FireRBPWreck
// 0x0010 (0x00B0 - 0x00A0)
class UBFGTaskNode_Boss_FireRBPWreck final : public UBFGTaskNode_BossBase
{
public:
	uint8                                         Pad_A0[0x10];                                      // 0x00A0(0x0010)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void Firing();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"BFGTaskNode_Boss_FireRBPWreck">();
	}
	static class UBFGTaskNode_Boss_FireRBPWreck* GetDefaultObj()
	{
		return GetDefaultObjImpl<UBFGTaskNode_Boss_FireRBPWreck>();
	}
};
static_assert(alignof(UBFGTaskNode_Boss_FireRBPWreck) == 0x000008, "Wrong alignment on UBFGTaskNode_Boss_FireRBPWreck");
static_assert(sizeof(UBFGTaskNode_Boss_FireRBPWreck) == 0x0000B0, "Wrong size on UBFGTaskNode_Boss_FireRBPWreck");

// Class BFGCore.BFGActorComponent_Objective
// 0x0020 (0x0148 - 0x0128)
class UBFGActorComponent_Objective final : public UActorComponent
{
public:
	bool                                          M_bShowMarkers;                                    // 0x0128(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_129[0x7];                                      // 0x0129(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<struct FBFGObjectiveMarkerInfoEntry>   M_aOverrides;                                      // 0x0130(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, ContainsInstancedReference, Protected, NativeAccessSpecifierProtected)
	uint8                                         Pad_140[0x8];                                      // 0x0140(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"BFGActorComponent_Objective">();
	}
	static class UBFGActorComponent_Objective* GetDefaultObj()
	{
		return GetDefaultObjImpl<UBFGActorComponent_Objective>();
	}
};
static_assert(alignof(UBFGActorComponent_Objective) == 0x000008, "Wrong alignment on UBFGActorComponent_Objective");
static_assert(sizeof(UBFGActorComponent_Objective) == 0x000148, "Wrong size on UBFGActorComponent_Objective");
static_assert(offsetof(UBFGActorComponent_Objective, M_bShowMarkers) == 0x000128, "Member 'UBFGActorComponent_Objective::M_bShowMarkers' has a wrong offset!");
static_assert(offsetof(UBFGActorComponent_Objective, M_aOverrides) == 0x000130, "Member 'UBFGActorComponent_Objective::M_aOverrides' has a wrong offset!");

// Class BFGCore.BFGActorComponent_ObjectiveMarkerScreen
// 0x0020 (0x0148 - 0x0128)
class UBFGActorComponent_ObjectiveMarkerScreen : public UActorComponent
{
public:
	uint8                                         Pad_128[0xC];                                      // 0x0128(0x000C)(Fixing Size After Last Property [ Dumper-7 ])
	class FName                                   M_oTagOnScreenMarker;                              // 0x0134(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class FName                                   M_oTagOffScreenMarker;                             // 0x013C(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_144[0x4];                                      // 0x0144(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void OnMarkerAttached(const struct FBFGObjectiveMarkerInfoEntry& _info);
	void RemoveMarker();
	void SetMarkerEnabled(bool _bEnabled);
	void SetMarkerFadedInDistance(float _fRadius);
	void SetMarkerFadedOutDistance(float _fRadius);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"BFGActorComponent_ObjectiveMarkerScreen">();
	}
	static class UBFGActorComponent_ObjectiveMarkerScreen* GetDefaultObj()
	{
		return GetDefaultObjImpl<UBFGActorComponent_ObjectiveMarkerScreen>();
	}
};
static_assert(alignof(UBFGActorComponent_ObjectiveMarkerScreen) == 0x000008, "Wrong alignment on UBFGActorComponent_ObjectiveMarkerScreen");
static_assert(sizeof(UBFGActorComponent_ObjectiveMarkerScreen) == 0x000148, "Wrong size on UBFGActorComponent_ObjectiveMarkerScreen");
static_assert(offsetof(UBFGActorComponent_ObjectiveMarkerScreen, M_oTagOnScreenMarker) == 0x000134, "Member 'UBFGActorComponent_ObjectiveMarkerScreen::M_oTagOnScreenMarker' has a wrong offset!");
static_assert(offsetof(UBFGActorComponent_ObjectiveMarkerScreen, M_oTagOffScreenMarker) == 0x00013C, "Member 'UBFGActorComponent_ObjectiveMarkerScreen::M_oTagOffScreenMarker' has a wrong offset!");

// Class BFGCore.BFGProjectile_Beam
// 0x0148 (0x0620 - 0x04D8)
class ABFGProjectile_Beam : public ABFGProjectile
{
public:
	float                                         M_fBeamLength;                                     // 0x04D8(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         M_fDamagePerTick;                                  // 0x04DC(0x0004)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          M_bStickyBeam;                                     // 0x04E0(0x0001)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_4E1[0x3];                                      // 0x04E1(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         M_fStickyMaxAngle;                                 // 0x04E4(0x0004)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         M_fTickRate;                                       // 0x04E8(0x0004)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         M_fStartupDelay;                                   // 0x04EC(0x0004)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_4F0[0x4];                                      // 0x04F0(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	bool                                          M_bIsBeamActive;                                   // 0x04F4(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_4F5[0xB];                                      // 0x04F5(0x000B)(Fixing Size After Last Property [ Dumper-7 ])
	struct FCharacterAimData                      M_currentAimData;                                  // 0x0500(0x00CC)(NoDestructor, ContainsInstancedReference, Protected, NativeAccessSpecifierProtected)
	uint8                                         Pad_5CC[0xC];                                      // 0x05CC(0x000C)(Fixing Size After Last Property [ Dumper-7 ])
	bool                                          M_bCreateDynamicObstacles;                         // 0x05D8(0x0001)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_5D9[0x3];                                      // 0x05D9(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         M_fDynamicObstacleSize;                            // 0x05DC(0x0004)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         M_fDynamicObstacleMaxDist;                         // 0x05E0(0x0004)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         M_fDynamicObstacleLifetime;                        // 0x05E4(0x0004)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	int32                                         M_iMaxDynamicObstacles;                            // 0x05E8(0x0004)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_5EC[0x4];                                      // 0x05EC(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	TSubclassOf<class UNavAreaBase>               M_pNavAreaClass;                                   // 0x05F0(0x0008)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UBFGDynamicObstaclePool_Sphere*         M_pDynamicObstaclePool;                            // 0x05F8(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TArray<struct FBFGBeamObstacle>               M_aDynamicObstacles;                               // 0x0600(0x0010)(ZeroConstructor, Transient, Protected, NativeAccessSpecifierProtected)
	uint8                                         Pad_610[0x10];                                     // 0x0610(0x0010)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void OnBeamDelayStarted(const struct FVector& _vTargetLocation, bool _bHitTarget, bool _bHitEnvironment, const struct FVector& _vImpactNormal);
	void StartBeam(const struct FVector& _vTargetLocation, bool _bHitTarget, bool _bHitEnvironment, const struct FVector& _vImpactNormal);
	void StopBeam();
	void UpdateBeam(const struct FVector& _vTargetLocation, bool _bHitTarget, const struct FVector& _vImpactNormal);
	void UpdateBeamWhileInactive(const struct FVector& _vTargetLocation, bool _bHitTarget, const struct FVector& _vImpactNormal);

	const struct FCharacterAimData GetCurrentAimData() const;
	float GetStartupTimer() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"BFGProjectile_Beam">();
	}
	static class ABFGProjectile_Beam* GetDefaultObj()
	{
		return GetDefaultObjImpl<ABFGProjectile_Beam>();
	}
};
static_assert(alignof(ABFGProjectile_Beam) == 0x000008, "Wrong alignment on ABFGProjectile_Beam");
static_assert(sizeof(ABFGProjectile_Beam) == 0x000620, "Wrong size on ABFGProjectile_Beam");
static_assert(offsetof(ABFGProjectile_Beam, M_fBeamLength) == 0x0004D8, "Member 'ABFGProjectile_Beam::M_fBeamLength' has a wrong offset!");
static_assert(offsetof(ABFGProjectile_Beam, M_fDamagePerTick) == 0x0004DC, "Member 'ABFGProjectile_Beam::M_fDamagePerTick' has a wrong offset!");
static_assert(offsetof(ABFGProjectile_Beam, M_bStickyBeam) == 0x0004E0, "Member 'ABFGProjectile_Beam::M_bStickyBeam' has a wrong offset!");
static_assert(offsetof(ABFGProjectile_Beam, M_fStickyMaxAngle) == 0x0004E4, "Member 'ABFGProjectile_Beam::M_fStickyMaxAngle' has a wrong offset!");
static_assert(offsetof(ABFGProjectile_Beam, M_fTickRate) == 0x0004E8, "Member 'ABFGProjectile_Beam::M_fTickRate' has a wrong offset!");
static_assert(offsetof(ABFGProjectile_Beam, M_fStartupDelay) == 0x0004EC, "Member 'ABFGProjectile_Beam::M_fStartupDelay' has a wrong offset!");
static_assert(offsetof(ABFGProjectile_Beam, M_bIsBeamActive) == 0x0004F4, "Member 'ABFGProjectile_Beam::M_bIsBeamActive' has a wrong offset!");
static_assert(offsetof(ABFGProjectile_Beam, M_currentAimData) == 0x000500, "Member 'ABFGProjectile_Beam::M_currentAimData' has a wrong offset!");
static_assert(offsetof(ABFGProjectile_Beam, M_bCreateDynamicObstacles) == 0x0005D8, "Member 'ABFGProjectile_Beam::M_bCreateDynamicObstacles' has a wrong offset!");
static_assert(offsetof(ABFGProjectile_Beam, M_fDynamicObstacleSize) == 0x0005DC, "Member 'ABFGProjectile_Beam::M_fDynamicObstacleSize' has a wrong offset!");
static_assert(offsetof(ABFGProjectile_Beam, M_fDynamicObstacleMaxDist) == 0x0005E0, "Member 'ABFGProjectile_Beam::M_fDynamicObstacleMaxDist' has a wrong offset!");
static_assert(offsetof(ABFGProjectile_Beam, M_fDynamicObstacleLifetime) == 0x0005E4, "Member 'ABFGProjectile_Beam::M_fDynamicObstacleLifetime' has a wrong offset!");
static_assert(offsetof(ABFGProjectile_Beam, M_iMaxDynamicObstacles) == 0x0005E8, "Member 'ABFGProjectile_Beam::M_iMaxDynamicObstacles' has a wrong offset!");
static_assert(offsetof(ABFGProjectile_Beam, M_pNavAreaClass) == 0x0005F0, "Member 'ABFGProjectile_Beam::M_pNavAreaClass' has a wrong offset!");
static_assert(offsetof(ABFGProjectile_Beam, M_pDynamicObstaclePool) == 0x0005F8, "Member 'ABFGProjectile_Beam::M_pDynamicObstaclePool' has a wrong offset!");
static_assert(offsetof(ABFGProjectile_Beam, M_aDynamicObstacles) == 0x000600, "Member 'ABFGProjectile_Beam::M_aDynamicObstacles' has a wrong offset!");

// Class BFGCore.BFGProjectile_Beam_Roboprez
// 0x0040 (0x0660 - 0x0620)
class ABFGProjectile_Beam_Roboprez final : public ABFGProjectile_Beam
{
public:
	class UStaticMeshComponent*                   M_pBeamFanMesh;                                    // 0x0620(0x0008)(Edit, BlueprintVisible, ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TArray<class AActor*>                         M_aActorsAwaitingDamageTick;                       // 0x0628(0x0010)(ZeroConstructor, Protected, NativeAccessSpecifierProtected)
	class USceneComponent*                        M_pRootComponent;                                  // 0x0638(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_640[0x20];                                     // 0x0640(0x0020)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void OnBeamDamageTick(class AActor* _pActorToDamage);
	void OnBeamDimensionsChanged();
	void OnBeamOverlapBegin(class UPrimitiveComponent* OverlappedComp, class AActor* OtherActor, class UPrimitiveComponent* OtherComp, int32 OtherBodyIndex, bool bFromSweep, const struct FHitResult& SweepResult);
	void OnBeamOverlapEnd(class UPrimitiveComponent* OverlappedComp, class AActor* OtherActor, class UPrimitiveComponent* OtherComp, int32 OtherBodyIndex);

	float GetBeamAngle() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"BFGProjectile_Beam_Roboprez">();
	}
	static class ABFGProjectile_Beam_Roboprez* GetDefaultObj()
	{
		return GetDefaultObjImpl<ABFGProjectile_Beam_Roboprez>();
	}
};
static_assert(alignof(ABFGProjectile_Beam_Roboprez) == 0x000008, "Wrong alignment on ABFGProjectile_Beam_Roboprez");
static_assert(sizeof(ABFGProjectile_Beam_Roboprez) == 0x000660, "Wrong size on ABFGProjectile_Beam_Roboprez");
static_assert(offsetof(ABFGProjectile_Beam_Roboprez, M_pBeamFanMesh) == 0x000620, "Member 'ABFGProjectile_Beam_Roboprez::M_pBeamFanMesh' has a wrong offset!");
static_assert(offsetof(ABFGProjectile_Beam_Roboprez, M_aActorsAwaitingDamageTick) == 0x000628, "Member 'ABFGProjectile_Beam_Roboprez::M_aActorsAwaitingDamageTick' has a wrong offset!");
static_assert(offsetof(ABFGProjectile_Beam_Roboprez, M_pRootComponent) == 0x000638, "Member 'ABFGProjectile_Beam_Roboprez::M_pRootComponent' has a wrong offset!");

// Class BFGCore.BFGSensor_Alerted_ResetTimeoutWhileSee
// 0x0000 (0x0040 - 0x0040)
class UBFGSensor_Alerted_ResetTimeoutWhileSee final : public UBFGSensor
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"BFGSensor_Alerted_ResetTimeoutWhileSee">();
	}
	static class UBFGSensor_Alerted_ResetTimeoutWhileSee* GetDefaultObj()
	{
		return GetDefaultObjImpl<UBFGSensor_Alerted_ResetTimeoutWhileSee>();
	}
};
static_assert(alignof(UBFGSensor_Alerted_ResetTimeoutWhileSee) == 0x000008, "Wrong alignment on UBFGSensor_Alerted_ResetTimeoutWhileSee");
static_assert(sizeof(UBFGSensor_Alerted_ResetTimeoutWhileSee) == 0x000040, "Wrong size on UBFGSensor_Alerted_ResetTimeoutWhileSee");

// Class BFGCore.BFGEventTrigger_KilledActor
// 0x0170 (0x01B0 - 0x0040)
class UBFGEventTrigger_KilledActor final : public UBFGEventTrigger
{
public:
	struct FBFGActorBinding                       M_actorBinding;                                    // 0x0040(0x0090)(Transient, Protected, NativeAccessSpecifierProtected)
	struct FGameplayTagQuery                      M_queryDamageType;                                 // 0x00D0(0x0048)(Transient, Protected, NativeAccessSpecifierProtected)
	struct FGameplayTagQuery                      M_queryDamageInstigator;                           // 0x0118(0x0048)(Transient, Protected, NativeAccessSpecifierProtected)
	struct FGameplayTagQuery                      M_queryDamageSource;                               // 0x0160(0x0048)(Transient, Protected, NativeAccessSpecifierProtected)
	uint8                                         Pad_1A8[0x8];                                      // 0x01A8(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void OnKilledActor(class AController* _pInstigator, class AActor* _pDamageSource, class AActor* _pKilled, TSubclassOf<class UDamageType> _damageType);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"BFGEventTrigger_KilledActor">();
	}
	static class UBFGEventTrigger_KilledActor* GetDefaultObj()
	{
		return GetDefaultObjImpl<UBFGEventTrigger_KilledActor>();
	}
};
static_assert(alignof(UBFGEventTrigger_KilledActor) == 0x000008, "Wrong alignment on UBFGEventTrigger_KilledActor");
static_assert(sizeof(UBFGEventTrigger_KilledActor) == 0x0001B0, "Wrong size on UBFGEventTrigger_KilledActor");
static_assert(offsetof(UBFGEventTrigger_KilledActor, M_actorBinding) == 0x000040, "Member 'UBFGEventTrigger_KilledActor::M_actorBinding' has a wrong offset!");
static_assert(offsetof(UBFGEventTrigger_KilledActor, M_queryDamageType) == 0x0000D0, "Member 'UBFGEventTrigger_KilledActor::M_queryDamageType' has a wrong offset!");
static_assert(offsetof(UBFGEventTrigger_KilledActor, M_queryDamageInstigator) == 0x000118, "Member 'UBFGEventTrigger_KilledActor::M_queryDamageInstigator' has a wrong offset!");
static_assert(offsetof(UBFGEventTrigger_KilledActor, M_queryDamageSource) == 0x000160, "Member 'UBFGEventTrigger_KilledActor::M_queryDamageSource' has a wrong offset!");

// Class BFGCore.BFGActorComponent_OOBNotifier
// 0x0010 (0x0138 - 0x0128)
class UBFGActorComponent_OOBNotifier : public UActorComponent
{
public:
	class ABFGMissionBoundaries*                  M_pLastTarget;                                     // 0x0128(0x0008)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class ABFGMissionBoundaries*                  M_pTarget;                                         // 0x0130(0x0008)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"BFGActorComponent_OOBNotifier">();
	}
	static class UBFGActorComponent_OOBNotifier* GetDefaultObj()
	{
		return GetDefaultObjImpl<UBFGActorComponent_OOBNotifier>();
	}
};
static_assert(alignof(UBFGActorComponent_OOBNotifier) == 0x000008, "Wrong alignment on UBFGActorComponent_OOBNotifier");
static_assert(sizeof(UBFGActorComponent_OOBNotifier) == 0x000138, "Wrong size on UBFGActorComponent_OOBNotifier");
static_assert(offsetof(UBFGActorComponent_OOBNotifier, M_pLastTarget) == 0x000128, "Member 'UBFGActorComponent_OOBNotifier::M_pLastTarget' has a wrong offset!");
static_assert(offsetof(UBFGActorComponent_OOBNotifier, M_pTarget) == 0x000130, "Member 'UBFGActorComponent_OOBNotifier::M_pTarget' has a wrong offset!");

// Class BFGCore.BFGSensor_CooldownUnlessReceivedDamage
// 0x0008 (0x0048 - 0x0040)
class UBFGSensor_CooldownUnlessReceivedDamage final : public UBFGSensor
{
public:
	EBFGBehaviourState_NPC                        M_state;                                           // 0x0040(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EBFGBehaviourState_NPC                        M_previousState;                                   // 0x0041(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_42[0x2];                                       // 0x0042(0x0002)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         M_fAlertCooldDown;                                 // 0x0044(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"BFGSensor_CooldownUnlessReceivedDamage">();
	}
	static class UBFGSensor_CooldownUnlessReceivedDamage* GetDefaultObj()
	{
		return GetDefaultObjImpl<UBFGSensor_CooldownUnlessReceivedDamage>();
	}
};
static_assert(alignof(UBFGSensor_CooldownUnlessReceivedDamage) == 0x000008, "Wrong alignment on UBFGSensor_CooldownUnlessReceivedDamage");
static_assert(sizeof(UBFGSensor_CooldownUnlessReceivedDamage) == 0x000048, "Wrong size on UBFGSensor_CooldownUnlessReceivedDamage");
static_assert(offsetof(UBFGSensor_CooldownUnlessReceivedDamage, M_state) == 0x000040, "Member 'UBFGSensor_CooldownUnlessReceivedDamage::M_state' has a wrong offset!");
static_assert(offsetof(UBFGSensor_CooldownUnlessReceivedDamage, M_previousState) == 0x000041, "Member 'UBFGSensor_CooldownUnlessReceivedDamage::M_previousState' has a wrong offset!");
static_assert(offsetof(UBFGSensor_CooldownUnlessReceivedDamage, M_fAlertCooldDown) == 0x000044, "Member 'UBFGSensor_CooldownUnlessReceivedDamage::M_fAlertCooldDown' has a wrong offset!");

// Class BFGCore.BFGEventTrigger_ResourceValue
// 0x0008 (0x0048 - 0x0040)
class UBFGEventTrigger_ResourceValue final : public UBFGEventTrigger
{
public:
	uint8                                         Pad_40[0x8];                                       // 0x0040(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void ValueChanged(EItemValueTypeEnum _eType, float _fNewValue, float _fOldValue);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"BFGEventTrigger_ResourceValue">();
	}
	static class UBFGEventTrigger_ResourceValue* GetDefaultObj()
	{
		return GetDefaultObjImpl<UBFGEventTrigger_ResourceValue>();
	}
};
static_assert(alignof(UBFGEventTrigger_ResourceValue) == 0x000008, "Wrong alignment on UBFGEventTrigger_ResourceValue");
static_assert(sizeof(UBFGEventTrigger_ResourceValue) == 0x000048, "Wrong size on UBFGEventTrigger_ResourceValue");

// Class BFGCore.BFGActorComponent_OpportunityComponent
// 0x00D8 (0x0880 - 0x07A8)
class UBFGActorComponent_OpportunityComponent : public UWidgetComponent
{
public:
	struct FBFGAgentInstanceOpportunityData       M_RuntimeData;                                     // 0x07A8(0x00C8)(Edit, BlueprintVisible, DisableEditOnInstance, EditConst, Protected, NativeAccessSpecifierProtected)
	uint8                                         Pad_870[0x8];                                      // 0x0870(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	class UBFGActorComponent_MentallyInteractable* M_pCachedMentallyInteractable;                     // 0x0878(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)

public:
	void HideWidget();
	void PerformExpensiveUpdate();
	bool ShouldShowOnBeginPlay();
	void ShowWidget(const struct FBFGAgentInstanceOpportunityData& _data);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"BFGActorComponent_OpportunityComponent">();
	}
	static class UBFGActorComponent_OpportunityComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UBFGActorComponent_OpportunityComponent>();
	}
};
static_assert(alignof(UBFGActorComponent_OpportunityComponent) == 0x000008, "Wrong alignment on UBFGActorComponent_OpportunityComponent");
static_assert(sizeof(UBFGActorComponent_OpportunityComponent) == 0x000880, "Wrong size on UBFGActorComponent_OpportunityComponent");
static_assert(offsetof(UBFGActorComponent_OpportunityComponent, M_RuntimeData) == 0x0007A8, "Member 'UBFGActorComponent_OpportunityComponent::M_RuntimeData' has a wrong offset!");
static_assert(offsetof(UBFGActorComponent_OpportunityComponent, M_pCachedMentallyInteractable) == 0x000878, "Member 'UBFGActorComponent_OpportunityComponent::M_pCachedMentallyInteractable' has a wrong offset!");

// Class BFGCore.BFGQuest_ElementFallOutOfWorld
// 0x0058 (0x0350 - 0x02F8)
class UBFGQuest_ElementFallOutOfWorld final : public UBFGQuest_Element
{
public:
	TArray<struct FBFGQuest_ElementFallOutOfWorld_Objective> M_aObjectives;                                     // 0x02F8(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, NativeAccessSpecifierPublic)
	EFBFGQuest_Element_ExecutionTime              M_executionTime;                                   // 0x0308(0x0001)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_309[0x7];                                      // 0x0309(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	struct FBFGQuest_Objectives                   M_runtimeObjectives;                               // 0x0310(0x0040)(Transient, ContainsInstancedReference, Protected, NativeAccessSpecifierProtected)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"BFGQuest_ElementFallOutOfWorld">();
	}
	static class UBFGQuest_ElementFallOutOfWorld* GetDefaultObj()
	{
		return GetDefaultObjImpl<UBFGQuest_ElementFallOutOfWorld>();
	}
};
static_assert(alignof(UBFGQuest_ElementFallOutOfWorld) == 0x000008, "Wrong alignment on UBFGQuest_ElementFallOutOfWorld");
static_assert(sizeof(UBFGQuest_ElementFallOutOfWorld) == 0x000350, "Wrong size on UBFGQuest_ElementFallOutOfWorld");
static_assert(offsetof(UBFGQuest_ElementFallOutOfWorld, M_aObjectives) == 0x0002F8, "Member 'UBFGQuest_ElementFallOutOfWorld::M_aObjectives' has a wrong offset!");
static_assert(offsetof(UBFGQuest_ElementFallOutOfWorld, M_executionTime) == 0x000308, "Member 'UBFGQuest_ElementFallOutOfWorld::M_executionTime' has a wrong offset!");
static_assert(offsetof(UBFGQuest_ElementFallOutOfWorld, M_runtimeObjectives) == 0x000310, "Member 'UBFGQuest_ElementFallOutOfWorld::M_runtimeObjectives' has a wrong offset!");

// Class BFGCore.BFGActorComponent_OverheatManager
// 0x0070 (0x0198 - 0x0128)
class UBFGActorComponent_OverheatManager final : public UActorComponent
{
public:
	class UCurveFloat*                            M_pOverheatCurve_None;                             // 0x0128(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UCurveFloat*                            M_pOverheatCurve_Mild;                             // 0x0130(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UCurveFloat*                            M_pOverheatCurve_Bright;                           // 0x0138(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         M_fOverheatValue_None;                             // 0x0140(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         M_fOverheatValue_Mild;                             // 0x0144(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         M_fOverheatValue_Bright;                           // 0x0148(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         M_fOverheatTransitionDuration_None;                // 0x014C(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         M_fOverheatTransitionDuration_Mild;                // 0x0150(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         M_fOverheatTransitionDuration_Bright;              // 0x0154(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UTimelineComponent*                     M_tOverheatTimeline;                               // 0x0158(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_160[0x38];                                     // 0x0160(0x0038)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void OverheatGlow_FinishedCallback();
	void OverheatGlow_Interpolation(float Val);

	EBFGOverheatGlow GetOverheatGlowState() const;
	float GetOverheatValue() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"BFGActorComponent_OverheatManager">();
	}
	static class UBFGActorComponent_OverheatManager* GetDefaultObj()
	{
		return GetDefaultObjImpl<UBFGActorComponent_OverheatManager>();
	}
};
static_assert(alignof(UBFGActorComponent_OverheatManager) == 0x000008, "Wrong alignment on UBFGActorComponent_OverheatManager");
static_assert(sizeof(UBFGActorComponent_OverheatManager) == 0x000198, "Wrong size on UBFGActorComponent_OverheatManager");
static_assert(offsetof(UBFGActorComponent_OverheatManager, M_pOverheatCurve_None) == 0x000128, "Member 'UBFGActorComponent_OverheatManager::M_pOverheatCurve_None' has a wrong offset!");
static_assert(offsetof(UBFGActorComponent_OverheatManager, M_pOverheatCurve_Mild) == 0x000130, "Member 'UBFGActorComponent_OverheatManager::M_pOverheatCurve_Mild' has a wrong offset!");
static_assert(offsetof(UBFGActorComponent_OverheatManager, M_pOverheatCurve_Bright) == 0x000138, "Member 'UBFGActorComponent_OverheatManager::M_pOverheatCurve_Bright' has a wrong offset!");
static_assert(offsetof(UBFGActorComponent_OverheatManager, M_fOverheatValue_None) == 0x000140, "Member 'UBFGActorComponent_OverheatManager::M_fOverheatValue_None' has a wrong offset!");
static_assert(offsetof(UBFGActorComponent_OverheatManager, M_fOverheatValue_Mild) == 0x000144, "Member 'UBFGActorComponent_OverheatManager::M_fOverheatValue_Mild' has a wrong offset!");
static_assert(offsetof(UBFGActorComponent_OverheatManager, M_fOverheatValue_Bright) == 0x000148, "Member 'UBFGActorComponent_OverheatManager::M_fOverheatValue_Bright' has a wrong offset!");
static_assert(offsetof(UBFGActorComponent_OverheatManager, M_fOverheatTransitionDuration_None) == 0x00014C, "Member 'UBFGActorComponent_OverheatManager::M_fOverheatTransitionDuration_None' has a wrong offset!");
static_assert(offsetof(UBFGActorComponent_OverheatManager, M_fOverheatTransitionDuration_Mild) == 0x000150, "Member 'UBFGActorComponent_OverheatManager::M_fOverheatTransitionDuration_Mild' has a wrong offset!");
static_assert(offsetof(UBFGActorComponent_OverheatManager, M_fOverheatTransitionDuration_Bright) == 0x000154, "Member 'UBFGActorComponent_OverheatManager::M_fOverheatTransitionDuration_Bright' has a wrong offset!");
static_assert(offsetof(UBFGActorComponent_OverheatManager, M_tOverheatTimeline) == 0x000158, "Member 'UBFGActorComponent_OverheatManager::M_tOverheatTimeline' has a wrong offset!");

// Class BFGCore.BFGTaskNode_Boss_RunSubtree
// 0x0010 (0x0098 - 0x0088)
class UBFGTaskNode_Boss_RunSubtree final : public UBTTask_RunBehaviorDynamic
{
public:
	class ABFGNPCCharacterBoss*                   M_pOwnerCharacterBoss;                             // 0x0088(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UBehaviorTreeComponent*                 M_pOwnerComp;                                      // 0x0090(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)

public:
	void InterruptSubtree();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"BFGTaskNode_Boss_RunSubtree">();
	}
	static class UBFGTaskNode_Boss_RunSubtree* GetDefaultObj()
	{
		return GetDefaultObjImpl<UBFGTaskNode_Boss_RunSubtree>();
	}
};
static_assert(alignof(UBFGTaskNode_Boss_RunSubtree) == 0x000008, "Wrong alignment on UBFGTaskNode_Boss_RunSubtree");
static_assert(sizeof(UBFGTaskNode_Boss_RunSubtree) == 0x000098, "Wrong size on UBFGTaskNode_Boss_RunSubtree");
static_assert(offsetof(UBFGTaskNode_Boss_RunSubtree, M_pOwnerCharacterBoss) == 0x000088, "Member 'UBFGTaskNode_Boss_RunSubtree::M_pOwnerCharacterBoss' has a wrong offset!");
static_assert(offsetof(UBFGTaskNode_Boss_RunSubtree, M_pOwnerComp) == 0x000090, "Member 'UBFGTaskNode_Boss_RunSubtree::M_pOwnerComp' has a wrong offset!");

// Class BFGCore.BFGEventTrigger_VariableChange
// 0x0010 (0x0050 - 0x0040)
class UBFGEventTrigger_VariableChange final : public UBFGEventTrigger
{
public:
	class UBFGVariable*                           M_pVariable;                                       // 0x0040(0x0008)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_48[0x8];                                       // 0x0048(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void OnVariableValueChanged(class UBFGVariableMirror* _pVarMirror, const class UBFGVariable* _pVariable, int32 _oldValue, int32 _newValue);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"BFGEventTrigger_VariableChange">();
	}
	static class UBFGEventTrigger_VariableChange* GetDefaultObj()
	{
		return GetDefaultObjImpl<UBFGEventTrigger_VariableChange>();
	}
};
static_assert(alignof(UBFGEventTrigger_VariableChange) == 0x000008, "Wrong alignment on UBFGEventTrigger_VariableChange");
static_assert(sizeof(UBFGEventTrigger_VariableChange) == 0x000050, "Wrong size on UBFGEventTrigger_VariableChange");
static_assert(offsetof(UBFGEventTrigger_VariableChange, M_pVariable) == 0x000040, "Member 'UBFGEventTrigger_VariableChange::M_pVariable' has a wrong offset!");

// Class BFGCore.BFGActorComponent_PawnDamage
// 0x00B0 (0x01D8 - 0x0128)
class UBFGActorComponent_PawnDamage final : public UActorComponent
{
public:
	UMulticastDelegateProperty_                   M_OnShieldGracePeriodDamage;                       // 0x0128(0x0018)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	UMulticastDelegateProperty_                   M_OnShieldDamage;                                  // 0x0140(0x0018)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	UMulticastDelegateProperty_                   M_OnHealthDamage;                                  // 0x0158(0x0018)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	bool                                          M_bEnableDamageHistory;                            // 0x0170(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          M_bReportDamageToAlertSystem;                      // 0x0171(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_172[0x2];                                      // 0x0172(0x0002)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         M_fDeathNotificationDelayForQuest;                 // 0x0174(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	struct FGameplayTagContainer                  M_oImmunityTags;                                   // 0x0178(0x0020)(Edit, BlueprintVisible, BlueprintReadOnly, DisableEditOnInstance, Protected, NativeAccessSpecifierProtected)
	TArray<TSubclassOf<class UBFGDamageType>>     M_aImmuneAgainstDamageTypes;                       // 0x0198(0x0010)(Edit, BlueprintVisible, ZeroConstructor, Protected, UObjectWrapper, NativeAccessSpecifierProtected)
	TArray<struct FBFGDamageHistoryEntry>         M_aDamageHistory;                                  // 0x01A8(0x0010)(ZeroConstructor, Protected, NativeAccessSpecifierProtected)
	uint8                                         Pad_1B8[0x4];                                      // 0x01B8(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	int32                                         M_iMaxDamageHistoryEntries;                        // 0x01BC(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         M_fDefaultShieldInvulnerabilityWindow;             // 0x01C0(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         M_fDefaultLastChanceShieldInvulnerabilityWindow;   // 0x01C4(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_1C8[0x10];                                     // 0x01C8(0x0010)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static float ApplyAndReportDamage(class AActor* _pDamagedActor, float _fDamage, class AController* _pInstigator, class AActor* _pDamageSource, TSubclassOf<class UDamageType> _damageType, bool _bAllowFriendlyFire);
	static float ApplyAndReportPointDamage(class AActor* _pDamagedActor, float _fDamage, const struct FVector& HitFromDirection, const struct FHitResult& HitInfo, class AController* _pInstigator, class AActor* _pDamageSource, TSubclassOf<class UDamageType> _damageType, bool _bAllowFriendlyFire);

	void BFGActorComponent_PawnDamage_PointDamageEvent__DelegateSignature(class UBFGActorComponent_PawnDamage* _pPawnDamage, float _fDamage, class AActor* _pDamageCauser, class UBFGDamageType* _pDamageType, const struct FVector& _rShotDirection, const struct FHitResult& _oHitResult);

	float ComputeCurrentShieldInvulnerabilityWindow() const;
	float GetDamageTakenSince(float _fMaxAgeSeconds) const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"BFGActorComponent_PawnDamage">();
	}
	static class UBFGActorComponent_PawnDamage* GetDefaultObj()
	{
		return GetDefaultObjImpl<UBFGActorComponent_PawnDamage>();
	}
};
static_assert(alignof(UBFGActorComponent_PawnDamage) == 0x000008, "Wrong alignment on UBFGActorComponent_PawnDamage");
static_assert(sizeof(UBFGActorComponent_PawnDamage) == 0x0001D8, "Wrong size on UBFGActorComponent_PawnDamage");
static_assert(offsetof(UBFGActorComponent_PawnDamage, M_OnShieldGracePeriodDamage) == 0x000128, "Member 'UBFGActorComponent_PawnDamage::M_OnShieldGracePeriodDamage' has a wrong offset!");
static_assert(offsetof(UBFGActorComponent_PawnDamage, M_OnShieldDamage) == 0x000140, "Member 'UBFGActorComponent_PawnDamage::M_OnShieldDamage' has a wrong offset!");
static_assert(offsetof(UBFGActorComponent_PawnDamage, M_OnHealthDamage) == 0x000158, "Member 'UBFGActorComponent_PawnDamage::M_OnHealthDamage' has a wrong offset!");
static_assert(offsetof(UBFGActorComponent_PawnDamage, M_bEnableDamageHistory) == 0x000170, "Member 'UBFGActorComponent_PawnDamage::M_bEnableDamageHistory' has a wrong offset!");
static_assert(offsetof(UBFGActorComponent_PawnDamage, M_bReportDamageToAlertSystem) == 0x000171, "Member 'UBFGActorComponent_PawnDamage::M_bReportDamageToAlertSystem' has a wrong offset!");
static_assert(offsetof(UBFGActorComponent_PawnDamage, M_fDeathNotificationDelayForQuest) == 0x000174, "Member 'UBFGActorComponent_PawnDamage::M_fDeathNotificationDelayForQuest' has a wrong offset!");
static_assert(offsetof(UBFGActorComponent_PawnDamage, M_oImmunityTags) == 0x000178, "Member 'UBFGActorComponent_PawnDamage::M_oImmunityTags' has a wrong offset!");
static_assert(offsetof(UBFGActorComponent_PawnDamage, M_aImmuneAgainstDamageTypes) == 0x000198, "Member 'UBFGActorComponent_PawnDamage::M_aImmuneAgainstDamageTypes' has a wrong offset!");
static_assert(offsetof(UBFGActorComponent_PawnDamage, M_aDamageHistory) == 0x0001A8, "Member 'UBFGActorComponent_PawnDamage::M_aDamageHistory' has a wrong offset!");
static_assert(offsetof(UBFGActorComponent_PawnDamage, M_iMaxDamageHistoryEntries) == 0x0001BC, "Member 'UBFGActorComponent_PawnDamage::M_iMaxDamageHistoryEntries' has a wrong offset!");
static_assert(offsetof(UBFGActorComponent_PawnDamage, M_fDefaultShieldInvulnerabilityWindow) == 0x0001C0, "Member 'UBFGActorComponent_PawnDamage::M_fDefaultShieldInvulnerabilityWindow' has a wrong offset!");
static_assert(offsetof(UBFGActorComponent_PawnDamage, M_fDefaultLastChanceShieldInvulnerabilityWindow) == 0x0001C4, "Member 'UBFGActorComponent_PawnDamage::M_fDefaultLastChanceShieldInvulnerabilityWindow' has a wrong offset!");

// Class BFGCore.BFGTaskNode_Boss_Stomp
// 0x0000 (0x00A0 - 0x00A0)
class UBFGTaskNode_Boss_Stomp final : public UBFGTaskNode_BossBase
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"BFGTaskNode_Boss_Stomp">();
	}
	static class UBFGTaskNode_Boss_Stomp* GetDefaultObj()
	{
		return GetDefaultObjImpl<UBFGTaskNode_Boss_Stomp>();
	}
};
static_assert(alignof(UBFGTaskNode_Boss_Stomp) == 0x000008, "Wrong alignment on UBFGTaskNode_Boss_Stomp");
static_assert(sizeof(UBFGTaskNode_Boss_Stomp) == 0x0000A0, "Wrong size on UBFGTaskNode_Boss_Stomp");

// Class BFGCore.BFGEventTrigger_SequenceFinished
// 0x0028 (0x0068 - 0x0040)
class UBFGEventTrigger_SequenceFinished final : public UBFGEventTrigger
{
public:
	uint8                                         Pad_40[0x18];                                      // 0x0040(0x0018)(Fixing Size After Last Property [ Dumper-7 ])
	class UBFGNarrativeSequence*                  M_pNarrativeSequence;                              // 0x0058(0x0008)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_60[0x8];                                       // 0x0060(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void OnNarrativeSequenceFinished(class UBFGNarrativeSequence* _pSequence);
	void OnSequenceFinished(class ALevelSequenceActor* _pActor, bool _bWasCutscene);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"BFGEventTrigger_SequenceFinished">();
	}
	static class UBFGEventTrigger_SequenceFinished* GetDefaultObj()
	{
		return GetDefaultObjImpl<UBFGEventTrigger_SequenceFinished>();
	}
};
static_assert(alignof(UBFGEventTrigger_SequenceFinished) == 0x000008, "Wrong alignment on UBFGEventTrigger_SequenceFinished");
static_assert(sizeof(UBFGEventTrigger_SequenceFinished) == 0x000068, "Wrong size on UBFGEventTrigger_SequenceFinished");
static_assert(offsetof(UBFGEventTrigger_SequenceFinished, M_pNarrativeSequence) == 0x000058, "Member 'UBFGEventTrigger_SequenceFinished::M_pNarrativeSequence' has a wrong offset!");

// Class BFGCore.BFGActorComponent_PhysicsHandle
// 0x0018 (0x01E0 - 0x01C8)
class UBFGActorComponent_PhysicsHandle final : public UPhysicsHandleComponent
{
public:
	float                                         M_fInterpolationSpeed_XY_Grabbing;                 // 0x01C8(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         M_fInterpolationSpeed_XY_Grabbed;                  // 0x01CC(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         M_fInterpolationSpeed_ZOffset_Grabbing;            // 0x01D0(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         M_fInterpolationSpeed_ZOffset_Grabbed;             // 0x01D4(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         M_fGrabbingToGrabbedDistanceThreshold;             // 0x01D8(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1DC[0x4];                                      // 0x01DC(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"BFGActorComponent_PhysicsHandle">();
	}
	static class UBFGActorComponent_PhysicsHandle* GetDefaultObj()
	{
		return GetDefaultObjImpl<UBFGActorComponent_PhysicsHandle>();
	}
};
static_assert(alignof(UBFGActorComponent_PhysicsHandle) == 0x000008, "Wrong alignment on UBFGActorComponent_PhysicsHandle");
static_assert(sizeof(UBFGActorComponent_PhysicsHandle) == 0x0001E0, "Wrong size on UBFGActorComponent_PhysicsHandle");
static_assert(offsetof(UBFGActorComponent_PhysicsHandle, M_fInterpolationSpeed_XY_Grabbing) == 0x0001C8, "Member 'UBFGActorComponent_PhysicsHandle::M_fInterpolationSpeed_XY_Grabbing' has a wrong offset!");
static_assert(offsetof(UBFGActorComponent_PhysicsHandle, M_fInterpolationSpeed_XY_Grabbed) == 0x0001CC, "Member 'UBFGActorComponent_PhysicsHandle::M_fInterpolationSpeed_XY_Grabbed' has a wrong offset!");
static_assert(offsetof(UBFGActorComponent_PhysicsHandle, M_fInterpolationSpeed_ZOffset_Grabbing) == 0x0001D0, "Member 'UBFGActorComponent_PhysicsHandle::M_fInterpolationSpeed_ZOffset_Grabbing' has a wrong offset!");
static_assert(offsetof(UBFGActorComponent_PhysicsHandle, M_fInterpolationSpeed_ZOffset_Grabbed) == 0x0001D4, "Member 'UBFGActorComponent_PhysicsHandle::M_fInterpolationSpeed_ZOffset_Grabbed' has a wrong offset!");
static_assert(offsetof(UBFGActorComponent_PhysicsHandle, M_fGrabbingToGrabbedDistanceThreshold) == 0x0001D8, "Member 'UBFGActorComponent_PhysicsHandle::M_fGrabbingToGrabbedDistanceThreshold' has a wrong offset!");

// Class BFGCore.BFGActorComponent_PlayerCharacterMovement
// 0x0110 (0x0A00 - 0x08F0)
class UBFGActorComponent_PlayerCharacterMovement final : public UBFGActorComponent_CharacterMovement
{
public:
	class UBFGDataAsset_JetpackParams*            M_pJetpackParams;                                  // 0x08E8(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_8F0[0x6C];                                     // 0x08F0(0x006C)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         M_fDirectionChangeMinAngle;                        // 0x095C(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         M_fDirectionChangeMinSize;                         // 0x0960(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         M_fDirectionChangeDelay;                           // 0x0964(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_968[0x14];                                     // 0x0968(0x0014)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         M_fFastInputMaxTime;                               // 0x097C(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_980[0x8];                                      // 0x0980(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         M_fMaxSpeedInWater;                                // 0x0988(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         M_fMaxAccelerationInWater;                         // 0x098C(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         M_fFrictionInWater;                                // 0x0990(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         M_fWaterBobbingSpeed;                              // 0x0994(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         M_fWaterBobbingHeight;                             // 0x0998(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         M_fWaterPushUpMultiplier;                          // 0x099C(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         M_fWaterEmergencyHeightOffset;                     // 0x09A0(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_9A4[0x4];                                      // 0x09A4(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         M_fNasalProbeTurnSpeed;                            // 0x09A8(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_9AC[0x1];                                      // 0x09AC(0x0001)(Fixing Size After Last Property [ Dumper-7 ])
	bool                                          M_bOrientRotationToInput;                          // 0x09AD(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_9AE[0x2];                                      // 0x09AE(0x0002)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         M_fOrientRotationToInputThreshold;                 // 0x09B0(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_9B4[0x10];                                     // 0x09B4(0x0010)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         M_fDefaultYawRotationRate;                         // 0x09C4(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_9C8[0x4];                                      // 0x09C8(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	struct FBFGPlayerCharacterMovementSettings    M_oDefaultMovementSettingsOverride;                // 0x09CC(0x001C)(Edit, NoDestructor, Protected, NativeAccessSpecifierProtected)
	uint8                                         Pad_9E8[0x18];                                     // 0x09E8(0x0018)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	struct FVector GetJetpackUpVelocity();

	bool IsTouchingGround() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"BFGActorComponent_PlayerCharacterMovement">();
	}
	static class UBFGActorComponent_PlayerCharacterMovement* GetDefaultObj()
	{
		return GetDefaultObjImpl<UBFGActorComponent_PlayerCharacterMovement>();
	}
};
static_assert(alignof(UBFGActorComponent_PlayerCharacterMovement) == 0x000010, "Wrong alignment on UBFGActorComponent_PlayerCharacterMovement");
static_assert(sizeof(UBFGActorComponent_PlayerCharacterMovement) == 0x000A00, "Wrong size on UBFGActorComponent_PlayerCharacterMovement");
static_assert(offsetof(UBFGActorComponent_PlayerCharacterMovement, M_pJetpackParams) == 0x0008E8, "Member 'UBFGActorComponent_PlayerCharacterMovement::M_pJetpackParams' has a wrong offset!");
static_assert(offsetof(UBFGActorComponent_PlayerCharacterMovement, M_fDirectionChangeMinAngle) == 0x00095C, "Member 'UBFGActorComponent_PlayerCharacterMovement::M_fDirectionChangeMinAngle' has a wrong offset!");
static_assert(offsetof(UBFGActorComponent_PlayerCharacterMovement, M_fDirectionChangeMinSize) == 0x000960, "Member 'UBFGActorComponent_PlayerCharacterMovement::M_fDirectionChangeMinSize' has a wrong offset!");
static_assert(offsetof(UBFGActorComponent_PlayerCharacterMovement, M_fDirectionChangeDelay) == 0x000964, "Member 'UBFGActorComponent_PlayerCharacterMovement::M_fDirectionChangeDelay' has a wrong offset!");
static_assert(offsetof(UBFGActorComponent_PlayerCharacterMovement, M_fFastInputMaxTime) == 0x00097C, "Member 'UBFGActorComponent_PlayerCharacterMovement::M_fFastInputMaxTime' has a wrong offset!");
static_assert(offsetof(UBFGActorComponent_PlayerCharacterMovement, M_fMaxSpeedInWater) == 0x000988, "Member 'UBFGActorComponent_PlayerCharacterMovement::M_fMaxSpeedInWater' has a wrong offset!");
static_assert(offsetof(UBFGActorComponent_PlayerCharacterMovement, M_fMaxAccelerationInWater) == 0x00098C, "Member 'UBFGActorComponent_PlayerCharacterMovement::M_fMaxAccelerationInWater' has a wrong offset!");
static_assert(offsetof(UBFGActorComponent_PlayerCharacterMovement, M_fFrictionInWater) == 0x000990, "Member 'UBFGActorComponent_PlayerCharacterMovement::M_fFrictionInWater' has a wrong offset!");
static_assert(offsetof(UBFGActorComponent_PlayerCharacterMovement, M_fWaterBobbingSpeed) == 0x000994, "Member 'UBFGActorComponent_PlayerCharacterMovement::M_fWaterBobbingSpeed' has a wrong offset!");
static_assert(offsetof(UBFGActorComponent_PlayerCharacterMovement, M_fWaterBobbingHeight) == 0x000998, "Member 'UBFGActorComponent_PlayerCharacterMovement::M_fWaterBobbingHeight' has a wrong offset!");
static_assert(offsetof(UBFGActorComponent_PlayerCharacterMovement, M_fWaterPushUpMultiplier) == 0x00099C, "Member 'UBFGActorComponent_PlayerCharacterMovement::M_fWaterPushUpMultiplier' has a wrong offset!");
static_assert(offsetof(UBFGActorComponent_PlayerCharacterMovement, M_fWaterEmergencyHeightOffset) == 0x0009A0, "Member 'UBFGActorComponent_PlayerCharacterMovement::M_fWaterEmergencyHeightOffset' has a wrong offset!");
static_assert(offsetof(UBFGActorComponent_PlayerCharacterMovement, M_fNasalProbeTurnSpeed) == 0x0009A8, "Member 'UBFGActorComponent_PlayerCharacterMovement::M_fNasalProbeTurnSpeed' has a wrong offset!");
static_assert(offsetof(UBFGActorComponent_PlayerCharacterMovement, M_bOrientRotationToInput) == 0x0009AD, "Member 'UBFGActorComponent_PlayerCharacterMovement::M_bOrientRotationToInput' has a wrong offset!");
static_assert(offsetof(UBFGActorComponent_PlayerCharacterMovement, M_fOrientRotationToInputThreshold) == 0x0009B0, "Member 'UBFGActorComponent_PlayerCharacterMovement::M_fOrientRotationToInputThreshold' has a wrong offset!");
static_assert(offsetof(UBFGActorComponent_PlayerCharacterMovement, M_fDefaultYawRotationRate) == 0x0009C4, "Member 'UBFGActorComponent_PlayerCharacterMovement::M_fDefaultYawRotationRate' has a wrong offset!");
static_assert(offsetof(UBFGActorComponent_PlayerCharacterMovement, M_oDefaultMovementSettingsOverride) == 0x0009CC, "Member 'UBFGActorComponent_PlayerCharacterMovement::M_oDefaultMovementSettingsOverride' has a wrong offset!");

// Class BFGCore.BFGRadarManager
// 0x0038 (0x0068 - 0x0030)
class UBFGRadarManager final : public UBFGGameSystem
{
public:
	UMulticastDelegateProperty_                   M_OnObjectsUpdated;                                // 0x0030(0x0018)(ZeroConstructor, InstancedReference, NativeAccessSpecifierPublic)
	class ABFGGameState*                          M_pGameState;                                      // 0x0048(0x0008)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_50[0x8];                                       // 0x0050(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<struct FBFGRadarManagerLayer>          M_apLayers;                                        // 0x0058(0x0010)(ZeroConstructor, Protected, NativeAccessSpecifierProtected)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"BFGRadarManager">();
	}
	static class UBFGRadarManager* GetDefaultObj()
	{
		return GetDefaultObjImpl<UBFGRadarManager>();
	}
};
static_assert(alignof(UBFGRadarManager) == 0x000008, "Wrong alignment on UBFGRadarManager");
static_assert(sizeof(UBFGRadarManager) == 0x000068, "Wrong size on UBFGRadarManager");
static_assert(offsetof(UBFGRadarManager, M_OnObjectsUpdated) == 0x000030, "Member 'UBFGRadarManager::M_OnObjectsUpdated' has a wrong offset!");
static_assert(offsetof(UBFGRadarManager, M_pGameState) == 0x000048, "Member 'UBFGRadarManager::M_pGameState' has a wrong offset!");
static_assert(offsetof(UBFGRadarManager, M_apLayers) == 0x000058, "Member 'UBFGRadarManager::M_apLayers' has a wrong offset!");

// Class BFGCore.BFGSensor_Investigative_See
// 0x0000 (0x0040 - 0x0040)
class UBFGSensor_Investigative_See final : public UBFGSensor
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"BFGSensor_Investigative_See">();
	}
	static class UBFGSensor_Investigative_See* GetDefaultObj()
	{
		return GetDefaultObjImpl<UBFGSensor_Investigative_See>();
	}
};
static_assert(alignof(UBFGSensor_Investigative_See) == 0x000008, "Wrong alignment on UBFGSensor_Investigative_See");
static_assert(sizeof(UBFGSensor_Investigative_See) == 0x000040, "Wrong size on UBFGSensor_Investigative_See");

// Class BFGCore.BFGEventTrigger_ProximityGoalReached
// 0x0008 (0x0048 - 0x0040)
class UBFGEventTrigger_ProximityGoalReached final : public UBFGEventTrigger
{
public:
	uint8                                         Pad_40[0x8];                                       // 0x0040(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void OnProximityGoalReached(const class UBFGQuest_ProximityMonitor* _pProximityMonitor);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"BFGEventTrigger_ProximityGoalReached">();
	}
	static class UBFGEventTrigger_ProximityGoalReached* GetDefaultObj()
	{
		return GetDefaultObjImpl<UBFGEventTrigger_ProximityGoalReached>();
	}
};
static_assert(alignof(UBFGEventTrigger_ProximityGoalReached) == 0x000008, "Wrong alignment on UBFGEventTrigger_ProximityGoalReached");
static_assert(sizeof(UBFGEventTrigger_ProximityGoalReached) == 0x000048, "Wrong size on UBFGEventTrigger_ProximityGoalReached");

// Class BFGCore.BFGActorComponent_PlayerInteractions
// 0x0010 (0x0138 - 0x0128)
class UBFGActorComponent_PlayerInteractions : public UActorComponent
{
public:
	float                                         M_fDefaultInteractTime;                            // 0x0128(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_12C[0xC];                                      // 0x012C(0x000C)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	bool CanInteract();
	bool CheckStillInteracting();
	void OnInteractStart();
	void OnInteractStop();
	void OnInteractTrigger();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"BFGActorComponent_PlayerInteractions">();
	}
	static class UBFGActorComponent_PlayerInteractions* GetDefaultObj()
	{
		return GetDefaultObjImpl<UBFGActorComponent_PlayerInteractions>();
	}
};
static_assert(alignof(UBFGActorComponent_PlayerInteractions) == 0x000008, "Wrong alignment on UBFGActorComponent_PlayerInteractions");
static_assert(sizeof(UBFGActorComponent_PlayerInteractions) == 0x000138, "Wrong size on UBFGActorComponent_PlayerInteractions");
static_assert(offsetof(UBFGActorComponent_PlayerInteractions, M_fDefaultInteractTime) == 0x000128, "Member 'UBFGActorComponent_PlayerInteractions::M_fDefaultInteractTime' has a wrong offset!");

// Class BFGCore.BFGActorComponent_PlayerInteractionsCharacter
// 0x0088 (0x01C0 - 0x0138)
class UBFGActorComponent_PlayerInteractionsCharacter final : public UBFGActorComponent_PlayerInteractions
{
public:
	UMulticastDelegateProperty_                   M_oOnStartFocusedMentalInteraction;                // 0x0138(0x0018)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	UMulticastDelegateProperty_                   M_oOnStopFocusedMentalInteraction;                 // 0x0150(0x0018)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	UMulticastDelegateProperty_                   M_oOnStartFocusedInteraction;                      // 0x0168(0x0018)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	UMulticastDelegateProperty_                   M_oOnStopFocusedInteraction;                       // 0x0180(0x0018)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	float                                         M_fDefaultMentallyInteractableCutoffDistance;      // 0x0198(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_19C[0x24];                                     // 0x019C(0x0024)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"BFGActorComponent_PlayerInteractionsCharacter">();
	}
	static class UBFGActorComponent_PlayerInteractionsCharacter* GetDefaultObj()
	{
		return GetDefaultObjImpl<UBFGActorComponent_PlayerInteractionsCharacter>();
	}
};
static_assert(alignof(UBFGActorComponent_PlayerInteractionsCharacter) == 0x000008, "Wrong alignment on UBFGActorComponent_PlayerInteractionsCharacter");
static_assert(sizeof(UBFGActorComponent_PlayerInteractionsCharacter) == 0x0001C0, "Wrong size on UBFGActorComponent_PlayerInteractionsCharacter");
static_assert(offsetof(UBFGActorComponent_PlayerInteractionsCharacter, M_oOnStartFocusedMentalInteraction) == 0x000138, "Member 'UBFGActorComponent_PlayerInteractionsCharacter::M_oOnStartFocusedMentalInteraction' has a wrong offset!");
static_assert(offsetof(UBFGActorComponent_PlayerInteractionsCharacter, M_oOnStopFocusedMentalInteraction) == 0x000150, "Member 'UBFGActorComponent_PlayerInteractionsCharacter::M_oOnStopFocusedMentalInteraction' has a wrong offset!");
static_assert(offsetof(UBFGActorComponent_PlayerInteractionsCharacter, M_oOnStartFocusedInteraction) == 0x000168, "Member 'UBFGActorComponent_PlayerInteractionsCharacter::M_oOnStartFocusedInteraction' has a wrong offset!");
static_assert(offsetof(UBFGActorComponent_PlayerInteractionsCharacter, M_oOnStopFocusedInteraction) == 0x000180, "Member 'UBFGActorComponent_PlayerInteractionsCharacter::M_oOnStopFocusedInteraction' has a wrong offset!");
static_assert(offsetof(UBFGActorComponent_PlayerInteractionsCharacter, M_fDefaultMentallyInteractableCutoffDistance) == 0x000198, "Member 'UBFGActorComponent_PlayerInteractionsCharacter::M_fDefaultMentallyInteractableCutoffDistance' has a wrong offset!");

// Class BFGCore.BFGSensor_MultipleAttackTargets
// 0x0050 (0x0090 - 0x0040)
class UBFGSensor_MultipleAttackTargets final : public UBFGSensor
{
public:
	struct FBlackboardKeySelector                 M_BBKeyCombatState;                                // 0x0040(0x0028)(Edit, BlueprintVisible, NativeAccessSpecifierPublic)
	struct FBlackboardKeySelector                 M_BBKeyAttackTarget;                               // 0x0068(0x0028)(Edit, BlueprintVisible, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"BFGSensor_MultipleAttackTargets">();
	}
	static class UBFGSensor_MultipleAttackTargets* GetDefaultObj()
	{
		return GetDefaultObjImpl<UBFGSensor_MultipleAttackTargets>();
	}
};
static_assert(alignof(UBFGSensor_MultipleAttackTargets) == 0x000008, "Wrong alignment on UBFGSensor_MultipleAttackTargets");
static_assert(sizeof(UBFGSensor_MultipleAttackTargets) == 0x000090, "Wrong size on UBFGSensor_MultipleAttackTargets");
static_assert(offsetof(UBFGSensor_MultipleAttackTargets, M_BBKeyCombatState) == 0x000040, "Member 'UBFGSensor_MultipleAttackTargets::M_BBKeyCombatState' has a wrong offset!");
static_assert(offsetof(UBFGSensor_MultipleAttackTargets, M_BBKeyAttackTarget) == 0x000068, "Member 'UBFGSensor_MultipleAttackTargets::M_BBKeyAttackTarget' has a wrong offset!");

// Class BFGCore.BFGEventTrigger_StreamingLevelState
// 0x0010 (0x0050 - 0x0040)
class UBFGEventTrigger_StreamingLevelState final : public UBFGEventTrigger
{
public:
	class UBFGStreamingLevelHandle*               M_pHandle;                                         // 0x0040(0x0008)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_48[0x8];                                       // 0x0048(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void Streaming_OnStateChanged(class UBFGStreamingLevelHandle* _pHandle, bool _bState);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"BFGEventTrigger_StreamingLevelState">();
	}
	static class UBFGEventTrigger_StreamingLevelState* GetDefaultObj()
	{
		return GetDefaultObjImpl<UBFGEventTrigger_StreamingLevelState>();
	}
};
static_assert(alignof(UBFGEventTrigger_StreamingLevelState) == 0x000008, "Wrong alignment on UBFGEventTrigger_StreamingLevelState");
static_assert(sizeof(UBFGEventTrigger_StreamingLevelState) == 0x000050, "Wrong size on UBFGEventTrigger_StreamingLevelState");
static_assert(offsetof(UBFGEventTrigger_StreamingLevelState, M_pHandle) == 0x000040, "Member 'UBFGEventTrigger_StreamingLevelState::M_pHandle' has a wrong offset!");

// Class BFGCore.BFGActorComponent_PlayerInteractionsUFO
// 0x0000 (0x0138 - 0x0138)
class UBFGActorComponent_PlayerInteractionsUFO final : public UBFGActorComponent_PlayerInteractions
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"BFGActorComponent_PlayerInteractionsUFO">();
	}
	static class UBFGActorComponent_PlayerInteractionsUFO* GetDefaultObj()
	{
		return GetDefaultObjImpl<UBFGActorComponent_PlayerInteractionsUFO>();
	}
};
static_assert(alignof(UBFGActorComponent_PlayerInteractionsUFO) == 0x000008, "Wrong alignment on UBFGActorComponent_PlayerInteractionsUFO");
static_assert(sizeof(UBFGActorComponent_PlayerInteractionsUFO) == 0x000138, "Wrong size on UBFGActorComponent_PlayerInteractionsUFO");

// Class BFGCore.BFGQuest_ElementObjectiveBase
// 0x0040 (0x0340 - 0x0300)
class UBFGQuest_ElementObjectiveBase : public UBFGQuest_ElementObjectiveCustom
{
public:
	struct FBFGQuest_Objectives                   M_runtimeObjectives;                               // 0x0300(0x0040)(Transient, ContainsInstancedReference, Protected, NativeAccessSpecifierProtected)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"BFGQuest_ElementObjectiveBase">();
	}
	static class UBFGQuest_ElementObjectiveBase* GetDefaultObj()
	{
		return GetDefaultObjImpl<UBFGQuest_ElementObjectiveBase>();
	}
};
static_assert(alignof(UBFGQuest_ElementObjectiveBase) == 0x000008, "Wrong alignment on UBFGQuest_ElementObjectiveBase");
static_assert(sizeof(UBFGQuest_ElementObjectiveBase) == 0x000340, "Wrong size on UBFGQuest_ElementObjectiveBase");
static_assert(offsetof(UBFGQuest_ElementObjectiveBase, M_runtimeObjectives) == 0x000300, "Member 'UBFGQuest_ElementObjectiveBase::M_runtimeObjectives' has a wrong offset!");

// Class BFGCore.BFGQuest_ElementReach
// 0x00C8 (0x0408 - 0x0340)
class UBFGQuest_ElementReach final : public UBFGQuest_ElementObjectiveBase
{
public:
	EFBFGQuest_Element_ExecutionTime              M_executionTime;                                   // 0x0340(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_341[0x7];                                      // 0x0341(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<struct FBFGQuest_ElementReach_Objective> M_aObjectives;                                     // 0x0348(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, ContainsInstancedReference, NativeAccessSpecifierPublic)
	struct FBFGActorBinding                       M_pawnBinding;                                     // 0x0358(0x0090)(Edit, BlueprintVisible, BlueprintReadOnly, DisableEditOnInstance, NativeAccessSpecifierPublic)
	UMulticastDelegateProperty_                   M_OnReachedEvent;                                  // 0x03E8(0x0018)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	EFBFGQuest_Element_ProcessingMode             M_processingMode;                                  // 0x0400(0x0001)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_401[0x7];                                      // 0x0401(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	TArray<class AActor*> FindObjectiveTargetActors() const;
	class UBFGVariable* GetObjectiveTargetVariable() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"BFGQuest_ElementReach">();
	}
	static class UBFGQuest_ElementReach* GetDefaultObj()
	{
		return GetDefaultObjImpl<UBFGQuest_ElementReach>();
	}
};
static_assert(alignof(UBFGQuest_ElementReach) == 0x000008, "Wrong alignment on UBFGQuest_ElementReach");
static_assert(sizeof(UBFGQuest_ElementReach) == 0x000408, "Wrong size on UBFGQuest_ElementReach");
static_assert(offsetof(UBFGQuest_ElementReach, M_executionTime) == 0x000340, "Member 'UBFGQuest_ElementReach::M_executionTime' has a wrong offset!");
static_assert(offsetof(UBFGQuest_ElementReach, M_aObjectives) == 0x000348, "Member 'UBFGQuest_ElementReach::M_aObjectives' has a wrong offset!");
static_assert(offsetof(UBFGQuest_ElementReach, M_pawnBinding) == 0x000358, "Member 'UBFGQuest_ElementReach::M_pawnBinding' has a wrong offset!");
static_assert(offsetof(UBFGQuest_ElementReach, M_OnReachedEvent) == 0x0003E8, "Member 'UBFGQuest_ElementReach::M_OnReachedEvent' has a wrong offset!");
static_assert(offsetof(UBFGQuest_ElementReach, M_processingMode) == 0x000400, "Member 'UBFGQuest_ElementReach::M_processingMode' has a wrong offset!");

// Class BFGCore.BFGActorComponent_PlayerStats
// 0x0008 (0x0188 - 0x0180)
class UBFGActorComponent_PlayerStats final : public UBFGActorComponent_PawnStats
{
public:
	uint8                                         Pad_180[0x8];                                      // 0x0180(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"BFGActorComponent_PlayerStats">();
	}
	static class UBFGActorComponent_PlayerStats* GetDefaultObj()
	{
		return GetDefaultObjImpl<UBFGActorComponent_PlayerStats>();
	}
};
static_assert(alignof(UBFGActorComponent_PlayerStats) == 0x000008, "Wrong alignment on UBFGActorComponent_PlayerStats");
static_assert(sizeof(UBFGActorComponent_PlayerStats) == 0x000188, "Wrong size on UBFGActorComponent_PlayerStats");

// Class BFGCore.BFGTaskNode_BossLeap
// 0x0038 (0x00D8 - 0x00A0)
class UBFGTaskNode_BossLeap final : public UBFGTaskNode_BossBase
{
public:
	struct FBlackboardKeySelector                 M_BBKeyNextPhaseAnchorLocation;                    // 0x00A0(0x0028)(Edit, BlueprintVisible, NativeAccessSpecifierPublic)
	bool                                          M_bIsTargetingPlayer;                              // 0x00C8(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_C9[0xF];                                       // 0x00C9(0x000F)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"BFGTaskNode_BossLeap">();
	}
	static class UBFGTaskNode_BossLeap* GetDefaultObj()
	{
		return GetDefaultObjImpl<UBFGTaskNode_BossLeap>();
	}
};
static_assert(alignof(UBFGTaskNode_BossLeap) == 0x000008, "Wrong alignment on UBFGTaskNode_BossLeap");
static_assert(sizeof(UBFGTaskNode_BossLeap) == 0x0000D8, "Wrong size on UBFGTaskNode_BossLeap");
static_assert(offsetof(UBFGTaskNode_BossLeap, M_BBKeyNextPhaseAnchorLocation) == 0x0000A0, "Member 'UBFGTaskNode_BossLeap::M_BBKeyNextPhaseAnchorLocation' has a wrong offset!");
static_assert(offsetof(UBFGTaskNode_BossLeap, M_bIsTargetingPlayer) == 0x0000C8, "Member 'UBFGTaskNode_BossLeap::M_bIsTargetingPlayer' has a wrong offset!");

// Class BFGCore.BFGEventAction_StopAITask
// 0x0018 (0x0048 - 0x0030)
class UBFGEventAction_StopAITask final : public UBFGEventAction
{
public:
	uint8                                         Pad_30[0x10];                                      // 0x0030(0x0010)(Fixing Size After Last Property [ Dumper-7 ])
	TWeakObjectPtr<class UBFG_AITask>             M_pTask;                                           // 0x0040(0x0008)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"BFGEventAction_StopAITask">();
	}
	static class UBFGEventAction_StopAITask* GetDefaultObj()
	{
		return GetDefaultObjImpl<UBFGEventAction_StopAITask>();
	}
};
static_assert(alignof(UBFGEventAction_StopAITask) == 0x000008, "Wrong alignment on UBFGEventAction_StopAITask");
static_assert(sizeof(UBFGEventAction_StopAITask) == 0x000048, "Wrong size on UBFGEventAction_StopAITask");
static_assert(offsetof(UBFGEventAction_StopAITask, M_pTask) == 0x000040, "Member 'UBFGEventAction_StopAITask::M_pTask' has a wrong offset!");

// Class BFGCore.BFGNetworkPath_ScriptedPath
// 0x0068 (0x0090 - 0x0028)
class UBFGNetworkPath_ScriptedPath final : public UObject
{
public:
	struct FVector                                M_vStartLocation;                                  // 0x0028(0x000C)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	struct FVector                                M_vTargetLocation;                                 // 0x0034(0x000C)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         M_fPathTotalLength;                                // 0x0040(0x0004)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_44[0x4];                                       // 0x0044(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<struct FBFGNetworkPath_SearchPathResultWayPoint> M_aPath;                                           // 0x0048(0x0010)(ZeroConstructor, Transient, Protected, NativeAccessSpecifierProtected)
	TWeakObjectPtr<class UBFGNetworkPathAgent>    M_pAgent;                                          // 0x0058(0x0008)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	int32                                         M_iCurrentWaypointIndex;                           // 0x0060(0x0004)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_64[0x4];                                       // 0x0064(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	struct FGameplayTagContainer                  M_tagsContainer;                                   // 0x0068(0x0020)(Transient, Protected, NativeAccessSpecifierProtected)
	bool                                          M_bStopAtEnd;                                      // 0x0088(0x0001)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	EBFGAgentStopMode                             M_eStopMode;                                       // 0x0089(0x0001)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          M_bWaypointInvalidated;                            // 0x008A(0x0001)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_8B[0x5];                                       // 0x008B(0x0005)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"BFGNetworkPath_ScriptedPath">();
	}
	static class UBFGNetworkPath_ScriptedPath* GetDefaultObj()
	{
		return GetDefaultObjImpl<UBFGNetworkPath_ScriptedPath>();
	}
};
static_assert(alignof(UBFGNetworkPath_ScriptedPath) == 0x000008, "Wrong alignment on UBFGNetworkPath_ScriptedPath");
static_assert(sizeof(UBFGNetworkPath_ScriptedPath) == 0x000090, "Wrong size on UBFGNetworkPath_ScriptedPath");
static_assert(offsetof(UBFGNetworkPath_ScriptedPath, M_vStartLocation) == 0x000028, "Member 'UBFGNetworkPath_ScriptedPath::M_vStartLocation' has a wrong offset!");
static_assert(offsetof(UBFGNetworkPath_ScriptedPath, M_vTargetLocation) == 0x000034, "Member 'UBFGNetworkPath_ScriptedPath::M_vTargetLocation' has a wrong offset!");
static_assert(offsetof(UBFGNetworkPath_ScriptedPath, M_fPathTotalLength) == 0x000040, "Member 'UBFGNetworkPath_ScriptedPath::M_fPathTotalLength' has a wrong offset!");
static_assert(offsetof(UBFGNetworkPath_ScriptedPath, M_aPath) == 0x000048, "Member 'UBFGNetworkPath_ScriptedPath::M_aPath' has a wrong offset!");
static_assert(offsetof(UBFGNetworkPath_ScriptedPath, M_pAgent) == 0x000058, "Member 'UBFGNetworkPath_ScriptedPath::M_pAgent' has a wrong offset!");
static_assert(offsetof(UBFGNetworkPath_ScriptedPath, M_iCurrentWaypointIndex) == 0x000060, "Member 'UBFGNetworkPath_ScriptedPath::M_iCurrentWaypointIndex' has a wrong offset!");
static_assert(offsetof(UBFGNetworkPath_ScriptedPath, M_tagsContainer) == 0x000068, "Member 'UBFGNetworkPath_ScriptedPath::M_tagsContainer' has a wrong offset!");
static_assert(offsetof(UBFGNetworkPath_ScriptedPath, M_bStopAtEnd) == 0x000088, "Member 'UBFGNetworkPath_ScriptedPath::M_bStopAtEnd' has a wrong offset!");
static_assert(offsetof(UBFGNetworkPath_ScriptedPath, M_eStopMode) == 0x000089, "Member 'UBFGNetworkPath_ScriptedPath::M_eStopMode' has a wrong offset!");
static_assert(offsetof(UBFGNetworkPath_ScriptedPath, M_bWaypointInvalidated) == 0x00008A, "Member 'UBFGNetworkPath_ScriptedPath::M_bWaypointInvalidated' has a wrong offset!");

// Class BFGCore.BFGActorComponent_PlayerUFOMovement
// 0x00E0 (0x0870 - 0x0790)
class UBFGActorComponent_PlayerUFOMovement final : public UCharacterMovementComponent
{
public:
	class ABFGPlayerUFO*                          M_pOwningUFO;                                      // 0x0790(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         M_fBarrelRollMaxSpeed;                             // 0x0798(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         M_fBarrelRollMaxAcceleration;                      // 0x079C(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         M_fBarrelRollDuration;                             // 0x07A0(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_7A4[0x4];                                      // 0x07A4(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class UCurveFloat*                            M_pBarrelRollRotationCurve;                        // 0x07A8(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UCurveFloat*                            M_pLateralSpeedCurve;                              // 0x07B0(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UCurveFloat*                            M_pUpSpeedCurve;                                   // 0x07B8(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_7C0[0x28];                                     // 0x07C0(0x0028)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         M_fTakeOffMaxAcceleration;                         // 0x07E8(0x0004)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         M_fTakeOffMaxSpeed;                                // 0x07EC(0x0004)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         M_fTakeOffHeight;                                  // 0x07F0(0x0004)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_7F4[0x4];                                      // 0x07F4(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         M_fLandTime;                                       // 0x07F8(0x0004)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         M_fLandInterpolationSpeed;                         // 0x07FC(0x0004)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class ABFGUFOLandingSite*                     M_pLandingSite;                                    // 0x0800(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_808[0x1C];                                     // 0x0808(0x001C)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         M_fLateralMaxAcceleration;                         // 0x0824(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         M_fLateralBreakDeceleration;                       // 0x0828(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         M_fLateralMaxSpeed;                                // 0x082C(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         M_fLateralFriction;                                // 0x0830(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_834[0xC];                                      // 0x0834(0x000C)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         M_fVerticalMaxAcceleration;                        // 0x0840(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         M_fVerticalBreakDeceleration;                      // 0x0844(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         M_fVerticalMaxSpeed;                               // 0x0848(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         M_fVerticalFriction;                               // 0x084C(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_850[0xC];                                      // 0x0850(0x000C)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         M_fMinHeight;                                      // 0x085C(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         M_fMaxHeight;                                      // 0x0860(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         M_fHeightLimitSlowDownBuffer;                      // 0x0864(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_868[0x8];                                      // 0x0868(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"BFGActorComponent_PlayerUFOMovement">();
	}
	static class UBFGActorComponent_PlayerUFOMovement* GetDefaultObj()
	{
		return GetDefaultObjImpl<UBFGActorComponent_PlayerUFOMovement>();
	}
};
static_assert(alignof(UBFGActorComponent_PlayerUFOMovement) == 0x000010, "Wrong alignment on UBFGActorComponent_PlayerUFOMovement");
static_assert(sizeof(UBFGActorComponent_PlayerUFOMovement) == 0x000870, "Wrong size on UBFGActorComponent_PlayerUFOMovement");
static_assert(offsetof(UBFGActorComponent_PlayerUFOMovement, M_pOwningUFO) == 0x000790, "Member 'UBFGActorComponent_PlayerUFOMovement::M_pOwningUFO' has a wrong offset!");
static_assert(offsetof(UBFGActorComponent_PlayerUFOMovement, M_fBarrelRollMaxSpeed) == 0x000798, "Member 'UBFGActorComponent_PlayerUFOMovement::M_fBarrelRollMaxSpeed' has a wrong offset!");
static_assert(offsetof(UBFGActorComponent_PlayerUFOMovement, M_fBarrelRollMaxAcceleration) == 0x00079C, "Member 'UBFGActorComponent_PlayerUFOMovement::M_fBarrelRollMaxAcceleration' has a wrong offset!");
static_assert(offsetof(UBFGActorComponent_PlayerUFOMovement, M_fBarrelRollDuration) == 0x0007A0, "Member 'UBFGActorComponent_PlayerUFOMovement::M_fBarrelRollDuration' has a wrong offset!");
static_assert(offsetof(UBFGActorComponent_PlayerUFOMovement, M_pBarrelRollRotationCurve) == 0x0007A8, "Member 'UBFGActorComponent_PlayerUFOMovement::M_pBarrelRollRotationCurve' has a wrong offset!");
static_assert(offsetof(UBFGActorComponent_PlayerUFOMovement, M_pLateralSpeedCurve) == 0x0007B0, "Member 'UBFGActorComponent_PlayerUFOMovement::M_pLateralSpeedCurve' has a wrong offset!");
static_assert(offsetof(UBFGActorComponent_PlayerUFOMovement, M_pUpSpeedCurve) == 0x0007B8, "Member 'UBFGActorComponent_PlayerUFOMovement::M_pUpSpeedCurve' has a wrong offset!");
static_assert(offsetof(UBFGActorComponent_PlayerUFOMovement, M_fTakeOffMaxAcceleration) == 0x0007E8, "Member 'UBFGActorComponent_PlayerUFOMovement::M_fTakeOffMaxAcceleration' has a wrong offset!");
static_assert(offsetof(UBFGActorComponent_PlayerUFOMovement, M_fTakeOffMaxSpeed) == 0x0007EC, "Member 'UBFGActorComponent_PlayerUFOMovement::M_fTakeOffMaxSpeed' has a wrong offset!");
static_assert(offsetof(UBFGActorComponent_PlayerUFOMovement, M_fTakeOffHeight) == 0x0007F0, "Member 'UBFGActorComponent_PlayerUFOMovement::M_fTakeOffHeight' has a wrong offset!");
static_assert(offsetof(UBFGActorComponent_PlayerUFOMovement, M_fLandTime) == 0x0007F8, "Member 'UBFGActorComponent_PlayerUFOMovement::M_fLandTime' has a wrong offset!");
static_assert(offsetof(UBFGActorComponent_PlayerUFOMovement, M_fLandInterpolationSpeed) == 0x0007FC, "Member 'UBFGActorComponent_PlayerUFOMovement::M_fLandInterpolationSpeed' has a wrong offset!");
static_assert(offsetof(UBFGActorComponent_PlayerUFOMovement, M_pLandingSite) == 0x000800, "Member 'UBFGActorComponent_PlayerUFOMovement::M_pLandingSite' has a wrong offset!");
static_assert(offsetof(UBFGActorComponent_PlayerUFOMovement, M_fLateralMaxAcceleration) == 0x000824, "Member 'UBFGActorComponent_PlayerUFOMovement::M_fLateralMaxAcceleration' has a wrong offset!");
static_assert(offsetof(UBFGActorComponent_PlayerUFOMovement, M_fLateralBreakDeceleration) == 0x000828, "Member 'UBFGActorComponent_PlayerUFOMovement::M_fLateralBreakDeceleration' has a wrong offset!");
static_assert(offsetof(UBFGActorComponent_PlayerUFOMovement, M_fLateralMaxSpeed) == 0x00082C, "Member 'UBFGActorComponent_PlayerUFOMovement::M_fLateralMaxSpeed' has a wrong offset!");
static_assert(offsetof(UBFGActorComponent_PlayerUFOMovement, M_fLateralFriction) == 0x000830, "Member 'UBFGActorComponent_PlayerUFOMovement::M_fLateralFriction' has a wrong offset!");
static_assert(offsetof(UBFGActorComponent_PlayerUFOMovement, M_fVerticalMaxAcceleration) == 0x000840, "Member 'UBFGActorComponent_PlayerUFOMovement::M_fVerticalMaxAcceleration' has a wrong offset!");
static_assert(offsetof(UBFGActorComponent_PlayerUFOMovement, M_fVerticalBreakDeceleration) == 0x000844, "Member 'UBFGActorComponent_PlayerUFOMovement::M_fVerticalBreakDeceleration' has a wrong offset!");
static_assert(offsetof(UBFGActorComponent_PlayerUFOMovement, M_fVerticalMaxSpeed) == 0x000848, "Member 'UBFGActorComponent_PlayerUFOMovement::M_fVerticalMaxSpeed' has a wrong offset!");
static_assert(offsetof(UBFGActorComponent_PlayerUFOMovement, M_fVerticalFriction) == 0x00084C, "Member 'UBFGActorComponent_PlayerUFOMovement::M_fVerticalFriction' has a wrong offset!");
static_assert(offsetof(UBFGActorComponent_PlayerUFOMovement, M_fMinHeight) == 0x00085C, "Member 'UBFGActorComponent_PlayerUFOMovement::M_fMinHeight' has a wrong offset!");
static_assert(offsetof(UBFGActorComponent_PlayerUFOMovement, M_fMaxHeight) == 0x000860, "Member 'UBFGActorComponent_PlayerUFOMovement::M_fMaxHeight' has a wrong offset!");
static_assert(offsetof(UBFGActorComponent_PlayerUFOMovement, M_fHeightLimitSlowDownBuffer) == 0x000864, "Member 'UBFGActorComponent_PlayerUFOMovement::M_fHeightLimitSlowDownBuffer' has a wrong offset!");

// Class BFGCore.BFGActorComponent_PlayerWeapon
// 0x0018 (0x0140 - 0x0128)
class UBFGActorComponent_PlayerWeapon final : public UActorComponent
{
public:
	uint8                                         Pad_128[0x8];                                      // 0x0128(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	class UBFGActorComponent_EquipmentManager*    M_pEquipmentManager;                               // 0x0130(0x0008)(ExportObject, ZeroConstructor, Transient, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          M_bIsFiringWeapon;                                 // 0x0138(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_139[0x7];                                      // 0x0139(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void OnDataChanged();
	void OnWeaponAmmoChanged(class ABFGWeapon* _pWeapon);
	void OnWeaponChanged(class ABFGWeapon* _pWeapon, bool _bEnabled);
	void OnWeaponFireChanged(class ABFGWeapon* _pWeapon, bool _bEnabled);
	void OnWeaponReloadDone(class ABFGWeapon* _pWeapon);
	void OnWeaponReloadStarted(class ABFGWeapon* _pWeapon);
	bool RequestEquipFirstAvailableWeapon();
	bool RequestNextWeaponEquip();
	bool RequestPreviousWeaponEquip();
	bool RequestWeaponEquip(class ABFGWeapon* _pWeapon);
	bool RequestWeaponEquipByClass(const TSubclassOf<class ABFGWeapon>& _rClass);
	void StartShooting();
	void StopShooting();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"BFGActorComponent_PlayerWeapon">();
	}
	static class UBFGActorComponent_PlayerWeapon* GetDefaultObj()
	{
		return GetDefaultObjImpl<UBFGActorComponent_PlayerWeapon>();
	}
};
static_assert(alignof(UBFGActorComponent_PlayerWeapon) == 0x000008, "Wrong alignment on UBFGActorComponent_PlayerWeapon");
static_assert(sizeof(UBFGActorComponent_PlayerWeapon) == 0x000140, "Wrong size on UBFGActorComponent_PlayerWeapon");
static_assert(offsetof(UBFGActorComponent_PlayerWeapon, M_pEquipmentManager) == 0x000130, "Member 'UBFGActorComponent_PlayerWeapon::M_pEquipmentManager' has a wrong offset!");
static_assert(offsetof(UBFGActorComponent_PlayerWeapon, M_bIsFiringWeapon) == 0x000138, "Member 'UBFGActorComponent_PlayerWeapon::M_bIsFiringWeapon' has a wrong offset!");

// Class BFGCore.BFGTaskNode_CivilianCower
// 0x0000 (0x0078 - 0x0078)
class UBFGTaskNode_CivilianCower final : public UBFGBTBaseTaskNode
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"BFGTaskNode_CivilianCower">();
	}
	static class UBFGTaskNode_CivilianCower* GetDefaultObj()
	{
		return GetDefaultObjImpl<UBFGTaskNode_CivilianCower>();
	}
};
static_assert(alignof(UBFGTaskNode_CivilianCower) == 0x000008, "Wrong alignment on UBFGTaskNode_CivilianCower");
static_assert(sizeof(UBFGTaskNode_CivilianCower) == 0x000078, "Wrong size on UBFGTaskNode_CivilianCower");

// Class BFGCore.BFGEventAction_RespawnObjectsAndBuildings
// 0x00A8 (0x00D8 - 0x0030)
class UBFGEventAction_RespawnObjectsAndBuildings final : public UBFGEventAction
{
public:
	uint8                                         Pad_30[0xA0];                                      // 0x0030(0x00A0)(Fixing Size After Last Property [ Dumper-7 ])
	class UBFGQuest_ElementFade*                  M_pContext;                                        // 0x00D0(0x0008)(ExportObject, ZeroConstructor, Transient, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"BFGEventAction_RespawnObjectsAndBuildings">();
	}
	static class UBFGEventAction_RespawnObjectsAndBuildings* GetDefaultObj()
	{
		return GetDefaultObjImpl<UBFGEventAction_RespawnObjectsAndBuildings>();
	}
};
static_assert(alignof(UBFGEventAction_RespawnObjectsAndBuildings) == 0x000008, "Wrong alignment on UBFGEventAction_RespawnObjectsAndBuildings");
static_assert(sizeof(UBFGEventAction_RespawnObjectsAndBuildings) == 0x0000D8, "Wrong size on UBFGEventAction_RespawnObjectsAndBuildings");
static_assert(offsetof(UBFGEventAction_RespawnObjectsAndBuildings, M_pContext) == 0x0000D0, "Member 'UBFGEventAction_RespawnObjectsAndBuildings::M_pContext' has a wrong offset!");

// Class BFGCore.BFGActorComponent_PlayerWeaponAndAbilitySelector
// 0x0050 (0x0178 - 0x0128)
class UBFGActorComponent_PlayerWeaponAndAbilitySelector final : public UActorComponent
{
public:
	UMulticastDelegateProperty_                   OnSelectionMenuStateChanged;                       // 0x0128(0x0018)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	class ABFGPlayerBase*                         M_pPlayer;                                         // 0x0140(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UBFGActorComponent_PlayerWeapon*        M_pPlayerWeaponComponent;                          // 0x0148(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UBFGRadialMenuUserWidget*               M_pMenu;                                           // 0x0150(0x0008)(ExportObject, ZeroConstructor, Transient, InstancedReference, IsPlainOldData, NoDestructor, Protected, PersistentInstance, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          M_bIsMenuOption;                                   // 0x0158(0x0001)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_159[0x3];                                      // 0x0159(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	struct FTimeDilationModifier                  M_oTimeModifier;                                   // 0x015C(0x001C)(Transient, NoDestructor, Protected, NativeAccessSpecifierProtected)

public:
	void ActionBool__DelegateSignature(bool _bValue);
	void OnActorIsDeadStatChanged(class AActor* _pActor, class UBFGActorStat_Bool* _pStat);
	void OnSelectionMenuClosed(class UBFGRadialMenuUserWidget* _pMenu);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"BFGActorComponent_PlayerWeaponAndAbilitySelector">();
	}
	static class UBFGActorComponent_PlayerWeaponAndAbilitySelector* GetDefaultObj()
	{
		return GetDefaultObjImpl<UBFGActorComponent_PlayerWeaponAndAbilitySelector>();
	}
};
static_assert(alignof(UBFGActorComponent_PlayerWeaponAndAbilitySelector) == 0x000008, "Wrong alignment on UBFGActorComponent_PlayerWeaponAndAbilitySelector");
static_assert(sizeof(UBFGActorComponent_PlayerWeaponAndAbilitySelector) == 0x000178, "Wrong size on UBFGActorComponent_PlayerWeaponAndAbilitySelector");
static_assert(offsetof(UBFGActorComponent_PlayerWeaponAndAbilitySelector, OnSelectionMenuStateChanged) == 0x000128, "Member 'UBFGActorComponent_PlayerWeaponAndAbilitySelector::OnSelectionMenuStateChanged' has a wrong offset!");
static_assert(offsetof(UBFGActorComponent_PlayerWeaponAndAbilitySelector, M_pPlayer) == 0x000140, "Member 'UBFGActorComponent_PlayerWeaponAndAbilitySelector::M_pPlayer' has a wrong offset!");
static_assert(offsetof(UBFGActorComponent_PlayerWeaponAndAbilitySelector, M_pPlayerWeaponComponent) == 0x000148, "Member 'UBFGActorComponent_PlayerWeaponAndAbilitySelector::M_pPlayerWeaponComponent' has a wrong offset!");
static_assert(offsetof(UBFGActorComponent_PlayerWeaponAndAbilitySelector, M_pMenu) == 0x000150, "Member 'UBFGActorComponent_PlayerWeaponAndAbilitySelector::M_pMenu' has a wrong offset!");
static_assert(offsetof(UBFGActorComponent_PlayerWeaponAndAbilitySelector, M_bIsMenuOption) == 0x000158, "Member 'UBFGActorComponent_PlayerWeaponAndAbilitySelector::M_bIsMenuOption' has a wrong offset!");
static_assert(offsetof(UBFGActorComponent_PlayerWeaponAndAbilitySelector, M_oTimeModifier) == 0x00015C, "Member 'UBFGActorComponent_PlayerWeaponAndAbilitySelector::M_oTimeModifier' has a wrong offset!");

// Class BFGCore.BFGEventTrigger_SpawnManagerEveryoneDead
// 0x0010 (0x0050 - 0x0040)
class UBFGEventTrigger_SpawnManagerEveryoneDead final : public UBFGEventTrigger
{
public:
	uint8                                         Pad_40[0x10];                                      // 0x0040(0x0010)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void OnLoaded(class ABFGMissionSpawnManager* _pSpawnManager);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"BFGEventTrigger_SpawnManagerEveryoneDead">();
	}
	static class UBFGEventTrigger_SpawnManagerEveryoneDead* GetDefaultObj()
	{
		return GetDefaultObjImpl<UBFGEventTrigger_SpawnManagerEveryoneDead>();
	}
};
static_assert(alignof(UBFGEventTrigger_SpawnManagerEveryoneDead) == 0x000008, "Wrong alignment on UBFGEventTrigger_SpawnManagerEveryoneDead");
static_assert(sizeof(UBFGEventTrigger_SpawnManagerEveryoneDead) == 0x000050, "Wrong size on UBFGEventTrigger_SpawnManagerEveryoneDead");

// Class BFGCore.BFGActorComponent_ProxyChildActor
// 0x0028 (0x02F0 - 0x02C8)
class UBFGActorComponent_ProxyChildActor final : public UChildActorComponent
{
public:
	UMulticastDelegateProperty_                   M_onPostCreateChildActor;                          // 0x02C8(0x0018)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	uint8                                         Pad_2E0[0x8];                                      // 0x02E0(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	class UBFGNetworkPathAgent*                   M_pAgent;                                          // 0x02E8(0x0008)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)

public:
	void Actor_OnDestroy(class AActor* _pActor);
	void Agent_OnDestroy(class UBFGNetworkPathAgent* _pAgent);
	void OnAgentChanged(class UBFGNetworkPathAgentComponent* _pComponent, class UBFGNetworkPathAgent* _pAgent, EBFGNetworkPathAgentComponent_AgentChangeReason _reason);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"BFGActorComponent_ProxyChildActor">();
	}
	static class UBFGActorComponent_ProxyChildActor* GetDefaultObj()
	{
		return GetDefaultObjImpl<UBFGActorComponent_ProxyChildActor>();
	}
};
static_assert(alignof(UBFGActorComponent_ProxyChildActor) == 0x000008, "Wrong alignment on UBFGActorComponent_ProxyChildActor");
static_assert(sizeof(UBFGActorComponent_ProxyChildActor) == 0x0002F0, "Wrong size on UBFGActorComponent_ProxyChildActor");
static_assert(offsetof(UBFGActorComponent_ProxyChildActor, M_onPostCreateChildActor) == 0x0002C8, "Member 'UBFGActorComponent_ProxyChildActor::M_onPostCreateChildActor' has a wrong offset!");
static_assert(offsetof(UBFGActorComponent_ProxyChildActor, M_pAgent) == 0x0002E8, "Member 'UBFGActorComponent_ProxyChildActor::M_pAgent' has a wrong offset!");

// Class BFGCore.BFGActorComponent_RadarObject
// 0x0050 (0x0178 - 0x0128)
class UBFGActorComponent_RadarObject : public UActorComponent
{
public:
	uint8                                         Pad_128[0x8];                                      // 0x0128(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	UMulticastDelegateProperty_                   M_OnInitialRegister;                               // 0x0130(0x0018)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	class USlateVectorArtData*                    M_pCachedPolygonData;                              // 0x0148(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UBFGDataAsset_RadarObjectStaticInfo*    M_pStaticInfo;                                     // 0x0150(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UBFGDataAsset_RadarObjectStaticInfo*    M_pStaticInfoOverride;                             // 0x0158(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         M_fLocationUpdateDistance;                         // 0x0160(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          M_bEnableNetworkCrowdSimulation;                   // 0x0164(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_165[0x3];                                      // 0x0165(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	class UBFGRadarManager*                       M_pRadarManager;                                   // 0x0168(0x0008)(ExportObject, ZeroConstructor, Transient, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UBFGNetworkPathAgent*                   M_pAgent;                                          // 0x0170(0x0008)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"BFGActorComponent_RadarObject">();
	}
	static class UBFGActorComponent_RadarObject* GetDefaultObj()
	{
		return GetDefaultObjImpl<UBFGActorComponent_RadarObject>();
	}
};
static_assert(alignof(UBFGActorComponent_RadarObject) == 0x000008, "Wrong alignment on UBFGActorComponent_RadarObject");
static_assert(sizeof(UBFGActorComponent_RadarObject) == 0x000178, "Wrong size on UBFGActorComponent_RadarObject");
static_assert(offsetof(UBFGActorComponent_RadarObject, M_OnInitialRegister) == 0x000130, "Member 'UBFGActorComponent_RadarObject::M_OnInitialRegister' has a wrong offset!");
static_assert(offsetof(UBFGActorComponent_RadarObject, M_pCachedPolygonData) == 0x000148, "Member 'UBFGActorComponent_RadarObject::M_pCachedPolygonData' has a wrong offset!");
static_assert(offsetof(UBFGActorComponent_RadarObject, M_pStaticInfo) == 0x000150, "Member 'UBFGActorComponent_RadarObject::M_pStaticInfo' has a wrong offset!");
static_assert(offsetof(UBFGActorComponent_RadarObject, M_pStaticInfoOverride) == 0x000158, "Member 'UBFGActorComponent_RadarObject::M_pStaticInfoOverride' has a wrong offset!");
static_assert(offsetof(UBFGActorComponent_RadarObject, M_fLocationUpdateDistance) == 0x000160, "Member 'UBFGActorComponent_RadarObject::M_fLocationUpdateDistance' has a wrong offset!");
static_assert(offsetof(UBFGActorComponent_RadarObject, M_bEnableNetworkCrowdSimulation) == 0x000164, "Member 'UBFGActorComponent_RadarObject::M_bEnableNetworkCrowdSimulation' has a wrong offset!");
static_assert(offsetof(UBFGActorComponent_RadarObject, M_pRadarManager) == 0x000168, "Member 'UBFGActorComponent_RadarObject::M_pRadarManager' has a wrong offset!");
static_assert(offsetof(UBFGActorComponent_RadarObject, M_pAgent) == 0x000170, "Member 'UBFGActorComponent_RadarObject::M_pAgent' has a wrong offset!");

// Class BFGCore.BFGEventAction_StartChallenge
// 0x0008 (0x0038 - 0x0030)
class UBFGEventAction_StartChallenge final : public UBFGEventAction
{
public:
	uint8                                         Pad_30[0x8];                                       // 0x0030(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"BFGEventAction_StartChallenge">();
	}
	static class UBFGEventAction_StartChallenge* GetDefaultObj()
	{
		return GetDefaultObjImpl<UBFGEventAction_StartChallenge>();
	}
};
static_assert(alignof(UBFGEventAction_StartChallenge) == 0x000008, "Wrong alignment on UBFGEventAction_StartChallenge");
static_assert(sizeof(UBFGEventAction_StartChallenge) == 0x000038, "Wrong size on UBFGEventAction_StartChallenge");

// Class BFGCore.BFGActorComponent_RadarObject_ExactRadius
// 0x0010 (0x0188 - 0x0178)
class UBFGActorComponent_RadarObject_ExactRadius final : public UBFGActorComponent_RadarObject
{
public:
	float                                         M_fRadius;                                         // 0x0178(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	struct FColor                                 M_TintColor;                                       // 0x017C(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_180[0x8];                                      // 0x0180(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void OnMarkerEnabled(bool _bEnabled);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"BFGActorComponent_RadarObject_ExactRadius">();
	}
	static class UBFGActorComponent_RadarObject_ExactRadius* GetDefaultObj()
	{
		return GetDefaultObjImpl<UBFGActorComponent_RadarObject_ExactRadius>();
	}
};
static_assert(alignof(UBFGActorComponent_RadarObject_ExactRadius) == 0x000008, "Wrong alignment on UBFGActorComponent_RadarObject_ExactRadius");
static_assert(sizeof(UBFGActorComponent_RadarObject_ExactRadius) == 0x000188, "Wrong size on UBFGActorComponent_RadarObject_ExactRadius");
static_assert(offsetof(UBFGActorComponent_RadarObject_ExactRadius, M_fRadius) == 0x000178, "Member 'UBFGActorComponent_RadarObject_ExactRadius::M_fRadius' has a wrong offset!");
static_assert(offsetof(UBFGActorComponent_RadarObject_ExactRadius, M_TintColor) == 0x00017C, "Member 'UBFGActorComponent_RadarObject_ExactRadius::M_TintColor' has a wrong offset!");

// Class BFGCore.BFGQuest_ProximityMonitor
// 0x0130 (0x0158 - 0x0028)
class UBFGQuest_ProximityMonitor final : public UObject
{
public:
	uint8                                         Pad_28[0x8];                                       // 0x0028(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	class UBFGVariable*                           M_pIsActiveVariable;                               // 0x0030(0x0008)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_38[0x8];                                       // 0x0038(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	class ABFGGameState*                          M_pGameState;                                      // 0x0040(0x0008)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_48[0x98];                                      // 0x0048(0x0098)(Fixing Size After Last Property [ Dumper-7 ])
	class APlayerController*                      M_pSourceController;                               // 0x00E0(0x0008)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class AActor*                                 M_pSourceActor;                                    // 0x00E8(0x0008)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UBFGNetworkPathAgent*                   M_pSourceAgent;                                    // 0x00F0(0x0008)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class AActor*                                 M_pTargetActor;                                    // 0x00F8(0x0008)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UBFGNetworkPathAgent*                   M_pTargetAgent;                                    // 0x0100(0x0008)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_108[0x50];                                     // 0x0108(0x0050)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void OnIsActiveChanged(class UBFGVariableMirror* _pVarMirror, const class UBFGVariable* _pVariable, int32 _oldValue, int32 _newValue);
	void OnSourceActorDestroyed(class AActor* _pActor);
	void OnSourceAgentChanged(class UBFGNetworkPathAgentComponent* _pComponent, class UBFGNetworkPathAgent* _pAgent, EBFGNetworkPathAgentComponent_AgentChangeReason _reason);
	void OnSourceAgentDestroyed(class UBFGNetworkPathAgent* _pAgent);
	void OnTargetActorDestroyed(class AActor* _pActor);
	void OnTargetAgentChanged(class UBFGNetworkPathAgentComponent* _pComponent, class UBFGNetworkPathAgent* _pAgent, EBFGNetworkPathAgentComponent_AgentChangeReason _reason);
	void OnTargetAgentDestroyed(class UBFGNetworkPathAgent* _pAgent);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"BFGQuest_ProximityMonitor">();
	}
	static class UBFGQuest_ProximityMonitor* GetDefaultObj()
	{
		return GetDefaultObjImpl<UBFGQuest_ProximityMonitor>();
	}
};
static_assert(alignof(UBFGQuest_ProximityMonitor) == 0x000008, "Wrong alignment on UBFGQuest_ProximityMonitor");
static_assert(sizeof(UBFGQuest_ProximityMonitor) == 0x000158, "Wrong size on UBFGQuest_ProximityMonitor");
static_assert(offsetof(UBFGQuest_ProximityMonitor, M_pIsActiveVariable) == 0x000030, "Member 'UBFGQuest_ProximityMonitor::M_pIsActiveVariable' has a wrong offset!");
static_assert(offsetof(UBFGQuest_ProximityMonitor, M_pGameState) == 0x000040, "Member 'UBFGQuest_ProximityMonitor::M_pGameState' has a wrong offset!");
static_assert(offsetof(UBFGQuest_ProximityMonitor, M_pSourceController) == 0x0000E0, "Member 'UBFGQuest_ProximityMonitor::M_pSourceController' has a wrong offset!");
static_assert(offsetof(UBFGQuest_ProximityMonitor, M_pSourceActor) == 0x0000E8, "Member 'UBFGQuest_ProximityMonitor::M_pSourceActor' has a wrong offset!");
static_assert(offsetof(UBFGQuest_ProximityMonitor, M_pSourceAgent) == 0x0000F0, "Member 'UBFGQuest_ProximityMonitor::M_pSourceAgent' has a wrong offset!");
static_assert(offsetof(UBFGQuest_ProximityMonitor, M_pTargetActor) == 0x0000F8, "Member 'UBFGQuest_ProximityMonitor::M_pTargetActor' has a wrong offset!");
static_assert(offsetof(UBFGQuest_ProximityMonitor, M_pTargetAgent) == 0x000100, "Member 'UBFGQuest_ProximityMonitor::M_pTargetAgent' has a wrong offset!");

// Class BFGCore.BFGActorComponent_RadarObject_NPC
// 0x0000 (0x0178 - 0x0178)
class UBFGActorComponent_RadarObject_NPC : public UBFGActorComponent_RadarObject
{
public:
	void OnIsDeadStatChanged(class AActor* _pActor, class UBFGActorStat_Bool* _pStat);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"BFGActorComponent_RadarObject_NPC">();
	}
	static class UBFGActorComponent_RadarObject_NPC* GetDefaultObj()
	{
		return GetDefaultObjImpl<UBFGActorComponent_RadarObject_NPC>();
	}
};
static_assert(alignof(UBFGActorComponent_RadarObject_NPC) == 0x000008, "Wrong alignment on UBFGActorComponent_RadarObject_NPC");
static_assert(sizeof(UBFGActorComponent_RadarObject_NPC) == 0x000178, "Wrong size on UBFGActorComponent_RadarObject_NPC");

// Class BFGCore.BFGActorComponent_RadarObject_TriggerZone
// 0x0000 (0x0178 - 0x0178)
class UBFGActorComponent_RadarObject_TriggerZone : public UBFGActorComponent_RadarObject
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"BFGActorComponent_RadarObject_TriggerZone">();
	}
	static class UBFGActorComponent_RadarObject_TriggerZone* GetDefaultObj()
	{
		return GetDefaultObjImpl<UBFGActorComponent_RadarObject_TriggerZone>();
	}
};
static_assert(alignof(UBFGActorComponent_RadarObject_TriggerZone) == 0x000008, "Wrong alignment on UBFGActorComponent_RadarObject_TriggerZone");
static_assert(sizeof(UBFGActorComponent_RadarObject_TriggerZone) == 0x000178, "Wrong size on UBFGActorComponent_RadarObject_TriggerZone");

// Class BFGCore.BFGDataAsset_BossPhase
// 0x0058 (0x0088 - 0x0030)
class UBFGDataAsset_BossPhase : public UDataAsset
{
public:
	float                                         M_fHealth;                                         // 0x0030(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         M_fMaxDistanceFromAnchor;                          // 0x0034(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         M_fReinforcementMaxThreshold;                      // 0x0038(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         M_fWeakStateDamageMultiplier;                      // 0x003C(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         M_fWeakStateDuration;                              // 0x0040(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	int32                                         M_iRepeatStep;                                     // 0x0044(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class AActor*                                 M_pAnchorLocation;                                 // 0x0048(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class AActor*                                 M_pReinforcementLocation;                          // 0x0050(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TArray<class AActor*>                         M_apRelocateLocation;                              // 0x0058(0x0010)(ZeroConstructor, Transient, Protected, NativeAccessSpecifierProtected)
	TArray<class AActor*>                         M_apAirMineSpawnLocation;                          // 0x0068(0x0010)(ZeroConstructor, Transient, Protected, NativeAccessSpecifierProtected)
	TArray<struct FStep>                          M_aSteps;                                          // 0x0078(0x0010)(Edit, ZeroConstructor, Protected, NativeAccessSpecifierProtected)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"BFGDataAsset_BossPhase">();
	}
	static class UBFGDataAsset_BossPhase* GetDefaultObj()
	{
		return GetDefaultObjImpl<UBFGDataAsset_BossPhase>();
	}
};
static_assert(alignof(UBFGDataAsset_BossPhase) == 0x000008, "Wrong alignment on UBFGDataAsset_BossPhase");
static_assert(sizeof(UBFGDataAsset_BossPhase) == 0x000088, "Wrong size on UBFGDataAsset_BossPhase");
static_assert(offsetof(UBFGDataAsset_BossPhase, M_fHealth) == 0x000030, "Member 'UBFGDataAsset_BossPhase::M_fHealth' has a wrong offset!");
static_assert(offsetof(UBFGDataAsset_BossPhase, M_fMaxDistanceFromAnchor) == 0x000034, "Member 'UBFGDataAsset_BossPhase::M_fMaxDistanceFromAnchor' has a wrong offset!");
static_assert(offsetof(UBFGDataAsset_BossPhase, M_fReinforcementMaxThreshold) == 0x000038, "Member 'UBFGDataAsset_BossPhase::M_fReinforcementMaxThreshold' has a wrong offset!");
static_assert(offsetof(UBFGDataAsset_BossPhase, M_fWeakStateDamageMultiplier) == 0x00003C, "Member 'UBFGDataAsset_BossPhase::M_fWeakStateDamageMultiplier' has a wrong offset!");
static_assert(offsetof(UBFGDataAsset_BossPhase, M_fWeakStateDuration) == 0x000040, "Member 'UBFGDataAsset_BossPhase::M_fWeakStateDuration' has a wrong offset!");
static_assert(offsetof(UBFGDataAsset_BossPhase, M_iRepeatStep) == 0x000044, "Member 'UBFGDataAsset_BossPhase::M_iRepeatStep' has a wrong offset!");
static_assert(offsetof(UBFGDataAsset_BossPhase, M_pAnchorLocation) == 0x000048, "Member 'UBFGDataAsset_BossPhase::M_pAnchorLocation' has a wrong offset!");
static_assert(offsetof(UBFGDataAsset_BossPhase, M_pReinforcementLocation) == 0x000050, "Member 'UBFGDataAsset_BossPhase::M_pReinforcementLocation' has a wrong offset!");
static_assert(offsetof(UBFGDataAsset_BossPhase, M_apRelocateLocation) == 0x000058, "Member 'UBFGDataAsset_BossPhase::M_apRelocateLocation' has a wrong offset!");
static_assert(offsetof(UBFGDataAsset_BossPhase, M_apAirMineSpawnLocation) == 0x000068, "Member 'UBFGDataAsset_BossPhase::M_apAirMineSpawnLocation' has a wrong offset!");
static_assert(offsetof(UBFGDataAsset_BossPhase, M_aSteps) == 0x000078, "Member 'UBFGDataAsset_BossPhase::M_aSteps' has a wrong offset!");

// Class BFGCore.BFGDataAsset_BossPhase_Armquist
// 0x0018 (0x00A0 - 0x0088)
class UBFGDataAsset_BossPhase_Armquist final : public UBFGDataAsset_BossPhase
{
public:
	class UDataTable*                             M_oMetaPattern_TooFar;                             // 0x0088(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UDataTable*                             M_oMetaPattern_RearQuadrant;                       // 0x0090(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         M_fWarningMarkerTime;                              // 0x0098(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_9C[0x4];                                       // 0x009C(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"BFGDataAsset_BossPhase_Armquist">();
	}
	static class UBFGDataAsset_BossPhase_Armquist* GetDefaultObj()
	{
		return GetDefaultObjImpl<UBFGDataAsset_BossPhase_Armquist>();
	}
};
static_assert(alignof(UBFGDataAsset_BossPhase_Armquist) == 0x000008, "Wrong alignment on UBFGDataAsset_BossPhase_Armquist");
static_assert(sizeof(UBFGDataAsset_BossPhase_Armquist) == 0x0000A0, "Wrong size on UBFGDataAsset_BossPhase_Armquist");
static_assert(offsetof(UBFGDataAsset_BossPhase_Armquist, M_oMetaPattern_TooFar) == 0x000088, "Member 'UBFGDataAsset_BossPhase_Armquist::M_oMetaPattern_TooFar' has a wrong offset!");
static_assert(offsetof(UBFGDataAsset_BossPhase_Armquist, M_oMetaPattern_RearQuadrant) == 0x000090, "Member 'UBFGDataAsset_BossPhase_Armquist::M_oMetaPattern_RearQuadrant' has a wrong offset!");
static_assert(offsetof(UBFGDataAsset_BossPhase_Armquist, M_fWarningMarkerTime) == 0x000098, "Member 'UBFGDataAsset_BossPhase_Armquist::M_fWarningMarkerTime' has a wrong offset!");

// Class BFGCore.BFGWidget_AR_SimpleOverlay
// 0x0060 (0x02A0 - 0x0240)
class UBFGWidget_AR_SimpleOverlay : public UUserWidget
{
public:
	uint8                                         Pad_240[0x8];                                      // 0x0240(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	TSet<EBFGHUDVisibilityState>                  M_aeHUDVisibilityStates;                           // 0x0248(0x0050)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Protected, NativeAccessSpecifierProtected)
	uint8                                         Pad_298[0x8];                                      // 0x0298(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"BFGWidget_AR_SimpleOverlay">();
	}
	static class UBFGWidget_AR_SimpleOverlay* GetDefaultObj()
	{
		return GetDefaultObjImpl<UBFGWidget_AR_SimpleOverlay>();
	}
};
static_assert(alignof(UBFGWidget_AR_SimpleOverlay) == 0x000008, "Wrong alignment on UBFGWidget_AR_SimpleOverlay");
static_assert(sizeof(UBFGWidget_AR_SimpleOverlay) == 0x0002A0, "Wrong size on UBFGWidget_AR_SimpleOverlay");
static_assert(offsetof(UBFGWidget_AR_SimpleOverlay, M_aeHUDVisibilityStates) == 0x000248, "Member 'UBFGWidget_AR_SimpleOverlay::M_aeHUDVisibilityStates' has a wrong offset!");

// Class BFGCore.BFGWidget_AR_ActorComponentWidget
// 0x0008 (0x02A8 - 0x02A0)
class UBFGWidget_AR_ActorComponentWidget : public UBFGWidget_AR_SimpleOverlay
{
public:
	class UBFGActorComponent_WidgetComponent*     M_pWidgetComponent;                                // 0x02A0(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, Transient, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)

public:
	class UBFGActorComponent_WidgetComponent* GetWidgetComponent();
	void SetWidgetComponent(class UBFGActorComponent_WidgetComponent* _pComponent);

	class UBFGGameInstance* GetBFGGameInstance() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"BFGWidget_AR_ActorComponentWidget">();
	}
	static class UBFGWidget_AR_ActorComponentWidget* GetDefaultObj()
	{
		return GetDefaultObjImpl<UBFGWidget_AR_ActorComponentWidget>();
	}
};
static_assert(alignof(UBFGWidget_AR_ActorComponentWidget) == 0x000008, "Wrong alignment on UBFGWidget_AR_ActorComponentWidget");
static_assert(sizeof(UBFGWidget_AR_ActorComponentWidget) == 0x0002A8, "Wrong size on UBFGWidget_AR_ActorComponentWidget");
static_assert(offsetof(UBFGWidget_AR_ActorComponentWidget, M_pWidgetComponent) == 0x0002A0, "Member 'UBFGWidget_AR_ActorComponentWidget::M_pWidgetComponent' has a wrong offset!");

// Class BFGCore.BFGActorComponent_RadarObject_QuestMarker
// 0x0000 (0x0178 - 0x0178)
class UBFGActorComponent_RadarObject_QuestMarker : public UBFGActorComponent_RadarObject_TriggerZone
{
public:
	void OnMarkerEnabled(bool _bEnabled);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"BFGActorComponent_RadarObject_QuestMarker">();
	}
	static class UBFGActorComponent_RadarObject_QuestMarker* GetDefaultObj()
	{
		return GetDefaultObjImpl<UBFGActorComponent_RadarObject_QuestMarker>();
	}
};
static_assert(alignof(UBFGActorComponent_RadarObject_QuestMarker) == 0x000008, "Wrong alignment on UBFGActorComponent_RadarObject_QuestMarker");
static_assert(sizeof(UBFGActorComponent_RadarObject_QuestMarker) == 0x000178, "Wrong size on UBFGActorComponent_RadarObject_QuestMarker");

// Class BFGCore.BFGActorComponent_RadarObject_RestrictedArea
// 0x0008 (0x0180 - 0x0178)
class UBFGActorComponent_RadarObject_RestrictedArea final : public UBFGActorComponent_RadarObject_TriggerZone
{
public:
	bool                                          M_bUseInsideTintColor;                             // 0x0178(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_179[0x3];                                      // 0x0179(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	struct FColor                                 M_insideTintColor;                                 // 0x017C(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"BFGActorComponent_RadarObject_RestrictedArea">();
	}
	static class UBFGActorComponent_RadarObject_RestrictedArea* GetDefaultObj()
	{
		return GetDefaultObjImpl<UBFGActorComponent_RadarObject_RestrictedArea>();
	}
};
static_assert(alignof(UBFGActorComponent_RadarObject_RestrictedArea) == 0x000008, "Wrong alignment on UBFGActorComponent_RadarObject_RestrictedArea");
static_assert(sizeof(UBFGActorComponent_RadarObject_RestrictedArea) == 0x000180, "Wrong size on UBFGActorComponent_RadarObject_RestrictedArea");
static_assert(offsetof(UBFGActorComponent_RadarObject_RestrictedArea, M_bUseInsideTintColor) == 0x000178, "Member 'UBFGActorComponent_RadarObject_RestrictedArea::M_bUseInsideTintColor' has a wrong offset!");
static_assert(offsetof(UBFGActorComponent_RadarObject_RestrictedArea, M_insideTintColor) == 0x00017C, "Member 'UBFGActorComponent_RadarObject_RestrictedArea::M_insideTintColor' has a wrong offset!");

// Class BFGCore.BFGNarrativeSequenceNode
// 0x0010 (0x00C0 - 0x00B0)
class UBFGNarrativeSequenceNode : public UGenericGraphNode
{
public:
	uint8                                         Pad_B0[0x10];                                      // 0x00B0(0x0010)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"BFGNarrativeSequenceNode">();
	}
	static class UBFGNarrativeSequenceNode* GetDefaultObj()
	{
		return GetDefaultObjImpl<UBFGNarrativeSequenceNode>();
	}
};
static_assert(alignof(UBFGNarrativeSequenceNode) == 0x000008, "Wrong alignment on UBFGNarrativeSequenceNode");
static_assert(sizeof(UBFGNarrativeSequenceNode) == 0x0000C0, "Wrong size on UBFGNarrativeSequenceNode");

// Class BFGCore.BFGNarrativeSequenceNode_Start
// 0x0000 (0x00C0 - 0x00C0)
class UBFGNarrativeSequenceNode_Start final : public UBFGNarrativeSequenceNode
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"BFGNarrativeSequenceNode_Start">();
	}
	static class UBFGNarrativeSequenceNode_Start* GetDefaultObj()
	{
		return GetDefaultObjImpl<UBFGNarrativeSequenceNode_Start>();
	}
};
static_assert(alignof(UBFGNarrativeSequenceNode_Start) == 0x000008, "Wrong alignment on UBFGNarrativeSequenceNode_Start");
static_assert(sizeof(UBFGNarrativeSequenceNode_Start) == 0x0000C0, "Wrong size on UBFGNarrativeSequenceNode_Start");

// Class BFGCore.BFGVariableAction_Quest_Abort
// 0x0000 (0x00F0 - 0x00F0)
class UBFGVariableAction_Quest_Abort final : public UBFGVariableAction
{
public:
	static const class FName GetActionName_QuestAbort();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"BFGVariableAction_Quest_Abort">();
	}
	static class UBFGVariableAction_Quest_Abort* GetDefaultObj()
	{
		return GetDefaultObjImpl<UBFGVariableAction_Quest_Abort>();
	}
};
static_assert(alignof(UBFGVariableAction_Quest_Abort) == 0x000008, "Wrong alignment on UBFGVariableAction_Quest_Abort");
static_assert(sizeof(UBFGVariableAction_Quest_Abort) == 0x0000F0, "Wrong size on UBFGVariableAction_Quest_Abort");

// Class BFGCore.BFGBTBaseService
// 0x0008 (0x0078 - 0x0070)
class UBFGBTBaseService : public UBTService
{
public:
	bool                                          M_bAutoResolveBlackboardKeys;                      // 0x0070(0x0001)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_71[0x7];                                       // 0x0071(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"BFGBTBaseService">();
	}
	static class UBFGBTBaseService* GetDefaultObj()
	{
		return GetDefaultObjImpl<UBFGBTBaseService>();
	}
};
static_assert(alignof(UBFGBTBaseService) == 0x000008, "Wrong alignment on UBFGBTBaseService");
static_assert(sizeof(UBFGBTBaseService) == 0x000078, "Wrong size on UBFGBTBaseService");
static_assert(offsetof(UBFGBTBaseService, M_bAutoResolveBlackboardKeys) == 0x000070, "Member 'UBFGBTBaseService::M_bAutoResolveBlackboardKeys' has a wrong offset!");

// Class BFGCore.BFGBTService_BaseCombat
// 0x01A0 (0x0218 - 0x0078)
class UBFGBTService_BaseCombat : public UBFGBTBaseService
{
public:
	struct FBlackboardKeySelector                 M_BBKeyCombatState;                                // 0x0078(0x0028)(Edit, BlueprintVisible, NativeAccessSpecifierPublic)
	struct FBlackboardKeySelector                 M_BBKeyInAttackTarget;                             // 0x00A0(0x0028)(Edit, BlueprintVisible, NativeAccessSpecifierPublic)
	struct FBlackboardKeySelector                 M_BBKeyCombatAttackTarget;                         // 0x00C8(0x0028)(Edit, BlueprintVisible, NativeAccessSpecifierPublic)
	struct FBlackboardKeySelector                 M_BBKeyCombatAttackTargetLocation;                 // 0x00F0(0x0028)(Edit, BlueprintVisible, NativeAccessSpecifierPublic)
	struct FBlackboardKeySelector                 M_BBKeyTargetType;                                 // 0x0118(0x0028)(Edit, BlueprintVisible, NativeAccessSpecifierPublic)
	struct FBlackboardKeySelector                 M_bbKeyLineOfSightToTarget;                        // 0x0140(0x0028)(Edit, BlueprintVisible, NativeAccessSpecifierPublic)
	struct FBlackboardKeySelector                 M_bbKeyLastKnownPositionUnsure;                    // 0x0168(0x0028)(Edit, BlueprintVisible, NativeAccessSpecifierPublic)
	bool                                          M_bAutomaticTargetSwitching;                       // 0x0190(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_191[0x87];                                     // 0x0191(0x0087)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"BFGBTService_BaseCombat">();
	}
	static class UBFGBTService_BaseCombat* GetDefaultObj()
	{
		return GetDefaultObjImpl<UBFGBTService_BaseCombat>();
	}
};
static_assert(alignof(UBFGBTService_BaseCombat) == 0x000008, "Wrong alignment on UBFGBTService_BaseCombat");
static_assert(sizeof(UBFGBTService_BaseCombat) == 0x000218, "Wrong size on UBFGBTService_BaseCombat");
static_assert(offsetof(UBFGBTService_BaseCombat, M_BBKeyCombatState) == 0x000078, "Member 'UBFGBTService_BaseCombat::M_BBKeyCombatState' has a wrong offset!");
static_assert(offsetof(UBFGBTService_BaseCombat, M_BBKeyInAttackTarget) == 0x0000A0, "Member 'UBFGBTService_BaseCombat::M_BBKeyInAttackTarget' has a wrong offset!");
static_assert(offsetof(UBFGBTService_BaseCombat, M_BBKeyCombatAttackTarget) == 0x0000C8, "Member 'UBFGBTService_BaseCombat::M_BBKeyCombatAttackTarget' has a wrong offset!");
static_assert(offsetof(UBFGBTService_BaseCombat, M_BBKeyCombatAttackTargetLocation) == 0x0000F0, "Member 'UBFGBTService_BaseCombat::M_BBKeyCombatAttackTargetLocation' has a wrong offset!");
static_assert(offsetof(UBFGBTService_BaseCombat, M_BBKeyTargetType) == 0x000118, "Member 'UBFGBTService_BaseCombat::M_BBKeyTargetType' has a wrong offset!");
static_assert(offsetof(UBFGBTService_BaseCombat, M_bbKeyLineOfSightToTarget) == 0x000140, "Member 'UBFGBTService_BaseCombat::M_bbKeyLineOfSightToTarget' has a wrong offset!");
static_assert(offsetof(UBFGBTService_BaseCombat, M_bbKeyLastKnownPositionUnsure) == 0x000168, "Member 'UBFGBTService_BaseCombat::M_bbKeyLastKnownPositionUnsure' has a wrong offset!");
static_assert(offsetof(UBFGBTService_BaseCombat, M_bAutomaticTargetSwitching) == 0x000190, "Member 'UBFGBTService_BaseCombat::M_bAutomaticTargetSwitching' has a wrong offset!");

// Class BFGCore.BFGBTService_NPCCombat
// 0x01A0 (0x03B8 - 0x0218)
class UBFGBTService_NPCCombat : public UBFGBTService_BaseCombat
{
public:
	struct FBlackboardKeySelector                 M_BBKeyAttackState;                                // 0x0218(0x0028)(Edit, BlueprintVisible, NativeAccessSpecifierPublic)
	struct FBlackboardKeySelector                 M_BBKeyIsTargetsTarget;                            // 0x0240(0x0028)(Edit, BlueprintVisible, NativeAccessSpecifierPublic)
	struct FBlackboardKeySelector                 M_BBKeyRelocateOrigin;                             // 0x0268(0x0028)(Edit, BlueprintVisible, NativeAccessSpecifierPublic)
	struct FBlackboardKeySelector                 M_BBKeyRelocate2DRange;                            // 0x0290(0x0028)(Edit, BlueprintVisible, NativeAccessSpecifierPublic)
	struct FBlackboardKeySelector                 M_BBKeyRelocateMin2DRange;                         // 0x02B8(0x0028)(Edit, BlueprintVisible, NativeAccessSpecifierPublic)
	struct FBlackboardKeySelector                 M_BBKeyRelocateMax2DRange;                         // 0x02E0(0x0028)(Edit, BlueprintVisible, NativeAccessSpecifierPublic)
	struct FBlackboardKeySelector                 M_BBKeyCurrentWeapon;                              // 0x0308(0x0028)(Edit, BlueprintVisible, NativeAccessSpecifierPublic)
	struct FBlackboardKeySelector                 M_BBKeyEstimatedAttackDelay;                       // 0x0330(0x0028)(Edit, BlueprintVisible, NativeAccessSpecifierPublic)
	float                                         M_fRelocateWeaponRangePercentage;                  // 0x0358(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         M_fRelocateAbortWeaponRangePercentage;             // 0x035C(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          M_bSetCombatStateToNoneDuringWeaponEquipping;      // 0x0360(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          M_bNeverInPositionAgainstUfo;                      // 0x0361(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_362[0xE];                                      // 0x0362(0x000E)(Fixing Size After Last Property [ Dumper-7 ])
	class ABFGWeapon*                             M_pWeapon;                                         // 0x0370(0x0008)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class ABFGWeapon*                             M_pCurrentWeapon;                                  // 0x0378(0x0008)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	struct FBFGTargetTrackerData                  M_targetTrackerData;                               // 0x0380(0x0038)(Transient, NoDestructor, Protected, NativeAccessSpecifierProtected)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"BFGBTService_NPCCombat">();
	}
	static class UBFGBTService_NPCCombat* GetDefaultObj()
	{
		return GetDefaultObjImpl<UBFGBTService_NPCCombat>();
	}
};
static_assert(alignof(UBFGBTService_NPCCombat) == 0x000008, "Wrong alignment on UBFGBTService_NPCCombat");
static_assert(sizeof(UBFGBTService_NPCCombat) == 0x0003B8, "Wrong size on UBFGBTService_NPCCombat");
static_assert(offsetof(UBFGBTService_NPCCombat, M_BBKeyAttackState) == 0x000218, "Member 'UBFGBTService_NPCCombat::M_BBKeyAttackState' has a wrong offset!");
static_assert(offsetof(UBFGBTService_NPCCombat, M_BBKeyIsTargetsTarget) == 0x000240, "Member 'UBFGBTService_NPCCombat::M_BBKeyIsTargetsTarget' has a wrong offset!");
static_assert(offsetof(UBFGBTService_NPCCombat, M_BBKeyRelocateOrigin) == 0x000268, "Member 'UBFGBTService_NPCCombat::M_BBKeyRelocateOrigin' has a wrong offset!");
static_assert(offsetof(UBFGBTService_NPCCombat, M_BBKeyRelocate2DRange) == 0x000290, "Member 'UBFGBTService_NPCCombat::M_BBKeyRelocate2DRange' has a wrong offset!");
static_assert(offsetof(UBFGBTService_NPCCombat, M_BBKeyRelocateMin2DRange) == 0x0002B8, "Member 'UBFGBTService_NPCCombat::M_BBKeyRelocateMin2DRange' has a wrong offset!");
static_assert(offsetof(UBFGBTService_NPCCombat, M_BBKeyRelocateMax2DRange) == 0x0002E0, "Member 'UBFGBTService_NPCCombat::M_BBKeyRelocateMax2DRange' has a wrong offset!");
static_assert(offsetof(UBFGBTService_NPCCombat, M_BBKeyCurrentWeapon) == 0x000308, "Member 'UBFGBTService_NPCCombat::M_BBKeyCurrentWeapon' has a wrong offset!");
static_assert(offsetof(UBFGBTService_NPCCombat, M_BBKeyEstimatedAttackDelay) == 0x000330, "Member 'UBFGBTService_NPCCombat::M_BBKeyEstimatedAttackDelay' has a wrong offset!");
static_assert(offsetof(UBFGBTService_NPCCombat, M_fRelocateWeaponRangePercentage) == 0x000358, "Member 'UBFGBTService_NPCCombat::M_fRelocateWeaponRangePercentage' has a wrong offset!");
static_assert(offsetof(UBFGBTService_NPCCombat, M_fRelocateAbortWeaponRangePercentage) == 0x00035C, "Member 'UBFGBTService_NPCCombat::M_fRelocateAbortWeaponRangePercentage' has a wrong offset!");
static_assert(offsetof(UBFGBTService_NPCCombat, M_bSetCombatStateToNoneDuringWeaponEquipping) == 0x000360, "Member 'UBFGBTService_NPCCombat::M_bSetCombatStateToNoneDuringWeaponEquipping' has a wrong offset!");
static_assert(offsetof(UBFGBTService_NPCCombat, M_bNeverInPositionAgainstUfo) == 0x000361, "Member 'UBFGBTService_NPCCombat::M_bNeverInPositionAgainstUfo' has a wrong offset!");
static_assert(offsetof(UBFGBTService_NPCCombat, M_pWeapon) == 0x000370, "Member 'UBFGBTService_NPCCombat::M_pWeapon' has a wrong offset!");
static_assert(offsetof(UBFGBTService_NPCCombat, M_pCurrentWeapon) == 0x000378, "Member 'UBFGBTService_NPCCombat::M_pCurrentWeapon' has a wrong offset!");
static_assert(offsetof(UBFGBTService_NPCCombat, M_targetTrackerData) == 0x000380, "Member 'UBFGBTService_NPCCombat::M_targetTrackerData' has a wrong offset!");

// Class BFGCore.BFGBTService_PSIMutantCombat
// 0x00D8 (0x0490 - 0x03B8)
class UBFGBTService_PSIMutantCombat final : public UBFGBTService_NPCCombat
{
public:
	struct FBlackboardKeySelector                 M_BBKeyProtectiveBubbleState;                      // 0x03B8(0x0028)(Edit, BlueprintVisible, NativeAccessSpecifierPublic)
	struct FBlackboardKeySelector                 M_BBKeyProtectiveBubbleTarget;                     // 0x03E0(0x0028)(Edit, BlueprintVisible, NativeAccessSpecifierPublic)
	float                                         M_fProtectiveBubbleFailsafeCryptoDistance;         // 0x0408(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         M_fProtectiveBubbleFailsafeDamageTimeframe;        // 0x040C(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         M_fProtectiveBubbleFailsafeDamagePercentage;       // 0x0410(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_414[0x4];                                      // 0x0414(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	struct FGameplayTagQuery                      M_actorCanBeProtcectedQuery;                       // 0x0418(0x0048)(Edit, BlueprintVisible, NativeAccessSpecifierPublic)
	TArray<TSoftClassPtr<class UClass>>           M_apMentalAbilties;                                // 0x0460(0x0010)(Edit, BlueprintVisible, ZeroConstructor, UObjectWrapper, NativeAccessSpecifierPublic)
	uint8                                         Pad_470[0x20];                                     // 0x0470(0x0020)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"BFGBTService_PSIMutantCombat">();
	}
	static class UBFGBTService_PSIMutantCombat* GetDefaultObj()
	{
		return GetDefaultObjImpl<UBFGBTService_PSIMutantCombat>();
	}
};
static_assert(alignof(UBFGBTService_PSIMutantCombat) == 0x000008, "Wrong alignment on UBFGBTService_PSIMutantCombat");
static_assert(sizeof(UBFGBTService_PSIMutantCombat) == 0x000490, "Wrong size on UBFGBTService_PSIMutantCombat");
static_assert(offsetof(UBFGBTService_PSIMutantCombat, M_BBKeyProtectiveBubbleState) == 0x0003B8, "Member 'UBFGBTService_PSIMutantCombat::M_BBKeyProtectiveBubbleState' has a wrong offset!");
static_assert(offsetof(UBFGBTService_PSIMutantCombat, M_BBKeyProtectiveBubbleTarget) == 0x0003E0, "Member 'UBFGBTService_PSIMutantCombat::M_BBKeyProtectiveBubbleTarget' has a wrong offset!");
static_assert(offsetof(UBFGBTService_PSIMutantCombat, M_fProtectiveBubbleFailsafeCryptoDistance) == 0x000408, "Member 'UBFGBTService_PSIMutantCombat::M_fProtectiveBubbleFailsafeCryptoDistance' has a wrong offset!");
static_assert(offsetof(UBFGBTService_PSIMutantCombat, M_fProtectiveBubbleFailsafeDamageTimeframe) == 0x00040C, "Member 'UBFGBTService_PSIMutantCombat::M_fProtectiveBubbleFailsafeDamageTimeframe' has a wrong offset!");
static_assert(offsetof(UBFGBTService_PSIMutantCombat, M_fProtectiveBubbleFailsafeDamagePercentage) == 0x000410, "Member 'UBFGBTService_PSIMutantCombat::M_fProtectiveBubbleFailsafeDamagePercentage' has a wrong offset!");
static_assert(offsetof(UBFGBTService_PSIMutantCombat, M_actorCanBeProtcectedQuery) == 0x000418, "Member 'UBFGBTService_PSIMutantCombat::M_actorCanBeProtcectedQuery' has a wrong offset!");
static_assert(offsetof(UBFGBTService_PSIMutantCombat, M_apMentalAbilties) == 0x000460, "Member 'UBFGBTService_PSIMutantCombat::M_apMentalAbilties' has a wrong offset!");

// Class BFGCore.BFGActorComponent_RagdollOptimizer
// 0x0038 (0x0160 - 0x0128)
class UBFGActorComponent_RagdollOptimizer final : public UActorComponent
{
public:
	class USkinnedMeshComponent*                  M_pSkinnedMesh;                                    // 0x0128(0x0008)(ExportObject, ZeroConstructor, Transient, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UBFGActorComponent_CharacterPhysics*    M_pPhysics;                                        // 0x0130(0x0008)(ExportObject, ZeroConstructor, Transient, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UBFGActorComponent_PawnStats*           M_pStats;                                          // 0x0138(0x0008)(ExportObject, ZeroConstructor, Transient, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class ABFGGameState*                          M_pGameState;                                      // 0x0140(0x0008)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UBFGTrafficCrowdManager*                M_pCrowdManager;                                   // 0x0148(0x0008)(ExportObject, ZeroConstructor, Transient, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_150[0x10];                                     // 0x0150(0x0010)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"BFGActorComponent_RagdollOptimizer">();
	}
	static class UBFGActorComponent_RagdollOptimizer* GetDefaultObj()
	{
		return GetDefaultObjImpl<UBFGActorComponent_RagdollOptimizer>();
	}
};
static_assert(alignof(UBFGActorComponent_RagdollOptimizer) == 0x000008, "Wrong alignment on UBFGActorComponent_RagdollOptimizer");
static_assert(sizeof(UBFGActorComponent_RagdollOptimizer) == 0x000160, "Wrong size on UBFGActorComponent_RagdollOptimizer");
static_assert(offsetof(UBFGActorComponent_RagdollOptimizer, M_pSkinnedMesh) == 0x000128, "Member 'UBFGActorComponent_RagdollOptimizer::M_pSkinnedMesh' has a wrong offset!");
static_assert(offsetof(UBFGActorComponent_RagdollOptimizer, M_pPhysics) == 0x000130, "Member 'UBFGActorComponent_RagdollOptimizer::M_pPhysics' has a wrong offset!");
static_assert(offsetof(UBFGActorComponent_RagdollOptimizer, M_pStats) == 0x000138, "Member 'UBFGActorComponent_RagdollOptimizer::M_pStats' has a wrong offset!");
static_assert(offsetof(UBFGActorComponent_RagdollOptimizer, M_pGameState) == 0x000140, "Member 'UBFGActorComponent_RagdollOptimizer::M_pGameState' has a wrong offset!");
static_assert(offsetof(UBFGActorComponent_RagdollOptimizer, M_pCrowdManager) == 0x000148, "Member 'UBFGActorComponent_RagdollOptimizer::M_pCrowdManager' has a wrong offset!");

// Class BFGCore.BFGActorComponent_ReinforcementManager
// 0x0048 (0x0170 - 0x0128)
class UBFGActorComponent_ReinforcementManager final : public UActorComponent
{
public:
	class ABFGNPCCharacterBoss*                   M_pOwnerCharacterBoss;                             // 0x0128(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_130[0x40];                                     // 0x0130(0x0040)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void ActivateCurrentPhaseReinforcementSpawners(int32 _iCurrentBossPhase);
	void RemoveReinforcementThreatValue(float _fThreatValue);
	void SpawnReinforcements();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"BFGActorComponent_ReinforcementManager">();
	}
	static class UBFGActorComponent_ReinforcementManager* GetDefaultObj()
	{
		return GetDefaultObjImpl<UBFGActorComponent_ReinforcementManager>();
	}
};
static_assert(alignof(UBFGActorComponent_ReinforcementManager) == 0x000008, "Wrong alignment on UBFGActorComponent_ReinforcementManager");
static_assert(sizeof(UBFGActorComponent_ReinforcementManager) == 0x000170, "Wrong size on UBFGActorComponent_ReinforcementManager");
static_assert(offsetof(UBFGActorComponent_ReinforcementManager, M_pOwnerCharacterBoss) == 0x000128, "Member 'UBFGActorComponent_ReinforcementManager::M_pOwnerCharacterBoss' has a wrong offset!");

// Class BFGCore.BFGVariableAction_AITaskState_Start
// 0x0000 (0x00F0 - 0x00F0)
class UBFGVariableAction_AITaskState_Start final : public UBFGVariableAction
{
public:
	static const class FName GetActionName_AITaskState_Start();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"BFGVariableAction_AITaskState_Start">();
	}
	static class UBFGVariableAction_AITaskState_Start* GetDefaultObj()
	{
		return GetDefaultObjImpl<UBFGVariableAction_AITaskState_Start>();
	}
};
static_assert(alignof(UBFGVariableAction_AITaskState_Start) == 0x000008, "Wrong alignment on UBFGVariableAction_AITaskState_Start");
static_assert(sizeof(UBFGVariableAction_AITaskState_Start) == 0x0000F0, "Wrong size on UBFGVariableAction_AITaskState_Start");

// Class BFGCore.BFGDataAsset_CortexScan
// 0x0028 (0x0058 - 0x0030)
class UBFGDataAsset_CortexScan final : public UDataAsset
{
public:
	bool                                          M_bTerminateSearch;                                // 0x0030(0x0001)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EBFGCortexScan_EntryPoint_SelectionMode       M_entryPointSelectionMode;                         // 0x0031(0x0001)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_32[0x6];                                       // 0x0032(0x0006)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<class UStringTable*>                   M_aStringTables;                                   // 0x0038(0x0010)(Edit, ZeroConstructor, DisableEditOnInstance, NativeAccessSpecifierPublic)
	TArray<class FText>                           M_aTextEntries;                                    // 0x0048(0x0010)(Edit, ZeroConstructor, DisableEditOnInstance, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"BFGDataAsset_CortexScan">();
	}
	static class UBFGDataAsset_CortexScan* GetDefaultObj()
	{
		return GetDefaultObjImpl<UBFGDataAsset_CortexScan>();
	}
};
static_assert(alignof(UBFGDataAsset_CortexScan) == 0x000008, "Wrong alignment on UBFGDataAsset_CortexScan");
static_assert(sizeof(UBFGDataAsset_CortexScan) == 0x000058, "Wrong size on UBFGDataAsset_CortexScan");
static_assert(offsetof(UBFGDataAsset_CortexScan, M_bTerminateSearch) == 0x000030, "Member 'UBFGDataAsset_CortexScan::M_bTerminateSearch' has a wrong offset!");
static_assert(offsetof(UBFGDataAsset_CortexScan, M_entryPointSelectionMode) == 0x000031, "Member 'UBFGDataAsset_CortexScan::M_entryPointSelectionMode' has a wrong offset!");
static_assert(offsetof(UBFGDataAsset_CortexScan, M_aStringTables) == 0x000038, "Member 'UBFGDataAsset_CortexScan::M_aStringTables' has a wrong offset!");
static_assert(offsetof(UBFGDataAsset_CortexScan, M_aTextEntries) == 0x000048, "Member 'UBFGDataAsset_CortexScan::M_aTextEntries' has a wrong offset!");

// Class BFGCore.BFGQuest_StartupMode
// 0x0020 (0x0048 - 0x0028)
class UBFGQuest_StartupMode final : public UObject
{
public:
	class UClass*                                 M_pQuestClass;                                     // 0x0028(0x0008)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_30[0x18];                                      // 0x0030(0x0018)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"BFGQuest_StartupMode">();
	}
	static class UBFGQuest_StartupMode* GetDefaultObj()
	{
		return GetDefaultObjImpl<UBFGQuest_StartupMode>();
	}
};
static_assert(alignof(UBFGQuest_StartupMode) == 0x000008, "Wrong alignment on UBFGQuest_StartupMode");
static_assert(sizeof(UBFGQuest_StartupMode) == 0x000048, "Wrong size on UBFGQuest_StartupMode");
static_assert(offsetof(UBFGQuest_StartupMode, M_pQuestClass) == 0x000028, "Member 'UBFGQuest_StartupMode::M_pQuestClass' has a wrong offset!");

// Class BFGCore.BFGActorComponent_SpawnManagerStats
// 0x0010 (0x0158 - 0x0148)
class UBFGActorComponent_SpawnManagerStats final : public UBFGActorComponent_StatsBase
{
public:
	class UBFGActorStat_Bool*                     M_pIsActiveStat;                                   // 0x0148(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UBFGActorStat_uint8*                    M_pCurrentWaveStat;                                // 0x0150(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)

public:
	class UBFGActorStat_uint8* GetCurrentWaveStat() const;
	class UBFGActorStat_Bool* GetIsActiveStat() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"BFGActorComponent_SpawnManagerStats">();
	}
	static class UBFGActorComponent_SpawnManagerStats* GetDefaultObj()
	{
		return GetDefaultObjImpl<UBFGActorComponent_SpawnManagerStats>();
	}
};
static_assert(alignof(UBFGActorComponent_SpawnManagerStats) == 0x000008, "Wrong alignment on UBFGActorComponent_SpawnManagerStats");
static_assert(sizeof(UBFGActorComponent_SpawnManagerStats) == 0x000158, "Wrong size on UBFGActorComponent_SpawnManagerStats");
static_assert(offsetof(UBFGActorComponent_SpawnManagerStats, M_pIsActiveStat) == 0x000148, "Member 'UBFGActorComponent_SpawnManagerStats::M_pIsActiveStat' has a wrong offset!");
static_assert(offsetof(UBFGActorComponent_SpawnManagerStats, M_pCurrentWaveStat) == 0x000150, "Member 'UBFGActorComponent_SpawnManagerStats::M_pCurrentWaveStat' has a wrong offset!");

// Class BFGCore.BFGNetworkPathAgent_AIStateNPCEnterVehicle
// 0x0218 (0x0270 - 0x0058)
class UBFGNetworkPathAgent_AIStateNPCEnterVehicle final : public UBFGNetworkPathAgent_AIStateBase
{
public:
	EBFGAnimation_Interact                        M_eEnterAnimationId;                               // 0x0058(0x0001)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	EBFGAgentAIPassengerEnterPhase                M_ePhase;                                          // 0x0059(0x0001)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_5A[0x2];                                       // 0x005A(0x0002)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         M_fEnterTimer;                                     // 0x005C(0x0004)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	struct FTransform                             M_spotTransform;                                   // 0x0060(0x0030)(Transient, IsPlainOldData, NoDestructor, Protected, NativeAccessSpecifierProtected)
	struct FVector                                M_vEnterVector;                                    // 0x0090(0x000C)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_9C[0x4];                                       // 0x009C(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	struct FBFGVehiclePassengerSpot               M_spot;                                            // 0x00A0(0x0190)(Edit, BlueprintVisible, Protected, NativeAccessSpecifierProtected)
	class UBFGNetworkPathAgent_Vehicle*           M_pAttachedVehicle;                                // 0x0230(0x0008)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class FName                                   M_DoorBoneName;                                    // 0x0238(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UCurveFloat*                            M_pDoorAnimCurve;                                  // 0x0240(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	struct FVector                                M_vEntryStartLocation;                             // 0x0248(0x000C)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	struct FVector                                M_vEntryDirection;                                 // 0x0254(0x000C)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          M_bMustCloseDoor;                                  // 0x0260(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_261[0xF];                                      // 0x0261(0x000F)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"BFGNetworkPathAgent_AIStateNPCEnterVehicle">();
	}
	static class UBFGNetworkPathAgent_AIStateNPCEnterVehicle* GetDefaultObj()
	{
		return GetDefaultObjImpl<UBFGNetworkPathAgent_AIStateNPCEnterVehicle>();
	}
};
static_assert(alignof(UBFGNetworkPathAgent_AIStateNPCEnterVehicle) == 0x000010, "Wrong alignment on UBFGNetworkPathAgent_AIStateNPCEnterVehicle");
static_assert(sizeof(UBFGNetworkPathAgent_AIStateNPCEnterVehicle) == 0x000270, "Wrong size on UBFGNetworkPathAgent_AIStateNPCEnterVehicle");
static_assert(offsetof(UBFGNetworkPathAgent_AIStateNPCEnterVehicle, M_eEnterAnimationId) == 0x000058, "Member 'UBFGNetworkPathAgent_AIStateNPCEnterVehicle::M_eEnterAnimationId' has a wrong offset!");
static_assert(offsetof(UBFGNetworkPathAgent_AIStateNPCEnterVehicle, M_ePhase) == 0x000059, "Member 'UBFGNetworkPathAgent_AIStateNPCEnterVehicle::M_ePhase' has a wrong offset!");
static_assert(offsetof(UBFGNetworkPathAgent_AIStateNPCEnterVehicle, M_fEnterTimer) == 0x00005C, "Member 'UBFGNetworkPathAgent_AIStateNPCEnterVehicle::M_fEnterTimer' has a wrong offset!");
static_assert(offsetof(UBFGNetworkPathAgent_AIStateNPCEnterVehicle, M_spotTransform) == 0x000060, "Member 'UBFGNetworkPathAgent_AIStateNPCEnterVehicle::M_spotTransform' has a wrong offset!");
static_assert(offsetof(UBFGNetworkPathAgent_AIStateNPCEnterVehicle, M_vEnterVector) == 0x000090, "Member 'UBFGNetworkPathAgent_AIStateNPCEnterVehicle::M_vEnterVector' has a wrong offset!");
static_assert(offsetof(UBFGNetworkPathAgent_AIStateNPCEnterVehicle, M_spot) == 0x0000A0, "Member 'UBFGNetworkPathAgent_AIStateNPCEnterVehicle::M_spot' has a wrong offset!");
static_assert(offsetof(UBFGNetworkPathAgent_AIStateNPCEnterVehicle, M_pAttachedVehicle) == 0x000230, "Member 'UBFGNetworkPathAgent_AIStateNPCEnterVehicle::M_pAttachedVehicle' has a wrong offset!");
static_assert(offsetof(UBFGNetworkPathAgent_AIStateNPCEnterVehicle, M_DoorBoneName) == 0x000238, "Member 'UBFGNetworkPathAgent_AIStateNPCEnterVehicle::M_DoorBoneName' has a wrong offset!");
static_assert(offsetof(UBFGNetworkPathAgent_AIStateNPCEnterVehicle, M_pDoorAnimCurve) == 0x000240, "Member 'UBFGNetworkPathAgent_AIStateNPCEnterVehicle::M_pDoorAnimCurve' has a wrong offset!");
static_assert(offsetof(UBFGNetworkPathAgent_AIStateNPCEnterVehicle, M_vEntryStartLocation) == 0x000248, "Member 'UBFGNetworkPathAgent_AIStateNPCEnterVehicle::M_vEntryStartLocation' has a wrong offset!");
static_assert(offsetof(UBFGNetworkPathAgent_AIStateNPCEnterVehicle, M_vEntryDirection) == 0x000254, "Member 'UBFGNetworkPathAgent_AIStateNPCEnterVehicle::M_vEntryDirection' has a wrong offset!");
static_assert(offsetof(UBFGNetworkPathAgent_AIStateNPCEnterVehicle, M_bMustCloseDoor) == 0x000260, "Member 'UBFGNetworkPathAgent_AIStateNPCEnterVehicle::M_bMustCloseDoor' has a wrong offset!");

// Class BFGCore.BFGActorComponent_TankCinematic
// 0x00D8 (0x0200 - 0x0128)
class UBFGActorComponent_TankCinematic final : public UActorComponent
{
public:
	class FName                                   M_splineCompName;                                  // 0x0128(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         M_fOverlapBetweenChains;                           // 0x0130(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         M_fTrackHeight;                                    // 0x0134(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TMap<class FName, int32>                      M_BoneNamesSplinePointsMap;                        // 0x0138(0x0050)(Edit, BlueprintVisible, ZeroConstructor, Interp, Protected, NativeAccessSpecifierProtected)
	TArray<class FName>                           M_BoneForWheelsRotationArray;                      // 0x0188(0x0010)(Edit, ZeroConstructor, Protected, NativeAccessSpecifierProtected)
	class UStaticMesh*                            M_pTrackChainStaticMesh;                           // 0x0198(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         M_fTankActualSpeed;                                // 0x01A0(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, Interp, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         M_fDeltaRot;                                       // 0x01A4(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, Interp, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_1A8[0x30];                                     // 0x01A8(0x0030)(Fixing Size After Last Property [ Dumper-7 ])
	class UPoseableMeshComponent*                 M_pTankPoesableComponent;                          // 0x01D8(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	TArray<class UActorComponent*>                M_pSplineActorComponentArray;                      // 0x01E0(0x0010)(ExportObject, ZeroConstructor, ContainsInstancedReference, NativeAccessSpecifierPrivate)
	class UInstancedStaticMeshComponent*          M_pInstanceMeshComp;                               // 0x01F0(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class USplineComponent*                       M_pSplineComponent;                                // 0x01F8(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"BFGActorComponent_TankCinematic">();
	}
	static class UBFGActorComponent_TankCinematic* GetDefaultObj()
	{
		return GetDefaultObjImpl<UBFGActorComponent_TankCinematic>();
	}
};
static_assert(alignof(UBFGActorComponent_TankCinematic) == 0x000008, "Wrong alignment on UBFGActorComponent_TankCinematic");
static_assert(sizeof(UBFGActorComponent_TankCinematic) == 0x000200, "Wrong size on UBFGActorComponent_TankCinematic");
static_assert(offsetof(UBFGActorComponent_TankCinematic, M_splineCompName) == 0x000128, "Member 'UBFGActorComponent_TankCinematic::M_splineCompName' has a wrong offset!");
static_assert(offsetof(UBFGActorComponent_TankCinematic, M_fOverlapBetweenChains) == 0x000130, "Member 'UBFGActorComponent_TankCinematic::M_fOverlapBetweenChains' has a wrong offset!");
static_assert(offsetof(UBFGActorComponent_TankCinematic, M_fTrackHeight) == 0x000134, "Member 'UBFGActorComponent_TankCinematic::M_fTrackHeight' has a wrong offset!");
static_assert(offsetof(UBFGActorComponent_TankCinematic, M_BoneNamesSplinePointsMap) == 0x000138, "Member 'UBFGActorComponent_TankCinematic::M_BoneNamesSplinePointsMap' has a wrong offset!");
static_assert(offsetof(UBFGActorComponent_TankCinematic, M_BoneForWheelsRotationArray) == 0x000188, "Member 'UBFGActorComponent_TankCinematic::M_BoneForWheelsRotationArray' has a wrong offset!");
static_assert(offsetof(UBFGActorComponent_TankCinematic, M_pTrackChainStaticMesh) == 0x000198, "Member 'UBFGActorComponent_TankCinematic::M_pTrackChainStaticMesh' has a wrong offset!");
static_assert(offsetof(UBFGActorComponent_TankCinematic, M_fTankActualSpeed) == 0x0001A0, "Member 'UBFGActorComponent_TankCinematic::M_fTankActualSpeed' has a wrong offset!");
static_assert(offsetof(UBFGActorComponent_TankCinematic, M_fDeltaRot) == 0x0001A4, "Member 'UBFGActorComponent_TankCinematic::M_fDeltaRot' has a wrong offset!");
static_assert(offsetof(UBFGActorComponent_TankCinematic, M_pTankPoesableComponent) == 0x0001D8, "Member 'UBFGActorComponent_TankCinematic::M_pTankPoesableComponent' has a wrong offset!");
static_assert(offsetof(UBFGActorComponent_TankCinematic, M_pSplineActorComponentArray) == 0x0001E0, "Member 'UBFGActorComponent_TankCinematic::M_pSplineActorComponentArray' has a wrong offset!");
static_assert(offsetof(UBFGActorComponent_TankCinematic, M_pInstanceMeshComp) == 0x0001F0, "Member 'UBFGActorComponent_TankCinematic::M_pInstanceMeshComp' has a wrong offset!");
static_assert(offsetof(UBFGActorComponent_TankCinematic, M_pSplineComponent) == 0x0001F8, "Member 'UBFGActorComponent_TankCinematic::M_pSplineComponent' has a wrong offset!");

// Class BFGCore.BFGDataAsset_BossData
// 0x0028 (0x0058 - 0x0030)
class UBFGDataAsset_BossData : public UDataAsset
{
public:
	struct FBossImmunities                        M_oImmunities;                                     // 0x0030(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, NativeAccessSpecifierProtected)
	uint8                                         Pad_31[0x7];                                       // 0x0031(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<class UBFGDataAsset_BossPhase*>        M_aPhases;                                         // 0x0038(0x0010)(Edit, BlueprintVisible, ZeroConstructor, Protected, NativeAccessSpecifierProtected)
	class UCurveFloat*                            M_pWarningTimeline_SpeedCurve;                     // 0x0048(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         M_fCallReinforcementActionTelegraphTime;           // 0x0050(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         M_fCallReinforcementCooldownTime;                  // 0x0054(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"BFGDataAsset_BossData">();
	}
	static class UBFGDataAsset_BossData* GetDefaultObj()
	{
		return GetDefaultObjImpl<UBFGDataAsset_BossData>();
	}
};
static_assert(alignof(UBFGDataAsset_BossData) == 0x000008, "Wrong alignment on UBFGDataAsset_BossData");
static_assert(sizeof(UBFGDataAsset_BossData) == 0x000058, "Wrong size on UBFGDataAsset_BossData");
static_assert(offsetof(UBFGDataAsset_BossData, M_oImmunities) == 0x000030, "Member 'UBFGDataAsset_BossData::M_oImmunities' has a wrong offset!");
static_assert(offsetof(UBFGDataAsset_BossData, M_aPhases) == 0x000038, "Member 'UBFGDataAsset_BossData::M_aPhases' has a wrong offset!");
static_assert(offsetof(UBFGDataAsset_BossData, M_pWarningTimeline_SpeedCurve) == 0x000048, "Member 'UBFGDataAsset_BossData::M_pWarningTimeline_SpeedCurve' has a wrong offset!");
static_assert(offsetof(UBFGDataAsset_BossData, M_fCallReinforcementActionTelegraphTime) == 0x000050, "Member 'UBFGDataAsset_BossData::M_fCallReinforcementActionTelegraphTime' has a wrong offset!");
static_assert(offsetof(UBFGDataAsset_BossData, M_fCallReinforcementCooldownTime) == 0x000054, "Member 'UBFGDataAsset_BossData::M_fCallReinforcementCooldownTime' has a wrong offset!");

// Class BFGCore.BFGDataAsset_BossData_Silhouette
// 0x0060 (0x00B8 - 0x0058)
class UBFGDataAsset_BossData_Silhouette final : public UBFGDataAsset_BossData
{
public:
	struct FVector                                M_vTelegraphLazerBeamColour;                       // 0x0058(0x000C)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   M_oLeftTelegraphLazerBeamStartBoneName;            // 0x0064(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   M_oRightTelegraphLazerBeamStartBoneName;           // 0x006C(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   M_oTelegraphLazerBeamEndBoneName;                  // 0x0074(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         M_fShieldCriticalStateDuration;                    // 0x007C(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         M_fTotalTime_Levitation_UP;                        // 0x0080(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_84[0x4];                                       // 0x0084(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class UCurveFloat*                            M_pLevitationCurve_UP;                             // 0x0088(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         M_fTotalTime_Levitation_DOWN;                      // 0x0090(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_94[0x4];                                       // 0x0094(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class UCurveFloat*                            M_pLevitationCurve_DOWN;                           // 0x0098(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         M_pLevitationDamageMultiplier;                     // 0x00A0(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         M_pEvasionDistanceFromIon;                         // 0x00A4(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         M_pEvasionMaxRange;                                // 0x00A8(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_AC[0x4];                                       // 0x00AC(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class UCurveVector*                           M_pEvasionVectorCurve;                             // 0x00B0(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"BFGDataAsset_BossData_Silhouette">();
	}
	static class UBFGDataAsset_BossData_Silhouette* GetDefaultObj()
	{
		return GetDefaultObjImpl<UBFGDataAsset_BossData_Silhouette>();
	}
};
static_assert(alignof(UBFGDataAsset_BossData_Silhouette) == 0x000008, "Wrong alignment on UBFGDataAsset_BossData_Silhouette");
static_assert(sizeof(UBFGDataAsset_BossData_Silhouette) == 0x0000B8, "Wrong size on UBFGDataAsset_BossData_Silhouette");
static_assert(offsetof(UBFGDataAsset_BossData_Silhouette, M_vTelegraphLazerBeamColour) == 0x000058, "Member 'UBFGDataAsset_BossData_Silhouette::M_vTelegraphLazerBeamColour' has a wrong offset!");
static_assert(offsetof(UBFGDataAsset_BossData_Silhouette, M_oLeftTelegraphLazerBeamStartBoneName) == 0x000064, "Member 'UBFGDataAsset_BossData_Silhouette::M_oLeftTelegraphLazerBeamStartBoneName' has a wrong offset!");
static_assert(offsetof(UBFGDataAsset_BossData_Silhouette, M_oRightTelegraphLazerBeamStartBoneName) == 0x00006C, "Member 'UBFGDataAsset_BossData_Silhouette::M_oRightTelegraphLazerBeamStartBoneName' has a wrong offset!");
static_assert(offsetof(UBFGDataAsset_BossData_Silhouette, M_oTelegraphLazerBeamEndBoneName) == 0x000074, "Member 'UBFGDataAsset_BossData_Silhouette::M_oTelegraphLazerBeamEndBoneName' has a wrong offset!");
static_assert(offsetof(UBFGDataAsset_BossData_Silhouette, M_fShieldCriticalStateDuration) == 0x00007C, "Member 'UBFGDataAsset_BossData_Silhouette::M_fShieldCriticalStateDuration' has a wrong offset!");
static_assert(offsetof(UBFGDataAsset_BossData_Silhouette, M_fTotalTime_Levitation_UP) == 0x000080, "Member 'UBFGDataAsset_BossData_Silhouette::M_fTotalTime_Levitation_UP' has a wrong offset!");
static_assert(offsetof(UBFGDataAsset_BossData_Silhouette, M_pLevitationCurve_UP) == 0x000088, "Member 'UBFGDataAsset_BossData_Silhouette::M_pLevitationCurve_UP' has a wrong offset!");
static_assert(offsetof(UBFGDataAsset_BossData_Silhouette, M_fTotalTime_Levitation_DOWN) == 0x000090, "Member 'UBFGDataAsset_BossData_Silhouette::M_fTotalTime_Levitation_DOWN' has a wrong offset!");
static_assert(offsetof(UBFGDataAsset_BossData_Silhouette, M_pLevitationCurve_DOWN) == 0x000098, "Member 'UBFGDataAsset_BossData_Silhouette::M_pLevitationCurve_DOWN' has a wrong offset!");
static_assert(offsetof(UBFGDataAsset_BossData_Silhouette, M_pLevitationDamageMultiplier) == 0x0000A0, "Member 'UBFGDataAsset_BossData_Silhouette::M_pLevitationDamageMultiplier' has a wrong offset!");
static_assert(offsetof(UBFGDataAsset_BossData_Silhouette, M_pEvasionDistanceFromIon) == 0x0000A4, "Member 'UBFGDataAsset_BossData_Silhouette::M_pEvasionDistanceFromIon' has a wrong offset!");
static_assert(offsetof(UBFGDataAsset_BossData_Silhouette, M_pEvasionMaxRange) == 0x0000A8, "Member 'UBFGDataAsset_BossData_Silhouette::M_pEvasionMaxRange' has a wrong offset!");
static_assert(offsetof(UBFGDataAsset_BossData_Silhouette, M_pEvasionVectorCurve) == 0x0000B0, "Member 'UBFGDataAsset_BossData_Silhouette::M_pEvasionVectorCurve' has a wrong offset!");

// Class BFGCore.BFGWheeledVehicle
// 0x0948 (0x0D90 - 0x0448)
class ABFGWheeledVehicle : public AWheeledVehicle
{
public:
	uint8                                         Pad_448[0x50];                                     // 0x0448(0x0050)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         M_fPKDamageMultiplier;                             // 0x0498(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_49C[0x4];                                      // 0x049C(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class UBFGActorComponent_GameplayEffectTags*  M_pGameplayEffectTagsComponent;                    // 0x04A0(0x0008)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, EditConst, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UBFGActorComponent_LockOnTarget*        M_pLockOnTargetComponent;                          // 0x04A8(0x0008)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, EditConst, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TMap<class UStaticMeshComponent*, class FName> GlassMap;                                          // 0x04B0(0x0050)(Edit, BlueprintVisible, ZeroConstructor, EditConst, ContainsInstancedReference, Protected, NativeAccessSpecifierProtected)
	TMap<class UDestructibleMesh*, class FName>   DestructibleGlassMap;                              // 0x0500(0x0050)(Edit, BlueprintVisible, ZeroConstructor, Transient, EditConst, Protected, NativeAccessSpecifierProtected)
	class UStaticMeshComponent*                   LightBulbsMesh;                                    // 0x0550(0x0008)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, Transient, EditConst, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class USpotLightComponent*                    FrontRightSpotLight;                               // 0x0558(0x0008)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, Transient, EditConst, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class USpotLightComponent*                    FrontLeftSpotLight;                                // 0x0560(0x0008)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, Transient, EditConst, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class FString                                 LicensePlateNumberChain;                           // 0x0568(0x0010)(Edit, BlueprintVisible, ZeroConstructor, EditConst, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UBFGActorComponent_MonetaryValue*       M_pMonetaryValueComponent;                         // 0x0578(0x0008)(Edit, BlueprintVisible, ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TArray<class USceneComponent*>                ChildComponents;                                   // 0x0580(0x0010)(ExportObject, ZeroConstructor, Transient, ContainsInstancedReference, Protected, NativeAccessSpecifierProtected)
	TArray<class FName>                           AdditionalWheels;                                  // 0x0590(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Protected, NativeAccessSpecifierProtected)
	TArray<class USceneComponent*>                Doors;                                             // 0x05A0(0x0010)(Edit, BlueprintVisible, ExportObject, ZeroConstructor, EditConst, ContainsInstancedReference, Protected, NativeAccessSpecifierProtected)
	TArray<class USceneComponent*>                GlassComponents;                                   // 0x05B0(0x0010)(Edit, BlueprintVisible, ExportObject, ZeroConstructor, EditConst, ContainsInstancedReference, Protected, NativeAccessSpecifierProtected)
	TArray<class UStaticMeshComponent*>           M_apEngineMeshes;                                  // 0x05C0(0x0010)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, Transient, EditConst, ContainsInstancedReference, Protected, NativeAccessSpecifierProtected)
	EBFGFaction                                   M_faction;                                         // 0x05D0(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_5D1[0x7];                                      // 0x05D1(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	class UBFGActorComponent_PawnDamage*          M_pDamageComponent;                                // 0x05D8(0x0008)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, EditConst, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UBFGActorComponent_PawnStats*           M_pStatsComponent;                                 // 0x05E0(0x0008)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, EditConst, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class USceneComponent*                        M_pObjectiveMarkerParentComponent;                 // 0x05E8(0x0008)(Edit, BlueprintVisible, ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UBFGActorComponent_Objective*           M_pObjectiveComponent;                             // 0x05F0(0x0008)(Edit, BlueprintVisible, ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UBFGActorComponent_FallDamage*          M_pFallDamageComponent;                            // 0x05F8(0x0008)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, EditConst, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UBFGActorComponent_EquipmentManager*    M_pEquipmentManager;                               // 0x0600(0x0008)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, EditConst, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	struct FSoftClassPath                         M_WeaponClass;                                     // 0x0608(0x0018)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, Protected, NativeAccessSpecifierProtected)
	class FName                                   M_strWeaponSocketName;                             // 0x0620(0x0008)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UBFGActorComponent_Effect*              M_pEffectComponent;                                // 0x0628(0x0008)(Edit, BlueprintVisible, ExportObject, ZeroConstructor, DisableEditOnInstance, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UBFGActorComponent_MissionGameplay*     M_pMissionGameplayComponent;                       // 0x0630(0x0008)(Edit, ExportObject, ZeroConstructor, EditConst, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UBFGActorComponent_AITarget*            M_pAITargetComponent;                              // 0x0638(0x0008)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, EditConst, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          M_bExplodesOnDeath;                                // 0x0640(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_641[0x7];                                      // 0x0641(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	class UBFGActorComponent_ExplosiveItem*       M_pExplosiveComponent;                             // 0x0648(0x0008)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UBFGBuoyancyForceComponent*             M_pBuoyancyComponent;                              // 0x0650(0x0008)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_658[0x50];                                     // 0x0658(0x0050)(Fixing Size After Last Property [ Dumper-7 ])
	class UBFGActorComponent_HolobobSuppressionAura* M_pHolobobSuppressionAuraComponent;                // 0x06A8(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, Transient, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          M_bImmuneToTransmog;                               // 0x06B0(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_6B1[0x7];                                      // 0x06B1(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	class UParticleSystem*                        M_cOnDeathParticles;                               // 0x06B8(0x0008)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TArray<class UMaterialInstanceDynamic*>       DynamicMaterials;                                  // 0x06C0(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, EditConst, NativeAccessSpecifierPublic)
	class UMaterialInstance*                      LightBulbsMaterial;                                // 0x06D0(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UMaterialInstanceDynamic*               M_pSirenMaterial;                                  // 0x06D8(0x0008)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FBFGWheeledVehicleConfig               Config;                                            // 0x06E0(0x03B8)(Edit, BlueprintVisible, NativeAccessSpecifierPublic)
	TArray<struct FBFGVehiclePlugin>              M_aPlugins;                                        // 0x0A98(0x0010)(ZeroConstructor, Transient, ContainsInstancedReference, NativeAccessSpecifierPublic)
	struct FVector                                NextPoint;                                         // 0x0AA8(0x000C)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_AB4[0x4];                                      // 0x0AB4(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class UBoxComponent*                          M_pBoundingBox;                                    // 0x0AB8(0x0008)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, Transient, EditConst, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class USkeletalMeshComponent*                 M_pSkeletalPushBar;                                // 0x0AC0(0x0008)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, Transient, EditConst, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                M_vPushBarScale;                                   // 0x0AC8(0x000C)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                M_vPushBarOffset;                                  // 0x0AD4(0x000C)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                M_vBrakeBarScale;                                  // 0x0AE0(0x000C)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                M_vBrakeBarOffset;                                 // 0x0AEC(0x000C)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FBFGVehicleAgentDriveInfo              M_driveInfo;                                       // 0x0AF8(0x005C)(Transient, NoDestructor, NativeAccessSpecifierPublic)
	uint8                                         Pad_B54[0x4];                                      // 0x0B54(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	struct FBFGVehicleState                       M_vehicleState;                                    // 0x0B58(0x0018)(Transient, NativeAccessSpecifierPublic)
	bool                                          M_bUpVectorFix;                                    // 0x0B70(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          M_bCarLightsOn;                                    // 0x0B71(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_B72[0x2];                                      // 0x0B72(0x0002)(Fixing Size After Last Property [ Dumper-7 ])
	int32                                         M_iRequestedPalette;                               // 0x0B74(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          M_bIsStaticCar;                                    // 0x0B78(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_B79[0x3];                                      // 0x0B79(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         M_fLastSteeringInput;                              // 0x0B7C(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TArray<class AActor*>                         M_apActorsOverlappingBrakeBox;                     // 0x0B80(0x0010)(ZeroConstructor, Protected, NativeAccessSpecifierProtected)
	struct FGameplayTagContainer                  M_gameplayTags;                                    // 0x0B90(0x0020)(Edit, BlueprintVisible, BlueprintReadOnly, Protected, NativeAccessSpecifierProtected)
	struct FVector                                M_vLastPosition;                                   // 0x0BB0(0x000C)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         M_fCurrentThrottle;                                // 0x0BBC(0x0004)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         M_fCurrentBrake;                                   // 0x0BC0(0x0004)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         M_fLastSpeed;                                      // 0x0BC4(0x0004)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         M_fPitch;                                          // 0x0BC8(0x0004)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         M_fTimer;                                          // 0x0BCC(0x0004)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         M_fDistanceDelta;                                  // 0x0BD0(0x0004)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         M_fDistanceDeltaTimer;                             // 0x0BD4(0x0004)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         M_fLastAcceleration;                               // 0x0BD8(0x0004)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         M_fWheelDistance;                                  // 0x0BDC(0x0004)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          M_bAutoRegisterMovementComponent;                  // 0x0BE0(0x0001)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          M_bSetupDone;                                      // 0x0BE1(0x0001)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_BE2[0x6];                                      // 0x0BE2(0x0006)(Fixing Size After Last Property [ Dumper-7 ])
	class UBFGNetworkPathAgentComponent*          M_pNetworkPathAgentComponent;                      // 0x0BE8(0x0008)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UBFGActorComponent_CrowdAgentVehicle*   M_pCrowdAgentInterfaceComponent;                   // 0x0BF0(0x0008)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, EditConst, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TSubclassOf<class UNavArea>                   M_pAreaClass_IsStaticVehicle;                      // 0x0BF8(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	struct FBFGVehicleObstacleInFront             M_obstacleInFront;                                 // 0x0C00(0x0084)(Edit, BlueprintVisible, NoDestructor, Protected, NativeAccessSpecifierProtected)
	uint8                                         Pad_C84[0x4];                                      // 0x0C84(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class UBFGVehicleDeformation*                 M_pCachedVehicleDeformation;                       // 0x0C88(0x0008)(ExportObject, ZeroConstructor, Transient, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_C90[0xC];                                      // 0x0C90(0x000C)(Fixing Size After Last Property [ Dumper-7 ])
	bool                                          M_bIsTransmogging;                                 // 0x0C9C(0x0001)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_C9D[0x3];                                      // 0x0C9D(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	class ABFGGameState*                          M_pGameState;                                      // 0x0CA0(0x0008)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_CA8[0x18];                                     // 0x0CA8(0x0018)(Fixing Size After Last Property [ Dumper-7 ])
	struct FBFGVirtualVehicle                     M_virtualVehicle;                                  // 0x0CC0(0x00D0)(Transient, NoDestructor, NativeAccessSpecifierPrivate)

public:
	void AddCarPlate(class FName SocketName, class UTextRenderComponent** CenterText, class UTextRenderComponent** TopText, class UTextRenderComponent** BottomText);
	float HonkAtObstacleInFront();
	void OnBrakeBoxBeginOverlap(class UPrimitiveComponent* _pOverlappedComponent, class AActor* _pOtherActor, class UPrimitiveComponent* _pOtherComp, int32 _iOtherBodyIndex, bool _bFromSweep, const struct FHitResult& _sweepResult);
	void OnBrakeBoxEndOverlap(class UPrimitiveComponent* _pOverlappedComponent, class AActor* _pOtherActor, class UPrimitiveComponent* _pOtherComp, int32 _iOtherBodyIndex);
	void OnVehicleDeath();
	void SetCarPlates();
	void SetColorVariations();
	void SetDoorOpen(int32 IDoorIndex, bool bOpen);
	void SetDoors();
	void SetEssentials();
	void SetLightBulbs();
	void SetPlugins();
	void SetupVehicle();
	void SetupWheels();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"BFGWheeledVehicle">();
	}
	static class ABFGWheeledVehicle* GetDefaultObj()
	{
		return GetDefaultObjImpl<ABFGWheeledVehicle>();
	}
};
static_assert(alignof(ABFGWheeledVehicle) == 0x000010, "Wrong alignment on ABFGWheeledVehicle");
static_assert(sizeof(ABFGWheeledVehicle) == 0x000D90, "Wrong size on ABFGWheeledVehicle");
static_assert(offsetof(ABFGWheeledVehicle, M_fPKDamageMultiplier) == 0x000498, "Member 'ABFGWheeledVehicle::M_fPKDamageMultiplier' has a wrong offset!");
static_assert(offsetof(ABFGWheeledVehicle, M_pGameplayEffectTagsComponent) == 0x0004A0, "Member 'ABFGWheeledVehicle::M_pGameplayEffectTagsComponent' has a wrong offset!");
static_assert(offsetof(ABFGWheeledVehicle, M_pLockOnTargetComponent) == 0x0004A8, "Member 'ABFGWheeledVehicle::M_pLockOnTargetComponent' has a wrong offset!");
static_assert(offsetof(ABFGWheeledVehicle, GlassMap) == 0x0004B0, "Member 'ABFGWheeledVehicle::GlassMap' has a wrong offset!");
static_assert(offsetof(ABFGWheeledVehicle, DestructibleGlassMap) == 0x000500, "Member 'ABFGWheeledVehicle::DestructibleGlassMap' has a wrong offset!");
static_assert(offsetof(ABFGWheeledVehicle, LightBulbsMesh) == 0x000550, "Member 'ABFGWheeledVehicle::LightBulbsMesh' has a wrong offset!");
static_assert(offsetof(ABFGWheeledVehicle, FrontRightSpotLight) == 0x000558, "Member 'ABFGWheeledVehicle::FrontRightSpotLight' has a wrong offset!");
static_assert(offsetof(ABFGWheeledVehicle, FrontLeftSpotLight) == 0x000560, "Member 'ABFGWheeledVehicle::FrontLeftSpotLight' has a wrong offset!");
static_assert(offsetof(ABFGWheeledVehicle, LicensePlateNumberChain) == 0x000568, "Member 'ABFGWheeledVehicle::LicensePlateNumberChain' has a wrong offset!");
static_assert(offsetof(ABFGWheeledVehicle, M_pMonetaryValueComponent) == 0x000578, "Member 'ABFGWheeledVehicle::M_pMonetaryValueComponent' has a wrong offset!");
static_assert(offsetof(ABFGWheeledVehicle, ChildComponents) == 0x000580, "Member 'ABFGWheeledVehicle::ChildComponents' has a wrong offset!");
static_assert(offsetof(ABFGWheeledVehicle, AdditionalWheels) == 0x000590, "Member 'ABFGWheeledVehicle::AdditionalWheels' has a wrong offset!");
static_assert(offsetof(ABFGWheeledVehicle, Doors) == 0x0005A0, "Member 'ABFGWheeledVehicle::Doors' has a wrong offset!");
static_assert(offsetof(ABFGWheeledVehicle, GlassComponents) == 0x0005B0, "Member 'ABFGWheeledVehicle::GlassComponents' has a wrong offset!");
static_assert(offsetof(ABFGWheeledVehicle, M_apEngineMeshes) == 0x0005C0, "Member 'ABFGWheeledVehicle::M_apEngineMeshes' has a wrong offset!");
static_assert(offsetof(ABFGWheeledVehicle, M_faction) == 0x0005D0, "Member 'ABFGWheeledVehicle::M_faction' has a wrong offset!");
static_assert(offsetof(ABFGWheeledVehicle, M_pDamageComponent) == 0x0005D8, "Member 'ABFGWheeledVehicle::M_pDamageComponent' has a wrong offset!");
static_assert(offsetof(ABFGWheeledVehicle, M_pStatsComponent) == 0x0005E0, "Member 'ABFGWheeledVehicle::M_pStatsComponent' has a wrong offset!");
static_assert(offsetof(ABFGWheeledVehicle, M_pObjectiveMarkerParentComponent) == 0x0005E8, "Member 'ABFGWheeledVehicle::M_pObjectiveMarkerParentComponent' has a wrong offset!");
static_assert(offsetof(ABFGWheeledVehicle, M_pObjectiveComponent) == 0x0005F0, "Member 'ABFGWheeledVehicle::M_pObjectiveComponent' has a wrong offset!");
static_assert(offsetof(ABFGWheeledVehicle, M_pFallDamageComponent) == 0x0005F8, "Member 'ABFGWheeledVehicle::M_pFallDamageComponent' has a wrong offset!");
static_assert(offsetof(ABFGWheeledVehicle, M_pEquipmentManager) == 0x000600, "Member 'ABFGWheeledVehicle::M_pEquipmentManager' has a wrong offset!");
static_assert(offsetof(ABFGWheeledVehicle, M_WeaponClass) == 0x000608, "Member 'ABFGWheeledVehicle::M_WeaponClass' has a wrong offset!");
static_assert(offsetof(ABFGWheeledVehicle, M_strWeaponSocketName) == 0x000620, "Member 'ABFGWheeledVehicle::M_strWeaponSocketName' has a wrong offset!");
static_assert(offsetof(ABFGWheeledVehicle, M_pEffectComponent) == 0x000628, "Member 'ABFGWheeledVehicle::M_pEffectComponent' has a wrong offset!");
static_assert(offsetof(ABFGWheeledVehicle, M_pMissionGameplayComponent) == 0x000630, "Member 'ABFGWheeledVehicle::M_pMissionGameplayComponent' has a wrong offset!");
static_assert(offsetof(ABFGWheeledVehicle, M_pAITargetComponent) == 0x000638, "Member 'ABFGWheeledVehicle::M_pAITargetComponent' has a wrong offset!");
static_assert(offsetof(ABFGWheeledVehicle, M_bExplodesOnDeath) == 0x000640, "Member 'ABFGWheeledVehicle::M_bExplodesOnDeath' has a wrong offset!");
static_assert(offsetof(ABFGWheeledVehicle, M_pExplosiveComponent) == 0x000648, "Member 'ABFGWheeledVehicle::M_pExplosiveComponent' has a wrong offset!");
static_assert(offsetof(ABFGWheeledVehicle, M_pBuoyancyComponent) == 0x000650, "Member 'ABFGWheeledVehicle::M_pBuoyancyComponent' has a wrong offset!");
static_assert(offsetof(ABFGWheeledVehicle, M_pHolobobSuppressionAuraComponent) == 0x0006A8, "Member 'ABFGWheeledVehicle::M_pHolobobSuppressionAuraComponent' has a wrong offset!");
static_assert(offsetof(ABFGWheeledVehicle, M_bImmuneToTransmog) == 0x0006B0, "Member 'ABFGWheeledVehicle::M_bImmuneToTransmog' has a wrong offset!");
static_assert(offsetof(ABFGWheeledVehicle, M_cOnDeathParticles) == 0x0006B8, "Member 'ABFGWheeledVehicle::M_cOnDeathParticles' has a wrong offset!");
static_assert(offsetof(ABFGWheeledVehicle, DynamicMaterials) == 0x0006C0, "Member 'ABFGWheeledVehicle::DynamicMaterials' has a wrong offset!");
static_assert(offsetof(ABFGWheeledVehicle, LightBulbsMaterial) == 0x0006D0, "Member 'ABFGWheeledVehicle::LightBulbsMaterial' has a wrong offset!");
static_assert(offsetof(ABFGWheeledVehicle, M_pSirenMaterial) == 0x0006D8, "Member 'ABFGWheeledVehicle::M_pSirenMaterial' has a wrong offset!");
static_assert(offsetof(ABFGWheeledVehicle, Config) == 0x0006E0, "Member 'ABFGWheeledVehicle::Config' has a wrong offset!");
static_assert(offsetof(ABFGWheeledVehicle, M_aPlugins) == 0x000A98, "Member 'ABFGWheeledVehicle::M_aPlugins' has a wrong offset!");
static_assert(offsetof(ABFGWheeledVehicle, NextPoint) == 0x000AA8, "Member 'ABFGWheeledVehicle::NextPoint' has a wrong offset!");
static_assert(offsetof(ABFGWheeledVehicle, M_pBoundingBox) == 0x000AB8, "Member 'ABFGWheeledVehicle::M_pBoundingBox' has a wrong offset!");
static_assert(offsetof(ABFGWheeledVehicle, M_pSkeletalPushBar) == 0x000AC0, "Member 'ABFGWheeledVehicle::M_pSkeletalPushBar' has a wrong offset!");
static_assert(offsetof(ABFGWheeledVehicle, M_vPushBarScale) == 0x000AC8, "Member 'ABFGWheeledVehicle::M_vPushBarScale' has a wrong offset!");
static_assert(offsetof(ABFGWheeledVehicle, M_vPushBarOffset) == 0x000AD4, "Member 'ABFGWheeledVehicle::M_vPushBarOffset' has a wrong offset!");
static_assert(offsetof(ABFGWheeledVehicle, M_vBrakeBarScale) == 0x000AE0, "Member 'ABFGWheeledVehicle::M_vBrakeBarScale' has a wrong offset!");
static_assert(offsetof(ABFGWheeledVehicle, M_vBrakeBarOffset) == 0x000AEC, "Member 'ABFGWheeledVehicle::M_vBrakeBarOffset' has a wrong offset!");
static_assert(offsetof(ABFGWheeledVehicle, M_driveInfo) == 0x000AF8, "Member 'ABFGWheeledVehicle::M_driveInfo' has a wrong offset!");
static_assert(offsetof(ABFGWheeledVehicle, M_vehicleState) == 0x000B58, "Member 'ABFGWheeledVehicle::M_vehicleState' has a wrong offset!");
static_assert(offsetof(ABFGWheeledVehicle, M_bUpVectorFix) == 0x000B70, "Member 'ABFGWheeledVehicle::M_bUpVectorFix' has a wrong offset!");
static_assert(offsetof(ABFGWheeledVehicle, M_bCarLightsOn) == 0x000B71, "Member 'ABFGWheeledVehicle::M_bCarLightsOn' has a wrong offset!");
static_assert(offsetof(ABFGWheeledVehicle, M_iRequestedPalette) == 0x000B74, "Member 'ABFGWheeledVehicle::M_iRequestedPalette' has a wrong offset!");
static_assert(offsetof(ABFGWheeledVehicle, M_bIsStaticCar) == 0x000B78, "Member 'ABFGWheeledVehicle::M_bIsStaticCar' has a wrong offset!");
static_assert(offsetof(ABFGWheeledVehicle, M_fLastSteeringInput) == 0x000B7C, "Member 'ABFGWheeledVehicle::M_fLastSteeringInput' has a wrong offset!");
static_assert(offsetof(ABFGWheeledVehicle, M_apActorsOverlappingBrakeBox) == 0x000B80, "Member 'ABFGWheeledVehicle::M_apActorsOverlappingBrakeBox' has a wrong offset!");
static_assert(offsetof(ABFGWheeledVehicle, M_gameplayTags) == 0x000B90, "Member 'ABFGWheeledVehicle::M_gameplayTags' has a wrong offset!");
static_assert(offsetof(ABFGWheeledVehicle, M_vLastPosition) == 0x000BB0, "Member 'ABFGWheeledVehicle::M_vLastPosition' has a wrong offset!");
static_assert(offsetof(ABFGWheeledVehicle, M_fCurrentThrottle) == 0x000BBC, "Member 'ABFGWheeledVehicle::M_fCurrentThrottle' has a wrong offset!");
static_assert(offsetof(ABFGWheeledVehicle, M_fCurrentBrake) == 0x000BC0, "Member 'ABFGWheeledVehicle::M_fCurrentBrake' has a wrong offset!");
static_assert(offsetof(ABFGWheeledVehicle, M_fLastSpeed) == 0x000BC4, "Member 'ABFGWheeledVehicle::M_fLastSpeed' has a wrong offset!");
static_assert(offsetof(ABFGWheeledVehicle, M_fPitch) == 0x000BC8, "Member 'ABFGWheeledVehicle::M_fPitch' has a wrong offset!");
static_assert(offsetof(ABFGWheeledVehicle, M_fTimer) == 0x000BCC, "Member 'ABFGWheeledVehicle::M_fTimer' has a wrong offset!");
static_assert(offsetof(ABFGWheeledVehicle, M_fDistanceDelta) == 0x000BD0, "Member 'ABFGWheeledVehicle::M_fDistanceDelta' has a wrong offset!");
static_assert(offsetof(ABFGWheeledVehicle, M_fDistanceDeltaTimer) == 0x000BD4, "Member 'ABFGWheeledVehicle::M_fDistanceDeltaTimer' has a wrong offset!");
static_assert(offsetof(ABFGWheeledVehicle, M_fLastAcceleration) == 0x000BD8, "Member 'ABFGWheeledVehicle::M_fLastAcceleration' has a wrong offset!");
static_assert(offsetof(ABFGWheeledVehicle, M_fWheelDistance) == 0x000BDC, "Member 'ABFGWheeledVehicle::M_fWheelDistance' has a wrong offset!");
static_assert(offsetof(ABFGWheeledVehicle, M_bAutoRegisterMovementComponent) == 0x000BE0, "Member 'ABFGWheeledVehicle::M_bAutoRegisterMovementComponent' has a wrong offset!");
static_assert(offsetof(ABFGWheeledVehicle, M_bSetupDone) == 0x000BE1, "Member 'ABFGWheeledVehicle::M_bSetupDone' has a wrong offset!");
static_assert(offsetof(ABFGWheeledVehicle, M_pNetworkPathAgentComponent) == 0x000BE8, "Member 'ABFGWheeledVehicle::M_pNetworkPathAgentComponent' has a wrong offset!");
static_assert(offsetof(ABFGWheeledVehicle, M_pCrowdAgentInterfaceComponent) == 0x000BF0, "Member 'ABFGWheeledVehicle::M_pCrowdAgentInterfaceComponent' has a wrong offset!");
static_assert(offsetof(ABFGWheeledVehicle, M_pAreaClass_IsStaticVehicle) == 0x000BF8, "Member 'ABFGWheeledVehicle::M_pAreaClass_IsStaticVehicle' has a wrong offset!");
static_assert(offsetof(ABFGWheeledVehicle, M_obstacleInFront) == 0x000C00, "Member 'ABFGWheeledVehicle::M_obstacleInFront' has a wrong offset!");
static_assert(offsetof(ABFGWheeledVehicle, M_pCachedVehicleDeformation) == 0x000C88, "Member 'ABFGWheeledVehicle::M_pCachedVehicleDeformation' has a wrong offset!");
static_assert(offsetof(ABFGWheeledVehicle, M_bIsTransmogging) == 0x000C9C, "Member 'ABFGWheeledVehicle::M_bIsTransmogging' has a wrong offset!");
static_assert(offsetof(ABFGWheeledVehicle, M_pGameState) == 0x000CA0, "Member 'ABFGWheeledVehicle::M_pGameState' has a wrong offset!");
static_assert(offsetof(ABFGWheeledVehicle, M_virtualVehicle) == 0x000CC0, "Member 'ABFGWheeledVehicle::M_virtualVehicle' has a wrong offset!");

// Class BFGCore.BFGWheeledVehicleTank
// 0x0070 (0x0E00 - 0x0D90)
class ABFGWheeledVehicleTank : public ABFGWheeledVehicle
{
public:
	uint8                                         Pad_D90[0x8];                                      // 0x0D90(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	class UBFGActorComponent_AimAssistTarget*     M_pAimAssistTargetComponent;                       // 0x0D98(0x0008)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, EditConst, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         _fTFrequence;                                      // 0x0DA0(0x0004)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_DA4[0x4];                                      // 0x0DA4(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<class UBFGActorComponent_TankTrack*>   M_apTracks;                                        // 0x0DA8(0x0010)(ExportObject, ZeroConstructor, Transient, ContainsInstancedReference, NativeAccessSpecifierPrivate)
	struct FBFGTankInfo                           M_tankInfo;                                        // 0x0DB8(0x0040)(Transient, NoDestructor, NativeAccessSpecifierPrivate)
	uint8                                         Pad_DF8[0x8];                                      // 0x0DF8(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void SetTrackUpdateFrequence(float _fNewTFrequence);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"BFGWheeledVehicleTank">();
	}
	static class ABFGWheeledVehicleTank* GetDefaultObj()
	{
		return GetDefaultObjImpl<ABFGWheeledVehicleTank>();
	}
};
static_assert(alignof(ABFGWheeledVehicleTank) == 0x000010, "Wrong alignment on ABFGWheeledVehicleTank");
static_assert(sizeof(ABFGWheeledVehicleTank) == 0x000E00, "Wrong size on ABFGWheeledVehicleTank");
static_assert(offsetof(ABFGWheeledVehicleTank, M_pAimAssistTargetComponent) == 0x000D98, "Member 'ABFGWheeledVehicleTank::M_pAimAssistTargetComponent' has a wrong offset!");
static_assert(offsetof(ABFGWheeledVehicleTank, _fTFrequence) == 0x000DA0, "Member 'ABFGWheeledVehicleTank::_fTFrequence' has a wrong offset!");
static_assert(offsetof(ABFGWheeledVehicleTank, M_apTracks) == 0x000DA8, "Member 'ABFGWheeledVehicleTank::M_apTracks' has a wrong offset!");
static_assert(offsetof(ABFGWheeledVehicleTank, M_tankInfo) == 0x000DB8, "Member 'ABFGWheeledVehicleTank::M_tankInfo' has a wrong offset!");

// Class BFGCore.BFGActorComponent_TankTrack
// 0x0128 (0x0250 - 0x0128)
class UBFGActorComponent_TankTrack final : public UActorComponent
{
public:
	class FName                                   M_splineCompName;                                  // 0x0128(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         M_fOverlapBetweenChains;                           // 0x0130(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         M_fTrackHeight;                                    // 0x0134(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         M_fMinVelocity;                                    // 0x0138(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         M_WheelSizeToRotate;                               // 0x013C(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TMap<class FName, int32>                      M_BoneNamesSplinePointsMap;                        // 0x0140(0x0050)(Edit, ZeroConstructor, DisableEditOnInstance, Protected, NativeAccessSpecifierProtected)
	TMap<class FName, class FName>                M_BoneToWheelMap;                                  // 0x0190(0x0050)(Edit, ZeroConstructor, DisableEditOnInstance, Protected, NativeAccessSpecifierProtected)
	TArray<class FName>                           M_BoneForWheelsRotationArray;                      // 0x01E0(0x0010)(Edit, ZeroConstructor, DisableEditOnInstance, Protected, NativeAccessSpecifierProtected)
	class UStaticMesh*                            M_pTrackChainStaticMesh;                           // 0x01F0(0x0008)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_1F8[0x30];                                     // 0x01F8(0x0030)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<class UActorComponent*>                M_pSplineActorComponentArray;                      // 0x0228(0x0010)(ExportObject, ZeroConstructor, ContainsInstancedReference, NativeAccessSpecifierPrivate)
	class UBFGPoseableMeshComponent*              M_pTankPoseableMeshComponent;                      // 0x0238(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UInstancedStaticMeshComponent*          M_pInstanceMeshComp;                               // 0x0240(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class USplineComponent*                       M_pSplineComponent;                                // 0x0248(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)

public:
	void DisableInstancedTrack();
	void HideInstances();
	void SetTFrequence(float _fNewTFrequence);
	void ShowInstances();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"BFGActorComponent_TankTrack">();
	}
	static class UBFGActorComponent_TankTrack* GetDefaultObj()
	{
		return GetDefaultObjImpl<UBFGActorComponent_TankTrack>();
	}
};
static_assert(alignof(UBFGActorComponent_TankTrack) == 0x000008, "Wrong alignment on UBFGActorComponent_TankTrack");
static_assert(sizeof(UBFGActorComponent_TankTrack) == 0x000250, "Wrong size on UBFGActorComponent_TankTrack");
static_assert(offsetof(UBFGActorComponent_TankTrack, M_splineCompName) == 0x000128, "Member 'UBFGActorComponent_TankTrack::M_splineCompName' has a wrong offset!");
static_assert(offsetof(UBFGActorComponent_TankTrack, M_fOverlapBetweenChains) == 0x000130, "Member 'UBFGActorComponent_TankTrack::M_fOverlapBetweenChains' has a wrong offset!");
static_assert(offsetof(UBFGActorComponent_TankTrack, M_fTrackHeight) == 0x000134, "Member 'UBFGActorComponent_TankTrack::M_fTrackHeight' has a wrong offset!");
static_assert(offsetof(UBFGActorComponent_TankTrack, M_fMinVelocity) == 0x000138, "Member 'UBFGActorComponent_TankTrack::M_fMinVelocity' has a wrong offset!");
static_assert(offsetof(UBFGActorComponent_TankTrack, M_WheelSizeToRotate) == 0x00013C, "Member 'UBFGActorComponent_TankTrack::M_WheelSizeToRotate' has a wrong offset!");
static_assert(offsetof(UBFGActorComponent_TankTrack, M_BoneNamesSplinePointsMap) == 0x000140, "Member 'UBFGActorComponent_TankTrack::M_BoneNamesSplinePointsMap' has a wrong offset!");
static_assert(offsetof(UBFGActorComponent_TankTrack, M_BoneToWheelMap) == 0x000190, "Member 'UBFGActorComponent_TankTrack::M_BoneToWheelMap' has a wrong offset!");
static_assert(offsetof(UBFGActorComponent_TankTrack, M_BoneForWheelsRotationArray) == 0x0001E0, "Member 'UBFGActorComponent_TankTrack::M_BoneForWheelsRotationArray' has a wrong offset!");
static_assert(offsetof(UBFGActorComponent_TankTrack, M_pTrackChainStaticMesh) == 0x0001F0, "Member 'UBFGActorComponent_TankTrack::M_pTrackChainStaticMesh' has a wrong offset!");
static_assert(offsetof(UBFGActorComponent_TankTrack, M_pSplineActorComponentArray) == 0x000228, "Member 'UBFGActorComponent_TankTrack::M_pSplineActorComponentArray' has a wrong offset!");
static_assert(offsetof(UBFGActorComponent_TankTrack, M_pTankPoseableMeshComponent) == 0x000238, "Member 'UBFGActorComponent_TankTrack::M_pTankPoseableMeshComponent' has a wrong offset!");
static_assert(offsetof(UBFGActorComponent_TankTrack, M_pInstanceMeshComp) == 0x000240, "Member 'UBFGActorComponent_TankTrack::M_pInstanceMeshComp' has a wrong offset!");
static_assert(offsetof(UBFGActorComponent_TankTrack, M_pSplineComponent) == 0x000248, "Member 'UBFGActorComponent_TankTrack::M_pSplineComponent' has a wrong offset!");

// Class BFGCore.BFGActorComponent_TankTrackLOD
// 0x0040 (0x0168 - 0x0128)
class UBFGActorComponent_TankTrackLOD final : public UActorComponent
{
public:
	bool                                          M_bIsLODBehaviorOverwritten;                       // 0x0128(0x0001)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_129[0x3];                                      // 0x0129(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         M_fLODChangeDistance;                              // 0x012C(0x0004)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UStaticMeshComponent*                   M_pTrackChainStaticMeshComp_R;                     // 0x0130(0x0008)(Edit, BlueprintVisible, ExportObject, ZeroConstructor, DisableEditOnInstance, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UStaticMeshComponent*                   M_pTrackChainStaticMeshComp_L;                     // 0x0138(0x0008)(Edit, BlueprintVisible, ExportObject, ZeroConstructor, DisableEditOnInstance, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         M_fRefreshFrequency;                               // 0x0140(0x0004)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_144[0x4];                                      // 0x0144(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class UBFGTrafficCrowdManager*                M_pTrafficManager;                                 // 0x0148(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	TArray<class UBFGActorComponent_TankTrack*>   M_pTankTrackActorCompArray;                        // 0x0150(0x0010)(ExportObject, ZeroConstructor, ContainsInstancedReference, NativeAccessSpecifierPrivate)
	class ABFGBasicVehicleTank*                   M_pTank;                                           // 0x0160(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"BFGActorComponent_TankTrackLOD">();
	}
	static class UBFGActorComponent_TankTrackLOD* GetDefaultObj()
	{
		return GetDefaultObjImpl<UBFGActorComponent_TankTrackLOD>();
	}
};
static_assert(alignof(UBFGActorComponent_TankTrackLOD) == 0x000008, "Wrong alignment on UBFGActorComponent_TankTrackLOD");
static_assert(sizeof(UBFGActorComponent_TankTrackLOD) == 0x000168, "Wrong size on UBFGActorComponent_TankTrackLOD");
static_assert(offsetof(UBFGActorComponent_TankTrackLOD, M_bIsLODBehaviorOverwritten) == 0x000128, "Member 'UBFGActorComponent_TankTrackLOD::M_bIsLODBehaviorOverwritten' has a wrong offset!");
static_assert(offsetof(UBFGActorComponent_TankTrackLOD, M_fLODChangeDistance) == 0x00012C, "Member 'UBFGActorComponent_TankTrackLOD::M_fLODChangeDistance' has a wrong offset!");
static_assert(offsetof(UBFGActorComponent_TankTrackLOD, M_pTrackChainStaticMeshComp_R) == 0x000130, "Member 'UBFGActorComponent_TankTrackLOD::M_pTrackChainStaticMeshComp_R' has a wrong offset!");
static_assert(offsetof(UBFGActorComponent_TankTrackLOD, M_pTrackChainStaticMeshComp_L) == 0x000138, "Member 'UBFGActorComponent_TankTrackLOD::M_pTrackChainStaticMeshComp_L' has a wrong offset!");
static_assert(offsetof(UBFGActorComponent_TankTrackLOD, M_fRefreshFrequency) == 0x000140, "Member 'UBFGActorComponent_TankTrackLOD::M_fRefreshFrequency' has a wrong offset!");
static_assert(offsetof(UBFGActorComponent_TankTrackLOD, M_pTrafficManager) == 0x000148, "Member 'UBFGActorComponent_TankTrackLOD::M_pTrafficManager' has a wrong offset!");
static_assert(offsetof(UBFGActorComponent_TankTrackLOD, M_pTankTrackActorCompArray) == 0x000150, "Member 'UBFGActorComponent_TankTrackLOD::M_pTankTrackActorCompArray' has a wrong offset!");
static_assert(offsetof(UBFGActorComponent_TankTrackLOD, M_pTank) == 0x000160, "Member 'UBFGActorComponent_TankTrackLOD::M_pTank' has a wrong offset!");

// Class BFGCore.BFGDetectionPostProcessor
// 0x0000 (0x0028 - 0x0028)
class UBFGDetectionPostProcessor : public UObject
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"BFGDetectionPostProcessor">();
	}
	static class UBFGDetectionPostProcessor* GetDefaultObj()
	{
		return GetDefaultObjImpl<UBFGDetectionPostProcessor>();
	}
};
static_assert(alignof(UBFGDetectionPostProcessor) == 0x000008, "Wrong alignment on UBFGDetectionPostProcessor");
static_assert(sizeof(UBFGDetectionPostProcessor) == 0x000028, "Wrong size on UBFGDetectionPostProcessor");

// Class BFGCore.BFGWidget_Archive_FuronHandbookChapter
// 0x0088 (0x0548 - 0x04C0)
class UBFGWidget_Archive_FuronHandbookChapter final : public UBFGWidget_GenericMenuTree
{
public:
	class UDataTable*                             M_pChapterTable;                                   // 0x04C0(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TSoftClassPtr<class UClass>                   M_pPageWidgetClass;                                // 0x04C8(0x0028)(Edit, DisableEditOnInstance, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UBFGWidget_TutorialPage*                M_pPage;                                           // 0x04F0(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TArray<class FName>                           M_astrRowNamesPages;                               // 0x04F8(0x0010)(ZeroConstructor, Protected, NativeAccessSpecifierProtected)
	float                                         M_fTutorialPageMaxScrollSpeed;                     // 0x0508(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_50C[0x4];                                      // 0x050C(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class FText                                   M_strLockedEntryText;                              // 0x0510(0x0018)(Edit, DisableEditOnInstance, Protected, NativeAccessSpecifierProtected)
	uint8                                         Pad_528[0x1C];                                     // 0x0528(0x001C)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         M_fMaxScrollSpeed;                                 // 0x0544(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)

public:
	void AddPageToLayout(class UBFGWidget_TutorialPage* _pPage);
	void Scroll(float _fValue);
	void ScrolltoWidget(class UBFGWidget_DialogOption* _pOption);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"BFGWidget_Archive_FuronHandbookChapter">();
	}
	static class UBFGWidget_Archive_FuronHandbookChapter* GetDefaultObj()
	{
		return GetDefaultObjImpl<UBFGWidget_Archive_FuronHandbookChapter>();
	}
};
static_assert(alignof(UBFGWidget_Archive_FuronHandbookChapter) == 0x000008, "Wrong alignment on UBFGWidget_Archive_FuronHandbookChapter");
static_assert(sizeof(UBFGWidget_Archive_FuronHandbookChapter) == 0x000548, "Wrong size on UBFGWidget_Archive_FuronHandbookChapter");
static_assert(offsetof(UBFGWidget_Archive_FuronHandbookChapter, M_pChapterTable) == 0x0004C0, "Member 'UBFGWidget_Archive_FuronHandbookChapter::M_pChapterTable' has a wrong offset!");
static_assert(offsetof(UBFGWidget_Archive_FuronHandbookChapter, M_pPageWidgetClass) == 0x0004C8, "Member 'UBFGWidget_Archive_FuronHandbookChapter::M_pPageWidgetClass' has a wrong offset!");
static_assert(offsetof(UBFGWidget_Archive_FuronHandbookChapter, M_pPage) == 0x0004F0, "Member 'UBFGWidget_Archive_FuronHandbookChapter::M_pPage' has a wrong offset!");
static_assert(offsetof(UBFGWidget_Archive_FuronHandbookChapter, M_astrRowNamesPages) == 0x0004F8, "Member 'UBFGWidget_Archive_FuronHandbookChapter::M_astrRowNamesPages' has a wrong offset!");
static_assert(offsetof(UBFGWidget_Archive_FuronHandbookChapter, M_fTutorialPageMaxScrollSpeed) == 0x000508, "Member 'UBFGWidget_Archive_FuronHandbookChapter::M_fTutorialPageMaxScrollSpeed' has a wrong offset!");
static_assert(offsetof(UBFGWidget_Archive_FuronHandbookChapter, M_strLockedEntryText) == 0x000510, "Member 'UBFGWidget_Archive_FuronHandbookChapter::M_strLockedEntryText' has a wrong offset!");
static_assert(offsetof(UBFGWidget_Archive_FuronHandbookChapter, M_fMaxScrollSpeed) == 0x000544, "Member 'UBFGWidget_Archive_FuronHandbookChapter::M_fMaxScrollSpeed' has a wrong offset!");

// Class BFGCore.BFGActorComponent_TargetSystem
// 0x0070 (0x0198 - 0x0128)
class UBFGActorComponent_TargetSystem final : public UActorComponent
{
public:
	uint8                                         Pad_128[0x8];                                      // 0x0128(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	ECollisionChannel                             M_eAimCollisionChannel;                            // 0x0130(0x0001)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_131[0x7];                                      // 0x0131(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<class FName>                           M_aTargetCheckBoneNameList;                        // 0x0138(0x0010)(Edit, ZeroConstructor, DisableEditOnInstance, NativeAccessSpecifierPublic)
	struct FGameplayTagContainer                  M_oPrerequisiteTags;                               // 0x0148(0x0020)(Edit, BlueprintVisible, BlueprintReadOnly, DisableEditOnInstance, Protected, NativeAccessSpecifierProtected)
	struct FGameplayTagContainer                  M_oForbiddenTags;                                  // 0x0168(0x0020)(Edit, BlueprintVisible, BlueprintReadOnly, DisableEditOnInstance, Protected, NativeAccessSpecifierProtected)
	float                                         M_fCrosshairOffsetY;                               // 0x0188(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_18C[0xC];                                      // 0x018C(0x000C)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	struct FVector GetActorTargetLocation(class AActor* _pActor, class FName BoneName) const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"BFGActorComponent_TargetSystem">();
	}
	static class UBFGActorComponent_TargetSystem* GetDefaultObj()
	{
		return GetDefaultObjImpl<UBFGActorComponent_TargetSystem>();
	}
};
static_assert(alignof(UBFGActorComponent_TargetSystem) == 0x000008, "Wrong alignment on UBFGActorComponent_TargetSystem");
static_assert(sizeof(UBFGActorComponent_TargetSystem) == 0x000198, "Wrong size on UBFGActorComponent_TargetSystem");
static_assert(offsetof(UBFGActorComponent_TargetSystem, M_eAimCollisionChannel) == 0x000130, "Member 'UBFGActorComponent_TargetSystem::M_eAimCollisionChannel' has a wrong offset!");
static_assert(offsetof(UBFGActorComponent_TargetSystem, M_aTargetCheckBoneNameList) == 0x000138, "Member 'UBFGActorComponent_TargetSystem::M_aTargetCheckBoneNameList' has a wrong offset!");
static_assert(offsetof(UBFGActorComponent_TargetSystem, M_oPrerequisiteTags) == 0x000148, "Member 'UBFGActorComponent_TargetSystem::M_oPrerequisiteTags' has a wrong offset!");
static_assert(offsetof(UBFGActorComponent_TargetSystem, M_oForbiddenTags) == 0x000168, "Member 'UBFGActorComponent_TargetSystem::M_oForbiddenTags' has a wrong offset!");
static_assert(offsetof(UBFGActorComponent_TargetSystem, M_fCrosshairOffsetY) == 0x000188, "Member 'UBFGActorComponent_TargetSystem::M_fCrosshairOffsetY' has a wrong offset!");

// Class BFGCore.BFGActorComponent_Timer
// 0x0028 (0x0150 - 0x0128)
class UBFGActorComponent_Timer final : public UActorComponent
{
public:
	struct FTimespan                              M_Timespan;                                        // 0x0128(0x0008)(Edit, BlueprintVisible, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          M_bNotify;                                         // 0x0130(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          M_bIsPublicDemo;                                   // 0x0131(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_132[0x6];                                      // 0x0132(0x0006)(Fixing Size After Last Property [ Dumper-7 ])
	class ABFGGameState*                          M_pGameState;                                      // 0x0138(0x0008)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UBFGGameInstance*                       M_pGameInstance;                                   // 0x0140(0x0008)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         M_fTimeLeft;                                       // 0x0148(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         M_fTimeElapsed;                                    // 0x014C(0x0004)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

public:
	float GetTimeLeft() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"BFGActorComponent_Timer">();
	}
	static class UBFGActorComponent_Timer* GetDefaultObj()
	{
		return GetDefaultObjImpl<UBFGActorComponent_Timer>();
	}
};
static_assert(alignof(UBFGActorComponent_Timer) == 0x000008, "Wrong alignment on UBFGActorComponent_Timer");
static_assert(sizeof(UBFGActorComponent_Timer) == 0x000150, "Wrong size on UBFGActorComponent_Timer");
static_assert(offsetof(UBFGActorComponent_Timer, M_Timespan) == 0x000128, "Member 'UBFGActorComponent_Timer::M_Timespan' has a wrong offset!");
static_assert(offsetof(UBFGActorComponent_Timer, M_bNotify) == 0x000130, "Member 'UBFGActorComponent_Timer::M_bNotify' has a wrong offset!");
static_assert(offsetof(UBFGActorComponent_Timer, M_bIsPublicDemo) == 0x000131, "Member 'UBFGActorComponent_Timer::M_bIsPublicDemo' has a wrong offset!");
static_assert(offsetof(UBFGActorComponent_Timer, M_pGameState) == 0x000138, "Member 'UBFGActorComponent_Timer::M_pGameState' has a wrong offset!");
static_assert(offsetof(UBFGActorComponent_Timer, M_pGameInstance) == 0x000140, "Member 'UBFGActorComponent_Timer::M_pGameInstance' has a wrong offset!");
static_assert(offsetof(UBFGActorComponent_Timer, M_fTimeLeft) == 0x000148, "Member 'UBFGActorComponent_Timer::M_fTimeLeft' has a wrong offset!");
static_assert(offsetof(UBFGActorComponent_Timer, M_fTimeElapsed) == 0x00014C, "Member 'UBFGActorComponent_Timer::M_fTimeElapsed' has a wrong offset!");

// Class BFGCore.BFGNavArea_CrowdLifeStation
// 0x0000 (0x0048 - 0x0048)
class UBFGNavArea_CrowdLifeStation final : public UNavArea
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"BFGNavArea_CrowdLifeStation">();
	}
	static class UBFGNavArea_CrowdLifeStation* GetDefaultObj()
	{
		return GetDefaultObjImpl<UBFGNavArea_CrowdLifeStation>();
	}
};
static_assert(alignof(UBFGNavArea_CrowdLifeStation) == 0x000008, "Wrong alignment on UBFGNavArea_CrowdLifeStation");
static_assert(sizeof(UBFGNavArea_CrowdLifeStation) == 0x000048, "Wrong size on UBFGNavArea_CrowdLifeStation");

// Class BFGCore.BFGVariableAction_RequestPlayback_Abort
// 0x0000 (0x00F0 - 0x00F0)
class UBFGVariableAction_RequestPlayback_Abort final : public UBFGVariableAction
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"BFGVariableAction_RequestPlayback_Abort">();
	}
	static class UBFGVariableAction_RequestPlayback_Abort* GetDefaultObj()
	{
		return GetDefaultObjImpl<UBFGVariableAction_RequestPlayback_Abort>();
	}
};
static_assert(alignof(UBFGVariableAction_RequestPlayback_Abort) == 0x000008, "Wrong alignment on UBFGVariableAction_RequestPlayback_Abort");
static_assert(sizeof(UBFGVariableAction_RequestPlayback_Abort) == 0x0000F0, "Wrong size on UBFGVariableAction_RequestPlayback_Abort");

// Class BFGCore.BFGBuilding_DataSet
// 0x0030 (0x0060 - 0x0030)
class UBFGBuilding_DataSet final : public UDataAsset
{
public:
	TArray<struct FBFGBuilding_FloorData>         M_aGroundFloors;                                   // 0x0030(0x0010)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, NativeAccessSpecifierPublic)
	TArray<struct FBFGBuilding_FloorData>         M_aRoofs;                                          // 0x0040(0x0010)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, NativeAccessSpecifierPublic)
	TArray<struct FBFGBuilding_FloorData>         M_aMiddleFloors;                                   // 0x0050(0x0010)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"BFGBuilding_DataSet">();
	}
	static class UBFGBuilding_DataSet* GetDefaultObj()
	{
		return GetDefaultObjImpl<UBFGBuilding_DataSet>();
	}
};
static_assert(alignof(UBFGBuilding_DataSet) == 0x000008, "Wrong alignment on UBFGBuilding_DataSet");
static_assert(sizeof(UBFGBuilding_DataSet) == 0x000060, "Wrong size on UBFGBuilding_DataSet");
static_assert(offsetof(UBFGBuilding_DataSet, M_aGroundFloors) == 0x000030, "Member 'UBFGBuilding_DataSet::M_aGroundFloors' has a wrong offset!");
static_assert(offsetof(UBFGBuilding_DataSet, M_aRoofs) == 0x000040, "Member 'UBFGBuilding_DataSet::M_aRoofs' has a wrong offset!");
static_assert(offsetof(UBFGBuilding_DataSet, M_aMiddleFloors) == 0x000050, "Member 'UBFGBuilding_DataSet::M_aMiddleFloors' has a wrong offset!");

// Class BFGCore.BFGActorComponent_WidgetComponent
// 0x0030 (0x07D8 - 0x07A8)
#pragma pack(push, 0x1)
class alignas(0x08) UBFGActorComponent_WidgetComponent : public UWidgetComponent
{
public:
	float                                         M_fWidgetMax;                                      // 0x07A8(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         M_fWidgetMin;                                      // 0x07AC(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         M_fTargetDistanceScale;                            // 0x07B0(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         M_fMaxDistanceFromPlayerEnabled;                   // 0x07B4(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	EBFGWidgetComponentEnableMode                 M_eEnableMode;                                     // 0x07B8(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_7B9[0x7];                                      // 0x07B9(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	class UBFGGameInstance*                       M_pGameInstance;                                   // 0x07C0(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class ABFGGameState*                          M_pGameState;                                      // 0x07C8(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_7D0[0x8];                                      // 0x07D0(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void DisableWidget();
	void EnableWidget();
	void EnsureWidgetInitialized();
	class AActor* GetCurrentActor();
	class UUserWidget* GetWidgetfromPool();
	void ReleaseWidget();
	void SetEnableMode(EBFGWidgetComponentEnableMode _eMode);
	void SetMaxDistanceFromPlayer(float _fMaxDistance);

	class AActor* GetAttachedActor() const;
	bool IsWidgetInitialized() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"BFGActorComponent_WidgetComponent">();
	}
	static class UBFGActorComponent_WidgetComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UBFGActorComponent_WidgetComponent>();
	}
};
#pragma pack(pop)
static_assert(alignof(UBFGActorComponent_WidgetComponent) == 0x000008, "Wrong alignment on UBFGActorComponent_WidgetComponent");
static_assert(sizeof(UBFGActorComponent_WidgetComponent) == 0x0007D8, "Wrong size on UBFGActorComponent_WidgetComponent");
static_assert(offsetof(UBFGActorComponent_WidgetComponent, M_fWidgetMax) == 0x0007A8, "Member 'UBFGActorComponent_WidgetComponent::M_fWidgetMax' has a wrong offset!");
static_assert(offsetof(UBFGActorComponent_WidgetComponent, M_fWidgetMin) == 0x0007AC, "Member 'UBFGActorComponent_WidgetComponent::M_fWidgetMin' has a wrong offset!");
static_assert(offsetof(UBFGActorComponent_WidgetComponent, M_fTargetDistanceScale) == 0x0007B0, "Member 'UBFGActorComponent_WidgetComponent::M_fTargetDistanceScale' has a wrong offset!");
static_assert(offsetof(UBFGActorComponent_WidgetComponent, M_fMaxDistanceFromPlayerEnabled) == 0x0007B4, "Member 'UBFGActorComponent_WidgetComponent::M_fMaxDistanceFromPlayerEnabled' has a wrong offset!");
static_assert(offsetof(UBFGActorComponent_WidgetComponent, M_eEnableMode) == 0x0007B8, "Member 'UBFGActorComponent_WidgetComponent::M_eEnableMode' has a wrong offset!");
static_assert(offsetof(UBFGActorComponent_WidgetComponent, M_pGameInstance) == 0x0007C0, "Member 'UBFGActorComponent_WidgetComponent::M_pGameInstance' has a wrong offset!");
static_assert(offsetof(UBFGActorComponent_WidgetComponent, M_pGameState) == 0x0007C8, "Member 'UBFGActorComponent_WidgetComponent::M_pGameState' has a wrong offset!");

// Class BFGCore.BFGActorComponent_WidgetComponent_Health
// 0x0018 (0x07F0 - 0x07D8)
class UBFGActorComponent_WidgetComponent_Health : public UBFGActorComponent_WidgetComponent
{
public:
	uint8                                         Pad_7D8[0x8];                                      // 0x07D8(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<class AActor*>                         M_apMarkingActors;                                 // 0x07E0(0x0010)(ZeroConstructor, Protected, NativeAccessSpecifierProtected)

public:
	void OnDeadStatChanged(class AActor* _pActor, class UBFGActorStat_Bool* _pBoolStat);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"BFGActorComponent_WidgetComponent_Health">();
	}
	static class UBFGActorComponent_WidgetComponent_Health* GetDefaultObj()
	{
		return GetDefaultObjImpl<UBFGActorComponent_WidgetComponent_Health>();
	}
};
static_assert(alignof(UBFGActorComponent_WidgetComponent_Health) == 0x000008, "Wrong alignment on UBFGActorComponent_WidgetComponent_Health");
static_assert(sizeof(UBFGActorComponent_WidgetComponent_Health) == 0x0007F0, "Wrong size on UBFGActorComponent_WidgetComponent_Health");
static_assert(offsetof(UBFGActorComponent_WidgetComponent_Health, M_apMarkingActors) == 0x0007E0, "Member 'UBFGActorComponent_WidgetComponent_Health::M_apMarkingActors' has a wrong offset!");

// Class BFGCore.BFGVariableAction_MissionGroup_Finish
// 0x0000 (0x00F0 - 0x00F0)
class UBFGVariableAction_MissionGroup_Finish final : public UBFGVariableAction
{
public:
	static const class FName GetActionName_MissionGroupFinish();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"BFGVariableAction_MissionGroup_Finish">();
	}
	static class UBFGVariableAction_MissionGroup_Finish* GetDefaultObj()
	{
		return GetDefaultObjImpl<UBFGVariableAction_MissionGroup_Finish>();
	}
};
static_assert(alignof(UBFGVariableAction_MissionGroup_Finish) == 0x000008, "Wrong alignment on UBFGVariableAction_MissionGroup_Finish");
static_assert(sizeof(UBFGVariableAction_MissionGroup_Finish) == 0x0000F0, "Wrong size on UBFGVariableAction_MissionGroup_Finish");

// Class BFGCore.BFGBTService_TransportCombat
// 0x0008 (0x0220 - 0x0218)
class UBFGBTService_TransportCombat final : public UBFGBTService_BaseCombat
{
public:
	EBFGCombatState_NPC                           M_defaultCombatState;                              // 0x0218(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_219[0x7];                                      // 0x0219(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"BFGBTService_TransportCombat">();
	}
	static class UBFGBTService_TransportCombat* GetDefaultObj()
	{
		return GetDefaultObjImpl<UBFGBTService_TransportCombat>();
	}
};
static_assert(alignof(UBFGBTService_TransportCombat) == 0x000008, "Wrong alignment on UBFGBTService_TransportCombat");
static_assert(sizeof(UBFGBTService_TransportCombat) == 0x000220, "Wrong size on UBFGBTService_TransportCombat");
static_assert(offsetof(UBFGBTService_TransportCombat, M_defaultCombatState) == 0x000218, "Member 'UBFGBTService_TransportCombat::M_defaultCombatState' has a wrong offset!");

// Class BFGCore.BFGActorComponent_WidgetComponent_Holobob
// 0x0028 (0x07D0 - 0x07A8)
class UBFGActorComponent_WidgetComponent_Holobob final : public UWidgetComponent
{
public:
	bool                                          M_bAlignWithCameraOnAllAxis;                       // 0x07A8(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_7A9[0x7];                                      // 0x07A9(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	class UCameraComponent*                       M_pCurrentCamera;                                  // 0x07B0(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UBFGMentalAbility_Holobob*              M_pHolobobAbility;                                 // 0x07B8(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          M_bNotificationVisible;                            // 0x07C0(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_7C1[0xF];                                      // 0x07C1(0x000F)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void SetVisibilityState(bool _bVisible, bool _bForceUpdate);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"BFGActorComponent_WidgetComponent_Holobob">();
	}
	static class UBFGActorComponent_WidgetComponent_Holobob* GetDefaultObj()
	{
		return GetDefaultObjImpl<UBFGActorComponent_WidgetComponent_Holobob>();
	}
};
static_assert(alignof(UBFGActorComponent_WidgetComponent_Holobob) == 0x000008, "Wrong alignment on UBFGActorComponent_WidgetComponent_Holobob");
static_assert(sizeof(UBFGActorComponent_WidgetComponent_Holobob) == 0x0007D0, "Wrong size on UBFGActorComponent_WidgetComponent_Holobob");
static_assert(offsetof(UBFGActorComponent_WidgetComponent_Holobob, M_bAlignWithCameraOnAllAxis) == 0x0007A8, "Member 'UBFGActorComponent_WidgetComponent_Holobob::M_bAlignWithCameraOnAllAxis' has a wrong offset!");
static_assert(offsetof(UBFGActorComponent_WidgetComponent_Holobob, M_pCurrentCamera) == 0x0007B0, "Member 'UBFGActorComponent_WidgetComponent_Holobob::M_pCurrentCamera' has a wrong offset!");
static_assert(offsetof(UBFGActorComponent_WidgetComponent_Holobob, M_pHolobobAbility) == 0x0007B8, "Member 'UBFGActorComponent_WidgetComponent_Holobob::M_pHolobobAbility' has a wrong offset!");
static_assert(offsetof(UBFGActorComponent_WidgetComponent_Holobob, M_bNotificationVisible) == 0x0007C0, "Member 'UBFGActorComponent_WidgetComponent_Holobob::M_bNotificationVisible' has a wrong offset!");

// Class BFGCore.BFGBTService_NPCDetection
// 0x0208 (0x0280 - 0x0078)
class UBFGBTService_NPCDetection final : public UBFGBTBaseService
{
public:
	struct FBlackboardKeySelector                 M_BBKeyState;                                      // 0x0078(0x0028)(Edit, BlueprintVisible, NativeAccessSpecifierPublic)
	struct FBlackboardKeySelector                 M_BBKeyStateAge;                                   // 0x00A0(0x0028)(Edit, BlueprintVisible, NativeAccessSpecifierPublic)
	struct FBlackboardKeySelector                 M_BBKeySuspiciousLocation;                         // 0x00C8(0x0028)(Edit, BlueprintVisible, NativeAccessSpecifierPublic)
	struct FBlackboardKeySelector                 M_BBKeySuspiciousTarget;                           // 0x00F0(0x0028)(Edit, BlueprintVisible, NativeAccessSpecifierPublic)
	struct FBlackboardKeySelector                 M_BBKeyCuriosityReason;                            // 0x0118(0x0028)(Edit, BlueprintVisible, NativeAccessSpecifierPublic)
	struct FBlackboardKeySelector                 M_BBKey_CrowdFlowAgent;                            // 0x0140(0x0028)(Edit, BlueprintVisible, NativeAccessSpecifierPublic)
	struct FBlackboardKeySelector                 M_bbKeyPlayAlertAnimation;                         // 0x0168(0x0028)(Edit, NativeAccessSpecifierPublic)
	TArray<class UBFGSensor*>                     M_apSensors;                                       // 0x0190(0x0010)(Edit, ExportObject, ZeroConstructor, ContainsInstancedReference, NativeAccessSpecifierPublic)
	TArray<class UBFGDetectionPostProcessor*>     M_apPostprocessors;                                // 0x01A0(0x0010)(Edit, ExportObject, ZeroConstructor, ContainsInstancedReference, NativeAccessSpecifierPublic)
	TMap<EBFGBehaviourState_NPC, struct FGameplayTagContainer> M_apStateGameplayEffectTags;                       // 0x01B0(0x0050)(Edit, ZeroConstructor, NativeAccessSpecifierPublic)
	bool                                          M_bEnabled;                                        // 0x0200(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_201[0x3F];                                     // 0x0201(0x003F)(Fixing Size After Last Property [ Dumper-7 ])
	class UBFGNetworkPathAgent*                   M_pAgent;                                          // 0x0240(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_248[0x30];                                     // 0x0248(0x0030)(Fixing Size After Last Property [ Dumper-7 ])
	class UBFGAISystem*                           M_pAISystem;                                       // 0x0278(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"BFGBTService_NPCDetection">();
	}
	static class UBFGBTService_NPCDetection* GetDefaultObj()
	{
		return GetDefaultObjImpl<UBFGBTService_NPCDetection>();
	}
};
static_assert(alignof(UBFGBTService_NPCDetection) == 0x000008, "Wrong alignment on UBFGBTService_NPCDetection");
static_assert(sizeof(UBFGBTService_NPCDetection) == 0x000280, "Wrong size on UBFGBTService_NPCDetection");
static_assert(offsetof(UBFGBTService_NPCDetection, M_BBKeyState) == 0x000078, "Member 'UBFGBTService_NPCDetection::M_BBKeyState' has a wrong offset!");
static_assert(offsetof(UBFGBTService_NPCDetection, M_BBKeyStateAge) == 0x0000A0, "Member 'UBFGBTService_NPCDetection::M_BBKeyStateAge' has a wrong offset!");
static_assert(offsetof(UBFGBTService_NPCDetection, M_BBKeySuspiciousLocation) == 0x0000C8, "Member 'UBFGBTService_NPCDetection::M_BBKeySuspiciousLocation' has a wrong offset!");
static_assert(offsetof(UBFGBTService_NPCDetection, M_BBKeySuspiciousTarget) == 0x0000F0, "Member 'UBFGBTService_NPCDetection::M_BBKeySuspiciousTarget' has a wrong offset!");
static_assert(offsetof(UBFGBTService_NPCDetection, M_BBKeyCuriosityReason) == 0x000118, "Member 'UBFGBTService_NPCDetection::M_BBKeyCuriosityReason' has a wrong offset!");
static_assert(offsetof(UBFGBTService_NPCDetection, M_BBKey_CrowdFlowAgent) == 0x000140, "Member 'UBFGBTService_NPCDetection::M_BBKey_CrowdFlowAgent' has a wrong offset!");
static_assert(offsetof(UBFGBTService_NPCDetection, M_bbKeyPlayAlertAnimation) == 0x000168, "Member 'UBFGBTService_NPCDetection::M_bbKeyPlayAlertAnimation' has a wrong offset!");
static_assert(offsetof(UBFGBTService_NPCDetection, M_apSensors) == 0x000190, "Member 'UBFGBTService_NPCDetection::M_apSensors' has a wrong offset!");
static_assert(offsetof(UBFGBTService_NPCDetection, M_apPostprocessors) == 0x0001A0, "Member 'UBFGBTService_NPCDetection::M_apPostprocessors' has a wrong offset!");
static_assert(offsetof(UBFGBTService_NPCDetection, M_apStateGameplayEffectTags) == 0x0001B0, "Member 'UBFGBTService_NPCDetection::M_apStateGameplayEffectTags' has a wrong offset!");
static_assert(offsetof(UBFGBTService_NPCDetection, M_bEnabled) == 0x000200, "Member 'UBFGBTService_NPCDetection::M_bEnabled' has a wrong offset!");
static_assert(offsetof(UBFGBTService_NPCDetection, M_pAgent) == 0x000240, "Member 'UBFGBTService_NPCDetection::M_pAgent' has a wrong offset!");
static_assert(offsetof(UBFGBTService_NPCDetection, M_pAISystem) == 0x000278, "Member 'UBFGBTService_NPCDetection::M_pAISystem' has a wrong offset!");

// Class BFGCore.BFGActorComponentInteractable
// 0x0070 (0x0700 - 0x0690)
class UBFGActorComponentInteractable final : public UCapsuleComponent
{
public:
	uint8                                         Pad_690[0x60];                                     // 0x0690(0x0060)(Fixing Size After Last Property [ Dumper-7 ])
	bool                                          M_bIsFocusable;                                    // 0x06F0(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          M_bEnabled;                                        // 0x06F1(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          M_bIsFocused;                                      // 0x06F2(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_6F3[0xD];                                      // 0x06F3(0x000D)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void SetFocusable(bool _bValue);
	void SetInteractEnabled(bool _bValue);

	bool IsFocused() const;
	bool IsInteractableFocusable() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"BFGActorComponentInteractable">();
	}
	static class UBFGActorComponentInteractable* GetDefaultObj()
	{
		return GetDefaultObjImpl<UBFGActorComponentInteractable>();
	}
};
static_assert(alignof(UBFGActorComponentInteractable) == 0x000008, "Wrong alignment on UBFGActorComponentInteractable");
static_assert(sizeof(UBFGActorComponentInteractable) == 0x000700, "Wrong size on UBFGActorComponentInteractable");
static_assert(offsetof(UBFGActorComponentInteractable, M_bIsFocusable) == 0x0006F0, "Member 'UBFGActorComponentInteractable::M_bIsFocusable' has a wrong offset!");
static_assert(offsetof(UBFGActorComponentInteractable, M_bEnabled) == 0x0006F1, "Member 'UBFGActorComponentInteractable::M_bEnabled' has a wrong offset!");
static_assert(offsetof(UBFGActorComponentInteractable, M_bIsFocused) == 0x0006F2, "Member 'UBFGActorComponentInteractable::M_bIsFocused' has a wrong offset!");

// Class BFGCore.BFGActorFallingLeaves
// 0x0068 (0x0440 - 0x03D8)
class ABFGActorFallingLeaves : public AActor
{
public:
	uint8                                         Pad_3D8[0x18];                                     // 0x03D8(0x0018)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         M_fActivationRadius;                               // 0x03F0(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_3F4[0x4];                                      // 0x03F4(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class UParticleSystem*                        M_pParticleFallingLeaves;                          // 0x03F8(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	int32                                         M_iMaxNumOfParticlesSpawned;                       // 0x0400(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         M_fSpawnRate;                                      // 0x0404(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         M_fCheckEnvironment;                               // 0x0408(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         M_fRefreshTimer;                                   // 0x040C(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          M_bIsDebugEnabled;                                 // 0x0410(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_411[0x7];                                      // 0x0411(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	class UParticleSystemComponent*               M_pFallingLeavesParticleComp;                      // 0x0418(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_420[0x20];                                     // 0x0420(0x0020)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void CheckEnvironment();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"BFGActorFallingLeaves">();
	}
	static class ABFGActorFallingLeaves* GetDefaultObj()
	{
		return GetDefaultObjImpl<ABFGActorFallingLeaves>();
	}
};
static_assert(alignof(ABFGActorFallingLeaves) == 0x000008, "Wrong alignment on ABFGActorFallingLeaves");
static_assert(sizeof(ABFGActorFallingLeaves) == 0x000440, "Wrong size on ABFGActorFallingLeaves");
static_assert(offsetof(ABFGActorFallingLeaves, M_fActivationRadius) == 0x0003F0, "Member 'ABFGActorFallingLeaves::M_fActivationRadius' has a wrong offset!");
static_assert(offsetof(ABFGActorFallingLeaves, M_pParticleFallingLeaves) == 0x0003F8, "Member 'ABFGActorFallingLeaves::M_pParticleFallingLeaves' has a wrong offset!");
static_assert(offsetof(ABFGActorFallingLeaves, M_iMaxNumOfParticlesSpawned) == 0x000400, "Member 'ABFGActorFallingLeaves::M_iMaxNumOfParticlesSpawned' has a wrong offset!");
static_assert(offsetof(ABFGActorFallingLeaves, M_fSpawnRate) == 0x000404, "Member 'ABFGActorFallingLeaves::M_fSpawnRate' has a wrong offset!");
static_assert(offsetof(ABFGActorFallingLeaves, M_fCheckEnvironment) == 0x000408, "Member 'ABFGActorFallingLeaves::M_fCheckEnvironment' has a wrong offset!");
static_assert(offsetof(ABFGActorFallingLeaves, M_fRefreshTimer) == 0x00040C, "Member 'ABFGActorFallingLeaves::M_fRefreshTimer' has a wrong offset!");
static_assert(offsetof(ABFGActorFallingLeaves, M_bIsDebugEnabled) == 0x000410, "Member 'ABFGActorFallingLeaves::M_bIsDebugEnabled' has a wrong offset!");
static_assert(offsetof(ABFGActorFallingLeaves, M_pFallingLeavesParticleComp) == 0x000418, "Member 'ABFGActorFallingLeaves::M_pFallingLeavesParticleComp' has a wrong offset!");

// Class BFGCore.BFGBTTaskNode_ActivatePSIStation
// 0x0000 (0x0078 - 0x0078)
class UBFGBTTaskNode_ActivatePSIStation final : public UBFGBTBaseTaskNode
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"BFGBTTaskNode_ActivatePSIStation">();
	}
	static class UBFGBTTaskNode_ActivatePSIStation* GetDefaultObj()
	{
		return GetDefaultObjImpl<UBFGBTTaskNode_ActivatePSIStation>();
	}
};
static_assert(alignof(UBFGBTTaskNode_ActivatePSIStation) == 0x000008, "Wrong alignment on UBFGBTTaskNode_ActivatePSIStation");
static_assert(sizeof(UBFGBTTaskNode_ActivatePSIStation) == 0x000078, "Wrong size on UBFGBTTaskNode_ActivatePSIStation");

// Class BFGCore.BFGWidget_MessageBox
// 0x0000 (0x0428 - 0x0428)
class UBFGWidget_MessageBox final : public UBFGWidget_GenericDialog
{
public:
	void SetupMessageBox(const struct FBFGMessageBoxParams& _params);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"BFGWidget_MessageBox">();
	}
	static class UBFGWidget_MessageBox* GetDefaultObj()
	{
		return GetDefaultObjImpl<UBFGWidget_MessageBox>();
	}
};
static_assert(alignof(UBFGWidget_MessageBox) == 0x000008, "Wrong alignment on UBFGWidget_MessageBox");
static_assert(sizeof(UBFGWidget_MessageBox) == 0x000428, "Wrong size on UBFGWidget_MessageBox");

// Class BFGCore.BFGActorInterface_EnvironmentMonitor
// 0x0000 (0x0028 - 0x0028)
class IBFGActorInterface_EnvironmentMonitor final : public IInterface
{
public:
	void OnEnvironmentChanged(class UBFGEnvironment* _pEnvironment);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"BFGActorInterface_EnvironmentMonitor">();
	}
	static class IBFGActorInterface_EnvironmentMonitor* GetDefaultObj()
	{
		return GetDefaultObjImpl<IBFGActorInterface_EnvironmentMonitor>();
	}
};
static_assert(alignof(IBFGActorInterface_EnvironmentMonitor) == 0x000008, "Wrong alignment on IBFGActorInterface_EnvironmentMonitor");
static_assert(sizeof(IBFGActorInterface_EnvironmentMonitor) == 0x000028, "Wrong size on IBFGActorInterface_EnvironmentMonitor");

// Class BFGCore.BFGActorOcean
// 0x02A0 (0x0678 - 0x03D8)
class ABFGActorOcean final : public AActor
{
public:
	int32                                         M_iSize;                                           // 0x03D8(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class FName                                   M_sTextureName;                                    // 0x03DC(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class FName                                   M_sPackageName;                                    // 0x03E4(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_3EC[0x4];                                      // 0x03EC(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	TSoftObjectPtr<class UTexture2D>              M_pHeightTextureSoftPtr;                           // 0x03F0(0x0028)(Edit, BlueprintVisible, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UTexture2D*                             M_pHeightTexture;                                  // 0x0418(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         M_iTextureDivider;                                 // 0x0420(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_421[0x7];                                      // 0x0421(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	class UMaterialParameterCollection*           M_pMaterialParamCollection;                        // 0x0428(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class FName                                   M_sHeightMultiplier;                               // 0x0430(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class FName                                   M_sHeightShifter;                                  // 0x0438(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class FName                                   M_sPolarUVLoop;                                    // 0x0440(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class FName                                   M_sPolarUVScale;                                   // 0x0448(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class FName                                   M_sTextureRUVPanner;                               // 0x0450(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class FName                                   M_sTextureGUVPanner;                               // 0x0458(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class FName                                   M_sTextureBUVPanner;                               // 0x0460(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class FName                                   M_sTextureAUVPanner;                               // 0x0468(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class FName                                   M_sPolarCenterShiftUV;                             // 0x0470(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class AActor*                                 M_pActorToUVTrace;                                 // 0x0478(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TSoftObjectPtr<class UTexture2D>              M_pMaskTextureSoftPtr;                             // 0x0480(0x0028)(Edit, BlueprintVisible, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UTexture2D*                             M_pMaskTexture;                                    // 0x04A8(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          M_bIsChannelUsedR;                                 // 0x04B0(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          M_bIsChannelUsedG;                                 // 0x04B1(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          M_bIsChannelUsedB;                                 // 0x04B2(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          M_bIsChannelUsedA;                                 // 0x04B3(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          M_bUsingPolarCoords;                               // 0x04B4(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_4B5[0x3];                                      // 0x04B5(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         M_fValueShift;                                     // 0x04B8(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_4BC[0x4];                                      // 0x04BC(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	TSoftObjectPtr<class UTexture2D>              M_pSDistanceFieldTextureSoftPtr;                   // 0x04C0(0x0028)(Edit, BlueprintVisible, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UTexture2D*                             M_pSDistanceFieldTexture;                          // 0x04E8(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         M_fDetailWavesTopStr;                              // 0x04F0(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         M_fDetailWavesBottomStr;                           // 0x04F4(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         M_fDetailWaveStr;                                  // 0x04F8(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         M_fWaveMask_HeightDivider;                         // 0x04FC(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         M_fWaveMask_Contrast;                              // 0x0500(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         M_fWaveMaskDivider;                                // 0x0504(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         M_fWaveMinValue;                                   // 0x0508(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         M_fWaveMaxValue;                                   // 0x050C(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          M_bIsDebugEnabled;                                 // 0x0510(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_511[0x3];                                      // 0x0511(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	int32                                         M_iNumberOfTestPoints;                             // 0x0514(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          M_bIsSoundTestEnabled;                             // 0x0518(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_519[0x3];                                      // 0x0519(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         M_fSoundTestRAdius;                                // 0x051C(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          M_bIsPlayerInWaterTestEnabled;                     // 0x0520(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_521[0x7];                                      // 0x0521(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	class UMaterialParameterCollectionInstance*   M_pMaterialParamCollectionInstance;                // 0x0528(0x0008)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	TArray<uint8>                                 M_aPixelArrayCopy;                                 // 0x0530(0x0010)(ZeroConstructor, NativeAccessSpecifierPrivate)
	TArray<uint8>                                 M_aPixelMaskArrayCopy;                             // 0x0540(0x0010)(ZeroConstructor, NativeAccessSpecifierPrivate)
	TArray<uint8>                                 M_aDistanceFieldArrayCopy;                         // 0x0550(0x0010)(ZeroConstructor, NativeAccessSpecifierPrivate)
	uint32                                        M_iHeightTextureSizeX;                             // 0x0560(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint32                                        M_iHeightTextureSizeY;                             // 0x0564(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint32                                        M_iMaskTextureSizeX;                               // 0x0568(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint32                                        M_iMaskTextureSizeY;                               // 0x056C(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint32                                        M_iSDistanceTextureSizeX;                          // 0x0570(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint32                                        M_iSDistanceTextureSizeY;                          // 0x0574(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint32                                        M_iOriginalHeightTextureSizeX;                     // 0x0578(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint32                                        M_iOriginalHeightTextureSizeY;                     // 0x057C(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint32                                        M_iOriginalMaskTextureSizeX;                       // 0x0580(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint32                                        M_iOriginalMaskTextureSizeY;                       // 0x0584(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint32                                        M_iOriginalSDistanceTextureSizeX;                  // 0x0588(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint32                                        M_iOriginalSDistanceTextureSizeY;                  // 0x058C(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_590[0xD8];                                     // 0x0590(0x00D8)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<struct FVector>                        M_aRandomPoints;                                   // 0x0668(0x0010)(ZeroConstructor, NativeAccessSpecifierPrivate)

public:
	struct FVector CheckOceanInRadius(const struct FVector& _vCentre, float _CheckRadius);
	void CreateOceanTexture(const struct FWaveParameter& _stChannelRed, const struct FWaveParameter& _stChannelGreen, const struct FWaveParameter& _stChannelBlue, const struct FWaveParameter& _stChannelAlpha);
	struct FVector GenerateRandomPointOnMesh();
	float GetOceanHeight(const struct FVector& _vWorldPos);
	bool IsLocationInOcean(const struct FVector& _vLocation);
	bool IsLocationInOceanWithHeight(const struct FVector& _vLocation, float _fOceanHeight);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"BFGActorOcean">();
	}
	static class ABFGActorOcean* GetDefaultObj()
	{
		return GetDefaultObjImpl<ABFGActorOcean>();
	}
};
static_assert(alignof(ABFGActorOcean) == 0x000008, "Wrong alignment on ABFGActorOcean");
static_assert(sizeof(ABFGActorOcean) == 0x000678, "Wrong size on ABFGActorOcean");
static_assert(offsetof(ABFGActorOcean, M_iSize) == 0x0003D8, "Member 'ABFGActorOcean::M_iSize' has a wrong offset!");
static_assert(offsetof(ABFGActorOcean, M_sTextureName) == 0x0003DC, "Member 'ABFGActorOcean::M_sTextureName' has a wrong offset!");
static_assert(offsetof(ABFGActorOcean, M_sPackageName) == 0x0003E4, "Member 'ABFGActorOcean::M_sPackageName' has a wrong offset!");
static_assert(offsetof(ABFGActorOcean, M_pHeightTextureSoftPtr) == 0x0003F0, "Member 'ABFGActorOcean::M_pHeightTextureSoftPtr' has a wrong offset!");
static_assert(offsetof(ABFGActorOcean, M_pHeightTexture) == 0x000418, "Member 'ABFGActorOcean::M_pHeightTexture' has a wrong offset!");
static_assert(offsetof(ABFGActorOcean, M_iTextureDivider) == 0x000420, "Member 'ABFGActorOcean::M_iTextureDivider' has a wrong offset!");
static_assert(offsetof(ABFGActorOcean, M_pMaterialParamCollection) == 0x000428, "Member 'ABFGActorOcean::M_pMaterialParamCollection' has a wrong offset!");
static_assert(offsetof(ABFGActorOcean, M_sHeightMultiplier) == 0x000430, "Member 'ABFGActorOcean::M_sHeightMultiplier' has a wrong offset!");
static_assert(offsetof(ABFGActorOcean, M_sHeightShifter) == 0x000438, "Member 'ABFGActorOcean::M_sHeightShifter' has a wrong offset!");
static_assert(offsetof(ABFGActorOcean, M_sPolarUVLoop) == 0x000440, "Member 'ABFGActorOcean::M_sPolarUVLoop' has a wrong offset!");
static_assert(offsetof(ABFGActorOcean, M_sPolarUVScale) == 0x000448, "Member 'ABFGActorOcean::M_sPolarUVScale' has a wrong offset!");
static_assert(offsetof(ABFGActorOcean, M_sTextureRUVPanner) == 0x000450, "Member 'ABFGActorOcean::M_sTextureRUVPanner' has a wrong offset!");
static_assert(offsetof(ABFGActorOcean, M_sTextureGUVPanner) == 0x000458, "Member 'ABFGActorOcean::M_sTextureGUVPanner' has a wrong offset!");
static_assert(offsetof(ABFGActorOcean, M_sTextureBUVPanner) == 0x000460, "Member 'ABFGActorOcean::M_sTextureBUVPanner' has a wrong offset!");
static_assert(offsetof(ABFGActorOcean, M_sTextureAUVPanner) == 0x000468, "Member 'ABFGActorOcean::M_sTextureAUVPanner' has a wrong offset!");
static_assert(offsetof(ABFGActorOcean, M_sPolarCenterShiftUV) == 0x000470, "Member 'ABFGActorOcean::M_sPolarCenterShiftUV' has a wrong offset!");
static_assert(offsetof(ABFGActorOcean, M_pActorToUVTrace) == 0x000478, "Member 'ABFGActorOcean::M_pActorToUVTrace' has a wrong offset!");
static_assert(offsetof(ABFGActorOcean, M_pMaskTextureSoftPtr) == 0x000480, "Member 'ABFGActorOcean::M_pMaskTextureSoftPtr' has a wrong offset!");
static_assert(offsetof(ABFGActorOcean, M_pMaskTexture) == 0x0004A8, "Member 'ABFGActorOcean::M_pMaskTexture' has a wrong offset!");
static_assert(offsetof(ABFGActorOcean, M_bIsChannelUsedR) == 0x0004B0, "Member 'ABFGActorOcean::M_bIsChannelUsedR' has a wrong offset!");
static_assert(offsetof(ABFGActorOcean, M_bIsChannelUsedG) == 0x0004B1, "Member 'ABFGActorOcean::M_bIsChannelUsedG' has a wrong offset!");
static_assert(offsetof(ABFGActorOcean, M_bIsChannelUsedB) == 0x0004B2, "Member 'ABFGActorOcean::M_bIsChannelUsedB' has a wrong offset!");
static_assert(offsetof(ABFGActorOcean, M_bIsChannelUsedA) == 0x0004B3, "Member 'ABFGActorOcean::M_bIsChannelUsedA' has a wrong offset!");
static_assert(offsetof(ABFGActorOcean, M_bUsingPolarCoords) == 0x0004B4, "Member 'ABFGActorOcean::M_bUsingPolarCoords' has a wrong offset!");
static_assert(offsetof(ABFGActorOcean, M_fValueShift) == 0x0004B8, "Member 'ABFGActorOcean::M_fValueShift' has a wrong offset!");
static_assert(offsetof(ABFGActorOcean, M_pSDistanceFieldTextureSoftPtr) == 0x0004C0, "Member 'ABFGActorOcean::M_pSDistanceFieldTextureSoftPtr' has a wrong offset!");
static_assert(offsetof(ABFGActorOcean, M_pSDistanceFieldTexture) == 0x0004E8, "Member 'ABFGActorOcean::M_pSDistanceFieldTexture' has a wrong offset!");
static_assert(offsetof(ABFGActorOcean, M_fDetailWavesTopStr) == 0x0004F0, "Member 'ABFGActorOcean::M_fDetailWavesTopStr' has a wrong offset!");
static_assert(offsetof(ABFGActorOcean, M_fDetailWavesBottomStr) == 0x0004F4, "Member 'ABFGActorOcean::M_fDetailWavesBottomStr' has a wrong offset!");
static_assert(offsetof(ABFGActorOcean, M_fDetailWaveStr) == 0x0004F8, "Member 'ABFGActorOcean::M_fDetailWaveStr' has a wrong offset!");
static_assert(offsetof(ABFGActorOcean, M_fWaveMask_HeightDivider) == 0x0004FC, "Member 'ABFGActorOcean::M_fWaveMask_HeightDivider' has a wrong offset!");
static_assert(offsetof(ABFGActorOcean, M_fWaveMask_Contrast) == 0x000500, "Member 'ABFGActorOcean::M_fWaveMask_Contrast' has a wrong offset!");
static_assert(offsetof(ABFGActorOcean, M_fWaveMaskDivider) == 0x000504, "Member 'ABFGActorOcean::M_fWaveMaskDivider' has a wrong offset!");
static_assert(offsetof(ABFGActorOcean, M_fWaveMinValue) == 0x000508, "Member 'ABFGActorOcean::M_fWaveMinValue' has a wrong offset!");
static_assert(offsetof(ABFGActorOcean, M_fWaveMaxValue) == 0x00050C, "Member 'ABFGActorOcean::M_fWaveMaxValue' has a wrong offset!");
static_assert(offsetof(ABFGActorOcean, M_bIsDebugEnabled) == 0x000510, "Member 'ABFGActorOcean::M_bIsDebugEnabled' has a wrong offset!");
static_assert(offsetof(ABFGActorOcean, M_iNumberOfTestPoints) == 0x000514, "Member 'ABFGActorOcean::M_iNumberOfTestPoints' has a wrong offset!");
static_assert(offsetof(ABFGActorOcean, M_bIsSoundTestEnabled) == 0x000518, "Member 'ABFGActorOcean::M_bIsSoundTestEnabled' has a wrong offset!");
static_assert(offsetof(ABFGActorOcean, M_fSoundTestRAdius) == 0x00051C, "Member 'ABFGActorOcean::M_fSoundTestRAdius' has a wrong offset!");
static_assert(offsetof(ABFGActorOcean, M_bIsPlayerInWaterTestEnabled) == 0x000520, "Member 'ABFGActorOcean::M_bIsPlayerInWaterTestEnabled' has a wrong offset!");
static_assert(offsetof(ABFGActorOcean, M_pMaterialParamCollectionInstance) == 0x000528, "Member 'ABFGActorOcean::M_pMaterialParamCollectionInstance' has a wrong offset!");
static_assert(offsetof(ABFGActorOcean, M_aPixelArrayCopy) == 0x000530, "Member 'ABFGActorOcean::M_aPixelArrayCopy' has a wrong offset!");
static_assert(offsetof(ABFGActorOcean, M_aPixelMaskArrayCopy) == 0x000540, "Member 'ABFGActorOcean::M_aPixelMaskArrayCopy' has a wrong offset!");
static_assert(offsetof(ABFGActorOcean, M_aDistanceFieldArrayCopy) == 0x000550, "Member 'ABFGActorOcean::M_aDistanceFieldArrayCopy' has a wrong offset!");
static_assert(offsetof(ABFGActorOcean, M_iHeightTextureSizeX) == 0x000560, "Member 'ABFGActorOcean::M_iHeightTextureSizeX' has a wrong offset!");
static_assert(offsetof(ABFGActorOcean, M_iHeightTextureSizeY) == 0x000564, "Member 'ABFGActorOcean::M_iHeightTextureSizeY' has a wrong offset!");
static_assert(offsetof(ABFGActorOcean, M_iMaskTextureSizeX) == 0x000568, "Member 'ABFGActorOcean::M_iMaskTextureSizeX' has a wrong offset!");
static_assert(offsetof(ABFGActorOcean, M_iMaskTextureSizeY) == 0x00056C, "Member 'ABFGActorOcean::M_iMaskTextureSizeY' has a wrong offset!");
static_assert(offsetof(ABFGActorOcean, M_iSDistanceTextureSizeX) == 0x000570, "Member 'ABFGActorOcean::M_iSDistanceTextureSizeX' has a wrong offset!");
static_assert(offsetof(ABFGActorOcean, M_iSDistanceTextureSizeY) == 0x000574, "Member 'ABFGActorOcean::M_iSDistanceTextureSizeY' has a wrong offset!");
static_assert(offsetof(ABFGActorOcean, M_iOriginalHeightTextureSizeX) == 0x000578, "Member 'ABFGActorOcean::M_iOriginalHeightTextureSizeX' has a wrong offset!");
static_assert(offsetof(ABFGActorOcean, M_iOriginalHeightTextureSizeY) == 0x00057C, "Member 'ABFGActorOcean::M_iOriginalHeightTextureSizeY' has a wrong offset!");
static_assert(offsetof(ABFGActorOcean, M_iOriginalMaskTextureSizeX) == 0x000580, "Member 'ABFGActorOcean::M_iOriginalMaskTextureSizeX' has a wrong offset!");
static_assert(offsetof(ABFGActorOcean, M_iOriginalMaskTextureSizeY) == 0x000584, "Member 'ABFGActorOcean::M_iOriginalMaskTextureSizeY' has a wrong offset!");
static_assert(offsetof(ABFGActorOcean, M_iOriginalSDistanceTextureSizeX) == 0x000588, "Member 'ABFGActorOcean::M_iOriginalSDistanceTextureSizeX' has a wrong offset!");
static_assert(offsetof(ABFGActorOcean, M_iOriginalSDistanceTextureSizeY) == 0x00058C, "Member 'ABFGActorOcean::M_iOriginalSDistanceTextureSizeY' has a wrong offset!");
static_assert(offsetof(ABFGActorOcean, M_aRandomPoints) == 0x000668, "Member 'ABFGActorOcean::M_aRandomPoints' has a wrong offset!");

// Class BFGCore.BFGNPCCharacterEnemy_Mecha
// 0x0000 (0x0BE0 - 0x0BE0)
class ABFGNPCCharacterEnemy_Mecha : public ABFGNPCCharacterEnemy
{
public:
	class UBFGActorComponent_ExplosiveItem*       M_pExplosiveComponent;                             // 0x0BD8(0x0008)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

public:
	void OnStompAttackStarted(float M_fStompDuration, bool _bUsedRightFoot);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"BFGNPCCharacterEnemy_Mecha">();
	}
	static class ABFGNPCCharacterEnemy_Mecha* GetDefaultObj()
	{
		return GetDefaultObjImpl<ABFGNPCCharacterEnemy_Mecha>();
	}
};
static_assert(alignof(ABFGNPCCharacterEnemy_Mecha) == 0x000010, "Wrong alignment on ABFGNPCCharacterEnemy_Mecha");
static_assert(sizeof(ABFGNPCCharacterEnemy_Mecha) == 0x000BE0, "Wrong size on ABFGNPCCharacterEnemy_Mecha");
static_assert(offsetof(ABFGNPCCharacterEnemy_Mecha, M_pExplosiveComponent) == 0x000BD8, "Member 'ABFGNPCCharacterEnemy_Mecha::M_pExplosiveComponent' has a wrong offset!");

// Class BFGCore.BFGTaskNode_WaitForCatchupTurning
// 0x0008 (0x0080 - 0x0078)
class UBFGTaskNode_WaitForCatchupTurning final : public UBFGBTBaseTaskNode
{
public:
	bool                                          M_bWaitOneTick;                                    // 0x0078(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_79[0x3];                                       // 0x0079(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         M_fMaxWeaponOffsetFromAimTarget;                   // 0x007C(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"BFGTaskNode_WaitForCatchupTurning">();
	}
	static class UBFGTaskNode_WaitForCatchupTurning* GetDefaultObj()
	{
		return GetDefaultObjImpl<UBFGTaskNode_WaitForCatchupTurning>();
	}
};
static_assert(alignof(UBFGTaskNode_WaitForCatchupTurning) == 0x000008, "Wrong alignment on UBFGTaskNode_WaitForCatchupTurning");
static_assert(sizeof(UBFGTaskNode_WaitForCatchupTurning) == 0x000080, "Wrong size on UBFGTaskNode_WaitForCatchupTurning");
static_assert(offsetof(UBFGTaskNode_WaitForCatchupTurning, M_bWaitOneTick) == 0x000078, "Member 'UBFGTaskNode_WaitForCatchupTurning::M_bWaitOneTick' has a wrong offset!");
static_assert(offsetof(UBFGTaskNode_WaitForCatchupTurning, M_fMaxWeaponOffsetFromAimTarget) == 0x00007C, "Member 'UBFGTaskNode_WaitForCatchupTurning::M_fMaxWeaponOffsetFromAimTarget' has a wrong offset!");

// Class BFGCore.BFGCheatManager
// 0x0000 (0x0028 - 0x0028)
class UBFGCheatManager final : public UObject
{
public:
	static class UBFGCheatSettings* GetSettings();

	void AddDNA(int32 _iAddedAmount);
	void CallUFO();
	void DecrementBFGMouseSensitivity();
	void DisableMusic();
	void FlyMode();
	void GenerateCrashDump();
	void IncrementBFGMouseSensitivity();
	void IncrementInputPack();
	bool IsHUDVisible();
	void KillPlayer();
	void LockAll(bool _bPermanent);
	void LockAllAbilities(bool _bPermanent);
	void LockAllWeapons(bool _bPermanent);
	void LockUnlockAbilityCortexScan(bool _bPermanent, int32 _tier);
	void LockUnlockAbilityExtractBrain(bool _bPermanent, int32 _tier);
	void LockUnlockAbilityHolobob(bool _bPermanent, int32 _tier);
	void LockUnlockAbilityHypnotize(bool _bPermanent, int32 _tier);
	void LockUnlockAbilityPsycokinesis(bool _bPermanent, int32 _tier);
	void LockUnlockWeaponAnalProbe(bool _bPermanent, int32 _tier);
	void LockUnlockWeaponDisintegratorRay(bool _bPermanent, int32 _tier);
	void LockUnlockWeaponIonDetonator(bool _bPermanent, int32 _tier);
	void LockUnlockWeaponZap(bool _bPermanent, int32 _tier);
	void NukeEnemies();
	void NukeEnemiesInRange(float _fRange);
	void ReceiveInitCheatManager();
	void RespawnPlayer();
	void SetBFGMouseSensitivity(float _fSensitivity);
	void SetCurrentLanguage(const class FString& _strCulture);
	void SetFuronigamiUnlocked(bool _bUnlocked);
	void SetGameIni(const class FString& _strVariable, int32 _iNewValue);
	void SetPrePurchaseDLCUnlocked(bool _bUnlocked);
	void ShowGameMenu(class FName _name);
	void SpawnCivilian();
	void SpawnCow();
	void SpawnDisintegratorAmmo();
	void SpawnEnemyCop();
	void SpawnEnemyFarmer();
	void SpawnEnemyMajestic();
	void SpawnEnemyPowersuit();
	void SpawnEnemySoldier();
	void SpawnIonDetonatorAmmo();
	void SpawnQuantumDeconstructor();
	void SpawnSonicBoomAmmo();
	void ToggleCrossHairHUDHidden();
	void ToggleFreezeWorld();
	void ToggleHUD();
	void ToggleImmortality();
	void ToggleInfiniteAmmo();
	void ToggleInfiniteCharge();
	void ToggleInfiniteConcentration();
	void ToggleInformativeHUDHidden();
	void ToggleInvertYAimingAxis();
	void ToggleInvisibility();
	void ToggleInvulnerability();
	void ToggleLockOnTag(const class FName _tag, bool _bPermanent);
	void ToggleMenu();
	void ToggleSaucer();
	void ToggleSubtitles();
	void ToggleWorldHelpersHUDHidden();
	void UnlockAlAbilities(bool _bPermanent);
	void UnlockAll(bool _bPermanent);
	void UnlockAllWeapons(bool _bPermanent);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"BFGCheatManager">();
	}
	static class UBFGCheatManager* GetDefaultObj()
	{
		return GetDefaultObjImpl<UBFGCheatManager>();
	}
};
static_assert(alignof(UBFGCheatManager) == 0x000008, "Wrong alignment on UBFGCheatManager");
static_assert(sizeof(UBFGCheatManager) == 0x000028, "Wrong size on UBFGCheatManager");

// Class BFGCore.BFGActorProxy
// 0x0058 (0x0430 - 0x03D8)
class ABFGActorProxy : public AActor
{
public:
	uint8                                         Pad_3D8[0x8];                                      // 0x03D8(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	class UBFGActorComponent_ProxyChildActor*     M_pProxyChildActor;                                // 0x03E0(0x0008)(Edit, ExportObject, ZeroConstructor, EditConst, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FGameplayTagContainer                  M_gameplayTags;                                    // 0x03E8(0x0020)(Edit, Protected, NativeAccessSpecifierProtected)
	struct FGameplayTagContainer                  M_gameplayTagsChildActor;                          // 0x0408(0x0020)(Edit, Protected, NativeAccessSpecifierProtected)
	bool                                          M_bEnableLODEnabledOverride;                       // 0x0428(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          M_bLODEnabledOverride;                             // 0x0429(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	EBFGActorProxyState                           M_state;                                           // 0x042A(0x0001)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_42B[0x5];                                      // 0x042B(0x0005)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"BFGActorProxy">();
	}
	static class ABFGActorProxy* GetDefaultObj()
	{
		return GetDefaultObjImpl<ABFGActorProxy>();
	}
};
static_assert(alignof(ABFGActorProxy) == 0x000008, "Wrong alignment on ABFGActorProxy");
static_assert(sizeof(ABFGActorProxy) == 0x000430, "Wrong size on ABFGActorProxy");
static_assert(offsetof(ABFGActorProxy, M_pProxyChildActor) == 0x0003E0, "Member 'ABFGActorProxy::M_pProxyChildActor' has a wrong offset!");
static_assert(offsetof(ABFGActorProxy, M_gameplayTags) == 0x0003E8, "Member 'ABFGActorProxy::M_gameplayTags' has a wrong offset!");
static_assert(offsetof(ABFGActorProxy, M_gameplayTagsChildActor) == 0x000408, "Member 'ABFGActorProxy::M_gameplayTagsChildActor' has a wrong offset!");
static_assert(offsetof(ABFGActorProxy, M_bEnableLODEnabledOverride) == 0x000428, "Member 'ABFGActorProxy::M_bEnableLODEnabledOverride' has a wrong offset!");
static_assert(offsetof(ABFGActorProxy, M_bLODEnabledOverride) == 0x000429, "Member 'ABFGActorProxy::M_bLODEnabledOverride' has a wrong offset!");
static_assert(offsetof(ABFGActorProxy, M_state) == 0x00042A, "Member 'ABFGActorProxy::M_state' has a wrong offset!");

// Class BFGCore.BFGActorProxyCollect
// 0x0000 (0x0430 - 0x0430)
class ABFGActorProxyCollect : public ABFGActorProxy
{
public:
	void OnPostCreateChildActor(class UBFGActorComponent_ProxyChildActor* _pComponent, class AActor* _pChildActor);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"BFGActorProxyCollect">();
	}
	static class ABFGActorProxyCollect* GetDefaultObj()
	{
		return GetDefaultObjImpl<ABFGActorProxyCollect>();
	}
};
static_assert(alignof(ABFGActorProxyCollect) == 0x000008, "Wrong alignment on ABFGActorProxyCollect");
static_assert(sizeof(ABFGActorProxyCollect) == 0x000430, "Wrong size on ABFGActorProxyCollect");

// Class BFGCore.BFGVariableAction_Quest_Progress
// 0x0000 (0x00F0 - 0x00F0)
class UBFGVariableAction_Quest_Progress final : public UBFGVariableAction
{
public:
	static const class FName GetActionNameQuestProgress();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"BFGVariableAction_Quest_Progress">();
	}
	static class UBFGVariableAction_Quest_Progress* GetDefaultObj()
	{
		return GetDefaultObjImpl<UBFGVariableAction_Quest_Progress>();
	}
};
static_assert(alignof(UBFGVariableAction_Quest_Progress) == 0x000008, "Wrong alignment on UBFGVariableAction_Quest_Progress");
static_assert(sizeof(UBFGVariableAction_Quest_Progress) == 0x0000F0, "Wrong size on UBFGVariableAction_Quest_Progress");

// Class BFGCore.BFGBuildingHelper
// 0x0000 (0x03D8 - 0x03D8)
class ABFGBuildingHelper final : public AActor
{
public:
	void InitializeBuildingEditor(class ABFGActorBuilding* _pActorBuilding);
	void StoreBuildingEditor();
	void ToggleBuildingEditor();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"BFGBuildingHelper">();
	}
	static class ABFGBuildingHelper* GetDefaultObj()
	{
		return GetDefaultObjImpl<ABFGBuildingHelper>();
	}
};
static_assert(alignof(ABFGBuildingHelper) == 0x000008, "Wrong alignment on ABFGBuildingHelper");
static_assert(sizeof(ABFGBuildingHelper) == 0x0003D8, "Wrong size on ABFGBuildingHelper");

// Class BFGCore.BFGActorStat
// 0x0020 (0x0048 - 0x0028)
class UBFGActorStat : public UObject
{
public:
	bool                                          M_bFrozenWhenCutscenePlaying;                      // 0x0028(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          M_bFrozenByGameplay;                               // 0x0029(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          M_bPersistentStat;                                 // 0x002A(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_2B[0x5];                                       // 0x002B(0x0005)(Fixing Size After Last Property [ Dumper-7 ])
	class AActor*                                 M_pOwner;                                          // 0x0030(0x0008)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_38[0xC];                                       // 0x0038(0x000C)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         M_fLastChangeTime;                                 // 0x0044(0x0004)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)

public:
	float GetLastChangedTime() const;
	bool IsFrozenEnabled() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"BFGActorStat">();
	}
	static class UBFGActorStat* GetDefaultObj()
	{
		return GetDefaultObjImpl<UBFGActorStat>();
	}
};
static_assert(alignof(UBFGActorStat) == 0x000008, "Wrong alignment on UBFGActorStat");
static_assert(sizeof(UBFGActorStat) == 0x000048, "Wrong size on UBFGActorStat");
static_assert(offsetof(UBFGActorStat, M_bFrozenWhenCutscenePlaying) == 0x000028, "Member 'UBFGActorStat::M_bFrozenWhenCutscenePlaying' has a wrong offset!");
static_assert(offsetof(UBFGActorStat, M_bFrozenByGameplay) == 0x000029, "Member 'UBFGActorStat::M_bFrozenByGameplay' has a wrong offset!");
static_assert(offsetof(UBFGActorStat, M_bPersistentStat) == 0x00002A, "Member 'UBFGActorStat::M_bPersistentStat' has a wrong offset!");
static_assert(offsetof(UBFGActorStat, M_pOwner) == 0x000030, "Member 'UBFGActorStat::M_pOwner' has a wrong offset!");
static_assert(offsetof(UBFGActorStat, M_fLastChangeTime) == 0x000044, "Member 'UBFGActorStat::M_fLastChangeTime' has a wrong offset!");

// Class BFGCore.BFGNetworkPathAgent_AI
// 0x0160 (0x0188 - 0x0028)
class UBFGNetworkPathAgent_AI : public UObject
{
public:
	uint8                                         Pad_28[0x78];                                      // 0x0028(0x0078)(Fixing Size After Last Property [ Dumper-7 ])
	class UBFGNetworkPathAgent*                   M_pAgent;                                          // 0x00A0(0x0008)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UBFGNetworkPathAgent_AIStateBase*       M_pCurrentState;                                   // 0x00A8(0x0008)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UBFGNetworkPathAgent_AIStateBase*       M_pStateBeforeLeftCrowdFlow;                       // 0x00B0(0x0008)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UBFGNetworkPathAgent_AIStateBase*       M_pInitialState;                                   // 0x00B8(0x0008)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	EBFGBehaviourState_NPC                        M_eCachedBehavourState;                            // 0x00C0(0x0001)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_C1[0x7];                                       // 0x00C1(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	struct FBFGAgentAIData                        M_agentAIData;                                     // 0x00C8(0x00B0)(Transient, ContainsInstancedReference, Protected, NativeAccessSpecifierProtected)
	TArray<class UObject*>                        M_apSensorUpdatesDisabledRequesters;               // 0x0178(0x0010)(ZeroConstructor, Transient, Protected, NativeAccessSpecifierProtected)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"BFGNetworkPathAgent_AI">();
	}
	static class UBFGNetworkPathAgent_AI* GetDefaultObj()
	{
		return GetDefaultObjImpl<UBFGNetworkPathAgent_AI>();
	}
};
static_assert(alignof(UBFGNetworkPathAgent_AI) == 0x000008, "Wrong alignment on UBFGNetworkPathAgent_AI");
static_assert(sizeof(UBFGNetworkPathAgent_AI) == 0x000188, "Wrong size on UBFGNetworkPathAgent_AI");
static_assert(offsetof(UBFGNetworkPathAgent_AI, M_pAgent) == 0x0000A0, "Member 'UBFGNetworkPathAgent_AI::M_pAgent' has a wrong offset!");
static_assert(offsetof(UBFGNetworkPathAgent_AI, M_pCurrentState) == 0x0000A8, "Member 'UBFGNetworkPathAgent_AI::M_pCurrentState' has a wrong offset!");
static_assert(offsetof(UBFGNetworkPathAgent_AI, M_pStateBeforeLeftCrowdFlow) == 0x0000B0, "Member 'UBFGNetworkPathAgent_AI::M_pStateBeforeLeftCrowdFlow' has a wrong offset!");
static_assert(offsetof(UBFGNetworkPathAgent_AI, M_pInitialState) == 0x0000B8, "Member 'UBFGNetworkPathAgent_AI::M_pInitialState' has a wrong offset!");
static_assert(offsetof(UBFGNetworkPathAgent_AI, M_eCachedBehavourState) == 0x0000C0, "Member 'UBFGNetworkPathAgent_AI::M_eCachedBehavourState' has a wrong offset!");
static_assert(offsetof(UBFGNetworkPathAgent_AI, M_agentAIData) == 0x0000C8, "Member 'UBFGNetworkPathAgent_AI::M_agentAIData' has a wrong offset!");
static_assert(offsetof(UBFGNetworkPathAgent_AI, M_apSensorUpdatesDisabledRequesters) == 0x000178, "Member 'UBFGNetworkPathAgent_AI::M_apSensorUpdatesDisabledRequesters' has a wrong offset!");

// Class BFGCore.BFGNetworkPathAgent_AIVehicle
// 0x0000 (0x0188 - 0x0188)
class UBFGNetworkPathAgent_AIVehicle final : public UBFGNetworkPathAgent_AI
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"BFGNetworkPathAgent_AIVehicle">();
	}
	static class UBFGNetworkPathAgent_AIVehicle* GetDefaultObj()
	{
		return GetDefaultObjImpl<UBFGNetworkPathAgent_AIVehicle>();
	}
};
static_assert(alignof(UBFGNetworkPathAgent_AIVehicle) == 0x000008, "Wrong alignment on UBFGNetworkPathAgent_AIVehicle");
static_assert(sizeof(UBFGNetworkPathAgent_AIVehicle) == 0x000188, "Wrong size on UBFGNetworkPathAgent_AIVehicle");

// Class BFGCore.BFGActorStat_Bool
// 0x0028 (0x0070 - 0x0048)
class UBFGActorStat_Bool final : public UBFGActorStat
{
public:
	bool                                          M_bInitialValue;                                   // 0x0048(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_49[0x7];                                       // 0x0049(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	UMulticastDelegateProperty_                   M_onChanged;                                       // 0x0050(0x0018)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	bool                                          M_bValue;                                          // 0x0068(0x0001)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_69[0x7];                                       // 0x0069(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void SetValue(bool _bValue, bool _bBroadcast);

	bool GetValue() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"BFGActorStat_Bool">();
	}
	static class UBFGActorStat_Bool* GetDefaultObj()
	{
		return GetDefaultObjImpl<UBFGActorStat_Bool>();
	}
};
static_assert(alignof(UBFGActorStat_Bool) == 0x000008, "Wrong alignment on UBFGActorStat_Bool");
static_assert(sizeof(UBFGActorStat_Bool) == 0x000070, "Wrong size on UBFGActorStat_Bool");
static_assert(offsetof(UBFGActorStat_Bool, M_bInitialValue) == 0x000048, "Member 'UBFGActorStat_Bool::M_bInitialValue' has a wrong offset!");
static_assert(offsetof(UBFGActorStat_Bool, M_onChanged) == 0x000050, "Member 'UBFGActorStat_Bool::M_onChanged' has a wrong offset!");
static_assert(offsetof(UBFGActorStat_Bool, M_bValue) == 0x000068, "Member 'UBFGActorStat_Bool::M_bValue' has a wrong offset!");

// Class BFGCore.BFGBTService_VehicleState
// 0x0190 (0x0208 - 0x0078)
class UBFGBTService_VehicleState : public UBFGBTBaseService
{
public:
	struct FBlackboardKeySelector                 M_BBKeyState;                                      // 0x0078(0x0028)(Edit, BlueprintVisible, NativeAccessSpecifierPublic)
	struct FBlackboardKeySelector                 M_BBKeyStateAge;                                   // 0x00A0(0x0028)(Edit, BlueprintVisible, NativeAccessSpecifierPublic)
	struct FBlackboardKeySelector                 M_BBKeySuspiciousLocation;                         // 0x00C8(0x0028)(Edit, BlueprintVisible, NativeAccessSpecifierPublic)
	struct FBlackboardKeySelector                 M_BBKeySuspiciousTarget;                           // 0x00F0(0x0028)(Edit, BlueprintVisible, NativeAccessSpecifierPublic)
	struct FBlackboardKeySelector                 M_BBKeyAttackTarget;                               // 0x0118(0x0028)(Edit, BlueprintVisible, NativeAccessSpecifierPublic)
	struct FBlackboardKeySelector                 M_BBKeyAttackTargetLoS;                            // 0x0140(0x0028)(Edit, BlueprintVisible, NativeAccessSpecifierPublic)
	struct FBlackboardKeySelector                 M_BBKeyAlertSensesAny;                             // 0x0168(0x0028)(Edit, BlueprintVisible, NativeAccessSpecifierPublic)
	struct FBlackboardKeySelector                 M_BBKeyShouldAttack;                               // 0x0190(0x0028)(Edit, BlueprintVisible, NativeAccessSpecifierPublic)
	struct FBlackboardKeySelector                 M_BBKeyDrivingMode;                                // 0x01B8(0x0028)(Edit, BlueprintVisible, NativeAccessSpecifierPublic)
	struct FBlackboardKeySelector                 M_BBKey_CrowdFlowAgent;                            // 0x01E0(0x0028)(Edit, BlueprintVisible, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"BFGBTService_VehicleState">();
	}
	static class UBFGBTService_VehicleState* GetDefaultObj()
	{
		return GetDefaultObjImpl<UBFGBTService_VehicleState>();
	}
};
static_assert(alignof(UBFGBTService_VehicleState) == 0x000008, "Wrong alignment on UBFGBTService_VehicleState");
static_assert(sizeof(UBFGBTService_VehicleState) == 0x000208, "Wrong size on UBFGBTService_VehicleState");
static_assert(offsetof(UBFGBTService_VehicleState, M_BBKeyState) == 0x000078, "Member 'UBFGBTService_VehicleState::M_BBKeyState' has a wrong offset!");
static_assert(offsetof(UBFGBTService_VehicleState, M_BBKeyStateAge) == 0x0000A0, "Member 'UBFGBTService_VehicleState::M_BBKeyStateAge' has a wrong offset!");
static_assert(offsetof(UBFGBTService_VehicleState, M_BBKeySuspiciousLocation) == 0x0000C8, "Member 'UBFGBTService_VehicleState::M_BBKeySuspiciousLocation' has a wrong offset!");
static_assert(offsetof(UBFGBTService_VehicleState, M_BBKeySuspiciousTarget) == 0x0000F0, "Member 'UBFGBTService_VehicleState::M_BBKeySuspiciousTarget' has a wrong offset!");
static_assert(offsetof(UBFGBTService_VehicleState, M_BBKeyAttackTarget) == 0x000118, "Member 'UBFGBTService_VehicleState::M_BBKeyAttackTarget' has a wrong offset!");
static_assert(offsetof(UBFGBTService_VehicleState, M_BBKeyAttackTargetLoS) == 0x000140, "Member 'UBFGBTService_VehicleState::M_BBKeyAttackTargetLoS' has a wrong offset!");
static_assert(offsetof(UBFGBTService_VehicleState, M_BBKeyAlertSensesAny) == 0x000168, "Member 'UBFGBTService_VehicleState::M_BBKeyAlertSensesAny' has a wrong offset!");
static_assert(offsetof(UBFGBTService_VehicleState, M_BBKeyShouldAttack) == 0x000190, "Member 'UBFGBTService_VehicleState::M_BBKeyShouldAttack' has a wrong offset!");
static_assert(offsetof(UBFGBTService_VehicleState, M_BBKeyDrivingMode) == 0x0001B8, "Member 'UBFGBTService_VehicleState::M_BBKeyDrivingMode' has a wrong offset!");
static_assert(offsetof(UBFGBTService_VehicleState, M_BBKey_CrowdFlowAgent) == 0x0001E0, "Member 'UBFGBTService_VehicleState::M_BBKey_CrowdFlowAgent' has a wrong offset!");

// Class BFGCore.BFGWidget_MainMenu
// 0x0008 (0x0430 - 0x0428)
class UBFGWidget_MainMenu final : public UBFGWidget_GenericDialog
{
public:
	uint8                                         Pad_428[0x8];                                      // 0x0428(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void Action__DelegateSignature();
	EBFGGameFlowState_MainMenu_State GetCurrentMenuState();
	void OnAcceptButtonClicked();
	void OnDroneAcknowledged();
	void OnFebruaryGiftsAcknowledged();
	void OnGiftsAcknowledged();
	void PlayFebruaryGiftsAnimation();
	void PlayGiftsAnimation();
	void PlayMainAnimation();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"BFGWidget_MainMenu">();
	}
	static class UBFGWidget_MainMenu* GetDefaultObj()
	{
		return GetDefaultObjImpl<UBFGWidget_MainMenu>();
	}
};
static_assert(alignof(UBFGWidget_MainMenu) == 0x000008, "Wrong alignment on UBFGWidget_MainMenu");
static_assert(sizeof(UBFGWidget_MainMenu) == 0x000430, "Wrong size on UBFGWidget_MainMenu");

// Class BFGCore.BFGActorStat_uint8
// 0x0028 (0x0070 - 0x0048)
class UBFGActorStat_uint8 : public UBFGActorStat
{
public:
	uint8                                         M_eInitialValue;                                   // 0x0048(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_49[0x7];                                       // 0x0049(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	UMulticastDelegateProperty_                   M_onChanged;                                       // 0x0050(0x0018)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	uint8                                         M_ubValue;                                         // 0x0068(0x0001)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_69[0x7];                                       // 0x0069(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void SetValue(int32 _iValue, bool _bBroadcast);

	uint8 GetValue() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"BFGActorStat_uint8">();
	}
	static class UBFGActorStat_uint8* GetDefaultObj()
	{
		return GetDefaultObjImpl<UBFGActorStat_uint8>();
	}
};
static_assert(alignof(UBFGActorStat_uint8) == 0x000008, "Wrong alignment on UBFGActorStat_uint8");
static_assert(sizeof(UBFGActorStat_uint8) == 0x000070, "Wrong size on UBFGActorStat_uint8");
static_assert(offsetof(UBFGActorStat_uint8, M_eInitialValue) == 0x000048, "Member 'UBFGActorStat_uint8::M_eInitialValue' has a wrong offset!");
static_assert(offsetof(UBFGActorStat_uint8, M_onChanged) == 0x000050, "Member 'UBFGActorStat_uint8::M_onChanged' has a wrong offset!");
static_assert(offsetof(UBFGActorStat_uint8, M_ubValue) == 0x000068, "Member 'UBFGActorStat_uint8::M_ubValue' has a wrong offset!");

// Class BFGCore.BFGActorStat_EnumBehaviourState_NPC
// 0x0000 (0x0070 - 0x0070)
class UBFGActorStat_EnumBehaviourState_NPC final : public UBFGActorStat_uint8
{
public:
	void SetValueEnum(EBFGBehaviourState_NPC _eValue, bool _bBroadcast);

	EBFGBehaviourState_NPC GetValueEnum() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"BFGActorStat_EnumBehaviourState_NPC">();
	}
	static class UBFGActorStat_EnumBehaviourState_NPC* GetDefaultObj()
	{
		return GetDefaultObjImpl<UBFGActorStat_EnumBehaviourState_NPC>();
	}
};
static_assert(alignof(UBFGActorStat_EnumBehaviourState_NPC) == 0x000008, "Wrong alignment on UBFGActorStat_EnumBehaviourState_NPC");
static_assert(sizeof(UBFGActorStat_EnumBehaviourState_NPC) == 0x000070, "Wrong size on UBFGActorStat_EnumBehaviourState_NPC");

// Class BFGCore.BFGChallengeStartingPoint
// 0x0098 (0x0470 - 0x03D8)
class ABFGChallengeStartingPoint : public AActor
{
public:
	uint8                                         Pad_3D8[0x10];                                     // 0x03D8(0x0010)(Fixing Size After Last Property [ Dumper-7 ])
	struct FGameplayTagContainer                  M_gameplayTags;                                    // 0x03E8(0x0020)(Edit, BlueprintVisible, BlueprintReadOnly, Protected, NativeAccessSpecifierProtected)
	class UBFGActorComponent_Objective*           M_pObjectiveComponent;                             // 0x0408(0x0008)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, EditConst, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class USceneComponent*                        M_pObjectiveMarkerParentComponent;                 // 0x0410(0x0008)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, EditConst, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UWidgetComponent*                       M_pPanelWidgetComponent;                           // 0x0418(0x0008)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, EditConst, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UChildActorComponent*                   M_pBeamChildActorComponent;                        // 0x0420(0x0008)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, EditConst, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         M_fDeadZoneRadius;                                 // 0x0428(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         M_fInteractiveRadius;                              // 0x042C(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         M_fVisibleRadius;                                  // 0x0430(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         M_fAnimationSpeed;                                 // 0x0434(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TSoftObjectPtr<class UBFGDataAsset_ChallengeInfo> M_spChallengeInfo;                                 // 0x0438(0x0028)(Edit, BlueprintVisible, BlueprintReadOnly, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_460[0xC];                                      // 0x0460(0x000C)(Fixing Size After Last Property [ Dumper-7 ])
	EBFGChallengeStartingPoint_Visibility         M_eCurrentVisibility;                              // 0x046C(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_46D[0x3];                                      // 0x046D(0x0003)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void OnPanelVisibilityChanged(EBFGChallengeStartingPoint_Visibility _eVisibility);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"BFGChallengeStartingPoint">();
	}
	static class ABFGChallengeStartingPoint* GetDefaultObj()
	{
		return GetDefaultObjImpl<ABFGChallengeStartingPoint>();
	}
};
static_assert(alignof(ABFGChallengeStartingPoint) == 0x000008, "Wrong alignment on ABFGChallengeStartingPoint");
static_assert(sizeof(ABFGChallengeStartingPoint) == 0x000470, "Wrong size on ABFGChallengeStartingPoint");
static_assert(offsetof(ABFGChallengeStartingPoint, M_gameplayTags) == 0x0003E8, "Member 'ABFGChallengeStartingPoint::M_gameplayTags' has a wrong offset!");
static_assert(offsetof(ABFGChallengeStartingPoint, M_pObjectiveComponent) == 0x000408, "Member 'ABFGChallengeStartingPoint::M_pObjectiveComponent' has a wrong offset!");
static_assert(offsetof(ABFGChallengeStartingPoint, M_pObjectiveMarkerParentComponent) == 0x000410, "Member 'ABFGChallengeStartingPoint::M_pObjectiveMarkerParentComponent' has a wrong offset!");
static_assert(offsetof(ABFGChallengeStartingPoint, M_pPanelWidgetComponent) == 0x000418, "Member 'ABFGChallengeStartingPoint::M_pPanelWidgetComponent' has a wrong offset!");
static_assert(offsetof(ABFGChallengeStartingPoint, M_pBeamChildActorComponent) == 0x000420, "Member 'ABFGChallengeStartingPoint::M_pBeamChildActorComponent' has a wrong offset!");
static_assert(offsetof(ABFGChallengeStartingPoint, M_fDeadZoneRadius) == 0x000428, "Member 'ABFGChallengeStartingPoint::M_fDeadZoneRadius' has a wrong offset!");
static_assert(offsetof(ABFGChallengeStartingPoint, M_fInteractiveRadius) == 0x00042C, "Member 'ABFGChallengeStartingPoint::M_fInteractiveRadius' has a wrong offset!");
static_assert(offsetof(ABFGChallengeStartingPoint, M_fVisibleRadius) == 0x000430, "Member 'ABFGChallengeStartingPoint::M_fVisibleRadius' has a wrong offset!");
static_assert(offsetof(ABFGChallengeStartingPoint, M_fAnimationSpeed) == 0x000434, "Member 'ABFGChallengeStartingPoint::M_fAnimationSpeed' has a wrong offset!");
static_assert(offsetof(ABFGChallengeStartingPoint, M_spChallengeInfo) == 0x000438, "Member 'ABFGChallengeStartingPoint::M_spChallengeInfo' has a wrong offset!");
static_assert(offsetof(ABFGChallengeStartingPoint, M_eCurrentVisibility) == 0x00046C, "Member 'ABFGChallengeStartingPoint::M_eCurrentVisibility' has a wrong offset!");

// Class BFGCore.BFGWidgetPoxLabEntryPoint
// 0x0030 (0x0270 - 0x0240)
class UBFGWidgetPoxLabEntryPoint final : public UUserWidget
{
public:
	uint8                                         Pad_240[0x18];                                     // 0x0240(0x0018)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<class UBFGWidgetPoxLabEntryPointOption*> M_aEntryOptions;                                   // 0x0258(0x0010)(BlueprintVisible, ExportObject, ZeroConstructor, ContainsInstancedReference, NativeAccessSpecifierPublic)
	uint8                                         Pad_268[0x8];                                      // 0x0268(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void OnOptionMouseHover(EBFGMotherShipPoxLabType _eType);
	void OnOptionMousePress(EBFGMotherShipPoxLabType _eType);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"BFGWidgetPoxLabEntryPoint">();
	}
	static class UBFGWidgetPoxLabEntryPoint* GetDefaultObj()
	{
		return GetDefaultObjImpl<UBFGWidgetPoxLabEntryPoint>();
	}
};
static_assert(alignof(UBFGWidgetPoxLabEntryPoint) == 0x000008, "Wrong alignment on UBFGWidgetPoxLabEntryPoint");
static_assert(sizeof(UBFGWidgetPoxLabEntryPoint) == 0x000270, "Wrong size on UBFGWidgetPoxLabEntryPoint");
static_assert(offsetof(UBFGWidgetPoxLabEntryPoint, M_aEntryOptions) == 0x000258, "Member 'UBFGWidgetPoxLabEntryPoint::M_aEntryOptions' has a wrong offset!");

// Class BFGCore.BFGActorStat_Float
// 0x0058 (0x00A0 - 0x0048)
class UBFGActorStat_Float final : public UBFGActorStat
{
public:
	float                                         M_fMaxValue;                                       // 0x0048(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         M_fMinValue;                                       // 0x004C(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         M_fInitialValue;                                   // 0x0050(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         M_fLastValue;                                      // 0x0054(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         M_fRegenrationRate;                                // 0x0058(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         M_fRegenrationRateOverride;                        // 0x005C(0x0004)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         M_fRegenrationDelay;                               // 0x0060(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         M_fRegenrationDelayOverride;                       // 0x0064(0x0004)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	UMulticastDelegateProperty_                   M_onChanged;                                       // 0x0068(0x0018)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	UMulticastDelegateProperty_                   M_onRegernationChanged;                            // 0x0080(0x0018)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	float                                         M_fValue;                                          // 0x0098(0x0004)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          M_bRegenEnabled;                                   // 0x009C(0x0001)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          M_bWasRegeneratingLastFrame;                       // 0x009D(0x0001)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          M_bIsRegenerating;                                 // 0x009E(0x0001)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_9F[0x1];                                       // 0x009F(0x0001)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void AddValue(float _fValue, bool _bBroadcast, bool _bRegisterChange);
	void ForceRegenEnabled();
	void SetRatio(float _fRatio, bool _bBroadcast, bool _bRegisterChange, bool _bForceInit);
	void SetRegenEnabled(bool _bRegenEnabled);
	void SetRegenerationDelayOverride(float _fOverride);
	void SetRegenerationRateOverride(float _fOverride);
	void SetValue(float _fValue, bool _bBroadcast, bool _bRegisterChange, bool _bForceInit);

	float GetCurrentRegenerationDelay() const;
	float GetCurrentRegenerationRate() const;
	bool GetIsCurrentlyRegenerating() const;
	float GetRatio() const;
	float GetValue() const;
	float GetValueNorm() const;
	bool IsRegenEnabled() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"BFGActorStat_Float">();
	}
	static class UBFGActorStat_Float* GetDefaultObj()
	{
		return GetDefaultObjImpl<UBFGActorStat_Float>();
	}
};
static_assert(alignof(UBFGActorStat_Float) == 0x000008, "Wrong alignment on UBFGActorStat_Float");
static_assert(sizeof(UBFGActorStat_Float) == 0x0000A0, "Wrong size on UBFGActorStat_Float");
static_assert(offsetof(UBFGActorStat_Float, M_fMaxValue) == 0x000048, "Member 'UBFGActorStat_Float::M_fMaxValue' has a wrong offset!");
static_assert(offsetof(UBFGActorStat_Float, M_fMinValue) == 0x00004C, "Member 'UBFGActorStat_Float::M_fMinValue' has a wrong offset!");
static_assert(offsetof(UBFGActorStat_Float, M_fInitialValue) == 0x000050, "Member 'UBFGActorStat_Float::M_fInitialValue' has a wrong offset!");
static_assert(offsetof(UBFGActorStat_Float, M_fLastValue) == 0x000054, "Member 'UBFGActorStat_Float::M_fLastValue' has a wrong offset!");
static_assert(offsetof(UBFGActorStat_Float, M_fRegenrationRate) == 0x000058, "Member 'UBFGActorStat_Float::M_fRegenrationRate' has a wrong offset!");
static_assert(offsetof(UBFGActorStat_Float, M_fRegenrationRateOverride) == 0x00005C, "Member 'UBFGActorStat_Float::M_fRegenrationRateOverride' has a wrong offset!");
static_assert(offsetof(UBFGActorStat_Float, M_fRegenrationDelay) == 0x000060, "Member 'UBFGActorStat_Float::M_fRegenrationDelay' has a wrong offset!");
static_assert(offsetof(UBFGActorStat_Float, M_fRegenrationDelayOverride) == 0x000064, "Member 'UBFGActorStat_Float::M_fRegenrationDelayOverride' has a wrong offset!");
static_assert(offsetof(UBFGActorStat_Float, M_onChanged) == 0x000068, "Member 'UBFGActorStat_Float::M_onChanged' has a wrong offset!");
static_assert(offsetof(UBFGActorStat_Float, M_onRegernationChanged) == 0x000080, "Member 'UBFGActorStat_Float::M_onRegernationChanged' has a wrong offset!");
static_assert(offsetof(UBFGActorStat_Float, M_fValue) == 0x000098, "Member 'UBFGActorStat_Float::M_fValue' has a wrong offset!");
static_assert(offsetof(UBFGActorStat_Float, M_bRegenEnabled) == 0x00009C, "Member 'UBFGActorStat_Float::M_bRegenEnabled' has a wrong offset!");
static_assert(offsetof(UBFGActorStat_Float, M_bWasRegeneratingLastFrame) == 0x00009D, "Member 'UBFGActorStat_Float::M_bWasRegeneratingLastFrame' has a wrong offset!");
static_assert(offsetof(UBFGActorStat_Float, M_bIsRegenerating) == 0x00009E, "Member 'UBFGActorStat_Float::M_bIsRegenerating' has a wrong offset!");

// Class BFGCore.BFGActorSwimmingFish
// 0x00B0 (0x0488 - 0x03D8)
class ABFGActorSwimmingFish : public AActor
{
public:
	class UStaticMesh*                            M_pStaticMesh;                                     // 0x03D8(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UBoxComponent*                          M_pBoxVolume;                                      // 0x03E0(0x0008)(Edit, BlueprintVisible, ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	int32                                         M_iNumberOfActors;                                 // 0x03E8(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	int32                                         M_iPathDensity;                                    // 0x03EC(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         M_fActorsSpeed;                                    // 0x03F0(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         M_fSplineDencity;                                  // 0x03F4(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         M_fRandomness;                                     // 0x03F8(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         M_fCheckFrequency;                                 // 0x03FC(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         M_fSMeshRotationalMultiplier;                      // 0x0400(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         M_fWakeUpDistance;                                 // 0x0404(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UInstancedStaticMeshComponent*          M_pInstanceMeshComp;                               // 0x0408(0x0008)(ExportObject, ZeroConstructor, Transient, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_410[0x78];                                     // 0x0410(0x0078)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"BFGActorSwimmingFish">();
	}
	static class ABFGActorSwimmingFish* GetDefaultObj()
	{
		return GetDefaultObjImpl<ABFGActorSwimmingFish>();
	}
};
static_assert(alignof(ABFGActorSwimmingFish) == 0x000008, "Wrong alignment on ABFGActorSwimmingFish");
static_assert(sizeof(ABFGActorSwimmingFish) == 0x000488, "Wrong size on ABFGActorSwimmingFish");
static_assert(offsetof(ABFGActorSwimmingFish, M_pStaticMesh) == 0x0003D8, "Member 'ABFGActorSwimmingFish::M_pStaticMesh' has a wrong offset!");
static_assert(offsetof(ABFGActorSwimmingFish, M_pBoxVolume) == 0x0003E0, "Member 'ABFGActorSwimmingFish::M_pBoxVolume' has a wrong offset!");
static_assert(offsetof(ABFGActorSwimmingFish, M_iNumberOfActors) == 0x0003E8, "Member 'ABFGActorSwimmingFish::M_iNumberOfActors' has a wrong offset!");
static_assert(offsetof(ABFGActorSwimmingFish, M_iPathDensity) == 0x0003EC, "Member 'ABFGActorSwimmingFish::M_iPathDensity' has a wrong offset!");
static_assert(offsetof(ABFGActorSwimmingFish, M_fActorsSpeed) == 0x0003F0, "Member 'ABFGActorSwimmingFish::M_fActorsSpeed' has a wrong offset!");
static_assert(offsetof(ABFGActorSwimmingFish, M_fSplineDencity) == 0x0003F4, "Member 'ABFGActorSwimmingFish::M_fSplineDencity' has a wrong offset!");
static_assert(offsetof(ABFGActorSwimmingFish, M_fRandomness) == 0x0003F8, "Member 'ABFGActorSwimmingFish::M_fRandomness' has a wrong offset!");
static_assert(offsetof(ABFGActorSwimmingFish, M_fCheckFrequency) == 0x0003FC, "Member 'ABFGActorSwimmingFish::M_fCheckFrequency' has a wrong offset!");
static_assert(offsetof(ABFGActorSwimmingFish, M_fSMeshRotationalMultiplier) == 0x000400, "Member 'ABFGActorSwimmingFish::M_fSMeshRotationalMultiplier' has a wrong offset!");
static_assert(offsetof(ABFGActorSwimmingFish, M_fWakeUpDistance) == 0x000404, "Member 'ABFGActorSwimmingFish::M_fWakeUpDistance' has a wrong offset!");
static_assert(offsetof(ABFGActorSwimmingFish, M_pInstanceMeshComp) == 0x000408, "Member 'ABFGActorSwimmingFish::M_pInstanceMeshComp' has a wrong offset!");

// Class BFGCore.BFGAIController
// 0x0108 (0x0600 - 0x04F8)
class ABFGAIController : public AAIController
{
public:
	uint8                                         Pad_4F8[0x8];                                      // 0x04F8(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	UMulticastDelegateProperty_                   M_OnAIStateChanged;                                // 0x0500(0x0018)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	class FName                                   M_strBBKey_StatIsDead;                             // 0x0518(0x0008)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UBehaviorTree*                          M_pBehaviorTree;                                   // 0x0520(0x0008)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UBlackboardData*                        M_pBlackboardData;                                 // 0x0528(0x0008)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UBFGActorComponent_Alert*               M_pAlertComponent;                                 // 0x0530(0x0008)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, EditConst, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UBFGActorComponent_AIReactions*         M_pAIReactions;                                    // 0x0538(0x0008)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, EditConst, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UBFGActorComponent_DetectionHelper*     M_pDetectionHelper;                                // 0x0540(0x0008)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, EditConst, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          M_bInitBlackboard;                                 // 0x0548(0x0001)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          M_bRunningTree;                                    // 0x0549(0x0001)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          M_bCorrectBehaviorTreeSet;                         // 0x054A(0x0001)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          M_bIsPawnDead;                                     // 0x054B(0x0001)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	EBFGAIControllerState                         M_aiControllerState;                               // 0x054C(0x0001)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_54D[0x3];                                      // 0x054D(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	class UBFGNetworkPathAgent*                   M_pAgent;                                          // 0x0550(0x0008)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         M_fHibernatingTickInterval;                        // 0x0558(0x0004)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         M_fActorlessTickInterval;                          // 0x055C(0x0004)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         M_fSavedTickInterval;                              // 0x0560(0x0004)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_564[0x4];                                      // 0x0564(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	TMap<class FName, class UBFGActorStat*>       M_aBBStats;                                        // 0x0568(0x0050)(ExportObject, ZeroConstructor, Transient, ContainsInstancedReference, Protected, NativeAccessSpecifierProtected)
	class UBFG_AITask*                            M_pAITask;                                         // 0x05B8(0x0008)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UBFG_AITask*                            M_pPendingAITask;                                  // 0x05C0(0x0008)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UBFGActorComponent_PawnStats*           M_pPossessedPawnStats;                             // 0x05C8(0x0008)(ExportObject, ZeroConstructor, Transient, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_5D0[0x8];                                      // 0x05D0(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<struct FBFGBehaviorStateChangeRequest> M_aRequestedbehaviorStates;                        // 0x05D8(0x0010)(ZeroConstructor, Transient, Protected, NativeAccessSpecifierProtected)
	class FName                                   M_BBKey_AIState;                                   // 0x05E8(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class FName                                   M_BBKey_IsActorDisabled;                           // 0x05F0(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UBFGAICombatMediator*                   M_pCombatMediator;                                 // 0x05F8(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)

public:
	void Awake(class APawn* _pPawn);
	void Hibernate(float _fInterval);
	void OnBehaviorTreeStarted(class UBehaviorTree* _pBehaviorTree);
	void OnBoolStatChanged(class AActor* _pActor, class UBFGActorStat_Bool* _pStat);
	void OnDeathStateChanged(class AActor* _pActor, class UBFGActorStat_Bool* _pStat);

	bool IsHibernating() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"BFGAIController">();
	}
	static class ABFGAIController* GetDefaultObj()
	{
		return GetDefaultObjImpl<ABFGAIController>();
	}
};
static_assert(alignof(ABFGAIController) == 0x000008, "Wrong alignment on ABFGAIController");
static_assert(sizeof(ABFGAIController) == 0x000600, "Wrong size on ABFGAIController");
static_assert(offsetof(ABFGAIController, M_OnAIStateChanged) == 0x000500, "Member 'ABFGAIController::M_OnAIStateChanged' has a wrong offset!");
static_assert(offsetof(ABFGAIController, M_strBBKey_StatIsDead) == 0x000518, "Member 'ABFGAIController::M_strBBKey_StatIsDead' has a wrong offset!");
static_assert(offsetof(ABFGAIController, M_pBehaviorTree) == 0x000520, "Member 'ABFGAIController::M_pBehaviorTree' has a wrong offset!");
static_assert(offsetof(ABFGAIController, M_pBlackboardData) == 0x000528, "Member 'ABFGAIController::M_pBlackboardData' has a wrong offset!");
static_assert(offsetof(ABFGAIController, M_pAlertComponent) == 0x000530, "Member 'ABFGAIController::M_pAlertComponent' has a wrong offset!");
static_assert(offsetof(ABFGAIController, M_pAIReactions) == 0x000538, "Member 'ABFGAIController::M_pAIReactions' has a wrong offset!");
static_assert(offsetof(ABFGAIController, M_pDetectionHelper) == 0x000540, "Member 'ABFGAIController::M_pDetectionHelper' has a wrong offset!");
static_assert(offsetof(ABFGAIController, M_bInitBlackboard) == 0x000548, "Member 'ABFGAIController::M_bInitBlackboard' has a wrong offset!");
static_assert(offsetof(ABFGAIController, M_bRunningTree) == 0x000549, "Member 'ABFGAIController::M_bRunningTree' has a wrong offset!");
static_assert(offsetof(ABFGAIController, M_bCorrectBehaviorTreeSet) == 0x00054A, "Member 'ABFGAIController::M_bCorrectBehaviorTreeSet' has a wrong offset!");
static_assert(offsetof(ABFGAIController, M_bIsPawnDead) == 0x00054B, "Member 'ABFGAIController::M_bIsPawnDead' has a wrong offset!");
static_assert(offsetof(ABFGAIController, M_aiControllerState) == 0x00054C, "Member 'ABFGAIController::M_aiControllerState' has a wrong offset!");
static_assert(offsetof(ABFGAIController, M_pAgent) == 0x000550, "Member 'ABFGAIController::M_pAgent' has a wrong offset!");
static_assert(offsetof(ABFGAIController, M_fHibernatingTickInterval) == 0x000558, "Member 'ABFGAIController::M_fHibernatingTickInterval' has a wrong offset!");
static_assert(offsetof(ABFGAIController, M_fActorlessTickInterval) == 0x00055C, "Member 'ABFGAIController::M_fActorlessTickInterval' has a wrong offset!");
static_assert(offsetof(ABFGAIController, M_fSavedTickInterval) == 0x000560, "Member 'ABFGAIController::M_fSavedTickInterval' has a wrong offset!");
static_assert(offsetof(ABFGAIController, M_aBBStats) == 0x000568, "Member 'ABFGAIController::M_aBBStats' has a wrong offset!");
static_assert(offsetof(ABFGAIController, M_pAITask) == 0x0005B8, "Member 'ABFGAIController::M_pAITask' has a wrong offset!");
static_assert(offsetof(ABFGAIController, M_pPendingAITask) == 0x0005C0, "Member 'ABFGAIController::M_pPendingAITask' has a wrong offset!");
static_assert(offsetof(ABFGAIController, M_pPossessedPawnStats) == 0x0005C8, "Member 'ABFGAIController::M_pPossessedPawnStats' has a wrong offset!");
static_assert(offsetof(ABFGAIController, M_aRequestedbehaviorStates) == 0x0005D8, "Member 'ABFGAIController::M_aRequestedbehaviorStates' has a wrong offset!");
static_assert(offsetof(ABFGAIController, M_BBKey_AIState) == 0x0005E8, "Member 'ABFGAIController::M_BBKey_AIState' has a wrong offset!");
static_assert(offsetof(ABFGAIController, M_BBKey_IsActorDisabled) == 0x0005F0, "Member 'ABFGAIController::M_BBKey_IsActorDisabled' has a wrong offset!");
static_assert(offsetof(ABFGAIController, M_pCombatMediator) == 0x0005F8, "Member 'ABFGAIController::M_pCombatMediator' has a wrong offset!");

// Class BFGCore.BFGNPCHumanController
// 0x0000 (0x0600 - 0x0600)
class ABFGNPCHumanController : public ABFGAIController
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"BFGNPCHumanController">();
	}
	static class ABFGNPCHumanController* GetDefaultObj()
	{
		return GetDefaultObjImpl<ABFGNPCHumanController>();
	}
};
static_assert(alignof(ABFGNPCHumanController) == 0x000008, "Wrong alignment on ABFGNPCHumanController");
static_assert(sizeof(ABFGNPCHumanController) == 0x000600, "Wrong size on ABFGNPCHumanController");

// Class BFGCore.BFGTrafficLodManager
// 0x0028 (0x0050 - 0x0028)
class UBFGTrafficLodManager final : public UObject
{
public:
	class UBFGTrafficCrowdManager*                M_pTrafficCrowdManager;                            // 0x0028(0x0008)(ExportObject, ZeroConstructor, Transient, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_30[0x20];                                      // 0x0030(0x0020)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"BFGTrafficLodManager">();
	}
	static class UBFGTrafficLodManager* GetDefaultObj()
	{
		return GetDefaultObjImpl<UBFGTrafficLodManager>();
	}
};
static_assert(alignof(UBFGTrafficLodManager) == 0x000008, "Wrong alignment on UBFGTrafficLodManager");
static_assert(sizeof(UBFGTrafficLodManager) == 0x000050, "Wrong size on UBFGTrafficLodManager");
static_assert(offsetof(UBFGTrafficLodManager, M_pTrafficCrowdManager) == 0x000028, "Member 'UBFGTrafficLodManager::M_pTrafficCrowdManager' has a wrong offset!");

// Class BFGCore.BFGCortexScanOverrideRule
// 0x0000 (0x0028 - 0x0028)
class UBFGCortexScanOverrideRule : public UObject
{
public:
	bool AppliesToTarget(class AActor* _pTarget) const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"BFGCortexScanOverrideRule">();
	}
	static class UBFGCortexScanOverrideRule* GetDefaultObj()
	{
		return GetDefaultObjImpl<UBFGCortexScanOverrideRule>();
	}
};
static_assert(alignof(UBFGCortexScanOverrideRule) == 0x000008, "Wrong alignment on UBFGCortexScanOverrideRule");
static_assert(sizeof(UBFGCortexScanOverrideRule) == 0x000028, "Wrong size on UBFGCortexScanOverrideRule");

// Class BFGCore.BFGActorUtils
// 0x0000 (0x0028 - 0x0028)
class UBFGActorUtils final : public UBlueprintFunctionLibrary
{
public:
	static TArray<class AActor*> ActivateExplosionFromBP(class AActor* PSourceActor, const struct FVector& _atPosition, float _fRadius, float _fDamage, float _fDamageToPlayer, TSubclassOf<class UDamageType> M_pDamageType, float _fPhysicsImpulseStrength, bool _bTraceHitResults, bool _bCanDestroyEnvironment);
	static void ApplyImpulseToActor(class AActor* _pActor, const struct FVector& _vImpulseAgainstNPC, const struct FVector& _vImpulseAgainstPlayer);
	static float CalcSkeletalMeshFeetHeight(class USceneComponent* _pComponent);
	static struct FBFGWaterPlaneInfo CalculateActorWaterInfo(class AActor* _pActor);
	static EObjectWeightClass ComputeActorWeightClass(class AActor* _pActor);
	static void CopyCollisionResponseToChannel(ECollisionChannel _eChannel, const class UStaticMesh* _pSource, class UPrimitiveComponent* _pDestination);
	static void FindAllAttachedActors(TArray<class AActor*>* _apOutActors, class AActor* _pRootActor);
	static EBFGGameplayScaling GetCurrentGameplayScale(class UObject* _pWorldContextObject);
	static class FString GetLevelNameFromActor(class AActor* _pActor);
	static class UPrimitiveComponent* GetMeshFromActor(class AActor* _pActor);
	static float GetMonetaryValue(EObjectWeightClass _eWeightClass);
	static class ABFGPlayerBase* GetPlayerBaseObject(class UWorld* _pWorld);
	static class ABFGPlayerCharacter* GetPlayerCharacter(class UWorld* _pWorld);
	static class ABFGPlayerCharacter* GetPlayerCharacterFromWorldContext(const class UObject* WorldContextObject);
	static class ABFGPlayerUFO* GetPlayerUFO(class UWorld* _pWorld);
	static class ABFGPlayerUFO* GetPlayerUFOFromWorldContext(const class UObject* WorldContextObject);
	static class ABFGPlayerCharacter* GetPrimaryPlayerCharacter(const class UObject* WorldContextObject);
	static class APlayerController* GetPrimaryPlayerController(const class UObject* WorldContextObject);
	static class ABFGPlayerUFO* GetPrimaryPlayerUFO(const class UObject* WorldContextObject);
	static class FString GetStaticMeshSocketTagFromSocketName(class UStaticMeshComponent* _pComponent, class FName _socketName);
	static struct FVector GetTeleportLocationForCharacterCapsule(class AActor* _pActor, const struct FVector& _vVec);
	static EObjectWeightClass GetWeightClassFromActor(class AActor* _pActor);
	static class UWorld* GetWorldFromContextObjectSafe(const class UObject* _pWorldContextObject);
	static void ImpactEnvironmentObject(class AActor* _pTarget, const struct FVector& _vAtLocation, float _fPhysicsImpulseStrength);
	static bool IsPrespawningPoolPhase(class UObject* _pWorldContext);
	static TArray<class AActor*> ResolveBindingArray(class UObject* _pWorldContextObject, const struct FBFGActorBinding& _binding);
	static class AActor* ResolveBindingSingle(class UObject* _pWorldContextObject, const struct FBFGActorBinding& _binding);
	static void ReturnActorToPool(class AActor* _pActor);
	static struct FVector TraceNavLocationToPhysicalGround(class UObject* WorldContextObject, const struct FVector& VInNavLocation);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"BFGActorUtils">();
	}
	static class UBFGActorUtils* GetDefaultObj()
	{
		return GetDefaultObjImpl<UBFGActorUtils>();
	}
};
static_assert(alignof(UBFGActorUtils) == 0x000008, "Wrong alignment on UBFGActorUtils");
static_assert(sizeof(UBFGActorUtils) == 0x000028, "Wrong size on UBFGActorUtils");

// Class BFGCore.BFGActorWithTags
// 0x0028 (0x0400 - 0x03D8)
class ABFGActorWithTags final : public AActor
{
public:
	uint8                                         Pad_3D8[0x8];                                      // 0x03D8(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	struct FGameplayTagContainer                  M_gameplayTags;                                    // 0x03E0(0x0020)(Edit, BlueprintVisible, BlueprintReadOnly, Protected, NativeAccessSpecifierProtected)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"BFGActorWithTags">();
	}
	static class ABFGActorWithTags* GetDefaultObj()
	{
		return GetDefaultObjImpl<ABFGActorWithTags>();
	}
};
static_assert(alignof(ABFGActorWithTags) == 0x000008, "Wrong alignment on ABFGActorWithTags");
static_assert(sizeof(ABFGActorWithTags) == 0x000400, "Wrong size on ABFGActorWithTags");
static_assert(offsetof(ABFGActorWithTags, M_gameplayTags) == 0x0003E0, "Member 'ABFGActorWithTags::M_gameplayTags' has a wrong offset!");

// Class BFGCore.BFGAIAlertEventConstraint
// 0x0000 (0x0028 - 0x0028)
class IBFGAIAlertEventConstraint final : public IInterface
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"BFGAIAlertEventConstraint">();
	}
	static class IBFGAIAlertEventConstraint* GetDefaultObj()
	{
		return GetDefaultObjImpl<IBFGAIAlertEventConstraint>();
	}
};
static_assert(alignof(IBFGAIAlertEventConstraint) == 0x000008, "Wrong alignment on IBFGAIAlertEventConstraint");
static_assert(sizeof(IBFGAIAlertEventConstraint) == 0x000028, "Wrong size on IBFGAIAlertEventConstraint");

// Class BFGCore.BFGMothershipSubstate
// 0x00A8 (0x00D0 - 0x0028)
class UBFGMothershipSubstate : public UObject
{
public:
	TSoftClassPtr<class UClass>                   M_pMenuClass;                                      // 0x0028(0x0028)(Edit, BlueprintVisible, BlueprintReadOnly, DisableEditOnInstance, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FText                                   M_oCustomButtonTextAccept;                         // 0x0050(0x0018)(Edit, DisableEditOnInstance, Protected, NativeAccessSpecifierProtected)
	class FText                                   M_oCustomButtonTextBack;                           // 0x0068(0x0018)(Edit, DisableEditOnInstance, Protected, NativeAccessSpecifierProtected)
	class FText                                   M_oCustomButtonTextOption1;                        // 0x0080(0x0018)(Edit, DisableEditOnInstance, Protected, NativeAccessSpecifierProtected)
	bool                                          M_bButtonAcceptEnabled;                            // 0x0098(0x0001)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          M_bButtonBackEnabled;                              // 0x0099(0x0001)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          M_bButtonOption1Enabled;                           // 0x009A(0x0001)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_9B[0x5];                                       // 0x009B(0x0005)(Fixing Size After Last Property [ Dumper-7 ])
	class FText                                   M_oCustomTitle;                                    // 0x00A0(0x0018)(Edit, DisableEditOnInstance, Protected, NativeAccessSpecifierProtected)
	class UBFGGameFlowState_Mothership_Main*      M_pParentState;                                    // 0x00B8(0x0008)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UBFGWidget_Mothership_Submenu*          M_pSubmenuWidget;                                  // 0x00C0(0x0008)(ExportObject, ZeroConstructor, Transient, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_C8[0x8];                                       // 0x00C8(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"BFGMothershipSubstate">();
	}
	static class UBFGMothershipSubstate* GetDefaultObj()
	{
		return GetDefaultObjImpl<UBFGMothershipSubstate>();
	}
};
static_assert(alignof(UBFGMothershipSubstate) == 0x000008, "Wrong alignment on UBFGMothershipSubstate");
static_assert(sizeof(UBFGMothershipSubstate) == 0x0000D0, "Wrong size on UBFGMothershipSubstate");
static_assert(offsetof(UBFGMothershipSubstate, M_pMenuClass) == 0x000028, "Member 'UBFGMothershipSubstate::M_pMenuClass' has a wrong offset!");
static_assert(offsetof(UBFGMothershipSubstate, M_oCustomButtonTextAccept) == 0x000050, "Member 'UBFGMothershipSubstate::M_oCustomButtonTextAccept' has a wrong offset!");
static_assert(offsetof(UBFGMothershipSubstate, M_oCustomButtonTextBack) == 0x000068, "Member 'UBFGMothershipSubstate::M_oCustomButtonTextBack' has a wrong offset!");
static_assert(offsetof(UBFGMothershipSubstate, M_oCustomButtonTextOption1) == 0x000080, "Member 'UBFGMothershipSubstate::M_oCustomButtonTextOption1' has a wrong offset!");
static_assert(offsetof(UBFGMothershipSubstate, M_bButtonAcceptEnabled) == 0x000098, "Member 'UBFGMothershipSubstate::M_bButtonAcceptEnabled' has a wrong offset!");
static_assert(offsetof(UBFGMothershipSubstate, M_bButtonBackEnabled) == 0x000099, "Member 'UBFGMothershipSubstate::M_bButtonBackEnabled' has a wrong offset!");
static_assert(offsetof(UBFGMothershipSubstate, M_bButtonOption1Enabled) == 0x00009A, "Member 'UBFGMothershipSubstate::M_bButtonOption1Enabled' has a wrong offset!");
static_assert(offsetof(UBFGMothershipSubstate, M_oCustomTitle) == 0x0000A0, "Member 'UBFGMothershipSubstate::M_oCustomTitle' has a wrong offset!");
static_assert(offsetof(UBFGMothershipSubstate, M_pParentState) == 0x0000B8, "Member 'UBFGMothershipSubstate::M_pParentState' has a wrong offset!");
static_assert(offsetof(UBFGMothershipSubstate, M_pSubmenuWidget) == 0x0000C0, "Member 'UBFGMothershipSubstate::M_pSubmenuWidget' has a wrong offset!");

// Class BFGCore.BFGMothershipSubstate_MissionSelection
// 0x0008 (0x00D8 - 0x00D0)
class UBFGMothershipSubstate_MissionSelection final : public UBFGMothershipSubstate
{
public:
	uint8                                         Pad_D0[0x8];                                       // 0x00D0(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void OnMissionAccepted(struct FBFGMissionSelectionInfo* _pInfo);
	void OnSandboxStart(struct FBFGMissionSelectionInfo* _pInfo);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"BFGMothershipSubstate_MissionSelection">();
	}
	static class UBFGMothershipSubstate_MissionSelection* GetDefaultObj()
	{
		return GetDefaultObjImpl<UBFGMothershipSubstate_MissionSelection>();
	}
};
static_assert(alignof(UBFGMothershipSubstate_MissionSelection) == 0x000008, "Wrong alignment on UBFGMothershipSubstate_MissionSelection");
static_assert(sizeof(UBFGMothershipSubstate_MissionSelection) == 0x0000D8, "Wrong size on UBFGMothershipSubstate_MissionSelection");

// Class BFGCore.BFGAICombatMediator
// 0x0050 (0x0078 - 0x0028)
class UBFGAICombatMediator final : public UObject
{
public:
	class ABFGGameState*                          M_pGameState;                                      // 0x0028(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UBFG_AISettings*                        M_pSettings;                                       // 0x0030(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UBFGAISystem*                           M_pAISystem;                                       // 0x0038(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UBFGAICombatMediator_WeaponCooldowns*   M_pWeaponCooldowns;                                // 0x0040(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UBFGAICombatMediator_GlobalCooldowns*   M_pGlobalCooldowns;                                // 0x0048(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UBFGAICombatMediator_NPCRegistry*       M_pCombatNPCRegistry;                              // 0x0050(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UBFGAICombatMediator_TargetTracker*     M_pTargetTracker;                                  // 0x0058(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	TArray<class UObject*>                        M_apCombatLockers;                                 // 0x0060(0x0010)(ZeroConstructor, NativeAccessSpecifierPrivate)
	EBFGCombatLock                                M_eCombatLock;                                     // 0x0070(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_71[0x7];                                       // 0x0071(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static float GetDistanceToFirelineSquared(const struct FVector& _vFromLocation, const struct FVector& _vShooterLocation, const struct FVector& _vTargetLocation);

	class UBFGAICombatMediator_TargetTracker* GetTargetTracker();

	TScriptInterface<class IBFGAICombatParticipant> GetClosestAttackingNPC(const struct FVector& _vFromLocation, class AActor* _pAttackTarget, TScriptInterface<class IBFGAICombatParticipant> _pExcludedPawn) const;
	TScriptInterface<class IBFGAICombatParticipant> GetClosestNPCForTargetsAndStates(const struct FVector& _vFromLocation, const TArray<class AActor*>& _apTargets, const TArray<EBFGCombatState_NPC>& _aCombatStates) const;
	TScriptInterface<class IBFGAICombatParticipant> GetClosestParticipant(const struct FVector& _vFromLocation, struct FVector* _vOutIntendedLocation, class APawn* _pExcludedPawn) const;
	EBFGCombatState_NPC GetCombatState(class AActor* _pAttackTarget, TScriptInterface<class IBFGAICombatParticipant> _pParticipant) const;
	float GetDistanceToClosestFireline(const struct FVector& _vFromLocation, class APawn* _pExcludedPawn) const;
	float GetDistanceToClosestParticipant(const struct FVector& _vFromLocation, class APawn* _pExcludedPawn) const;
	float GetDistanceToParticipant(const struct FVector& _vFromLocation, TScriptInterface<class IBFGAICombatParticipant> _pParticipant) const;
	bool IsTargeted(class AActor* _pAttackTarget) const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"BFGAICombatMediator">();
	}
	static class UBFGAICombatMediator* GetDefaultObj()
	{
		return GetDefaultObjImpl<UBFGAICombatMediator>();
	}
};
static_assert(alignof(UBFGAICombatMediator) == 0x000008, "Wrong alignment on UBFGAICombatMediator");
static_assert(sizeof(UBFGAICombatMediator) == 0x000078, "Wrong size on UBFGAICombatMediator");
static_assert(offsetof(UBFGAICombatMediator, M_pGameState) == 0x000028, "Member 'UBFGAICombatMediator::M_pGameState' has a wrong offset!");
static_assert(offsetof(UBFGAICombatMediator, M_pSettings) == 0x000030, "Member 'UBFGAICombatMediator::M_pSettings' has a wrong offset!");
static_assert(offsetof(UBFGAICombatMediator, M_pAISystem) == 0x000038, "Member 'UBFGAICombatMediator::M_pAISystem' has a wrong offset!");
static_assert(offsetof(UBFGAICombatMediator, M_pWeaponCooldowns) == 0x000040, "Member 'UBFGAICombatMediator::M_pWeaponCooldowns' has a wrong offset!");
static_assert(offsetof(UBFGAICombatMediator, M_pGlobalCooldowns) == 0x000048, "Member 'UBFGAICombatMediator::M_pGlobalCooldowns' has a wrong offset!");
static_assert(offsetof(UBFGAICombatMediator, M_pCombatNPCRegistry) == 0x000050, "Member 'UBFGAICombatMediator::M_pCombatNPCRegistry' has a wrong offset!");
static_assert(offsetof(UBFGAICombatMediator, M_pTargetTracker) == 0x000058, "Member 'UBFGAICombatMediator::M_pTargetTracker' has a wrong offset!");
static_assert(offsetof(UBFGAICombatMediator, M_apCombatLockers) == 0x000060, "Member 'UBFGAICombatMediator::M_apCombatLockers' has a wrong offset!");
static_assert(offsetof(UBFGAICombatMediator, M_eCombatLock) == 0x000070, "Member 'UBFGAICombatMediator::M_eCombatLock' has a wrong offset!");

// Class BFGCore.BFGBurningGround
// 0x0028 (0x0408 - 0x03E0)
class ABFGBurningGround : public ATriggerBox
{
public:
	struct FVector                                M_vBoundsMin;                                      // 0x03E0(0x000C)(Edit, BlueprintVisible, ZeroConstructor, Transient, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                M_vBoundsExtent;                                   // 0x03EC(0x000C)(Edit, BlueprintVisible, ZeroConstructor, Transient, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         M_iRenderTargetWidth;                              // 0x03F8(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         M_iRenderTargetHeight;                             // 0x03FC(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector2D                              M_vRenderTargetSize;                               // 0x0400(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

public:
	class UBFGBurningGroundManager* GetManager();

	struct FVector2D ConvertWorldToRenderTarget(const struct FVector& _vWorldPos) const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"BFGBurningGround">();
	}
	static class ABFGBurningGround* GetDefaultObj()
	{
		return GetDefaultObjImpl<ABFGBurningGround>();
	}
};
static_assert(alignof(ABFGBurningGround) == 0x000008, "Wrong alignment on ABFGBurningGround");
static_assert(sizeof(ABFGBurningGround) == 0x000408, "Wrong size on ABFGBurningGround");
static_assert(offsetof(ABFGBurningGround, M_vBoundsMin) == 0x0003E0, "Member 'ABFGBurningGround::M_vBoundsMin' has a wrong offset!");
static_assert(offsetof(ABFGBurningGround, M_vBoundsExtent) == 0x0003EC, "Member 'ABFGBurningGround::M_vBoundsExtent' has a wrong offset!");
static_assert(offsetof(ABFGBurningGround, M_iRenderTargetWidth) == 0x0003F8, "Member 'ABFGBurningGround::M_iRenderTargetWidth' has a wrong offset!");
static_assert(offsetof(ABFGBurningGround, M_iRenderTargetHeight) == 0x0003FC, "Member 'ABFGBurningGround::M_iRenderTargetHeight' has a wrong offset!");
static_assert(offsetof(ABFGBurningGround, M_vRenderTargetSize) == 0x000400, "Member 'ABFGBurningGround::M_vRenderTargetSize' has a wrong offset!");

// Class BFGCore.BFGWidget_Mothership_Submenu
// 0x0088 (0x02C8 - 0x0240)
class UBFGWidget_Mothership_Submenu : public UUserWidget
{
public:
	class UBFGWidget_GenericDialog*               M_pParent;                                         // 0x0240(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	UMulticastDelegateProperty_                   M_OnMenuContextChanged;                            // 0x0248(0x0018)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	uint8                                         Pad_260[0x68];                                     // 0x0260(0x0068)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void Accept();
	void ActionMenuContext__DelegateSignature(const TArray<struct FBFGTreeMenuContext>& _aMenuContextPath);
	void OnDisabledInternal();
	void OnEnabledInternal();
	void PlayAnimationHide(float _fPlaybackSpeed);
	void PlayAnimationShow(float _fPlaybackSpeed);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"BFGWidget_Mothership_Submenu">();
	}
	static class UBFGWidget_Mothership_Submenu* GetDefaultObj()
	{
		return GetDefaultObjImpl<UBFGWidget_Mothership_Submenu>();
	}
};
static_assert(alignof(UBFGWidget_Mothership_Submenu) == 0x000008, "Wrong alignment on UBFGWidget_Mothership_Submenu");
static_assert(sizeof(UBFGWidget_Mothership_Submenu) == 0x0002C8, "Wrong size on UBFGWidget_Mothership_Submenu");
static_assert(offsetof(UBFGWidget_Mothership_Submenu, M_pParent) == 0x000240, "Member 'UBFGWidget_Mothership_Submenu::M_pParent' has a wrong offset!");
static_assert(offsetof(UBFGWidget_Mothership_Submenu, M_OnMenuContextChanged) == 0x000248, "Member 'UBFGWidget_Mothership_Submenu::M_OnMenuContextChanged' has a wrong offset!");

// Class BFGCore.BFGWidget_Mothership_MissionSelect
// 0x0078 (0x0340 - 0x02C8)
class UBFGWidget_Mothership_MissionSelect final : public UBFGWidget_Mothership_Submenu
{
public:
	uint8                                         Pad_2C8[0x30];                                     // 0x02C8(0x0030)(Fixing Size After Last Property [ Dumper-7 ])
	bool                                          M_bWasPreConstructed;                              // 0x02F8(0x0001)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2F9[0x7];                                      // 0x02F9(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<class UBFGWidgetMissionSelectionNode*> M_apSelectionNodes;                                // 0x0300(0x0010)(ExportObject, ZeroConstructor, ContainsInstancedReference, Protected, NativeAccessSpecifierProtected)
	uint8                                         Pad_310[0x10];                                     // 0x0310(0x0010)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<struct FBFGMissionSelectionInfo>       M_aoSelectionInfo;                                 // 0x0320(0x0010)(ZeroConstructor, Protected, NativeAccessSpecifierProtected)
	uint8                                         Pad_330[0x8];                                      // 0x0330(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         M_fWeight;                                         // 0x0338(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          M_bShowAllMaps;                                    // 0x033C(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_33D[0x3];                                      // 0x033D(0x0003)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void EnableExploreInfo(bool _bEnabled);
	class UBFGWidgetMissionSelectionNode* GetNodeByWorldIdentifier(class FName _oWorldName);
	void OnNodeClicked(class UBFGWidgetMissionSelectionNode* _pNode);
	void OnNodeDoubleClicked(class UBFGWidgetMissionSelectionNode* _pNode);
	void OnSFX_NodeSelected();
	void SetChallengeDisabled(EBFGChallengeType _eType, bool _bDisabled);
	void SetChallengeRating(EBFGChallengeType _eType, int32 _iRating);
	void SetDroneCount(int32 _iMax, int32 _iCurrent);
	void SwitchToNewMissionStyle();
	void SwitchToSandboxStyle();
	void UpdateDescription(const class FText& _oDescription);
	void UpdateImage(const struct FSlateBrush& _oImage);
	void UpdateTitle(const class FText& _oTitle);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"BFGWidget_Mothership_MissionSelect">();
	}
	static class UBFGWidget_Mothership_MissionSelect* GetDefaultObj()
	{
		return GetDefaultObjImpl<UBFGWidget_Mothership_MissionSelect>();
	}
};
static_assert(alignof(UBFGWidget_Mothership_MissionSelect) == 0x000008, "Wrong alignment on UBFGWidget_Mothership_MissionSelect");
static_assert(sizeof(UBFGWidget_Mothership_MissionSelect) == 0x000340, "Wrong size on UBFGWidget_Mothership_MissionSelect");
static_assert(offsetof(UBFGWidget_Mothership_MissionSelect, M_bWasPreConstructed) == 0x0002F8, "Member 'UBFGWidget_Mothership_MissionSelect::M_bWasPreConstructed' has a wrong offset!");
static_assert(offsetof(UBFGWidget_Mothership_MissionSelect, M_apSelectionNodes) == 0x000300, "Member 'UBFGWidget_Mothership_MissionSelect::M_apSelectionNodes' has a wrong offset!");
static_assert(offsetof(UBFGWidget_Mothership_MissionSelect, M_aoSelectionInfo) == 0x000320, "Member 'UBFGWidget_Mothership_MissionSelect::M_aoSelectionInfo' has a wrong offset!");
static_assert(offsetof(UBFGWidget_Mothership_MissionSelect, M_fWeight) == 0x000338, "Member 'UBFGWidget_Mothership_MissionSelect::M_fWeight' has a wrong offset!");
static_assert(offsetof(UBFGWidget_Mothership_MissionSelect, M_bShowAllMaps) == 0x00033C, "Member 'UBFGWidget_Mothership_MissionSelect::M_bShowAllMaps' has a wrong offset!");

// Class BFGCore.BFGAICombatMediator_GlobalCooldowns
// 0x0018 (0x0040 - 0x0028)
class UBFGAICombatMediator_GlobalCooldowns final : public UObject
{
public:
	class UBFGAISystem*                           M_pAISystem;                                       // 0x0028(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	TArray<struct FBFGAIGlobalCooldown>           M_aCooldowns;                                      // 0x0030(0x0010)(ZeroConstructor, NativeAccessSpecifierPrivate)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"BFGAICombatMediator_GlobalCooldowns">();
	}
	static class UBFGAICombatMediator_GlobalCooldowns* GetDefaultObj()
	{
		return GetDefaultObjImpl<UBFGAICombatMediator_GlobalCooldowns>();
	}
};
static_assert(alignof(UBFGAICombatMediator_GlobalCooldowns) == 0x000008, "Wrong alignment on UBFGAICombatMediator_GlobalCooldowns");
static_assert(sizeof(UBFGAICombatMediator_GlobalCooldowns) == 0x000040, "Wrong size on UBFGAICombatMediator_GlobalCooldowns");
static_assert(offsetof(UBFGAICombatMediator_GlobalCooldowns, M_pAISystem) == 0x000028, "Member 'UBFGAICombatMediator_GlobalCooldowns::M_pAISystem' has a wrong offset!");
static_assert(offsetof(UBFGAICombatMediator_GlobalCooldowns, M_aCooldowns) == 0x000030, "Member 'UBFGAICombatMediator_GlobalCooldowns::M_aCooldowns' has a wrong offset!");

// Class BFGCore.BFGAICombatMediator_NPCRegistry
// 0x0070 (0x0098 - 0x0028)
class UBFGAICombatMediator_NPCRegistry final : public UObject
{
public:
	TMap<class UObject*, struct FBFGAICombatRegistryData> M_aNPCs;                                           // 0x0028(0x0050)(ZeroConstructor, NativeAccessSpecifierPrivate)
	class ABFGGameState*                          M_pGameState;                                      // 0x0078(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UBFGAISystem*                           M_pAISystem;                                       // 0x0080(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UBFG_AISettings*                        M_pSettings;                                       // 0x0088(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UBFGAICombatMediator_TargetTracker*     M_pTargetTracker;                                  // 0x0090(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"BFGAICombatMediator_NPCRegistry">();
	}
	static class UBFGAICombatMediator_NPCRegistry* GetDefaultObj()
	{
		return GetDefaultObjImpl<UBFGAICombatMediator_NPCRegistry>();
	}
};
static_assert(alignof(UBFGAICombatMediator_NPCRegistry) == 0x000008, "Wrong alignment on UBFGAICombatMediator_NPCRegistry");
static_assert(sizeof(UBFGAICombatMediator_NPCRegistry) == 0x000098, "Wrong size on UBFGAICombatMediator_NPCRegistry");
static_assert(offsetof(UBFGAICombatMediator_NPCRegistry, M_aNPCs) == 0x000028, "Member 'UBFGAICombatMediator_NPCRegistry::M_aNPCs' has a wrong offset!");
static_assert(offsetof(UBFGAICombatMediator_NPCRegistry, M_pGameState) == 0x000078, "Member 'UBFGAICombatMediator_NPCRegistry::M_pGameState' has a wrong offset!");
static_assert(offsetof(UBFGAICombatMediator_NPCRegistry, M_pAISystem) == 0x000080, "Member 'UBFGAICombatMediator_NPCRegistry::M_pAISystem' has a wrong offset!");
static_assert(offsetof(UBFGAICombatMediator_NPCRegistry, M_pSettings) == 0x000088, "Member 'UBFGAICombatMediator_NPCRegistry::M_pSettings' has a wrong offset!");
static_assert(offsetof(UBFGAICombatMediator_NPCRegistry, M_pTargetTracker) == 0x000090, "Member 'UBFGAICombatMediator_NPCRegistry::M_pTargetTracker' has a wrong offset!");

// Class BFGCore.BFGWidget_SelectorItem
// 0x00A8 (0x02E8 - 0x0240)
class UBFGWidget_SelectorItem final : public UUserWidget
{
public:
	uint8                                         Pad_240[0xA8];                                     // 0x0240(0x00A8)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void ActionInt__DelegateSignature(int32 _iInteger);
	class UImage* GetElementImage();
	void OnButtonPressed();
	void SetSelected(bool _bSelected);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"BFGWidget_SelectorItem">();
	}
	static class UBFGWidget_SelectorItem* GetDefaultObj()
	{
		return GetDefaultObjImpl<UBFGWidget_SelectorItem>();
	}
};
static_assert(alignof(UBFGWidget_SelectorItem) == 0x000008, "Wrong alignment on UBFGWidget_SelectorItem");
static_assert(sizeof(UBFGWidget_SelectorItem) == 0x0002E8, "Wrong size on UBFGWidget_SelectorItem");

// Class BFGCore.BFGAICombatMediator_TargetTracker
// 0x0090 (0x00B8 - 0x0028)
class UBFGAICombatMediator_TargetTracker final : public UObject
{
public:
	TMap<class AActor*, struct FBFGTargetTrackerData> M_aData;                                           // 0x0028(0x0050)(ZeroConstructor, Transient, NativeAccessSpecifierPrivate)
	class ABFGGameState*                          M_pGameState;                                      // 0x0078(0x0008)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	TArray<struct FBFGTargetTracker_CachedLocations> M_aCachedLocations;                                // 0x0080(0x0010)(ZeroConstructor, Transient, NativeAccessSpecifierPrivate)
	class UBFGAICombatMediator_NPCRegistry*       M_pNPCRegistry;                                    // 0x0090(0x0008)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_98[0x8];                                       // 0x0098(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	class UBFGTrafficCrowdManager*                M_pTrafficCrowdManager;                            // 0x00A0(0x0008)(ExportObject, ZeroConstructor, Transient, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UBFGAICombatMediator*                   M_pCombatMediator;                                 // 0x00A8(0x0008)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_B0[0x8];                                       // 0x00B0(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void OnObstaclePlaced(class ABFGDynamicObstacle_Sphere* _pSphere);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"BFGAICombatMediator_TargetTracker">();
	}
	static class UBFGAICombatMediator_TargetTracker* GetDefaultObj()
	{
		return GetDefaultObjImpl<UBFGAICombatMediator_TargetTracker>();
	}
};
static_assert(alignof(UBFGAICombatMediator_TargetTracker) == 0x000008, "Wrong alignment on UBFGAICombatMediator_TargetTracker");
static_assert(sizeof(UBFGAICombatMediator_TargetTracker) == 0x0000B8, "Wrong size on UBFGAICombatMediator_TargetTracker");
static_assert(offsetof(UBFGAICombatMediator_TargetTracker, M_aData) == 0x000028, "Member 'UBFGAICombatMediator_TargetTracker::M_aData' has a wrong offset!");
static_assert(offsetof(UBFGAICombatMediator_TargetTracker, M_pGameState) == 0x000078, "Member 'UBFGAICombatMediator_TargetTracker::M_pGameState' has a wrong offset!");
static_assert(offsetof(UBFGAICombatMediator_TargetTracker, M_aCachedLocations) == 0x000080, "Member 'UBFGAICombatMediator_TargetTracker::M_aCachedLocations' has a wrong offset!");
static_assert(offsetof(UBFGAICombatMediator_TargetTracker, M_pNPCRegistry) == 0x000090, "Member 'UBFGAICombatMediator_TargetTracker::M_pNPCRegistry' has a wrong offset!");
static_assert(offsetof(UBFGAICombatMediator_TargetTracker, M_pTrafficCrowdManager) == 0x0000A0, "Member 'UBFGAICombatMediator_TargetTracker::M_pTrafficCrowdManager' has a wrong offset!");
static_assert(offsetof(UBFGAICombatMediator_TargetTracker, M_pCombatMediator) == 0x0000A8, "Member 'UBFGAICombatMediator_TargetTracker::M_pCombatMediator' has a wrong offset!");

// Class BFGCore.BFGAICombatMediator_WeaponCooldowns
// 0x0068 (0x0090 - 0x0028)
class UBFGAICombatMediator_WeaponCooldowns final : public UObject
{
public:
	class UBFGAICombatMediator*                   M_pMediator;                                       // 0x0028(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UBFGAISystem*                           M_pAISystem;                                       // 0x0030(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UBFG_AISettings*                        M_pSettings;                                       // 0x0038(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	TMap<class ABFGWeapon*, struct FBFGAIWeaponCooldown> M_aCooldowns;                                      // 0x0040(0x0050)(ZeroConstructor, NativeAccessSpecifierPrivate)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"BFGAICombatMediator_WeaponCooldowns">();
	}
	static class UBFGAICombatMediator_WeaponCooldowns* GetDefaultObj()
	{
		return GetDefaultObjImpl<UBFGAICombatMediator_WeaponCooldowns>();
	}
};
static_assert(alignof(UBFGAICombatMediator_WeaponCooldowns) == 0x000008, "Wrong alignment on UBFGAICombatMediator_WeaponCooldowns");
static_assert(sizeof(UBFGAICombatMediator_WeaponCooldowns) == 0x000090, "Wrong size on UBFGAICombatMediator_WeaponCooldowns");
static_assert(offsetof(UBFGAICombatMediator_WeaponCooldowns, M_pMediator) == 0x000028, "Member 'UBFGAICombatMediator_WeaponCooldowns::M_pMediator' has a wrong offset!");
static_assert(offsetof(UBFGAICombatMediator_WeaponCooldowns, M_pAISystem) == 0x000030, "Member 'UBFGAICombatMediator_WeaponCooldowns::M_pAISystem' has a wrong offset!");
static_assert(offsetof(UBFGAICombatMediator_WeaponCooldowns, M_pSettings) == 0x000038, "Member 'UBFGAICombatMediator_WeaponCooldowns::M_pSettings' has a wrong offset!");
static_assert(offsetof(UBFGAICombatMediator_WeaponCooldowns, M_aCooldowns) == 0x000040, "Member 'UBFGAICombatMediator_WeaponCooldowns::M_aCooldowns' has a wrong offset!");

// Class BFGCore.BFGNetworkPathAgent_AIStatePatrol
// 0x0040 (0x0098 - 0x0058)
class UBFGNetworkPathAgent_AIStatePatrol final : public UBFGNetworkPathAgent_AIStateBase
{
public:
	EBFGAIPatrolState                             M_eState;                                          // 0x0058(0x0001)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_59[0x7];                                       // 0x0059(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	class UBFGNetworkPath*                        M_pPath;                                           // 0x0060(0x0008)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	int32                                         M_iCurrentInterestPoint;                           // 0x0068(0x0004)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	int32                                         M_iLastInterestPoint;                              // 0x006C(0x0004)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         M_fInterestPointLocationOnSpline;                  // 0x0070(0x0004)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	struct FVector                                M_vInterestPointChachedLocation;                   // 0x0074(0x000C)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	struct FVector                                M_vInterestPointChachedPointingDirection;          // 0x0080(0x000C)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         M_fInterestPointTimer;                             // 0x008C(0x0004)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	EBFGNetworkPathExtremity                      M_eLastTargetExtremity;                            // 0x0090(0x0001)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_91[0x7];                                       // 0x0091(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"BFGNetworkPathAgent_AIStatePatrol">();
	}
	static class UBFGNetworkPathAgent_AIStatePatrol* GetDefaultObj()
	{
		return GetDefaultObjImpl<UBFGNetworkPathAgent_AIStatePatrol>();
	}
};
static_assert(alignof(UBFGNetworkPathAgent_AIStatePatrol) == 0x000008, "Wrong alignment on UBFGNetworkPathAgent_AIStatePatrol");
static_assert(sizeof(UBFGNetworkPathAgent_AIStatePatrol) == 0x000098, "Wrong size on UBFGNetworkPathAgent_AIStatePatrol");
static_assert(offsetof(UBFGNetworkPathAgent_AIStatePatrol, M_eState) == 0x000058, "Member 'UBFGNetworkPathAgent_AIStatePatrol::M_eState' has a wrong offset!");
static_assert(offsetof(UBFGNetworkPathAgent_AIStatePatrol, M_pPath) == 0x000060, "Member 'UBFGNetworkPathAgent_AIStatePatrol::M_pPath' has a wrong offset!");
static_assert(offsetof(UBFGNetworkPathAgent_AIStatePatrol, M_iCurrentInterestPoint) == 0x000068, "Member 'UBFGNetworkPathAgent_AIStatePatrol::M_iCurrentInterestPoint' has a wrong offset!");
static_assert(offsetof(UBFGNetworkPathAgent_AIStatePatrol, M_iLastInterestPoint) == 0x00006C, "Member 'UBFGNetworkPathAgent_AIStatePatrol::M_iLastInterestPoint' has a wrong offset!");
static_assert(offsetof(UBFGNetworkPathAgent_AIStatePatrol, M_fInterestPointLocationOnSpline) == 0x000070, "Member 'UBFGNetworkPathAgent_AIStatePatrol::M_fInterestPointLocationOnSpline' has a wrong offset!");
static_assert(offsetof(UBFGNetworkPathAgent_AIStatePatrol, M_vInterestPointChachedLocation) == 0x000074, "Member 'UBFGNetworkPathAgent_AIStatePatrol::M_vInterestPointChachedLocation' has a wrong offset!");
static_assert(offsetof(UBFGNetworkPathAgent_AIStatePatrol, M_vInterestPointChachedPointingDirection) == 0x000080, "Member 'UBFGNetworkPathAgent_AIStatePatrol::M_vInterestPointChachedPointingDirection' has a wrong offset!");
static_assert(offsetof(UBFGNetworkPathAgent_AIStatePatrol, M_fInterestPointTimer) == 0x00008C, "Member 'UBFGNetworkPathAgent_AIStatePatrol::M_fInterestPointTimer' has a wrong offset!");
static_assert(offsetof(UBFGNetworkPathAgent_AIStatePatrol, M_eLastTargetExtremity) == 0x000090, "Member 'UBFGNetworkPathAgent_AIStatePatrol::M_eLastTargetExtremity' has a wrong offset!");

// Class BFGCore.BFGTaskNode_CivilianFlee
// 0x0090 (0x0100 - 0x0070)
class UBFGTaskNode_CivilianFlee final : public UBTTaskNode
{
public:
	class UEnvQuery*                              M_pHideQuery;                                      // 0x0070(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	struct FEnvQueryRequest                       M_queryRequest;                                    // 0x0078(0x0068)(Transient, Protected, NativeAccessSpecifierProtected)
	bool                                          M_bIsWaitingHideEQSResult;                         // 0x00E0(0x0001)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          M_bHasHideLocation;                                // 0x00E1(0x0001)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          M_bMovingToTargetLocation;                         // 0x00E2(0x0001)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_E3[0x1];                                       // 0x00E3(0x0001)(Fixing Size After Last Property [ Dumper-7 ])
	struct FVector                                M_vHideLocation;                                   // 0x00E4(0x000C)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class AAIController*                          M_pController;                                     // 0x00F0(0x0008)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         M_fFleeTimeOut;                                    // 0x00F8(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         M_fCurrentFleeTime;                                // 0x00FC(0x0004)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"BFGTaskNode_CivilianFlee">();
	}
	static class UBFGTaskNode_CivilianFlee* GetDefaultObj()
	{
		return GetDefaultObjImpl<UBFGTaskNode_CivilianFlee>();
	}
};
static_assert(alignof(UBFGTaskNode_CivilianFlee) == 0x000008, "Wrong alignment on UBFGTaskNode_CivilianFlee");
static_assert(sizeof(UBFGTaskNode_CivilianFlee) == 0x000100, "Wrong size on UBFGTaskNode_CivilianFlee");
static_assert(offsetof(UBFGTaskNode_CivilianFlee, M_pHideQuery) == 0x000070, "Member 'UBFGTaskNode_CivilianFlee::M_pHideQuery' has a wrong offset!");
static_assert(offsetof(UBFGTaskNode_CivilianFlee, M_queryRequest) == 0x000078, "Member 'UBFGTaskNode_CivilianFlee::M_queryRequest' has a wrong offset!");
static_assert(offsetof(UBFGTaskNode_CivilianFlee, M_bIsWaitingHideEQSResult) == 0x0000E0, "Member 'UBFGTaskNode_CivilianFlee::M_bIsWaitingHideEQSResult' has a wrong offset!");
static_assert(offsetof(UBFGTaskNode_CivilianFlee, M_bHasHideLocation) == 0x0000E1, "Member 'UBFGTaskNode_CivilianFlee::M_bHasHideLocation' has a wrong offset!");
static_assert(offsetof(UBFGTaskNode_CivilianFlee, M_bMovingToTargetLocation) == 0x0000E2, "Member 'UBFGTaskNode_CivilianFlee::M_bMovingToTargetLocation' has a wrong offset!");
static_assert(offsetof(UBFGTaskNode_CivilianFlee, M_vHideLocation) == 0x0000E4, "Member 'UBFGTaskNode_CivilianFlee::M_vHideLocation' has a wrong offset!");
static_assert(offsetof(UBFGTaskNode_CivilianFlee, M_pController) == 0x0000F0, "Member 'UBFGTaskNode_CivilianFlee::M_pController' has a wrong offset!");
static_assert(offsetof(UBFGTaskNode_CivilianFlee, M_fFleeTimeOut) == 0x0000F8, "Member 'UBFGTaskNode_CivilianFlee::M_fFleeTimeOut' has a wrong offset!");
static_assert(offsetof(UBFGTaskNode_CivilianFlee, M_fCurrentFleeTime) == 0x0000FC, "Member 'UBFGTaskNode_CivilianFlee::M_fCurrentFleeTime' has a wrong offset!");

// Class BFGCore.BFGCrowdLife
// 0x0030 (0x0408 - 0x03D8)
class ABFGCrowdLife : public AActor
{
public:
	uint8                                         Pad_3D8[0x8];                                      // 0x03D8(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	class UBFGCrowdLifeStationComponent*          StationComponent;                                  // 0x03E0(0x0008)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, EditConst, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FGameplayTagContainer                  M_gameplayTags;                                    // 0x03E8(0x0020)(Edit, BlueprintVisible, BlueprintReadOnly, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"BFGCrowdLife">();
	}
	static class ABFGCrowdLife* GetDefaultObj()
	{
		return GetDefaultObjImpl<ABFGCrowdLife>();
	}
};
static_assert(alignof(ABFGCrowdLife) == 0x000008, "Wrong alignment on ABFGCrowdLife");
static_assert(sizeof(ABFGCrowdLife) == 0x000408, "Wrong size on ABFGCrowdLife");
static_assert(offsetof(ABFGCrowdLife, StationComponent) == 0x0003E0, "Member 'ABFGCrowdLife::StationComponent' has a wrong offset!");
static_assert(offsetof(ABFGCrowdLife, M_gameplayTags) == 0x0003E8, "Member 'ABFGCrowdLife::M_gameplayTags' has a wrong offset!");

// Class BFGCore.BFGAICombatParticipant
// 0x0000 (0x0028 - 0x0028)
class IBFGAICombatParticipant final : public IInterface
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"BFGAICombatParticipant">();
	}
	static class IBFGAICombatParticipant* GetDefaultObj()
	{
		return GetDefaultObjImpl<IBFGAICombatParticipant>();
	}
};
static_assert(alignof(IBFGAICombatParticipant) == 0x000008, "Wrong alignment on IBFGAICombatParticipant");
static_assert(sizeof(IBFGAICombatParticipant) == 0x000028, "Wrong size on IBFGAICombatParticipant");

// Class BFGCore.BFGQuest_ElementWaitAlertState
// 0x0068 (0x0368 - 0x0300)
class UBFGQuest_ElementWaitAlertState final : public UBFGQuest_ElementObjectiveCustom
{
public:
	EBFGAlertSystemState                          M_eStateForFail;                                   // 0x0300(0x0001)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          M_bLowerTo;                                        // 0x0301(0x0001)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_302[0x6];                                      // 0x0302(0x0006)(Fixing Size After Last Property [ Dumper-7 ])
	struct FBFGQuest_UIProvider                   M_descriptionProvider;                             // 0x0308(0x0050)(Edit, DisableEditOnInstance, Protected, NativeAccessSpecifierProtected)
	uint8                                         Pad_358[0x8];                                      // 0x0358(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	class UBFGVariable*                           M_pCompletionVariable;                             // 0x0360(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"BFGQuest_ElementWaitAlertState">();
	}
	static class UBFGQuest_ElementWaitAlertState* GetDefaultObj()
	{
		return GetDefaultObjImpl<UBFGQuest_ElementWaitAlertState>();
	}
};
static_assert(alignof(UBFGQuest_ElementWaitAlertState) == 0x000008, "Wrong alignment on UBFGQuest_ElementWaitAlertState");
static_assert(sizeof(UBFGQuest_ElementWaitAlertState) == 0x000368, "Wrong size on UBFGQuest_ElementWaitAlertState");
static_assert(offsetof(UBFGQuest_ElementWaitAlertState, M_eStateForFail) == 0x000300, "Member 'UBFGQuest_ElementWaitAlertState::M_eStateForFail' has a wrong offset!");
static_assert(offsetof(UBFGQuest_ElementWaitAlertState, M_bLowerTo) == 0x000301, "Member 'UBFGQuest_ElementWaitAlertState::M_bLowerTo' has a wrong offset!");
static_assert(offsetof(UBFGQuest_ElementWaitAlertState, M_descriptionProvider) == 0x000308, "Member 'UBFGQuest_ElementWaitAlertState::M_descriptionProvider' has a wrong offset!");
static_assert(offsetof(UBFGQuest_ElementWaitAlertState, M_pCompletionVariable) == 0x000360, "Member 'UBFGQuest_ElementWaitAlertState::M_pCompletionVariable' has a wrong offset!");

// Class BFGCore.BFGAICrowdPathFollowing
// 0x0000 (0x0028 - 0x0028)
class IBFGAICrowdPathFollowing final : public IInterface
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"BFGAICrowdPathFollowing">();
	}
	static class IBFGAICrowdPathFollowing* GetDefaultObj()
	{
		return GetDefaultObjImpl<IBFGAICrowdPathFollowing>();
	}
};
static_assert(alignof(IBFGAICrowdPathFollowing) == 0x000008, "Wrong alignment on IBFGAICrowdPathFollowing");
static_assert(sizeof(IBFGAICrowdPathFollowing) == 0x000028, "Wrong size on IBFGAICrowdPathFollowing");

// Class BFGCore.BFGWidget_DialogOption_ComboBox
// 0x0030 (0x02A8 - 0x0278)
class UBFGWidget_DialogOption_ComboBox final : public UBFGWidget_DialogOption_Customizable
{
public:
	UMulticastDelegateProperty_                   M_OnOptionChanged;                                 // 0x0278(0x0018)(ZeroConstructor, InstancedReference, NativeAccessSpecifierPublic)
	uint8                                         Pad_290[0x18];                                     // 0x0290(0x0018)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void ActionComboBox__DelegateSignature(class UBFGWidget_DialogOption_ComboBox* _pComboBox);
	void ButtonLeftClicked();
	void ButtonRightClicked();
	void SetCurrentOptionText(const class FText& _strText);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"BFGWidget_DialogOption_ComboBox">();
	}
	static class UBFGWidget_DialogOption_ComboBox* GetDefaultObj()
	{
		return GetDefaultObjImpl<UBFGWidget_DialogOption_ComboBox>();
	}
};
static_assert(alignof(UBFGWidget_DialogOption_ComboBox) == 0x000008, "Wrong alignment on UBFGWidget_DialogOption_ComboBox");
static_assert(sizeof(UBFGWidget_DialogOption_ComboBox) == 0x0002A8, "Wrong size on UBFGWidget_DialogOption_ComboBox");
static_assert(offsetof(UBFGWidget_DialogOption_ComboBox, M_OnOptionChanged) == 0x000278, "Member 'UBFGWidget_DialogOption_ComboBox::M_OnOptionChanged' has a wrong offset!");

// Class BFGCore.BFGAimAssistManager
// 0x0020 (0x0050 - 0x0030)
class UBFGAimAssistManager : public UBFGGameSystem
{
public:
	float                                         M_fMaxTargetDistance;                              // 0x0030(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         M_fWeightPowerCurve;                               // 0x0034(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class ABFGGameState*                          M_pGameState;                                      // 0x0038(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TArray<class UBFGActorComponent_AimAssistTarget*> M_apTargetRegistry;                                // 0x0040(0x0010)(ExportObject, ZeroConstructor, ContainsInstancedReference, Protected, NativeAccessSpecifierProtected)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"BFGAimAssistManager">();
	}
	static class UBFGAimAssistManager* GetDefaultObj()
	{
		return GetDefaultObjImpl<UBFGAimAssistManager>();
	}
};
static_assert(alignof(UBFGAimAssistManager) == 0x000008, "Wrong alignment on UBFGAimAssistManager");
static_assert(sizeof(UBFGAimAssistManager) == 0x000050, "Wrong size on UBFGAimAssistManager");
static_assert(offsetof(UBFGAimAssistManager, M_fMaxTargetDistance) == 0x000030, "Member 'UBFGAimAssistManager::M_fMaxTargetDistance' has a wrong offset!");
static_assert(offsetof(UBFGAimAssistManager, M_fWeightPowerCurve) == 0x000034, "Member 'UBFGAimAssistManager::M_fWeightPowerCurve' has a wrong offset!");
static_assert(offsetof(UBFGAimAssistManager, M_pGameState) == 0x000038, "Member 'UBFGAimAssistManager::M_pGameState' has a wrong offset!");
static_assert(offsetof(UBFGAimAssistManager, M_apTargetRegistry) == 0x000040, "Member 'UBFGAimAssistManager::M_apTargetRegistry' has a wrong offset!");

// Class BFGCore.BFGAimUtils
// 0x0000 (0x0028 - 0x0028)
class UBFGAimUtils final : public UBlueprintFunctionLibrary
{
public:
	static struct FBFGAimBallisticProjectileResponse AimBallisticProjectileAtMovingTarget(class UObject* _WorldContext, const struct FBFGAimBallisticProjectileParameters& _rParameters);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"BFGAimUtils">();
	}
	static class UBFGAimUtils* GetDefaultObj()
	{
		return GetDefaultObjImpl<UBFGAimUtils>();
	}
};
static_assert(alignof(UBFGAimUtils) == 0x000008, "Wrong alignment on UBFGAimUtils");
static_assert(sizeof(UBFGAimUtils) == 0x000028, "Wrong size on UBFGAimUtils");

// Class BFGCore.BFGCreditsLetter
// 0x0010 (0x03E8 - 0x03D8)
class ABFGCreditsLetter final : public AActor
{
public:
	class UStaticMeshComponent*                   M_pMesh;                                           // 0x03D8(0x0008)(Edit, ExportObject, ZeroConstructor, EditConst, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TSubclassOf<class ABFGCreditsDestructableLetter> M_pDestructableVersionClass;                       // 0x03E0(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)

public:
	void OnCompHit(class UPrimitiveComponent* _pHitComp, class AActor* _pOtherActor, class UPrimitiveComponent* _pOtherComp, const struct FVector& _pNormalImpulse, const struct FHitResult& _pHit);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"BFGCreditsLetter">();
	}
	static class ABFGCreditsLetter* GetDefaultObj()
	{
		return GetDefaultObjImpl<ABFGCreditsLetter>();
	}
};
static_assert(alignof(ABFGCreditsLetter) == 0x000008, "Wrong alignment on ABFGCreditsLetter");
static_assert(sizeof(ABFGCreditsLetter) == 0x0003E8, "Wrong size on ABFGCreditsLetter");
static_assert(offsetof(ABFGCreditsLetter, M_pMesh) == 0x0003D8, "Member 'ABFGCreditsLetter::M_pMesh' has a wrong offset!");
static_assert(offsetof(ABFGCreditsLetter, M_pDestructableVersionClass) == 0x0003E0, "Member 'ABFGCreditsLetter::M_pDestructableVersionClass' has a wrong offset!");

// Class BFGCore.BFGWidget_GameOptionsCategory
// 0x0018 (0x0440 - 0x0428)
class UBFGWidget_GameOptionsCategory : public UBFGWidget_GenericDialog
{
public:
	uint8                                         Pad_428[0x18];                                     // 0x0428(0x0018)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void AddOptionToLayout(class UBFGWidget_DialogOption* _pOption);
	void ScrollIntoView(class UBFGWidget_DialogOption* _pDialogOption);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"BFGWidget_GameOptionsCategory">();
	}
	static class UBFGWidget_GameOptionsCategory* GetDefaultObj()
	{
		return GetDefaultObjImpl<UBFGWidget_GameOptionsCategory>();
	}
};
static_assert(alignof(UBFGWidget_GameOptionsCategory) == 0x000008, "Wrong alignment on UBFGWidget_GameOptionsCategory");
static_assert(sizeof(UBFGWidget_GameOptionsCategory) == 0x000440, "Wrong size on UBFGWidget_GameOptionsCategory");

// Class BFGCore.BFGWidget_GameOptionsGamepad
// 0x0058 (0x0498 - 0x0440)
class UBFGWidget_GameOptionsGamepad final : public UBFGWidget_GameOptionsCategory
{
public:
	TSoftClassPtr<class UClass>                   M_pPanelClass_Durango;                             // 0x0440(0x0028)(Edit, DisableEditOnInstance, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TSoftClassPtr<class UClass>                   M_pPanelClass_Orbis;                               // 0x0468(0x0028)(Edit, DisableEditOnInstance, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UBFGWidget_GamepadPanel*                M_pPanel;                                          // 0x0490(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)

public:
	void AddPanelToLayout(class UBFGWidget_GamepadPanel* _pPanel);
	void OnLeftButtonClicked();
	void OnRightButtonClicked();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"BFGWidget_GameOptionsGamepad">();
	}
	static class UBFGWidget_GameOptionsGamepad* GetDefaultObj()
	{
		return GetDefaultObjImpl<UBFGWidget_GameOptionsGamepad>();
	}
};
static_assert(alignof(UBFGWidget_GameOptionsGamepad) == 0x000008, "Wrong alignment on UBFGWidget_GameOptionsGamepad");
static_assert(sizeof(UBFGWidget_GameOptionsGamepad) == 0x000498, "Wrong size on UBFGWidget_GameOptionsGamepad");
static_assert(offsetof(UBFGWidget_GameOptionsGamepad, M_pPanelClass_Durango) == 0x000440, "Member 'UBFGWidget_GameOptionsGamepad::M_pPanelClass_Durango' has a wrong offset!");
static_assert(offsetof(UBFGWidget_GameOptionsGamepad, M_pPanelClass_Orbis) == 0x000468, "Member 'UBFGWidget_GameOptionsGamepad::M_pPanelClass_Orbis' has a wrong offset!");
static_assert(offsetof(UBFGWidget_GameOptionsGamepad, M_pPanel) == 0x000490, "Member 'UBFGWidget_GameOptionsGamepad::M_pPanel' has a wrong offset!");

// Class BFGCore.BFGAINetworkPathChaseMediator
// 0x0058 (0x0080 - 0x0028)
class UBFGAINetworkPathChaseMediator final : public UObject
{
public:
	uint8                                         Pad_28[0x8];                                       // 0x0028(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	TMap<int32, struct FBFGChaseParticipant>      M_aChaseParticipants;                              // 0x0030(0x0050)(ZeroConstructor, Transient, Protected, NativeAccessSpecifierProtected)

public:
	void OnAgentDespawned(class UBFGNetworkPathAgent* _pAgent);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"BFGAINetworkPathChaseMediator">();
	}
	static class UBFGAINetworkPathChaseMediator* GetDefaultObj()
	{
		return GetDefaultObjImpl<UBFGAINetworkPathChaseMediator>();
	}
};
static_assert(alignof(UBFGAINetworkPathChaseMediator) == 0x000008, "Wrong alignment on UBFGAINetworkPathChaseMediator");
static_assert(sizeof(UBFGAINetworkPathChaseMediator) == 0x000080, "Wrong size on UBFGAINetworkPathChaseMediator");
static_assert(offsetof(UBFGAINetworkPathChaseMediator, M_aChaseParticipants) == 0x000030, "Member 'UBFGAINetworkPathChaseMediator::M_aChaseParticipants' has a wrong offset!");

// Class BFGCore.BFGAISystem
// 0x0050 (0x0080 - 0x0030)
class UBFGAISystem final : public UBFGGameSystem
{
public:
	uint8                                         Pad_30[0x8];                                       // 0x0030(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	bool                                          M_bAlertDebugEnabled;                              // 0x0038(0x0001)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          M_bDetectionDebugEnabled;                          // 0x0039(0x0001)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          M_bRotationDebugEnabled;                           // 0x003A(0x0001)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EBFGSensorGameplayOverrideBehavior            M_eSensorGameplayOverrideBehavior;                 // 0x003B(0x0001)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_3C[0x4];                                       // 0x003C(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class UObjectLibrary*                         M_pPreloadLibrary;                                 // 0x0040(0x0008)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class ABFGGameState*                          M_pGameState;                                      // 0x0048(0x0008)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UBFG_AISettings*                        M_pSettings;                                       // 0x0050(0x0008)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UBFGAICombatMediator*                   M_pCombatMediator;                                 // 0x0058(0x0008)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UBFGAINetworkPathChaseMediator*         M_pNetworkPathChaseMediator;                       // 0x0060(0x0008)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UBFGDynamicObstaclePool_Sphere*         M_pDynamicObstaclePool_Sphere;                     // 0x0068(0x0008)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UBFGDynamicObstaclePool_Box*            M_pDynamicObstaclePool_Box;                        // 0x0070(0x0008)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UBFGVisibilityCheckerPool_Box*          M_pVisibilityCheckerPool_Box;                      // 0x0078(0x0008)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)

public:
	void OnWorldLoading(class UBFGGameInstance* _pGameInstance, class UWorld* _pWorld);
	void SetAIAmmoShotDelayLogBase(float _fNewBase);
	void SetAIAmmoShotDelayScalingFactor(float _fNewFactor);
	void SetAICombatReloadLogBase(float _fNewBase);
	void SetAICombatReloadTimeScalingFactor(float _fNewFactor);
	void ToggleAIAlertDebug();
	void ToggleAICombatDebug();
	void ToggleAIDetectionDebug();
	void ToggleAIRotationDebug();
	void ToggleAIStatVariablesDebug();

	class UBFGAlertSystemManager* GetAlertSystemManager() const;
	class UBFGAICombatMediator* GetCombatMediator() const;
	class UBFGDynamicObstaclePool_Box* GetDyanmicObstaclePool_Box() const;
	class UBFGDynamicObstaclePool_Sphere* GetDyanmicObstaclePool_Sphere() const;
	class UBFGVisibilityCheckerPool_Box* GetVisibilityCheckerPool_Box() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"BFGAISystem">();
	}
	static class UBFGAISystem* GetDefaultObj()
	{
		return GetDefaultObjImpl<UBFGAISystem>();
	}
};
static_assert(alignof(UBFGAISystem) == 0x000008, "Wrong alignment on UBFGAISystem");
static_assert(sizeof(UBFGAISystem) == 0x000080, "Wrong size on UBFGAISystem");
static_assert(offsetof(UBFGAISystem, M_bAlertDebugEnabled) == 0x000038, "Member 'UBFGAISystem::M_bAlertDebugEnabled' has a wrong offset!");
static_assert(offsetof(UBFGAISystem, M_bDetectionDebugEnabled) == 0x000039, "Member 'UBFGAISystem::M_bDetectionDebugEnabled' has a wrong offset!");
static_assert(offsetof(UBFGAISystem, M_bRotationDebugEnabled) == 0x00003A, "Member 'UBFGAISystem::M_bRotationDebugEnabled' has a wrong offset!");
static_assert(offsetof(UBFGAISystem, M_eSensorGameplayOverrideBehavior) == 0x00003B, "Member 'UBFGAISystem::M_eSensorGameplayOverrideBehavior' has a wrong offset!");
static_assert(offsetof(UBFGAISystem, M_pPreloadLibrary) == 0x000040, "Member 'UBFGAISystem::M_pPreloadLibrary' has a wrong offset!");
static_assert(offsetof(UBFGAISystem, M_pGameState) == 0x000048, "Member 'UBFGAISystem::M_pGameState' has a wrong offset!");
static_assert(offsetof(UBFGAISystem, M_pSettings) == 0x000050, "Member 'UBFGAISystem::M_pSettings' has a wrong offset!");
static_assert(offsetof(UBFGAISystem, M_pCombatMediator) == 0x000058, "Member 'UBFGAISystem::M_pCombatMediator' has a wrong offset!");
static_assert(offsetof(UBFGAISystem, M_pNetworkPathChaseMediator) == 0x000060, "Member 'UBFGAISystem::M_pNetworkPathChaseMediator' has a wrong offset!");
static_assert(offsetof(UBFGAISystem, M_pDynamicObstaclePool_Sphere) == 0x000068, "Member 'UBFGAISystem::M_pDynamicObstaclePool_Sphere' has a wrong offset!");
static_assert(offsetof(UBFGAISystem, M_pDynamicObstaclePool_Box) == 0x000070, "Member 'UBFGAISystem::M_pDynamicObstaclePool_Box' has a wrong offset!");
static_assert(offsetof(UBFGAISystem, M_pVisibilityCheckerPool_Box) == 0x000078, "Member 'UBFGAISystem::M_pVisibilityCheckerPool_Box' has a wrong offset!");

// Class BFGCore.BFGNetworkPathAgent_AIStateVehicleChaseTarget
// 0x0068 (0x00C0 - 0x0058)
class UBFGNetworkPathAgent_AIStateVehicleChaseTarget final : public UBFGNetworkPathAgent_AIStateBase
{
public:
	class UObject*                                M_pChasedTarget;                                   // 0x0058(0x0008)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          M_bTargetChanged;                                  // 0x0060(0x0001)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_61[0x3];                                       // 0x0061(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         M_fRecomputeTimer;                                 // 0x0064(0x0004)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	EBFGAIVehicleVehicleChaseTargetPhase          M_ePhase;                                          // 0x0068(0x0001)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_69[0x3];                                       // 0x0069(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	struct FVector                                M_vLastKnownLocation;                              // 0x006C(0x000C)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	struct FVector                                M_vTargetStopLocation;                             // 0x0078(0x000C)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          M_bHasValidTargetStopLocation;                     // 0x0084(0x0001)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_85[0x3];                                       // 0x0085(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         M_fCoolDownTimer;                                  // 0x0088(0x0004)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_8C[0x4];                                       // 0x008C(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class UBFGNetworkPath*                        M_pLastValidPath;                                  // 0x0090(0x0008)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          M_bReleasePassengersAtTargetLocation;              // 0x0098(0x0001)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_99[0x3];                                       // 0x0099(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         M_fStuckInTrafficTimer;                            // 0x009C(0x0004)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         M_fStuckInTrafficTimeoutValue;                     // 0x00A0(0x0004)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         M_fStopDistance;                                   // 0x00A4(0x0004)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	EBFGAIVehicleVehicleChaseTargetPathDecision   M_eLastPathDecision;                               // 0x00A8(0x0001)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_A9[0x7];                                       // 0x00A9(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	class UBFGAINetworkPathChaseMediator*         M_pNetworkPathChaseMediator;                       // 0x00B0(0x0008)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	int32                                         M_iParticipantId;                                  // 0x00B8(0x0004)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_BC[0x4];                                       // 0x00BC(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"BFGNetworkPathAgent_AIStateVehicleChaseTarget">();
	}
	static class UBFGNetworkPathAgent_AIStateVehicleChaseTarget* GetDefaultObj()
	{
		return GetDefaultObjImpl<UBFGNetworkPathAgent_AIStateVehicleChaseTarget>();
	}
};
static_assert(alignof(UBFGNetworkPathAgent_AIStateVehicleChaseTarget) == 0x000008, "Wrong alignment on UBFGNetworkPathAgent_AIStateVehicleChaseTarget");
static_assert(sizeof(UBFGNetworkPathAgent_AIStateVehicleChaseTarget) == 0x0000C0, "Wrong size on UBFGNetworkPathAgent_AIStateVehicleChaseTarget");
static_assert(offsetof(UBFGNetworkPathAgent_AIStateVehicleChaseTarget, M_pChasedTarget) == 0x000058, "Member 'UBFGNetworkPathAgent_AIStateVehicleChaseTarget::M_pChasedTarget' has a wrong offset!");
static_assert(offsetof(UBFGNetworkPathAgent_AIStateVehicleChaseTarget, M_bTargetChanged) == 0x000060, "Member 'UBFGNetworkPathAgent_AIStateVehicleChaseTarget::M_bTargetChanged' has a wrong offset!");
static_assert(offsetof(UBFGNetworkPathAgent_AIStateVehicleChaseTarget, M_fRecomputeTimer) == 0x000064, "Member 'UBFGNetworkPathAgent_AIStateVehicleChaseTarget::M_fRecomputeTimer' has a wrong offset!");
static_assert(offsetof(UBFGNetworkPathAgent_AIStateVehicleChaseTarget, M_ePhase) == 0x000068, "Member 'UBFGNetworkPathAgent_AIStateVehicleChaseTarget::M_ePhase' has a wrong offset!");
static_assert(offsetof(UBFGNetworkPathAgent_AIStateVehicleChaseTarget, M_vLastKnownLocation) == 0x00006C, "Member 'UBFGNetworkPathAgent_AIStateVehicleChaseTarget::M_vLastKnownLocation' has a wrong offset!");
static_assert(offsetof(UBFGNetworkPathAgent_AIStateVehicleChaseTarget, M_vTargetStopLocation) == 0x000078, "Member 'UBFGNetworkPathAgent_AIStateVehicleChaseTarget::M_vTargetStopLocation' has a wrong offset!");
static_assert(offsetof(UBFGNetworkPathAgent_AIStateVehicleChaseTarget, M_bHasValidTargetStopLocation) == 0x000084, "Member 'UBFGNetworkPathAgent_AIStateVehicleChaseTarget::M_bHasValidTargetStopLocation' has a wrong offset!");
static_assert(offsetof(UBFGNetworkPathAgent_AIStateVehicleChaseTarget, M_fCoolDownTimer) == 0x000088, "Member 'UBFGNetworkPathAgent_AIStateVehicleChaseTarget::M_fCoolDownTimer' has a wrong offset!");
static_assert(offsetof(UBFGNetworkPathAgent_AIStateVehicleChaseTarget, M_pLastValidPath) == 0x000090, "Member 'UBFGNetworkPathAgent_AIStateVehicleChaseTarget::M_pLastValidPath' has a wrong offset!");
static_assert(offsetof(UBFGNetworkPathAgent_AIStateVehicleChaseTarget, M_bReleasePassengersAtTargetLocation) == 0x000098, "Member 'UBFGNetworkPathAgent_AIStateVehicleChaseTarget::M_bReleasePassengersAtTargetLocation' has a wrong offset!");
static_assert(offsetof(UBFGNetworkPathAgent_AIStateVehicleChaseTarget, M_fStuckInTrafficTimer) == 0x00009C, "Member 'UBFGNetworkPathAgent_AIStateVehicleChaseTarget::M_fStuckInTrafficTimer' has a wrong offset!");
static_assert(offsetof(UBFGNetworkPathAgent_AIStateVehicleChaseTarget, M_fStuckInTrafficTimeoutValue) == 0x0000A0, "Member 'UBFGNetworkPathAgent_AIStateVehicleChaseTarget::M_fStuckInTrafficTimeoutValue' has a wrong offset!");
static_assert(offsetof(UBFGNetworkPathAgent_AIStateVehicleChaseTarget, M_fStopDistance) == 0x0000A4, "Member 'UBFGNetworkPathAgent_AIStateVehicleChaseTarget::M_fStopDistance' has a wrong offset!");
static_assert(offsetof(UBFGNetworkPathAgent_AIStateVehicleChaseTarget, M_eLastPathDecision) == 0x0000A8, "Member 'UBFGNetworkPathAgent_AIStateVehicleChaseTarget::M_eLastPathDecision' has a wrong offset!");
static_assert(offsetof(UBFGNetworkPathAgent_AIStateVehicleChaseTarget, M_pNetworkPathChaseMediator) == 0x0000B0, "Member 'UBFGNetworkPathAgent_AIStateVehicleChaseTarget::M_pNetworkPathChaseMediator' has a wrong offset!");
static_assert(offsetof(UBFGNetworkPathAgent_AIStateVehicleChaseTarget, M_iParticipantId) == 0x0000B8, "Member 'UBFGNetworkPathAgent_AIStateVehicleChaseTarget::M_iParticipantId' has a wrong offset!");

// Class BFGCore.BFGTaskNode_FinishStuckEvade
// 0x0028 (0x00A0 - 0x0078)
class UBFGTaskNode_FinishStuckEvade final : public UBFGBTBaseTaskNode
{
public:
	struct FBlackboardKeySelector                 M_bbKeyTarget;                                     // 0x0078(0x0028)(Edit, BlueprintVisible, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"BFGTaskNode_FinishStuckEvade">();
	}
	static class UBFGTaskNode_FinishStuckEvade* GetDefaultObj()
	{
		return GetDefaultObjImpl<UBFGTaskNode_FinishStuckEvade>();
	}
};
static_assert(alignof(UBFGTaskNode_FinishStuckEvade) == 0x000008, "Wrong alignment on UBFGTaskNode_FinishStuckEvade");
static_assert(sizeof(UBFGTaskNode_FinishStuckEvade) == 0x0000A0, "Wrong size on UBFGTaskNode_FinishStuckEvade");
static_assert(offsetof(UBFGTaskNode_FinishStuckEvade, M_bbKeyTarget) == 0x000078, "Member 'UBFGTaskNode_FinishStuckEvade::M_bbKeyTarget' has a wrong offset!");

// Class BFGCore.BFGCrowdScriptConAsset
// 0x0060 (0x0090 - 0x0030)
class UBFGCrowdScriptConAsset final : public UDataAsset
{
public:
	TMap<EBFGCrowdScriptConAsset_Participant, struct FBFGActorBinding> M_aParticipants;                                   // 0x0030(0x0050)(Edit, ZeroConstructor, DisableEditOnInstance, NativeAccessSpecifierPublic)
	TArray<struct FBFGCrowdScriptConAsset_Line>   M_aLines;                                          // 0x0080(0x0010)(Edit, ZeroConstructor, DisableEditOnInstance, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"BFGCrowdScriptConAsset">();
	}
	static class UBFGCrowdScriptConAsset* GetDefaultObj()
	{
		return GetDefaultObjImpl<UBFGCrowdScriptConAsset>();
	}
};
static_assert(alignof(UBFGCrowdScriptConAsset) == 0x000008, "Wrong alignment on UBFGCrowdScriptConAsset");
static_assert(sizeof(UBFGCrowdScriptConAsset) == 0x000090, "Wrong size on UBFGCrowdScriptConAsset");
static_assert(offsetof(UBFGCrowdScriptConAsset, M_aParticipants) == 0x000030, "Member 'UBFGCrowdScriptConAsset::M_aParticipants' has a wrong offset!");
static_assert(offsetof(UBFGCrowdScriptConAsset, M_aLines) == 0x000080, "Member 'UBFGCrowdScriptConAsset::M_aLines' has a wrong offset!");

// Class BFGCore.BFGAITagQueries
// 0x0318 (0x0348 - 0x0030)
class UBFGAITagQueries final : public UDataAsset
{
public:
	struct FGameplayTagQuery                      M_EnemyTypeTagQuery;                               // 0x0030(0x0048)(Edit, BlueprintVisible, BlueprintReadOnly, NativeAccessSpecifierPublic)
	struct FGameplayTagQuery                      M_ActorAgentQuery;                                 // 0x0078(0x0048)(Edit, BlueprintVisible, BlueprintReadOnly, NativeAccessSpecifierPublic)
	struct FGameplayTagQuery                      M_ActorFarmerQuery;                                // 0x00C0(0x0048)(Edit, BlueprintVisible, BlueprintReadOnly, NativeAccessSpecifierPublic)
	struct FGameplayTagQuery                      M_ActorIsChickenQuery;                             // 0x0108(0x0048)(Edit, BlueprintVisible, NativeAccessSpecifierPublic)
	struct FGameplayTagQuery                      M_ActorIsVehicleQuery;                             // 0x0150(0x0048)(Edit, BlueprintVisible, NativeAccessSpecifierPublic)
	struct FGameplayTagQuery                      M_ActorIsHypnotizedQuery;                          // 0x0198(0x0048)(Edit, BlueprintVisible, NativeAccessSpecifierPublic)
	struct FGameplayTagQuery                      M_ActorIsHolobbedQuery;                            // 0x01E0(0x0048)(Edit, BlueprintVisible, NativeAccessSpecifierPublic)
	struct FGameplayTagQuery                      M_ActorIsDetectableQuery;                          // 0x0228(0x0048)(Edit, BlueprintVisible, NativeAccessSpecifierPublic)
	struct FGameplayTagQuery                      M_ActorIsInProtectiveBubbleQuery;                  // 0x0270(0x0048)(Edit, BlueprintVisible, NativeAccessSpecifierPublic)
	struct FGameplayTagQuery                      M_ActorIsCombatantQuery;                           // 0x02B8(0x0048)(Edit, BlueprintVisible, NativeAccessSpecifierPublic)
	struct FGameplayTagQuery                      M_ActorIsBrainExtractedQuery;                      // 0x0300(0x0048)(Edit, BlueprintVisible, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"BFGAITagQueries">();
	}
	static class UBFGAITagQueries* GetDefaultObj()
	{
		return GetDefaultObjImpl<UBFGAITagQueries>();
	}
};
static_assert(alignof(UBFGAITagQueries) == 0x000008, "Wrong alignment on UBFGAITagQueries");
static_assert(sizeof(UBFGAITagQueries) == 0x000348, "Wrong size on UBFGAITagQueries");
static_assert(offsetof(UBFGAITagQueries, M_EnemyTypeTagQuery) == 0x000030, "Member 'UBFGAITagQueries::M_EnemyTypeTagQuery' has a wrong offset!");
static_assert(offsetof(UBFGAITagQueries, M_ActorAgentQuery) == 0x000078, "Member 'UBFGAITagQueries::M_ActorAgentQuery' has a wrong offset!");
static_assert(offsetof(UBFGAITagQueries, M_ActorFarmerQuery) == 0x0000C0, "Member 'UBFGAITagQueries::M_ActorFarmerQuery' has a wrong offset!");
static_assert(offsetof(UBFGAITagQueries, M_ActorIsChickenQuery) == 0x000108, "Member 'UBFGAITagQueries::M_ActorIsChickenQuery' has a wrong offset!");
static_assert(offsetof(UBFGAITagQueries, M_ActorIsVehicleQuery) == 0x000150, "Member 'UBFGAITagQueries::M_ActorIsVehicleQuery' has a wrong offset!");
static_assert(offsetof(UBFGAITagQueries, M_ActorIsHypnotizedQuery) == 0x000198, "Member 'UBFGAITagQueries::M_ActorIsHypnotizedQuery' has a wrong offset!");
static_assert(offsetof(UBFGAITagQueries, M_ActorIsHolobbedQuery) == 0x0001E0, "Member 'UBFGAITagQueries::M_ActorIsHolobbedQuery' has a wrong offset!");
static_assert(offsetof(UBFGAITagQueries, M_ActorIsDetectableQuery) == 0x000228, "Member 'UBFGAITagQueries::M_ActorIsDetectableQuery' has a wrong offset!");
static_assert(offsetof(UBFGAITagQueries, M_ActorIsInProtectiveBubbleQuery) == 0x000270, "Member 'UBFGAITagQueries::M_ActorIsInProtectiveBubbleQuery' has a wrong offset!");
static_assert(offsetof(UBFGAITagQueries, M_ActorIsCombatantQuery) == 0x0002B8, "Member 'UBFGAITagQueries::M_ActorIsCombatantQuery' has a wrong offset!");
static_assert(offsetof(UBFGAITagQueries, M_ActorIsBrainExtractedQuery) == 0x000300, "Member 'UBFGAITagQueries::M_ActorIsBrainExtractedQuery' has a wrong offset!");

// Class BFGCore.BFGQuest_Timer
// 0x0060 (0x0088 - 0x0028)
class UBFGQuest_Timer final : public UObject
{
public:
	uint8                                         Pad_28[0x48];                                      // 0x0028(0x0048)(Fixing Size After Last Property [ Dumper-7 ])
	class UBFGVariable*                           M_pVariable;                                       // 0x0070(0x0008)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UBFGQuest_Manager*                      M_pManager;                                        // 0x0078(0x0008)(ExportObject, ZeroConstructor, Transient, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_80[0x8];                                       // 0x0080(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	float GetDuration() const;
	struct FTimespan GetDurationTimespan() const;
	float GetRemainingTime() const;
	struct FTimespan GetRemainingTimespan() const;
	bool IsHUDVisible() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"BFGQuest_Timer">();
	}
	static class UBFGQuest_Timer* GetDefaultObj()
	{
		return GetDefaultObjImpl<UBFGQuest_Timer>();
	}
};
static_assert(alignof(UBFGQuest_Timer) == 0x000008, "Wrong alignment on UBFGQuest_Timer");
static_assert(sizeof(UBFGQuest_Timer) == 0x000088, "Wrong size on UBFGQuest_Timer");
static_assert(offsetof(UBFGQuest_Timer, M_pVariable) == 0x000070, "Member 'UBFGQuest_Timer::M_pVariable' has a wrong offset!");
static_assert(offsetof(UBFGQuest_Timer, M_pManager) == 0x000078, "Member 'UBFGQuest_Timer::M_pManager' has a wrong offset!");

// Class BFGCore.BFGAITargetInterface
// 0x0000 (0x0028 - 0x0028)
class IBFGAITargetInterface final : public IInterface
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"BFGAITargetInterface">();
	}
	static class IBFGAITargetInterface* GetDefaultObj()
	{
		return GetDefaultObjImpl<IBFGAITargetInterface>();
	}
};
static_assert(alignof(IBFGAITargetInterface) == 0x000008, "Wrong alignment on IBFGAITargetInterface");
static_assert(sizeof(IBFGAITargetInterface) == 0x000028, "Wrong size on IBFGAITargetInterface");

// Class BFGCore.BFGTaskNode_BossCharge_Complete
// 0x0000 (0x00A0 - 0x00A0)
class UBFGTaskNode_BossCharge_Complete final : public UBFGTaskNode_BossBase
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"BFGTaskNode_BossCharge_Complete">();
	}
	static class UBFGTaskNode_BossCharge_Complete* GetDefaultObj()
	{
		return GetDefaultObjImpl<UBFGTaskNode_BossCharge_Complete>();
	}
};
static_assert(alignof(UBFGTaskNode_BossCharge_Complete) == 0x000008, "Wrong alignment on UBFGTaskNode_BossCharge_Complete");
static_assert(sizeof(UBFGTaskNode_BossCharge_Complete) == 0x0000A0, "Wrong size on UBFGTaskNode_BossCharge_Complete");

// Class BFGCore.BFGCrowdLifeRecruitmentAsset
// 0x0070 (0x00A0 - 0x0030)
class UBFGCrowdLifeRecruitmentAsset final : public UDataAsset
{
public:
	float                                         M_fGeneralRecruitmentProbability;                  // 0x0030(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_34[0x4];                                       // 0x0034(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	struct FGameplayTagQuery                      M_initialFilter;                                   // 0x0038(0x0048)(Edit, BlueprintVisible, Protected, NativeAccessSpecifierProtected)
	TArray<struct FBFGCrowdLifeRecruitmentFilter> M_aFilters;                                        // 0x0080(0x0010)(Edit, BlueprintVisible, ZeroConstructor, Protected, NativeAccessSpecifierProtected)
	TArray<struct FBFGCrowdLifeRecruitmentFilterGroup> M_aGroups;                                         // 0x0090(0x0010)(Edit, BlueprintVisible, ZeroConstructor, Protected, NativeAccessSpecifierProtected)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"BFGCrowdLifeRecruitmentAsset">();
	}
	static class UBFGCrowdLifeRecruitmentAsset* GetDefaultObj()
	{
		return GetDefaultObjImpl<UBFGCrowdLifeRecruitmentAsset>();
	}
};
static_assert(alignof(UBFGCrowdLifeRecruitmentAsset) == 0x000008, "Wrong alignment on UBFGCrowdLifeRecruitmentAsset");
static_assert(sizeof(UBFGCrowdLifeRecruitmentAsset) == 0x0000A0, "Wrong size on UBFGCrowdLifeRecruitmentAsset");
static_assert(offsetof(UBFGCrowdLifeRecruitmentAsset, M_fGeneralRecruitmentProbability) == 0x000030, "Member 'UBFGCrowdLifeRecruitmentAsset::M_fGeneralRecruitmentProbability' has a wrong offset!");
static_assert(offsetof(UBFGCrowdLifeRecruitmentAsset, M_initialFilter) == 0x000038, "Member 'UBFGCrowdLifeRecruitmentAsset::M_initialFilter' has a wrong offset!");
static_assert(offsetof(UBFGCrowdLifeRecruitmentAsset, M_aFilters) == 0x000080, "Member 'UBFGCrowdLifeRecruitmentAsset::M_aFilters' has a wrong offset!");
static_assert(offsetof(UBFGCrowdLifeRecruitmentAsset, M_aGroups) == 0x000090, "Member 'UBFGCrowdLifeRecruitmentAsset::M_aGroups' has a wrong offset!");

// Class BFGCore.BFGQuest_ElementCollectResource
// 0x00C0 (0x03C0 - 0x0300)
class UBFGQuest_ElementCollectResource final : public UBFGQuest_ElementObjectiveCustom
{
public:
	UMulticastDelegateProperty_                   M_onResourceValueCounted;                          // 0x0300(0x0018)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	EItemValueTypeEnum                            M_eType;                                           // 0x0318(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_319[0x3];                                      // 0x0319(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         M_fTargetAmount;                                   // 0x031C(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	struct FBFGQuest_UIProvider                   M_descriptionProvider;                             // 0x0320(0x0050)(Edit, BlueprintVisible, BlueprintReadOnly, DisableEditOnInstance, Protected, NativeAccessSpecifierProtected)
	bool                                          M_bEnableChallengeScore;                           // 0x0370(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_371[0x7];                                      // 0x0371(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	struct FBFGQuest_Objectives                   M_runtimeObjectives;                               // 0x0378(0x0040)(Transient, ContainsInstancedReference, Protected, NativeAccessSpecifierProtected)
	uint8                                         Pad_3B8[0x8];                                      // 0x03B8(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"BFGQuest_ElementCollectResource">();
	}
	static class UBFGQuest_ElementCollectResource* GetDefaultObj()
	{
		return GetDefaultObjImpl<UBFGQuest_ElementCollectResource>();
	}
};
static_assert(alignof(UBFGQuest_ElementCollectResource) == 0x000008, "Wrong alignment on UBFGQuest_ElementCollectResource");
static_assert(sizeof(UBFGQuest_ElementCollectResource) == 0x0003C0, "Wrong size on UBFGQuest_ElementCollectResource");
static_assert(offsetof(UBFGQuest_ElementCollectResource, M_onResourceValueCounted) == 0x000300, "Member 'UBFGQuest_ElementCollectResource::M_onResourceValueCounted' has a wrong offset!");
static_assert(offsetof(UBFGQuest_ElementCollectResource, M_eType) == 0x000318, "Member 'UBFGQuest_ElementCollectResource::M_eType' has a wrong offset!");
static_assert(offsetof(UBFGQuest_ElementCollectResource, M_fTargetAmount) == 0x00031C, "Member 'UBFGQuest_ElementCollectResource::M_fTargetAmount' has a wrong offset!");
static_assert(offsetof(UBFGQuest_ElementCollectResource, M_descriptionProvider) == 0x000320, "Member 'UBFGQuest_ElementCollectResource::M_descriptionProvider' has a wrong offset!");
static_assert(offsetof(UBFGQuest_ElementCollectResource, M_bEnableChallengeScore) == 0x000370, "Member 'UBFGQuest_ElementCollectResource::M_bEnableChallengeScore' has a wrong offset!");
static_assert(offsetof(UBFGQuest_ElementCollectResource, M_runtimeObjectives) == 0x000378, "Member 'UBFGQuest_ElementCollectResource::M_runtimeObjectives' has a wrong offset!");

// Class BFGCore.BFGAIUtils
// 0x0000 (0x0028 - 0x0028)
class UBFGAIUtils final : public UObject
{
public:
	static class AActor* CheckFriendlyFire(class APawn* _pThis, class AActor* _pTarget, class ABFGWeapon* _pSpecificWeapon);
	static struct FVector ComputeClosestNetworkPathLocation(const struct FVector& _vLocation, float _fMaxRadius, const class UObject* _pWorldContextObject);
	static struct FGameplayTag FindMainGameplayTag(const struct FGameplayTagContainer& _enemyTagContainer);
	static class AActor* GetAttackTarget(class APawn* _pPlayer);
	static EBFGBehaviourState_NPC GetBehaviorState(class AActor* _pActor);
	static class AActor* GetCryptosTarget(class APawn* _pPlayer);
	static class ABFGWeapon* GetCurrentWeapon(class AActor* _pThis);
	static class ABFGWeapon* GetNPCCurrentWeapon(class AActor* _pThis);
	static class ABFGWeapon* GetNPCWeapon(class AActor* _pThis, TSoftClassPtr<class UClass> _specificClass);
	static bool GetPawnAndController(class AActor* _pPawnOrController, bool _bRequirePawn, class APawn** _pOutPawn, bool _bRequireController, class AController** _pOutController);
	static EBFGSensorGameplayOverrideBehavior GetSensorGameplayOverrideBehavior(const class UObject* _pWorldContextObject);
	static EBFGTargetType GetTargetType(class AActor* _pTarget);
	static EBFGTargetType GetTargetTypeOfCurrentTarget(class AActor* _pActor);
	static bool HasLineOfFire(class APawn* _pThis, class AActor* _pOther, class ABFGWeapon* _pSpecificWeapon);
	static bool HasLineOfSight(class AActor* _pThis, class AActor* _pOther, bool _bCheckSightPie);
	static bool IsActorAlive(class AActor* _pActor);
	static bool IsActorInAir(class AActor* _pTargetActor);
	static bool IsActorInvisible(class AActor* _pActor);
	static bool IsActorRotatingInPlace(class AActor* _pActor, struct FVector* _vOutRotatngDirection);
	static bool IsInMissionBoundaries(const struct FVector& _vVector, const class UObject* _pWorldContextObject);
	static bool IsPositionInViewFrustrum(class ULocalPlayer* _pLocalPlayer, const struct FVector& _position, float _fRadius);
	static bool SetSensorGameplayOverrideBehavior(EBFGSensorGameplayOverrideBehavior _eBehavior, const class UObject* _pWorldContextObject);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"BFGAIUtils">();
	}
	static class UBFGAIUtils* GetDefaultObj()
	{
		return GetDefaultObjImpl<UBFGAIUtils>();
	}
};
static_assert(alignof(UBFGAIUtils) == 0x000008, "Wrong alignment on UBFGAIUtils");
static_assert(sizeof(UBFGAIUtils) == 0x000028, "Wrong size on UBFGAIUtils");

// Class BFGCore.BFGAlertResponseLevelState
// 0x0140 (0x0168 - 0x0028)
class UBFGAlertResponseLevelState : public UObject
{
public:
	class FString                                 ResponseLevelName;                                 // 0x0028(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class FText                                   DisplayName;                                       // 0x0038(0x0018)(Edit, BlueprintVisible, BlueprintReadOnly, DisableEditOnInstance, Protected, NativeAccessSpecifierProtected)
	class FText                                   Description;                                       // 0x0050(0x0018)(Edit, BlueprintVisible, BlueprintReadOnly, DisableEditOnInstance, Protected, NativeAccessSpecifierProtected)
	float                                         SpawnWaveTriggerInterval;                          // 0x0068(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         M_fCuriosityTimeScale;                             // 0x006C(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	EBFGAlertLevelIconType                        M_eIconType;                                       // 0x0070(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_71[0x7];                                       // 0x0071(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	class UBFGAlertSystemManager*                 M_pAlertSystem;                                    // 0x0078(0x0008)(ExportObject, ZeroConstructor, Transient, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	struct FBFGResponseLevelDef                   Definition;                                        // 0x0080(0x0030)(Transient, Protected, NativeAccessSpecifierProtected)
	float                                         M_fUpdateTimer;                                    // 0x00B0(0x0004)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         M_fSpawnTimer;                                     // 0x00B4(0x0004)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_B8[0x18];                                      // 0x00B8(0x0018)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<class UBFGNetworkPathAgent*>           M_apSpawnedAgents;                                 // 0x00D0(0x0010)(ZeroConstructor, Transient, Protected, NativeAccessSpecifierProtected)
	TMap<class UBFGNetworkPathAgent*, struct FGameplayTagContainer> M_apSpawnedAgentsTags;                             // 0x00E0(0x0050)(ZeroConstructor, Transient, Protected, NativeAccessSpecifierProtected)
	TArray<struct FBFGDeferredSpawnRequest>       M_aSpawnRequests;                                  // 0x0130(0x0010)(ZeroConstructor, Transient, Protected, NativeAccessSpecifierProtected)
	TArray<struct FBFGSpawnRequestVehicleData>    M_apWithPassengersVehiclesToTreat;                 // 0x0140(0x0010)(ZeroConstructor, Transient, Protected, NativeAccessSpecifierProtected)
	TArray<class UBFGNetworkPathAgent*>           M_apMaxPopulationRelevantAgents;                   // 0x0150(0x0010)(ZeroConstructor, Transient, Protected, NativeAccessSpecifierProtected)
	uint8                                         Pad_160[0x8];                                      // 0x0160(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void DespawnAll(bool _bImmediate);
	void OnAgentDead(class UBFGNetworkPathAgent* _pAgent, class AActor* _pActor, bool _bIsAttched);
	void OnAgentDestroyed(class UBFGNetworkPathAgent* _pAgent);
	void OnEnter(class UBFGAlertResponseLevelState* _pPreviousState);
	void OnLeave();
	void OnVehiclePassengersOut(class UBFGNetworkPathAgent* _pAgent);
	void Update(float _fDeltaTime);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"BFGAlertResponseLevelState">();
	}
	static class UBFGAlertResponseLevelState* GetDefaultObj()
	{
		return GetDefaultObjImpl<UBFGAlertResponseLevelState>();
	}
};
static_assert(alignof(UBFGAlertResponseLevelState) == 0x000008, "Wrong alignment on UBFGAlertResponseLevelState");
static_assert(sizeof(UBFGAlertResponseLevelState) == 0x000168, "Wrong size on UBFGAlertResponseLevelState");
static_assert(offsetof(UBFGAlertResponseLevelState, ResponseLevelName) == 0x000028, "Member 'UBFGAlertResponseLevelState::ResponseLevelName' has a wrong offset!");
static_assert(offsetof(UBFGAlertResponseLevelState, DisplayName) == 0x000038, "Member 'UBFGAlertResponseLevelState::DisplayName' has a wrong offset!");
static_assert(offsetof(UBFGAlertResponseLevelState, Description) == 0x000050, "Member 'UBFGAlertResponseLevelState::Description' has a wrong offset!");
static_assert(offsetof(UBFGAlertResponseLevelState, SpawnWaveTriggerInterval) == 0x000068, "Member 'UBFGAlertResponseLevelState::SpawnWaveTriggerInterval' has a wrong offset!");
static_assert(offsetof(UBFGAlertResponseLevelState, M_fCuriosityTimeScale) == 0x00006C, "Member 'UBFGAlertResponseLevelState::M_fCuriosityTimeScale' has a wrong offset!");
static_assert(offsetof(UBFGAlertResponseLevelState, M_eIconType) == 0x000070, "Member 'UBFGAlertResponseLevelState::M_eIconType' has a wrong offset!");
static_assert(offsetof(UBFGAlertResponseLevelState, M_pAlertSystem) == 0x000078, "Member 'UBFGAlertResponseLevelState::M_pAlertSystem' has a wrong offset!");
static_assert(offsetof(UBFGAlertResponseLevelState, Definition) == 0x000080, "Member 'UBFGAlertResponseLevelState::Definition' has a wrong offset!");
static_assert(offsetof(UBFGAlertResponseLevelState, M_fUpdateTimer) == 0x0000B0, "Member 'UBFGAlertResponseLevelState::M_fUpdateTimer' has a wrong offset!");
static_assert(offsetof(UBFGAlertResponseLevelState, M_fSpawnTimer) == 0x0000B4, "Member 'UBFGAlertResponseLevelState::M_fSpawnTimer' has a wrong offset!");
static_assert(offsetof(UBFGAlertResponseLevelState, M_apSpawnedAgents) == 0x0000D0, "Member 'UBFGAlertResponseLevelState::M_apSpawnedAgents' has a wrong offset!");
static_assert(offsetof(UBFGAlertResponseLevelState, M_apSpawnedAgentsTags) == 0x0000E0, "Member 'UBFGAlertResponseLevelState::M_apSpawnedAgentsTags' has a wrong offset!");
static_assert(offsetof(UBFGAlertResponseLevelState, M_aSpawnRequests) == 0x000130, "Member 'UBFGAlertResponseLevelState::M_aSpawnRequests' has a wrong offset!");
static_assert(offsetof(UBFGAlertResponseLevelState, M_apWithPassengersVehiclesToTreat) == 0x000140, "Member 'UBFGAlertResponseLevelState::M_apWithPassengersVehiclesToTreat' has a wrong offset!");
static_assert(offsetof(UBFGAlertResponseLevelState, M_apMaxPopulationRelevantAgents) == 0x000150, "Member 'UBFGAlertResponseLevelState::M_apMaxPopulationRelevantAgents' has a wrong offset!");

// Class BFGCore.BFGCredits
// 0x00A8 (0x0480 - 0x03D8)
class ABFGCredits final : public AActor
{
public:
	class UCameraComponent*                       M_pCamera;                                         // 0x03D8(0x0008)(Edit, ExportObject, ZeroConstructor, EditConst, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class USceneComponent*                        M_pStartPosition;                                  // 0x03E0(0x0008)(Edit, ExportObject, ZeroConstructor, EditConst, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class USplineComponent*                       M_pCreditsSpline;                                  // 0x03E8(0x0008)(Edit, ExportObject, ZeroConstructor, EditConst, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UBFGInputScheme*                        M_pInputScheme;                                    // 0x03F0(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TMap<class FString, TSubclassOf<class ABFGCreditsLetter>> M_aLetterMap;                                      // 0x03F8(0x0050)(Edit, ZeroConstructor, Protected, UObjectWrapper, NativeAccessSpecifierProtected)
	float                                         M_fLineIntervalTime;                               // 0x0448(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         M_fLineSplineTravelTime;                           // 0x044C(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         M_fSpaceSize;                                      // 0x0450(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         M_fLetterSpacing;                                  // 0x0454(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TArray<class FString>                         M_aCreditStrings;                                  // 0x0458(0x0010)(ZeroConstructor, Transient, Protected, NativeAccessSpecifierProtected)
	TArray<class ABFGCreditsLine*>                M_aCreditLines;                                    // 0x0468(0x0010)(ZeroConstructor, Transient, Protected, NativeAccessSpecifierProtected)
	uint8                                         Pad_478[0x8];                                      // 0x0478(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"BFGCredits">();
	}
	static class ABFGCredits* GetDefaultObj()
	{
		return GetDefaultObjImpl<ABFGCredits>();
	}
};
static_assert(alignof(ABFGCredits) == 0x000008, "Wrong alignment on ABFGCredits");
static_assert(sizeof(ABFGCredits) == 0x000480, "Wrong size on ABFGCredits");
static_assert(offsetof(ABFGCredits, M_pCamera) == 0x0003D8, "Member 'ABFGCredits::M_pCamera' has a wrong offset!");
static_assert(offsetof(ABFGCredits, M_pStartPosition) == 0x0003E0, "Member 'ABFGCredits::M_pStartPosition' has a wrong offset!");
static_assert(offsetof(ABFGCredits, M_pCreditsSpline) == 0x0003E8, "Member 'ABFGCredits::M_pCreditsSpline' has a wrong offset!");
static_assert(offsetof(ABFGCredits, M_pInputScheme) == 0x0003F0, "Member 'ABFGCredits::M_pInputScheme' has a wrong offset!");
static_assert(offsetof(ABFGCredits, M_aLetterMap) == 0x0003F8, "Member 'ABFGCredits::M_aLetterMap' has a wrong offset!");
static_assert(offsetof(ABFGCredits, M_fLineIntervalTime) == 0x000448, "Member 'ABFGCredits::M_fLineIntervalTime' has a wrong offset!");
static_assert(offsetof(ABFGCredits, M_fLineSplineTravelTime) == 0x00044C, "Member 'ABFGCredits::M_fLineSplineTravelTime' has a wrong offset!");
static_assert(offsetof(ABFGCredits, M_fSpaceSize) == 0x000450, "Member 'ABFGCredits::M_fSpaceSize' has a wrong offset!");
static_assert(offsetof(ABFGCredits, M_fLetterSpacing) == 0x000454, "Member 'ABFGCredits::M_fLetterSpacing' has a wrong offset!");
static_assert(offsetof(ABFGCredits, M_aCreditStrings) == 0x000458, "Member 'ABFGCredits::M_aCreditStrings' has a wrong offset!");
static_assert(offsetof(ABFGCredits, M_aCreditLines) == 0x000468, "Member 'ABFGCredits::M_aCreditLines' has a wrong offset!");

// Class BFGCore.BFGWidget_GameOptions
// 0x0248 (0x0670 - 0x0428)
class UBFGWidget_GameOptions final : public UBFGWidget_GenericDialog
{
public:
	UMulticastDelegateProperty_                   M_OnOptionIntChanged;                              // 0x0428(0x0018)(ZeroConstructor, InstancedReference, NativeAccessSpecifierPublic)
	UMulticastDelegateProperty_                   M_OnOptionFloatChanged;                            // 0x0440(0x0018)(ZeroConstructor, InstancedReference, NativeAccessSpecifierPublic)
	UMulticastDelegateProperty_                   M_OnOptionKeyAssignmentChanged;                    // 0x0458(0x0018)(ZeroConstructor, InstancedReference, NativeAccessSpecifierPublic)
	UMulticastDelegateProperty_                   M_OnChangesAccepted;                               // 0x0470(0x0018)(ZeroConstructor, InstancedReference, NativeAccessSpecifierPublic)
	UMulticastDelegateProperty_                   M_OnChangesReset;                                  // 0x0488(0x0018)(ZeroConstructor, InstancedReference, NativeAccessSpecifierPublic)
	TArray<class UImage*>                         M_apContollerHints;                                // 0x04A0(0x0010)(Edit, BlueprintVisible, ExportObject, ZeroConstructor, ContainsInstancedReference, NativeAccessSpecifierPublic)
	TSoftClassPtr<class UClass>                   M_pDialogOptionClass_AssignKey;                    // 0x04B0(0x0028)(Edit, BlueprintVisible, BlueprintReadOnly, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TSoftClassPtr<class UClass>                   M_pDialogOptionClass_ComboBox;                     // 0x04D8(0x0028)(Edit, BlueprintVisible, BlueprintReadOnly, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TSoftClassPtr<class UClass>                   M_pDialogOptionClass_ComboBoxLanguage;             // 0x0500(0x0028)(Edit, BlueprintVisible, BlueprintReadOnly, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TSoftClassPtr<class UClass>                   M_pDialogOptionClass_Slider;                       // 0x0528(0x0028)(Edit, BlueprintVisible, BlueprintReadOnly, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TSoftClassPtr<class UClass>                   M_pDialogOptionClass_Selector;                     // 0x0550(0x0028)(Edit, BlueprintVisible, BlueprintReadOnly, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TSoftClassPtr<class UClass>                   M_pDialogOptionClass_Title;                        // 0x0578(0x0028)(Edit, BlueprintVisible, BlueprintReadOnly, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TSoftClassPtr<class UClass>                   M_pKeyAssignmentWindowClass;                       // 0x05A0(0x0028)(Edit, BlueprintVisible, BlueprintReadOnly, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TArray<TSoftClassPtr<class UClass>>           M_apGameOptionsCategoryClasses;                    // 0x05C8(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Protected, UObjectWrapper, NativeAccessSpecifierProtected)
	TSoftClassPtr<class UClass>                   M_pGameOptionsCategoryButtonClass;                 // 0x05D8(0x0028)(Edit, BlueprintVisible, BlueprintReadOnly, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TArray<class UBFGWidget_GameOptionsCategory*> M_apOptionsCategories;                             // 0x0600(0x0010)(ExportObject, ZeroConstructor, ContainsInstancedReference, Protected, NativeAccessSpecifierProtected)
	TMap<class FName, class UBFGWidget_DialogOption*> M_apAllOptions;                                    // 0x0610(0x0050)(ExportObject, ZeroConstructor, ContainsInstancedReference, Protected, NativeAccessSpecifierProtected)
	class UBFGWidget_KeyAssignmentWindow*         M_pKeyAssignWindow;                                // 0x0660(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_668[0x8];                                      // 0x0668(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void Action__DelegateSignature();
	void ActionOptionFloat__DelegateSignature(class FName _oOptionName, float _iOptionValue);
	void ActionOptionInt__DelegateSignature(class FName _oOptionName, int32 _iOptionValue);
	void AddCategoryButtonToLayout(class UBFGWidget_DialogOption_Customizable* _pCategory);
	void AddCategoryToLayout(class UBFGWidget_GameOptionsCategory* _pCategory);
	void AddKeyAssignmentWindowToLayout(class UBFGWidget_KeyAssignmentWindow* _pWindow);
	void OnCategoryEntrySelected(int32 _iIndex);
	void OnComboBoxOptionChanged(class UBFGWidget_DialogOption_ComboBox* _pComboBox);
	void OnKeyAssignmentBegin(class UBFGWidget_DialogOption_AssignKey* _pOption, const struct FKey& _oKey, int32 _iIndex);
	void OnKeyAssignmentDone();
	void OnResetButtonClicked();
	void OnSaveButtonClicked();
	void OnSelectorOptionChanged(class UBFGWidget_DialogOption_Selector* _pSelector);
	void OnSliderOptionChanged(class UBFGWidget_DialogOption_Slider* _pSlider);
	void PlayTestSampleSFX();
	void PlayTestSampleUI();
	void PlayTestSampleVoice();
	void RemoveKeyAssignmentWindowFromLayout();
	void SetCategoryLabel(const class FText& _strText);
	void ShowAcceptHint(bool _bShow);
	void ShowControllerHints(bool _bShow);
	void ShowEditHint(bool _bShow);
	void UpdateControllerHints(class UBFGWidget_DialogOption* _pOption);
	void UpdateEntry_KeyInput(class FName _oOptionName);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"BFGWidget_GameOptions">();
	}
	static class UBFGWidget_GameOptions* GetDefaultObj()
	{
		return GetDefaultObjImpl<UBFGWidget_GameOptions>();
	}
};
static_assert(alignof(UBFGWidget_GameOptions) == 0x000008, "Wrong alignment on UBFGWidget_GameOptions");
static_assert(sizeof(UBFGWidget_GameOptions) == 0x000670, "Wrong size on UBFGWidget_GameOptions");
static_assert(offsetof(UBFGWidget_GameOptions, M_OnOptionIntChanged) == 0x000428, "Member 'UBFGWidget_GameOptions::M_OnOptionIntChanged' has a wrong offset!");
static_assert(offsetof(UBFGWidget_GameOptions, M_OnOptionFloatChanged) == 0x000440, "Member 'UBFGWidget_GameOptions::M_OnOptionFloatChanged' has a wrong offset!");
static_assert(offsetof(UBFGWidget_GameOptions, M_OnOptionKeyAssignmentChanged) == 0x000458, "Member 'UBFGWidget_GameOptions::M_OnOptionKeyAssignmentChanged' has a wrong offset!");
static_assert(offsetof(UBFGWidget_GameOptions, M_OnChangesAccepted) == 0x000470, "Member 'UBFGWidget_GameOptions::M_OnChangesAccepted' has a wrong offset!");
static_assert(offsetof(UBFGWidget_GameOptions, M_OnChangesReset) == 0x000488, "Member 'UBFGWidget_GameOptions::M_OnChangesReset' has a wrong offset!");
static_assert(offsetof(UBFGWidget_GameOptions, M_apContollerHints) == 0x0004A0, "Member 'UBFGWidget_GameOptions::M_apContollerHints' has a wrong offset!");
static_assert(offsetof(UBFGWidget_GameOptions, M_pDialogOptionClass_AssignKey) == 0x0004B0, "Member 'UBFGWidget_GameOptions::M_pDialogOptionClass_AssignKey' has a wrong offset!");
static_assert(offsetof(UBFGWidget_GameOptions, M_pDialogOptionClass_ComboBox) == 0x0004D8, "Member 'UBFGWidget_GameOptions::M_pDialogOptionClass_ComboBox' has a wrong offset!");
static_assert(offsetof(UBFGWidget_GameOptions, M_pDialogOptionClass_ComboBoxLanguage) == 0x000500, "Member 'UBFGWidget_GameOptions::M_pDialogOptionClass_ComboBoxLanguage' has a wrong offset!");
static_assert(offsetof(UBFGWidget_GameOptions, M_pDialogOptionClass_Slider) == 0x000528, "Member 'UBFGWidget_GameOptions::M_pDialogOptionClass_Slider' has a wrong offset!");
static_assert(offsetof(UBFGWidget_GameOptions, M_pDialogOptionClass_Selector) == 0x000550, "Member 'UBFGWidget_GameOptions::M_pDialogOptionClass_Selector' has a wrong offset!");
static_assert(offsetof(UBFGWidget_GameOptions, M_pDialogOptionClass_Title) == 0x000578, "Member 'UBFGWidget_GameOptions::M_pDialogOptionClass_Title' has a wrong offset!");
static_assert(offsetof(UBFGWidget_GameOptions, M_pKeyAssignmentWindowClass) == 0x0005A0, "Member 'UBFGWidget_GameOptions::M_pKeyAssignmentWindowClass' has a wrong offset!");
static_assert(offsetof(UBFGWidget_GameOptions, M_apGameOptionsCategoryClasses) == 0x0005C8, "Member 'UBFGWidget_GameOptions::M_apGameOptionsCategoryClasses' has a wrong offset!");
static_assert(offsetof(UBFGWidget_GameOptions, M_pGameOptionsCategoryButtonClass) == 0x0005D8, "Member 'UBFGWidget_GameOptions::M_pGameOptionsCategoryButtonClass' has a wrong offset!");
static_assert(offsetof(UBFGWidget_GameOptions, M_apOptionsCategories) == 0x000600, "Member 'UBFGWidget_GameOptions::M_apOptionsCategories' has a wrong offset!");
static_assert(offsetof(UBFGWidget_GameOptions, M_apAllOptions) == 0x000610, "Member 'UBFGWidget_GameOptions::M_apAllOptions' has a wrong offset!");
static_assert(offsetof(UBFGWidget_GameOptions, M_pKeyAssignWindow) == 0x000660, "Member 'UBFGWidget_GameOptions::M_pKeyAssignWindow' has a wrong offset!");

// Class BFGCore.BFGAlertSpawnCaps
// 0x0048 (0x0070 - 0x0028)
class UBFGAlertSpawnCaps final : public UObject
{
public:
	class ABFGGameState*                          M_pGameState;                                      // 0x0028(0x0008)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UBFGAICombatMediator_NPCRegistry*       M_pNPCRegistry;                                    // 0x0030(0x0008)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UBFGAlertSystemManager*                 M_pAlertSystemManager;                             // 0x0038(0x0008)(ExportObject, ZeroConstructor, Transient, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UBFGTrafficLodManager*                  M_pTrafficLodManager;                              // 0x0040(0x0008)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UBFGTrafficCrowdManager*                M_pTrafficManager;                                 // 0x0048(0x0008)(ExportObject, ZeroConstructor, Transient, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class ABFGGameState*                          M_pGameStte;                                       // 0x0050(0x0008)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_58[0x18];                                      // 0x0058(0x0018)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"BFGAlertSpawnCaps">();
	}
	static class UBFGAlertSpawnCaps* GetDefaultObj()
	{
		return GetDefaultObjImpl<UBFGAlertSpawnCaps>();
	}
};
static_assert(alignof(UBFGAlertSpawnCaps) == 0x000008, "Wrong alignment on UBFGAlertSpawnCaps");
static_assert(sizeof(UBFGAlertSpawnCaps) == 0x000070, "Wrong size on UBFGAlertSpawnCaps");
static_assert(offsetof(UBFGAlertSpawnCaps, M_pGameState) == 0x000028, "Member 'UBFGAlertSpawnCaps::M_pGameState' has a wrong offset!");
static_assert(offsetof(UBFGAlertSpawnCaps, M_pNPCRegistry) == 0x000030, "Member 'UBFGAlertSpawnCaps::M_pNPCRegistry' has a wrong offset!");
static_assert(offsetof(UBFGAlertSpawnCaps, M_pAlertSystemManager) == 0x000038, "Member 'UBFGAlertSpawnCaps::M_pAlertSystemManager' has a wrong offset!");
static_assert(offsetof(UBFGAlertSpawnCaps, M_pTrafficLodManager) == 0x000040, "Member 'UBFGAlertSpawnCaps::M_pTrafficLodManager' has a wrong offset!");
static_assert(offsetof(UBFGAlertSpawnCaps, M_pTrafficManager) == 0x000048, "Member 'UBFGAlertSpawnCaps::M_pTrafficManager' has a wrong offset!");
static_assert(offsetof(UBFGAlertSpawnCaps, M_pGameStte) == 0x000050, "Member 'UBFGAlertSpawnCaps::M_pGameStte' has a wrong offset!");

// Class BFGCore.BFGAlertSpawnPositionHelper
// 0x0038 (0x0060 - 0x0028)
class UBFGAlertSpawnPositionHelper final : public UObject
{
public:
	class UBFGAlertSystemManager*                 M_pAlertSystemManager;                             // 0x0028(0x0008)(ExportObject, ZeroConstructor, Transient, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TArray<struct FBFGAlertSpawnPositionRequest>  M_aRequests;                                       // 0x0030(0x0010)(ZeroConstructor, Transient, Protected, NativeAccessSpecifierProtected)
	class UBFGVisibilityCheckerPool_Box*          M_pVisibilityCheckerPool;                          // 0x0040(0x0008)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	int32                                         M_iLastFoundRequestIndex;                          // 0x0048(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_4C[0x14];                                      // 0x004C(0x0014)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"BFGAlertSpawnPositionHelper">();
	}
	static class UBFGAlertSpawnPositionHelper* GetDefaultObj()
	{
		return GetDefaultObjImpl<UBFGAlertSpawnPositionHelper>();
	}
};
static_assert(alignof(UBFGAlertSpawnPositionHelper) == 0x000008, "Wrong alignment on UBFGAlertSpawnPositionHelper");
static_assert(sizeof(UBFGAlertSpawnPositionHelper) == 0x000060, "Wrong size on UBFGAlertSpawnPositionHelper");
static_assert(offsetof(UBFGAlertSpawnPositionHelper, M_pAlertSystemManager) == 0x000028, "Member 'UBFGAlertSpawnPositionHelper::M_pAlertSystemManager' has a wrong offset!");
static_assert(offsetof(UBFGAlertSpawnPositionHelper, M_aRequests) == 0x000030, "Member 'UBFGAlertSpawnPositionHelper::M_aRequests' has a wrong offset!");
static_assert(offsetof(UBFGAlertSpawnPositionHelper, M_pVisibilityCheckerPool) == 0x000040, "Member 'UBFGAlertSpawnPositionHelper::M_pVisibilityCheckerPool' has a wrong offset!");
static_assert(offsetof(UBFGAlertSpawnPositionHelper, M_iLastFoundRequestIndex) == 0x000048, "Member 'UBFGAlertSpawnPositionHelper::M_iLastFoundRequestIndex' has a wrong offset!");

// Class BFGCore.BFGCrowdLifeTaskNodeStrategyBase
// 0x0000 (0x0028 - 0x0028)
class UBFGCrowdLifeTaskNodeStrategyBase : public UObject
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"BFGCrowdLifeTaskNodeStrategyBase">();
	}
	static class UBFGCrowdLifeTaskNodeStrategyBase* GetDefaultObj()
	{
		return GetDefaultObjImpl<UBFGCrowdLifeTaskNodeStrategyBase>();
	}
};
static_assert(alignof(UBFGCrowdLifeTaskNodeStrategyBase) == 0x000008, "Wrong alignment on UBFGCrowdLifeTaskNodeStrategyBase");
static_assert(sizeof(UBFGCrowdLifeTaskNodeStrategyBase) == 0x000028, "Wrong size on UBFGCrowdLifeTaskNodeStrategyBase");

// Class BFGCore.BFGCrowdLifeTaskNodeStrategyLowRes
// 0x0000 (0x0028 - 0x0028)
class UBFGCrowdLifeTaskNodeStrategyLowRes final : public UBFGCrowdLifeTaskNodeStrategyBase
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"BFGCrowdLifeTaskNodeStrategyLowRes">();
	}
	static class UBFGCrowdLifeTaskNodeStrategyLowRes* GetDefaultObj()
	{
		return GetDefaultObjImpl<UBFGCrowdLifeTaskNodeStrategyLowRes>();
	}
};
static_assert(alignof(UBFGCrowdLifeTaskNodeStrategyLowRes) == 0x000008, "Wrong alignment on UBFGCrowdLifeTaskNodeStrategyLowRes");
static_assert(sizeof(UBFGCrowdLifeTaskNodeStrategyLowRes) == 0x000028, "Wrong size on UBFGCrowdLifeTaskNodeStrategyLowRes");

// Class BFGCore.BFGWeapon
// 0x0320 (0x06F8 - 0x03D8)
class ABFGWeapon : public AActor
{
public:
	uint8                                         Pad_3D8[0x8];                                      // 0x03D8(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	class UBFGActorComponent_CharacterPhysics*    M_pCharacterPhysicsComponent;                      // 0x03E0(0x0008)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, EditConst, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	UMulticastDelegateProperty_                   M_OnWeaponFireChanged;                             // 0x03E8(0x0018)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	UMulticastDelegateProperty_                   M_OnWeaponAmmoChanged;                             // 0x0400(0x0018)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	UMulticastDelegateProperty_                   M_OnReloadStarted;                                 // 0x0418(0x0018)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	UMulticastDelegateProperty_                   M_OnReloadDone;                                    // 0x0430(0x0018)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	uint8                                         Pad_448[0x8];                                      // 0x0448(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	UMulticastDelegateProperty_                   M_oEquipStateChanged;                              // 0x0450(0x0018)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	class UBFGActorComponent_Effect*              M_pEffectComponent;                                // 0x0468(0x0008)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, EditConst, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	struct FGameplayTagContainer                  M_gameplayTags;                                    // 0x0470(0x0020)(Edit, DisableEditOnInstance, Protected, NativeAccessSpecifierProtected)
	class FText                                   M_strName;                                         // 0x0490(0x0018)(Edit, Protected, NativeAccessSpecifierProtected)
	class FText                                   M_strDescription;                                  // 0x04A8(0x0018)(Edit, Protected, NativeAccessSpecifierProtected)
	EBFGAnimation_WeaponPosture                   M_animationPosture;                                // 0x04C0(0x0001)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          M_bGetsStuckoNEnvironment;                         // 0x04C1(0x0001)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_4C2[0x6];                                      // 0x04C2(0x0006)(Fixing Size After Last Property [ Dumper-7 ])
	class AActor*                                 M_pHolder;                                         // 0x04C8(0x0008)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UBFGActorComponent_EquipmentManager*    M_pEquipmentManager;                               // 0x04D0(0x0008)(ExportObject, ZeroConstructor, Transient, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_4D8[0x8];                                      // 0x04D8(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	class UBFGActorComponent_TargetSystem*        M_pOwnerTargetComponent;                           // 0x04E0(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class ABFGGameState*                          M_pGameState;                                      // 0x04E8(0x0008)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UBFGActorComponent_Animation*           M_pAnimationComponent;                             // 0x04F0(0x0008)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, EditConst, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UBFGActorComponent_PawnStats*           M_pHolderStatsComponent;                           // 0x04F8(0x0008)(ExportObject, ZeroConstructor, Transient, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UBFGActorComponent_Animation*           M_pHolderAnimationComponent;                       // 0x0500(0x0008)(ExportObject, ZeroConstructor, Transient, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	ECollisionChannel                             M_eEnemyAimCollisionChannel;                       // 0x0508(0x0001)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          M_bUsesPredictiveAiming;                           // 0x0509(0x0001)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          M_bIsAiming;                                       // 0x050A(0x0001)(Edit, ZeroConstructor, Transient, EditConst, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_50B[0x5];                                      // 0x050B(0x0005)(Fixing Size After Last Property [ Dumper-7 ])
	struct FSoftClassPath                         M_DecalClass;                                      // 0x0510(0x0018)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, Protected, NativeAccessSpecifierProtected)
	bool                                          M_bUsesAutoTargetSystem;                           // 0x0528(0x0001)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_529[0x3];                                      // 0x0529(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         M_fAutoTarget2DRangePercentage;                    // 0x052C(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         M_fAutoAimStickyMultiplier;                        // 0x0530(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          M_bIgnoresFoliage;                                 // 0x0534(0x0001)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_535[0x3];                                      // 0x0535(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	struct FVector                                M_fAimInaccuracy;                                  // 0x0538(0x000C)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         M_fBaseInaccuracy;                                 // 0x0544(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	struct FVector                                M_vOptinalDistanceInaccuracy;                      // 0x0548(0x000C)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	struct FVector                                M_vMaxDistanceInaccuracy;                          // 0x0554(0x000C)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class FName                                   M_oTargetBoneNameOverride;                         // 0x0560(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TArray<class AActor*>                         M_apCurrentLockedTargets;                          // 0x0568(0x0010)(ZeroConstructor, Transient, Protected, NativeAccessSpecifierProtected)
	TArray<class AActor*>                         M_apPreviousLockedTargets;                         // 0x0578(0x0010)(ZeroConstructor, Transient, Protected, NativeAccessSpecifierProtected)
	uint8                                         Pad_588[0xD0];                                     // 0x0588(0x00D0)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         M_fMaximumRangeAgainstGround;                      // 0x0658(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         M_fMaximumRangeAgainstAir;                         // 0x065C(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         M_fOptimalRangeAgainstGround;                      // 0x0660(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         M_fOptimalRangeAgainstAir;                         // 0x0664(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         M_fMinimalRangeAgainstGround;                      // 0x0668(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         M_fMinimalRangeAgainstAir;                         // 0x066C(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         M_fMaximumProjectileTravelDistanceAgainstGround;   // 0x0670(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         M_fMaximumProjectileTravelDistanceAgainstAir;      // 0x0674(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	EBFGGlobalCooldown                            M_globalCooldown;                                  // 0x0678(0x0001)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          M_bRequiresLoS;                                    // 0x0679(0x0001)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_67A[0x2];                                      // 0x067A(0x0002)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         M_fEquipTime;                                      // 0x067C(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_680[0x8];                                      // 0x0680(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	bool                                          M_bAllowRepeatFireLoops;                           // 0x0688(0x0001)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          M_bCanRequestFireWhenNotReady;                     // 0x0689(0x0001)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_68A[0x2];                                      // 0x068A(0x0002)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         M_fHitActorOnFireImpulseStrength;                  // 0x068C(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_690[0x8];                                      // 0x0690(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	bool                                          M_bAutoReload;                                     // 0x0698(0x0001)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_699[0x3];                                      // 0x0699(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         M_fReloadTime;                                     // 0x069C(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	int32                                         M_iShotsPerReloadCount;                            // 0x06A0(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_6A4[0xC];                                      // 0x06A4(0x000C)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         M_fTelegraphTime;                                  // 0x06B0(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_6B4[0x4];                                      // 0x06B4(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         M_fHoldTime;                                       // 0x06B8(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_6BC[0x8];                                      // 0x06BC(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         M_fChargeTime;                                     // 0x06C4(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	int32                                         M_iMaxChargeCount;                                 // 0x06C8(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_6CC[0x8];                                      // 0x06CC(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         M_fCrossHairWidgetMax;                             // 0x06D4(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         M_fCrossHairWidgetMin;                             // 0x06D8(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         M_fCrossHairDistanceScale;                         // 0x06DC(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TSubclassOf<class UUserWidget>                M_CrosshairWidget;                                 // 0x06E0(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          M_bHideCrosshair;                                  // 0x06E8(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_6E9[0x7];                                      // 0x06E9(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	class UUserWidget*                            M_CrosshairInstance;                               // 0x06F0(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, Transient, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)

public:
	void AbortReload();
	EWeaponFireAttemptResult CanStartWeapon();
	void Disable();
	void DisplayTargetDecal(const struct FVector& Position, float Radius, float _fStartDelay, float _fDuration);
	void Enable();
	int32 GetAvailableMaximumShotCount();
	int32 GetAvailableShotCount();
	float GetAvailableShotRatio();
	struct FVector GetMuzzleLocation();
	void HitReaction(class AActor* _pOwner, class AActor* _pDamageCauser, class UBFGDamageType* _pDamageType, class APawn* _pInstigator);
	void OnDisable();
	void OnEnable();
	void OnFailedFireAttempt(EWeaponFireAttemptResult _weaponFireResult);
	void OnHitReaction(class AActor* _pDamageCauser, class APawn* _pInstigator);
	void OnHoldEnd();
	void OnHoldStart();
	void OnReloadEnd();
	void OnReloadStart();
	void OnShotImpact(const struct FHitResult& _oHitResult);
	void OnStartedFire();
	void OnStoppedFire();
	void OnTelegraphEnd();
	void OnTelegraphStart();
	void OnWeaponFire(class FName _nSocketName);
	void SetAddedReloadTimeFactor(float _fReloadTimeFactor);
	void SetAiming(bool _bAiming, float _fStopAimingDelay);
	void SetEquipmentManager(class UBFGActorComponent_EquipmentManager* _pManager);
	void SetHolder(class AActor* _pHolder);
	void SetRequestWeaponFire(bool _bRequestFireEnabled);
	void SetWidgetVisibility(ESlateVisibility _eVisibility);
	void TriggerReload();

	float GetAmmoRatio() const;
	EBFGAnimation_WeaponPosture GetAnimPosture() const;
	class ABFGGameState* GetBFGGameState() const;
	struct FCharacterAimData GetCurrentAimData() const;
	class AActor* GetCurrentLocketTarget() const;
	float GetEquipTime() const;
	class AActor* GetFirstAutolockedTarget() const;
	class AActor* GetHolderSafe() const;
	bool GetIsDisabled() const;
	float GetMaximumRange(class AActor* _pTarget) const;
	float GetMinimalRange(class AActor* _pTarget) const;
	float GetOptimalRange(class AActor* _pTarget) const;
	float GetProjectileRange(class AActor* _pTarget) const;
	float GetReloadTime() const;
	float GetTimeReloading() const;
	const class FText GetWeaponName() const;
	bool IsAiming() const;
	bool IsEquip() const;
	bool IsHolding() const;
	bool IsOverheated() const;
	bool IsReloading() const;
	bool IsRequestWeaponFireEnabled() const;
	bool IsShooting() const;
	bool IsTelegraphing() const;
	void TrySetHitActorOnFire(const struct FHitResult& _hitResult) const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"BFGWeapon">();
	}
	static class ABFGWeapon* GetDefaultObj()
	{
		return GetDefaultObjImpl<ABFGWeapon>();
	}
};
static_assert(alignof(ABFGWeapon) == 0x000008, "Wrong alignment on ABFGWeapon");
static_assert(sizeof(ABFGWeapon) == 0x0006F8, "Wrong size on ABFGWeapon");
static_assert(offsetof(ABFGWeapon, M_pCharacterPhysicsComponent) == 0x0003E0, "Member 'ABFGWeapon::M_pCharacterPhysicsComponent' has a wrong offset!");
static_assert(offsetof(ABFGWeapon, M_OnWeaponFireChanged) == 0x0003E8, "Member 'ABFGWeapon::M_OnWeaponFireChanged' has a wrong offset!");
static_assert(offsetof(ABFGWeapon, M_OnWeaponAmmoChanged) == 0x000400, "Member 'ABFGWeapon::M_OnWeaponAmmoChanged' has a wrong offset!");
static_assert(offsetof(ABFGWeapon, M_OnReloadStarted) == 0x000418, "Member 'ABFGWeapon::M_OnReloadStarted' has a wrong offset!");
static_assert(offsetof(ABFGWeapon, M_OnReloadDone) == 0x000430, "Member 'ABFGWeapon::M_OnReloadDone' has a wrong offset!");
static_assert(offsetof(ABFGWeapon, M_oEquipStateChanged) == 0x000450, "Member 'ABFGWeapon::M_oEquipStateChanged' has a wrong offset!");
static_assert(offsetof(ABFGWeapon, M_pEffectComponent) == 0x000468, "Member 'ABFGWeapon::M_pEffectComponent' has a wrong offset!");
static_assert(offsetof(ABFGWeapon, M_gameplayTags) == 0x000470, "Member 'ABFGWeapon::M_gameplayTags' has a wrong offset!");
static_assert(offsetof(ABFGWeapon, M_strName) == 0x000490, "Member 'ABFGWeapon::M_strName' has a wrong offset!");
static_assert(offsetof(ABFGWeapon, M_strDescription) == 0x0004A8, "Member 'ABFGWeapon::M_strDescription' has a wrong offset!");
static_assert(offsetof(ABFGWeapon, M_animationPosture) == 0x0004C0, "Member 'ABFGWeapon::M_animationPosture' has a wrong offset!");
static_assert(offsetof(ABFGWeapon, M_bGetsStuckoNEnvironment) == 0x0004C1, "Member 'ABFGWeapon::M_bGetsStuckoNEnvironment' has a wrong offset!");
static_assert(offsetof(ABFGWeapon, M_pHolder) == 0x0004C8, "Member 'ABFGWeapon::M_pHolder' has a wrong offset!");
static_assert(offsetof(ABFGWeapon, M_pEquipmentManager) == 0x0004D0, "Member 'ABFGWeapon::M_pEquipmentManager' has a wrong offset!");
static_assert(offsetof(ABFGWeapon, M_pOwnerTargetComponent) == 0x0004E0, "Member 'ABFGWeapon::M_pOwnerTargetComponent' has a wrong offset!");
static_assert(offsetof(ABFGWeapon, M_pGameState) == 0x0004E8, "Member 'ABFGWeapon::M_pGameState' has a wrong offset!");
static_assert(offsetof(ABFGWeapon, M_pAnimationComponent) == 0x0004F0, "Member 'ABFGWeapon::M_pAnimationComponent' has a wrong offset!");
static_assert(offsetof(ABFGWeapon, M_pHolderStatsComponent) == 0x0004F8, "Member 'ABFGWeapon::M_pHolderStatsComponent' has a wrong offset!");
static_assert(offsetof(ABFGWeapon, M_pHolderAnimationComponent) == 0x000500, "Member 'ABFGWeapon::M_pHolderAnimationComponent' has a wrong offset!");
static_assert(offsetof(ABFGWeapon, M_eEnemyAimCollisionChannel) == 0x000508, "Member 'ABFGWeapon::M_eEnemyAimCollisionChannel' has a wrong offset!");
static_assert(offsetof(ABFGWeapon, M_bUsesPredictiveAiming) == 0x000509, "Member 'ABFGWeapon::M_bUsesPredictiveAiming' has a wrong offset!");
static_assert(offsetof(ABFGWeapon, M_bIsAiming) == 0x00050A, "Member 'ABFGWeapon::M_bIsAiming' has a wrong offset!");
static_assert(offsetof(ABFGWeapon, M_DecalClass) == 0x000510, "Member 'ABFGWeapon::M_DecalClass' has a wrong offset!");
static_assert(offsetof(ABFGWeapon, M_bUsesAutoTargetSystem) == 0x000528, "Member 'ABFGWeapon::M_bUsesAutoTargetSystem' has a wrong offset!");
static_assert(offsetof(ABFGWeapon, M_fAutoTarget2DRangePercentage) == 0x00052C, "Member 'ABFGWeapon::M_fAutoTarget2DRangePercentage' has a wrong offset!");
static_assert(offsetof(ABFGWeapon, M_fAutoAimStickyMultiplier) == 0x000530, "Member 'ABFGWeapon::M_fAutoAimStickyMultiplier' has a wrong offset!");
static_assert(offsetof(ABFGWeapon, M_bIgnoresFoliage) == 0x000534, "Member 'ABFGWeapon::M_bIgnoresFoliage' has a wrong offset!");
static_assert(offsetof(ABFGWeapon, M_fAimInaccuracy) == 0x000538, "Member 'ABFGWeapon::M_fAimInaccuracy' has a wrong offset!");
static_assert(offsetof(ABFGWeapon, M_fBaseInaccuracy) == 0x000544, "Member 'ABFGWeapon::M_fBaseInaccuracy' has a wrong offset!");
static_assert(offsetof(ABFGWeapon, M_vOptinalDistanceInaccuracy) == 0x000548, "Member 'ABFGWeapon::M_vOptinalDistanceInaccuracy' has a wrong offset!");
static_assert(offsetof(ABFGWeapon, M_vMaxDistanceInaccuracy) == 0x000554, "Member 'ABFGWeapon::M_vMaxDistanceInaccuracy' has a wrong offset!");
static_assert(offsetof(ABFGWeapon, M_oTargetBoneNameOverride) == 0x000560, "Member 'ABFGWeapon::M_oTargetBoneNameOverride' has a wrong offset!");
static_assert(offsetof(ABFGWeapon, M_apCurrentLockedTargets) == 0x000568, "Member 'ABFGWeapon::M_apCurrentLockedTargets' has a wrong offset!");
static_assert(offsetof(ABFGWeapon, M_apPreviousLockedTargets) == 0x000578, "Member 'ABFGWeapon::M_apPreviousLockedTargets' has a wrong offset!");
static_assert(offsetof(ABFGWeapon, M_fMaximumRangeAgainstGround) == 0x000658, "Member 'ABFGWeapon::M_fMaximumRangeAgainstGround' has a wrong offset!");
static_assert(offsetof(ABFGWeapon, M_fMaximumRangeAgainstAir) == 0x00065C, "Member 'ABFGWeapon::M_fMaximumRangeAgainstAir' has a wrong offset!");
static_assert(offsetof(ABFGWeapon, M_fOptimalRangeAgainstGround) == 0x000660, "Member 'ABFGWeapon::M_fOptimalRangeAgainstGround' has a wrong offset!");
static_assert(offsetof(ABFGWeapon, M_fOptimalRangeAgainstAir) == 0x000664, "Member 'ABFGWeapon::M_fOptimalRangeAgainstAir' has a wrong offset!");
static_assert(offsetof(ABFGWeapon, M_fMinimalRangeAgainstGround) == 0x000668, "Member 'ABFGWeapon::M_fMinimalRangeAgainstGround' has a wrong offset!");
static_assert(offsetof(ABFGWeapon, M_fMinimalRangeAgainstAir) == 0x00066C, "Member 'ABFGWeapon::M_fMinimalRangeAgainstAir' has a wrong offset!");
static_assert(offsetof(ABFGWeapon, M_fMaximumProjectileTravelDistanceAgainstGround) == 0x000670, "Member 'ABFGWeapon::M_fMaximumProjectileTravelDistanceAgainstGround' has a wrong offset!");
static_assert(offsetof(ABFGWeapon, M_fMaximumProjectileTravelDistanceAgainstAir) == 0x000674, "Member 'ABFGWeapon::M_fMaximumProjectileTravelDistanceAgainstAir' has a wrong offset!");
static_assert(offsetof(ABFGWeapon, M_globalCooldown) == 0x000678, "Member 'ABFGWeapon::M_globalCooldown' has a wrong offset!");
static_assert(offsetof(ABFGWeapon, M_bRequiresLoS) == 0x000679, "Member 'ABFGWeapon::M_bRequiresLoS' has a wrong offset!");
static_assert(offsetof(ABFGWeapon, M_fEquipTime) == 0x00067C, "Member 'ABFGWeapon::M_fEquipTime' has a wrong offset!");
static_assert(offsetof(ABFGWeapon, M_bAllowRepeatFireLoops) == 0x000688, "Member 'ABFGWeapon::M_bAllowRepeatFireLoops' has a wrong offset!");
static_assert(offsetof(ABFGWeapon, M_bCanRequestFireWhenNotReady) == 0x000689, "Member 'ABFGWeapon::M_bCanRequestFireWhenNotReady' has a wrong offset!");
static_assert(offsetof(ABFGWeapon, M_fHitActorOnFireImpulseStrength) == 0x00068C, "Member 'ABFGWeapon::M_fHitActorOnFireImpulseStrength' has a wrong offset!");
static_assert(offsetof(ABFGWeapon, M_bAutoReload) == 0x000698, "Member 'ABFGWeapon::M_bAutoReload' has a wrong offset!");
static_assert(offsetof(ABFGWeapon, M_fReloadTime) == 0x00069C, "Member 'ABFGWeapon::M_fReloadTime' has a wrong offset!");
static_assert(offsetof(ABFGWeapon, M_iShotsPerReloadCount) == 0x0006A0, "Member 'ABFGWeapon::M_iShotsPerReloadCount' has a wrong offset!");
static_assert(offsetof(ABFGWeapon, M_fTelegraphTime) == 0x0006B0, "Member 'ABFGWeapon::M_fTelegraphTime' has a wrong offset!");
static_assert(offsetof(ABFGWeapon, M_fHoldTime) == 0x0006B8, "Member 'ABFGWeapon::M_fHoldTime' has a wrong offset!");
static_assert(offsetof(ABFGWeapon, M_fChargeTime) == 0x0006C4, "Member 'ABFGWeapon::M_fChargeTime' has a wrong offset!");
static_assert(offsetof(ABFGWeapon, M_iMaxChargeCount) == 0x0006C8, "Member 'ABFGWeapon::M_iMaxChargeCount' has a wrong offset!");
static_assert(offsetof(ABFGWeapon, M_fCrossHairWidgetMax) == 0x0006D4, "Member 'ABFGWeapon::M_fCrossHairWidgetMax' has a wrong offset!");
static_assert(offsetof(ABFGWeapon, M_fCrossHairWidgetMin) == 0x0006D8, "Member 'ABFGWeapon::M_fCrossHairWidgetMin' has a wrong offset!");
static_assert(offsetof(ABFGWeapon, M_fCrossHairDistanceScale) == 0x0006DC, "Member 'ABFGWeapon::M_fCrossHairDistanceScale' has a wrong offset!");
static_assert(offsetof(ABFGWeapon, M_CrosshairWidget) == 0x0006E0, "Member 'ABFGWeapon::M_CrosshairWidget' has a wrong offset!");
static_assert(offsetof(ABFGWeapon, M_bHideCrosshair) == 0x0006E8, "Member 'ABFGWeapon::M_bHideCrosshair' has a wrong offset!");
static_assert(offsetof(ABFGWeapon, M_CrosshairInstance) == 0x0006F0, "Member 'ABFGWeapon::M_CrosshairInstance' has a wrong offset!");

// Class BFGCore.BFGWeapon_BaseProjectile
// 0x0058 (0x0750 - 0x06F8)
class ABFGWeapon_BaseProjectile : public ABFGWeapon
{
public:
	struct FSoftClassPath                         M_ProjectileClass;                                 // 0x06F8(0x0018)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, Protected, NativeAccessSpecifierProtected)
	class UClass*                                 M_pCachedProjectileClass;                          // 0x0710(0x0008)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	int32                                         M_iMaximumAmmo;                                    // 0x0718(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	int32                                         M_iDefaultAmmo;                                    // 0x071C(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         M_fAmmoConsumedPerShot;                            // 0x0720(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         M_fAmmoShotsDelay;                                 // 0x0724(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         M_fTimeTillAmmoShot;                               // 0x0728(0x0004)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_72C[0x4];                                      // 0x072C(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<class FName>                           M_aBulletSocketList;                               // 0x0730(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, Protected, NativeAccessSpecifierProtected)
	uint8                                         Pad_740[0x4];                                      // 0x0740(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	bool                                          M_bFavorLowArcs;                                   // 0x0744(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_745[0x3];                                      // 0x0745(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         M_fPredictionDelay;                                // 0x0748(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          M_bTargetAimingAtLocation;                         // 0x074C(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_74D[0x3];                                      // 0x074D(0x0003)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void OnShootProjectile(class ABFGProjectile_Object* _pProjectile);
	void OnShootProjectileWave();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"BFGWeapon_BaseProjectile">();
	}
	static class ABFGWeapon_BaseProjectile* GetDefaultObj()
	{
		return GetDefaultObjImpl<ABFGWeapon_BaseProjectile>();
	}
};
static_assert(alignof(ABFGWeapon_BaseProjectile) == 0x000008, "Wrong alignment on ABFGWeapon_BaseProjectile");
static_assert(sizeof(ABFGWeapon_BaseProjectile) == 0x000750, "Wrong size on ABFGWeapon_BaseProjectile");
static_assert(offsetof(ABFGWeapon_BaseProjectile, M_ProjectileClass) == 0x0006F8, "Member 'ABFGWeapon_BaseProjectile::M_ProjectileClass' has a wrong offset!");
static_assert(offsetof(ABFGWeapon_BaseProjectile, M_pCachedProjectileClass) == 0x000710, "Member 'ABFGWeapon_BaseProjectile::M_pCachedProjectileClass' has a wrong offset!");
static_assert(offsetof(ABFGWeapon_BaseProjectile, M_iMaximumAmmo) == 0x000718, "Member 'ABFGWeapon_BaseProjectile::M_iMaximumAmmo' has a wrong offset!");
static_assert(offsetof(ABFGWeapon_BaseProjectile, M_iDefaultAmmo) == 0x00071C, "Member 'ABFGWeapon_BaseProjectile::M_iDefaultAmmo' has a wrong offset!");
static_assert(offsetof(ABFGWeapon_BaseProjectile, M_fAmmoConsumedPerShot) == 0x000720, "Member 'ABFGWeapon_BaseProjectile::M_fAmmoConsumedPerShot' has a wrong offset!");
static_assert(offsetof(ABFGWeapon_BaseProjectile, M_fAmmoShotsDelay) == 0x000724, "Member 'ABFGWeapon_BaseProjectile::M_fAmmoShotsDelay' has a wrong offset!");
static_assert(offsetof(ABFGWeapon_BaseProjectile, M_fTimeTillAmmoShot) == 0x000728, "Member 'ABFGWeapon_BaseProjectile::M_fTimeTillAmmoShot' has a wrong offset!");
static_assert(offsetof(ABFGWeapon_BaseProjectile, M_aBulletSocketList) == 0x000730, "Member 'ABFGWeapon_BaseProjectile::M_aBulletSocketList' has a wrong offset!");
static_assert(offsetof(ABFGWeapon_BaseProjectile, M_bFavorLowArcs) == 0x000744, "Member 'ABFGWeapon_BaseProjectile::M_bFavorLowArcs' has a wrong offset!");
static_assert(offsetof(ABFGWeapon_BaseProjectile, M_fPredictionDelay) == 0x000748, "Member 'ABFGWeapon_BaseProjectile::M_fPredictionDelay' has a wrong offset!");
static_assert(offsetof(ABFGWeapon_BaseProjectile, M_bTargetAimingAtLocation) == 0x00074C, "Member 'ABFGWeapon_BaseProjectile::M_bTargetAimingAtLocation' has a wrong offset!");

// Class BFGCore.BFGWeapon_Enemy
// 0x0100 (0x0850 - 0x0750)
class ABFGWeapon_Enemy : public ABFGWeapon_BaseProjectile
{
public:
	int32                                         M_iMinimumShotsPerSalvo;                           // 0x0750(0x0004)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	int32                                         M_iMaximumShotsPerSalvo;                           // 0x0754(0x0004)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         M_fTimeBetweenSalvoShots;                          // 0x0758(0x0004)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_75C[0x8];                                      // 0x075C(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         M_fMinimumPitch;                                   // 0x0764(0x0004)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         M_fMaxmimumPitch;                                  // 0x0768(0x0004)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         M_fAimTargetFollowSpeedIdle;                       // 0x076C(0x0004)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         M_fAimTargetFollowSpeedShooting;                   // 0x0770(0x0004)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         M_fAimTargetFollowSpeedReloading;                  // 0x0774(0x0004)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         M_fAimTargetFollowSpeedTelegraphing;               // 0x0778(0x0004)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          M_bUseCatchUpFocus;                                // 0x077C(0x0001)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          M_bUseRelativeAimTargetFollowRotation;             // 0x077D(0x0001)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_77E[0x2];                                      // 0x077E(0x0002)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         M_fMaxAimRotationOffsetForFire;                    // 0x0780(0x0004)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_784[0x4];                                      // 0x0784(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class UCurveFloat*                            M_pTargetVelocitySpeedCurve;                       // 0x0788(0x0008)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          M_bFirelineDynamicObstacle;                        // 0x0790(0x0001)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_791[0x3];                                      // 0x0791(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         M_fFirelineDynamicObstacleWidth;                   // 0x0794(0x0004)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         M_fFirelineDynamicObstacleHeight;                  // 0x0798(0x0004)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          M_bAOEDynamicObstacle;                             // 0x079C(0x0001)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_79D[0x3];                                      // 0x079D(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         M_fAOEDynamicObstacleRadius;                       // 0x07A0(0x0004)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         M_fAOEDynamicObstacleLifetime;                     // 0x07A4(0x0004)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_7A8[0x10];                                     // 0x07A8(0x0010)(Fixing Size After Last Property [ Dumper-7 ])
	class AActor*                                 M_pAimTarget;                                      // 0x07B8(0x0008)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_7C0[0x10];                                     // 0x07C0(0x0010)(Fixing Size After Last Property [ Dumper-7 ])
	class UCharacterMovementComponent*            M_pAimTargetMovementComponent;                     // 0x07D0(0x0008)(ExportObject, ZeroConstructor, Transient, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UBFGAICombatMediator_TargetTracker*     M_pTargetTracker;                                  // 0x07D8(0x0008)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_7E0[0x40];                                     // 0x07E0(0x0040)(Fixing Size After Last Property [ Dumper-7 ])
	TSubclassOf<class UNavAreaBase>               M_pNavAreaClass;                                   // 0x0820(0x0008)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UBFGDynamicObstaclePool_Sphere*         M_pDynamicObstaclePool_Sphere;                     // 0x0828(0x0008)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TArray<struct FBFGWeaponObstacle>             M_apDyanamicObstacles_Sphere;                      // 0x0830(0x0010)(ZeroConstructor, Transient, Protected, NativeAccessSpecifierProtected)
	class UBFGDynamicObstaclePool_Box*            M_pDynamicObstaclePool_Box;                        // 0x0840(0x0008)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class ABFGDynamicObstacle_Box*                M_pFirelineObstacle;                               // 0x0848(0x0008)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)

public:
	void OnSalvoEnded();

	bool IsBusyFiringSalvo() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"BFGWeapon_Enemy">();
	}
	static class ABFGWeapon_Enemy* GetDefaultObj()
	{
		return GetDefaultObjImpl<ABFGWeapon_Enemy>();
	}
};
static_assert(alignof(ABFGWeapon_Enemy) == 0x000008, "Wrong alignment on ABFGWeapon_Enemy");
static_assert(sizeof(ABFGWeapon_Enemy) == 0x000850, "Wrong size on ABFGWeapon_Enemy");
static_assert(offsetof(ABFGWeapon_Enemy, M_iMinimumShotsPerSalvo) == 0x000750, "Member 'ABFGWeapon_Enemy::M_iMinimumShotsPerSalvo' has a wrong offset!");
static_assert(offsetof(ABFGWeapon_Enemy, M_iMaximumShotsPerSalvo) == 0x000754, "Member 'ABFGWeapon_Enemy::M_iMaximumShotsPerSalvo' has a wrong offset!");
static_assert(offsetof(ABFGWeapon_Enemy, M_fTimeBetweenSalvoShots) == 0x000758, "Member 'ABFGWeapon_Enemy::M_fTimeBetweenSalvoShots' has a wrong offset!");
static_assert(offsetof(ABFGWeapon_Enemy, M_fMinimumPitch) == 0x000764, "Member 'ABFGWeapon_Enemy::M_fMinimumPitch' has a wrong offset!");
static_assert(offsetof(ABFGWeapon_Enemy, M_fMaxmimumPitch) == 0x000768, "Member 'ABFGWeapon_Enemy::M_fMaxmimumPitch' has a wrong offset!");
static_assert(offsetof(ABFGWeapon_Enemy, M_fAimTargetFollowSpeedIdle) == 0x00076C, "Member 'ABFGWeapon_Enemy::M_fAimTargetFollowSpeedIdle' has a wrong offset!");
static_assert(offsetof(ABFGWeapon_Enemy, M_fAimTargetFollowSpeedShooting) == 0x000770, "Member 'ABFGWeapon_Enemy::M_fAimTargetFollowSpeedShooting' has a wrong offset!");
static_assert(offsetof(ABFGWeapon_Enemy, M_fAimTargetFollowSpeedReloading) == 0x000774, "Member 'ABFGWeapon_Enemy::M_fAimTargetFollowSpeedReloading' has a wrong offset!");
static_assert(offsetof(ABFGWeapon_Enemy, M_fAimTargetFollowSpeedTelegraphing) == 0x000778, "Member 'ABFGWeapon_Enemy::M_fAimTargetFollowSpeedTelegraphing' has a wrong offset!");
static_assert(offsetof(ABFGWeapon_Enemy, M_bUseCatchUpFocus) == 0x00077C, "Member 'ABFGWeapon_Enemy::M_bUseCatchUpFocus' has a wrong offset!");
static_assert(offsetof(ABFGWeapon_Enemy, M_bUseRelativeAimTargetFollowRotation) == 0x00077D, "Member 'ABFGWeapon_Enemy::M_bUseRelativeAimTargetFollowRotation' has a wrong offset!");
static_assert(offsetof(ABFGWeapon_Enemy, M_fMaxAimRotationOffsetForFire) == 0x000780, "Member 'ABFGWeapon_Enemy::M_fMaxAimRotationOffsetForFire' has a wrong offset!");
static_assert(offsetof(ABFGWeapon_Enemy, M_pTargetVelocitySpeedCurve) == 0x000788, "Member 'ABFGWeapon_Enemy::M_pTargetVelocitySpeedCurve' has a wrong offset!");
static_assert(offsetof(ABFGWeapon_Enemy, M_bFirelineDynamicObstacle) == 0x000790, "Member 'ABFGWeapon_Enemy::M_bFirelineDynamicObstacle' has a wrong offset!");
static_assert(offsetof(ABFGWeapon_Enemy, M_fFirelineDynamicObstacleWidth) == 0x000794, "Member 'ABFGWeapon_Enemy::M_fFirelineDynamicObstacleWidth' has a wrong offset!");
static_assert(offsetof(ABFGWeapon_Enemy, M_fFirelineDynamicObstacleHeight) == 0x000798, "Member 'ABFGWeapon_Enemy::M_fFirelineDynamicObstacleHeight' has a wrong offset!");
static_assert(offsetof(ABFGWeapon_Enemy, M_bAOEDynamicObstacle) == 0x00079C, "Member 'ABFGWeapon_Enemy::M_bAOEDynamicObstacle' has a wrong offset!");
static_assert(offsetof(ABFGWeapon_Enemy, M_fAOEDynamicObstacleRadius) == 0x0007A0, "Member 'ABFGWeapon_Enemy::M_fAOEDynamicObstacleRadius' has a wrong offset!");
static_assert(offsetof(ABFGWeapon_Enemy, M_fAOEDynamicObstacleLifetime) == 0x0007A4, "Member 'ABFGWeapon_Enemy::M_fAOEDynamicObstacleLifetime' has a wrong offset!");
static_assert(offsetof(ABFGWeapon_Enemy, M_pAimTarget) == 0x0007B8, "Member 'ABFGWeapon_Enemy::M_pAimTarget' has a wrong offset!");
static_assert(offsetof(ABFGWeapon_Enemy, M_pAimTargetMovementComponent) == 0x0007D0, "Member 'ABFGWeapon_Enemy::M_pAimTargetMovementComponent' has a wrong offset!");
static_assert(offsetof(ABFGWeapon_Enemy, M_pTargetTracker) == 0x0007D8, "Member 'ABFGWeapon_Enemy::M_pTargetTracker' has a wrong offset!");
static_assert(offsetof(ABFGWeapon_Enemy, M_pNavAreaClass) == 0x000820, "Member 'ABFGWeapon_Enemy::M_pNavAreaClass' has a wrong offset!");
static_assert(offsetof(ABFGWeapon_Enemy, M_pDynamicObstaclePool_Sphere) == 0x000828, "Member 'ABFGWeapon_Enemy::M_pDynamicObstaclePool_Sphere' has a wrong offset!");
static_assert(offsetof(ABFGWeapon_Enemy, M_apDyanamicObstacles_Sphere) == 0x000830, "Member 'ABFGWeapon_Enemy::M_apDyanamicObstacles_Sphere' has a wrong offset!");
static_assert(offsetof(ABFGWeapon_Enemy, M_pDynamicObstaclePool_Box) == 0x000840, "Member 'ABFGWeapon_Enemy::M_pDynamicObstaclePool_Box' has a wrong offset!");
static_assert(offsetof(ABFGWeapon_Enemy, M_pFirelineObstacle) == 0x000848, "Member 'ABFGWeapon_Enemy::M_pFirelineObstacle' has a wrong offset!");

// Class BFGCore.BFGWeapon_MindLinkProtectiveBubble
// 0x0008 (0x0858 - 0x0850)
class ABFGWeapon_MindLinkProtectiveBubble final : public ABFGWeapon_Enemy
{
public:
	class ABFGProjectile_MindLinkProtectiveBubble* M_pCurrentBubble;                                  // 0x0850(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"BFGWeapon_MindLinkProtectiveBubble">();
	}
	static class ABFGWeapon_MindLinkProtectiveBubble* GetDefaultObj()
	{
		return GetDefaultObjImpl<ABFGWeapon_MindLinkProtectiveBubble>();
	}
};
static_assert(alignof(ABFGWeapon_MindLinkProtectiveBubble) == 0x000008, "Wrong alignment on ABFGWeapon_MindLinkProtectiveBubble");
static_assert(sizeof(ABFGWeapon_MindLinkProtectiveBubble) == 0x000858, "Wrong size on ABFGWeapon_MindLinkProtectiveBubble");
static_assert(offsetof(ABFGWeapon_MindLinkProtectiveBubble, M_pCurrentBubble) == 0x000850, "Member 'ABFGWeapon_MindLinkProtectiveBubble::M_pCurrentBubble' has a wrong offset!");

// Class BFGCore.BFGAlertSystemDebug
// 0x0078 (0x00A0 - 0x0028)
class UBFGAlertSystemDebug final : public UObject
{
public:
	class UBFGAlertSystemManager*                 M_pAlertSystem;                                    // 0x0028(0x0008)(ExportObject, ZeroConstructor, Transient, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          M_bDisplayAlertEventLog;                           // 0x0030(0x0001)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          M_bDisplayAlertEventCooldDowns;                    // 0x0031(0x0001)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          M_bDisplayAlertDespawns;                           // 0x0032(0x0001)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          M_bDetailedResponseLevelInfo;                      // 0x0033(0x0001)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_34[0x4];                                       // 0x0034(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	struct FBFGResponseLevelDebugInfo             M_responseLevelDebugInfo;                          // 0x0038(0x0030)(Transient, Protected, NativeAccessSpecifierProtected)
	TArray<struct FBFGAlertEventLogItem>          M_aAlertEventsLog;                                 // 0x0068(0x0010)(ZeroConstructor, Transient, Protected, NativeAccessSpecifierProtected)
	int32                                         M_iMaxAlertEventsInLog;                            // 0x0078(0x0004)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_7C[0x4];                                       // 0x007C(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<struct FBFGAlertEventCoolDownsDebugInfo> M_aAlertEventsCoolDownDebugInfo;                   // 0x0080(0x0010)(ZeroConstructor, Transient, Protected, NativeAccessSpecifierProtected)
	TArray<class FString>                         M_aStrDespawnLog;                                  // 0x0090(0x0010)(ZeroConstructor, Transient, Protected, NativeAccessSpecifierProtected)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"BFGAlertSystemDebug">();
	}
	static class UBFGAlertSystemDebug* GetDefaultObj()
	{
		return GetDefaultObjImpl<UBFGAlertSystemDebug>();
	}
};
static_assert(alignof(UBFGAlertSystemDebug) == 0x000008, "Wrong alignment on UBFGAlertSystemDebug");
static_assert(sizeof(UBFGAlertSystemDebug) == 0x0000A0, "Wrong size on UBFGAlertSystemDebug");
static_assert(offsetof(UBFGAlertSystemDebug, M_pAlertSystem) == 0x000028, "Member 'UBFGAlertSystemDebug::M_pAlertSystem' has a wrong offset!");
static_assert(offsetof(UBFGAlertSystemDebug, M_bDisplayAlertEventLog) == 0x000030, "Member 'UBFGAlertSystemDebug::M_bDisplayAlertEventLog' has a wrong offset!");
static_assert(offsetof(UBFGAlertSystemDebug, M_bDisplayAlertEventCooldDowns) == 0x000031, "Member 'UBFGAlertSystemDebug::M_bDisplayAlertEventCooldDowns' has a wrong offset!");
static_assert(offsetof(UBFGAlertSystemDebug, M_bDisplayAlertDespawns) == 0x000032, "Member 'UBFGAlertSystemDebug::M_bDisplayAlertDespawns' has a wrong offset!");
static_assert(offsetof(UBFGAlertSystemDebug, M_bDetailedResponseLevelInfo) == 0x000033, "Member 'UBFGAlertSystemDebug::M_bDetailedResponseLevelInfo' has a wrong offset!");
static_assert(offsetof(UBFGAlertSystemDebug, M_responseLevelDebugInfo) == 0x000038, "Member 'UBFGAlertSystemDebug::M_responseLevelDebugInfo' has a wrong offset!");
static_assert(offsetof(UBFGAlertSystemDebug, M_aAlertEventsLog) == 0x000068, "Member 'UBFGAlertSystemDebug::M_aAlertEventsLog' has a wrong offset!");
static_assert(offsetof(UBFGAlertSystemDebug, M_iMaxAlertEventsInLog) == 0x000078, "Member 'UBFGAlertSystemDebug::M_iMaxAlertEventsInLog' has a wrong offset!");
static_assert(offsetof(UBFGAlertSystemDebug, M_aAlertEventsCoolDownDebugInfo) == 0x000080, "Member 'UBFGAlertSystemDebug::M_aAlertEventsCoolDownDebugInfo' has a wrong offset!");
static_assert(offsetof(UBFGAlertSystemDebug, M_aStrDespawnLog) == 0x000090, "Member 'UBFGAlertSystemDebug::M_aStrDespawnLog' has a wrong offset!");

// Class BFGCore.BFGAlertSystemDefinitionAsset
// 0x00C8 (0x00F8 - 0x0030)
class UBFGAlertSystemDefinitionAsset final : public UDataAsset
{
public:
	TArray<struct FBFGResponseLevelDef>           ResponseLevels;                                    // 0x0030(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, Protected, NativeAccessSpecifierProtected)
	TArray<struct FBFGPopulationControlDef>       MaxPopulationByType;                               // 0x0040(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, Protected, NativeAccessSpecifierProtected)
	float                                         StartDecayDelay;                                   // 0x0050(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         DecayInitialAmount;                                // 0x0054(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         DecayMultiplier;                                   // 0x0058(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         DecayMultiplierInterval;                           // 0x005C(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UDataTable*                             DataTable;                                         // 0x0060(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	struct FEQSParametrizedQueryExecutionRequest  EQSRequest;                                        // 0x0068(0x0048)(Edit, DisableEditOnInstance, Protected, NativeAccessSpecifierProtected)
	struct FEQSParametrizedQueryExecutionRequest  EQSRequestWithPathToNetwork;                       // 0x00B0(0x0048)(Edit, DisableEditOnInstance, Protected, NativeAccessSpecifierProtected)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"BFGAlertSystemDefinitionAsset">();
	}
	static class UBFGAlertSystemDefinitionAsset* GetDefaultObj()
	{
		return GetDefaultObjImpl<UBFGAlertSystemDefinitionAsset>();
	}
};
static_assert(alignof(UBFGAlertSystemDefinitionAsset) == 0x000008, "Wrong alignment on UBFGAlertSystemDefinitionAsset");
static_assert(sizeof(UBFGAlertSystemDefinitionAsset) == 0x0000F8, "Wrong size on UBFGAlertSystemDefinitionAsset");
static_assert(offsetof(UBFGAlertSystemDefinitionAsset, ResponseLevels) == 0x000030, "Member 'UBFGAlertSystemDefinitionAsset::ResponseLevels' has a wrong offset!");
static_assert(offsetof(UBFGAlertSystemDefinitionAsset, MaxPopulationByType) == 0x000040, "Member 'UBFGAlertSystemDefinitionAsset::MaxPopulationByType' has a wrong offset!");
static_assert(offsetof(UBFGAlertSystemDefinitionAsset, StartDecayDelay) == 0x000050, "Member 'UBFGAlertSystemDefinitionAsset::StartDecayDelay' has a wrong offset!");
static_assert(offsetof(UBFGAlertSystemDefinitionAsset, DecayInitialAmount) == 0x000054, "Member 'UBFGAlertSystemDefinitionAsset::DecayInitialAmount' has a wrong offset!");
static_assert(offsetof(UBFGAlertSystemDefinitionAsset, DecayMultiplier) == 0x000058, "Member 'UBFGAlertSystemDefinitionAsset::DecayMultiplier' has a wrong offset!");
static_assert(offsetof(UBFGAlertSystemDefinitionAsset, DecayMultiplierInterval) == 0x00005C, "Member 'UBFGAlertSystemDefinitionAsset::DecayMultiplierInterval' has a wrong offset!");
static_assert(offsetof(UBFGAlertSystemDefinitionAsset, DataTable) == 0x000060, "Member 'UBFGAlertSystemDefinitionAsset::DataTable' has a wrong offset!");
static_assert(offsetof(UBFGAlertSystemDefinitionAsset, EQSRequest) == 0x000068, "Member 'UBFGAlertSystemDefinitionAsset::EQSRequest' has a wrong offset!");
static_assert(offsetof(UBFGAlertSystemDefinitionAsset, EQSRequestWithPathToNetwork) == 0x0000B0, "Member 'UBFGAlertSystemDefinitionAsset::EQSRequestWithPathToNetwork' has a wrong offset!");

// Class BFGCore.BFGMissionWorldState
// 0x0188 (0x01B0 - 0x0028)
class UBFGMissionWorldState final : public UObject
{
public:
	class ABFGGameState*                          M_pGameState;                                      // 0x0028(0x0008)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	struct FBFGMissionWorldLayout                 M_worldLayout;                                     // 0x0030(0x0150)(Transient, Protected, NativeAccessSpecifierProtected)
	TArray<class UBFGMissionGroup*>               M_apMissionGroups;                                 // 0x0180(0x0010)(ZeroConstructor, Transient, Protected, NativeAccessSpecifierProtected)
	uint8                                         Pad_190[0x20];                                     // 0x0190(0x0020)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	const class FText GetNextQuestTitle() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"BFGMissionWorldState">();
	}
	static class UBFGMissionWorldState* GetDefaultObj()
	{
		return GetDefaultObjImpl<UBFGMissionWorldState>();
	}
};
static_assert(alignof(UBFGMissionWorldState) == 0x000008, "Wrong alignment on UBFGMissionWorldState");
static_assert(sizeof(UBFGMissionWorldState) == 0x0001B0, "Wrong size on UBFGMissionWorldState");
static_assert(offsetof(UBFGMissionWorldState, M_pGameState) == 0x000028, "Member 'UBFGMissionWorldState::M_pGameState' has a wrong offset!");
static_assert(offsetof(UBFGMissionWorldState, M_worldLayout) == 0x000030, "Member 'UBFGMissionWorldState::M_worldLayout' has a wrong offset!");
static_assert(offsetof(UBFGMissionWorldState, M_apMissionGroups) == 0x000180, "Member 'UBFGMissionWorldState::M_apMissionGroups' has a wrong offset!");

// Class BFGCore.BFGVariable
// 0x0078 (0x00A0 - 0x0028)
class UBFGVariable final : public UObject
{
public:
	uint8                                         Pad_28[0x8];                                       // 0x0028(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	struct FGuid                                  M_guid;                                            // 0x0030(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   M_strVariableName;                                 // 0x0040(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   M_strVariableTypeName;                             // 0x0048(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   M_strDefaultValue;                                 // 0x0050(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	UMulticastDelegateProperty_                   M_OnValueChanged;                                  // 0x0058(0x0018)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	uint8                                         Pad_70[0x28];                                      // 0x0070(0x0028)(Fixing Size After Last Property [ Dumper-7 ])
	class UBFGVariableType*                       M_pVariableType;                                   // 0x0098(0x0008)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"BFGVariable">();
	}
	static class UBFGVariable* GetDefaultObj()
	{
		return GetDefaultObjImpl<UBFGVariable>();
	}
};
static_assert(alignof(UBFGVariable) == 0x000008, "Wrong alignment on UBFGVariable");
static_assert(sizeof(UBFGVariable) == 0x0000A0, "Wrong size on UBFGVariable");
static_assert(offsetof(UBFGVariable, M_guid) == 0x000030, "Member 'UBFGVariable::M_guid' has a wrong offset!");
static_assert(offsetof(UBFGVariable, M_strVariableName) == 0x000040, "Member 'UBFGVariable::M_strVariableName' has a wrong offset!");
static_assert(offsetof(UBFGVariable, M_strVariableTypeName) == 0x000048, "Member 'UBFGVariable::M_strVariableTypeName' has a wrong offset!");
static_assert(offsetof(UBFGVariable, M_strDefaultValue) == 0x000050, "Member 'UBFGVariable::M_strDefaultValue' has a wrong offset!");
static_assert(offsetof(UBFGVariable, M_OnValueChanged) == 0x000058, "Member 'UBFGVariable::M_OnValueChanged' has a wrong offset!");
static_assert(offsetof(UBFGVariable, M_pVariableType) == 0x000098, "Member 'UBFGVariable::M_pVariableType' has a wrong offset!");

// Class BFGCore.BFGDamageType
// 0x0058 (0x0098 - 0x0040)
class UBFGDamageType : public UDamageType
{
public:
	uint8                                         Pad_40[0x8];                                       // 0x0040(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	bool                                          M_bIsFatalDamage;                                  // 0x0048(0x0001)(Edit, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EBFGDamageTypeFromFeature                     M_damageFromFeature;                               // 0x0049(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EBFGDamageTypeProperty                        M_damageProperty;                                  // 0x004A(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_4B[0x5];                                       // 0x004B(0x0005)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<struct FGameplayEffectTagsTimer>       M_aShieldGameplayEffectTagTimers;                  // 0x0050(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, NativeAccessSpecifierPublic)
	TArray<struct FGameplayEffectTagsTimer>       M_aGameplayEffectTagTimers;                        // 0x0060(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, NativeAccessSpecifierPublic)
	struct FGameplayTagContainer                  M_gameplayTags;                                    // 0x0070(0x0020)(Edit, BlueprintVisible, BlueprintReadOnly, DisableEditOnInstance, NativeAccessSpecifierPublic)
	bool                                          M_bNotifyAnimation;                                // 0x0090(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_91[0x7];                                       // 0x0091(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"BFGDamageType">();
	}
	static class UBFGDamageType* GetDefaultObj()
	{
		return GetDefaultObjImpl<UBFGDamageType>();
	}
};
static_assert(alignof(UBFGDamageType) == 0x000008, "Wrong alignment on UBFGDamageType");
static_assert(sizeof(UBFGDamageType) == 0x000098, "Wrong size on UBFGDamageType");
static_assert(offsetof(UBFGDamageType, M_bIsFatalDamage) == 0x000048, "Member 'UBFGDamageType::M_bIsFatalDamage' has a wrong offset!");
static_assert(offsetof(UBFGDamageType, M_damageFromFeature) == 0x000049, "Member 'UBFGDamageType::M_damageFromFeature' has a wrong offset!");
static_assert(offsetof(UBFGDamageType, M_damageProperty) == 0x00004A, "Member 'UBFGDamageType::M_damageProperty' has a wrong offset!");
static_assert(offsetof(UBFGDamageType, M_aShieldGameplayEffectTagTimers) == 0x000050, "Member 'UBFGDamageType::M_aShieldGameplayEffectTagTimers' has a wrong offset!");
static_assert(offsetof(UBFGDamageType, M_aGameplayEffectTagTimers) == 0x000060, "Member 'UBFGDamageType::M_aGameplayEffectTagTimers' has a wrong offset!");
static_assert(offsetof(UBFGDamageType, M_gameplayTags) == 0x000070, "Member 'UBFGDamageType::M_gameplayTags' has a wrong offset!");
static_assert(offsetof(UBFGDamageType, M_bNotifyAnimation) == 0x000090, "Member 'UBFGDamageType::M_bNotifyAnimation' has a wrong offset!");

// Class BFGCore.BFGAlertSystemManager
// 0x0180 (0x01B0 - 0x0030)
class UBFGAlertSystemManager : public UBFGGameSystem
{
public:
	uint8                                         Pad_30[0x28];                                      // 0x0030(0x0028)(Fixing Size After Last Property [ Dumper-7 ])
	class ABFGGameState*                          M_pGameState;                                      // 0x0058(0x0008)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_60[0x4];                                       // 0x0060(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         M_fResponseValue;                                  // 0x0064(0x0004)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         M_fPotentialResponseValue;                         // 0x0068(0x0004)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          M_bDecayIsActive;                                  // 0x006C(0x0001)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_6D[0x3];                                       // 0x006D(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         M_fCurrentDecayValue;                              // 0x0070(0x0004)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         M_fTimeToNextDecayMultiplier;                      // 0x0074(0x0004)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         M_fTimeToApplyDecay;                               // 0x0078(0x0004)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          M_bResponseLevelLocked;                            // 0x007C(0x0001)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_7D[0x3];                                       // 0x007D(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	int32                                         M_iCurrentResponseLevelIndex;                      // 0x0080(0x0004)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	int32                                         M_iMaxResponseLevelIndex;                          // 0x0084(0x0004)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UBFGAlertResponseLevelState*            M_pResponseLevelState;                             // 0x0088(0x0008)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TMap<int32, class UBFGAlertResponseLevelState*> M_apResponseLevelStates;                           // 0x0090(0x0050)(ZeroConstructor, Transient, Protected, NativeAccessSpecifierProtected)
	class UBFGAlertSystemDefinitionAsset*         M_pAlertSystemDefinitionAsset;                     // 0x00E0(0x0008)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TMap<class FName, struct FBFGAlertEventNotificationSet> M_aAlertTriggerNotificationSets;                   // 0x00E8(0x0050)(ZeroConstructor, Transient, Protected, NativeAccessSpecifierProtected)
	float                                         M_fTimeSinceLastNotification;                      // 0x0138(0x0004)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	EBFGAlertSystemState                          M_eCurrentAlertState;                              // 0x013C(0x0001)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_13D[0x3];                                      // 0x013D(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<struct FBFGPopulationByTags>           M_aPopulationCountByTags;                          // 0x0140(0x0010)(ZeroConstructor, Transient, Protected, NativeAccessSpecifierProtected)
	class UBFGAlertSystemDebug*                   M_pAlertSystemDebug;                               // 0x0150(0x0008)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class ABFGActorAlertSystem*                   M_pAlertSystemActor;                               // 0x0158(0x0008)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UBFGAlertSpawnPositionHelper*           M_pSpawnPositionHelper;                            // 0x0160(0x0008)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UBFGAlertSpawnCaps*                     M_pSpawnCaps;                                      // 0x0168(0x0008)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TArray<class UBFGActorComponent_Alert*>       M_apPotentialAlerters;                             // 0x0170(0x0010)(ExportObject, ZeroConstructor, Transient, ContainsInstancedReference, Protected, NativeAccessSpecifierProtected)
	TArray<class UBFGActorComponent_DetectionHelper*> M_apDetecters;                                     // 0x0180(0x0010)(ExportObject, ZeroConstructor, Transient, ContainsInstancedReference, Protected, NativeAccessSpecifierProtected)
	class UBFGAISystem*                           M_pAISystem;                                       // 0x0190(0x0008)(ExportObject, ZeroConstructor, Transient, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UBFGAICombatMediator*                   M_pCombatMediator;                                 // 0x0198(0x0008)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          M_bSystemEnabled;                                  // 0x01A0(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_1A1[0x3];                                      // 0x01A1(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         M_fActiveCheckStateTimer;                          // 0x01A4(0x0004)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	EBFGAlertSystemSeenState                      M_currentSeenState;                                // 0x01A8(0x0001)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_1A9[0x7];                                      // 0x01A9(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	bool IsUndetected();
	void LowerResponseLevel(int32 _iIndex);
	void OnChangeAlarmState(int32 _iResponseLevelIndex);
	void OnPlayerRespawnAtCheckPoint();
	void Reset();
	void ResetDecay();
	void RiseResponseLevel(int32 _iIndex);
	void SetMaxResponseLevelIndex(int32 _iIndex);
	void SetResponseLevelIndex(int32 _iIndex, bool _bReportPlayerLKP);
	void SetResponseLevelLockedMode(bool _bLocked);
	void SetSpawningEnabled(bool _bEnabled);
	void SetStealthWarning(bool _bEnabled, EBFGAlertSystemState _state);
	void SetUndetected();

	EBFGAlertSystemState GetCurrentAlertSystemState() const;
	int32 GetCurrentResponseLevelIndex() const;
	class FString GetCurrentResponseLevelName() const;
	float GetDetectionCuriosityScale() const;
	int32 GetMaxResponseLevelIndex() const;
	float GetPotentialResponseValue() const;
	float GetResponseValue() const;
	EBFGAlertSystemSeenState GetSeenState() const;
	bool IsResponseLevelLocked() const;
	bool IsSpawningEnabled() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"BFGAlertSystemManager">();
	}
	static class UBFGAlertSystemManager* GetDefaultObj()
	{
		return GetDefaultObjImpl<UBFGAlertSystemManager>();
	}
};
static_assert(alignof(UBFGAlertSystemManager) == 0x000008, "Wrong alignment on UBFGAlertSystemManager");
static_assert(sizeof(UBFGAlertSystemManager) == 0x0001B0, "Wrong size on UBFGAlertSystemManager");
static_assert(offsetof(UBFGAlertSystemManager, M_pGameState) == 0x000058, "Member 'UBFGAlertSystemManager::M_pGameState' has a wrong offset!");
static_assert(offsetof(UBFGAlertSystemManager, M_fResponseValue) == 0x000064, "Member 'UBFGAlertSystemManager::M_fResponseValue' has a wrong offset!");
static_assert(offsetof(UBFGAlertSystemManager, M_fPotentialResponseValue) == 0x000068, "Member 'UBFGAlertSystemManager::M_fPotentialResponseValue' has a wrong offset!");
static_assert(offsetof(UBFGAlertSystemManager, M_bDecayIsActive) == 0x00006C, "Member 'UBFGAlertSystemManager::M_bDecayIsActive' has a wrong offset!");
static_assert(offsetof(UBFGAlertSystemManager, M_fCurrentDecayValue) == 0x000070, "Member 'UBFGAlertSystemManager::M_fCurrentDecayValue' has a wrong offset!");
static_assert(offsetof(UBFGAlertSystemManager, M_fTimeToNextDecayMultiplier) == 0x000074, "Member 'UBFGAlertSystemManager::M_fTimeToNextDecayMultiplier' has a wrong offset!");
static_assert(offsetof(UBFGAlertSystemManager, M_fTimeToApplyDecay) == 0x000078, "Member 'UBFGAlertSystemManager::M_fTimeToApplyDecay' has a wrong offset!");
static_assert(offsetof(UBFGAlertSystemManager, M_bResponseLevelLocked) == 0x00007C, "Member 'UBFGAlertSystemManager::M_bResponseLevelLocked' has a wrong offset!");
static_assert(offsetof(UBFGAlertSystemManager, M_iCurrentResponseLevelIndex) == 0x000080, "Member 'UBFGAlertSystemManager::M_iCurrentResponseLevelIndex' has a wrong offset!");
static_assert(offsetof(UBFGAlertSystemManager, M_iMaxResponseLevelIndex) == 0x000084, "Member 'UBFGAlertSystemManager::M_iMaxResponseLevelIndex' has a wrong offset!");
static_assert(offsetof(UBFGAlertSystemManager, M_pResponseLevelState) == 0x000088, "Member 'UBFGAlertSystemManager::M_pResponseLevelState' has a wrong offset!");
static_assert(offsetof(UBFGAlertSystemManager, M_apResponseLevelStates) == 0x000090, "Member 'UBFGAlertSystemManager::M_apResponseLevelStates' has a wrong offset!");
static_assert(offsetof(UBFGAlertSystemManager, M_pAlertSystemDefinitionAsset) == 0x0000E0, "Member 'UBFGAlertSystemManager::M_pAlertSystemDefinitionAsset' has a wrong offset!");
static_assert(offsetof(UBFGAlertSystemManager, M_aAlertTriggerNotificationSets) == 0x0000E8, "Member 'UBFGAlertSystemManager::M_aAlertTriggerNotificationSets' has a wrong offset!");
static_assert(offsetof(UBFGAlertSystemManager, M_fTimeSinceLastNotification) == 0x000138, "Member 'UBFGAlertSystemManager::M_fTimeSinceLastNotification' has a wrong offset!");
static_assert(offsetof(UBFGAlertSystemManager, M_eCurrentAlertState) == 0x00013C, "Member 'UBFGAlertSystemManager::M_eCurrentAlertState' has a wrong offset!");
static_assert(offsetof(UBFGAlertSystemManager, M_aPopulationCountByTags) == 0x000140, "Member 'UBFGAlertSystemManager::M_aPopulationCountByTags' has a wrong offset!");
static_assert(offsetof(UBFGAlertSystemManager, M_pAlertSystemDebug) == 0x000150, "Member 'UBFGAlertSystemManager::M_pAlertSystemDebug' has a wrong offset!");
static_assert(offsetof(UBFGAlertSystemManager, M_pAlertSystemActor) == 0x000158, "Member 'UBFGAlertSystemManager::M_pAlertSystemActor' has a wrong offset!");
static_assert(offsetof(UBFGAlertSystemManager, M_pSpawnPositionHelper) == 0x000160, "Member 'UBFGAlertSystemManager::M_pSpawnPositionHelper' has a wrong offset!");
static_assert(offsetof(UBFGAlertSystemManager, M_pSpawnCaps) == 0x000168, "Member 'UBFGAlertSystemManager::M_pSpawnCaps' has a wrong offset!");
static_assert(offsetof(UBFGAlertSystemManager, M_apPotentialAlerters) == 0x000170, "Member 'UBFGAlertSystemManager::M_apPotentialAlerters' has a wrong offset!");
static_assert(offsetof(UBFGAlertSystemManager, M_apDetecters) == 0x000180, "Member 'UBFGAlertSystemManager::M_apDetecters' has a wrong offset!");
static_assert(offsetof(UBFGAlertSystemManager, M_pAISystem) == 0x000190, "Member 'UBFGAlertSystemManager::M_pAISystem' has a wrong offset!");
static_assert(offsetof(UBFGAlertSystemManager, M_pCombatMediator) == 0x000198, "Member 'UBFGAlertSystemManager::M_pCombatMediator' has a wrong offset!");
static_assert(offsetof(UBFGAlertSystemManager, M_bSystemEnabled) == 0x0001A0, "Member 'UBFGAlertSystemManager::M_bSystemEnabled' has a wrong offset!");
static_assert(offsetof(UBFGAlertSystemManager, M_fActiveCheckStateTimer) == 0x0001A4, "Member 'UBFGAlertSystemManager::M_fActiveCheckStateTimer' has a wrong offset!");
static_assert(offsetof(UBFGAlertSystemManager, M_currentSeenState) == 0x0001A8, "Member 'UBFGAlertSystemManager::M_currentSeenState' has a wrong offset!");

// Class BFGCore.BFGTaskNode_ClearBlackboardValue
// 0x0028 (0x00A0 - 0x0078)
class UBFGTaskNode_ClearBlackboardValue final : public UBFGBTBaseTaskNode
{
public:
	struct FBlackboardKeySelector                 M_BBKey;                                           // 0x0078(0x0028)(Edit, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"BFGTaskNode_ClearBlackboardValue">();
	}
	static class UBFGTaskNode_ClearBlackboardValue* GetDefaultObj()
	{
		return GetDefaultObjImpl<UBFGTaskNode_ClearBlackboardValue>();
	}
};
static_assert(alignof(UBFGTaskNode_ClearBlackboardValue) == 0x000008, "Wrong alignment on UBFGTaskNode_ClearBlackboardValue");
static_assert(sizeof(UBFGTaskNode_ClearBlackboardValue) == 0x0000A0, "Wrong size on UBFGTaskNode_ClearBlackboardValue");
static_assert(offsetof(UBFGTaskNode_ClearBlackboardValue, M_BBKey) == 0x000078, "Member 'UBFGTaskNode_ClearBlackboardValue::M_BBKey' has a wrong offset!");

// Class BFGCore.BFGCrowdScriptConSettings
// 0x0020 (0x0058 - 0x0038)
class UBFGCrowdScriptConSettings final : public UDeveloperSettings
{
public:
	TArray<TSoftObjectPtr<class UBFGCrowdLifeAnimationSequenceDefinitionAsset>> M_aSpeakerAnimDefinitions;                         // 0x0038(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Config, GlobalConfig, UObjectWrapper, NativeAccessSpecifierPublic)
	TArray<TSoftObjectPtr<class UBFGCrowdLifeAnimationSequenceDefinitionAsset>> M_aListenerAnimDefinitions;                        // 0x0048(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Config, GlobalConfig, UObjectWrapper, NativeAccessSpecifierPublic)

public:
	static class UBFGCrowdScriptConSettings* GetSettings();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"BFGCrowdScriptConSettings">();
	}
	static class UBFGCrowdScriptConSettings* GetDefaultObj()
	{
		return GetDefaultObjImpl<UBFGCrowdScriptConSettings>();
	}
};
static_assert(alignof(UBFGCrowdScriptConSettings) == 0x000008, "Wrong alignment on UBFGCrowdScriptConSettings");
static_assert(sizeof(UBFGCrowdScriptConSettings) == 0x000058, "Wrong size on UBFGCrowdScriptConSettings");
static_assert(offsetof(UBFGCrowdScriptConSettings, M_aSpeakerAnimDefinitions) == 0x000038, "Member 'UBFGCrowdScriptConSettings::M_aSpeakerAnimDefinitions' has a wrong offset!");
static_assert(offsetof(UBFGCrowdScriptConSettings, M_aListenerAnimDefinitions) == 0x000048, "Member 'UBFGCrowdScriptConSettings::M_aListenerAnimDefinitions' has a wrong offset!");

// Class BFGCore.BFGQuest_ElementInteract
// 0x0038 (0x0378 - 0x0340)
class UBFGQuest_ElementInteract final : public UBFGQuest_ElementObjectiveBase
{
public:
	EFBFGQuest_Element_ExecutionTime              M_executionTime;                                   // 0x0340(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_341[0x7];                                      // 0x0341(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<struct FBFGQuest_ElementInteract_Objective> M_aObjectives;                                     // 0x0348(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, ContainsInstancedReference, NativeAccessSpecifierPublic)
	UMulticastDelegateProperty_                   M_OnInteractEvent;                                 // 0x0358(0x0018)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	EFBFGQuest_Element_ProcessingMode             M_processingMode;                                  // 0x0370(0x0001)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          M_bMakeTargetsInteractableOnStart;                 // 0x0371(0x0001)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_372[0x6];                                      // 0x0372(0x0006)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	TArray<class UBFGVariable*> GetSparseQuestCounterVariables() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"BFGQuest_ElementInteract">();
	}
	static class UBFGQuest_ElementInteract* GetDefaultObj()
	{
		return GetDefaultObjImpl<UBFGQuest_ElementInteract>();
	}
};
static_assert(alignof(UBFGQuest_ElementInteract) == 0x000008, "Wrong alignment on UBFGQuest_ElementInteract");
static_assert(sizeof(UBFGQuest_ElementInteract) == 0x000378, "Wrong size on UBFGQuest_ElementInteract");
static_assert(offsetof(UBFGQuest_ElementInteract, M_executionTime) == 0x000340, "Member 'UBFGQuest_ElementInteract::M_executionTime' has a wrong offset!");
static_assert(offsetof(UBFGQuest_ElementInteract, M_aObjectives) == 0x000348, "Member 'UBFGQuest_ElementInteract::M_aObjectives' has a wrong offset!");
static_assert(offsetof(UBFGQuest_ElementInteract, M_OnInteractEvent) == 0x000358, "Member 'UBFGQuest_ElementInteract::M_OnInteractEvent' has a wrong offset!");
static_assert(offsetof(UBFGQuest_ElementInteract, M_processingMode) == 0x000370, "Member 'UBFGQuest_ElementInteract::M_processingMode' has a wrong offset!");
static_assert(offsetof(UBFGQuest_ElementInteract, M_bMakeTargetsInteractableOnStart) == 0x000371, "Member 'UBFGQuest_ElementInteract::M_bMakeTargetsInteractableOnStart' has a wrong offset!");

// Class BFGCore.BFGAmbientSound
// 0x0030 (0x0410 - 0x03E0)
class ABFGAmbientSound : public AAmbientSound
{
public:
	uint8                                         Pad_3E0[0x8];                                      // 0x03E0(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	struct FGameplayTagContainer                  M_gameplayTags;                                    // 0x03E8(0x0020)(Edit, BlueprintVisible, BlueprintReadOnly, Protected, NativeAccessSpecifierProtected)
	class UBFGAmbientSoundManager*                M_pAmbientSoundManger;                             // 0x0408(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"BFGAmbientSound">();
	}
	static class ABFGAmbientSound* GetDefaultObj()
	{
		return GetDefaultObjImpl<ABFGAmbientSound>();
	}
};
static_assert(alignof(ABFGAmbientSound) == 0x000008, "Wrong alignment on ABFGAmbientSound");
static_assert(sizeof(ABFGAmbientSound) == 0x000410, "Wrong size on ABFGAmbientSound");
static_assert(offsetof(ABFGAmbientSound, M_gameplayTags) == 0x0003E8, "Member 'ABFGAmbientSound::M_gameplayTags' has a wrong offset!");
static_assert(offsetof(ABFGAmbientSound, M_pAmbientSoundManger) == 0x000408, "Member 'ABFGAmbientSound::M_pAmbientSoundManger' has a wrong offset!");

// Class BFGCore.BFGAmbientSoundManager
// 0x0010 (0x0040 - 0x0030)
class UBFGAmbientSoundManager final : public UBFGGameSystem
{
public:
	TArray<class ABFGAmbientSound*>               M_apAmbientSounds;                                 // 0x0030(0x0010)(ZeroConstructor, Transient, NativeAccessSpecifierPrivate)

public:
	TArray<class ABFGAmbientSound*> FindAllSoundsMatchingAllGameplayTags(const struct FGameplayTagContainer& _tagContainer) const;
	TArray<class ABFGAmbientSound*> FindAllSoundsMatchingAnyGameplayTags(const struct FGameplayTagContainer& _tagContainer) const;
	TArray<class ABFGAmbientSound*> FindAllSoundsMatchingGameplayTag(const struct FGameplayTag& _tag) const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"BFGAmbientSoundManager">();
	}
	static class UBFGAmbientSoundManager* GetDefaultObj()
	{
		return GetDefaultObjImpl<UBFGAmbientSoundManager>();
	}
};
static_assert(alignof(UBFGAmbientSoundManager) == 0x000008, "Wrong alignment on UBFGAmbientSoundManager");
static_assert(sizeof(UBFGAmbientSoundManager) == 0x000040, "Wrong size on UBFGAmbientSoundManager");
static_assert(offsetof(UBFGAmbientSoundManager, M_apAmbientSounds) == 0x000030, "Member 'UBFGAmbientSoundManager::M_apAmbientSounds' has a wrong offset!");

// Class BFGCore.BFGWeapon_GroundStomp
// 0x0018 (0x0868 - 0x0850)
class ABFGWeapon_GroundStomp final : public ABFGWeapon_Enemy
{
public:
	float                                         M_fKnockbackStrengthAgainstPlayer;                 // 0x0850(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         M_fKnockbackStrengthAgainstNPCs;                   // 0x0854(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         M_fStompDamage;                                    // 0x0858(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_85C[0x4];                                      // 0x085C(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	TSubclassOf<class UDamageType>                M_pDamageType;                                     // 0x0860(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"BFGWeapon_GroundStomp">();
	}
	static class ABFGWeapon_GroundStomp* GetDefaultObj()
	{
		return GetDefaultObjImpl<ABFGWeapon_GroundStomp>();
	}
};
static_assert(alignof(ABFGWeapon_GroundStomp) == 0x000008, "Wrong alignment on ABFGWeapon_GroundStomp");
static_assert(sizeof(ABFGWeapon_GroundStomp) == 0x000868, "Wrong size on ABFGWeapon_GroundStomp");
static_assert(offsetof(ABFGWeapon_GroundStomp, M_fKnockbackStrengthAgainstPlayer) == 0x000850, "Member 'ABFGWeapon_GroundStomp::M_fKnockbackStrengthAgainstPlayer' has a wrong offset!");
static_assert(offsetof(ABFGWeapon_GroundStomp, M_fKnockbackStrengthAgainstNPCs) == 0x000854, "Member 'ABFGWeapon_GroundStomp::M_fKnockbackStrengthAgainstNPCs' has a wrong offset!");
static_assert(offsetof(ABFGWeapon_GroundStomp, M_fStompDamage) == 0x000858, "Member 'ABFGWeapon_GroundStomp::M_fStompDamage' has a wrong offset!");
static_assert(offsetof(ABFGWeapon_GroundStomp, M_pDamageType) == 0x000860, "Member 'ABFGWeapon_GroundStomp::M_pDamageType' has a wrong offset!");

// Class BFGCore.BFGAnimation_Events
// 0x01C8 (0x01F0 - 0x0028)
class UBFGAnimation_Events : public UObject
{
public:
	UMulticastDelegateProperty_                   M_G2AGetHit;                                       // 0x0028(0x0018)(ZeroConstructor, InstancedReference, BlueprintAssignable, BlueprintCallable, NativeAccessSpecifierPublic)
	UMulticastDelegateProperty_                   M_G2AShotFired;                                    // 0x0040(0x0018)(ZeroConstructor, InstancedReference, BlueprintAssignable, BlueprintCallable, NativeAccessSpecifierPublic)
	UMulticastDelegateProperty_                   M_eStandUpStarted;                                 // 0x0058(0x0018)(ZeroConstructor, InstancedReference, BlueprintAssignable, BlueprintCallable, NativeAccessSpecifierPublic)
	UMulticastDelegateProperty_                   M_G2ALodTransitionStarted;                         // 0x0070(0x0018)(ZeroConstructor, InstancedReference, BlueprintAssignable, BlueprintCallable, NativeAccessSpecifierPublic)
	UMulticastDelegateProperty_                   M_G2ALodTransitionUpdate;                          // 0x0088(0x0018)(ZeroConstructor, InstancedReference, BlueprintAssignable, BlueprintCallable, NativeAccessSpecifierPublic)
	UMulticastDelegateProperty_                   M_eStandUpFinished;                                // 0x00A0(0x0018)(ZeroConstructor, InstancedReference, BlueprintAssignable, BlueprintCallable, NativeAccessSpecifierPublic)
	UMulticastDelegateProperty_                   M_G2AhitByPhysicsObject;                           // 0x00B8(0x0018)(ZeroConstructor, InstancedReference, BlueprintAssignable, BlueprintCallable, NativeAccessSpecifierPublic)
	UMulticastDelegateProperty_                   M_G2ACryptoUFOInteraction;                         // 0x00D0(0x0018)(ZeroConstructor, InstancedReference, BlueprintAssignable, BlueprintCallable, NativeAccessSpecifierPublic)
	UMulticastDelegateProperty_                   M_G2AWeaponEquip;                                  // 0x00E8(0x0018)(ZeroConstructor, InstancedReference, BlueprintAssignable, BlueprintCallable, NativeAccessSpecifierPublic)
	UMulticastDelegateProperty_                   M_G2AWeaponUpequip;                                // 0x0100(0x0018)(ZeroConstructor, InstancedReference, BlueprintAssignable, BlueprintCallable, NativeAccessSpecifierPublic)
	UMulticastDelegateProperty_                   M_G2AWeaponShotFired;                              // 0x0118(0x0018)(ZeroConstructor, InstancedReference, BlueprintAssignable, BlueprintCallable, NativeAccessSpecifierPublic)
	UMulticastDelegateProperty_                   M_G2AWeaponTelegraphingStart;                      // 0x0130(0x0018)(ZeroConstructor, InstancedReference, BlueprintAssignable, BlueprintCallable, NativeAccessSpecifierPublic)
	UMulticastDelegateProperty_                   M_G2AWeaponTelegraphingEnd;                        // 0x0148(0x0018)(ZeroConstructor, InstancedReference, BlueprintAssignable, BlueprintCallable, NativeAccessSpecifierPublic)
	UMulticastDelegateProperty_                   M_A2GWeaponReadyChanges;                           // 0x0160(0x0018)(ZeroConstructor, InstancedReference, BlueprintAssignable, BlueprintCallable, NativeAccessSpecifierPublic)
	UMulticastDelegateProperty_                   M_A2GWeaponVisibilityChanges;                      // 0x0178(0x0018)(ZeroConstructor, InstancedReference, BlueprintAssignable, BlueprintCallable, NativeAccessSpecifierPublic)
	UMulticastDelegateProperty_                   M_A2GWeaponReady;                                  // 0x0190(0x0018)(ZeroConstructor, InstancedReference, BlueprintAssignable, BlueprintCallable, NativeAccessSpecifierPublic)
	UMulticastDelegateProperty_                   M_A2GWeaponNotReady;                               // 0x01A8(0x0018)(ZeroConstructor, InstancedReference, BlueprintAssignable, BlueprintCallable, NativeAccessSpecifierPublic)
	UMulticastDelegateProperty_                   M_A2GWeaponVisible;                                // 0x01C0(0x0018)(ZeroConstructor, InstancedReference, BlueprintAssignable, BlueprintCallable, NativeAccessSpecifierPublic)
	UMulticastDelegateProperty_                   M_A2GWeaponNotVisible;                             // 0x01D8(0x0018)(ZeroConstructor, InstancedReference, BlueprintAssignable, BlueprintCallable, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"BFGAnimation_Events">();
	}
	static class UBFGAnimation_Events* GetDefaultObj()
	{
		return GetDefaultObjImpl<UBFGAnimation_Events>();
	}
};
static_assert(alignof(UBFGAnimation_Events) == 0x000008, "Wrong alignment on UBFGAnimation_Events");
static_assert(sizeof(UBFGAnimation_Events) == 0x0001F0, "Wrong size on UBFGAnimation_Events");
static_assert(offsetof(UBFGAnimation_Events, M_G2AGetHit) == 0x000028, "Member 'UBFGAnimation_Events::M_G2AGetHit' has a wrong offset!");
static_assert(offsetof(UBFGAnimation_Events, M_G2AShotFired) == 0x000040, "Member 'UBFGAnimation_Events::M_G2AShotFired' has a wrong offset!");
static_assert(offsetof(UBFGAnimation_Events, M_eStandUpStarted) == 0x000058, "Member 'UBFGAnimation_Events::M_eStandUpStarted' has a wrong offset!");
static_assert(offsetof(UBFGAnimation_Events, M_G2ALodTransitionStarted) == 0x000070, "Member 'UBFGAnimation_Events::M_G2ALodTransitionStarted' has a wrong offset!");
static_assert(offsetof(UBFGAnimation_Events, M_G2ALodTransitionUpdate) == 0x000088, "Member 'UBFGAnimation_Events::M_G2ALodTransitionUpdate' has a wrong offset!");
static_assert(offsetof(UBFGAnimation_Events, M_eStandUpFinished) == 0x0000A0, "Member 'UBFGAnimation_Events::M_eStandUpFinished' has a wrong offset!");
static_assert(offsetof(UBFGAnimation_Events, M_G2AhitByPhysicsObject) == 0x0000B8, "Member 'UBFGAnimation_Events::M_G2AhitByPhysicsObject' has a wrong offset!");
static_assert(offsetof(UBFGAnimation_Events, M_G2ACryptoUFOInteraction) == 0x0000D0, "Member 'UBFGAnimation_Events::M_G2ACryptoUFOInteraction' has a wrong offset!");
static_assert(offsetof(UBFGAnimation_Events, M_G2AWeaponEquip) == 0x0000E8, "Member 'UBFGAnimation_Events::M_G2AWeaponEquip' has a wrong offset!");
static_assert(offsetof(UBFGAnimation_Events, M_G2AWeaponUpequip) == 0x000100, "Member 'UBFGAnimation_Events::M_G2AWeaponUpequip' has a wrong offset!");
static_assert(offsetof(UBFGAnimation_Events, M_G2AWeaponShotFired) == 0x000118, "Member 'UBFGAnimation_Events::M_G2AWeaponShotFired' has a wrong offset!");
static_assert(offsetof(UBFGAnimation_Events, M_G2AWeaponTelegraphingStart) == 0x000130, "Member 'UBFGAnimation_Events::M_G2AWeaponTelegraphingStart' has a wrong offset!");
static_assert(offsetof(UBFGAnimation_Events, M_G2AWeaponTelegraphingEnd) == 0x000148, "Member 'UBFGAnimation_Events::M_G2AWeaponTelegraphingEnd' has a wrong offset!");
static_assert(offsetof(UBFGAnimation_Events, M_A2GWeaponReadyChanges) == 0x000160, "Member 'UBFGAnimation_Events::M_A2GWeaponReadyChanges' has a wrong offset!");
static_assert(offsetof(UBFGAnimation_Events, M_A2GWeaponVisibilityChanges) == 0x000178, "Member 'UBFGAnimation_Events::M_A2GWeaponVisibilityChanges' has a wrong offset!");
static_assert(offsetof(UBFGAnimation_Events, M_A2GWeaponReady) == 0x000190, "Member 'UBFGAnimation_Events::M_A2GWeaponReady' has a wrong offset!");
static_assert(offsetof(UBFGAnimation_Events, M_A2GWeaponNotReady) == 0x0001A8, "Member 'UBFGAnimation_Events::M_A2GWeaponNotReady' has a wrong offset!");
static_assert(offsetof(UBFGAnimation_Events, M_A2GWeaponVisible) == 0x0001C0, "Member 'UBFGAnimation_Events::M_A2GWeaponVisible' has a wrong offset!");
static_assert(offsetof(UBFGAnimation_Events, M_A2GWeaponNotVisible) == 0x0001D8, "Member 'UBFGAnimation_Events::M_A2GWeaponNotVisible' has a wrong offset!");

// Class BFGCore.BFGAnimation_Events_Npc
// 0x0048 (0x0238 - 0x01F0)
class UBFGAnimation_Events_Npc : public UBFGAnimation_Events
{
public:
	UMulticastDelegateProperty_                   M_G2APlayerBumped;                                 // 0x01F0(0x0018)(ZeroConstructor, InstancedReference, BlueprintAssignable, BlueprintCallable, NativeAccessSpecifierPublic)
	UMulticastDelegateProperty_                   M_G2AEvade;                                        // 0x0208(0x0018)(ZeroConstructor, InstancedReference, BlueprintAssignable, BlueprintCallable, NativeAccessSpecifierPublic)
	UMulticastDelegateProperty_                   M_G2AAlert;                                        // 0x0220(0x0018)(ZeroConstructor, InstancedReference, BlueprintAssignable, BlueprintCallable, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"BFGAnimation_Events_Npc">();
	}
	static class UBFGAnimation_Events_Npc* GetDefaultObj()
	{
		return GetDefaultObjImpl<UBFGAnimation_Events_Npc>();
	}
};
static_assert(alignof(UBFGAnimation_Events_Npc) == 0x000008, "Wrong alignment on UBFGAnimation_Events_Npc");
static_assert(sizeof(UBFGAnimation_Events_Npc) == 0x000238, "Wrong size on UBFGAnimation_Events_Npc");
static_assert(offsetof(UBFGAnimation_Events_Npc, M_G2APlayerBumped) == 0x0001F0, "Member 'UBFGAnimation_Events_Npc::M_G2APlayerBumped' has a wrong offset!");
static_assert(offsetof(UBFGAnimation_Events_Npc, M_G2AEvade) == 0x000208, "Member 'UBFGAnimation_Events_Npc::M_G2AEvade' has a wrong offset!");
static_assert(offsetof(UBFGAnimation_Events_Npc, M_G2AAlert) == 0x000220, "Member 'UBFGAnimation_Events_Npc::M_G2AAlert' has a wrong offset!");

// Class BFGCore.BFGDamageModifierCache
// 0x0050 (0x0078 - 0x0028)
class UBFGDamageModifierCache final : public UObject
{
public:
	TMap<uint32, class UBFGDamageModifierCache_Entry*> M_aModifiersByWeapon;                              // 0x0028(0x0050)(ExportObject, ZeroConstructor, Transient, ContainsInstancedReference, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"BFGDamageModifierCache">();
	}
	static class UBFGDamageModifierCache* GetDefaultObj()
	{
		return GetDefaultObjImpl<UBFGDamageModifierCache>();
	}
};
static_assert(alignof(UBFGDamageModifierCache) == 0x000008, "Wrong alignment on UBFGDamageModifierCache");
static_assert(sizeof(UBFGDamageModifierCache) == 0x000078, "Wrong size on UBFGDamageModifierCache");
static_assert(offsetof(UBFGDamageModifierCache, M_aModifiersByWeapon) == 0x000028, "Member 'UBFGDamageModifierCache::M_aModifiersByWeapon' has a wrong offset!");

// Class BFGCore.BFGWeapon_UFO_QuantumDeconstructor
// 0x0080 (0x07D0 - 0x0750)
class ABFGWeapon_UFO_QuantumDeconstructor : public ABFGWeapon_BaseProjectile
{
public:
	struct FGameplayTag                           M_tUpgradeTagGammaParticleEnrichment;              // 0x0750(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, DisableEditOnInstance, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FGameplayTag                           M_tUpgradeTagGammaParticleAggregation;             // 0x0758(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, DisableEditOnInstance, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FGameplayTag                           M_tUpgradeTagNeutronFieldFluxators;                // 0x0760(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, DisableEditOnInstance, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FGameplayTag                           M_tUpgradeTagMagnetoStorageCompartment;            // 0x0768(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, DisableEditOnInstance, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FGameplayTag                           M_tUpgradeTagDynamoStorageCompartment;             // 0x0770(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, DisableEditOnInstance, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FGameplayTag                           M_tUpgradeTagRepulsorChargeAccumulator;            // 0x0778(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, DisableEditOnInstance, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         M_fGammaParticleEnrichment_ExtraRangeMultiplier;   // 0x0780(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         M_fGammaParticleAggregation_ExtraRangeMultiplier;  // 0x0784(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         M_iMagnetoStorage_Ammo;                            // 0x0788(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         M_iDynamoStorage_Ammo;                             // 0x078C(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         M_fNeutronFieldFluxators_TransmogChance;           // 0x0790(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_794[0x4];                                      // 0x0794(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class UClass*                                 M_pTransmogrifierClass;                            // 0x0798(0x0008)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UClass*                                 M_pBuildingAmmoClass;                              // 0x07A0(0x0008)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UClass*                                 M_pRepulsorChargeAccumulator_AmmoClass;            // 0x07A8(0x0008)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TArray<TSubclassOf<class UDamageType>>        M_aRepulsorChargeAccumulator_IgnoreDamageTypes;    // 0x07B0(0x0010)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, UObjectWrapper, NativeAccessSpecifierPublic)
	float                                         M_fRepulsorChargeAccumulator_HumanModifier;        // 0x07C0(0x0004)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         M_fRepulsorChargeAccumulator_VehicleModifier;      // 0x07C4(0x0004)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         M_fRepulsorChargeAccumulator_BuildingModifier;     // 0x07C8(0x0004)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_7CC[0x4];                                      // 0x07CC(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void OnUFODealtDamage(class AActor* _pTarget, float _fDamage, bool _bFatal, TSubclassOf<class UDamageType> _damageType);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"BFGWeapon_UFO_QuantumDeconstructor">();
	}
	static class ABFGWeapon_UFO_QuantumDeconstructor* GetDefaultObj()
	{
		return GetDefaultObjImpl<ABFGWeapon_UFO_QuantumDeconstructor>();
	}
};
static_assert(alignof(ABFGWeapon_UFO_QuantumDeconstructor) == 0x000008, "Wrong alignment on ABFGWeapon_UFO_QuantumDeconstructor");
static_assert(sizeof(ABFGWeapon_UFO_QuantumDeconstructor) == 0x0007D0, "Wrong size on ABFGWeapon_UFO_QuantumDeconstructor");
static_assert(offsetof(ABFGWeapon_UFO_QuantumDeconstructor, M_tUpgradeTagGammaParticleEnrichment) == 0x000750, "Member 'ABFGWeapon_UFO_QuantumDeconstructor::M_tUpgradeTagGammaParticleEnrichment' has a wrong offset!");
static_assert(offsetof(ABFGWeapon_UFO_QuantumDeconstructor, M_tUpgradeTagGammaParticleAggregation) == 0x000758, "Member 'ABFGWeapon_UFO_QuantumDeconstructor::M_tUpgradeTagGammaParticleAggregation' has a wrong offset!");
static_assert(offsetof(ABFGWeapon_UFO_QuantumDeconstructor, M_tUpgradeTagNeutronFieldFluxators) == 0x000760, "Member 'ABFGWeapon_UFO_QuantumDeconstructor::M_tUpgradeTagNeutronFieldFluxators' has a wrong offset!");
static_assert(offsetof(ABFGWeapon_UFO_QuantumDeconstructor, M_tUpgradeTagMagnetoStorageCompartment) == 0x000768, "Member 'ABFGWeapon_UFO_QuantumDeconstructor::M_tUpgradeTagMagnetoStorageCompartment' has a wrong offset!");
static_assert(offsetof(ABFGWeapon_UFO_QuantumDeconstructor, M_tUpgradeTagDynamoStorageCompartment) == 0x000770, "Member 'ABFGWeapon_UFO_QuantumDeconstructor::M_tUpgradeTagDynamoStorageCompartment' has a wrong offset!");
static_assert(offsetof(ABFGWeapon_UFO_QuantumDeconstructor, M_tUpgradeTagRepulsorChargeAccumulator) == 0x000778, "Member 'ABFGWeapon_UFO_QuantumDeconstructor::M_tUpgradeTagRepulsorChargeAccumulator' has a wrong offset!");
static_assert(offsetof(ABFGWeapon_UFO_QuantumDeconstructor, M_fGammaParticleEnrichment_ExtraRangeMultiplier) == 0x000780, "Member 'ABFGWeapon_UFO_QuantumDeconstructor::M_fGammaParticleEnrichment_ExtraRangeMultiplier' has a wrong offset!");
static_assert(offsetof(ABFGWeapon_UFO_QuantumDeconstructor, M_fGammaParticleAggregation_ExtraRangeMultiplier) == 0x000784, "Member 'ABFGWeapon_UFO_QuantumDeconstructor::M_fGammaParticleAggregation_ExtraRangeMultiplier' has a wrong offset!");
static_assert(offsetof(ABFGWeapon_UFO_QuantumDeconstructor, M_iMagnetoStorage_Ammo) == 0x000788, "Member 'ABFGWeapon_UFO_QuantumDeconstructor::M_iMagnetoStorage_Ammo' has a wrong offset!");
static_assert(offsetof(ABFGWeapon_UFO_QuantumDeconstructor, M_iDynamoStorage_Ammo) == 0x00078C, "Member 'ABFGWeapon_UFO_QuantumDeconstructor::M_iDynamoStorage_Ammo' has a wrong offset!");
static_assert(offsetof(ABFGWeapon_UFO_QuantumDeconstructor, M_fNeutronFieldFluxators_TransmogChance) == 0x000790, "Member 'ABFGWeapon_UFO_QuantumDeconstructor::M_fNeutronFieldFluxators_TransmogChance' has a wrong offset!");
static_assert(offsetof(ABFGWeapon_UFO_QuantumDeconstructor, M_pTransmogrifierClass) == 0x000798, "Member 'ABFGWeapon_UFO_QuantumDeconstructor::M_pTransmogrifierClass' has a wrong offset!");
static_assert(offsetof(ABFGWeapon_UFO_QuantumDeconstructor, M_pBuildingAmmoClass) == 0x0007A0, "Member 'ABFGWeapon_UFO_QuantumDeconstructor::M_pBuildingAmmoClass' has a wrong offset!");
static_assert(offsetof(ABFGWeapon_UFO_QuantumDeconstructor, M_pRepulsorChargeAccumulator_AmmoClass) == 0x0007A8, "Member 'ABFGWeapon_UFO_QuantumDeconstructor::M_pRepulsorChargeAccumulator_AmmoClass' has a wrong offset!");
static_assert(offsetof(ABFGWeapon_UFO_QuantumDeconstructor, M_aRepulsorChargeAccumulator_IgnoreDamageTypes) == 0x0007B0, "Member 'ABFGWeapon_UFO_QuantumDeconstructor::M_aRepulsorChargeAccumulator_IgnoreDamageTypes' has a wrong offset!");
static_assert(offsetof(ABFGWeapon_UFO_QuantumDeconstructor, M_fRepulsorChargeAccumulator_HumanModifier) == 0x0007C0, "Member 'ABFGWeapon_UFO_QuantumDeconstructor::M_fRepulsorChargeAccumulator_HumanModifier' has a wrong offset!");
static_assert(offsetof(ABFGWeapon_UFO_QuantumDeconstructor, M_fRepulsorChargeAccumulator_VehicleModifier) == 0x0007C4, "Member 'ABFGWeapon_UFO_QuantumDeconstructor::M_fRepulsorChargeAccumulator_VehicleModifier' has a wrong offset!");
static_assert(offsetof(ABFGWeapon_UFO_QuantumDeconstructor, M_fRepulsorChargeAccumulator_BuildingModifier) == 0x0007C8, "Member 'ABFGWeapon_UFO_QuantumDeconstructor::M_fRepulsorChargeAccumulator_BuildingModifier' has a wrong offset!");

// Class BFGCore.BFGAnimation_Events_Animal
// 0x0000 (0x0238 - 0x0238)
class UBFGAnimation_Events_Animal final : public UBFGAnimation_Events_Npc
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"BFGAnimation_Events_Animal">();
	}
	static class UBFGAnimation_Events_Animal* GetDefaultObj()
	{
		return GetDefaultObjImpl<UBFGAnimation_Events_Animal>();
	}
};
static_assert(alignof(UBFGAnimation_Events_Animal) == 0x000008, "Wrong alignment on UBFGAnimation_Events_Animal");
static_assert(sizeof(UBFGAnimation_Events_Animal) == 0x000238, "Wrong size on UBFGAnimation_Events_Animal");

// Class BFGCore.BFGAnimation_Events_Boss
// 0x0108 (0x0340 - 0x0238)
class UBFGAnimation_Events_Boss final : public UBFGAnimation_Events_Npc
{
public:
	UMulticastDelegateProperty_                   M_G2ACallReinforcementsAction;                     // 0x0238(0x0018)(ZeroConstructor, InstancedReference, BlueprintAssignable, BlueprintCallable, NativeAccessSpecifierPublic)
	UMulticastDelegateProperty_                   M_G2AEnrageBeforeCharge;                           // 0x0250(0x0018)(ZeroConstructor, InstancedReference, BlueprintAssignable, BlueprintCallable, NativeAccessSpecifierPublic)
	UMulticastDelegateProperty_                   M_G2ALeapAction;                                   // 0x0268(0x0018)(ZeroConstructor, InstancedReference, BlueprintAssignable, BlueprintCallable, NativeAccessSpecifierPublic)
	UMulticastDelegateProperty_                   M_G2AStompActionStarted;                           // 0x0280(0x0018)(ZeroConstructor, InstancedReference, BlueprintAssignable, BlueprintCallable, NativeAccessSpecifierPublic)
	UMulticastDelegateProperty_                   M_G2AKnockDown;                                    // 0x0298(0x0018)(ZeroConstructor, InstancedReference, BlueprintAssignable, BlueprintCallable, NativeAccessSpecifierPublic)
	UMulticastDelegateProperty_                   M_G2AStandUpStarted;                               // 0x02B0(0x0018)(ZeroConstructor, InstancedReference, BlueprintAssignable, BlueprintCallable, NativeAccessSpecifierPublic)
	UMulticastDelegateProperty_                   M_G2ARocketLaunched;                               // 0x02C8(0x0018)(ZeroConstructor, InstancedReference, BlueprintAssignable, BlueprintCallable, NativeAccessSpecifierPublic)
	UMulticastDelegateProperty_                   M_G2AEvasionAction;                                // 0x02E0(0x0018)(ZeroConstructor, InstancedReference, BlueprintAssignable, BlueprintCallable, NativeAccessSpecifierPublic)
	UMulticastDelegateProperty_                   M_G2ANasalActionStarted;                           // 0x02F8(0x0018)(ZeroConstructor, InstancedReference, BlueprintAssignable, BlueprintCallable, NativeAccessSpecifierPublic)
	UMulticastDelegateProperty_                   M_G2APhaseTransitionTriggered;                     // 0x0310(0x0018)(ZeroConstructor, InstancedReference, BlueprintAssignable, BlueprintCallable, NativeAccessSpecifierPublic)
	UMulticastDelegateProperty_                   M_G2ABossInterruptedByDamage;                      // 0x0328(0x0018)(ZeroConstructor, InstancedReference, BlueprintAssignable, BlueprintCallable, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"BFGAnimation_Events_Boss">();
	}
	static class UBFGAnimation_Events_Boss* GetDefaultObj()
	{
		return GetDefaultObjImpl<UBFGAnimation_Events_Boss>();
	}
};
static_assert(alignof(UBFGAnimation_Events_Boss) == 0x000008, "Wrong alignment on UBFGAnimation_Events_Boss");
static_assert(sizeof(UBFGAnimation_Events_Boss) == 0x000340, "Wrong size on UBFGAnimation_Events_Boss");
static_assert(offsetof(UBFGAnimation_Events_Boss, M_G2ACallReinforcementsAction) == 0x000238, "Member 'UBFGAnimation_Events_Boss::M_G2ACallReinforcementsAction' has a wrong offset!");
static_assert(offsetof(UBFGAnimation_Events_Boss, M_G2AEnrageBeforeCharge) == 0x000250, "Member 'UBFGAnimation_Events_Boss::M_G2AEnrageBeforeCharge' has a wrong offset!");
static_assert(offsetof(UBFGAnimation_Events_Boss, M_G2ALeapAction) == 0x000268, "Member 'UBFGAnimation_Events_Boss::M_G2ALeapAction' has a wrong offset!");
static_assert(offsetof(UBFGAnimation_Events_Boss, M_G2AStompActionStarted) == 0x000280, "Member 'UBFGAnimation_Events_Boss::M_G2AStompActionStarted' has a wrong offset!");
static_assert(offsetof(UBFGAnimation_Events_Boss, M_G2AKnockDown) == 0x000298, "Member 'UBFGAnimation_Events_Boss::M_G2AKnockDown' has a wrong offset!");
static_assert(offsetof(UBFGAnimation_Events_Boss, M_G2AStandUpStarted) == 0x0002B0, "Member 'UBFGAnimation_Events_Boss::M_G2AStandUpStarted' has a wrong offset!");
static_assert(offsetof(UBFGAnimation_Events_Boss, M_G2ARocketLaunched) == 0x0002C8, "Member 'UBFGAnimation_Events_Boss::M_G2ARocketLaunched' has a wrong offset!");
static_assert(offsetof(UBFGAnimation_Events_Boss, M_G2AEvasionAction) == 0x0002E0, "Member 'UBFGAnimation_Events_Boss::M_G2AEvasionAction' has a wrong offset!");
static_assert(offsetof(UBFGAnimation_Events_Boss, M_G2ANasalActionStarted) == 0x0002F8, "Member 'UBFGAnimation_Events_Boss::M_G2ANasalActionStarted' has a wrong offset!");
static_assert(offsetof(UBFGAnimation_Events_Boss, M_G2APhaseTransitionTriggered) == 0x000310, "Member 'UBFGAnimation_Events_Boss::M_G2APhaseTransitionTriggered' has a wrong offset!");
static_assert(offsetof(UBFGAnimation_Events_Boss, M_G2ABossInterruptedByDamage) == 0x000328, "Member 'UBFGAnimation_Events_Boss::M_G2ABossInterruptedByDamage' has a wrong offset!");

// Class BFGCore.BFGNarrativeSequenceNode_End
// 0x0000 (0x00C0 - 0x00C0)
class UBFGNarrativeSequenceNode_End final : public UBFGNarrativeSequenceNode
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"BFGNarrativeSequenceNode_End">();
	}
	static class UBFGNarrativeSequenceNode_End* GetDefaultObj()
	{
		return GetDefaultObjImpl<UBFGNarrativeSequenceNode_End>();
	}
};
static_assert(alignof(UBFGNarrativeSequenceNode_End) == 0x000008, "Wrong alignment on UBFGNarrativeSequenceNode_End");
static_assert(sizeof(UBFGNarrativeSequenceNode_End) == 0x0000C0, "Wrong size on UBFGNarrativeSequenceNode_End");

// Class BFGCore.BFGVariableAction_MissionGroup_Lock
// 0x0000 (0x00F0 - 0x00F0)
class UBFGVariableAction_MissionGroup_Lock final : public UBFGVariableAction
{
public:
	static const class FName GetActionName_MissionGroupLock();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"BFGVariableAction_MissionGroup_Lock">();
	}
	static class UBFGVariableAction_MissionGroup_Lock* GetDefaultObj()
	{
		return GetDefaultObjImpl<UBFGVariableAction_MissionGroup_Lock>();
	}
};
static_assert(alignof(UBFGVariableAction_MissionGroup_Lock) == 0x000008, "Wrong alignment on UBFGVariableAction_MissionGroup_Lock");
static_assert(sizeof(UBFGVariableAction_MissionGroup_Lock) == 0x0000F0, "Wrong size on UBFGVariableAction_MissionGroup_Lock");

// Class BFGCore.BFGDataAsset_BossPhase_Silhouette
// 0x0030 (0x00B8 - 0x0088)
class UBFGDataAsset_BossPhase_Silhouette final : public UBFGDataAsset_BossPhase
{
public:
	int32                                         M_iAdditionalNasalProbes;                          // 0x0088(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         M_fShield;                                         // 0x008C(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         M_fDamageInWeakstate;                              // 0x0090(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         M_fRBPBeamWarning;                                 // 0x0094(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         M_fRBPBeamFire;                                    // 0x0098(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         M_fRBPBeamDamageOnBoss;                            // 0x009C(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         M_fRBPBeamDamageOnPlayer;                          // 0x00A0(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         M_fRBPBeamDamageOnActors;                          // 0x00A4(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         M_fTimerToCheckIsPlayerInCover;                    // 0x00A8(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         M_fNasalProbeDrainLimit;                           // 0x00AC(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class ABFGNPCCharacterEnemy_PSIStation*       M_pPSIStation;                                     // 0x00B0(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"BFGDataAsset_BossPhase_Silhouette">();
	}
	static class UBFGDataAsset_BossPhase_Silhouette* GetDefaultObj()
	{
		return GetDefaultObjImpl<UBFGDataAsset_BossPhase_Silhouette>();
	}
};
static_assert(alignof(UBFGDataAsset_BossPhase_Silhouette) == 0x000008, "Wrong alignment on UBFGDataAsset_BossPhase_Silhouette");
static_assert(sizeof(UBFGDataAsset_BossPhase_Silhouette) == 0x0000B8, "Wrong size on UBFGDataAsset_BossPhase_Silhouette");
static_assert(offsetof(UBFGDataAsset_BossPhase_Silhouette, M_iAdditionalNasalProbes) == 0x000088, "Member 'UBFGDataAsset_BossPhase_Silhouette::M_iAdditionalNasalProbes' has a wrong offset!");
static_assert(offsetof(UBFGDataAsset_BossPhase_Silhouette, M_fShield) == 0x00008C, "Member 'UBFGDataAsset_BossPhase_Silhouette::M_fShield' has a wrong offset!");
static_assert(offsetof(UBFGDataAsset_BossPhase_Silhouette, M_fDamageInWeakstate) == 0x000090, "Member 'UBFGDataAsset_BossPhase_Silhouette::M_fDamageInWeakstate' has a wrong offset!");
static_assert(offsetof(UBFGDataAsset_BossPhase_Silhouette, M_fRBPBeamWarning) == 0x000094, "Member 'UBFGDataAsset_BossPhase_Silhouette::M_fRBPBeamWarning' has a wrong offset!");
static_assert(offsetof(UBFGDataAsset_BossPhase_Silhouette, M_fRBPBeamFire) == 0x000098, "Member 'UBFGDataAsset_BossPhase_Silhouette::M_fRBPBeamFire' has a wrong offset!");
static_assert(offsetof(UBFGDataAsset_BossPhase_Silhouette, M_fRBPBeamDamageOnBoss) == 0x00009C, "Member 'UBFGDataAsset_BossPhase_Silhouette::M_fRBPBeamDamageOnBoss' has a wrong offset!");
static_assert(offsetof(UBFGDataAsset_BossPhase_Silhouette, M_fRBPBeamDamageOnPlayer) == 0x0000A0, "Member 'UBFGDataAsset_BossPhase_Silhouette::M_fRBPBeamDamageOnPlayer' has a wrong offset!");
static_assert(offsetof(UBFGDataAsset_BossPhase_Silhouette, M_fRBPBeamDamageOnActors) == 0x0000A4, "Member 'UBFGDataAsset_BossPhase_Silhouette::M_fRBPBeamDamageOnActors' has a wrong offset!");
static_assert(offsetof(UBFGDataAsset_BossPhase_Silhouette, M_fTimerToCheckIsPlayerInCover) == 0x0000A8, "Member 'UBFGDataAsset_BossPhase_Silhouette::M_fTimerToCheckIsPlayerInCover' has a wrong offset!");
static_assert(offsetof(UBFGDataAsset_BossPhase_Silhouette, M_fNasalProbeDrainLimit) == 0x0000AC, "Member 'UBFGDataAsset_BossPhase_Silhouette::M_fNasalProbeDrainLimit' has a wrong offset!");
static_assert(offsetof(UBFGDataAsset_BossPhase_Silhouette, M_pPSIStation) == 0x0000B0, "Member 'UBFGDataAsset_BossPhase_Silhouette::M_pPSIStation' has a wrong offset!");

// Class BFGCore.BFGAnimation_Events_Crypto
// 0x0000 (0x01F0 - 0x01F0)
class UBFGAnimation_Events_Crypto final : public UBFGAnimation_Events
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"BFGAnimation_Events_Crypto">();
	}
	static class UBFGAnimation_Events_Crypto* GetDefaultObj()
	{
		return GetDefaultObjImpl<UBFGAnimation_Events_Crypto>();
	}
};
static_assert(alignof(UBFGAnimation_Events_Crypto) == 0x000008, "Wrong alignment on UBFGAnimation_Events_Crypto");
static_assert(sizeof(UBFGAnimation_Events_Crypto) == 0x0001F0, "Wrong size on UBFGAnimation_Events_Crypto");

// Class BFGCore.BFGAnimation_Events_Human
// 0x0000 (0x0238 - 0x0238)
class UBFGAnimation_Events_Human final : public UBFGAnimation_Events_Npc
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"BFGAnimation_Events_Human">();
	}
	static class UBFGAnimation_Events_Human* GetDefaultObj()
	{
		return GetDefaultObjImpl<UBFGAnimation_Events_Human>();
	}
};
static_assert(alignof(UBFGAnimation_Events_Human) == 0x000008, "Wrong alignment on UBFGAnimation_Events_Human");
static_assert(sizeof(UBFGAnimation_Events_Human) == 0x000238, "Wrong size on UBFGAnimation_Events_Human");

// Class BFGCore.BFGMentalAbility_Transmogrify
// 0x0028 (0x01F0 - 0x01C8)
class UBFGMentalAbility_Transmogrify : public UBFGMentalAbilityBase
{
public:
	TSubclassOf<class UDamageType>                M_pFatalDamageType;                                // 0x01C8(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	struct FVector                                M_vSingularityOffset;                              // 0x01D0(0x000C)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         M_fLootDelayIncrement;                             // 0x01DC(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	struct FVector                                M_vSingularityLocation;                            // 0x01E0(0x000C)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_1EC[0x4];                                      // 0x01EC(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"BFGMentalAbility_Transmogrify">();
	}
	static class UBFGMentalAbility_Transmogrify* GetDefaultObj()
	{
		return GetDefaultObjImpl<UBFGMentalAbility_Transmogrify>();
	}
};
static_assert(alignof(UBFGMentalAbility_Transmogrify) == 0x000008, "Wrong alignment on UBFGMentalAbility_Transmogrify");
static_assert(sizeof(UBFGMentalAbility_Transmogrify) == 0x0001F0, "Wrong size on UBFGMentalAbility_Transmogrify");
static_assert(offsetof(UBFGMentalAbility_Transmogrify, M_pFatalDamageType) == 0x0001C8, "Member 'UBFGMentalAbility_Transmogrify::M_pFatalDamageType' has a wrong offset!");
static_assert(offsetof(UBFGMentalAbility_Transmogrify, M_vSingularityOffset) == 0x0001D0, "Member 'UBFGMentalAbility_Transmogrify::M_vSingularityOffset' has a wrong offset!");
static_assert(offsetof(UBFGMentalAbility_Transmogrify, M_fLootDelayIncrement) == 0x0001DC, "Member 'UBFGMentalAbility_Transmogrify::M_fLootDelayIncrement' has a wrong offset!");
static_assert(offsetof(UBFGMentalAbility_Transmogrify, M_vSingularityLocation) == 0x0001E0, "Member 'UBFGMentalAbility_Transmogrify::M_vSingularityLocation' has a wrong offset!");

// Class BFGCore.BFGUFOAbility_Transmog
// 0x0000 (0x01F0 - 0x01F0)
class UBFGUFOAbility_Transmog : public UBFGMentalAbility_Transmogrify
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"BFGUFOAbility_Transmog">();
	}
	static class UBFGUFOAbility_Transmog* GetDefaultObj()
	{
		return GetDefaultObjImpl<UBFGUFOAbility_Transmog>();
	}
};
static_assert(alignof(UBFGUFOAbility_Transmog) == 0x000008, "Wrong alignment on UBFGUFOAbility_Transmog");
static_assert(sizeof(UBFGUFOAbility_Transmog) == 0x0001F0, "Wrong size on UBFGUFOAbility_Transmog");

// Class BFGCore.BFGDataAsset_BossData_Armquist
// 0x00E0 (0x0138 - 0x0058)
class UBFGDataAsset_BossData_Armquist final : public UBFGDataAsset_BossData
{
public:
	TMap<EBFGRocketSocket, class FName>           M_mRocketSocketMap;                                // 0x0058(0x0050)(Edit, ZeroConstructor, Protected, NativeAccessSpecifierProtected)
	class USoundCue*                              M_pReinforcementVO_Default;                        // 0x00A8(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class USoundCue*                              M_pReinforcementVO_NavyIntro;                      // 0x00B0(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class USoundCue*                              M_pReinforcementVO_NavyDefault;                    // 0x00B8(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class USoundCue*                              M_pReinforcementVO_AirIntro;                       // 0x00C0(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class USoundCue*                              M_pReinforcementVO_AirDefault;                     // 0x00C8(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         M_fActionTelegraphTime_Charge;                     // 0x00D0(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         M_fMinDistanceToCharge;                            // 0x00D4(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         M_fMaxDistanceToCharge;                            // 0x00D8(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         M_fMinDistanceAcceptanceRadiusToPlayer;            // 0x00DC(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         M_fMinDistanceAcceptanceRadiusToObject;            // 0x00E0(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         M_fMinDistanceImpulse;                             // 0x00E4(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         M_fImpulseStrength;                                // 0x00E8(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         M_fActionCharge_AOEDelay;                          // 0x00EC(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TSubclassOf<class ABFGAOE_Boss>               M_pAOEClass_Charge;                                // 0x00F0(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         M_fActionTelegraphTime_Leap;                       // 0x00F8(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         M_fMinDistanceToLeap;                              // 0x00FC(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         M_fMaxHeight_Leap;                                 // 0x0100(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_104[0x4];                                      // 0x0104(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	TSubclassOf<class ABFGAOE_Boss>               M_pAOEClass_Leap;                                  // 0x0108(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UCurveFloat*                            M_pTimeline_SpeedCurve_Leap;                       // 0x0110(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         M_fActionTelegraphTime_Stomp;                      // 0x0118(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         M_fActionTelegraphRadius_Stomp;                    // 0x011C(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TSubclassOf<class ABFGAOE_Boss>               M_pAOEClass_Stomp;                                 // 0x0120(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	int32                                         M_iAirMineMaxSpawnNumber;                          // 0x0128(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_12C[0x4];                                      // 0x012C(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	TSubclassOf<class ABFGNPCCharacterEnemy_Mine> M_pClass_AirMine;                                  // 0x0130(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"BFGDataAsset_BossData_Armquist">();
	}
	static class UBFGDataAsset_BossData_Armquist* GetDefaultObj()
	{
		return GetDefaultObjImpl<UBFGDataAsset_BossData_Armquist>();
	}
};
static_assert(alignof(UBFGDataAsset_BossData_Armquist) == 0x000008, "Wrong alignment on UBFGDataAsset_BossData_Armquist");
static_assert(sizeof(UBFGDataAsset_BossData_Armquist) == 0x000138, "Wrong size on UBFGDataAsset_BossData_Armquist");
static_assert(offsetof(UBFGDataAsset_BossData_Armquist, M_mRocketSocketMap) == 0x000058, "Member 'UBFGDataAsset_BossData_Armquist::M_mRocketSocketMap' has a wrong offset!");
static_assert(offsetof(UBFGDataAsset_BossData_Armquist, M_pReinforcementVO_Default) == 0x0000A8, "Member 'UBFGDataAsset_BossData_Armquist::M_pReinforcementVO_Default' has a wrong offset!");
static_assert(offsetof(UBFGDataAsset_BossData_Armquist, M_pReinforcementVO_NavyIntro) == 0x0000B0, "Member 'UBFGDataAsset_BossData_Armquist::M_pReinforcementVO_NavyIntro' has a wrong offset!");
static_assert(offsetof(UBFGDataAsset_BossData_Armquist, M_pReinforcementVO_NavyDefault) == 0x0000B8, "Member 'UBFGDataAsset_BossData_Armquist::M_pReinforcementVO_NavyDefault' has a wrong offset!");
static_assert(offsetof(UBFGDataAsset_BossData_Armquist, M_pReinforcementVO_AirIntro) == 0x0000C0, "Member 'UBFGDataAsset_BossData_Armquist::M_pReinforcementVO_AirIntro' has a wrong offset!");
static_assert(offsetof(UBFGDataAsset_BossData_Armquist, M_pReinforcementVO_AirDefault) == 0x0000C8, "Member 'UBFGDataAsset_BossData_Armquist::M_pReinforcementVO_AirDefault' has a wrong offset!");
static_assert(offsetof(UBFGDataAsset_BossData_Armquist, M_fActionTelegraphTime_Charge) == 0x0000D0, "Member 'UBFGDataAsset_BossData_Armquist::M_fActionTelegraphTime_Charge' has a wrong offset!");
static_assert(offsetof(UBFGDataAsset_BossData_Armquist, M_fMinDistanceToCharge) == 0x0000D4, "Member 'UBFGDataAsset_BossData_Armquist::M_fMinDistanceToCharge' has a wrong offset!");
static_assert(offsetof(UBFGDataAsset_BossData_Armquist, M_fMaxDistanceToCharge) == 0x0000D8, "Member 'UBFGDataAsset_BossData_Armquist::M_fMaxDistanceToCharge' has a wrong offset!");
static_assert(offsetof(UBFGDataAsset_BossData_Armquist, M_fMinDistanceAcceptanceRadiusToPlayer) == 0x0000DC, "Member 'UBFGDataAsset_BossData_Armquist::M_fMinDistanceAcceptanceRadiusToPlayer' has a wrong offset!");
static_assert(offsetof(UBFGDataAsset_BossData_Armquist, M_fMinDistanceAcceptanceRadiusToObject) == 0x0000E0, "Member 'UBFGDataAsset_BossData_Armquist::M_fMinDistanceAcceptanceRadiusToObject' has a wrong offset!");
static_assert(offsetof(UBFGDataAsset_BossData_Armquist, M_fMinDistanceImpulse) == 0x0000E4, "Member 'UBFGDataAsset_BossData_Armquist::M_fMinDistanceImpulse' has a wrong offset!");
static_assert(offsetof(UBFGDataAsset_BossData_Armquist, M_fImpulseStrength) == 0x0000E8, "Member 'UBFGDataAsset_BossData_Armquist::M_fImpulseStrength' has a wrong offset!");
static_assert(offsetof(UBFGDataAsset_BossData_Armquist, M_fActionCharge_AOEDelay) == 0x0000EC, "Member 'UBFGDataAsset_BossData_Armquist::M_fActionCharge_AOEDelay' has a wrong offset!");
static_assert(offsetof(UBFGDataAsset_BossData_Armquist, M_pAOEClass_Charge) == 0x0000F0, "Member 'UBFGDataAsset_BossData_Armquist::M_pAOEClass_Charge' has a wrong offset!");
static_assert(offsetof(UBFGDataAsset_BossData_Armquist, M_fActionTelegraphTime_Leap) == 0x0000F8, "Member 'UBFGDataAsset_BossData_Armquist::M_fActionTelegraphTime_Leap' has a wrong offset!");
static_assert(offsetof(UBFGDataAsset_BossData_Armquist, M_fMinDistanceToLeap) == 0x0000FC, "Member 'UBFGDataAsset_BossData_Armquist::M_fMinDistanceToLeap' has a wrong offset!");
static_assert(offsetof(UBFGDataAsset_BossData_Armquist, M_fMaxHeight_Leap) == 0x000100, "Member 'UBFGDataAsset_BossData_Armquist::M_fMaxHeight_Leap' has a wrong offset!");
static_assert(offsetof(UBFGDataAsset_BossData_Armquist, M_pAOEClass_Leap) == 0x000108, "Member 'UBFGDataAsset_BossData_Armquist::M_pAOEClass_Leap' has a wrong offset!");
static_assert(offsetof(UBFGDataAsset_BossData_Armquist, M_pTimeline_SpeedCurve_Leap) == 0x000110, "Member 'UBFGDataAsset_BossData_Armquist::M_pTimeline_SpeedCurve_Leap' has a wrong offset!");
static_assert(offsetof(UBFGDataAsset_BossData_Armquist, M_fActionTelegraphTime_Stomp) == 0x000118, "Member 'UBFGDataAsset_BossData_Armquist::M_fActionTelegraphTime_Stomp' has a wrong offset!");
static_assert(offsetof(UBFGDataAsset_BossData_Armquist, M_fActionTelegraphRadius_Stomp) == 0x00011C, "Member 'UBFGDataAsset_BossData_Armquist::M_fActionTelegraphRadius_Stomp' has a wrong offset!");
static_assert(offsetof(UBFGDataAsset_BossData_Armquist, M_pAOEClass_Stomp) == 0x000120, "Member 'UBFGDataAsset_BossData_Armquist::M_pAOEClass_Stomp' has a wrong offset!");
static_assert(offsetof(UBFGDataAsset_BossData_Armquist, M_iAirMineMaxSpawnNumber) == 0x000128, "Member 'UBFGDataAsset_BossData_Armquist::M_iAirMineMaxSpawnNumber' has a wrong offset!");
static_assert(offsetof(UBFGDataAsset_BossData_Armquist, M_pClass_AirMine) == 0x000130, "Member 'UBFGDataAsset_BossData_Armquist::M_pClass_AirMine' has a wrong offset!");

// Class BFGCore.BFGQuest_ElementScriptedSequence
// 0x0140 (0x0480 - 0x0340)
class UBFGQuest_ElementScriptedSequence final : public UBFGQuest_ElementObjectiveBase
{
public:
	UMulticastDelegateProperty_                   M_addScriptTasks;                                  // 0x0340(0x0018)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	TArray<struct FBFGQuest_ElementScriptedSequence_Objective> M_aObjectives;                                     // 0x0358(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, ContainsInstancedReference, NativeAccessSpecifierPublic)
	EFBFGQuest_Element_ExecutionTime              M_executionTime;                                   // 0x0368(0x0001)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	EFBFGQuest_Element_ProcessingMode             M_processingMode;                                  // 0x0369(0x0001)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          M_bFailScriptFailQuest;                            // 0x036A(0x0001)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_36B[0x5];                                      // 0x036B(0x0005)(Fixing Size After Last Property [ Dumper-7 ])
	struct FBFGQuest_Failure                      M_infoSequenceFail;                                // 0x0370(0x0088)(Edit, DisableEditOnInstance, Protected, NativeAccessSpecifierProtected)
	bool                                          M_bInfoScriptFailUpdated;                          // 0x03F8(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_3F9[0x7];                                      // 0x03F9(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	TSoftObjectPtr<class UBFGDataAsset_NewspaperInfo> M_softScriptFailNewspaper;                         // 0x0400(0x0028)(Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class FText                                   M_strScriptFailReason;                             // 0x0428(0x0018)(Protected, NativeAccessSpecifierProtected)
	TSoftClassPtr<class UClass>                   M_softScriptFailNarrativeSequence;                 // 0x0440(0x0028)(Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_468[0x8];                                      // 0x0468(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<struct FBFGQuest_ElementScriptedSequence_RuntimeData> M_aExtraRuntimeData;                               // 0x0470(0x0010)(ZeroConstructor, Transient, Protected, NativeAccessSpecifierProtected)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"BFGQuest_ElementScriptedSequence">();
	}
	static class UBFGQuest_ElementScriptedSequence* GetDefaultObj()
	{
		return GetDefaultObjImpl<UBFGQuest_ElementScriptedSequence>();
	}
};
static_assert(alignof(UBFGQuest_ElementScriptedSequence) == 0x000008, "Wrong alignment on UBFGQuest_ElementScriptedSequence");
static_assert(sizeof(UBFGQuest_ElementScriptedSequence) == 0x000480, "Wrong size on UBFGQuest_ElementScriptedSequence");
static_assert(offsetof(UBFGQuest_ElementScriptedSequence, M_addScriptTasks) == 0x000340, "Member 'UBFGQuest_ElementScriptedSequence::M_addScriptTasks' has a wrong offset!");
static_assert(offsetof(UBFGQuest_ElementScriptedSequence, M_aObjectives) == 0x000358, "Member 'UBFGQuest_ElementScriptedSequence::M_aObjectives' has a wrong offset!");
static_assert(offsetof(UBFGQuest_ElementScriptedSequence, M_executionTime) == 0x000368, "Member 'UBFGQuest_ElementScriptedSequence::M_executionTime' has a wrong offset!");
static_assert(offsetof(UBFGQuest_ElementScriptedSequence, M_processingMode) == 0x000369, "Member 'UBFGQuest_ElementScriptedSequence::M_processingMode' has a wrong offset!");
static_assert(offsetof(UBFGQuest_ElementScriptedSequence, M_bFailScriptFailQuest) == 0x00036A, "Member 'UBFGQuest_ElementScriptedSequence::M_bFailScriptFailQuest' has a wrong offset!");
static_assert(offsetof(UBFGQuest_ElementScriptedSequence, M_infoSequenceFail) == 0x000370, "Member 'UBFGQuest_ElementScriptedSequence::M_infoSequenceFail' has a wrong offset!");
static_assert(offsetof(UBFGQuest_ElementScriptedSequence, M_bInfoScriptFailUpdated) == 0x0003F8, "Member 'UBFGQuest_ElementScriptedSequence::M_bInfoScriptFailUpdated' has a wrong offset!");
static_assert(offsetof(UBFGQuest_ElementScriptedSequence, M_softScriptFailNewspaper) == 0x000400, "Member 'UBFGQuest_ElementScriptedSequence::M_softScriptFailNewspaper' has a wrong offset!");
static_assert(offsetof(UBFGQuest_ElementScriptedSequence, M_strScriptFailReason) == 0x000428, "Member 'UBFGQuest_ElementScriptedSequence::M_strScriptFailReason' has a wrong offset!");
static_assert(offsetof(UBFGQuest_ElementScriptedSequence, M_softScriptFailNarrativeSequence) == 0x000440, "Member 'UBFGQuest_ElementScriptedSequence::M_softScriptFailNarrativeSequence' has a wrong offset!");
static_assert(offsetof(UBFGQuest_ElementScriptedSequence, M_aExtraRuntimeData) == 0x000470, "Member 'UBFGQuest_ElementScriptedSequence::M_aExtraRuntimeData' has a wrong offset!");

// Class BFGCore.BFGAnimation_Events_Pox
// 0x0030 (0x0220 - 0x01F0)
class UBFGAnimation_Events_Pox final : public UBFGAnimation_Events
{
public:
	UMulticastDelegateProperty_                   M_G2APlayAnimationSequenceByName;                  // 0x01F0(0x0018)(ZeroConstructor, InstancedReference, BlueprintAssignable, BlueprintCallable, NativeAccessSpecifierPublic)
	UMulticastDelegateProperty_                   M_G2AStopCurrentAnimationSequence;                 // 0x0208(0x0018)(ZeroConstructor, InstancedReference, BlueprintAssignable, BlueprintCallable, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"BFGAnimation_Events_Pox">();
	}
	static class UBFGAnimation_Events_Pox* GetDefaultObj()
	{
		return GetDefaultObjImpl<UBFGAnimation_Events_Pox>();
	}
};
static_assert(alignof(UBFGAnimation_Events_Pox) == 0x000008, "Wrong alignment on UBFGAnimation_Events_Pox");
static_assert(sizeof(UBFGAnimation_Events_Pox) == 0x000220, "Wrong size on UBFGAnimation_Events_Pox");
static_assert(offsetof(UBFGAnimation_Events_Pox, M_G2APlayAnimationSequenceByName) == 0x0001F0, "Member 'UBFGAnimation_Events_Pox::M_G2APlayAnimationSequenceByName' has a wrong offset!");
static_assert(offsetof(UBFGAnimation_Events_Pox, M_G2AStopCurrentAnimationSequence) == 0x000208, "Member 'UBFGAnimation_Events_Pox::M_G2AStopCurrentAnimationSequence' has a wrong offset!");

// Class BFGCore.BFGNetworkPathAgent
// 0x0578 (0x05A0 - 0x0028)
class UBFGNetworkPathAgent : public UObject
{
public:
	uint8                                         Pad_28[0x18];                                      // 0x0028(0x0018)(Fixing Size After Last Property [ Dumper-7 ])
	UMulticastDelegateProperty_                   M_onDestroyed;                                     // 0x0040(0x0018)(ZeroConstructor, InstancedReference, BlueprintAssignable, BlueprintCallable, NativeAccessSpecifierPublic)
	UMulticastDelegateProperty_                   M_onAttachedActorReset;                            // 0x0058(0x0018)(ZeroConstructor, InstancedReference, BlueprintAssignable, BlueprintCallable, NativeAccessSpecifierPublic)
	uint8                                         Pad_70[0x10];                                      // 0x0070(0x0010)(Fixing Size After Last Property [ Dumper-7 ])
	struct FBFGNetworkPathAgent_ActorlessSpawnData M_ActorlessSpawnData;                              // 0x0080(0x03F8)(Transient, NativeAccessSpecifierPublic)
	uint8                                         Pad_478[0x8];                                      // 0x0478(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	class ULevel*                                 M_pLevel;                                          // 0x0480(0x0008)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UWorld*                                 M_pLevelWorld;                                     // 0x0488(0x0008)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          M_bActive;                                         // 0x0490(0x0001)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          M_bBeingDestroyed;                                 // 0x0491(0x0001)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_492[0x6];                                      // 0x0492(0x0006)(Fixing Size After Last Property [ Dumper-7 ])
	class UBFGTrafficCrowdManager*                M_pManager;                                        // 0x0498(0x0008)(ExportObject, ZeroConstructor, Transient, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UBFGVirtualCrowdManager*                M_pVirtualCrowd;                                   // 0x04A0(0x0008)(ExportObject, ZeroConstructor, Transient, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TSoftObjectPtr<class AActor>                  M_softReference;                                   // 0x04A8(0x0028)(Transient, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	struct FVector                                M_vAgentLocation;                                  // 0x04D0(0x000C)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	struct FVector                                M_vAgentDirection;                                 // 0x04DC(0x000C)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	struct FVector                                M_vPreviousAgentLocation;                          // 0x04E8(0x000C)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	struct FVector                                M_vPreviousAgentDirection;                         // 0x04F4(0x000C)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         M_fSpeed;                                          // 0x0500(0x0004)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	struct FVector                                M_vTargetLocation;                                 // 0x0504(0x000C)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	struct FVector                                M_vTargetDirection;                                // 0x0510(0x000C)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	struct FVector                                M_vLastTargetLocation;                             // 0x051C(0x000C)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	EBFGNetworkPathAgentMode                      M_eAgentMode;                                      // 0x0528(0x0001)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          M_bDespawnOnDeath;                                 // 0x0529(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_52A[0x2];                                      // 0x052A(0x0002)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         M_fCurrentTargetSpeed;                             // 0x052C(0x0004)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         M_fMainTimerTickInterval;                          // 0x0530(0x0004)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         M_fUpdateTimer;                                    // 0x0534(0x0004)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	EBFGNetworkPathAgentDespawnRequest            M_eDespawnRequest;                                 // 0x0538(0x0001)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_539[0x3];                                      // 0x0539(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         M_fDespawnTimer;                                   // 0x053C(0x0004)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TWeakObjectPtr<class UBFGNetworkPath>         M_pSpawnerPath;                                    // 0x0540(0x0008)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          M_bIsTracked;                                      // 0x0548(0x0001)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	EBFGNetworkPathAgentPriorityLevel             M_ePriority;                                       // 0x0549(0x0001)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	EBFGNetworkPathAgentEnterExitRule             M_eEnterExitRule;                                  // 0x054A(0x0001)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_54B[0x5];                                      // 0x054B(0x0005)(Fixing Size After Last Property [ Dumper-7 ])
	class UBFGNetworkPathAgent_AttachedEntity*    M_pAttachedEntity;                                 // 0x0550(0x0008)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UBFGNetworkPathAgent_Navigation*        M_pNavigation;                                     // 0x0558(0x0008)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UBFGNetworkPathAgent_Move*              M_pMove;                                           // 0x0560(0x0008)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UBFGNetworkPathAgent_AI*                M_pAI;                                             // 0x0568(0x0008)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UBFGNetworkPathAgentRadarInfo*          M_pRadar;                                          // 0x0570(0x0008)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_578[0x8];                                      // 0x0578(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	class UBFGTrafficPathFinder_Tester*           M_pPathFinderTest;                                 // 0x0580(0x0008)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         M_fTimerLightWeightSwitch;                         // 0x0588(0x0004)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_58C[0x4];                                      // 0x058C(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class UBFGCrowdLifeStationComponent*          M_pStation;                                        // 0x0590(0x0008)(ExportObject, ZeroConstructor, Transient, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         M_fTimeSinceNotVisible;                            // 0x0598(0x0004)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          M_bDespawned;                                      // 0x059C(0x0001)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_59D[0x3];                                      // 0x059D(0x0003)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void OnAttachedActorChange(class UBFGNetworkPathAgent* _pAgent, class AActor* _pActor, bool _bIsAttached);
	void OnLevelRemovedFromWorld(class ULevel* _pLevel, class UWorld* _pWorld);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"BFGNetworkPathAgent">();
	}
	static class UBFGNetworkPathAgent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UBFGNetworkPathAgent>();
	}
};
static_assert(alignof(UBFGNetworkPathAgent) == 0x000008, "Wrong alignment on UBFGNetworkPathAgent");
static_assert(sizeof(UBFGNetworkPathAgent) == 0x0005A0, "Wrong size on UBFGNetworkPathAgent");
static_assert(offsetof(UBFGNetworkPathAgent, M_onDestroyed) == 0x000040, "Member 'UBFGNetworkPathAgent::M_onDestroyed' has a wrong offset!");
static_assert(offsetof(UBFGNetworkPathAgent, M_onAttachedActorReset) == 0x000058, "Member 'UBFGNetworkPathAgent::M_onAttachedActorReset' has a wrong offset!");
static_assert(offsetof(UBFGNetworkPathAgent, M_ActorlessSpawnData) == 0x000080, "Member 'UBFGNetworkPathAgent::M_ActorlessSpawnData' has a wrong offset!");
static_assert(offsetof(UBFGNetworkPathAgent, M_pLevel) == 0x000480, "Member 'UBFGNetworkPathAgent::M_pLevel' has a wrong offset!");
static_assert(offsetof(UBFGNetworkPathAgent, M_pLevelWorld) == 0x000488, "Member 'UBFGNetworkPathAgent::M_pLevelWorld' has a wrong offset!");
static_assert(offsetof(UBFGNetworkPathAgent, M_bActive) == 0x000490, "Member 'UBFGNetworkPathAgent::M_bActive' has a wrong offset!");
static_assert(offsetof(UBFGNetworkPathAgent, M_bBeingDestroyed) == 0x000491, "Member 'UBFGNetworkPathAgent::M_bBeingDestroyed' has a wrong offset!");
static_assert(offsetof(UBFGNetworkPathAgent, M_pManager) == 0x000498, "Member 'UBFGNetworkPathAgent::M_pManager' has a wrong offset!");
static_assert(offsetof(UBFGNetworkPathAgent, M_pVirtualCrowd) == 0x0004A0, "Member 'UBFGNetworkPathAgent::M_pVirtualCrowd' has a wrong offset!");
static_assert(offsetof(UBFGNetworkPathAgent, M_softReference) == 0x0004A8, "Member 'UBFGNetworkPathAgent::M_softReference' has a wrong offset!");
static_assert(offsetof(UBFGNetworkPathAgent, M_vAgentLocation) == 0x0004D0, "Member 'UBFGNetworkPathAgent::M_vAgentLocation' has a wrong offset!");
static_assert(offsetof(UBFGNetworkPathAgent, M_vAgentDirection) == 0x0004DC, "Member 'UBFGNetworkPathAgent::M_vAgentDirection' has a wrong offset!");
static_assert(offsetof(UBFGNetworkPathAgent, M_vPreviousAgentLocation) == 0x0004E8, "Member 'UBFGNetworkPathAgent::M_vPreviousAgentLocation' has a wrong offset!");
static_assert(offsetof(UBFGNetworkPathAgent, M_vPreviousAgentDirection) == 0x0004F4, "Member 'UBFGNetworkPathAgent::M_vPreviousAgentDirection' has a wrong offset!");
static_assert(offsetof(UBFGNetworkPathAgent, M_fSpeed) == 0x000500, "Member 'UBFGNetworkPathAgent::M_fSpeed' has a wrong offset!");
static_assert(offsetof(UBFGNetworkPathAgent, M_vTargetLocation) == 0x000504, "Member 'UBFGNetworkPathAgent::M_vTargetLocation' has a wrong offset!");
static_assert(offsetof(UBFGNetworkPathAgent, M_vTargetDirection) == 0x000510, "Member 'UBFGNetworkPathAgent::M_vTargetDirection' has a wrong offset!");
static_assert(offsetof(UBFGNetworkPathAgent, M_vLastTargetLocation) == 0x00051C, "Member 'UBFGNetworkPathAgent::M_vLastTargetLocation' has a wrong offset!");
static_assert(offsetof(UBFGNetworkPathAgent, M_eAgentMode) == 0x000528, "Member 'UBFGNetworkPathAgent::M_eAgentMode' has a wrong offset!");
static_assert(offsetof(UBFGNetworkPathAgent, M_bDespawnOnDeath) == 0x000529, "Member 'UBFGNetworkPathAgent::M_bDespawnOnDeath' has a wrong offset!");
static_assert(offsetof(UBFGNetworkPathAgent, M_fCurrentTargetSpeed) == 0x00052C, "Member 'UBFGNetworkPathAgent::M_fCurrentTargetSpeed' has a wrong offset!");
static_assert(offsetof(UBFGNetworkPathAgent, M_fMainTimerTickInterval) == 0x000530, "Member 'UBFGNetworkPathAgent::M_fMainTimerTickInterval' has a wrong offset!");
static_assert(offsetof(UBFGNetworkPathAgent, M_fUpdateTimer) == 0x000534, "Member 'UBFGNetworkPathAgent::M_fUpdateTimer' has a wrong offset!");
static_assert(offsetof(UBFGNetworkPathAgent, M_eDespawnRequest) == 0x000538, "Member 'UBFGNetworkPathAgent::M_eDespawnRequest' has a wrong offset!");
static_assert(offsetof(UBFGNetworkPathAgent, M_fDespawnTimer) == 0x00053C, "Member 'UBFGNetworkPathAgent::M_fDespawnTimer' has a wrong offset!");
static_assert(offsetof(UBFGNetworkPathAgent, M_pSpawnerPath) == 0x000540, "Member 'UBFGNetworkPathAgent::M_pSpawnerPath' has a wrong offset!");
static_assert(offsetof(UBFGNetworkPathAgent, M_bIsTracked) == 0x000548, "Member 'UBFGNetworkPathAgent::M_bIsTracked' has a wrong offset!");
static_assert(offsetof(UBFGNetworkPathAgent, M_ePriority) == 0x000549, "Member 'UBFGNetworkPathAgent::M_ePriority' has a wrong offset!");
static_assert(offsetof(UBFGNetworkPathAgent, M_eEnterExitRule) == 0x00054A, "Member 'UBFGNetworkPathAgent::M_eEnterExitRule' has a wrong offset!");
static_assert(offsetof(UBFGNetworkPathAgent, M_pAttachedEntity) == 0x000550, "Member 'UBFGNetworkPathAgent::M_pAttachedEntity' has a wrong offset!");
static_assert(offsetof(UBFGNetworkPathAgent, M_pNavigation) == 0x000558, "Member 'UBFGNetworkPathAgent::M_pNavigation' has a wrong offset!");
static_assert(offsetof(UBFGNetworkPathAgent, M_pMove) == 0x000560, "Member 'UBFGNetworkPathAgent::M_pMove' has a wrong offset!");
static_assert(offsetof(UBFGNetworkPathAgent, M_pAI) == 0x000568, "Member 'UBFGNetworkPathAgent::M_pAI' has a wrong offset!");
static_assert(offsetof(UBFGNetworkPathAgent, M_pRadar) == 0x000570, "Member 'UBFGNetworkPathAgent::M_pRadar' has a wrong offset!");
static_assert(offsetof(UBFGNetworkPathAgent, M_pPathFinderTest) == 0x000580, "Member 'UBFGNetworkPathAgent::M_pPathFinderTest' has a wrong offset!");
static_assert(offsetof(UBFGNetworkPathAgent, M_fTimerLightWeightSwitch) == 0x000588, "Member 'UBFGNetworkPathAgent::M_fTimerLightWeightSwitch' has a wrong offset!");
static_assert(offsetof(UBFGNetworkPathAgent, M_pStation) == 0x000590, "Member 'UBFGNetworkPathAgent::M_pStation' has a wrong offset!");
static_assert(offsetof(UBFGNetworkPathAgent, M_fTimeSinceNotVisible) == 0x000598, "Member 'UBFGNetworkPathAgent::M_fTimeSinceNotVisible' has a wrong offset!");
static_assert(offsetof(UBFGNetworkPathAgent, M_bDespawned) == 0x00059C, "Member 'UBFGNetworkPathAgent::M_bDespawned' has a wrong offset!");

// Class BFGCore.BFGAnimation_Variables
// 0x02A8 (0x02D0 - 0x0028)
#pragma pack(push, 0x1)
class alignas(0x10) UBFGAnimation_Variables : public UObject
{
public:
	struct FVector                                M_vLastInputDirection;                             // 0x0028(0x000C)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	struct FVector                                M_vCapsuleVelocity;                                // 0x0034(0x000C)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	struct FVector                                M_vCustomVelocity;                                 // 0x0040(0x000C)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	struct FRotator                               M_oControlRotation;                                // 0x004C(0x000C)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, NativeAccessSpecifierProtected)
	struct FRotator                               M_oActorRotation;                                  // 0x0058(0x000C)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, NativeAccessSpecifierProtected)
	float                                         M_fHorizontalSpeed;                                // 0x0064(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         M_fVerticalSpeed;                                  // 0x0068(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          M_bIsStartTurning;                                 // 0x006C(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          M_bIsStopping;                                     // 0x006D(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          M_bStartingToPivot;                                // 0x006E(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          M_bIsHatchOpen;                                    // 0x006F(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          M_bJumping;                                        // 0x0070(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          M_bPreviouslyGrounded;                             // 0x0071(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          M_bGrounded;                                       // 0x0072(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          M_bIsInCutscene;                                   // 0x0073(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         M_fDistanceToFloor;                                // 0x0074(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	struct FHitResult                             M_fFloorCheckHitResult;                            // 0x0078(0x0088)(Edit, BlueprintVisible, IsPlainOldData, NoDestructor, ContainsInstancedReference, Protected, NativeAccessSpecifierProtected)
	TMap<EBFGAnimation_Sequence, int32>           M_SequenceVariationsCount;                         // 0x0100(0x0050)(Edit, BlueprintVisible, ZeroConstructor, Protected, NativeAccessSpecifierProtected)
	TMap<EBFGNPCCharacter_MoveSpeed, int32>       M_ActiveMotionSpeedIndex;                          // 0x0150(0x0050)(Edit, BlueprintVisible, ZeroConstructor, Protected, NativeAccessSpecifierProtected)
	bool                                          M_bDead;                                           // 0x01A0(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          M_bIsFullyFrozenToPose;                            // 0x01A1(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_1A2[0x6];                                      // 0x01A2(0x0006)(Fixing Size After Last Property [ Dumper-7 ])
	struct FPoseSnapshot                          M_oFreezePose;                                     // 0x01A8(0x0038)(Edit, BlueprintVisible, BlueprintReadOnly, Protected, NativeAccessSpecifierProtected)
	bool                                          M_bWeaponEquipped;                                 // 0x01E0(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	EBFGAnimation_WeaponPosture                   M_eWeaponPosture;                                  // 0x01E1(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          M_bWeaponShooting;                                 // 0x01E2(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          M_bWeaponAiming;                                   // 0x01E3(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          M_bWeaponReloading;                                // 0x01E4(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          M_bWeaponTelegraphing;                             // 0x01E5(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_1E6[0x2];                                      // 0x01E6(0x0002)(Fixing Size After Last Property [ Dumper-7 ])
	struct FVector                                M_vAimedAtPosition;                                // 0x01E8(0x000C)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	struct FVector                                M_vBestShotDirection;                              // 0x01F4(0x000C)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	struct FVector                                M_vVectorToTarget;                                 // 0x0200(0x000C)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	struct FVector                                M_vVectorToAimingAtLocation;                       // 0x020C(0x000C)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          M_bWillNextShotTriggerSpecialEvent;                // 0x0218(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          M_bAnalProbeIsInUse;                               // 0x0219(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_21A[0x2];                                      // 0x021A(0x0002)(Fixing Size After Last Property [ Dumper-7 ])
	int32                                         M_iAnalProbeAvailableAmmoCount;                    // 0x021C(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         M_fAnalProbeMinigameValue;                         // 0x0220(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class FName                                   M_oWeaponBoneName;                                 // 0x0224(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_22C[0x4];                                      // 0x022C(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	struct FTransform                             M_tWeaponBoneTransform;                            // 0x0230(0x0030)(Edit, BlueprintVisible, BlueprintReadOnly, IsPlainOldData, NoDestructor, Protected, NativeAccessSpecifierProtected)
	bool                                          M_bAimCatchTurning;                                // 0x0260(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_261[0x3];                                      // 0x0261(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         M_fAimCatchUpTotalYaw;                             // 0x0264(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         M_fAimPitchDelta;                                  // 0x0268(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         M_fAimYawDelta;                                    // 0x026C(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	int32                                         M_iAttackEventIndex;                               // 0x0270(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_274[0x4];                                      // 0x0274(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	TMap<struct FGameplayTag, bool>               M_aGameplayEffectResults;                          // 0x0278(0x0050)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Protected, NativeAccessSpecifierProtected)

public:
	int32 GetSquenceVariationsCount(EBFGAnimation_Sequence _sequence);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"BFGAnimation_Variables">();
	}
	static class UBFGAnimation_Variables* GetDefaultObj()
	{
		return GetDefaultObjImpl<UBFGAnimation_Variables>();
	}
};
#pragma pack(pop)
static_assert(alignof(UBFGAnimation_Variables) == 0x000010, "Wrong alignment on UBFGAnimation_Variables");
static_assert(sizeof(UBFGAnimation_Variables) == 0x0002D0, "Wrong size on UBFGAnimation_Variables");
static_assert(offsetof(UBFGAnimation_Variables, M_vLastInputDirection) == 0x000028, "Member 'UBFGAnimation_Variables::M_vLastInputDirection' has a wrong offset!");
static_assert(offsetof(UBFGAnimation_Variables, M_vCapsuleVelocity) == 0x000034, "Member 'UBFGAnimation_Variables::M_vCapsuleVelocity' has a wrong offset!");
static_assert(offsetof(UBFGAnimation_Variables, M_vCustomVelocity) == 0x000040, "Member 'UBFGAnimation_Variables::M_vCustomVelocity' has a wrong offset!");
static_assert(offsetof(UBFGAnimation_Variables, M_oControlRotation) == 0x00004C, "Member 'UBFGAnimation_Variables::M_oControlRotation' has a wrong offset!");
static_assert(offsetof(UBFGAnimation_Variables, M_oActorRotation) == 0x000058, "Member 'UBFGAnimation_Variables::M_oActorRotation' has a wrong offset!");
static_assert(offsetof(UBFGAnimation_Variables, M_fHorizontalSpeed) == 0x000064, "Member 'UBFGAnimation_Variables::M_fHorizontalSpeed' has a wrong offset!");
static_assert(offsetof(UBFGAnimation_Variables, M_fVerticalSpeed) == 0x000068, "Member 'UBFGAnimation_Variables::M_fVerticalSpeed' has a wrong offset!");
static_assert(offsetof(UBFGAnimation_Variables, M_bIsStartTurning) == 0x00006C, "Member 'UBFGAnimation_Variables::M_bIsStartTurning' has a wrong offset!");
static_assert(offsetof(UBFGAnimation_Variables, M_bIsStopping) == 0x00006D, "Member 'UBFGAnimation_Variables::M_bIsStopping' has a wrong offset!");
static_assert(offsetof(UBFGAnimation_Variables, M_bStartingToPivot) == 0x00006E, "Member 'UBFGAnimation_Variables::M_bStartingToPivot' has a wrong offset!");
static_assert(offsetof(UBFGAnimation_Variables, M_bIsHatchOpen) == 0x00006F, "Member 'UBFGAnimation_Variables::M_bIsHatchOpen' has a wrong offset!");
static_assert(offsetof(UBFGAnimation_Variables, M_bJumping) == 0x000070, "Member 'UBFGAnimation_Variables::M_bJumping' has a wrong offset!");
static_assert(offsetof(UBFGAnimation_Variables, M_bPreviouslyGrounded) == 0x000071, "Member 'UBFGAnimation_Variables::M_bPreviouslyGrounded' has a wrong offset!");
static_assert(offsetof(UBFGAnimation_Variables, M_bGrounded) == 0x000072, "Member 'UBFGAnimation_Variables::M_bGrounded' has a wrong offset!");
static_assert(offsetof(UBFGAnimation_Variables, M_bIsInCutscene) == 0x000073, "Member 'UBFGAnimation_Variables::M_bIsInCutscene' has a wrong offset!");
static_assert(offsetof(UBFGAnimation_Variables, M_fDistanceToFloor) == 0x000074, "Member 'UBFGAnimation_Variables::M_fDistanceToFloor' has a wrong offset!");
static_assert(offsetof(UBFGAnimation_Variables, M_fFloorCheckHitResult) == 0x000078, "Member 'UBFGAnimation_Variables::M_fFloorCheckHitResult' has a wrong offset!");
static_assert(offsetof(UBFGAnimation_Variables, M_SequenceVariationsCount) == 0x000100, "Member 'UBFGAnimation_Variables::M_SequenceVariationsCount' has a wrong offset!");
static_assert(offsetof(UBFGAnimation_Variables, M_ActiveMotionSpeedIndex) == 0x000150, "Member 'UBFGAnimation_Variables::M_ActiveMotionSpeedIndex' has a wrong offset!");
static_assert(offsetof(UBFGAnimation_Variables, M_bDead) == 0x0001A0, "Member 'UBFGAnimation_Variables::M_bDead' has a wrong offset!");
static_assert(offsetof(UBFGAnimation_Variables, M_bIsFullyFrozenToPose) == 0x0001A1, "Member 'UBFGAnimation_Variables::M_bIsFullyFrozenToPose' has a wrong offset!");
static_assert(offsetof(UBFGAnimation_Variables, M_oFreezePose) == 0x0001A8, "Member 'UBFGAnimation_Variables::M_oFreezePose' has a wrong offset!");
static_assert(offsetof(UBFGAnimation_Variables, M_bWeaponEquipped) == 0x0001E0, "Member 'UBFGAnimation_Variables::M_bWeaponEquipped' has a wrong offset!");
static_assert(offsetof(UBFGAnimation_Variables, M_eWeaponPosture) == 0x0001E1, "Member 'UBFGAnimation_Variables::M_eWeaponPosture' has a wrong offset!");
static_assert(offsetof(UBFGAnimation_Variables, M_bWeaponShooting) == 0x0001E2, "Member 'UBFGAnimation_Variables::M_bWeaponShooting' has a wrong offset!");
static_assert(offsetof(UBFGAnimation_Variables, M_bWeaponAiming) == 0x0001E3, "Member 'UBFGAnimation_Variables::M_bWeaponAiming' has a wrong offset!");
static_assert(offsetof(UBFGAnimation_Variables, M_bWeaponReloading) == 0x0001E4, "Member 'UBFGAnimation_Variables::M_bWeaponReloading' has a wrong offset!");
static_assert(offsetof(UBFGAnimation_Variables, M_bWeaponTelegraphing) == 0x0001E5, "Member 'UBFGAnimation_Variables::M_bWeaponTelegraphing' has a wrong offset!");
static_assert(offsetof(UBFGAnimation_Variables, M_vAimedAtPosition) == 0x0001E8, "Member 'UBFGAnimation_Variables::M_vAimedAtPosition' has a wrong offset!");
static_assert(offsetof(UBFGAnimation_Variables, M_vBestShotDirection) == 0x0001F4, "Member 'UBFGAnimation_Variables::M_vBestShotDirection' has a wrong offset!");
static_assert(offsetof(UBFGAnimation_Variables, M_vVectorToTarget) == 0x000200, "Member 'UBFGAnimation_Variables::M_vVectorToTarget' has a wrong offset!");
static_assert(offsetof(UBFGAnimation_Variables, M_vVectorToAimingAtLocation) == 0x00020C, "Member 'UBFGAnimation_Variables::M_vVectorToAimingAtLocation' has a wrong offset!");
static_assert(offsetof(UBFGAnimation_Variables, M_bWillNextShotTriggerSpecialEvent) == 0x000218, "Member 'UBFGAnimation_Variables::M_bWillNextShotTriggerSpecialEvent' has a wrong offset!");
static_assert(offsetof(UBFGAnimation_Variables, M_bAnalProbeIsInUse) == 0x000219, "Member 'UBFGAnimation_Variables::M_bAnalProbeIsInUse' has a wrong offset!");
static_assert(offsetof(UBFGAnimation_Variables, M_iAnalProbeAvailableAmmoCount) == 0x00021C, "Member 'UBFGAnimation_Variables::M_iAnalProbeAvailableAmmoCount' has a wrong offset!");
static_assert(offsetof(UBFGAnimation_Variables, M_fAnalProbeMinigameValue) == 0x000220, "Member 'UBFGAnimation_Variables::M_fAnalProbeMinigameValue' has a wrong offset!");
static_assert(offsetof(UBFGAnimation_Variables, M_oWeaponBoneName) == 0x000224, "Member 'UBFGAnimation_Variables::M_oWeaponBoneName' has a wrong offset!");
static_assert(offsetof(UBFGAnimation_Variables, M_tWeaponBoneTransform) == 0x000230, "Member 'UBFGAnimation_Variables::M_tWeaponBoneTransform' has a wrong offset!");
static_assert(offsetof(UBFGAnimation_Variables, M_bAimCatchTurning) == 0x000260, "Member 'UBFGAnimation_Variables::M_bAimCatchTurning' has a wrong offset!");
static_assert(offsetof(UBFGAnimation_Variables, M_fAimCatchUpTotalYaw) == 0x000264, "Member 'UBFGAnimation_Variables::M_fAimCatchUpTotalYaw' has a wrong offset!");
static_assert(offsetof(UBFGAnimation_Variables, M_fAimPitchDelta) == 0x000268, "Member 'UBFGAnimation_Variables::M_fAimPitchDelta' has a wrong offset!");
static_assert(offsetof(UBFGAnimation_Variables, M_fAimYawDelta) == 0x00026C, "Member 'UBFGAnimation_Variables::M_fAimYawDelta' has a wrong offset!");
static_assert(offsetof(UBFGAnimation_Variables, M_iAttackEventIndex) == 0x000270, "Member 'UBFGAnimation_Variables::M_iAttackEventIndex' has a wrong offset!");
static_assert(offsetof(UBFGAnimation_Variables, M_aGameplayEffectResults) == 0x000278, "Member 'UBFGAnimation_Variables::M_aGameplayEffectResults' has a wrong offset!");

// Class BFGCore.BFGDamageCauserInterface
// 0x0000 (0x0028 - 0x0028)
class IBFGDamageCauserInterface final : public IInterface
{
public:
	class AActor* GetDamageInitiator() const;
	TSubclassOf<class UBFGMentalAbilityBase> GetMentalAbilityClass() const;
	TSubclassOf<class ABFGWeapon> GetWeaponClass() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"BFGDamageCauserInterface">();
	}
	static class IBFGDamageCauserInterface* GetDefaultObj()
	{
		return GetDefaultObjImpl<IBFGDamageCauserInterface>();
	}
};
static_assert(alignof(IBFGDamageCauserInterface) == 0x000008, "Wrong alignment on IBFGDamageCauserInterface");
static_assert(sizeof(IBFGDamageCauserInterface) == 0x000028, "Wrong size on IBFGDamageCauserInterface");

// Class BFGCore.BFGWeapon_BaseRay
// 0x0048 (0x0740 - 0x06F8)
class ABFGWeapon_BaseRay : public ABFGWeapon
{
public:
	struct FSoftClassPath                         M_BeamClass;                                       // 0x06F8(0x0018)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, NativeAccessSpecifierPublic)
	class USceneComponent*                        PSocketComponent;                                  // 0x0710(0x0008)(Edit, BlueprintVisible, ExportObject, ZeroConstructor, DisableEditOnInstance, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         M_fMaxCharge;                                      // 0x0718(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         M_fOverheatCooldownThreshold;                      // 0x071C(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_720[0x4];                                      // 0x0720(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         M_fDischargeRate;                                  // 0x0724(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         M_fRechargeRate;                                   // 0x0728(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         M_fRechargeDelayAfterUse;                          // 0x072C(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class ABFGProjectile_Beam*                    M_pBeam;                                           // 0x0730(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_738[0x8];                                      // 0x0738(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void RechargeWeapon(float _fInDelta);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"BFGWeapon_BaseRay">();
	}
	static class ABFGWeapon_BaseRay* GetDefaultObj()
	{
		return GetDefaultObjImpl<ABFGWeapon_BaseRay>();
	}
};
static_assert(alignof(ABFGWeapon_BaseRay) == 0x000008, "Wrong alignment on ABFGWeapon_BaseRay");
static_assert(sizeof(ABFGWeapon_BaseRay) == 0x000740, "Wrong size on ABFGWeapon_BaseRay");
static_assert(offsetof(ABFGWeapon_BaseRay, M_BeamClass) == 0x0006F8, "Member 'ABFGWeapon_BaseRay::M_BeamClass' has a wrong offset!");
static_assert(offsetof(ABFGWeapon_BaseRay, PSocketComponent) == 0x000710, "Member 'ABFGWeapon_BaseRay::PSocketComponent' has a wrong offset!");
static_assert(offsetof(ABFGWeapon_BaseRay, M_fMaxCharge) == 0x000718, "Member 'ABFGWeapon_BaseRay::M_fMaxCharge' has a wrong offset!");
static_assert(offsetof(ABFGWeapon_BaseRay, M_fOverheatCooldownThreshold) == 0x00071C, "Member 'ABFGWeapon_BaseRay::M_fOverheatCooldownThreshold' has a wrong offset!");
static_assert(offsetof(ABFGWeapon_BaseRay, M_fDischargeRate) == 0x000724, "Member 'ABFGWeapon_BaseRay::M_fDischargeRate' has a wrong offset!");
static_assert(offsetof(ABFGWeapon_BaseRay, M_fRechargeRate) == 0x000728, "Member 'ABFGWeapon_BaseRay::M_fRechargeRate' has a wrong offset!");
static_assert(offsetof(ABFGWeapon_BaseRay, M_fRechargeDelayAfterUse) == 0x00072C, "Member 'ABFGWeapon_BaseRay::M_fRechargeDelayAfterUse' has a wrong offset!");
static_assert(offsetof(ABFGWeapon_BaseRay, M_pBeam) == 0x000730, "Member 'ABFGWeapon_BaseRay::M_pBeam' has a wrong offset!");

// Class BFGCore.BFGWeapon_UFO_AbductoBeam
// 0x0040 (0x0780 - 0x0740)
class ABFGWeapon_UFO_AbductoBeam final : public ABFGWeapon_BaseRay
{
public:
	struct FSoftClassPath                         M_ProjectileClass;                                 // 0x0740(0x0018)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, NativeAccessSpecifierPublic)
	float                                         M_fAbductionHitRadius;                             // 0x0758(0x0004)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	ECollisionChannel                             M_PKCollisionChannel;                              // 0x075C(0x0001)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_75D[0x3];                                      // 0x075D(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         M_fAbductionHoldOffsetZ;                           // 0x0760(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         M_fAbductionMaxTime;                               // 0x0764(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TSubclassOf<class UDamageType>                M_pFatalDamageType;                                // 0x0768(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class AActor*                                 M_pAbductedTarget;                                 // 0x0770(0x0008)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_778[0x8];                                      // 0x0778(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"BFGWeapon_UFO_AbductoBeam">();
	}
	static class ABFGWeapon_UFO_AbductoBeam* GetDefaultObj()
	{
		return GetDefaultObjImpl<ABFGWeapon_UFO_AbductoBeam>();
	}
};
static_assert(alignof(ABFGWeapon_UFO_AbductoBeam) == 0x000008, "Wrong alignment on ABFGWeapon_UFO_AbductoBeam");
static_assert(sizeof(ABFGWeapon_UFO_AbductoBeam) == 0x000780, "Wrong size on ABFGWeapon_UFO_AbductoBeam");
static_assert(offsetof(ABFGWeapon_UFO_AbductoBeam, M_ProjectileClass) == 0x000740, "Member 'ABFGWeapon_UFO_AbductoBeam::M_ProjectileClass' has a wrong offset!");
static_assert(offsetof(ABFGWeapon_UFO_AbductoBeam, M_fAbductionHitRadius) == 0x000758, "Member 'ABFGWeapon_UFO_AbductoBeam::M_fAbductionHitRadius' has a wrong offset!");
static_assert(offsetof(ABFGWeapon_UFO_AbductoBeam, M_PKCollisionChannel) == 0x00075C, "Member 'ABFGWeapon_UFO_AbductoBeam::M_PKCollisionChannel' has a wrong offset!");
static_assert(offsetof(ABFGWeapon_UFO_AbductoBeam, M_fAbductionHoldOffsetZ) == 0x000760, "Member 'ABFGWeapon_UFO_AbductoBeam::M_fAbductionHoldOffsetZ' has a wrong offset!");
static_assert(offsetof(ABFGWeapon_UFO_AbductoBeam, M_fAbductionMaxTime) == 0x000764, "Member 'ABFGWeapon_UFO_AbductoBeam::M_fAbductionMaxTime' has a wrong offset!");
static_assert(offsetof(ABFGWeapon_UFO_AbductoBeam, M_pFatalDamageType) == 0x000768, "Member 'ABFGWeapon_UFO_AbductoBeam::M_pFatalDamageType' has a wrong offset!");
static_assert(offsetof(ABFGWeapon_UFO_AbductoBeam, M_pAbductedTarget) == 0x000770, "Member 'ABFGWeapon_UFO_AbductoBeam::M_pAbductedTarget' has a wrong offset!");

// Class BFGCore.BFGAnimation_Variables_Npc
// 0x0080 (0x0350 - 0x02D0)
#pragma pack(push, 0x1)
class alignas(0x10) UBFGAnimation_Variables_Npc : public UBFGAnimation_Variables
{
public:
	bool                                          M_bElectrocuted;                                   // 0x02C8(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	EBFGAlertSystemSeenState                      M_eCryptoSeenState;                                // 0x02C9(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_2CA[0x2];                                      // 0x02CA(0x0002)(Fixing Size After Last Property [ Dumper-7 ])
	struct FVector                                M_vCryptoLocation;                                 // 0x02CC(0x000C)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	EAbilityState                                 M_eAbilityState;                                   // 0x02D8(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_2D9[0x3];                                      // 0x02D9(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         M_fChannelEffectProgressPercent;                   // 0x02DC(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         M_fChannelPercentState;                            // 0x02E0(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_2E4[0x4];                                      // 0x02E4(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	TSubclassOf<class UBFGMentalAbilityBase>      M_CurrentlyUsedAbilityClass;                       // 0x02E8(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	EBFGBehaviourState_NPC                        M_eCurrentNPCState;                                // 0x02F0(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_2F1[0x3];                                      // 0x02F1(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	TWeakObjectPtr<class AActor>                  M_pCurrentTarget;                                  // 0x02F4(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_2FC[0x4];                                      // 0x02FC(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<struct FBFGAnimationVariables_Weapon>  M_aWeapons;                                        // 0x0300(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Protected, NativeAccessSpecifierProtected)
	EBFGCuriosityReason_NPC                       M_eCuriosityReason;                                // 0x0310(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_311[0x3];                                      // 0x0311(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	struct FVector                                M_vVectorToSuspisciousLocation;                    // 0x0314(0x000C)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         M_fGetUpDuration;                                  // 0x0320(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         M_fGetUpProgress;                                  // 0x0324(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          M_bIsStoppingMovement;                             // 0x0328(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          M_bIsTurningInPlace;                               // 0x0329(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_32A[0x2];                                      // 0x032A(0x0002)(Fixing Size After Last Property [ Dumper-7 ])
	struct FVector                                M_vTurningDirection;                               // 0x032C(0x000C)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         M_fTurningRate;                                    // 0x0338(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	EBFGFaction                                   M_oFaction;                                        // 0x033C(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          M_bIsAllyNonActive;                                // 0x033D(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_33E[0x2];                                      // 0x033E(0x0002)(Fixing Size After Last Property [ Dumper-7 ])
	TWeakObjectPtr<class AActor>                  M_pCurrentLookAtTarget;                            // 0x0340(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"BFGAnimation_Variables_Npc">();
	}
	static class UBFGAnimation_Variables_Npc* GetDefaultObj()
	{
		return GetDefaultObjImpl<UBFGAnimation_Variables_Npc>();
	}
};
#pragma pack(pop)
static_assert(alignof(UBFGAnimation_Variables_Npc) == 0x000010, "Wrong alignment on UBFGAnimation_Variables_Npc");
static_assert(sizeof(UBFGAnimation_Variables_Npc) == 0x000350, "Wrong size on UBFGAnimation_Variables_Npc");
static_assert(offsetof(UBFGAnimation_Variables_Npc, M_bElectrocuted) == 0x0002C8, "Member 'UBFGAnimation_Variables_Npc::M_bElectrocuted' has a wrong offset!");
static_assert(offsetof(UBFGAnimation_Variables_Npc, M_eCryptoSeenState) == 0x0002C9, "Member 'UBFGAnimation_Variables_Npc::M_eCryptoSeenState' has a wrong offset!");
static_assert(offsetof(UBFGAnimation_Variables_Npc, M_vCryptoLocation) == 0x0002CC, "Member 'UBFGAnimation_Variables_Npc::M_vCryptoLocation' has a wrong offset!");
static_assert(offsetof(UBFGAnimation_Variables_Npc, M_eAbilityState) == 0x0002D8, "Member 'UBFGAnimation_Variables_Npc::M_eAbilityState' has a wrong offset!");
static_assert(offsetof(UBFGAnimation_Variables_Npc, M_fChannelEffectProgressPercent) == 0x0002DC, "Member 'UBFGAnimation_Variables_Npc::M_fChannelEffectProgressPercent' has a wrong offset!");
static_assert(offsetof(UBFGAnimation_Variables_Npc, M_fChannelPercentState) == 0x0002E0, "Member 'UBFGAnimation_Variables_Npc::M_fChannelPercentState' has a wrong offset!");
static_assert(offsetof(UBFGAnimation_Variables_Npc, M_CurrentlyUsedAbilityClass) == 0x0002E8, "Member 'UBFGAnimation_Variables_Npc::M_CurrentlyUsedAbilityClass' has a wrong offset!");
static_assert(offsetof(UBFGAnimation_Variables_Npc, M_eCurrentNPCState) == 0x0002F0, "Member 'UBFGAnimation_Variables_Npc::M_eCurrentNPCState' has a wrong offset!");
static_assert(offsetof(UBFGAnimation_Variables_Npc, M_pCurrentTarget) == 0x0002F4, "Member 'UBFGAnimation_Variables_Npc::M_pCurrentTarget' has a wrong offset!");
static_assert(offsetof(UBFGAnimation_Variables_Npc, M_aWeapons) == 0x000300, "Member 'UBFGAnimation_Variables_Npc::M_aWeapons' has a wrong offset!");
static_assert(offsetof(UBFGAnimation_Variables_Npc, M_eCuriosityReason) == 0x000310, "Member 'UBFGAnimation_Variables_Npc::M_eCuriosityReason' has a wrong offset!");
static_assert(offsetof(UBFGAnimation_Variables_Npc, M_vVectorToSuspisciousLocation) == 0x000314, "Member 'UBFGAnimation_Variables_Npc::M_vVectorToSuspisciousLocation' has a wrong offset!");
static_assert(offsetof(UBFGAnimation_Variables_Npc, M_fGetUpDuration) == 0x000320, "Member 'UBFGAnimation_Variables_Npc::M_fGetUpDuration' has a wrong offset!");
static_assert(offsetof(UBFGAnimation_Variables_Npc, M_fGetUpProgress) == 0x000324, "Member 'UBFGAnimation_Variables_Npc::M_fGetUpProgress' has a wrong offset!");
static_assert(offsetof(UBFGAnimation_Variables_Npc, M_bIsStoppingMovement) == 0x000328, "Member 'UBFGAnimation_Variables_Npc::M_bIsStoppingMovement' has a wrong offset!");
static_assert(offsetof(UBFGAnimation_Variables_Npc, M_bIsTurningInPlace) == 0x000329, "Member 'UBFGAnimation_Variables_Npc::M_bIsTurningInPlace' has a wrong offset!");
static_assert(offsetof(UBFGAnimation_Variables_Npc, M_vTurningDirection) == 0x00032C, "Member 'UBFGAnimation_Variables_Npc::M_vTurningDirection' has a wrong offset!");
static_assert(offsetof(UBFGAnimation_Variables_Npc, M_fTurningRate) == 0x000338, "Member 'UBFGAnimation_Variables_Npc::M_fTurningRate' has a wrong offset!");
static_assert(offsetof(UBFGAnimation_Variables_Npc, M_oFaction) == 0x00033C, "Member 'UBFGAnimation_Variables_Npc::M_oFaction' has a wrong offset!");
static_assert(offsetof(UBFGAnimation_Variables_Npc, M_bIsAllyNonActive) == 0x00033D, "Member 'UBFGAnimation_Variables_Npc::M_bIsAllyNonActive' has a wrong offset!");
static_assert(offsetof(UBFGAnimation_Variables_Npc, M_pCurrentLookAtTarget) == 0x000340, "Member 'UBFGAnimation_Variables_Npc::M_pCurrentLookAtTarget' has a wrong offset!");

// Class BFGCore.BFGGameFlowState
// 0x0040 (0x0068 - 0x0028)
class UBFGGameFlowState : public UObject
{
public:
	UMulticastDelegateProperty_                   M_onEnters;                                        // 0x0028(0x0018)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	UMulticastDelegateProperty_                   M_onLeaves;                                        // 0x0040(0x0018)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	class UBFGGameFlowStateManager*               M_pManager;                                        // 0x0058(0x0008)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_60[0x8];                                       // 0x0060(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"BFGGameFlowState">();
	}
	static class UBFGGameFlowState* GetDefaultObj()
	{
		return GetDefaultObjImpl<UBFGGameFlowState>();
	}
};
static_assert(alignof(UBFGGameFlowState) == 0x000008, "Wrong alignment on UBFGGameFlowState");
static_assert(sizeof(UBFGGameFlowState) == 0x000068, "Wrong size on UBFGGameFlowState");
static_assert(offsetof(UBFGGameFlowState, M_onEnters) == 0x000028, "Member 'UBFGGameFlowState::M_onEnters' has a wrong offset!");
static_assert(offsetof(UBFGGameFlowState, M_onLeaves) == 0x000040, "Member 'UBFGGameFlowState::M_onLeaves' has a wrong offset!");
static_assert(offsetof(UBFGGameFlowState, M_pManager) == 0x000058, "Member 'UBFGGameFlowState::M_pManager' has a wrong offset!");

// Class BFGCore.BFGGameFlowState_LoadingScreenBase
// 0x0068 (0x00D0 - 0x0068)
class UBFGGameFlowState_LoadingScreenBase : public UBFGGameFlowState
{
public:
	uint8                                         Pad_68[0x10];                                      // 0x0068(0x0010)(Fixing Size After Last Property [ Dumper-7 ])
	bool                                          M_bShouldPause;                                    // 0x0078(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_79[0x10];                                      // 0x0079(0x0010)(Fixing Size After Last Property [ Dumper-7 ])
	EBFGGameFlowState_LoadingScreenBase           M_statePostFadeLoadingScreen;                      // 0x0089(0x0001)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_8A[0x6];                                       // 0x008A(0x0006)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<class UBFGGameFlowState*>              M_apExitStateStack;                                // 0x0090(0x0010)(ZeroConstructor, Transient, Protected, NativeAccessSpecifierProtected)
	uint8                                         Pad_A0[0x10];                                      // 0x00A0(0x0010)(Fixing Size After Last Property [ Dumper-7 ])
	EBFGGameFlowState_LoadingScreenBase           M_stateLoadingScreen;                              // 0x00B0(0x0001)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_B1[0x1F];                                      // 0x00B1(0x001F)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void LoadingScreen_Begin(const class FString& _strMapName);
	void LoadingScreen_Begin_Internal(const class FString& _strMapName, bool _bShowBackgroundPicture);
	void LoadingScreen_End(class UWorld* _pWorld);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"BFGGameFlowState_LoadingScreenBase">();
	}
	static class UBFGGameFlowState_LoadingScreenBase* GetDefaultObj()
	{
		return GetDefaultObjImpl<UBFGGameFlowState_LoadingScreenBase>();
	}
};
static_assert(alignof(UBFGGameFlowState_LoadingScreenBase) == 0x000008, "Wrong alignment on UBFGGameFlowState_LoadingScreenBase");
static_assert(sizeof(UBFGGameFlowState_LoadingScreenBase) == 0x0000D0, "Wrong size on UBFGGameFlowState_LoadingScreenBase");
static_assert(offsetof(UBFGGameFlowState_LoadingScreenBase, M_bShouldPause) == 0x000078, "Member 'UBFGGameFlowState_LoadingScreenBase::M_bShouldPause' has a wrong offset!");
static_assert(offsetof(UBFGGameFlowState_LoadingScreenBase, M_statePostFadeLoadingScreen) == 0x000089, "Member 'UBFGGameFlowState_LoadingScreenBase::M_statePostFadeLoadingScreen' has a wrong offset!");
static_assert(offsetof(UBFGGameFlowState_LoadingScreenBase, M_apExitStateStack) == 0x000090, "Member 'UBFGGameFlowState_LoadingScreenBase::M_apExitStateStack' has a wrong offset!");
static_assert(offsetof(UBFGGameFlowState_LoadingScreenBase, M_stateLoadingScreen) == 0x0000B0, "Member 'UBFGGameFlowState_LoadingScreenBase::M_stateLoadingScreen' has a wrong offset!");

// Class BFGCore.BFGGameFlowState_LoadMap
// 0x0050 (0x0120 - 0x00D0)
class UBFGGameFlowState_LoadMap : public UBFGGameFlowState_LoadingScreenBase
{
public:
	struct FBFGSavedMapDescription                M_targetMap;                                       // 0x00D0(0x0038)(Transient, Protected, NativeAccessSpecifierProtected)
	uint8                                         Pad_108[0x18];                                     // 0x0108(0x0018)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static bool StartMapLoad(class UBFGGameInstance* _pGameInstance, const class FString& _strLevelName, int32 _iSaveToSlot, bool _bDoNotFadeIn, bool _bForceFadeIn);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"BFGGameFlowState_LoadMap">();
	}
	static class UBFGGameFlowState_LoadMap* GetDefaultObj()
	{
		return GetDefaultObjImpl<UBFGGameFlowState_LoadMap>();
	}
};
static_assert(alignof(UBFGGameFlowState_LoadMap) == 0x000008, "Wrong alignment on UBFGGameFlowState_LoadMap");
static_assert(sizeof(UBFGGameFlowState_LoadMap) == 0x000120, "Wrong size on UBFGGameFlowState_LoadMap");
static_assert(offsetof(UBFGGameFlowState_LoadMap, M_targetMap) == 0x0000D0, "Member 'UBFGGameFlowState_LoadMap::M_targetMap' has a wrong offset!");

// Class BFGCore.BFGGameFlowState_DebugLoadMap
// 0x0050 (0x0170 - 0x0120)
class UBFGGameFlowState_DebugLoadMap final : public UBFGGameFlowState_LoadMap
{
public:
	struct FBFGDebugStartMenu_EntryData           M_Data;                                            // 0x0120(0x0050)(Transient, Protected, NativeAccessSpecifierProtected)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"BFGGameFlowState_DebugLoadMap">();
	}
	static class UBFGGameFlowState_DebugLoadMap* GetDefaultObj()
	{
		return GetDefaultObjImpl<UBFGGameFlowState_DebugLoadMap>();
	}
};
static_assert(alignof(UBFGGameFlowState_DebugLoadMap) == 0x000008, "Wrong alignment on UBFGGameFlowState_DebugLoadMap");
static_assert(sizeof(UBFGGameFlowState_DebugLoadMap) == 0x000170, "Wrong size on UBFGGameFlowState_DebugLoadMap");
static_assert(offsetof(UBFGGameFlowState_DebugLoadMap, M_Data) == 0x000120, "Member 'UBFGGameFlowState_DebugLoadMap::M_Data' has a wrong offset!");

// Class BFGCore.BFGAnimation_Variables_Animal
// 0x0000 (0x0350 - 0x0350)
class UBFGAnimation_Variables_Animal final : public UBFGAnimation_Variables_Npc
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"BFGAnimation_Variables_Animal">();
	}
	static class UBFGAnimation_Variables_Animal* GetDefaultObj()
	{
		return GetDefaultObjImpl<UBFGAnimation_Variables_Animal>();
	}
};
static_assert(alignof(UBFGAnimation_Variables_Animal) == 0x000010, "Wrong alignment on UBFGAnimation_Variables_Animal");
static_assert(sizeof(UBFGAnimation_Variables_Animal) == 0x000350, "Wrong size on UBFGAnimation_Variables_Animal");

// Class BFGCore.BFGDynamicObstacle_Box
// 0x0008 (0x03E0 - 0x03D8)
class ABFGDynamicObstacle_Box final : public AActor
{
public:
	class UBoxComponent*                          M_pBoxComponent;                                   // 0x03D8(0x0008)(Edit, ExportObject, ZeroConstructor, EditConst, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"BFGDynamicObstacle_Box">();
	}
	static class ABFGDynamicObstacle_Box* GetDefaultObj()
	{
		return GetDefaultObjImpl<ABFGDynamicObstacle_Box>();
	}
};
static_assert(alignof(ABFGDynamicObstacle_Box) == 0x000008, "Wrong alignment on ABFGDynamicObstacle_Box");
static_assert(sizeof(ABFGDynamicObstacle_Box) == 0x0003E0, "Wrong size on ABFGDynamicObstacle_Box");
static_assert(offsetof(ABFGDynamicObstacle_Box, M_pBoxComponent) == 0x0003D8, "Member 'ABFGDynamicObstacle_Box::M_pBoxComponent' has a wrong offset!");

// Class BFGCore.BFGWidget_HUD_SceneObjectHighlighter
// 0x0010 (0x0308 - 0x02F8)
class UBFGWidget_HUD_SceneObjectHighlighter : public UBFGWidget_HUD
{
public:
	TArray<class UBFGWidgetSceneObjectHighlighter*> M_apHighlighters;                                  // 0x02F8(0x0010)(ExportObject, ZeroConstructor, ContainsInstancedReference, Protected, NativeAccessSpecifierProtected)

public:
	void AddHighlighterToCanvas(class UBFGWidgetSceneObjectHighlighter* _pHighlighter);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"BFGWidget_HUD_SceneObjectHighlighter">();
	}
	static class UBFGWidget_HUD_SceneObjectHighlighter* GetDefaultObj()
	{
		return GetDefaultObjImpl<UBFGWidget_HUD_SceneObjectHighlighter>();
	}
};
static_assert(alignof(UBFGWidget_HUD_SceneObjectHighlighter) == 0x000008, "Wrong alignment on UBFGWidget_HUD_SceneObjectHighlighter");
static_assert(sizeof(UBFGWidget_HUD_SceneObjectHighlighter) == 0x000308, "Wrong size on UBFGWidget_HUD_SceneObjectHighlighter");
static_assert(offsetof(UBFGWidget_HUD_SceneObjectHighlighter, M_apHighlighters) == 0x0002F8, "Member 'UBFGWidget_HUD_SceneObjectHighlighter::M_apHighlighters' has a wrong offset!");

// Class BFGCore.BFGAnimation_Variables_Boss
// 0x00A0 (0x03F0 - 0x0350)
class UBFGAnimation_Variables_Boss final : public UBFGAnimation_Variables_Npc
{
public:
	bool                                          M_bIsInWeakState;                                  // 0x0348(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          M_bIsAimingWeaponL;                                // 0x0349(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          M_bIsAimingWeaponR;                                // 0x034A(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          M_bIsShootingMinigunL;                             // 0x034B(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          M_bIsShootingMinigunR;                             // 0x034C(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          M_bIsTelegraphingWeaponL;                          // 0x034D(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          M_bIsTelegraphingWeaponR;                          // 0x034E(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_34F[0x1];                                      // 0x034F(0x0001)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         M_fMinigunTelegraphTime;                           // 0x0350(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         M_fRocketTelegraphTime;                            // 0x0354(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	struct FVector                                M_vTargetDirectionToArmL;                          // 0x0358(0x000C)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	struct FVector                                M_vTargetDirectionToArmR;                          // 0x0364(0x000C)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	struct FVector                                M_vUpperBodyDirection;                             // 0x0370(0x000C)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          M_bIsTurning;                                      // 0x037C(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_37D[0x3];                                      // 0x037D(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         M_fTurnDelayStanding;                              // 0x0380(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         M_fTurnDelayMoving;                                // 0x0384(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         M_fTurnDeltaYaw;                                   // 0x0388(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         M_fMaxTurnDelta;                                   // 0x038C(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          M_bIsShootingMissiles;                             // 0x0390(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          M_bIsStompingL;                                    // 0x0391(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          M_bIsStompingR;                                    // 0x0392(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_393[0x1];                                      // 0x0393(0x0001)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         M_fStompDamageDelay;                               // 0x0394(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         M_fStompAnimationLength;                           // 0x0398(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          M_bIsTelegraphingCharge;                           // 0x039C(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          M_bIsCharging;                                     // 0x039D(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_39E[0x2];                                      // 0x039E(0x0002)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         M_fBrakeFrictionOverride;                          // 0x03A0(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          M_bIsTelegraphingLeap;                             // 0x03A4(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          M_bIsGrounded;                                     // 0x03A5(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_3A6[0x2];                                      // 0x03A6(0x0002)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         M_fLandingDelay;                                   // 0x03A8(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         M_fLeapTelegraphTime;                              // 0x03AC(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         M_fReinforcementDelay;                             // 0x03B0(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         M_fKnockDownDelay;                                 // 0x03B4(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          M_bIsAttacking;                                    // 0x03B8(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          M_bIsAttacking360;                                 // 0x03B9(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          M_bIsBeamActive;                                   // 0x03BA(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_3BB[0x1];                                      // 0x03BB(0x0001)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         M_f360Attack_StartDelay;                           // 0x03BC(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         M_f360Attack_StopDelay;                            // 0x03C0(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	EBFG360AttackPhase                            M_e360AttackPhase;                                 // 0x03C4(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	EBFGSilhouetteWeaponState                     M_eSilhouetteWeaponState;                          // 0x03C5(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_3C6[0x2];                                      // 0x03C6(0x0002)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         M_fAimYaw;                                         // 0x03C8(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         M_fAimPitch;                                       // 0x03CC(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	EBFGLevitationState                           M_eHoverState;                                     // 0x03D0(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          M_bIsChargingNasalProbe;                           // 0x03D1(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_3D2[0x2];                                      // 0x03D2(0x0002)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         M_fNasalProbeChargeRatio;                          // 0x03D4(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          M_bIsVulnerable;                                   // 0x03D8(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          M_bIsActivelyDrainingPSI;                          // 0x03D9(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          M_bIsUnderCover;                                   // 0x03DA(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          M_bIsPerformingCosmeticActivity;                   // 0x03DB(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          M_bFlinch;                                         // 0x03DC(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          M_bIsShootingBeam;                                 // 0x03DD(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	EBFGBeamAttackPhase                           M_eBeamAttackPhase;                                // 0x03DE(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_3DF[0x1];                                      // 0x03DF(0x0001)(Fixing Size After Last Property [ Dumper-7 ])
	struct FVector                                M_vAimDirectionBeam;                               // 0x03E0(0x000C)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          M_bIsRelocating;                                   // 0x03EC(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          M_bIsStartUpPhase;                                 // 0x03ED(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_3EE[0x2];                                      // 0x03EE(0x0002)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"BFGAnimation_Variables_Boss">();
	}
	static class UBFGAnimation_Variables_Boss* GetDefaultObj()
	{
		return GetDefaultObjImpl<UBFGAnimation_Variables_Boss>();
	}
};
static_assert(alignof(UBFGAnimation_Variables_Boss) == 0x000010, "Wrong alignment on UBFGAnimation_Variables_Boss");
static_assert(sizeof(UBFGAnimation_Variables_Boss) == 0x0003F0, "Wrong size on UBFGAnimation_Variables_Boss");
static_assert(offsetof(UBFGAnimation_Variables_Boss, M_bIsInWeakState) == 0x000348, "Member 'UBFGAnimation_Variables_Boss::M_bIsInWeakState' has a wrong offset!");
static_assert(offsetof(UBFGAnimation_Variables_Boss, M_bIsAimingWeaponL) == 0x000349, "Member 'UBFGAnimation_Variables_Boss::M_bIsAimingWeaponL' has a wrong offset!");
static_assert(offsetof(UBFGAnimation_Variables_Boss, M_bIsAimingWeaponR) == 0x00034A, "Member 'UBFGAnimation_Variables_Boss::M_bIsAimingWeaponR' has a wrong offset!");
static_assert(offsetof(UBFGAnimation_Variables_Boss, M_bIsShootingMinigunL) == 0x00034B, "Member 'UBFGAnimation_Variables_Boss::M_bIsShootingMinigunL' has a wrong offset!");
static_assert(offsetof(UBFGAnimation_Variables_Boss, M_bIsShootingMinigunR) == 0x00034C, "Member 'UBFGAnimation_Variables_Boss::M_bIsShootingMinigunR' has a wrong offset!");
static_assert(offsetof(UBFGAnimation_Variables_Boss, M_bIsTelegraphingWeaponL) == 0x00034D, "Member 'UBFGAnimation_Variables_Boss::M_bIsTelegraphingWeaponL' has a wrong offset!");
static_assert(offsetof(UBFGAnimation_Variables_Boss, M_bIsTelegraphingWeaponR) == 0x00034E, "Member 'UBFGAnimation_Variables_Boss::M_bIsTelegraphingWeaponR' has a wrong offset!");
static_assert(offsetof(UBFGAnimation_Variables_Boss, M_fMinigunTelegraphTime) == 0x000350, "Member 'UBFGAnimation_Variables_Boss::M_fMinigunTelegraphTime' has a wrong offset!");
static_assert(offsetof(UBFGAnimation_Variables_Boss, M_fRocketTelegraphTime) == 0x000354, "Member 'UBFGAnimation_Variables_Boss::M_fRocketTelegraphTime' has a wrong offset!");
static_assert(offsetof(UBFGAnimation_Variables_Boss, M_vTargetDirectionToArmL) == 0x000358, "Member 'UBFGAnimation_Variables_Boss::M_vTargetDirectionToArmL' has a wrong offset!");
static_assert(offsetof(UBFGAnimation_Variables_Boss, M_vTargetDirectionToArmR) == 0x000364, "Member 'UBFGAnimation_Variables_Boss::M_vTargetDirectionToArmR' has a wrong offset!");
static_assert(offsetof(UBFGAnimation_Variables_Boss, M_vUpperBodyDirection) == 0x000370, "Member 'UBFGAnimation_Variables_Boss::M_vUpperBodyDirection' has a wrong offset!");
static_assert(offsetof(UBFGAnimation_Variables_Boss, M_bIsTurning) == 0x00037C, "Member 'UBFGAnimation_Variables_Boss::M_bIsTurning' has a wrong offset!");
static_assert(offsetof(UBFGAnimation_Variables_Boss, M_fTurnDelayStanding) == 0x000380, "Member 'UBFGAnimation_Variables_Boss::M_fTurnDelayStanding' has a wrong offset!");
static_assert(offsetof(UBFGAnimation_Variables_Boss, M_fTurnDelayMoving) == 0x000384, "Member 'UBFGAnimation_Variables_Boss::M_fTurnDelayMoving' has a wrong offset!");
static_assert(offsetof(UBFGAnimation_Variables_Boss, M_fTurnDeltaYaw) == 0x000388, "Member 'UBFGAnimation_Variables_Boss::M_fTurnDeltaYaw' has a wrong offset!");
static_assert(offsetof(UBFGAnimation_Variables_Boss, M_fMaxTurnDelta) == 0x00038C, "Member 'UBFGAnimation_Variables_Boss::M_fMaxTurnDelta' has a wrong offset!");
static_assert(offsetof(UBFGAnimation_Variables_Boss, M_bIsShootingMissiles) == 0x000390, "Member 'UBFGAnimation_Variables_Boss::M_bIsShootingMissiles' has a wrong offset!");
static_assert(offsetof(UBFGAnimation_Variables_Boss, M_bIsStompingL) == 0x000391, "Member 'UBFGAnimation_Variables_Boss::M_bIsStompingL' has a wrong offset!");
static_assert(offsetof(UBFGAnimation_Variables_Boss, M_bIsStompingR) == 0x000392, "Member 'UBFGAnimation_Variables_Boss::M_bIsStompingR' has a wrong offset!");
static_assert(offsetof(UBFGAnimation_Variables_Boss, M_fStompDamageDelay) == 0x000394, "Member 'UBFGAnimation_Variables_Boss::M_fStompDamageDelay' has a wrong offset!");
static_assert(offsetof(UBFGAnimation_Variables_Boss, M_fStompAnimationLength) == 0x000398, "Member 'UBFGAnimation_Variables_Boss::M_fStompAnimationLength' has a wrong offset!");
static_assert(offsetof(UBFGAnimation_Variables_Boss, M_bIsTelegraphingCharge) == 0x00039C, "Member 'UBFGAnimation_Variables_Boss::M_bIsTelegraphingCharge' has a wrong offset!");
static_assert(offsetof(UBFGAnimation_Variables_Boss, M_bIsCharging) == 0x00039D, "Member 'UBFGAnimation_Variables_Boss::M_bIsCharging' has a wrong offset!");
static_assert(offsetof(UBFGAnimation_Variables_Boss, M_fBrakeFrictionOverride) == 0x0003A0, "Member 'UBFGAnimation_Variables_Boss::M_fBrakeFrictionOverride' has a wrong offset!");
static_assert(offsetof(UBFGAnimation_Variables_Boss, M_bIsTelegraphingLeap) == 0x0003A4, "Member 'UBFGAnimation_Variables_Boss::M_bIsTelegraphingLeap' has a wrong offset!");
static_assert(offsetof(UBFGAnimation_Variables_Boss, M_bIsGrounded) == 0x0003A5, "Member 'UBFGAnimation_Variables_Boss::M_bIsGrounded' has a wrong offset!");
static_assert(offsetof(UBFGAnimation_Variables_Boss, M_fLandingDelay) == 0x0003A8, "Member 'UBFGAnimation_Variables_Boss::M_fLandingDelay' has a wrong offset!");
static_assert(offsetof(UBFGAnimation_Variables_Boss, M_fLeapTelegraphTime) == 0x0003AC, "Member 'UBFGAnimation_Variables_Boss::M_fLeapTelegraphTime' has a wrong offset!");
static_assert(offsetof(UBFGAnimation_Variables_Boss, M_fReinforcementDelay) == 0x0003B0, "Member 'UBFGAnimation_Variables_Boss::M_fReinforcementDelay' has a wrong offset!");
static_assert(offsetof(UBFGAnimation_Variables_Boss, M_fKnockDownDelay) == 0x0003B4, "Member 'UBFGAnimation_Variables_Boss::M_fKnockDownDelay' has a wrong offset!");
static_assert(offsetof(UBFGAnimation_Variables_Boss, M_bIsAttacking) == 0x0003B8, "Member 'UBFGAnimation_Variables_Boss::M_bIsAttacking' has a wrong offset!");
static_assert(offsetof(UBFGAnimation_Variables_Boss, M_bIsAttacking360) == 0x0003B9, "Member 'UBFGAnimation_Variables_Boss::M_bIsAttacking360' has a wrong offset!");
static_assert(offsetof(UBFGAnimation_Variables_Boss, M_bIsBeamActive) == 0x0003BA, "Member 'UBFGAnimation_Variables_Boss::M_bIsBeamActive' has a wrong offset!");
static_assert(offsetof(UBFGAnimation_Variables_Boss, M_f360Attack_StartDelay) == 0x0003BC, "Member 'UBFGAnimation_Variables_Boss::M_f360Attack_StartDelay' has a wrong offset!");
static_assert(offsetof(UBFGAnimation_Variables_Boss, M_f360Attack_StopDelay) == 0x0003C0, "Member 'UBFGAnimation_Variables_Boss::M_f360Attack_StopDelay' has a wrong offset!");
static_assert(offsetof(UBFGAnimation_Variables_Boss, M_e360AttackPhase) == 0x0003C4, "Member 'UBFGAnimation_Variables_Boss::M_e360AttackPhase' has a wrong offset!");
static_assert(offsetof(UBFGAnimation_Variables_Boss, M_eSilhouetteWeaponState) == 0x0003C5, "Member 'UBFGAnimation_Variables_Boss::M_eSilhouetteWeaponState' has a wrong offset!");
static_assert(offsetof(UBFGAnimation_Variables_Boss, M_fAimYaw) == 0x0003C8, "Member 'UBFGAnimation_Variables_Boss::M_fAimYaw' has a wrong offset!");
static_assert(offsetof(UBFGAnimation_Variables_Boss, M_fAimPitch) == 0x0003CC, "Member 'UBFGAnimation_Variables_Boss::M_fAimPitch' has a wrong offset!");
static_assert(offsetof(UBFGAnimation_Variables_Boss, M_eHoverState) == 0x0003D0, "Member 'UBFGAnimation_Variables_Boss::M_eHoverState' has a wrong offset!");
static_assert(offsetof(UBFGAnimation_Variables_Boss, M_bIsChargingNasalProbe) == 0x0003D1, "Member 'UBFGAnimation_Variables_Boss::M_bIsChargingNasalProbe' has a wrong offset!");
static_assert(offsetof(UBFGAnimation_Variables_Boss, M_fNasalProbeChargeRatio) == 0x0003D4, "Member 'UBFGAnimation_Variables_Boss::M_fNasalProbeChargeRatio' has a wrong offset!");
static_assert(offsetof(UBFGAnimation_Variables_Boss, M_bIsVulnerable) == 0x0003D8, "Member 'UBFGAnimation_Variables_Boss::M_bIsVulnerable' has a wrong offset!");
static_assert(offsetof(UBFGAnimation_Variables_Boss, M_bIsActivelyDrainingPSI) == 0x0003D9, "Member 'UBFGAnimation_Variables_Boss::M_bIsActivelyDrainingPSI' has a wrong offset!");
static_assert(offsetof(UBFGAnimation_Variables_Boss, M_bIsUnderCover) == 0x0003DA, "Member 'UBFGAnimation_Variables_Boss::M_bIsUnderCover' has a wrong offset!");
static_assert(offsetof(UBFGAnimation_Variables_Boss, M_bIsPerformingCosmeticActivity) == 0x0003DB, "Member 'UBFGAnimation_Variables_Boss::M_bIsPerformingCosmeticActivity' has a wrong offset!");
static_assert(offsetof(UBFGAnimation_Variables_Boss, M_bFlinch) == 0x0003DC, "Member 'UBFGAnimation_Variables_Boss::M_bFlinch' has a wrong offset!");
static_assert(offsetof(UBFGAnimation_Variables_Boss, M_bIsShootingBeam) == 0x0003DD, "Member 'UBFGAnimation_Variables_Boss::M_bIsShootingBeam' has a wrong offset!");
static_assert(offsetof(UBFGAnimation_Variables_Boss, M_eBeamAttackPhase) == 0x0003DE, "Member 'UBFGAnimation_Variables_Boss::M_eBeamAttackPhase' has a wrong offset!");
static_assert(offsetof(UBFGAnimation_Variables_Boss, M_vAimDirectionBeam) == 0x0003E0, "Member 'UBFGAnimation_Variables_Boss::M_vAimDirectionBeam' has a wrong offset!");
static_assert(offsetof(UBFGAnimation_Variables_Boss, M_bIsRelocating) == 0x0003EC, "Member 'UBFGAnimation_Variables_Boss::M_bIsRelocating' has a wrong offset!");
static_assert(offsetof(UBFGAnimation_Variables_Boss, M_bIsStartUpPhase) == 0x0003ED, "Member 'UBFGAnimation_Variables_Boss::M_bIsStartUpPhase' has a wrong offset!");

// Class BFGCore.BFGAnimation_Variables_Crypto
// 0x0060 (0x0330 - 0x02D0)
class UBFGAnimation_Variables_Crypto final : public UBFGAnimation_Variables
{
public:
	bool                                          M_bMentalAbilityIsActive;                          // 0x02C8(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	EBFGAnimation_MentalAbilityPosture            M_eMentalAbilityPosture;                           // 0x02C9(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_2CA[0x6];                                      // 0x02CA(0x0006)(Fixing Size After Last Property [ Dumper-7 ])
	class AActor*                                 M_pMentalAbilityCurrentTarget;                     // 0x02D0(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         M_fPKChargeRatio;                                  // 0x02D8(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_2DC[0x4];                                      // 0x02DC(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<struct FGameplayTag>                   M_aHolobobCopiedGameplayTags;                      // 0x02E0(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Protected, NativeAccessSpecifierProtected)
	bool                                          M_bIsEnteringOrLeavingUFO;                         // 0x02F0(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          M_bIsPKButtonBeeingHeld;                           // 0x02F1(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          M_bPKWillBeThrowOrDrop;                            // 0x02F2(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_2F3[0x1];                                      // 0x02F3(0x0001)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         M_fBrainExtractProgess;                            // 0x02F4(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          M_bDashing;                                        // 0x02F8(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_2F9[0x3];                                      // 0x02F9(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	int32                                         M_iCurrentDashPhase;                               // 0x02FC(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          M_bJetpackDeployed;                                // 0x0300(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          M_bJetpackThrottleActive;                          // 0x0301(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          M_bJetpackSkating;                                 // 0x0302(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_303[0x1];                                      // 0x0303(0x0001)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         M_fJetpackFuelRatio;                               // 0x0304(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          M_bTurning;                                        // 0x0308(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          M_bIsInWater;                                      // 0x0309(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_30A[0x2];                                      // 0x030A(0x0002)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         M_fAimPitchOffset;                                 // 0x030C(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         M_fAimYawOffset;                                   // 0x0310(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          M_bUseAimMode;                                     // 0x0314(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_315[0x3];                                      // 0x0315(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         M_fADSAlpha;                                       // 0x0318(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_31C[0x4];                                      // 0x031C(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class UBFGActorComponent_LockOnTarget*        M_pLockOnTarget;                                   // 0x0320(0x0008)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          M_bInCredits;                                      // 0x0328(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_329[0x7];                                      // 0x0329(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"BFGAnimation_Variables_Crypto">();
	}
	static class UBFGAnimation_Variables_Crypto* GetDefaultObj()
	{
		return GetDefaultObjImpl<UBFGAnimation_Variables_Crypto>();
	}
};
static_assert(alignof(UBFGAnimation_Variables_Crypto) == 0x000010, "Wrong alignment on UBFGAnimation_Variables_Crypto");
static_assert(sizeof(UBFGAnimation_Variables_Crypto) == 0x000330, "Wrong size on UBFGAnimation_Variables_Crypto");
static_assert(offsetof(UBFGAnimation_Variables_Crypto, M_bMentalAbilityIsActive) == 0x0002C8, "Member 'UBFGAnimation_Variables_Crypto::M_bMentalAbilityIsActive' has a wrong offset!");
static_assert(offsetof(UBFGAnimation_Variables_Crypto, M_eMentalAbilityPosture) == 0x0002C9, "Member 'UBFGAnimation_Variables_Crypto::M_eMentalAbilityPosture' has a wrong offset!");
static_assert(offsetof(UBFGAnimation_Variables_Crypto, M_pMentalAbilityCurrentTarget) == 0x0002D0, "Member 'UBFGAnimation_Variables_Crypto::M_pMentalAbilityCurrentTarget' has a wrong offset!");
static_assert(offsetof(UBFGAnimation_Variables_Crypto, M_fPKChargeRatio) == 0x0002D8, "Member 'UBFGAnimation_Variables_Crypto::M_fPKChargeRatio' has a wrong offset!");
static_assert(offsetof(UBFGAnimation_Variables_Crypto, M_aHolobobCopiedGameplayTags) == 0x0002E0, "Member 'UBFGAnimation_Variables_Crypto::M_aHolobobCopiedGameplayTags' has a wrong offset!");
static_assert(offsetof(UBFGAnimation_Variables_Crypto, M_bIsEnteringOrLeavingUFO) == 0x0002F0, "Member 'UBFGAnimation_Variables_Crypto::M_bIsEnteringOrLeavingUFO' has a wrong offset!");
static_assert(offsetof(UBFGAnimation_Variables_Crypto, M_bIsPKButtonBeeingHeld) == 0x0002F1, "Member 'UBFGAnimation_Variables_Crypto::M_bIsPKButtonBeeingHeld' has a wrong offset!");
static_assert(offsetof(UBFGAnimation_Variables_Crypto, M_bPKWillBeThrowOrDrop) == 0x0002F2, "Member 'UBFGAnimation_Variables_Crypto::M_bPKWillBeThrowOrDrop' has a wrong offset!");
static_assert(offsetof(UBFGAnimation_Variables_Crypto, M_fBrainExtractProgess) == 0x0002F4, "Member 'UBFGAnimation_Variables_Crypto::M_fBrainExtractProgess' has a wrong offset!");
static_assert(offsetof(UBFGAnimation_Variables_Crypto, M_bDashing) == 0x0002F8, "Member 'UBFGAnimation_Variables_Crypto::M_bDashing' has a wrong offset!");
static_assert(offsetof(UBFGAnimation_Variables_Crypto, M_iCurrentDashPhase) == 0x0002FC, "Member 'UBFGAnimation_Variables_Crypto::M_iCurrentDashPhase' has a wrong offset!");
static_assert(offsetof(UBFGAnimation_Variables_Crypto, M_bJetpackDeployed) == 0x000300, "Member 'UBFGAnimation_Variables_Crypto::M_bJetpackDeployed' has a wrong offset!");
static_assert(offsetof(UBFGAnimation_Variables_Crypto, M_bJetpackThrottleActive) == 0x000301, "Member 'UBFGAnimation_Variables_Crypto::M_bJetpackThrottleActive' has a wrong offset!");
static_assert(offsetof(UBFGAnimation_Variables_Crypto, M_bJetpackSkating) == 0x000302, "Member 'UBFGAnimation_Variables_Crypto::M_bJetpackSkating' has a wrong offset!");
static_assert(offsetof(UBFGAnimation_Variables_Crypto, M_fJetpackFuelRatio) == 0x000304, "Member 'UBFGAnimation_Variables_Crypto::M_fJetpackFuelRatio' has a wrong offset!");
static_assert(offsetof(UBFGAnimation_Variables_Crypto, M_bTurning) == 0x000308, "Member 'UBFGAnimation_Variables_Crypto::M_bTurning' has a wrong offset!");
static_assert(offsetof(UBFGAnimation_Variables_Crypto, M_bIsInWater) == 0x000309, "Member 'UBFGAnimation_Variables_Crypto::M_bIsInWater' has a wrong offset!");
static_assert(offsetof(UBFGAnimation_Variables_Crypto, M_fAimPitchOffset) == 0x00030C, "Member 'UBFGAnimation_Variables_Crypto::M_fAimPitchOffset' has a wrong offset!");
static_assert(offsetof(UBFGAnimation_Variables_Crypto, M_fAimYawOffset) == 0x000310, "Member 'UBFGAnimation_Variables_Crypto::M_fAimYawOffset' has a wrong offset!");
static_assert(offsetof(UBFGAnimation_Variables_Crypto, M_bUseAimMode) == 0x000314, "Member 'UBFGAnimation_Variables_Crypto::M_bUseAimMode' has a wrong offset!");
static_assert(offsetof(UBFGAnimation_Variables_Crypto, M_fADSAlpha) == 0x000318, "Member 'UBFGAnimation_Variables_Crypto::M_fADSAlpha' has a wrong offset!");
static_assert(offsetof(UBFGAnimation_Variables_Crypto, M_pLockOnTarget) == 0x000320, "Member 'UBFGAnimation_Variables_Crypto::M_pLockOnTarget' has a wrong offset!");
static_assert(offsetof(UBFGAnimation_Variables_Crypto, M_bInCredits) == 0x000328, "Member 'UBFGAnimation_Variables_Crypto::M_bInCredits' has a wrong offset!");

// Class BFGCore.BFGNetworkPathAgent_Vehicle
// 0x0008 (0x05A8 - 0x05A0)
class UBFGNetworkPathAgent_Vehicle : public UBFGNetworkPathAgent
{
public:
	bool                                          M_bIsEnemyVehicle;                                 // 0x05A0(0x0001)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_5A1[0x7];                                      // 0x05A1(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"BFGNetworkPathAgent_Vehicle">();
	}
	static class UBFGNetworkPathAgent_Vehicle* GetDefaultObj()
	{
		return GetDefaultObjImpl<UBFGNetworkPathAgent_Vehicle>();
	}
};
static_assert(alignof(UBFGNetworkPathAgent_Vehicle) == 0x000008, "Wrong alignment on UBFGNetworkPathAgent_Vehicle");
static_assert(sizeof(UBFGNetworkPathAgent_Vehicle) == 0x0005A8, "Wrong size on UBFGNetworkPathAgent_Vehicle");
static_assert(offsetof(UBFGNetworkPathAgent_Vehicle, M_bIsEnemyVehicle) == 0x0005A0, "Member 'UBFGNetworkPathAgent_Vehicle::M_bIsEnemyVehicle' has a wrong offset!");

// Class BFGCore.BFGDataAsset_StaticMesh
// 0x0030 (0x0060 - 0x0030)
class UBFGDataAsset_StaticMesh final : public UDataAsset
{
public:
	struct FGameplayTagContainer                  M_gameplayTags_PKDynamicActor;                     // 0x0030(0x0020)(Edit, DisableEditOnInstance, NativeAccessSpecifierPublic)
	class UBFGDataAsset_StaticMeshDestruction*    M_pDestructionDataAsset;                           // 0x0050(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UBFGDataAsset_StaticMeshBurning*        M_pBurningDataAsset;                               // 0x0058(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

public:
	static class UBFGDataAsset_StaticMesh* GetFromComponent(class UStaticMeshComponent* _pComponent);
	static class UBFGDataAsset_StaticMesh* GetFromMesh(class UStaticMesh* _pMesh);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"BFGDataAsset_StaticMesh">();
	}
	static class UBFGDataAsset_StaticMesh* GetDefaultObj()
	{
		return GetDefaultObjImpl<UBFGDataAsset_StaticMesh>();
	}
};
static_assert(alignof(UBFGDataAsset_StaticMesh) == 0x000008, "Wrong alignment on UBFGDataAsset_StaticMesh");
static_assert(sizeof(UBFGDataAsset_StaticMesh) == 0x000060, "Wrong size on UBFGDataAsset_StaticMesh");
static_assert(offsetof(UBFGDataAsset_StaticMesh, M_gameplayTags_PKDynamicActor) == 0x000030, "Member 'UBFGDataAsset_StaticMesh::M_gameplayTags_PKDynamicActor' has a wrong offset!");
static_assert(offsetof(UBFGDataAsset_StaticMesh, M_pDestructionDataAsset) == 0x000050, "Member 'UBFGDataAsset_StaticMesh::M_pDestructionDataAsset' has a wrong offset!");
static_assert(offsetof(UBFGDataAsset_StaticMesh, M_pBurningDataAsset) == 0x000058, "Member 'UBFGDataAsset_StaticMesh::M_pBurningDataAsset' has a wrong offset!");

// Class BFGCore.BFGAnimation_Variables_Human
// 0x0000 (0x0350 - 0x0350)
class UBFGAnimation_Variables_Human final : public UBFGAnimation_Variables_Npc
{
public:
	bool                                          M_bMentalAbilityIsActive;                          // 0x0348(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          M_bIsCoward;                                       // 0x0349(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	EBFGHypnotizeState_NPC                        M_hypnotizeState;                                  // 0x034A(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_34B[0x5];                                      // 0x034B(0x0005)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"BFGAnimation_Variables_Human">();
	}
	static class UBFGAnimation_Variables_Human* GetDefaultObj()
	{
		return GetDefaultObjImpl<UBFGAnimation_Variables_Human>();
	}
};
static_assert(alignof(UBFGAnimation_Variables_Human) == 0x000010, "Wrong alignment on UBFGAnimation_Variables_Human");
static_assert(sizeof(UBFGAnimation_Variables_Human) == 0x000350, "Wrong size on UBFGAnimation_Variables_Human");
static_assert(offsetof(UBFGAnimation_Variables_Human, M_bMentalAbilityIsActive) == 0x000348, "Member 'UBFGAnimation_Variables_Human::M_bMentalAbilityIsActive' has a wrong offset!");
static_assert(offsetof(UBFGAnimation_Variables_Human, M_bIsCoward) == 0x000349, "Member 'UBFGAnimation_Variables_Human::M_bIsCoward' has a wrong offset!");
static_assert(offsetof(UBFGAnimation_Variables_Human, M_hypnotizeState) == 0x00034A, "Member 'UBFGAnimation_Variables_Human::M_hypnotizeState' has a wrong offset!");

// Class BFGCore.BFGAnimation_Variables_Pox
// 0x0000 (0x02D0 - 0x02D0)
class UBFGAnimation_Variables_Pox final : public UBFGAnimation_Variables
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"BFGAnimation_Variables_Pox">();
	}
	static class UBFGAnimation_Variables_Pox* GetDefaultObj()
	{
		return GetDefaultObjImpl<UBFGAnimation_Variables_Pox>();
	}
};
static_assert(alignof(UBFGAnimation_Variables_Pox) == 0x000010, "Wrong alignment on UBFGAnimation_Variables_Pox");
static_assert(sizeof(UBFGAnimation_Variables_Pox) == 0x0002D0, "Wrong size on UBFGAnimation_Variables_Pox");

// Class BFGCore.BFGVoiceoverPlaybackComponent
// 0x0150 (0x0278 - 0x0128)
class UBFGVoiceoverPlaybackComponent : public UActorComponent
{
public:
	UMulticastDelegateProperty_                   M_onPlaybackStoppedEvent;                          // 0x0128(0x0018)(ZeroConstructor, InstancedReference, NativeAccessSpecifierPublic)
	struct FBFGVoiceoverPlaybackRequest           M_request;                                         // 0x0140(0x0130)(BlueprintVisible, BlueprintReadOnly, NativeAccessSpecifierPublic)
	uint8                                         Pad_270[0x8];                                      // 0x0270(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void BFGVoiceoverPlaybackCompoment_Event__DelegateSignature();
	void CancelPlaybackItem(float _fOverriddenFadeoutDuration);
	void DoEndPlayback();
	void SetPauseItem(bool _bIsPaused);
	void StartPlaybackItem();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"BFGVoiceoverPlaybackComponent">();
	}
	static class UBFGVoiceoverPlaybackComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UBFGVoiceoverPlaybackComponent>();
	}
};
static_assert(alignof(UBFGVoiceoverPlaybackComponent) == 0x000008, "Wrong alignment on UBFGVoiceoverPlaybackComponent");
static_assert(sizeof(UBFGVoiceoverPlaybackComponent) == 0x000278, "Wrong size on UBFGVoiceoverPlaybackComponent");
static_assert(offsetof(UBFGVoiceoverPlaybackComponent, M_onPlaybackStoppedEvent) == 0x000128, "Member 'UBFGVoiceoverPlaybackComponent::M_onPlaybackStoppedEvent' has a wrong offset!");
static_assert(offsetof(UBFGVoiceoverPlaybackComponent, M_request) == 0x000140, "Member 'UBFGVoiceoverPlaybackComponent::M_request' has a wrong offset!");

// Class BFGCore.BFGVoiceoverPlaybackComponent_Simple
// 0x0020 (0x0298 - 0x0278)
class UBFGVoiceoverPlaybackComponent_Simple : public UBFGVoiceoverPlaybackComponent
{
public:
	class UAudioComponent*                        M_pAudioComponent;                                 // 0x0278(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         M_fFadeOutOnCancelDuration;                        // 0x0280(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         M_fMax3DPlaybackDistance;                          // 0x0284(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_288[0x10];                                     // 0x0288(0x0010)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"BFGVoiceoverPlaybackComponent_Simple">();
	}
	static class UBFGVoiceoverPlaybackComponent_Simple* GetDefaultObj()
	{
		return GetDefaultObjImpl<UBFGVoiceoverPlaybackComponent_Simple>();
	}
};
static_assert(alignof(UBFGVoiceoverPlaybackComponent_Simple) == 0x000008, "Wrong alignment on UBFGVoiceoverPlaybackComponent_Simple");
static_assert(sizeof(UBFGVoiceoverPlaybackComponent_Simple) == 0x000298, "Wrong size on UBFGVoiceoverPlaybackComponent_Simple");
static_assert(offsetof(UBFGVoiceoverPlaybackComponent_Simple, M_pAudioComponent) == 0x000278, "Member 'UBFGVoiceoverPlaybackComponent_Simple::M_pAudioComponent' has a wrong offset!");
static_assert(offsetof(UBFGVoiceoverPlaybackComponent_Simple, M_fFadeOutOnCancelDuration) == 0x000280, "Member 'UBFGVoiceoverPlaybackComponent_Simple::M_fFadeOutOnCancelDuration' has a wrong offset!");
static_assert(offsetof(UBFGVoiceoverPlaybackComponent_Simple, M_fMax3DPlaybackDistance) == 0x000284, "Member 'UBFGVoiceoverPlaybackComponent_Simple::M_fMax3DPlaybackDistance' has a wrong offset!");

// Class BFGCore.BFGVoiceoverPlaybackComponent_Subtitle
// 0x0028 (0x02C0 - 0x0298)
class UBFGVoiceoverPlaybackComponent_Subtitle final : public UBFGVoiceoverPlaybackComponent_Simple
{
public:
	uint8                                         Pad_298[0x8];                                      // 0x0298(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	class FText                                   M_strSubtitleText;                                 // 0x02A0(0x0018)(BlueprintVisible, BlueprintReadOnly, NativeAccessSpecifierPublic)
	bool                                          M_bShowWidget;                                     // 0x02B8(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2B9[0x7];                                      // 0x02B9(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"BFGVoiceoverPlaybackComponent_Subtitle">();
	}
	static class UBFGVoiceoverPlaybackComponent_Subtitle* GetDefaultObj()
	{
		return GetDefaultObjImpl<UBFGVoiceoverPlaybackComponent_Subtitle>();
	}
};
static_assert(alignof(UBFGVoiceoverPlaybackComponent_Subtitle) == 0x000008, "Wrong alignment on UBFGVoiceoverPlaybackComponent_Subtitle");
static_assert(sizeof(UBFGVoiceoverPlaybackComponent_Subtitle) == 0x0002C0, "Wrong size on UBFGVoiceoverPlaybackComponent_Subtitle");
static_assert(offsetof(UBFGVoiceoverPlaybackComponent_Subtitle, M_strSubtitleText) == 0x0002A0, "Member 'UBFGVoiceoverPlaybackComponent_Subtitle::M_strSubtitleText' has a wrong offset!");
static_assert(offsetof(UBFGVoiceoverPlaybackComponent_Subtitle, M_bShowWidget) == 0x0002B8, "Member 'UBFGVoiceoverPlaybackComponent_Subtitle::M_bShowWidget' has a wrong offset!");

// Class BFGCore.BFGDynamicSpacer
// 0x0020 (0x0138 - 0x0118)
class UBFGDynamicSpacer final : public UWidget
{
public:
	struct FVector2D                              MaxSize;                                           // 0x0118(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector2D                              SizeMultiplier;                                    // 0x0120(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_128[0x10];                                     // 0x0128(0x0010)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void SetMaxSize(const struct FVector2D& _vMaxSize);
	void SetSizeMultiplier(const struct FVector2D& _vMultiplier);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"BFGDynamicSpacer">();
	}
	static class UBFGDynamicSpacer* GetDefaultObj()
	{
		return GetDefaultObjImpl<UBFGDynamicSpacer>();
	}
};
static_assert(alignof(UBFGDynamicSpacer) == 0x000008, "Wrong alignment on UBFGDynamicSpacer");
static_assert(sizeof(UBFGDynamicSpacer) == 0x000138, "Wrong size on UBFGDynamicSpacer");
static_assert(offsetof(UBFGDynamicSpacer, MaxSize) == 0x000118, "Member 'UBFGDynamicSpacer::MaxSize' has a wrong offset!");
static_assert(offsetof(UBFGDynamicSpacer, SizeMultiplier) == 0x000120, "Member 'UBFGDynamicSpacer::SizeMultiplier' has a wrong offset!");

// Class BFGCore.BFGAnimationInstance
// 0x0160 (0x03F8 - 0x0298)
#pragma pack(push, 0x1)
class alignas(0x08) UBFGAnimationInstance : public UAnimInstance
{
public:
	class UBFGAnimation_Variables*                M_pVariables;                                      // 0x0298(0x0008)(Edit, ExportObject, ZeroConstructor, Transient, EditConst, InstancedReference, NoClear, IsPlainOldData, NoDestructor, Protected, PersistentInstance, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UBFGAnimation_Events*                   M_pEvents;                                         // 0x02A0(0x0008)(Edit, ExportObject, ZeroConstructor, Transient, EditConst, InstancedReference, NoClear, IsPlainOldData, NoDestructor, Protected, PersistentInstance, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	struct FGameplayTagContainer                  M_oGameplayEffectTags;                             // 0x02A8(0x0020)(Edit, Protected, NativeAccessSpecifierProtected)
	float                                         M_fMaxFloorDistance;                               // 0x02C8(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          M_bUseDistanceLookupOptimisations;                 // 0x02CC(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_2CD[0x3];                                      // 0x02CD(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<class UAnimSequence*>                  M_apStartDistanceAnimations;                       // 0x02D0(0x0010)(Edit, ZeroConstructor, Protected, NativeAccessSpecifierProtected)
	TArray<class UAnimSequence*>                  M_apActiveStartDistanceAnimations;                 // 0x02E0(0x0010)(ZeroConstructor, Transient, Protected, NativeAccessSpecifierProtected)
	TArray<struct FBFGAnimationDistanceCurveReader> M_apStartDistanceCurveReaders;                     // 0x02F0(0x0010)(ZeroConstructor, Transient, Protected, NativeAccessSpecifierProtected)
	TArray<class UAnimSequence*>                  M_apStartTurnDistanceAnimations;                   // 0x0300(0x0010)(Edit, ZeroConstructor, Protected, NativeAccessSpecifierProtected)
	TArray<class UAnimSequence*>                  M_apActiveStartTurnDistanceAnimations;             // 0x0310(0x0010)(ZeroConstructor, Transient, Protected, NativeAccessSpecifierProtected)
	TArray<struct FBFGAnimationDistanceCurveReader> M_apStartTurnDistanceCurveReaders;                 // 0x0320(0x0010)(ZeroConstructor, Transient, Protected, NativeAccessSpecifierProtected)
	TArray<class UAnimSequence*>                  M_apStopDistanceAnimations;                        // 0x0330(0x0010)(Edit, ZeroConstructor, Protected, NativeAccessSpecifierProtected)
	TArray<class UAnimSequence*>                  M_apActiveStopDistanceAnimations;                  // 0x0340(0x0010)(ZeroConstructor, Transient, Protected, NativeAccessSpecifierProtected)
	TArray<struct FBFGAnimationDistanceCurveReader> M_apStopDistanceCurveReaders;                      // 0x0350(0x0010)(ZeroConstructor, Transient, Protected, NativeAccessSpecifierProtected)
	TArray<class UAnimSequence*>                  M_apPrePivotDistanceAnimations;                    // 0x0360(0x0010)(Edit, ZeroConstructor, Protected, NativeAccessSpecifierProtected)
	TArray<class UAnimSequence*>                  M_apActivePrePivotDistanceAnimations;              // 0x0370(0x0010)(ZeroConstructor, Transient, Protected, NativeAccessSpecifierProtected)
	TArray<struct FBFGAnimationDistanceCurveReader> M_apPrePivotDistanceCurveReaders;                  // 0x0380(0x0010)(ZeroConstructor, Transient, Protected, NativeAccessSpecifierProtected)
	TArray<class UAnimSequence*>                  M_apPostPivotDistanceAnimations;                   // 0x0390(0x0010)(Edit, ZeroConstructor, Protected, NativeAccessSpecifierProtected)
	TArray<class UAnimSequence*>                  M_apActivePostPivotDistanceAnimations;             // 0x03A0(0x0010)(ZeroConstructor, Transient, Protected, NativeAccessSpecifierProtected)
	TArray<struct FBFGAnimationDistanceCurveReader> M_apPostPivotDistanceCurveReaders;                 // 0x03B0(0x0010)(ZeroConstructor, Transient, Protected, NativeAccessSpecifierProtected)
	TArray<class UAnimSequence*>                  M_apTurningDistanceAnimations;                     // 0x03C0(0x0010)(Edit, ZeroConstructor, Protected, NativeAccessSpecifierProtected)
	TArray<class UAnimSequence*>                  M_apActiveTurningDistanceAnimations;               // 0x03D0(0x0010)(ZeroConstructor, Transient, Protected, NativeAccessSpecifierProtected)
	TArray<struct FBFGAnimationDistanceCurveReader> M_apTurningDistanceCurveReaders;                   // 0x03E0(0x0010)(ZeroConstructor, Transient, Protected, NativeAccessSpecifierProtected)
	class UBFGActorComponent_CharacterMovement*   M_pMovementComponent;                              // 0x03F0(0x0008)(ExportObject, ZeroConstructor, Transient, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)

public:
	void AddActivePostPivotAnimationDistanceLookup(class UAnimSequence* _pAnimation);
	void AddActivePrePivotAnimationDistanceLookup(class UAnimSequence* _pAnimation);
	void AddActiveStartAnimationDistanceLookup(class UAnimSequence* _pAnimation);
	void AddActiveStartTurnAnimationDistanceLookup(class UAnimSequence* _pAnimation);
	void AddActiveStopAnimationDistanceLookup(class UAnimSequence* _pAnimation);
	void AddActiveTurningAnimationDistanceLookup(class UAnimSequence* _pAnimation);
	void ClearActivePostPivotAnimationDistanceLookups();
	void ClearActivePrePivotAnimationDistanceLookups();
	void ClearActiveStartAnimationDistanceLookups();
	void ClearActiveStartTurnAnimationDistanceLookups();
	void ClearActiveStopAnimationDistanceLookups();
	void ClearActiveTurningAnimationDistanceLookups();
	void G2ACryptoUFOInteraction(bool _bIsEntering);
	void G2AGetHit(const struct FVector& _vHitDirection, const class UBFGDamageType* _pDamageType);
	void G2AHitByPhysicsObject(const struct FVector& _vHitDirection, float _fVelocity, class AActor* _pHitByActor);
	void G2AShotFire(class FName _nSocketName);
	void G2AWeaponShotFired(class ABFGWeapon* _pWeapon);
	void G2AWeaponTelegraphingEnd(class ABFGWeapon* _pWeapon);
	void G2AWeaponTelegraphingStart(class ABFGWeapon* _pWeapon);
	TArray<class UAnimSequence*> GetActiveStopAnimationDistanceLookups();
	void LodTransitionStarted(const struct FPoseSnapshot& _oPoseSnapshot, float _fTransitionTime);
	void LodTransitionUpdated(const struct FPoseSnapshot& _oPoseSnapshot);
	void RemoveActivePostPivotAnimationDistanceLookup(class UAnimSequence* _pAnimation);
	void RemoveActivePrePivotAnimationDistanceLookup(class UAnimSequence* _pAnimation);
	void RemoveActiveStartAnimationDistanceLookup(class UAnimSequence* _pAnimation);
	void RemoveActiveStartTurnAnimationDistanceLookup(class UAnimSequence* _pAnimation);
	void RemoveActiveStopAnimationDistanceLookup(class UAnimSequence* _pAnimation);
	void RemoveActiveTurningAnimationDistanceLookup(class UAnimSequence* _pAnimation);
	void StandUpFinished();
	void StandUpStarted(bool _bIsFaceDown, const struct FPoseSnapshot& _oPoseSnapshot);

	class UBFGAnimation_Events* GetEvents() const;
	const struct FGameplayTagContainer GetGameplayEffectTags() const;
	float GetMaxFloorDistance() const;
	float GetPostPivotAnimationDistanceResult(class UAnimSequence* _pAnimation) const;
	float GetPrePivotAnimationDistanceResult(class UAnimSequence* _pAnimation) const;
	float GetStartAnimationDistanceResult(class UAnimSequence* _pAnimation) const;
	float GetStartTurnAnimationDistanceResult(class UAnimSequence* _pAnimation) const;
	float GetStopAnimationDistanceResult(class UAnimSequence* _pAnimation) const;
	float GetTurningAnimationDistanceResult(class UAnimSequence* _pAnimation) const;
	class UBFGAnimation_Variables* GetVariables() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"BFGAnimationInstance">();
	}
	static class UBFGAnimationInstance* GetDefaultObj()
	{
		return GetDefaultObjImpl<UBFGAnimationInstance>();
	}
};
#pragma pack(pop)
static_assert(alignof(UBFGAnimationInstance) == 0x000008, "Wrong alignment on UBFGAnimationInstance");
static_assert(sizeof(UBFGAnimationInstance) == 0x0003F8, "Wrong size on UBFGAnimationInstance");
static_assert(offsetof(UBFGAnimationInstance, M_pVariables) == 0x000298, "Member 'UBFGAnimationInstance::M_pVariables' has a wrong offset!");
static_assert(offsetof(UBFGAnimationInstance, M_pEvents) == 0x0002A0, "Member 'UBFGAnimationInstance::M_pEvents' has a wrong offset!");
static_assert(offsetof(UBFGAnimationInstance, M_oGameplayEffectTags) == 0x0002A8, "Member 'UBFGAnimationInstance::M_oGameplayEffectTags' has a wrong offset!");
static_assert(offsetof(UBFGAnimationInstance, M_fMaxFloorDistance) == 0x0002C8, "Member 'UBFGAnimationInstance::M_fMaxFloorDistance' has a wrong offset!");
static_assert(offsetof(UBFGAnimationInstance, M_bUseDistanceLookupOptimisations) == 0x0002CC, "Member 'UBFGAnimationInstance::M_bUseDistanceLookupOptimisations' has a wrong offset!");
static_assert(offsetof(UBFGAnimationInstance, M_apStartDistanceAnimations) == 0x0002D0, "Member 'UBFGAnimationInstance::M_apStartDistanceAnimations' has a wrong offset!");
static_assert(offsetof(UBFGAnimationInstance, M_apActiveStartDistanceAnimations) == 0x0002E0, "Member 'UBFGAnimationInstance::M_apActiveStartDistanceAnimations' has a wrong offset!");
static_assert(offsetof(UBFGAnimationInstance, M_apStartDistanceCurveReaders) == 0x0002F0, "Member 'UBFGAnimationInstance::M_apStartDistanceCurveReaders' has a wrong offset!");
static_assert(offsetof(UBFGAnimationInstance, M_apStartTurnDistanceAnimations) == 0x000300, "Member 'UBFGAnimationInstance::M_apStartTurnDistanceAnimations' has a wrong offset!");
static_assert(offsetof(UBFGAnimationInstance, M_apActiveStartTurnDistanceAnimations) == 0x000310, "Member 'UBFGAnimationInstance::M_apActiveStartTurnDistanceAnimations' has a wrong offset!");
static_assert(offsetof(UBFGAnimationInstance, M_apStartTurnDistanceCurveReaders) == 0x000320, "Member 'UBFGAnimationInstance::M_apStartTurnDistanceCurveReaders' has a wrong offset!");
static_assert(offsetof(UBFGAnimationInstance, M_apStopDistanceAnimations) == 0x000330, "Member 'UBFGAnimationInstance::M_apStopDistanceAnimations' has a wrong offset!");
static_assert(offsetof(UBFGAnimationInstance, M_apActiveStopDistanceAnimations) == 0x000340, "Member 'UBFGAnimationInstance::M_apActiveStopDistanceAnimations' has a wrong offset!");
static_assert(offsetof(UBFGAnimationInstance, M_apStopDistanceCurveReaders) == 0x000350, "Member 'UBFGAnimationInstance::M_apStopDistanceCurveReaders' has a wrong offset!");
static_assert(offsetof(UBFGAnimationInstance, M_apPrePivotDistanceAnimations) == 0x000360, "Member 'UBFGAnimationInstance::M_apPrePivotDistanceAnimations' has a wrong offset!");
static_assert(offsetof(UBFGAnimationInstance, M_apActivePrePivotDistanceAnimations) == 0x000370, "Member 'UBFGAnimationInstance::M_apActivePrePivotDistanceAnimations' has a wrong offset!");
static_assert(offsetof(UBFGAnimationInstance, M_apPrePivotDistanceCurveReaders) == 0x000380, "Member 'UBFGAnimationInstance::M_apPrePivotDistanceCurveReaders' has a wrong offset!");
static_assert(offsetof(UBFGAnimationInstance, M_apPostPivotDistanceAnimations) == 0x000390, "Member 'UBFGAnimationInstance::M_apPostPivotDistanceAnimations' has a wrong offset!");
static_assert(offsetof(UBFGAnimationInstance, M_apActivePostPivotDistanceAnimations) == 0x0003A0, "Member 'UBFGAnimationInstance::M_apActivePostPivotDistanceAnimations' has a wrong offset!");
static_assert(offsetof(UBFGAnimationInstance, M_apPostPivotDistanceCurveReaders) == 0x0003B0, "Member 'UBFGAnimationInstance::M_apPostPivotDistanceCurveReaders' has a wrong offset!");
static_assert(offsetof(UBFGAnimationInstance, M_apTurningDistanceAnimations) == 0x0003C0, "Member 'UBFGAnimationInstance::M_apTurningDistanceAnimations' has a wrong offset!");
static_assert(offsetof(UBFGAnimationInstance, M_apActiveTurningDistanceAnimations) == 0x0003D0, "Member 'UBFGAnimationInstance::M_apActiveTurningDistanceAnimations' has a wrong offset!");
static_assert(offsetof(UBFGAnimationInstance, M_apTurningDistanceCurveReaders) == 0x0003E0, "Member 'UBFGAnimationInstance::M_apTurningDistanceCurveReaders' has a wrong offset!");
static_assert(offsetof(UBFGAnimationInstance, M_pMovementComponent) == 0x0003F0, "Member 'UBFGAnimationInstance::M_pMovementComponent' has a wrong offset!");

// Class BFGCore.BFGObject_StaticWithPhysics
// 0x01C0 (0x0598 - 0x03D8)
class ABFGObject_StaticWithPhysics : public AActor
{
public:
	uint8                                         Pad_3D8[0x38];                                     // 0x03D8(0x0038)(Fixing Size After Last Property [ Dumper-7 ])
	class UBFGActorComponent_MonetaryValue*       M_pMonetaryValueComponent;                         // 0x0410(0x0008)(Edit, BlueprintVisible, ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UBFGActorComponent_CharacterPhysics*    M_pCharacterPhysicsComponent;                      // 0x0418(0x0008)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, EditConst, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UBFGActorComponent_Effect*              M_pEffectsComponent;                               // 0x0420(0x0008)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, EditConst, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UBFGActorComponent_GameplayEffectTags*  M_pGameplayEffectTagsComponent;                    // 0x0428(0x0008)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, EditConst, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UBFGBuoyancyForceComponent*             M_pBuoyancyComponent;                              // 0x0430(0x0008)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, EditConst, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UBFGActorComponent_FallDamage*          M_pFallDamageComponent;                            // 0x0438(0x0008)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, EditConst, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FGameplayTagContainer                  M_gameplayTags;                                    // 0x0440(0x0020)(Edit, BlueprintVisible, BlueprintReadOnly, NativeAccessSpecifierPublic)
	struct FGameplayTagContainer                  M_gameplayTags_RunTime;                            // 0x0460(0x0020)(Edit, BlueprintVisible, BlueprintReadOnly, EditConst, NativeAccessSpecifierPublic)
	struct FBFGObject_StaticWithPhysics_SpawnParams M_spawnParams;                                     // 0x0480(0x0002)(Edit, BlueprintVisible, BlueprintReadOnly, NoDestructor, NativeAccessSpecifierPublic)
	uint8                                         Pad_482[0x2];                                      // 0x0482(0x0002)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         M_fDestructionTimeFrame;                           // 0x0484(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         M_fDestructionRemovalTimeFrame;                    // 0x0488(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         M_fObjectDebrisRemovalSpeed;                       // 0x048C(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         M_fBlastMeshDamageOnHit;                           // 0x0490(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         M_fBlastMeshImpulseMultiplier;                     // 0x0494(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         M_fMinimumDestructionVelocity;                     // 0x0498(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_49C[0x4];                                      // 0x049C(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class UStaticMeshComponent*                   M_pStaticMesh;                                     // 0x04A0(0x0008)(Edit, BlueprintVisible, ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_4A8[0x8];                                      // 0x04A8(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	class UBFGActorComponent_MissionGameplay*     M_pMissionGameplayComponent;                       // 0x04B0(0x0008)(Edit, ExportObject, ZeroConstructor, EditConst, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UBlastMeshComponent*                    M_pBlastMeshComponent;                             // 0x04B8(0x0008)(Edit, ExportObject, ZeroConstructor, EditConst, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UParticleSystemComponent*               M_pParticleSystemComponent;                        // 0x04C0(0x0008)(Edit, ExportObject, ZeroConstructor, EditConst, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_4C8[0xA8];                                     // 0x04C8(0x00A8)(Fixing Size After Last Property [ Dumper-7 ])
	class UBFGDataAsset_StaticMesh*               M_pCachedStaticMeshDataAsset;                      // 0x0570(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UBFGDataAsset_StaticMeshDestruction*    M_pCachedStaticMeshDestructionDataAsset;           // 0x0578(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UBFGDataAsset_StaticMeshBurning*        M_pCachedStaticMeshBurningDataAsset;               // 0x0580(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_588[0x10];                                     // 0x0588(0x0010)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	bool GetDisableTargeting();
	void OnDestructionTriggered();
	void OnPKDrop();
	void OnPKPickUp();
	void SetDisableTargeting(bool _bIsTargetingDisabled);
	void SetMeshFromBlueprint(class UStaticMeshComponent* PStaticMesh);
	void SetOnFire();
	void TriggerObjectBlastMeshDestruction(const struct FVector& _fImpulse);

	bool GetIsDestructionInProgess() const;
	bool GetIsHeldInPK() const;
	class UBFGDataAsset_StaticMeshBurning* GetStaticMeshBurningDataAsset() const;
	class UStaticMeshComponent* GetStaticMeshComponent() const;
	class UBFGDataAsset_StaticMesh* GetStaticMeshDataAsset() const;
	class UBFGDataAsset_StaticMeshDestruction* GetStaticMeshDestructionDataAsset() const;
	bool IsDestructable() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"BFGObject_StaticWithPhysics">();
	}
	static class ABFGObject_StaticWithPhysics* GetDefaultObj()
	{
		return GetDefaultObjImpl<ABFGObject_StaticWithPhysics>();
	}
};
static_assert(alignof(ABFGObject_StaticWithPhysics) == 0x000008, "Wrong alignment on ABFGObject_StaticWithPhysics");
static_assert(sizeof(ABFGObject_StaticWithPhysics) == 0x000598, "Wrong size on ABFGObject_StaticWithPhysics");
static_assert(offsetof(ABFGObject_StaticWithPhysics, M_pMonetaryValueComponent) == 0x000410, "Member 'ABFGObject_StaticWithPhysics::M_pMonetaryValueComponent' has a wrong offset!");
static_assert(offsetof(ABFGObject_StaticWithPhysics, M_pCharacterPhysicsComponent) == 0x000418, "Member 'ABFGObject_StaticWithPhysics::M_pCharacterPhysicsComponent' has a wrong offset!");
static_assert(offsetof(ABFGObject_StaticWithPhysics, M_pEffectsComponent) == 0x000420, "Member 'ABFGObject_StaticWithPhysics::M_pEffectsComponent' has a wrong offset!");
static_assert(offsetof(ABFGObject_StaticWithPhysics, M_pGameplayEffectTagsComponent) == 0x000428, "Member 'ABFGObject_StaticWithPhysics::M_pGameplayEffectTagsComponent' has a wrong offset!");
static_assert(offsetof(ABFGObject_StaticWithPhysics, M_pBuoyancyComponent) == 0x000430, "Member 'ABFGObject_StaticWithPhysics::M_pBuoyancyComponent' has a wrong offset!");
static_assert(offsetof(ABFGObject_StaticWithPhysics, M_pFallDamageComponent) == 0x000438, "Member 'ABFGObject_StaticWithPhysics::M_pFallDamageComponent' has a wrong offset!");
static_assert(offsetof(ABFGObject_StaticWithPhysics, M_gameplayTags) == 0x000440, "Member 'ABFGObject_StaticWithPhysics::M_gameplayTags' has a wrong offset!");
static_assert(offsetof(ABFGObject_StaticWithPhysics, M_gameplayTags_RunTime) == 0x000460, "Member 'ABFGObject_StaticWithPhysics::M_gameplayTags_RunTime' has a wrong offset!");
static_assert(offsetof(ABFGObject_StaticWithPhysics, M_spawnParams) == 0x000480, "Member 'ABFGObject_StaticWithPhysics::M_spawnParams' has a wrong offset!");
static_assert(offsetof(ABFGObject_StaticWithPhysics, M_fDestructionTimeFrame) == 0x000484, "Member 'ABFGObject_StaticWithPhysics::M_fDestructionTimeFrame' has a wrong offset!");
static_assert(offsetof(ABFGObject_StaticWithPhysics, M_fDestructionRemovalTimeFrame) == 0x000488, "Member 'ABFGObject_StaticWithPhysics::M_fDestructionRemovalTimeFrame' has a wrong offset!");
static_assert(offsetof(ABFGObject_StaticWithPhysics, M_fObjectDebrisRemovalSpeed) == 0x00048C, "Member 'ABFGObject_StaticWithPhysics::M_fObjectDebrisRemovalSpeed' has a wrong offset!");
static_assert(offsetof(ABFGObject_StaticWithPhysics, M_fBlastMeshDamageOnHit) == 0x000490, "Member 'ABFGObject_StaticWithPhysics::M_fBlastMeshDamageOnHit' has a wrong offset!");
static_assert(offsetof(ABFGObject_StaticWithPhysics, M_fBlastMeshImpulseMultiplier) == 0x000494, "Member 'ABFGObject_StaticWithPhysics::M_fBlastMeshImpulseMultiplier' has a wrong offset!");
static_assert(offsetof(ABFGObject_StaticWithPhysics, M_fMinimumDestructionVelocity) == 0x000498, "Member 'ABFGObject_StaticWithPhysics::M_fMinimumDestructionVelocity' has a wrong offset!");
static_assert(offsetof(ABFGObject_StaticWithPhysics, M_pStaticMesh) == 0x0004A0, "Member 'ABFGObject_StaticWithPhysics::M_pStaticMesh' has a wrong offset!");
static_assert(offsetof(ABFGObject_StaticWithPhysics, M_pMissionGameplayComponent) == 0x0004B0, "Member 'ABFGObject_StaticWithPhysics::M_pMissionGameplayComponent' has a wrong offset!");
static_assert(offsetof(ABFGObject_StaticWithPhysics, M_pBlastMeshComponent) == 0x0004B8, "Member 'ABFGObject_StaticWithPhysics::M_pBlastMeshComponent' has a wrong offset!");
static_assert(offsetof(ABFGObject_StaticWithPhysics, M_pParticleSystemComponent) == 0x0004C0, "Member 'ABFGObject_StaticWithPhysics::M_pParticleSystemComponent' has a wrong offset!");
static_assert(offsetof(ABFGObject_StaticWithPhysics, M_pCachedStaticMeshDataAsset) == 0x000570, "Member 'ABFGObject_StaticWithPhysics::M_pCachedStaticMeshDataAsset' has a wrong offset!");
static_assert(offsetof(ABFGObject_StaticWithPhysics, M_pCachedStaticMeshDestructionDataAsset) == 0x000578, "Member 'ABFGObject_StaticWithPhysics::M_pCachedStaticMeshDestructionDataAsset' has a wrong offset!");
static_assert(offsetof(ABFGObject_StaticWithPhysics, M_pCachedStaticMeshBurningDataAsset) == 0x000580, "Member 'ABFGObject_StaticWithPhysics::M_pCachedStaticMeshBurningDataAsset' has a wrong offset!");

// Class BFGCore.BFGAnimationInstance_Npc
// 0x0168 (0x0560 - 0x03F8)
#pragma pack(push, 0x1)
class alignas(0x10) UBFGAnimationInstance_Npc : public UBFGAnimationInstance
{
public:
	uint8                                         Pad_3F8[0x8];                                      // 0x03F8(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	class UDataTable*                             M_pInteractAnimationTable;                         // 0x0400(0x0008)(Edit, BlueprintVisible, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UAnimationAsset*                        M_pInteractAnimation;                              // 0x0408(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, EditConst, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          M_bIsPlayingInteract;                              // 0x0410(0x0001)(Edit, BlueprintVisible, ZeroConstructor, Transient, EditConst, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          M_bWasPlayingInteract;                             // 0x0411(0x0001)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_412[0x6];                                      // 0x0412(0x0006)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<struct FBFGInteractAnimationSequence>  M_apAnimationSequences;                            // 0x0418(0x0010)(Edit, BlueprintVisible, ZeroConstructor, Transient, EditConst, Protected, NativeAccessSpecifierProtected)
	struct FBFGInteractAnimationData              M_lastAnimationData;                               // 0x0428(0x0060)(Transient, NoDestructor, Protected, NativeAccessSpecifierProtected)
	UMulticastDelegateProperty_                   M_onInteractAnimationSequenceInterrupted;          // 0x0488(0x0018)(ZeroConstructor, InstancedReference, BlueprintAssignable, Protected, BlueprintCallable, NativeAccessSpecifierProtected)
	UMulticastDelegateProperty_                   M_onInteractAnimationPop;                          // 0x04A0(0x0018)(ZeroConstructor, InstancedReference, BlueprintAssignable, Protected, BlueprintCallable, NativeAccessSpecifierProtected)
	TScriptInterface<class IBFGInteractAnimationPlayerInterface> M_orchestrator;                                    // 0x04B8(0x0010)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, UObjectWrapper, NativeAccessSpecifierProtected)
	float                                         M_fBlendingRemainingTime;                          // 0x04C8(0x0004)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	struct FVector                                M_vInitialLocation;                                // 0x04CC(0x000C)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	struct FRotator                               M_vInitialRotation;                                // 0x04D8(0x000C)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, NativeAccessSpecifierProtected)
	uint8                                         Pad_4E4[0xC];                                      // 0x04E4(0x000C)(Fixing Size After Last Property [ Dumper-7 ])
	struct FTransform                             M_meshRelativeTransform;                           // 0x04F0(0x0030)(Transient, IsPlainOldData, NoDestructor, Protected, NativeAccessSpecifierProtected)
	struct FTransform                             M_vTargetTransform;                                // 0x0520(0x0030)(Transient, IsPlainOldData, NoDestructor, Protected, NativeAccessSpecifierProtected)
	class UBFGActorComponent_NPCCharacterMovement* M_pNPCMovementComponent;                           // 0x0550(0x0008)(ExportObject, ZeroConstructor, Transient, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)

public:
	void ClearInteractAnimations(bool _bRestoreCollisions);
	void G2AAlert();
	void G2AEvade(EBFGEvadeDirection _direction, class AActor* _pEvadeFromActor);
	void G2APlayerBumped(const struct FVector& _vHitDirection, float _fVelocity, class AActor* _pHitByActor);
	void OnOrchestratorInteractAnimationPop(TScriptInterface<class IBFGInteractAnimationPlayerInterface> _pOrchestrator, const struct FBFGInteractAnimationData& _data, const struct FBFGInteractAnimationData& _oldData);
	struct FBFGInteractAnimationData PeekInteractAnimation();
	struct FBFGInteractAnimationData PopInteractAnimation();

	bool FindWeaponState(TSoftClassPtr<class UClass> _pWeaponType, struct FBFGAnimationVariables_Weapon* _weaponState) const;
	class UBFGAnimation_Events_Npc* GetEvents_Npc() const;
	class UBFGAnimation_Variables_Npc* GetVariables_Npc() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"BFGAnimationInstance_Npc">();
	}
	static class UBFGAnimationInstance_Npc* GetDefaultObj()
	{
		return GetDefaultObjImpl<UBFGAnimationInstance_Npc>();
	}
};
#pragma pack(pop)
static_assert(alignof(UBFGAnimationInstance_Npc) == 0x000010, "Wrong alignment on UBFGAnimationInstance_Npc");
static_assert(sizeof(UBFGAnimationInstance_Npc) == 0x000560, "Wrong size on UBFGAnimationInstance_Npc");
static_assert(offsetof(UBFGAnimationInstance_Npc, M_pInteractAnimationTable) == 0x000400, "Member 'UBFGAnimationInstance_Npc::M_pInteractAnimationTable' has a wrong offset!");
static_assert(offsetof(UBFGAnimationInstance_Npc, M_pInteractAnimation) == 0x000408, "Member 'UBFGAnimationInstance_Npc::M_pInteractAnimation' has a wrong offset!");
static_assert(offsetof(UBFGAnimationInstance_Npc, M_bIsPlayingInteract) == 0x000410, "Member 'UBFGAnimationInstance_Npc::M_bIsPlayingInteract' has a wrong offset!");
static_assert(offsetof(UBFGAnimationInstance_Npc, M_bWasPlayingInteract) == 0x000411, "Member 'UBFGAnimationInstance_Npc::M_bWasPlayingInteract' has a wrong offset!");
static_assert(offsetof(UBFGAnimationInstance_Npc, M_apAnimationSequences) == 0x000418, "Member 'UBFGAnimationInstance_Npc::M_apAnimationSequences' has a wrong offset!");
static_assert(offsetof(UBFGAnimationInstance_Npc, M_lastAnimationData) == 0x000428, "Member 'UBFGAnimationInstance_Npc::M_lastAnimationData' has a wrong offset!");
static_assert(offsetof(UBFGAnimationInstance_Npc, M_onInteractAnimationSequenceInterrupted) == 0x000488, "Member 'UBFGAnimationInstance_Npc::M_onInteractAnimationSequenceInterrupted' has a wrong offset!");
static_assert(offsetof(UBFGAnimationInstance_Npc, M_onInteractAnimationPop) == 0x0004A0, "Member 'UBFGAnimationInstance_Npc::M_onInteractAnimationPop' has a wrong offset!");
static_assert(offsetof(UBFGAnimationInstance_Npc, M_orchestrator) == 0x0004B8, "Member 'UBFGAnimationInstance_Npc::M_orchestrator' has a wrong offset!");
static_assert(offsetof(UBFGAnimationInstance_Npc, M_fBlendingRemainingTime) == 0x0004C8, "Member 'UBFGAnimationInstance_Npc::M_fBlendingRemainingTime' has a wrong offset!");
static_assert(offsetof(UBFGAnimationInstance_Npc, M_vInitialLocation) == 0x0004CC, "Member 'UBFGAnimationInstance_Npc::M_vInitialLocation' has a wrong offset!");
static_assert(offsetof(UBFGAnimationInstance_Npc, M_vInitialRotation) == 0x0004D8, "Member 'UBFGAnimationInstance_Npc::M_vInitialRotation' has a wrong offset!");
static_assert(offsetof(UBFGAnimationInstance_Npc, M_meshRelativeTransform) == 0x0004F0, "Member 'UBFGAnimationInstance_Npc::M_meshRelativeTransform' has a wrong offset!");
static_assert(offsetof(UBFGAnimationInstance_Npc, M_vTargetTransform) == 0x000520, "Member 'UBFGAnimationInstance_Npc::M_vTargetTransform' has a wrong offset!");
static_assert(offsetof(UBFGAnimationInstance_Npc, M_pNPCMovementComponent) == 0x000550, "Member 'UBFGAnimationInstance_Npc::M_pNPCMovementComponent' has a wrong offset!");

// Class BFGCore.BFGWidget_HUD_SavingSpinner
// 0x0008 (0x0300 - 0x02F8)
class UBFGWidget_HUD_SavingSpinner final : public UBFGWidget_HUD
{
public:
	uint8                                         Pad_2F8[0x8];                                      // 0x02F8(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void ShowWidget(bool _bShow);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"BFGWidget_HUD_SavingSpinner">();
	}
	static class UBFGWidget_HUD_SavingSpinner* GetDefaultObj()
	{
		return GetDefaultObjImpl<UBFGWidget_HUD_SavingSpinner>();
	}
};
static_assert(alignof(UBFGWidget_HUD_SavingSpinner) == 0x000008, "Wrong alignment on UBFGWidget_HUD_SavingSpinner");
static_assert(sizeof(UBFGWidget_HUD_SavingSpinner) == 0x000300, "Wrong size on UBFGWidget_HUD_SavingSpinner");

// Class BFGCore.BFGAnimationInstance_Animal
// 0x0000 (0x0560 - 0x0560)
class UBFGAnimationInstance_Animal : public UBFGAnimationInstance_Npc
{
public:
	class UBFGAnimation_Events_Animal* GetEvents_Animal() const;
	class UBFGAnimation_Variables_Animal* GetVariables_Animal() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"BFGAnimationInstance_Animal">();
	}
	static class UBFGAnimationInstance_Animal* GetDefaultObj()
	{
		return GetDefaultObjImpl<UBFGAnimationInstance_Animal>();
	}
};
static_assert(alignof(UBFGAnimationInstance_Animal) == 0x000010, "Wrong alignment on UBFGAnimationInstance_Animal");
static_assert(sizeof(UBFGAnimationInstance_Animal) == 0x000560, "Wrong size on UBFGAnimationInstance_Animal");

// Class BFGCore.BFGDiscordWrapper
// 0x0008 (0x0030 - 0x0028)
class UBFGDiscordWrapper : public UObject
{
public:
	bool                                          M_bIsEnabled;                                      // 0x0028(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_29[0x7];                                       // 0x0029(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void Init();
	void Shutdown();
	void Update(float _fDeltaTime);

	bool GetIsEnabled() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"BFGDiscordWrapper">();
	}
	static class UBFGDiscordWrapper* GetDefaultObj()
	{
		return GetDefaultObjImpl<UBFGDiscordWrapper>();
	}
};
static_assert(alignof(UBFGDiscordWrapper) == 0x000008, "Wrong alignment on UBFGDiscordWrapper");
static_assert(sizeof(UBFGDiscordWrapper) == 0x000030, "Wrong size on UBFGDiscordWrapper");
static_assert(offsetof(UBFGDiscordWrapper, M_bIsEnabled) == 0x000028, "Member 'UBFGDiscordWrapper::M_bIsEnabled' has a wrong offset!");

// Class BFGCore.BFGGameFlowState_GamestartSequence
// 0x0040 (0x00A8 - 0x0068)
class UBFGGameFlowState_GamestartSequence : public UBFGGameFlowState
{
public:
	TSoftClassPtr<class UClass>                   M_pIISStateClass;                                  // 0x0068(0x0028)(Edit, BlueprintVisible, BlueprintReadOnly, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_90[0x8];                                       // 0x0090(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	class UBFGSaveSystem_LoadOptionsAction*       M_pAction;                                         // 0x0098(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_A0[0x8];                                       // 0x00A0(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void OnActionDone(class UBFGSaveSystem* _pSaveSystem, class UBFGSaveSystem_Action* _pAction, EBFGSaveSystem_ActionResult _result);
	void OnIISClosed(EBFGDialogMessage _eMessage);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"BFGGameFlowState_GamestartSequence">();
	}
	static class UBFGGameFlowState_GamestartSequence* GetDefaultObj()
	{
		return GetDefaultObjImpl<UBFGGameFlowState_GamestartSequence>();
	}
};
static_assert(alignof(UBFGGameFlowState_GamestartSequence) == 0x000008, "Wrong alignment on UBFGGameFlowState_GamestartSequence");
static_assert(sizeof(UBFGGameFlowState_GamestartSequence) == 0x0000A8, "Wrong size on UBFGGameFlowState_GamestartSequence");
static_assert(offsetof(UBFGGameFlowState_GamestartSequence, M_pIISStateClass) == 0x000068, "Member 'UBFGGameFlowState_GamestartSequence::M_pIISStateClass' has a wrong offset!");
static_assert(offsetof(UBFGGameFlowState_GamestartSequence, M_pAction) == 0x000098, "Member 'UBFGGameFlowState_GamestartSequence::M_pAction' has a wrong offset!");

// Class BFGCore.BFGAnimationInstance_Boss
// 0x0000 (0x0560 - 0x0560)
class UBFGAnimationInstance_Boss final : public UBFGAnimationInstance_Npc
{
public:
	void G2ABossActionEvasion(EBFGAttackQuadrant _eEvasionQuadrant);
	void G2ABossActionKnockDown(EBFGAttackQuadrant _eHitQuadrant);
	void G2ABossActionNasalProbeShotLeft();
	void G2ABossActionNasalProbeShotRight();
	void G2ABossActionNasalProbeStarted();
	void G2ABossActionRocketLaunched(EBFGRocketSocket _eRocketSocket);
	void G2ABossActionStandUp();
	void G2ABossActionStompLeft();
	void G2ABossActionStompRight();
	void G2ABossCallReinforcementAction();
	void G2ABossEnrageBeforeCharge();
	void G2ABossInterruptedByDamage(EBFGAttackQuadrant _eHitQuadrant);
	void G2ABossLeapAction();
	void G2ABossStompActionStarted(class AActor* _pOwnerActor, class AActor* _pTargetActor);
	void G2APhaseTransitionTriggered(int32 _iCurrentPhaseNumber);

	class UBFGAnimation_Events_Boss* GetEvents_Boss() const;
	class UBFGAnimation_Variables_Boss* GetVariables_Boss() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"BFGAnimationInstance_Boss">();
	}
	static class UBFGAnimationInstance_Boss* GetDefaultObj()
	{
		return GetDefaultObjImpl<UBFGAnimationInstance_Boss>();
	}
};
static_assert(alignof(UBFGAnimationInstance_Boss) == 0x000010, "Wrong alignment on UBFGAnimationInstance_Boss");
static_assert(sizeof(UBFGAnimationInstance_Boss) == 0x000560, "Wrong size on UBFGAnimationInstance_Boss");

// Class BFGCore.BFGDataAsset_QuestRewards
// 0x0040 (0x0070 - 0x0030)
class UBFGDataAsset_QuestRewards final : public UDataAsset
{
public:
	TArray<struct FBFGQuestRewards>               M_aRewardFirstTime;                                // 0x0030(0x0010)(Edit, ZeroConstructor, DisableEditOnInstance, NativeAccessSpecifierPublic)
	TArray<struct FBFGQuestRewards>               M_aRewardRepeat;                                   // 0x0040(0x0010)(Edit, ZeroConstructor, DisableEditOnInstance, NativeAccessSpecifierPublic)
	TArray<struct FBFGQuestRewards>               M_aRewardFirstFullyCompletedTime;                  // 0x0050(0x0010)(Edit, ZeroConstructor, DisableEditOnInstance, NativeAccessSpecifierPublic)
	TArray<struct FBFGQuestRewards>               M_aAdditionalRewards;                              // 0x0060(0x0010)(Edit, ZeroConstructor, DisableEditOnInstance, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"BFGDataAsset_QuestRewards">();
	}
	static class UBFGDataAsset_QuestRewards* GetDefaultObj()
	{
		return GetDefaultObjImpl<UBFGDataAsset_QuestRewards>();
	}
};
static_assert(alignof(UBFGDataAsset_QuestRewards) == 0x000008, "Wrong alignment on UBFGDataAsset_QuestRewards");
static_assert(sizeof(UBFGDataAsset_QuestRewards) == 0x000070, "Wrong size on UBFGDataAsset_QuestRewards");
static_assert(offsetof(UBFGDataAsset_QuestRewards, M_aRewardFirstTime) == 0x000030, "Member 'UBFGDataAsset_QuestRewards::M_aRewardFirstTime' has a wrong offset!");
static_assert(offsetof(UBFGDataAsset_QuestRewards, M_aRewardRepeat) == 0x000040, "Member 'UBFGDataAsset_QuestRewards::M_aRewardRepeat' has a wrong offset!");
static_assert(offsetof(UBFGDataAsset_QuestRewards, M_aRewardFirstFullyCompletedTime) == 0x000050, "Member 'UBFGDataAsset_QuestRewards::M_aRewardFirstFullyCompletedTime' has a wrong offset!");
static_assert(offsetof(UBFGDataAsset_QuestRewards, M_aAdditionalRewards) == 0x000060, "Member 'UBFGDataAsset_QuestRewards::M_aAdditionalRewards' has a wrong offset!");

// Class BFGCore.BFGWidget_IIS
// 0x0018 (0x0440 - 0x0428)
class UBFGWidget_IIS final : public UBFGWidget_GenericDialog
{
public:
	uint8                                         Pad_428[0x4];                                      // 0x0428(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         M_fWaitTimer;                                      // 0x042C(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_430[0x8];                                      // 0x0430(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	class UBFGUserSignInManager*                  M_pManager;                                        // 0x0438(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)

public:
	void HidePrompt();
	void OnApplicationPostInputKeyDownEvent(const struct FKeyEvent& _keyEvent);
	void OnBusyWithSigninStateChange(bool _bBusy);
	void OnMousePressed();
	void ShowSpinner();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"BFGWidget_IIS">();
	}
	static class UBFGWidget_IIS* GetDefaultObj()
	{
		return GetDefaultObjImpl<UBFGWidget_IIS>();
	}
};
static_assert(alignof(UBFGWidget_IIS) == 0x000008, "Wrong alignment on UBFGWidget_IIS");
static_assert(sizeof(UBFGWidget_IIS) == 0x000440, "Wrong size on UBFGWidget_IIS");
static_assert(offsetof(UBFGWidget_IIS, M_fWaitTimer) == 0x00042C, "Member 'UBFGWidget_IIS::M_fWaitTimer' has a wrong offset!");
static_assert(offsetof(UBFGWidget_IIS, M_pManager) == 0x000438, "Member 'UBFGWidget_IIS::M_pManager' has a wrong offset!");

// Class BFGCore.BFGAnimationInstance_Crypto
// 0x0008 (0x0400 - 0x03F8)
class UBFGAnimationInstance_Crypto : public UBFGAnimationInstance
{
public:
	uint8                                         Pad_3F8[0x8];                                      // 0x03F8(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	class UBFGAnimation_Events_Crypto* GetEvents_Crypto() const;
	class UBFGAnimation_Variables_Crypto* GetVariables_Crypto() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"BFGAnimationInstance_Crypto">();
	}
	static class UBFGAnimationInstance_Crypto* GetDefaultObj()
	{
		return GetDefaultObjImpl<UBFGAnimationInstance_Crypto>();
	}
};
static_assert(alignof(UBFGAnimationInstance_Crypto) == 0x000008, "Wrong alignment on UBFGAnimationInstance_Crypto");
static_assert(sizeof(UBFGAnimationInstance_Crypto) == 0x000400, "Wrong size on UBFGAnimationInstance_Crypto");

// Class BFGCore.BFGAnimationInstance_Human
// 0x0000 (0x0560 - 0x0560)
#pragma pack(push, 0x1)
class alignas(0x10) UBFGAnimationInstance_Human : public UBFGAnimationInstance_Npc
{
public:
	class UBFGAnimation_Events_Human* GetEvents_Human() const;
	class UBFGAnimation_Variables_Human* GetVariables_Human() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"BFGAnimationInstance_Human">();
	}
	static class UBFGAnimationInstance_Human* GetDefaultObj()
	{
		return GetDefaultObjImpl<UBFGAnimationInstance_Human>();
	}
};
#pragma pack(pop)
static_assert(alignof(UBFGAnimationInstance_Human) == 0x000010, "Wrong alignment on UBFGAnimationInstance_Human");
static_assert(sizeof(UBFGAnimationInstance_Human) == 0x000560, "Wrong size on UBFGAnimationInstance_Human");

// Class BFGCore.BFGNPCCharacter_Cluckthulhu
// 0x0000 (0x0B90 - 0x0B90)
class ABFGNPCCharacter_Cluckthulhu final : public ABFGNPCCharacterGameplay
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"BFGNPCCharacter_Cluckthulhu">();
	}
	static class ABFGNPCCharacter_Cluckthulhu* GetDefaultObj()
	{
		return GetDefaultObjImpl<ABFGNPCCharacter_Cluckthulhu>();
	}
};
static_assert(alignof(ABFGNPCCharacter_Cluckthulhu) == 0x000010, "Wrong alignment on ABFGNPCCharacter_Cluckthulhu");
static_assert(sizeof(ABFGNPCCharacter_Cluckthulhu) == 0x000B90, "Wrong size on ABFGNPCCharacter_Cluckthulhu");

// Class BFGCore.BFGWeapon_EnemyBallistic
// 0x0000 (0x0850 - 0x0850)
class ABFGWeapon_EnemyBallistic : public ABFGWeapon_Enemy
{
public:
	float ComputeBallisticRange() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"BFGWeapon_EnemyBallistic">();
	}
	static class ABFGWeapon_EnemyBallistic* GetDefaultObj()
	{
		return GetDefaultObjImpl<ABFGWeapon_EnemyBallistic>();
	}
};
static_assert(alignof(ABFGWeapon_EnemyBallistic) == 0x000008, "Wrong alignment on ABFGWeapon_EnemyBallistic");
static_assert(sizeof(ABFGWeapon_EnemyBallistic) == 0x000850, "Wrong size on ABFGWeapon_EnemyBallistic");

// Class BFGCore.BFGDataHub
// 0x00A8 (0x00D8 - 0x0030)
class UBFGDataHub final : public UBFGGameSystem
{
public:
	TMap<class FName, class UBFGDataSubscriberCollection*> M_aDataSubscribers;                                // 0x0030(0x0050)(ZeroConstructor, NativeAccessSpecifierPrivate)
	TMap<class FName, TScriptInterface<class IBFGDataProvider>> M_aDataProviders;                                  // 0x0080(0x0050)(ZeroConstructor, UObjectWrapper, NativeAccessSpecifierPrivate)
	class ABFGGameState*                          M_pGameState;                                      // 0x00D0(0x0008)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)

public:
	void OnDataChanged(class FName _tag, TScriptInterface<class IBFGDataProvider> _pSourceProvider);
	void RegisterDataProvider(class FName _name, TScriptInterface<class IBFGDataProvider> _pProvider);
	void RegisterDataSubscriber(class FName _name, TScriptInterface<class IBFGDataSubscriber> _pSubscriber);
	void UnregisterDataProvider(class FName _name, TScriptInterface<class IBFGDataProvider> _pProvider);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"BFGDataHub">();
	}
	static class UBFGDataHub* GetDefaultObj()
	{
		return GetDefaultObjImpl<UBFGDataHub>();
	}
};
static_assert(alignof(UBFGDataHub) == 0x000008, "Wrong alignment on UBFGDataHub");
static_assert(sizeof(UBFGDataHub) == 0x0000D8, "Wrong size on UBFGDataHub");
static_assert(offsetof(UBFGDataHub, M_aDataSubscribers) == 0x000030, "Member 'UBFGDataHub::M_aDataSubscribers' has a wrong offset!");
static_assert(offsetof(UBFGDataHub, M_aDataProviders) == 0x000080, "Member 'UBFGDataHub::M_aDataProviders' has a wrong offset!");
static_assert(offsetof(UBFGDataHub, M_pGameState) == 0x0000D0, "Member 'UBFGDataHub::M_pGameState' has a wrong offset!");

// Class BFGCore.BFGAnimationInstance_Pox
// 0x0008 (0x0400 - 0x03F8)
class UBFGAnimationInstance_Pox final : public UBFGAnimationInstance
{
public:
	uint8                                         Pad_3F8[0x8];                                      // 0x03F8(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void G2APlayAnimationSequenceByName(class FName _oName);
	void G2AStopCurrentAnimationSequence();

	class UBFGAnimation_Events_Pox* GetEvents_Pox() const;
	class UBFGAnimation_Variables_Pox* GetVariables_Pox() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"BFGAnimationInstance_Pox">();
	}
	static class UBFGAnimationInstance_Pox* GetDefaultObj()
	{
		return GetDefaultObjImpl<UBFGAnimationInstance_Pox>();
	}
};
static_assert(alignof(UBFGAnimationInstance_Pox) == 0x000008, "Wrong alignment on UBFGAnimationInstance_Pox");
static_assert(sizeof(UBFGAnimationInstance_Pox) == 0x000400, "Wrong size on UBFGAnimationInstance_Pox");

// Class BFGCore.BFGAnimationInteractPlayer
// 0x00B0 (0x00D8 - 0x0028)
class UBFGAnimationInteractPlayer final : public UObject
{
public:
	uint8                                         Pad_28[0x8];                                       // 0x0028(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<struct FBFGInteractAnimationSequence>  M_apAnimationSequences;                            // 0x0030(0x0010)(ZeroConstructor, Transient, Protected, NativeAccessSpecifierProtected)
	struct FBFGInteractAnimationData              M_lastAnimationData;                               // 0x0040(0x0060)(Transient, NoDestructor, Protected, NativeAccessSpecifierProtected)
	bool                                          M_bIsPlayingInteract;                              // 0x00A0(0x0001)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          M_bOrchestratorInterruptAnimRequested;             // 0x00A1(0x0001)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_A2[0x6];                                       // 0x00A2(0x0006)(Fixing Size After Last Property [ Dumper-7 ])
	class USkeletalMeshComponent*                 M_pAnimatedComponent;                              // 0x00A8(0x0008)(ExportObject, ZeroConstructor, Transient, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	UMulticastDelegateProperty_                   M_onInteractAnimationPop;                          // 0x00B0(0x0018)(ZeroConstructor, InstancedReference, BlueprintAssignable, Protected, BlueprintCallable, NativeAccessSpecifierProtected)
	TScriptInterface<class IBFGInteractAnimationPlayerInterface> M_orchestrator;                                    // 0x00C8(0x0010)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, UObjectWrapper, NativeAccessSpecifierProtected)

public:
	void OnOrchestratorInteractAnimationPop(TScriptInterface<class IBFGInteractAnimationPlayerInterface> _pOrchestrator, const struct FBFGInteractAnimationData& _data, const struct FBFGInteractAnimationData& _oldData);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"BFGAnimationInteractPlayer">();
	}
	static class UBFGAnimationInteractPlayer* GetDefaultObj()
	{
		return GetDefaultObjImpl<UBFGAnimationInteractPlayer>();
	}
};
static_assert(alignof(UBFGAnimationInteractPlayer) == 0x000008, "Wrong alignment on UBFGAnimationInteractPlayer");
static_assert(sizeof(UBFGAnimationInteractPlayer) == 0x0000D8, "Wrong size on UBFGAnimationInteractPlayer");
static_assert(offsetof(UBFGAnimationInteractPlayer, M_apAnimationSequences) == 0x000030, "Member 'UBFGAnimationInteractPlayer::M_apAnimationSequences' has a wrong offset!");
static_assert(offsetof(UBFGAnimationInteractPlayer, M_lastAnimationData) == 0x000040, "Member 'UBFGAnimationInteractPlayer::M_lastAnimationData' has a wrong offset!");
static_assert(offsetof(UBFGAnimationInteractPlayer, M_bIsPlayingInteract) == 0x0000A0, "Member 'UBFGAnimationInteractPlayer::M_bIsPlayingInteract' has a wrong offset!");
static_assert(offsetof(UBFGAnimationInteractPlayer, M_bOrchestratorInterruptAnimRequested) == 0x0000A1, "Member 'UBFGAnimationInteractPlayer::M_bOrchestratorInterruptAnimRequested' has a wrong offset!");
static_assert(offsetof(UBFGAnimationInteractPlayer, M_pAnimatedComponent) == 0x0000A8, "Member 'UBFGAnimationInteractPlayer::M_pAnimatedComponent' has a wrong offset!");
static_assert(offsetof(UBFGAnimationInteractPlayer, M_onInteractAnimationPop) == 0x0000B0, "Member 'UBFGAnimationInteractPlayer::M_onInteractAnimationPop' has a wrong offset!");
static_assert(offsetof(UBFGAnimationInteractPlayer, M_orchestrator) == 0x0000C8, "Member 'UBFGAnimationInteractPlayer::M_orchestrator' has a wrong offset!");

// Class BFGCore.BFGVoiceoverSystem
// 0x0058 (0x0088 - 0x0030)
class UBFGVoiceoverSystem final : public UBFGGameSystem
{
public:
	uint8                                         Pad_30[0x8];                                       // 0x0030(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	bool                                          M_bDebugEnabled;                                   // 0x0038(0x0001)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_39[0x7];                                       // 0x0039(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	class ABFGGameState*                          M_pGameState;                                      // 0x0040(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UBFGVoiceoverItemResolver*              M_pItemResolver;                                   // 0x0048(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UBFGVoiceoverStatistics*                M_pStatistics;                                     // 0x0050(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UBFGVoiceoverRouter*                    M_pRouter;                                         // 0x0058(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UBFGVoiceoverSettings*                  M_pSettings;                                       // 0x0060(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class USoundBase*                             M_pFallbackSound;                                  // 0x0068(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UObjectLibrary*                         M_pGroupLibrary;                                   // 0x0070(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UObjectLibrary*                         M_pQueueLibrary;                                   // 0x0078(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_80[0x8];                                       // 0x0080(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	class UBFGVoiceoverItemResolver* GetItemResolver();
	class UBFGVoiceoverSettings* GetSettings();
	class UBFGVoiceoverStatistics* GetStatistics();
	void ToggleVoiceoverSkipThroughMode();
	void ToggleVoiceoverSystemDebug();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"BFGVoiceoverSystem">();
	}
	static class UBFGVoiceoverSystem* GetDefaultObj()
	{
		return GetDefaultObjImpl<UBFGVoiceoverSystem>();
	}
};
static_assert(alignof(UBFGVoiceoverSystem) == 0x000008, "Wrong alignment on UBFGVoiceoverSystem");
static_assert(sizeof(UBFGVoiceoverSystem) == 0x000088, "Wrong size on UBFGVoiceoverSystem");
static_assert(offsetof(UBFGVoiceoverSystem, M_bDebugEnabled) == 0x000038, "Member 'UBFGVoiceoverSystem::M_bDebugEnabled' has a wrong offset!");
static_assert(offsetof(UBFGVoiceoverSystem, M_pGameState) == 0x000040, "Member 'UBFGVoiceoverSystem::M_pGameState' has a wrong offset!");
static_assert(offsetof(UBFGVoiceoverSystem, M_pItemResolver) == 0x000048, "Member 'UBFGVoiceoverSystem::M_pItemResolver' has a wrong offset!");
static_assert(offsetof(UBFGVoiceoverSystem, M_pStatistics) == 0x000050, "Member 'UBFGVoiceoverSystem::M_pStatistics' has a wrong offset!");
static_assert(offsetof(UBFGVoiceoverSystem, M_pRouter) == 0x000058, "Member 'UBFGVoiceoverSystem::M_pRouter' has a wrong offset!");
static_assert(offsetof(UBFGVoiceoverSystem, M_pSettings) == 0x000060, "Member 'UBFGVoiceoverSystem::M_pSettings' has a wrong offset!");
static_assert(offsetof(UBFGVoiceoverSystem, M_pFallbackSound) == 0x000068, "Member 'UBFGVoiceoverSystem::M_pFallbackSound' has a wrong offset!");
static_assert(offsetof(UBFGVoiceoverSystem, M_pGroupLibrary) == 0x000070, "Member 'UBFGVoiceoverSystem::M_pGroupLibrary' has a wrong offset!");
static_assert(offsetof(UBFGVoiceoverSystem, M_pQueueLibrary) == 0x000078, "Member 'UBFGVoiceoverSystem::M_pQueueLibrary' has a wrong offset!");

// Class BFGCore.BFGDataAsset_StaticMeshDestruction
// 0x0048 (0x0078 - 0x0030)
class UBFGDataAsset_StaticMeshDestruction final : public UDataAsset
{
public:
	TSoftObjectPtr<class UBlastMesh>              M_pDestructibleMesh;                               // 0x0030(0x0028)(Edit, BlueprintVisible, BlueprintReadOnly, DisableEditOnInstance, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UBlastMesh*                             M_pDestructibleMesh_RuntimeCached;                 // 0x0058(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UGeometryCache*                         M_pGeometryCache;                                  // 0x0060(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UParticleSystem*                        M_pPFX;                                            // 0x0068(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EBFGBuilding_DestructionPhase                 M_ePhase;                                          // 0x0070(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EBFGBuilding_DestructionBehavior              M_eDestructionBehavior;                            // 0x0071(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_72[0x6];                                       // 0x0072(0x0006)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	class UBlastMesh* GetDestructionMesh();

	bool IsValid() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"BFGDataAsset_StaticMeshDestruction">();
	}
	static class UBFGDataAsset_StaticMeshDestruction* GetDefaultObj()
	{
		return GetDefaultObjImpl<UBFGDataAsset_StaticMeshDestruction>();
	}
};
static_assert(alignof(UBFGDataAsset_StaticMeshDestruction) == 0x000008, "Wrong alignment on UBFGDataAsset_StaticMeshDestruction");
static_assert(sizeof(UBFGDataAsset_StaticMeshDestruction) == 0x000078, "Wrong size on UBFGDataAsset_StaticMeshDestruction");
static_assert(offsetof(UBFGDataAsset_StaticMeshDestruction, M_pDestructibleMesh) == 0x000030, "Member 'UBFGDataAsset_StaticMeshDestruction::M_pDestructibleMesh' has a wrong offset!");
static_assert(offsetof(UBFGDataAsset_StaticMeshDestruction, M_pDestructibleMesh_RuntimeCached) == 0x000058, "Member 'UBFGDataAsset_StaticMeshDestruction::M_pDestructibleMesh_RuntimeCached' has a wrong offset!");
static_assert(offsetof(UBFGDataAsset_StaticMeshDestruction, M_pGeometryCache) == 0x000060, "Member 'UBFGDataAsset_StaticMeshDestruction::M_pGeometryCache' has a wrong offset!");
static_assert(offsetof(UBFGDataAsset_StaticMeshDestruction, M_pPFX) == 0x000068, "Member 'UBFGDataAsset_StaticMeshDestruction::M_pPFX' has a wrong offset!");
static_assert(offsetof(UBFGDataAsset_StaticMeshDestruction, M_ePhase) == 0x000070, "Member 'UBFGDataAsset_StaticMeshDestruction::M_ePhase' has a wrong offset!");
static_assert(offsetof(UBFGDataAsset_StaticMeshDestruction, M_eDestructionBehavior) == 0x000071, "Member 'UBFGDataAsset_StaticMeshDestruction::M_eDestructionBehavior' has a wrong offset!");

// Class BFGCore.BFGAnimationInteractPlayerStaticMesh
// 0x0038 (0x0060 - 0x0028)
class UBFGAnimationInteractPlayerStaticMesh final : public UObject
{
public:
	uint8                                         Pad_28[0x8];                                       // 0x0028(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	bool                                          M_bIsPlayingInteract;                              // 0x0030(0x0001)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_31[0x7];                                       // 0x0031(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	UMulticastDelegateProperty_                   M_onInteractAnimationPop;                          // 0x0038(0x0018)(ZeroConstructor, InstancedReference, BlueprintAssignable, Protected, BlueprintCallable, NativeAccessSpecifierProtected)
	TScriptInterface<class IBFGInteractAnimationPlayerInterface> M_orchestrator;                                    // 0x0050(0x0010)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, UObjectWrapper, NativeAccessSpecifierProtected)

public:
	void OnOrchestratorInteractAnimationPop(TScriptInterface<class IBFGInteractAnimationPlayerInterface> _pOrchestrator, const struct FBFGInteractAnimationData& _data, const struct FBFGInteractAnimationData& _oldData);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"BFGAnimationInteractPlayerStaticMesh">();
	}
	static class UBFGAnimationInteractPlayerStaticMesh* GetDefaultObj()
	{
		return GetDefaultObjImpl<UBFGAnimationInteractPlayerStaticMesh>();
	}
};
static_assert(alignof(UBFGAnimationInteractPlayerStaticMesh) == 0x000008, "Wrong alignment on UBFGAnimationInteractPlayerStaticMesh");
static_assert(sizeof(UBFGAnimationInteractPlayerStaticMesh) == 0x000060, "Wrong size on UBFGAnimationInteractPlayerStaticMesh");
static_assert(offsetof(UBFGAnimationInteractPlayerStaticMesh, M_bIsPlayingInteract) == 0x000030, "Member 'UBFGAnimationInteractPlayerStaticMesh::M_bIsPlayingInteract' has a wrong offset!");
static_assert(offsetof(UBFGAnimationInteractPlayerStaticMesh, M_onInteractAnimationPop) == 0x000038, "Member 'UBFGAnimationInteractPlayerStaticMesh::M_onInteractAnimationPop' has a wrong offset!");
static_assert(offsetof(UBFGAnimationInteractPlayerStaticMesh, M_orchestrator) == 0x000050, "Member 'UBFGAnimationInteractPlayerStaticMesh::M_orchestrator' has a wrong offset!");

// Class BFGCore.BFGObjectiveMarkerSystem
// 0x01A0 (0x01D0 - 0x0030)
class UBFGObjectiveMarkerSystem final : public UBFGGameSystem
{
public:
	uint8                                         Pad_30[0x8];                                       // 0x0030(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<class UBFGActorComponent_Objective*>   M_apPotentialMarkers;                              // 0x0038(0x0010)(ExportObject, ZeroConstructor, Transient, ContainsInstancedReference, NativeAccessSpecifierPrivate)
	uint8                                         Pad_48[0x50];                                      // 0x0048(0x0050)(Fixing Size After Last Property [ Dumper-7 ])
	class ABFGGameState*                          M_pGameState;                                      // 0x0098(0x0008)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	TMap<struct FGuid, class UBFGObjectiveMarkerGroup*> M_aGroups;                                         // 0x00A0(0x0050)(ZeroConstructor, Transient, NativeAccessSpecifierPrivate)
	TMap<class AActor*, int32>                    M_aObjectives;                                     // 0x00F0(0x0050)(ZeroConstructor, Transient, NativeAccessSpecifierPrivate)
	TArray<class UBFGObjectiveEntitlement*>       M_apEntitlements;                                  // 0x0140(0x0010)(ExportObject, ZeroConstructor, Transient, ContainsInstancedReference, NativeAccessSpecifierPrivate)
	class UObjectLibrary*                         M_pPreloadLibrary;                                 // 0x0150(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	struct FTickObjectiveMarkerFunction           M_TickFunction;                                    // 0x0158(0x0078)(ContainsInstancedReference, NativeAccessSpecifierPrivate)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"BFGObjectiveMarkerSystem">();
	}
	static class UBFGObjectiveMarkerSystem* GetDefaultObj()
	{
		return GetDefaultObjImpl<UBFGObjectiveMarkerSystem>();
	}
};
static_assert(alignof(UBFGObjectiveMarkerSystem) == 0x000008, "Wrong alignment on UBFGObjectiveMarkerSystem");
static_assert(sizeof(UBFGObjectiveMarkerSystem) == 0x0001D0, "Wrong size on UBFGObjectiveMarkerSystem");
static_assert(offsetof(UBFGObjectiveMarkerSystem, M_apPotentialMarkers) == 0x000038, "Member 'UBFGObjectiveMarkerSystem::M_apPotentialMarkers' has a wrong offset!");
static_assert(offsetof(UBFGObjectiveMarkerSystem, M_pGameState) == 0x000098, "Member 'UBFGObjectiveMarkerSystem::M_pGameState' has a wrong offset!");
static_assert(offsetof(UBFGObjectiveMarkerSystem, M_aGroups) == 0x0000A0, "Member 'UBFGObjectiveMarkerSystem::M_aGroups' has a wrong offset!");
static_assert(offsetof(UBFGObjectiveMarkerSystem, M_aObjectives) == 0x0000F0, "Member 'UBFGObjectiveMarkerSystem::M_aObjectives' has a wrong offset!");
static_assert(offsetof(UBFGObjectiveMarkerSystem, M_apEntitlements) == 0x000140, "Member 'UBFGObjectiveMarkerSystem::M_apEntitlements' has a wrong offset!");
static_assert(offsetof(UBFGObjectiveMarkerSystem, M_pPreloadLibrary) == 0x000150, "Member 'UBFGObjectiveMarkerSystem::M_pPreloadLibrary' has a wrong offset!");
static_assert(offsetof(UBFGObjectiveMarkerSystem, M_TickFunction) == 0x000158, "Member 'UBFGObjectiveMarkerSystem::M_TickFunction' has a wrong offset!");

// Class BFGCore.BFGAnimationSharingSetup
// 0x0000 (0x0048 - 0x0048)
class UBFGAnimationSharingSetup : public UAnimationSharingSetup
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"BFGAnimationSharingSetup">();
	}
	static class UBFGAnimationSharingSetup* GetDefaultObj()
	{
		return GetDefaultObjImpl<UBFGAnimationSharingSetup>();
	}
};
static_assert(alignof(UBFGAnimationSharingSetup) == 0x000008, "Wrong alignment on UBFGAnimationSharingSetup");
static_assert(sizeof(UBFGAnimationSharingSetup) == 0x000048, "Wrong size on UBFGAnimationSharingSetup");

// Class BFGCore.BFGWeaponSlot
// 0x0000 (0x0240 - 0x0240)
class UBFGWeaponSlot : public UUserWidget
{
public:
	void Clear();
	void SetBrush(const struct FSlateBrush& _oBrush);
	void SetEquipped(bool _bEquipped);
	void SetInputActionName(class FName _strInputActionName);
	void SetInputHintEnabled(bool _bEnabled);
	void SetJammed(bool _bJammed);
	void SetUnlocked(bool _bLocked);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"BFGWeaponSlot">();
	}
	static class UBFGWeaponSlot* GetDefaultObj()
	{
		return GetDefaultObjImpl<UBFGWeaponSlot>();
	}
};
static_assert(alignof(UBFGWeaponSlot) == 0x000008, "Wrong alignment on UBFGWeaponSlot");
static_assert(sizeof(UBFGWeaponSlot) == 0x000240, "Wrong size on UBFGWeaponSlot");

// Class BFGCore.BFGGameFlowState_GameplayEndSequence
// 0x0230 (0x0298 - 0x0068)
class UBFGGameFlowState_GameplayEndSequence final : public UBFGGameFlowState
{
public:
	struct FBFGGameplayEndSequence_Data           M_Data;                                            // 0x0068(0x0190)(Protected, NativeAccessSpecifierProtected)
	uint8                                         Pad_1F8[0x8];                                      // 0x01F8(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	class UBFGTransitionManager*                  M_pTransitionManager;                              // 0x0200(0x0008)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UBFGGameplayEndSystem*                  M_pGameEndSystem;                                  // 0x0208(0x0008)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UBFGGameplayEndSession*                 M_pSession;                                        // 0x0210(0x0008)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UBFGGameplayEndEffects*                 M_pEndEffects;                                     // 0x0218(0x0008)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UBFGDataAsset_NewspaperInfo*            M_pNewspaper;                                      // 0x0220(0x0008)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TSoftObjectPtr<class UBFGDataAsset_NewspaperInfo> M_softNewspaper;                                   // 0x0228(0x0028)(Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UObject*                                M_pLastLoaded;                                     // 0x0250(0x0008)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_258[0x8];                                      // 0x0258(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	class UBFGQuest*                              M_pQuestStartActionPayload;                        // 0x0260(0x0008)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TSubclassOf<class UBFGNarrativeSequence>      M_pClassNarrativeSequence;                         // 0x0268(0x0008)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UBFGNarrativeSequence*                  M_pNarrativeSequence;                              // 0x0270(0x0008)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_278[0x8];                                      // 0x0278(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<class UBFGQuest*>                      M_apQuestStreaming;                                // 0x0280(0x0010)(ZeroConstructor, Transient, Protected, NativeAccessSpecifierProtected)
	uint8                                         Pad_290[0x8];                                      // 0x0290(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static void GameplayEndFadeOut(class UGameInstance* _pGameInstance);
	static void GameplayEndStartNewEnding(class UGameInstance* _pGameInstance);

	void OnEndEffectsRemoved(class UBFGGameplayEndSession* _pSession, class UBFGGameplayEndEffects* _pEndEffects);
	void OnNarrativeSequenceEnds(class UBFGNarrativeSequence* _pNarrativeSequence);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"BFGGameFlowState_GameplayEndSequence">();
	}
	static class UBFGGameFlowState_GameplayEndSequence* GetDefaultObj()
	{
		return GetDefaultObjImpl<UBFGGameFlowState_GameplayEndSequence>();
	}
};
static_assert(alignof(UBFGGameFlowState_GameplayEndSequence) == 0x000008, "Wrong alignment on UBFGGameFlowState_GameplayEndSequence");
static_assert(sizeof(UBFGGameFlowState_GameplayEndSequence) == 0x000298, "Wrong size on UBFGGameFlowState_GameplayEndSequence");
static_assert(offsetof(UBFGGameFlowState_GameplayEndSequence, M_Data) == 0x000068, "Member 'UBFGGameFlowState_GameplayEndSequence::M_Data' has a wrong offset!");
static_assert(offsetof(UBFGGameFlowState_GameplayEndSequence, M_pTransitionManager) == 0x000200, "Member 'UBFGGameFlowState_GameplayEndSequence::M_pTransitionManager' has a wrong offset!");
static_assert(offsetof(UBFGGameFlowState_GameplayEndSequence, M_pGameEndSystem) == 0x000208, "Member 'UBFGGameFlowState_GameplayEndSequence::M_pGameEndSystem' has a wrong offset!");
static_assert(offsetof(UBFGGameFlowState_GameplayEndSequence, M_pSession) == 0x000210, "Member 'UBFGGameFlowState_GameplayEndSequence::M_pSession' has a wrong offset!");
static_assert(offsetof(UBFGGameFlowState_GameplayEndSequence, M_pEndEffects) == 0x000218, "Member 'UBFGGameFlowState_GameplayEndSequence::M_pEndEffects' has a wrong offset!");
static_assert(offsetof(UBFGGameFlowState_GameplayEndSequence, M_pNewspaper) == 0x000220, "Member 'UBFGGameFlowState_GameplayEndSequence::M_pNewspaper' has a wrong offset!");
static_assert(offsetof(UBFGGameFlowState_GameplayEndSequence, M_softNewspaper) == 0x000228, "Member 'UBFGGameFlowState_GameplayEndSequence::M_softNewspaper' has a wrong offset!");
static_assert(offsetof(UBFGGameFlowState_GameplayEndSequence, M_pLastLoaded) == 0x000250, "Member 'UBFGGameFlowState_GameplayEndSequence::M_pLastLoaded' has a wrong offset!");
static_assert(offsetof(UBFGGameFlowState_GameplayEndSequence, M_pQuestStartActionPayload) == 0x000260, "Member 'UBFGGameFlowState_GameplayEndSequence::M_pQuestStartActionPayload' has a wrong offset!");
static_assert(offsetof(UBFGGameFlowState_GameplayEndSequence, M_pClassNarrativeSequence) == 0x000268, "Member 'UBFGGameFlowState_GameplayEndSequence::M_pClassNarrativeSequence' has a wrong offset!");
static_assert(offsetof(UBFGGameFlowState_GameplayEndSequence, M_pNarrativeSequence) == 0x000270, "Member 'UBFGGameFlowState_GameplayEndSequence::M_pNarrativeSequence' has a wrong offset!");
static_assert(offsetof(UBFGGameFlowState_GameplayEndSequence, M_apQuestStreaming) == 0x000280, "Member 'UBFGGameFlowState_GameplayEndSequence::M_apQuestStreaming' has a wrong offset!");

// Class BFGCore.BFGAnimSharingStateProcessor
// 0x0000 (0x0050 - 0x0050)
class UBFGAnimSharingStateProcessor : public UAnimationSharingStateProcessor
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"BFGAnimSharingStateProcessor">();
	}
	static class UBFGAnimSharingStateProcessor* GetDefaultObj()
	{
		return GetDefaultObjImpl<UBFGAnimSharingStateProcessor>();
	}
};
static_assert(alignof(UBFGAnimSharingStateProcessor) == 0x000008, "Wrong alignment on UBFGAnimSharingStateProcessor");
static_assert(sizeof(UBFGAnimSharingStateProcessor) == 0x000050, "Wrong size on UBFGAnimSharingStateProcessor");

// Class BFGCore.BFGDataAsset_JetpackParams
// 0x0110 (0x0140 - 0x0030)
class UBFGDataAsset_JetpackParams final : public UDataAsset
{
public:
	float                                         M_fWaitForJumpTime;                                // 0x0030(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         M_fWaitForJumpTimeInHolobob;                       // 0x0034(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FGameplayTag                           M_oJetpackUnlockTag;                               // 0x0038(0x0008)(Edit, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         M_fImpulseFriction;                                // 0x0040(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FBFGPlayerCharacterMovementSettings    M_oJetpackMovementSettings;                        // 0x0044(0x001C)(Edit, NoDestructor, NativeAccessSpecifierPublic)
	float                                         M_fTakeOffUpAcceleration;                          // 0x0060(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         M_fTakeOffMaxUpSpeed;                              // 0x0064(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         M_fTakeOffForwardAcceleration;                     // 0x0068(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         M_fTakeOffMaxForwardSpeed;                         // 0x006C(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         M_fTakeOffTime;                                    // 0x0070(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         M_fTakeOffFriction;                                // 0x0074(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         M_fCruiseUpAcceleration;                           // 0x0078(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         M_fCruiseMaxUpSpeed;                               // 0x007C(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         M_fCruiseForwardAcceleration;                      // 0x0080(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         M_fCruiseMaxForwardSpeed;                          // 0x0084(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         M_fCruiseFriction;                                 // 0x0088(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         M_fCruiseUpFadeOutSpeed;                           // 0x008C(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         M_fCruiseCutOffHeight;                             // 0x0090(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         M_fGlideMaxDownSpeed;                              // 0x0094(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         M_fGlideForwardAcceleration;                       // 0x0098(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         M_fGlideMaxForwardSpeed;                           // 0x009C(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         M_fGlideCutOffHeight;                              // 0x00A0(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         M_fGlideFriction;                                  // 0x00A4(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         M_fGlideUpFadeOutSpeed;                            // 0x00A8(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         M_fHoverForwardAcceleration;                       // 0x00AC(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         M_fHoverMaxForwardSpeed;                           // 0x00B0(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         M_fHoverFriction;                                  // 0x00B4(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         M_fHoverUpFadeOutSpeed;                            // 0x00B8(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         M_fSkateForwardAcceleration;                       // 0x00BC(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         M_fSkateStartForwardSpeed;                         // 0x00C0(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         M_fSkateMaxForwardSpeed;                           // 0x00C4(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         M_fSkateMaxSpeedTime;                              // 0x00C8(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         M_fSkateFriction;                                  // 0x00CC(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         M_fSkateBrakeFriction;                             // 0x00D0(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         M_fSkateUpFadeOutSpeed;                            // 0x00D4(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         M_fSkateDeployDelay;                               // 0x00D8(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         M_fSkateMaxDownSpeed;                              // 0x00DC(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         M_fSkateHangTime;                                  // 0x00E0(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         M_fSkateHeight;                                    // 0x00E4(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FBFGPlayerCharacterMovementSettings    M_oSkateMovementSettings;                          // 0x00E8(0x001C)(Edit, NoDestructor, NativeAccessSpecifierPublic)
	uint8                                         Pad_104[0x4];                                      // 0x0104(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	struct FGameplayTagContainer                  M_oSkateGameplayEffectTags;                        // 0x0108(0x0020)(Edit, BlueprintVisible, NativeAccessSpecifierPublic)
	float                                         M_fMaxFuel;                                        // 0x0128(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         M_fFuelConsumption;                                // 0x012C(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         M_fHoverFuelConsumption;                           // 0x0130(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         M_fFuelRegenSpeed;                                 // 0x0134(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         M_fFuelRegenDelay;                                 // 0x0138(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_13C[0x4];                                      // 0x013C(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"BFGDataAsset_JetpackParams">();
	}
	static class UBFGDataAsset_JetpackParams* GetDefaultObj()
	{
		return GetDefaultObjImpl<UBFGDataAsset_JetpackParams>();
	}
};
static_assert(alignof(UBFGDataAsset_JetpackParams) == 0x000008, "Wrong alignment on UBFGDataAsset_JetpackParams");
static_assert(sizeof(UBFGDataAsset_JetpackParams) == 0x000140, "Wrong size on UBFGDataAsset_JetpackParams");
static_assert(offsetof(UBFGDataAsset_JetpackParams, M_fWaitForJumpTime) == 0x000030, "Member 'UBFGDataAsset_JetpackParams::M_fWaitForJumpTime' has a wrong offset!");
static_assert(offsetof(UBFGDataAsset_JetpackParams, M_fWaitForJumpTimeInHolobob) == 0x000034, "Member 'UBFGDataAsset_JetpackParams::M_fWaitForJumpTimeInHolobob' has a wrong offset!");
static_assert(offsetof(UBFGDataAsset_JetpackParams, M_oJetpackUnlockTag) == 0x000038, "Member 'UBFGDataAsset_JetpackParams::M_oJetpackUnlockTag' has a wrong offset!");
static_assert(offsetof(UBFGDataAsset_JetpackParams, M_fImpulseFriction) == 0x000040, "Member 'UBFGDataAsset_JetpackParams::M_fImpulseFriction' has a wrong offset!");
static_assert(offsetof(UBFGDataAsset_JetpackParams, M_oJetpackMovementSettings) == 0x000044, "Member 'UBFGDataAsset_JetpackParams::M_oJetpackMovementSettings' has a wrong offset!");
static_assert(offsetof(UBFGDataAsset_JetpackParams, M_fTakeOffUpAcceleration) == 0x000060, "Member 'UBFGDataAsset_JetpackParams::M_fTakeOffUpAcceleration' has a wrong offset!");
static_assert(offsetof(UBFGDataAsset_JetpackParams, M_fTakeOffMaxUpSpeed) == 0x000064, "Member 'UBFGDataAsset_JetpackParams::M_fTakeOffMaxUpSpeed' has a wrong offset!");
static_assert(offsetof(UBFGDataAsset_JetpackParams, M_fTakeOffForwardAcceleration) == 0x000068, "Member 'UBFGDataAsset_JetpackParams::M_fTakeOffForwardAcceleration' has a wrong offset!");
static_assert(offsetof(UBFGDataAsset_JetpackParams, M_fTakeOffMaxForwardSpeed) == 0x00006C, "Member 'UBFGDataAsset_JetpackParams::M_fTakeOffMaxForwardSpeed' has a wrong offset!");
static_assert(offsetof(UBFGDataAsset_JetpackParams, M_fTakeOffTime) == 0x000070, "Member 'UBFGDataAsset_JetpackParams::M_fTakeOffTime' has a wrong offset!");
static_assert(offsetof(UBFGDataAsset_JetpackParams, M_fTakeOffFriction) == 0x000074, "Member 'UBFGDataAsset_JetpackParams::M_fTakeOffFriction' has a wrong offset!");
static_assert(offsetof(UBFGDataAsset_JetpackParams, M_fCruiseUpAcceleration) == 0x000078, "Member 'UBFGDataAsset_JetpackParams::M_fCruiseUpAcceleration' has a wrong offset!");
static_assert(offsetof(UBFGDataAsset_JetpackParams, M_fCruiseMaxUpSpeed) == 0x00007C, "Member 'UBFGDataAsset_JetpackParams::M_fCruiseMaxUpSpeed' has a wrong offset!");
static_assert(offsetof(UBFGDataAsset_JetpackParams, M_fCruiseForwardAcceleration) == 0x000080, "Member 'UBFGDataAsset_JetpackParams::M_fCruiseForwardAcceleration' has a wrong offset!");
static_assert(offsetof(UBFGDataAsset_JetpackParams, M_fCruiseMaxForwardSpeed) == 0x000084, "Member 'UBFGDataAsset_JetpackParams::M_fCruiseMaxForwardSpeed' has a wrong offset!");
static_assert(offsetof(UBFGDataAsset_JetpackParams, M_fCruiseFriction) == 0x000088, "Member 'UBFGDataAsset_JetpackParams::M_fCruiseFriction' has a wrong offset!");
static_assert(offsetof(UBFGDataAsset_JetpackParams, M_fCruiseUpFadeOutSpeed) == 0x00008C, "Member 'UBFGDataAsset_JetpackParams::M_fCruiseUpFadeOutSpeed' has a wrong offset!");
static_assert(offsetof(UBFGDataAsset_JetpackParams, M_fCruiseCutOffHeight) == 0x000090, "Member 'UBFGDataAsset_JetpackParams::M_fCruiseCutOffHeight' has a wrong offset!");
static_assert(offsetof(UBFGDataAsset_JetpackParams, M_fGlideMaxDownSpeed) == 0x000094, "Member 'UBFGDataAsset_JetpackParams::M_fGlideMaxDownSpeed' has a wrong offset!");
static_assert(offsetof(UBFGDataAsset_JetpackParams, M_fGlideForwardAcceleration) == 0x000098, "Member 'UBFGDataAsset_JetpackParams::M_fGlideForwardAcceleration' has a wrong offset!");
static_assert(offsetof(UBFGDataAsset_JetpackParams, M_fGlideMaxForwardSpeed) == 0x00009C, "Member 'UBFGDataAsset_JetpackParams::M_fGlideMaxForwardSpeed' has a wrong offset!");
static_assert(offsetof(UBFGDataAsset_JetpackParams, M_fGlideCutOffHeight) == 0x0000A0, "Member 'UBFGDataAsset_JetpackParams::M_fGlideCutOffHeight' has a wrong offset!");
static_assert(offsetof(UBFGDataAsset_JetpackParams, M_fGlideFriction) == 0x0000A4, "Member 'UBFGDataAsset_JetpackParams::M_fGlideFriction' has a wrong offset!");
static_assert(offsetof(UBFGDataAsset_JetpackParams, M_fGlideUpFadeOutSpeed) == 0x0000A8, "Member 'UBFGDataAsset_JetpackParams::M_fGlideUpFadeOutSpeed' has a wrong offset!");
static_assert(offsetof(UBFGDataAsset_JetpackParams, M_fHoverForwardAcceleration) == 0x0000AC, "Member 'UBFGDataAsset_JetpackParams::M_fHoverForwardAcceleration' has a wrong offset!");
static_assert(offsetof(UBFGDataAsset_JetpackParams, M_fHoverMaxForwardSpeed) == 0x0000B0, "Member 'UBFGDataAsset_JetpackParams::M_fHoverMaxForwardSpeed' has a wrong offset!");
static_assert(offsetof(UBFGDataAsset_JetpackParams, M_fHoverFriction) == 0x0000B4, "Member 'UBFGDataAsset_JetpackParams::M_fHoverFriction' has a wrong offset!");
static_assert(offsetof(UBFGDataAsset_JetpackParams, M_fHoverUpFadeOutSpeed) == 0x0000B8, "Member 'UBFGDataAsset_JetpackParams::M_fHoverUpFadeOutSpeed' has a wrong offset!");
static_assert(offsetof(UBFGDataAsset_JetpackParams, M_fSkateForwardAcceleration) == 0x0000BC, "Member 'UBFGDataAsset_JetpackParams::M_fSkateForwardAcceleration' has a wrong offset!");
static_assert(offsetof(UBFGDataAsset_JetpackParams, M_fSkateStartForwardSpeed) == 0x0000C0, "Member 'UBFGDataAsset_JetpackParams::M_fSkateStartForwardSpeed' has a wrong offset!");
static_assert(offsetof(UBFGDataAsset_JetpackParams, M_fSkateMaxForwardSpeed) == 0x0000C4, "Member 'UBFGDataAsset_JetpackParams::M_fSkateMaxForwardSpeed' has a wrong offset!");
static_assert(offsetof(UBFGDataAsset_JetpackParams, M_fSkateMaxSpeedTime) == 0x0000C8, "Member 'UBFGDataAsset_JetpackParams::M_fSkateMaxSpeedTime' has a wrong offset!");
static_assert(offsetof(UBFGDataAsset_JetpackParams, M_fSkateFriction) == 0x0000CC, "Member 'UBFGDataAsset_JetpackParams::M_fSkateFriction' has a wrong offset!");
static_assert(offsetof(UBFGDataAsset_JetpackParams, M_fSkateBrakeFriction) == 0x0000D0, "Member 'UBFGDataAsset_JetpackParams::M_fSkateBrakeFriction' has a wrong offset!");
static_assert(offsetof(UBFGDataAsset_JetpackParams, M_fSkateUpFadeOutSpeed) == 0x0000D4, "Member 'UBFGDataAsset_JetpackParams::M_fSkateUpFadeOutSpeed' has a wrong offset!");
static_assert(offsetof(UBFGDataAsset_JetpackParams, M_fSkateDeployDelay) == 0x0000D8, "Member 'UBFGDataAsset_JetpackParams::M_fSkateDeployDelay' has a wrong offset!");
static_assert(offsetof(UBFGDataAsset_JetpackParams, M_fSkateMaxDownSpeed) == 0x0000DC, "Member 'UBFGDataAsset_JetpackParams::M_fSkateMaxDownSpeed' has a wrong offset!");
static_assert(offsetof(UBFGDataAsset_JetpackParams, M_fSkateHangTime) == 0x0000E0, "Member 'UBFGDataAsset_JetpackParams::M_fSkateHangTime' has a wrong offset!");
static_assert(offsetof(UBFGDataAsset_JetpackParams, M_fSkateHeight) == 0x0000E4, "Member 'UBFGDataAsset_JetpackParams::M_fSkateHeight' has a wrong offset!");
static_assert(offsetof(UBFGDataAsset_JetpackParams, M_oSkateMovementSettings) == 0x0000E8, "Member 'UBFGDataAsset_JetpackParams::M_oSkateMovementSettings' has a wrong offset!");
static_assert(offsetof(UBFGDataAsset_JetpackParams, M_oSkateGameplayEffectTags) == 0x000108, "Member 'UBFGDataAsset_JetpackParams::M_oSkateGameplayEffectTags' has a wrong offset!");
static_assert(offsetof(UBFGDataAsset_JetpackParams, M_fMaxFuel) == 0x000128, "Member 'UBFGDataAsset_JetpackParams::M_fMaxFuel' has a wrong offset!");
static_assert(offsetof(UBFGDataAsset_JetpackParams, M_fFuelConsumption) == 0x00012C, "Member 'UBFGDataAsset_JetpackParams::M_fFuelConsumption' has a wrong offset!");
static_assert(offsetof(UBFGDataAsset_JetpackParams, M_fHoverFuelConsumption) == 0x000130, "Member 'UBFGDataAsset_JetpackParams::M_fHoverFuelConsumption' has a wrong offset!");
static_assert(offsetof(UBFGDataAsset_JetpackParams, M_fFuelRegenSpeed) == 0x000134, "Member 'UBFGDataAsset_JetpackParams::M_fFuelRegenSpeed' has a wrong offset!");
static_assert(offsetof(UBFGDataAsset_JetpackParams, M_fFuelRegenDelay) == 0x000138, "Member 'UBFGDataAsset_JetpackParams::M_fFuelRegenDelay' has a wrong offset!");

// Class BFGCore.BFGDialogOptionHandler_Base
// 0x0028 (0x0050 - 0x0028)
class UBFGDialogOptionHandler_Base : public UObject
{
public:
	class FName                                   M_name;                                            // 0x0028(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	UMulticastDelegateProperty_                   M_OnHandled;                                       // 0x0030(0x0018)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	TWeakObjectPtr<class UBFGGameInstance>        M_pGameInstance;                                   // 0x0048(0x0008)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)

public:
	void ActionOptionHandler__DelegateSignature(class UBFGDialogOptionHandler_Base* _pHandler, EBFGDialogMessage _message);
	void Handle();
	void Init(class UBFGGameInstance* _pGameInstance);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"BFGDialogOptionHandler_Base">();
	}
	static class UBFGDialogOptionHandler_Base* GetDefaultObj()
	{
		return GetDefaultObjImpl<UBFGDialogOptionHandler_Base>();
	}
};
static_assert(alignof(UBFGDialogOptionHandler_Base) == 0x000008, "Wrong alignment on UBFGDialogOptionHandler_Base");
static_assert(sizeof(UBFGDialogOptionHandler_Base) == 0x000050, "Wrong size on UBFGDialogOptionHandler_Base");
static_assert(offsetof(UBFGDialogOptionHandler_Base, M_name) == 0x000028, "Member 'UBFGDialogOptionHandler_Base::M_name' has a wrong offset!");
static_assert(offsetof(UBFGDialogOptionHandler_Base, M_OnHandled) == 0x000030, "Member 'UBFGDialogOptionHandler_Base::M_OnHandled' has a wrong offset!");
static_assert(offsetof(UBFGDialogOptionHandler_Base, M_pGameInstance) == 0x000048, "Member 'UBFGDialogOptionHandler_Base::M_pGameInstance' has a wrong offset!");

// Class BFGCore.BFGDialogOptionHandler_SubDialogState
// 0x0038 (0x0088 - 0x0050)
class UBFGDialogOptionHandler_SubDialogState : public UBFGDialogOptionHandler_Base
{
public:
	TSoftClassPtr<class UClass>                   M_pDialogStateClass;                               // 0x0050(0x0028)(Edit, BlueprintVisible, BlueprintReadOnly, DisableEditOnInstance, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TWeakObjectPtr<class UBFGGameFlowState_GenericDialog> M_pDialogState;                                    // 0x0078(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          M_bBubbleReturnOnFail;                             // 0x0080(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          M_bBubbleReturnOnSuccess;                          // 0x0081(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_82[0x6];                                       // 0x0082(0x0006)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void OnDialogMessage(EBFGDialogMessage _eMessage);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"BFGDialogOptionHandler_SubDialogState">();
	}
	static class UBFGDialogOptionHandler_SubDialogState* GetDefaultObj()
	{
		return GetDefaultObjImpl<UBFGDialogOptionHandler_SubDialogState>();
	}
};
static_assert(alignof(UBFGDialogOptionHandler_SubDialogState) == 0x000008, "Wrong alignment on UBFGDialogOptionHandler_SubDialogState");
static_assert(sizeof(UBFGDialogOptionHandler_SubDialogState) == 0x000088, "Wrong size on UBFGDialogOptionHandler_SubDialogState");
static_assert(offsetof(UBFGDialogOptionHandler_SubDialogState, M_pDialogStateClass) == 0x000050, "Member 'UBFGDialogOptionHandler_SubDialogState::M_pDialogStateClass' has a wrong offset!");
static_assert(offsetof(UBFGDialogOptionHandler_SubDialogState, M_pDialogState) == 0x000078, "Member 'UBFGDialogOptionHandler_SubDialogState::M_pDialogState' has a wrong offset!");
static_assert(offsetof(UBFGDialogOptionHandler_SubDialogState, M_bBubbleReturnOnFail) == 0x000080, "Member 'UBFGDialogOptionHandler_SubDialogState::M_bBubbleReturnOnFail' has a wrong offset!");
static_assert(offsetof(UBFGDialogOptionHandler_SubDialogState, M_bBubbleReturnOnSuccess) == 0x000081, "Member 'UBFGDialogOptionHandler_SubDialogState::M_bBubbleReturnOnSuccess' has a wrong offset!");

// Class BFGCore.BFGDialogOptionHandler_MainMenu_SaveSlotSubMenu
// 0x0008 (0x0090 - 0x0088)
class UBFGDialogOptionHandler_MainMenu_SaveSlotSubMenu final : public UBFGDialogOptionHandler_SubDialogState
{
public:
	int32                                         M_iSlotIndex;                                      // 0x0088(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          M_bNewGame;                                        // 0x008C(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_8D[0x3];                                       // 0x008D(0x0003)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"BFGDialogOptionHandler_MainMenu_SaveSlotSubMenu">();
	}
	static class UBFGDialogOptionHandler_MainMenu_SaveSlotSubMenu* GetDefaultObj()
	{
		return GetDefaultObjImpl<UBFGDialogOptionHandler_MainMenu_SaveSlotSubMenu>();
	}
};
static_assert(alignof(UBFGDialogOptionHandler_MainMenu_SaveSlotSubMenu) == 0x000008, "Wrong alignment on UBFGDialogOptionHandler_MainMenu_SaveSlotSubMenu");
static_assert(sizeof(UBFGDialogOptionHandler_MainMenu_SaveSlotSubMenu) == 0x000090, "Wrong size on UBFGDialogOptionHandler_MainMenu_SaveSlotSubMenu");
static_assert(offsetof(UBFGDialogOptionHandler_MainMenu_SaveSlotSubMenu, M_iSlotIndex) == 0x000088, "Member 'UBFGDialogOptionHandler_MainMenu_SaveSlotSubMenu::M_iSlotIndex' has a wrong offset!");
static_assert(offsetof(UBFGDialogOptionHandler_MainMenu_SaveSlotSubMenu, M_bNewGame) == 0x00008C, "Member 'UBFGDialogOptionHandler_MainMenu_SaveSlotSubMenu::M_bNewGame' has a wrong offset!");

// Class BFGCore.BFGAnimSharingStateProcessorNPCLowRes
// 0x0000 (0x0050 - 0x0050)
class UBFGAnimSharingStateProcessorNPCLowRes : public UBFGAnimSharingStateProcessor
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"BFGAnimSharingStateProcessorNPCLowRes">();
	}
	static class UBFGAnimSharingStateProcessorNPCLowRes* GetDefaultObj()
	{
		return GetDefaultObjImpl<UBFGAnimSharingStateProcessorNPCLowRes>();
	}
};
static_assert(alignof(UBFGAnimSharingStateProcessorNPCLowRes) == 0x000008, "Wrong alignment on UBFGAnimSharingStateProcessorNPCLowRes");
static_assert(sizeof(UBFGAnimSharingStateProcessorNPCLowRes) == 0x000050, "Wrong size on UBFGAnimSharingStateProcessorNPCLowRes");

// Class BFGCore.BFGDataAsset_WorldDefaultSelectionInfo
// 0x00B8 (0x00E8 - 0x0030)
class UBFGDataAsset_WorldDefaultSelectionInfo final : public UDataAsset
{
public:
	class FText                                   M_oWorldDefaultName;                               // 0x0030(0x0018)(Edit, BlueprintVisible, BlueprintReadOnly, DisableEditOnInstance, NativeAccessSpecifierPublic)
	class FText                                   M_oWorldDefaultDescription;                        // 0x0048(0x0018)(Edit, BlueprintVisible, BlueprintReadOnly, DisableEditOnInstance, NativeAccessSpecifierPublic)
	struct FSlateBrush                            M_oWorldDefaultImage;                              // 0x0060(0x0088)(Edit, BlueprintVisible, BlueprintReadOnly, DisableEditOnInstance, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"BFGDataAsset_WorldDefaultSelectionInfo">();
	}
	static class UBFGDataAsset_WorldDefaultSelectionInfo* GetDefaultObj()
	{
		return GetDefaultObjImpl<UBFGDataAsset_WorldDefaultSelectionInfo>();
	}
};
static_assert(alignof(UBFGDataAsset_WorldDefaultSelectionInfo) == 0x000008, "Wrong alignment on UBFGDataAsset_WorldDefaultSelectionInfo");
static_assert(sizeof(UBFGDataAsset_WorldDefaultSelectionInfo) == 0x0000E8, "Wrong size on UBFGDataAsset_WorldDefaultSelectionInfo");
static_assert(offsetof(UBFGDataAsset_WorldDefaultSelectionInfo, M_oWorldDefaultName) == 0x000030, "Member 'UBFGDataAsset_WorldDefaultSelectionInfo::M_oWorldDefaultName' has a wrong offset!");
static_assert(offsetof(UBFGDataAsset_WorldDefaultSelectionInfo, M_oWorldDefaultDescription) == 0x000048, "Member 'UBFGDataAsset_WorldDefaultSelectionInfo::M_oWorldDefaultDescription' has a wrong offset!");
static_assert(offsetof(UBFGDataAsset_WorldDefaultSelectionInfo, M_oWorldDefaultImage) == 0x000060, "Member 'UBFGDataAsset_WorldDefaultSelectionInfo::M_oWorldDefaultImage' has a wrong offset!");

// Class BFGCore.BFGAOE
// 0x00F8 (0x04D0 - 0x03D8)
class ABFGAOE : public AActor
{
public:
	uint8                                         Pad_3D8[0x18];                                     // 0x03D8(0x0018)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         M_fDuration;                                       // 0x03F0(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         M_fRadius;                                         // 0x03F4(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          M_b2DRadius;                                       // 0x03F8(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_3F9[0x3];                                      // 0x03F9(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         M_fMaxHeight;                                      // 0x03FC(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         M_fTickInterval;                                   // 0x0400(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          M_bSpawnBurningGround;                             // 0x0404(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_405[0x3];                                      // 0x0405(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	struct FAOEData                               M_oAoeStart;                                       // 0x0408(0x0018)(Edit, NoDestructor, NativeAccessSpecifierPublic)
	struct FAOEData                               M_oAoeTick;                                        // 0x0420(0x0018)(Edit, NoDestructor, NativeAccessSpecifierPublic)
	struct FAOEData                               M_oAoeEnd;                                         // 0x0438(0x0018)(Edit, NoDestructor, NativeAccessSpecifierPublic)
	uint8                                         Pad_450[0x8];                                      // 0x0450(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	TSubclassOf<class ABFGEffectActor>            M_pExplosionEffectActorClass;                      // 0x0458(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TSubclassOf<class ABFGEffectActor>            M_pImpactEffectActorClass;                         // 0x0460(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class ABFGEffectActor*                        M_pEffectActor;                                    // 0x0468(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TSubclassOf<class ABFGEffectActor>            M_pTelegraphEffectActorClass;                      // 0x0470(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class ABFGEffectActor*                        M_pTelegraphEffectActor;                           // 0x0478(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class AActor*                                 M_pActor;                                          // 0x0480(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	TArray<class UClass*>                         M_aTargetClasses;                                  // 0x0488(0x0010)(ZeroConstructor, NativeAccessSpecifierPrivate)
	uint8                                         Pad_498[0x38];                                     // 0x0498(0x0038)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void CastAOE(const struct FAOEData& _oData);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"BFGAOE">();
	}
	static class ABFGAOE* GetDefaultObj()
	{
		return GetDefaultObjImpl<ABFGAOE>();
	}
};
static_assert(alignof(ABFGAOE) == 0x000008, "Wrong alignment on ABFGAOE");
static_assert(sizeof(ABFGAOE) == 0x0004D0, "Wrong size on ABFGAOE");
static_assert(offsetof(ABFGAOE, M_fDuration) == 0x0003F0, "Member 'ABFGAOE::M_fDuration' has a wrong offset!");
static_assert(offsetof(ABFGAOE, M_fRadius) == 0x0003F4, "Member 'ABFGAOE::M_fRadius' has a wrong offset!");
static_assert(offsetof(ABFGAOE, M_b2DRadius) == 0x0003F8, "Member 'ABFGAOE::M_b2DRadius' has a wrong offset!");
static_assert(offsetof(ABFGAOE, M_fMaxHeight) == 0x0003FC, "Member 'ABFGAOE::M_fMaxHeight' has a wrong offset!");
static_assert(offsetof(ABFGAOE, M_fTickInterval) == 0x000400, "Member 'ABFGAOE::M_fTickInterval' has a wrong offset!");
static_assert(offsetof(ABFGAOE, M_bSpawnBurningGround) == 0x000404, "Member 'ABFGAOE::M_bSpawnBurningGround' has a wrong offset!");
static_assert(offsetof(ABFGAOE, M_oAoeStart) == 0x000408, "Member 'ABFGAOE::M_oAoeStart' has a wrong offset!");
static_assert(offsetof(ABFGAOE, M_oAoeTick) == 0x000420, "Member 'ABFGAOE::M_oAoeTick' has a wrong offset!");
static_assert(offsetof(ABFGAOE, M_oAoeEnd) == 0x000438, "Member 'ABFGAOE::M_oAoeEnd' has a wrong offset!");
static_assert(offsetof(ABFGAOE, M_pExplosionEffectActorClass) == 0x000458, "Member 'ABFGAOE::M_pExplosionEffectActorClass' has a wrong offset!");
static_assert(offsetof(ABFGAOE, M_pImpactEffectActorClass) == 0x000460, "Member 'ABFGAOE::M_pImpactEffectActorClass' has a wrong offset!");
static_assert(offsetof(ABFGAOE, M_pEffectActor) == 0x000468, "Member 'ABFGAOE::M_pEffectActor' has a wrong offset!");
static_assert(offsetof(ABFGAOE, M_pTelegraphEffectActorClass) == 0x000470, "Member 'ABFGAOE::M_pTelegraphEffectActorClass' has a wrong offset!");
static_assert(offsetof(ABFGAOE, M_pTelegraphEffectActor) == 0x000478, "Member 'ABFGAOE::M_pTelegraphEffectActor' has a wrong offset!");
static_assert(offsetof(ABFGAOE, M_pActor) == 0x000480, "Member 'ABFGAOE::M_pActor' has a wrong offset!");
static_assert(offsetof(ABFGAOE, M_aTargetClasses) == 0x000488, "Member 'ABFGAOE::M_aTargetClasses' has a wrong offset!");

// Class BFGCore.BFGGameFlowState_LevelSwitch
// 0x0050 (0x0120 - 0x00D0)
class UBFGGameFlowState_LevelSwitch : public UBFGGameFlowState_LoadingScreenBase
{
public:
	struct FBFGSavedMapDescription                M_targetMap;                                       // 0x00D0(0x0038)(Transient, Protected, NativeAccessSpecifierProtected)
	bool                                          M_bSaveInitiated;                                  // 0x0108(0x0001)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          M_bIsSaveDone;                                     // 0x0109(0x0001)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_10A[0x1];                                      // 0x010A(0x0001)(Fixing Size After Last Property [ Dumper-7 ])
	bool                                          M_bAbortedQuests;                                  // 0x010B(0x0001)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_10C[0x4];                                      // 0x010C(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class UBFGSaveSystem*                         M_pSaveSystem;                                     // 0x0110(0x0008)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UBFGSaveSystem_SaveGameAction*          M_pSaveAction;                                     // 0x0118(0x0008)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)

public:
	static bool StartLevelSwitch(class UBFGGameInstance* _pGameInstance, const class FString& _strLevelName);

	void OnSaveSystemActionCompleted(class UBFGSaveSystem* _pSaveSystem, class UBFGSaveSystem_Action* _pAction, EBFGSaveSystem_ActionResult _result);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"BFGGameFlowState_LevelSwitch">();
	}
	static class UBFGGameFlowState_LevelSwitch* GetDefaultObj()
	{
		return GetDefaultObjImpl<UBFGGameFlowState_LevelSwitch>();
	}
};
static_assert(alignof(UBFGGameFlowState_LevelSwitch) == 0x000008, "Wrong alignment on UBFGGameFlowState_LevelSwitch");
static_assert(sizeof(UBFGGameFlowState_LevelSwitch) == 0x000120, "Wrong size on UBFGGameFlowState_LevelSwitch");
static_assert(offsetof(UBFGGameFlowState_LevelSwitch, M_targetMap) == 0x0000D0, "Member 'UBFGGameFlowState_LevelSwitch::M_targetMap' has a wrong offset!");
static_assert(offsetof(UBFGGameFlowState_LevelSwitch, M_bSaveInitiated) == 0x000108, "Member 'UBFGGameFlowState_LevelSwitch::M_bSaveInitiated' has a wrong offset!");
static_assert(offsetof(UBFGGameFlowState_LevelSwitch, M_bIsSaveDone) == 0x000109, "Member 'UBFGGameFlowState_LevelSwitch::M_bIsSaveDone' has a wrong offset!");
static_assert(offsetof(UBFGGameFlowState_LevelSwitch, M_bAbortedQuests) == 0x00010B, "Member 'UBFGGameFlowState_LevelSwitch::M_bAbortedQuests' has a wrong offset!");
static_assert(offsetof(UBFGGameFlowState_LevelSwitch, M_pSaveSystem) == 0x000110, "Member 'UBFGGameFlowState_LevelSwitch::M_pSaveSystem' has a wrong offset!");
static_assert(offsetof(UBFGGameFlowState_LevelSwitch, M_pSaveAction) == 0x000118, "Member 'UBFGGameFlowState_LevelSwitch::M_pSaveAction' has a wrong offset!");

// Class BFGCore.BFGGameFlowState_DebugLevelSwitch
// 0x0050 (0x0170 - 0x0120)
class UBFGGameFlowState_DebugLevelSwitch final : public UBFGGameFlowState_LevelSwitch
{
public:
	struct FBFGDebugStartMenu_EntryData           M_entryData;                                       // 0x0120(0x0050)(Protected, NativeAccessSpecifierProtected)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"BFGGameFlowState_DebugLevelSwitch">();
	}
	static class UBFGGameFlowState_DebugLevelSwitch* GetDefaultObj()
	{
		return GetDefaultObjImpl<UBFGGameFlowState_DebugLevelSwitch>();
	}
};
static_assert(alignof(UBFGGameFlowState_DebugLevelSwitch) == 0x000008, "Wrong alignment on UBFGGameFlowState_DebugLevelSwitch");
static_assert(sizeof(UBFGGameFlowState_DebugLevelSwitch) == 0x000170, "Wrong size on UBFGGameFlowState_DebugLevelSwitch");
static_assert(offsetof(UBFGGameFlowState_DebugLevelSwitch, M_entryData) == 0x000120, "Member 'UBFGGameFlowState_DebugLevelSwitch::M_entryData' has a wrong offset!");

// Class BFGCore.BFGAOE_Boss
// 0x0018 (0x04E8 - 0x04D0)
class ABFGAOE_Boss : public ABFGAOE
{
public:
	bool                                          M_bUseWarningMarkers;                              // 0x04D0(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_4D1[0x7];                                      // 0x04D1(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	class UBFGActorComponent_AOEWarningMarker*    M_pWarningMarkerComponent;                         // 0x04D8(0x0008)(Edit, ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class ABFGNPCCharacterBoss*                   M_pOwnerCharacterBoss;                             // 0x04E0(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)

public:
	void OnWarningFinished();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"BFGAOE_Boss">();
	}
	static class ABFGAOE_Boss* GetDefaultObj()
	{
		return GetDefaultObjImpl<ABFGAOE_Boss>();
	}
};
static_assert(alignof(ABFGAOE_Boss) == 0x000008, "Wrong alignment on ABFGAOE_Boss");
static_assert(sizeof(ABFGAOE_Boss) == 0x0004E8, "Wrong size on ABFGAOE_Boss");
static_assert(offsetof(ABFGAOE_Boss, M_bUseWarningMarkers) == 0x0004D0, "Member 'ABFGAOE_Boss::M_bUseWarningMarkers' has a wrong offset!");
static_assert(offsetof(ABFGAOE_Boss, M_pWarningMarkerComponent) == 0x0004D8, "Member 'ABFGAOE_Boss::M_pWarningMarkerComponent' has a wrong offset!");
static_assert(offsetof(ABFGAOE_Boss, M_pOwnerCharacterBoss) == 0x0004E0, "Member 'ABFGAOE_Boss::M_pOwnerCharacterBoss' has a wrong offset!");

// Class BFGCore.BFGProjectile_Enemy
// 0x0010 (0x0688 - 0x0678)
class ABFGProjectile_Enemy : public ABFGProjectile_Object
{
public:
	float                                         M_fDelayDuration;                                  // 0x0678(0x0004)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_67C[0xC];                                      // 0x067C(0x000C)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"BFGProjectile_Enemy">();
	}
	static class ABFGProjectile_Enemy* GetDefaultObj()
	{
		return GetDefaultObjImpl<ABFGProjectile_Enemy>();
	}
};
static_assert(alignof(ABFGProjectile_Enemy) == 0x000008, "Wrong alignment on ABFGProjectile_Enemy");
static_assert(sizeof(ABFGProjectile_Enemy) == 0x000688, "Wrong size on ABFGProjectile_Enemy");
static_assert(offsetof(ABFGProjectile_Enemy, M_fDelayDuration) == 0x000678, "Member 'ABFGProjectile_Enemy::M_fDelayDuration' has a wrong offset!");

// Class BFGCore.BFGProjectile_EnemyTank
// 0x0000 (0x0688 - 0x0688)
class ABFGProjectile_EnemyTank final : public ABFGProjectile_Enemy
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"BFGProjectile_EnemyTank">();
	}
	static class ABFGProjectile_EnemyTank* GetDefaultObj()
	{
		return GetDefaultObjImpl<ABFGProjectile_EnemyTank>();
	}
};
static_assert(alignof(ABFGProjectile_EnemyTank) == 0x000008, "Wrong alignment on ABFGProjectile_EnemyTank");
static_assert(sizeof(ABFGProjectile_EnemyTank) == 0x000688, "Wrong size on ABFGProjectile_EnemyTank");

// Class BFGCore.BFGVariableAction_Timer_End
// 0x0000 (0x00F0 - 0x00F0)
class UBFGVariableAction_Timer_End final : public UBFGVariableAction
{
public:
	static const class FName GetActionName_TimerEnd();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"BFGVariableAction_Timer_End">();
	}
	static class UBFGVariableAction_Timer_End* GetDefaultObj()
	{
		return GetDefaultObjImpl<UBFGVariableAction_Timer_End>();
	}
};
static_assert(alignof(UBFGVariableAction_Timer_End) == 0x000008, "Wrong alignment on UBFGVariableAction_Timer_End");
static_assert(sizeof(UBFGVariableAction_Timer_End) == 0x0000F0, "Wrong size on UBFGVariableAction_Timer_End");

// Class BFGCore.BFGBTBaseDecorator
// 0x0008 (0x0070 - 0x0068)
class UBFGBTBaseDecorator : public UBTDecorator
{
public:
	bool                                          M_bAutoResolveBlackboardKeys;                      // 0x0068(0x0001)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_69[0x7];                                       // 0x0069(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"BFGBTBaseDecorator">();
	}
	static class UBFGBTBaseDecorator* GetDefaultObj()
	{
		return GetDefaultObjImpl<UBFGBTBaseDecorator>();
	}
};
static_assert(alignof(UBFGBTBaseDecorator) == 0x000008, "Wrong alignment on UBFGBTBaseDecorator");
static_assert(sizeof(UBFGBTBaseDecorator) == 0x000070, "Wrong size on UBFGBTBaseDecorator");
static_assert(offsetof(UBFGBTBaseDecorator, M_bAutoResolveBlackboardKeys) == 0x000068, "Member 'UBFGBTBaseDecorator::M_bAutoResolveBlackboardKeys' has a wrong offset!");

// Class BFGCore.BFGDecorator_ObservingBase
// 0x0000 (0x0070 - 0x0070)
class UBFGDecorator_ObservingBase : public UBFGBTBaseDecorator
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"BFGDecorator_ObservingBase">();
	}
	static class UBFGDecorator_ObservingBase* GetDefaultObj()
	{
		return GetDefaultObjImpl<UBFGDecorator_ObservingBase>();
	}
};
static_assert(alignof(UBFGDecorator_ObservingBase) == 0x000008, "Wrong alignment on UBFGDecorator_ObservingBase");
static_assert(sizeof(UBFGDecorator_ObservingBase) == 0x000070, "Wrong size on UBFGDecorator_ObservingBase");

// Class BFGCore.BFGDecorator_BlackboardRandom
// 0x0008 (0x0078 - 0x0070)
class UBFGDecorator_BlackboardRandom final : public UBFGDecorator_ObservingBase
{
public:
	float                                         M_fMin;                                            // 0x0070(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         M_fMax;                                            // 0x0074(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"BFGDecorator_BlackboardRandom">();
	}
	static class UBFGDecorator_BlackboardRandom* GetDefaultObj()
	{
		return GetDefaultObjImpl<UBFGDecorator_BlackboardRandom>();
	}
};
static_assert(alignof(UBFGDecorator_BlackboardRandom) == 0x000008, "Wrong alignment on UBFGDecorator_BlackboardRandom");
static_assert(sizeof(UBFGDecorator_BlackboardRandom) == 0x000078, "Wrong size on UBFGDecorator_BlackboardRandom");
static_assert(offsetof(UBFGDecorator_BlackboardRandom, M_fMin) == 0x000070, "Member 'UBFGDecorator_BlackboardRandom::M_fMin' has a wrong offset!");
static_assert(offsetof(UBFGDecorator_BlackboardRandom, M_fMax) == 0x000074, "Member 'UBFGDecorator_BlackboardRandom::M_fMax' has a wrong offset!");

// Class BFGCore.BFGAudio
// 0x0000 (0x0028 - 0x0028)
class UBFGAudio final : public UBlueprintFunctionLibrary
{
public:
	static bool GetSoundClassVolume(const class FString& ClassName, float* Volume);
	static bool SetSoundClassVolume(const class FString& ClassName, float Volume);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"BFGAudio">();
	}
	static class UBFGAudio* GetDefaultObj()
	{
		return GetDefaultObjImpl<UBFGAudio>();
	}
};
static_assert(alignof(UBFGAudio) == 0x000008, "Wrong alignment on UBFGAudio");
static_assert(sizeof(UBFGAudio) == 0x000028, "Wrong size on UBFGAudio");

// Class BFGCore.BFGWeapon_BossBase
// 0x0150 (0x08A0 - 0x0750)
class ABFGWeapon_BossBase : public ABFGWeapon_BaseProjectile
{
public:
	UMulticastDelegateProperty_                   M_dPatternCompleteDelegate;                        // 0x0750(0x0018)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	TMap<TSubclassOf<class ABFGPattern_Base>, class ABFGPattern_Base*> M_mPatternMap;                                     // 0x0768(0x0050)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, NativeAccessSpecifierPublic)
	uint8                                         Pad_7B8[0xD0];                                     // 0x07B8(0x00D0)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<class ABFGPattern_Base*>               M_aPatterns;                                       // 0x0888(0x0010)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Protected, NativeAccessSpecifierProtected)
	class ABFGPattern_Base*                       M_pActivePattern;                                  // 0x0898(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)

public:
	void SetActivePattern(int32 _iWeaponPatternIndex);
	bool TryActivatePattern();
	bool TryClearActivePattern();
	bool TryPreparePattern(TSubclassOf<class ABFGPattern_Base> _pPatternClass);

	class ABFGPattern_Base* GetActivePattern() const;
	struct FVector GetAimDirection() const;
	bool HasActivePattern() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"BFGWeapon_BossBase">();
	}
	static class ABFGWeapon_BossBase* GetDefaultObj()
	{
		return GetDefaultObjImpl<ABFGWeapon_BossBase>();
	}
};
static_assert(alignof(ABFGWeapon_BossBase) == 0x000008, "Wrong alignment on ABFGWeapon_BossBase");
static_assert(sizeof(ABFGWeapon_BossBase) == 0x0008A0, "Wrong size on ABFGWeapon_BossBase");
static_assert(offsetof(ABFGWeapon_BossBase, M_dPatternCompleteDelegate) == 0x000750, "Member 'ABFGWeapon_BossBase::M_dPatternCompleteDelegate' has a wrong offset!");
static_assert(offsetof(ABFGWeapon_BossBase, M_mPatternMap) == 0x000768, "Member 'ABFGWeapon_BossBase::M_mPatternMap' has a wrong offset!");
static_assert(offsetof(ABFGWeapon_BossBase, M_aPatterns) == 0x000888, "Member 'ABFGWeapon_BossBase::M_aPatterns' has a wrong offset!");
static_assert(offsetof(ABFGWeapon_BossBase, M_pActivePattern) == 0x000898, "Member 'ABFGWeapon_BossBase::M_pActivePattern' has a wrong offset!");

// Class BFGCore.BFGWeapon_BossAOE
// 0x0088 (0x0928 - 0x08A0)
class ABFGWeapon_BossAOE : public ABFGWeapon_BossBase
{
public:
	TArray<TSubclassOf<class ABFGPattern_AOE>>    M_aAOEPatternClasses;                              // 0x08A0(0x0010)(Edit, ZeroConstructor, DisableEditOnInstance, UObjectWrapper, NativeAccessSpecifierPublic)
	TArray<EBFGRocketSocket>                      M_aRocketSockets;                                  // 0x08B0(0x0010)(Edit, ZeroConstructor, NativeAccessSpecifierPublic)
	class FName                                   M_strHandSocket;                                   // 0x08C0(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FSoftClassPath                         M_AlternateProjectileClass;                        // 0x08C8(0x0018)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, NativeAccessSpecifierPublic)
	struct FSoftClassPath                         M_SecondAlternateProjectileClass;                  // 0x08E0(0x0018)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, NativeAccessSpecifierPublic)
	class UClass*                                 M_pCachedAlternateProjectileClass;                 // 0x08F8(0x0008)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UClass*                                 M_pCachedSecondAlternateProjectileClass;           // 0x0900(0x0008)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         M_fProjectileExitTime;                             // 0x0908(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         M_fWarningTime;                                    // 0x090C(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         M_fTrajectoryHeight;                               // 0x0910(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          M_bDebugShowPatternOrigin;                         // 0x0914(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_915[0x13];                                     // 0x0915(0x0013)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"BFGWeapon_BossAOE">();
	}
	static class ABFGWeapon_BossAOE* GetDefaultObj()
	{
		return GetDefaultObjImpl<ABFGWeapon_BossAOE>();
	}
};
static_assert(alignof(ABFGWeapon_BossAOE) == 0x000008, "Wrong alignment on ABFGWeapon_BossAOE");
static_assert(sizeof(ABFGWeapon_BossAOE) == 0x000928, "Wrong size on ABFGWeapon_BossAOE");
static_assert(offsetof(ABFGWeapon_BossAOE, M_aAOEPatternClasses) == 0x0008A0, "Member 'ABFGWeapon_BossAOE::M_aAOEPatternClasses' has a wrong offset!");
static_assert(offsetof(ABFGWeapon_BossAOE, M_aRocketSockets) == 0x0008B0, "Member 'ABFGWeapon_BossAOE::M_aRocketSockets' has a wrong offset!");
static_assert(offsetof(ABFGWeapon_BossAOE, M_strHandSocket) == 0x0008C0, "Member 'ABFGWeapon_BossAOE::M_strHandSocket' has a wrong offset!");
static_assert(offsetof(ABFGWeapon_BossAOE, M_AlternateProjectileClass) == 0x0008C8, "Member 'ABFGWeapon_BossAOE::M_AlternateProjectileClass' has a wrong offset!");
static_assert(offsetof(ABFGWeapon_BossAOE, M_SecondAlternateProjectileClass) == 0x0008E0, "Member 'ABFGWeapon_BossAOE::M_SecondAlternateProjectileClass' has a wrong offset!");
static_assert(offsetof(ABFGWeapon_BossAOE, M_pCachedAlternateProjectileClass) == 0x0008F8, "Member 'ABFGWeapon_BossAOE::M_pCachedAlternateProjectileClass' has a wrong offset!");
static_assert(offsetof(ABFGWeapon_BossAOE, M_pCachedSecondAlternateProjectileClass) == 0x000900, "Member 'ABFGWeapon_BossAOE::M_pCachedSecondAlternateProjectileClass' has a wrong offset!");
static_assert(offsetof(ABFGWeapon_BossAOE, M_fProjectileExitTime) == 0x000908, "Member 'ABFGWeapon_BossAOE::M_fProjectileExitTime' has a wrong offset!");
static_assert(offsetof(ABFGWeapon_BossAOE, M_fWarningTime) == 0x00090C, "Member 'ABFGWeapon_BossAOE::M_fWarningTime' has a wrong offset!");
static_assert(offsetof(ABFGWeapon_BossAOE, M_fTrajectoryHeight) == 0x000910, "Member 'ABFGWeapon_BossAOE::M_fTrajectoryHeight' has a wrong offset!");
static_assert(offsetof(ABFGWeapon_BossAOE, M_bDebugShowPatternOrigin) == 0x000914, "Member 'ABFGWeapon_BossAOE::M_bDebugShowPatternOrigin' has a wrong offset!");

// Class BFGCore.BFGDecorator_AllowFlee
// 0x0000 (0x0070 - 0x0070)
class UBFGDecorator_AllowFlee final : public UBFGBTBaseDecorator
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"BFGDecorator_AllowFlee">();
	}
	static class UBFGDecorator_AllowFlee* GetDefaultObj()
	{
		return GetDefaultObjImpl<UBFGDecorator_AllowFlee>();
	}
};
static_assert(alignof(UBFGDecorator_AllowFlee) == 0x000008, "Wrong alignment on UBFGDecorator_AllowFlee");
static_assert(sizeof(UBFGDecorator_AllowFlee) == 0x000070, "Wrong size on UBFGDecorator_AllowFlee");

// Class BFGCore.BFGPattern_Base
// 0x0020 (0x03F8 - 0x03D8)
class ABFGPattern_Base : public AActor
{
public:
	EPatternTargetingMode                         M_ePatternTargetingMode;                           // 0x03D8(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          M_bTrackTarget;                                    // 0x03D9(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          M_bUsePredictiveAiming;                            // 0x03DA(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_3DB[0x1];                                      // 0x03DB(0x0001)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         M_fPatternRepeatInterval;                          // 0x03DC(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UArrowComponent*                        M_pOrigin;                                         // 0x03E0(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TArray<class UBFGPatternTargetMarker*>        M_aTargetMarkers;                                  // 0x03E8(0x0010)(ExportObject, ZeroConstructor, ContainsInstancedReference, Protected, NativeAccessSpecifierProtected)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"BFGPattern_Base">();
	}
	static class ABFGPattern_Base* GetDefaultObj()
	{
		return GetDefaultObjImpl<ABFGPattern_Base>();
	}
};
static_assert(alignof(ABFGPattern_Base) == 0x000008, "Wrong alignment on ABFGPattern_Base");
static_assert(sizeof(ABFGPattern_Base) == 0x0003F8, "Wrong size on ABFGPattern_Base");
static_assert(offsetof(ABFGPattern_Base, M_ePatternTargetingMode) == 0x0003D8, "Member 'ABFGPattern_Base::M_ePatternTargetingMode' has a wrong offset!");
static_assert(offsetof(ABFGPattern_Base, M_bTrackTarget) == 0x0003D9, "Member 'ABFGPattern_Base::M_bTrackTarget' has a wrong offset!");
static_assert(offsetof(ABFGPattern_Base, M_bUsePredictiveAiming) == 0x0003DA, "Member 'ABFGPattern_Base::M_bUsePredictiveAiming' has a wrong offset!");
static_assert(offsetof(ABFGPattern_Base, M_fPatternRepeatInterval) == 0x0003DC, "Member 'ABFGPattern_Base::M_fPatternRepeatInterval' has a wrong offset!");
static_assert(offsetof(ABFGPattern_Base, M_pOrigin) == 0x0003E0, "Member 'ABFGPattern_Base::M_pOrigin' has a wrong offset!");
static_assert(offsetof(ABFGPattern_Base, M_aTargetMarkers) == 0x0003E8, "Member 'ABFGPattern_Base::M_aTargetMarkers' has a wrong offset!");

// Class BFGCore.BFGPattern_AOE
// 0x0010 (0x0408 - 0x03F8)
class ABFGPattern_AOE : public ABFGPattern_Base
{
public:
	struct FVector                                M_vPatternOffset;                                  // 0x03F8(0x000C)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_404[0x4];                                      // 0x0404(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"BFGPattern_AOE">();
	}
	static class ABFGPattern_AOE* GetDefaultObj()
	{
		return GetDefaultObjImpl<ABFGPattern_AOE>();
	}
};
static_assert(alignof(ABFGPattern_AOE) == 0x000008, "Wrong alignment on ABFGPattern_AOE");
static_assert(sizeof(ABFGPattern_AOE) == 0x000408, "Wrong size on ABFGPattern_AOE");
static_assert(offsetof(ABFGPattern_AOE, M_vPatternOffset) == 0x0003F8, "Member 'ABFGPattern_AOE::M_vPatternOffset' has a wrong offset!");

// Class BFGCore.BFGBackgroundLoader
// 0x0058 (0x0080 - 0x0028)
class UBFGBackgroundLoader final : public UObject
{
public:
	TSet<struct FBFGBackgroundLoadableEntry>      M_aLoadables;                                      // 0x0028(0x0050)(ZeroConstructor, Transient, NativeAccessSpecifierPrivate)
	class UBFGGameInstance*                       M_pGameInstance;                                   // 0x0078(0x0008)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"BFGBackgroundLoader">();
	}
	static class UBFGBackgroundLoader* GetDefaultObj()
	{
		return GetDefaultObjImpl<UBFGBackgroundLoader>();
	}
};
static_assert(alignof(UBFGBackgroundLoader) == 0x000008, "Wrong alignment on UBFGBackgroundLoader");
static_assert(sizeof(UBFGBackgroundLoader) == 0x000080, "Wrong size on UBFGBackgroundLoader");
static_assert(offsetof(UBFGBackgroundLoader, M_aLoadables) == 0x000028, "Member 'UBFGBackgroundLoader::M_aLoadables' has a wrong offset!");
static_assert(offsetof(UBFGBackgroundLoader, M_pGameInstance) == 0x000078, "Member 'UBFGBackgroundLoader::M_pGameInstance' has a wrong offset!");

// Class BFGCore.BFGDialogOptionHandler_Message
// 0x0008 (0x0058 - 0x0050)
class UBFGDialogOptionHandler_Message : public UBFGDialogOptionHandler_Base
{
public:
	EBFGDialogMessage                             M_eMessageToSend;                                  // 0x0050(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_51[0x7];                                       // 0x0051(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"BFGDialogOptionHandler_Message">();
	}
	static class UBFGDialogOptionHandler_Message* GetDefaultObj()
	{
		return GetDefaultObjImpl<UBFGDialogOptionHandler_Message>();
	}
};
static_assert(alignof(UBFGDialogOptionHandler_Message) == 0x000008, "Wrong alignment on UBFGDialogOptionHandler_Message");
static_assert(sizeof(UBFGDialogOptionHandler_Message) == 0x000058, "Wrong size on UBFGDialogOptionHandler_Message");
static_assert(offsetof(UBFGDialogOptionHandler_Message, M_eMessageToSend) == 0x000050, "Member 'UBFGDialogOptionHandler_Message::M_eMessageToSend' has a wrong offset!");

// Class BFGCore.BFGDialogOptionHandler_MainMenu_SaveSlotEntry
// 0x0008 (0x0060 - 0x0058)
class UBFGDialogOptionHandler_MainMenu_SaveSlotEntry final : public UBFGDialogOptionHandler_Message
{
public:
	int32                                         M_iSlotIndex;                                      // 0x0058(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          M_bNewGame;                                        // 0x005C(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_5D[0x3];                                       // 0x005D(0x0003)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"BFGDialogOptionHandler_MainMenu_SaveSlotEntry">();
	}
	static class UBFGDialogOptionHandler_MainMenu_SaveSlotEntry* GetDefaultObj()
	{
		return GetDefaultObjImpl<UBFGDialogOptionHandler_MainMenu_SaveSlotEntry>();
	}
};
static_assert(alignof(UBFGDialogOptionHandler_MainMenu_SaveSlotEntry) == 0x000008, "Wrong alignment on UBFGDialogOptionHandler_MainMenu_SaveSlotEntry");
static_assert(sizeof(UBFGDialogOptionHandler_MainMenu_SaveSlotEntry) == 0x000060, "Wrong size on UBFGDialogOptionHandler_MainMenu_SaveSlotEntry");
static_assert(offsetof(UBFGDialogOptionHandler_MainMenu_SaveSlotEntry, M_iSlotIndex) == 0x000058, "Member 'UBFGDialogOptionHandler_MainMenu_SaveSlotEntry::M_iSlotIndex' has a wrong offset!");
static_assert(offsetof(UBFGDialogOptionHandler_MainMenu_SaveSlotEntry, M_bNewGame) == 0x00005C, "Member 'UBFGDialogOptionHandler_MainMenu_SaveSlotEntry::M_bNewGame' has a wrong offset!");

// Class BFGCore.BFGBasicVehicle
// 0x0898 (0x0CD0 - 0x0438)
class ABFGBasicVehicle : public APawn
{
public:
	uint8                                         Pad_438[0x50];                                     // 0x0438(0x0050)(Fixing Size After Last Property [ Dumper-7 ])
	TWeakObjectPtr<class AActor>                  M_pReplacementWheeledVehicle;                      // 0x0488(0x0008)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UBFGPoseableMeshComponent*              M_pMesh;                                           // 0x0490(0x0008)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, EditConst, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TSubclassOf<class UBFGActorComponent_WidgetComponent_Health> M_pDefaultHealthBarClass;                          // 0x0498(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         M_fDefaultHealthBarZOffset;                        // 0x04A0(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_4A4[0x4];                                      // 0x04A4(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class UBFGActorComponent_WidgetComponent_Health* M_pHealthBarComponent;                             // 0x04A8(0x0008)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, Transient, EditConst, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UBFGActorComponent_GameplayEffectTags*  M_pGameplayEffectTagsComponent;                    // 0x04B0(0x0008)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, EditConst, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	struct FGameplayTagContainer                  M_gameplayTags;                                    // 0x04B8(0x0020)(Edit, BlueprintVisible, BlueprintReadOnly, Protected, NativeAccessSpecifierProtected)
	class UStaticMeshComponent*                   LightBulbsMesh;                                    // 0x04D8(0x0008)(ExportObject, ZeroConstructor, Transient, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class USpotLightComponent*                    FrontRightSpotLight;                               // 0x04E0(0x0008)(ExportObject, ZeroConstructor, Transient, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class USpotLightComponent*                    FrontLeftSpotLight;                                // 0x04E8(0x0008)(ExportObject, ZeroConstructor, Transient, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TArray<class USceneComponent*>                ChildComponents;                                   // 0x04F0(0x0010)(ExportObject, ZeroConstructor, Transient, ContainsInstancedReference, Protected, NativeAccessSpecifierProtected)
	TArray<class USceneComponent*>                Doors;                                             // 0x0500(0x0010)(ExportObject, ZeroConstructor, Transient, ContainsInstancedReference, Protected, NativeAccessSpecifierProtected)
	TArray<class USceneComponent*>                GlassComponents;                                   // 0x0510(0x0010)(ExportObject, ZeroConstructor, Transient, ContainsInstancedReference, Protected, NativeAccessSpecifierProtected)
	class FString                                 M_CustomName;                                      // 0x0520(0x0010)(Edit, ZeroConstructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	struct FBFGWheeledVehicleConfig               Config;                                            // 0x0530(0x03B8)(Edit, BlueprintVisible, Protected, NativeAccessSpecifierProtected)
	TArray<struct FBFGVehiclePlugin>              M_aPlugins;                                        // 0x08E8(0x0010)(ZeroConstructor, Transient, ContainsInstancedReference, Protected, NativeAccessSpecifierProtected)
	TArray<class UMaterialInstanceDynamic*>       DynamicMaterials;                                  // 0x08F8(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, EditConst, Protected, NativeAccessSpecifierProtected)
	class UMaterialInstance*                      LightBulbsMaterial;                                // 0x0908(0x0008)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UMaterialInstanceDynamic*               M_pSirenMaterial;                                  // 0x0910(0x0008)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	EBFGFaction                                   M_faction;                                         // 0x0918(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_919[0x7];                                      // 0x0919(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	class UBFGActorComponent_PawnDamage*          M_pDamageComponent;                                // 0x0920(0x0008)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, EditConst, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UBFGActorComponent_PawnStats*           M_pStatsComponent;                                 // 0x0928(0x0008)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, EditConst, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UBFGNetworkPathAgentComponent*          M_pNetworkPathAgentComponent;                      // 0x0930(0x0008)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, EditConst, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UBFGActorComponent_CrowdAgentVehicle*   M_pCrowdAgentInterfaceComponent;                   // 0x0938(0x0008)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, EditConst, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UBFGActorComponent_FallDamage*          M_pFallDamageComponent;                            // 0x0940(0x0008)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, EditConst, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UBFGActorComponent_ExplosiveItem*       M_pExplosiveComponent;                             // 0x0948(0x0008)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UBFGBuoyancyForceComponent*             M_pBuoyancyComponent;                              // 0x0950(0x0008)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          M_bCarLightsOn;                                    // 0x0958(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          M_bIsStaticVehicle;                                // 0x0959(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_95A[0x2];                                      // 0x095A(0x0002)(Fixing Size After Last Property [ Dumper-7 ])
	int32                                         M_iRequestedPalette;                               // 0x095C(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	struct FBFGVehicleAgentDriveInfo              M_driveInfo;                                       // 0x0960(0x005C)(Transient, NoDestructor, Protected, NativeAccessSpecifierProtected)
	uint8                                         Pad_9BC[0x4];                                      // 0x09BC(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	struct FBFGVehicleState                       M_vehicleState;                                    // 0x09C0(0x0018)(Transient, Protected, NativeAccessSpecifierProtected)
	uint8                                         Pad_9D8[0x38];                                     // 0x09D8(0x0038)(Fixing Size After Last Property [ Dumper-7 ])
	class UBFGActorComponent_MonetaryValue*       M_pMonetaryValueComponent;                         // 0x0A10(0x0008)(Edit, BlueprintVisible, ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UBFGActorComponent_Effect*              M_pEffectComponent;                                // 0x0A18(0x0008)(Edit, BlueprintVisible, ExportObject, ZeroConstructor, DisableEditOnInstance, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UBFGActorComponent_MissionGameplay*     M_pMissionGameplayComponent;                       // 0x0A20(0x0008)(Edit, ExportObject, ZeroConstructor, EditConst, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         M_fLastSpeed;                                      // 0x0A28(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	struct FVector                                M_vLastNormal;                                     // 0x0A2C(0x000C)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         M_fLastZ;                                          // 0x0A38(0x0004)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	struct FVector                                M_vVirtualLocation;                                // 0x0A3C(0x000C)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	struct FRotator                               M_vVirtualRotation;                                // 0x0A48(0x000C)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, NativeAccessSpecifierProtected)
	struct FVector                                M_vSplineLocation;                                 // 0x0A54(0x000C)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          M_bSetupDone;                                      // 0x0A60(0x0001)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          M_bIsPKed;                                         // 0x0A61(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          M_bIsTransmogrifying;                              // 0x0A62(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_A63[0x5];                                      // 0x0A63(0x0005)(Fixing Size After Last Property [ Dumper-7 ])
	class UPhysicsAsset*                          M_pCachedWheeledPhysicsAsset;                      // 0x0A68(0x0008)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UPhysicsAsset*                          M_pCachedNormalPhysicsAsset;                       // 0x0A70(0x0008)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_A78[0x4];                                      // 0x0A78(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	struct FBFGVehicleObstacleInFront             M_obstacleInFront;                                 // 0x0A7C(0x0084)(Edit, BlueprintVisible, NoDestructor, Protected, NativeAccessSpecifierProtected)
	TArray<struct FBFGRespawnInformationData>     M_aRespawnInformationData;                         // 0x0B00(0x0010)(ZeroConstructor, Transient, Protected, NativeAccessSpecifierProtected)
	uint8                                         Pad_B10[0x18];                                     // 0x0B10(0x0018)(Fixing Size After Last Property [ Dumper-7 ])
	bool                                          M_bExplodesOnDeath;                                // 0x0B28(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_B29[0x57];                                     // 0x0B29(0x0057)(Fixing Size After Last Property [ Dumper-7 ])
	class UBFGActorComponent_LockOnTarget*        M_pLockOnTargetComponent;                          // 0x0B80(0x0008)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, EditConst, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class USceneComponent*                        M_pObjectiveMarkerParentComponent;                 // 0x0B88(0x0008)(Edit, BlueprintVisible, ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UBFGActorComponent_Objective*           M_pObjectiveComponent;                             // 0x0B90(0x0008)(Edit, BlueprintVisible, ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UBFGActorComponent_AITarget*            M_pAITargetComponent;                              // 0x0B98(0x0008)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, EditConst, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UBFGActorComponent_HolobobSuppressionAura* M_pHolobobSuppressionAuraComponent;                // 0x0BA0(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, Transient, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UAnimSequence*                          M_pCustomAnimationSequence;                        // 0x0BA8(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TArray<struct FBFGVehicleMaterialEntry>       M_aCustomAnimationMaterialReplacements;            // 0x0BB0(0x0010)(Edit, BlueprintVisible, ZeroConstructor, Protected, NativeAccessSpecifierProtected)
	bool                                          M_bHeightUseRayCastOnly;                           // 0x0BC0(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_BC1[0xB];                                      // 0x0BC1(0x000B)(Fixing Size After Last Property [ Dumper-7 ])
	bool                                          M_bUseCustomAnimMaterials;                         // 0x0BCC(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_BCD[0x7];                                      // 0x0BCD(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	bool                                          M_bImmuneToTransmog;                               // 0x0BD4(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_BD5[0x3];                                      // 0x0BD5(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	TSubclassOf<class UNavArea>                   M_pAreaClass_IsStaticVehicle;                      // 0x0BD8(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          M_bUseVirtualVehicleAllowed;                       // 0x0BE0(0x0001)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_BE1[0xF];                                      // 0x0BE1(0x000F)(Fixing Size After Last Property [ Dumper-7 ])
	struct FBFGVirtualVehicle                     M_virtualVehicle;                                  // 0x0BF0(0x00D0)(Transient, NoDestructor, Protected, NativeAccessSpecifierProtected)
	class UBFGVehicleDeformation*                 M_pCachedVehicleDeformation;                       // 0x0CC0(0x0008)(ExportObject, ZeroConstructor, Transient, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class ABFGGameState*                          M_pGameState;                                      // 0x0CC8(0x0008)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)

public:
	void DisablePassengers();
	void EnablePassengers();
	float HonkAtObstacleInFront();
	void OnBeforeCreatePhysicsState(class UActorComponent* _pComponent);
	void OnTransmogrifyStateChanged(bool _bActive);
	void OnVehicleDeath();
	void RestartAudio();
	void SetPhysicsEnabled(bool _bEnabled);
	class ABFGWheeledVehicle* SpawnPhysicsVehicle(TSubclassOf<class ABFGWheeledVehicle> _type, const struct FTransform& _Transform);

	TSubclassOf<class ABFGWheeledVehicle> GetReplacementWheeledVehicleType() const;
	bool IsPhysicsEnabled() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"BFGBasicVehicle">();
	}
	static class ABFGBasicVehicle* GetDefaultObj()
	{
		return GetDefaultObjImpl<ABFGBasicVehicle>();
	}
};
static_assert(alignof(ABFGBasicVehicle) == 0x000010, "Wrong alignment on ABFGBasicVehicle");
static_assert(sizeof(ABFGBasicVehicle) == 0x000CD0, "Wrong size on ABFGBasicVehicle");
static_assert(offsetof(ABFGBasicVehicle, M_pReplacementWheeledVehicle) == 0x000488, "Member 'ABFGBasicVehicle::M_pReplacementWheeledVehicle' has a wrong offset!");
static_assert(offsetof(ABFGBasicVehicle, M_pMesh) == 0x000490, "Member 'ABFGBasicVehicle::M_pMesh' has a wrong offset!");
static_assert(offsetof(ABFGBasicVehicle, M_pDefaultHealthBarClass) == 0x000498, "Member 'ABFGBasicVehicle::M_pDefaultHealthBarClass' has a wrong offset!");
static_assert(offsetof(ABFGBasicVehicle, M_fDefaultHealthBarZOffset) == 0x0004A0, "Member 'ABFGBasicVehicle::M_fDefaultHealthBarZOffset' has a wrong offset!");
static_assert(offsetof(ABFGBasicVehicle, M_pHealthBarComponent) == 0x0004A8, "Member 'ABFGBasicVehicle::M_pHealthBarComponent' has a wrong offset!");
static_assert(offsetof(ABFGBasicVehicle, M_pGameplayEffectTagsComponent) == 0x0004B0, "Member 'ABFGBasicVehicle::M_pGameplayEffectTagsComponent' has a wrong offset!");
static_assert(offsetof(ABFGBasicVehicle, M_gameplayTags) == 0x0004B8, "Member 'ABFGBasicVehicle::M_gameplayTags' has a wrong offset!");
static_assert(offsetof(ABFGBasicVehicle, LightBulbsMesh) == 0x0004D8, "Member 'ABFGBasicVehicle::LightBulbsMesh' has a wrong offset!");
static_assert(offsetof(ABFGBasicVehicle, FrontRightSpotLight) == 0x0004E0, "Member 'ABFGBasicVehicle::FrontRightSpotLight' has a wrong offset!");
static_assert(offsetof(ABFGBasicVehicle, FrontLeftSpotLight) == 0x0004E8, "Member 'ABFGBasicVehicle::FrontLeftSpotLight' has a wrong offset!");
static_assert(offsetof(ABFGBasicVehicle, ChildComponents) == 0x0004F0, "Member 'ABFGBasicVehicle::ChildComponents' has a wrong offset!");
static_assert(offsetof(ABFGBasicVehicle, Doors) == 0x000500, "Member 'ABFGBasicVehicle::Doors' has a wrong offset!");
static_assert(offsetof(ABFGBasicVehicle, GlassComponents) == 0x000510, "Member 'ABFGBasicVehicle::GlassComponents' has a wrong offset!");
static_assert(offsetof(ABFGBasicVehicle, M_CustomName) == 0x000520, "Member 'ABFGBasicVehicle::M_CustomName' has a wrong offset!");
static_assert(offsetof(ABFGBasicVehicle, Config) == 0x000530, "Member 'ABFGBasicVehicle::Config' has a wrong offset!");
static_assert(offsetof(ABFGBasicVehicle, M_aPlugins) == 0x0008E8, "Member 'ABFGBasicVehicle::M_aPlugins' has a wrong offset!");
static_assert(offsetof(ABFGBasicVehicle, DynamicMaterials) == 0x0008F8, "Member 'ABFGBasicVehicle::DynamicMaterials' has a wrong offset!");
static_assert(offsetof(ABFGBasicVehicle, LightBulbsMaterial) == 0x000908, "Member 'ABFGBasicVehicle::LightBulbsMaterial' has a wrong offset!");
static_assert(offsetof(ABFGBasicVehicle, M_pSirenMaterial) == 0x000910, "Member 'ABFGBasicVehicle::M_pSirenMaterial' has a wrong offset!");
static_assert(offsetof(ABFGBasicVehicle, M_faction) == 0x000918, "Member 'ABFGBasicVehicle::M_faction' has a wrong offset!");
static_assert(offsetof(ABFGBasicVehicle, M_pDamageComponent) == 0x000920, "Member 'ABFGBasicVehicle::M_pDamageComponent' has a wrong offset!");
static_assert(offsetof(ABFGBasicVehicle, M_pStatsComponent) == 0x000928, "Member 'ABFGBasicVehicle::M_pStatsComponent' has a wrong offset!");
static_assert(offsetof(ABFGBasicVehicle, M_pNetworkPathAgentComponent) == 0x000930, "Member 'ABFGBasicVehicle::M_pNetworkPathAgentComponent' has a wrong offset!");
static_assert(offsetof(ABFGBasicVehicle, M_pCrowdAgentInterfaceComponent) == 0x000938, "Member 'ABFGBasicVehicle::M_pCrowdAgentInterfaceComponent' has a wrong offset!");
static_assert(offsetof(ABFGBasicVehicle, M_pFallDamageComponent) == 0x000940, "Member 'ABFGBasicVehicle::M_pFallDamageComponent' has a wrong offset!");
static_assert(offsetof(ABFGBasicVehicle, M_pExplosiveComponent) == 0x000948, "Member 'ABFGBasicVehicle::M_pExplosiveComponent' has a wrong offset!");
static_assert(offsetof(ABFGBasicVehicle, M_pBuoyancyComponent) == 0x000950, "Member 'ABFGBasicVehicle::M_pBuoyancyComponent' has a wrong offset!");
static_assert(offsetof(ABFGBasicVehicle, M_bCarLightsOn) == 0x000958, "Member 'ABFGBasicVehicle::M_bCarLightsOn' has a wrong offset!");
static_assert(offsetof(ABFGBasicVehicle, M_bIsStaticVehicle) == 0x000959, "Member 'ABFGBasicVehicle::M_bIsStaticVehicle' has a wrong offset!");
static_assert(offsetof(ABFGBasicVehicle, M_iRequestedPalette) == 0x00095C, "Member 'ABFGBasicVehicle::M_iRequestedPalette' has a wrong offset!");
static_assert(offsetof(ABFGBasicVehicle, M_driveInfo) == 0x000960, "Member 'ABFGBasicVehicle::M_driveInfo' has a wrong offset!");
static_assert(offsetof(ABFGBasicVehicle, M_vehicleState) == 0x0009C0, "Member 'ABFGBasicVehicle::M_vehicleState' has a wrong offset!");
static_assert(offsetof(ABFGBasicVehicle, M_pMonetaryValueComponent) == 0x000A10, "Member 'ABFGBasicVehicle::M_pMonetaryValueComponent' has a wrong offset!");
static_assert(offsetof(ABFGBasicVehicle, M_pEffectComponent) == 0x000A18, "Member 'ABFGBasicVehicle::M_pEffectComponent' has a wrong offset!");
static_assert(offsetof(ABFGBasicVehicle, M_pMissionGameplayComponent) == 0x000A20, "Member 'ABFGBasicVehicle::M_pMissionGameplayComponent' has a wrong offset!");
static_assert(offsetof(ABFGBasicVehicle, M_fLastSpeed) == 0x000A28, "Member 'ABFGBasicVehicle::M_fLastSpeed' has a wrong offset!");
static_assert(offsetof(ABFGBasicVehicle, M_vLastNormal) == 0x000A2C, "Member 'ABFGBasicVehicle::M_vLastNormal' has a wrong offset!");
static_assert(offsetof(ABFGBasicVehicle, M_fLastZ) == 0x000A38, "Member 'ABFGBasicVehicle::M_fLastZ' has a wrong offset!");
static_assert(offsetof(ABFGBasicVehicle, M_vVirtualLocation) == 0x000A3C, "Member 'ABFGBasicVehicle::M_vVirtualLocation' has a wrong offset!");
static_assert(offsetof(ABFGBasicVehicle, M_vVirtualRotation) == 0x000A48, "Member 'ABFGBasicVehicle::M_vVirtualRotation' has a wrong offset!");
static_assert(offsetof(ABFGBasicVehicle, M_vSplineLocation) == 0x000A54, "Member 'ABFGBasicVehicle::M_vSplineLocation' has a wrong offset!");
static_assert(offsetof(ABFGBasicVehicle, M_bSetupDone) == 0x000A60, "Member 'ABFGBasicVehicle::M_bSetupDone' has a wrong offset!");
static_assert(offsetof(ABFGBasicVehicle, M_bIsPKed) == 0x000A61, "Member 'ABFGBasicVehicle::M_bIsPKed' has a wrong offset!");
static_assert(offsetof(ABFGBasicVehicle, M_bIsTransmogrifying) == 0x000A62, "Member 'ABFGBasicVehicle::M_bIsTransmogrifying' has a wrong offset!");
static_assert(offsetof(ABFGBasicVehicle, M_pCachedWheeledPhysicsAsset) == 0x000A68, "Member 'ABFGBasicVehicle::M_pCachedWheeledPhysicsAsset' has a wrong offset!");
static_assert(offsetof(ABFGBasicVehicle, M_pCachedNormalPhysicsAsset) == 0x000A70, "Member 'ABFGBasicVehicle::M_pCachedNormalPhysicsAsset' has a wrong offset!");
static_assert(offsetof(ABFGBasicVehicle, M_obstacleInFront) == 0x000A7C, "Member 'ABFGBasicVehicle::M_obstacleInFront' has a wrong offset!");
static_assert(offsetof(ABFGBasicVehicle, M_aRespawnInformationData) == 0x000B00, "Member 'ABFGBasicVehicle::M_aRespawnInformationData' has a wrong offset!");
static_assert(offsetof(ABFGBasicVehicle, M_bExplodesOnDeath) == 0x000B28, "Member 'ABFGBasicVehicle::M_bExplodesOnDeath' has a wrong offset!");
static_assert(offsetof(ABFGBasicVehicle, M_pLockOnTargetComponent) == 0x000B80, "Member 'ABFGBasicVehicle::M_pLockOnTargetComponent' has a wrong offset!");
static_assert(offsetof(ABFGBasicVehicle, M_pObjectiveMarkerParentComponent) == 0x000B88, "Member 'ABFGBasicVehicle::M_pObjectiveMarkerParentComponent' has a wrong offset!");
static_assert(offsetof(ABFGBasicVehicle, M_pObjectiveComponent) == 0x000B90, "Member 'ABFGBasicVehicle::M_pObjectiveComponent' has a wrong offset!");
static_assert(offsetof(ABFGBasicVehicle, M_pAITargetComponent) == 0x000B98, "Member 'ABFGBasicVehicle::M_pAITargetComponent' has a wrong offset!");
static_assert(offsetof(ABFGBasicVehicle, M_pHolobobSuppressionAuraComponent) == 0x000BA0, "Member 'ABFGBasicVehicle::M_pHolobobSuppressionAuraComponent' has a wrong offset!");
static_assert(offsetof(ABFGBasicVehicle, M_pCustomAnimationSequence) == 0x000BA8, "Member 'ABFGBasicVehicle::M_pCustomAnimationSequence' has a wrong offset!");
static_assert(offsetof(ABFGBasicVehicle, M_aCustomAnimationMaterialReplacements) == 0x000BB0, "Member 'ABFGBasicVehicle::M_aCustomAnimationMaterialReplacements' has a wrong offset!");
static_assert(offsetof(ABFGBasicVehicle, M_bHeightUseRayCastOnly) == 0x000BC0, "Member 'ABFGBasicVehicle::M_bHeightUseRayCastOnly' has a wrong offset!");
static_assert(offsetof(ABFGBasicVehicle, M_bUseCustomAnimMaterials) == 0x000BCC, "Member 'ABFGBasicVehicle::M_bUseCustomAnimMaterials' has a wrong offset!");
static_assert(offsetof(ABFGBasicVehicle, M_bImmuneToTransmog) == 0x000BD4, "Member 'ABFGBasicVehicle::M_bImmuneToTransmog' has a wrong offset!");
static_assert(offsetof(ABFGBasicVehicle, M_pAreaClass_IsStaticVehicle) == 0x000BD8, "Member 'ABFGBasicVehicle::M_pAreaClass_IsStaticVehicle' has a wrong offset!");
static_assert(offsetof(ABFGBasicVehicle, M_bUseVirtualVehicleAllowed) == 0x000BE0, "Member 'ABFGBasicVehicle::M_bUseVirtualVehicleAllowed' has a wrong offset!");
static_assert(offsetof(ABFGBasicVehicle, M_virtualVehicle) == 0x000BF0, "Member 'ABFGBasicVehicle::M_virtualVehicle' has a wrong offset!");
static_assert(offsetof(ABFGBasicVehicle, M_pCachedVehicleDeformation) == 0x000CC0, "Member 'ABFGBasicVehicle::M_pCachedVehicleDeformation' has a wrong offset!");
static_assert(offsetof(ABFGBasicVehicle, M_pGameState) == 0x000CC8, "Member 'ABFGBasicVehicle::M_pGameState' has a wrong offset!");

// Class BFGCore.BFGDataAsset_TutorialInputAction
// 0x0040 (0x0070 - 0x0030)
class UBFGDataAsset_TutorialInputAction final : public UDataAsset
{
public:
	class FName                                   M_actionName;                                      // 0x0030(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          M_bIsAxis;                                         // 0x0038(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_39[0x7];                                       // 0x0039(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	TSoftObjectPtr<class UBFGInputScheme>         M_pInputSchemeFallback;                            // 0x0040(0x0028)(Edit, BlueprintVisible, BlueprintReadOnly, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EInputSchemeIdentifier                        M_eInputSchemeIdentifier;                          // 0x0068(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EBFGInputActionWidgetType                     M_eInteractionTypeOverride;                        // 0x0069(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_6A[0x6];                                       // 0x006A(0x0006)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"BFGDataAsset_TutorialInputAction">();
	}
	static class UBFGDataAsset_TutorialInputAction* GetDefaultObj()
	{
		return GetDefaultObjImpl<UBFGDataAsset_TutorialInputAction>();
	}
};
static_assert(alignof(UBFGDataAsset_TutorialInputAction) == 0x000008, "Wrong alignment on UBFGDataAsset_TutorialInputAction");
static_assert(sizeof(UBFGDataAsset_TutorialInputAction) == 0x000070, "Wrong size on UBFGDataAsset_TutorialInputAction");
static_assert(offsetof(UBFGDataAsset_TutorialInputAction, M_actionName) == 0x000030, "Member 'UBFGDataAsset_TutorialInputAction::M_actionName' has a wrong offset!");
static_assert(offsetof(UBFGDataAsset_TutorialInputAction, M_bIsAxis) == 0x000038, "Member 'UBFGDataAsset_TutorialInputAction::M_bIsAxis' has a wrong offset!");
static_assert(offsetof(UBFGDataAsset_TutorialInputAction, M_pInputSchemeFallback) == 0x000040, "Member 'UBFGDataAsset_TutorialInputAction::M_pInputSchemeFallback' has a wrong offset!");
static_assert(offsetof(UBFGDataAsset_TutorialInputAction, M_eInputSchemeIdentifier) == 0x000068, "Member 'UBFGDataAsset_TutorialInputAction::M_eInputSchemeIdentifier' has a wrong offset!");
static_assert(offsetof(UBFGDataAsset_TutorialInputAction, M_eInteractionTypeOverride) == 0x000069, "Member 'UBFGDataAsset_TutorialInputAction::M_eInteractionTypeOverride' has a wrong offset!");

// Class BFGCore.BFGBasicVehicleTank
// 0x00A0 (0x0D70 - 0x0CD0)
class ABFGBasicVehicleTank : public ABFGBasicVehicle
{
public:
	uint8                                         Pad_CD0[0x8];                                      // 0x0CD0(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	class UBFGActorComponent_AimAssistTarget*     M_pAimAssistTargetComponent;                       // 0x0CD8(0x0008)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, EditConst, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UBFGActorComponent_EquipmentManager*    M_pEquipmentManager;                               // 0x0CE0(0x0008)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, EditConst, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	struct FSoftClassPath                         M_WeaponClass;                                     // 0x0CE8(0x0018)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, Protected, NativeAccessSpecifierProtected)
	class FName                                   M_strWeaponSocketName;                             // 0x0D00(0x0008)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         M_fTFrequence;                                     // 0x0D08(0x0004)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_D0C[0x4];                                      // 0x0D0C(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<class UBFGActorComponent_TankTrack*>   M_apTracks;                                        // 0x0D10(0x0010)(ExportObject, ZeroConstructor, Transient, ContainsInstancedReference, Protected, NativeAccessSpecifierProtected)
	struct FBFGTankInfo                           M_tankInfo;                                        // 0x0D20(0x0040)(Transient, NoDestructor, Protected, NativeAccessSpecifierProtected)
	uint8                                         Pad_D60[0x10];                                     // 0x0D60(0x0010)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void SetTrackUpdateFrequence(float _fNewTFrequence);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"BFGBasicVehicleTank">();
	}
	static class ABFGBasicVehicleTank* GetDefaultObj()
	{
		return GetDefaultObjImpl<ABFGBasicVehicleTank>();
	}
};
static_assert(alignof(ABFGBasicVehicleTank) == 0x000010, "Wrong alignment on ABFGBasicVehicleTank");
static_assert(sizeof(ABFGBasicVehicleTank) == 0x000D70, "Wrong size on ABFGBasicVehicleTank");
static_assert(offsetof(ABFGBasicVehicleTank, M_pAimAssistTargetComponent) == 0x000CD8, "Member 'ABFGBasicVehicleTank::M_pAimAssistTargetComponent' has a wrong offset!");
static_assert(offsetof(ABFGBasicVehicleTank, M_pEquipmentManager) == 0x000CE0, "Member 'ABFGBasicVehicleTank::M_pEquipmentManager' has a wrong offset!");
static_assert(offsetof(ABFGBasicVehicleTank, M_WeaponClass) == 0x000CE8, "Member 'ABFGBasicVehicleTank::M_WeaponClass' has a wrong offset!");
static_assert(offsetof(ABFGBasicVehicleTank, M_strWeaponSocketName) == 0x000D00, "Member 'ABFGBasicVehicleTank::M_strWeaponSocketName' has a wrong offset!");
static_assert(offsetof(ABFGBasicVehicleTank, M_fTFrequence) == 0x000D08, "Member 'ABFGBasicVehicleTank::M_fTFrequence' has a wrong offset!");
static_assert(offsetof(ABFGBasicVehicleTank, M_apTracks) == 0x000D10, "Member 'ABFGBasicVehicleTank::M_apTracks' has a wrong offset!");
static_assert(offsetof(ABFGBasicVehicleTank, M_tankInfo) == 0x000D20, "Member 'ABFGBasicVehicleTank::M_tankInfo' has a wrong offset!");

// Class BFGCore.BFGDecorator_BlackboardBool
// 0x0008 (0x00C8 - 0x00C0)
class UBFGDecorator_BlackboardBool final : public UBTDecorator_Blackboard
{
public:
	bool                                          M_bBoolValue;                                      // 0x00C0(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_C1[0x7];                                       // 0x00C1(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"BFGDecorator_BlackboardBool">();
	}
	static class UBFGDecorator_BlackboardBool* GetDefaultObj()
	{
		return GetDefaultObjImpl<UBFGDecorator_BlackboardBool>();
	}
};
static_assert(alignof(UBFGDecorator_BlackboardBool) == 0x000008, "Wrong alignment on UBFGDecorator_BlackboardBool");
static_assert(sizeof(UBFGDecorator_BlackboardBool) == 0x0000C8, "Wrong size on UBFGDecorator_BlackboardBool");
static_assert(offsetof(UBFGDecorator_BlackboardBool, M_bBoolValue) == 0x0000C0, "Member 'UBFGDecorator_BlackboardBool::M_bBoolValue' has a wrong offset!");

// Class BFGCore.BFGBendableAntenna
// 0x0010 (0x03E8 - 0x03D8)
class ABFGBendableAntenna final : public AActor
{
public:
	class UBFGActorComponent_MentallyInteractable* M_pMentallyInteractableComponent;                  // 0x03D8(0x0008)(Edit, ExportObject, ZeroConstructor, EditConst, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          M_bIsBent;                                         // 0x03E0(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_3E1[0x7];                                      // 0x03E1(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void HandleMentallyInteractabledUse(class UBFGActorComponent_MentallyInteractable* _pMentallyInteractable, class AController* _pController);
	void OnBend();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"BFGBendableAntenna">();
	}
	static class ABFGBendableAntenna* GetDefaultObj()
	{
		return GetDefaultObjImpl<ABFGBendableAntenna>();
	}
};
static_assert(alignof(ABFGBendableAntenna) == 0x000008, "Wrong alignment on ABFGBendableAntenna");
static_assert(sizeof(ABFGBendableAntenna) == 0x0003E8, "Wrong size on ABFGBendableAntenna");
static_assert(offsetof(ABFGBendableAntenna, M_pMentallyInteractableComponent) == 0x0003D8, "Member 'ABFGBendableAntenna::M_pMentallyInteractableComponent' has a wrong offset!");
static_assert(offsetof(ABFGBendableAntenna, M_bIsBent) == 0x0003E0, "Member 'ABFGBendableAntenna::M_bIsBent' has a wrong offset!");

// Class BFGCore.BFGGameFlowState_Gameplay
// 0x0000 (0x0068 - 0x0068)
class UBFGGameFlowState_Gameplay final : public UBFGGameFlowState
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"BFGGameFlowState_Gameplay">();
	}
	static class UBFGGameFlowState_Gameplay* GetDefaultObj()
	{
		return GetDefaultObjImpl<UBFGGameFlowState_Gameplay>();
	}
};
static_assert(alignof(UBFGGameFlowState_Gameplay) == 0x000008, "Wrong alignment on UBFGGameFlowState_Gameplay");
static_assert(sizeof(UBFGGameFlowState_Gameplay) == 0x000068, "Wrong size on UBFGGameFlowState_Gameplay");

// Class BFGCore.BFGBombTruckInterface
// 0x0000 (0x0028 - 0x0028)
class IBFGBombTruckInterface final : public IInterface
{
public:
	class FString GetBombTruckTimerAsString();
	void SetBombTruckTimerEnabled(bool _bEnabled);

	bool IsBombTruckTimerEnabled() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"BFGBombTruckInterface">();
	}
	static class IBFGBombTruckInterface* GetDefaultObj()
	{
		return GetDefaultObjImpl<IBFGBombTruckInterface>();
	}
};
static_assert(alignof(IBFGBombTruckInterface) == 0x000008, "Wrong alignment on IBFGBombTruckInterface");
static_assert(sizeof(IBFGBombTruckInterface) == 0x000028, "Wrong size on IBFGBombTruckInterface");

// Class BFGCore.BFGProjectile_PulseField
// 0x0058 (0x06D0 - 0x0678)
class ABFGProjectile_PulseField : public ABFGProjectile_Object
{
public:
	float                                         M_fPulseDelay;                                     // 0x0678(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         M_fPulseInterval;                                  // 0x067C(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         M_fPulseExpansionSpeed;                            // 0x0680(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         M_fPulseThickness;                                 // 0x0684(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         M_fPulseHeight;                                    // 0x0688(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	int32                                         M_iPulseChargeCount;                               // 0x068C(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         M_fMaxPulseRadius;                                 // 0x0690(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	struct FVector                                M_vPulseOffset;                                    // 0x0694(0x000C)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          M_bAutoPulse;                                      // 0x06A0(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          M_bDestroyWhenFinishedPulsing;                     // 0x06A1(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_6A2[0x2];                                      // 0x06A2(0x0002)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         M_fPulseDamage;                                    // 0x06A4(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          M_bApplyDamageToFriendlyActors;                    // 0x06A8(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          M_bDamageInterruptsMentalAbilities;                // 0x06A9(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_6AA[0x2];                                      // 0x06AA(0x0002)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         M_fLifetimeAfterPulses;                            // 0x06AC(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          M_bIsPulsing;                                      // 0x06B0(0x0001)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_6B1[0x3];                                      // 0x06B1(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         M_fPulseTimer;                                     // 0x06B4(0x0004)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TArray<struct FBFGPulseFieldPulseData>        M_aPulseData;                                      // 0x06B8(0x0010)(ZeroConstructor, Transient, ContainsInstancedReference, Protected, NativeAccessSpecifierProtected)
	int32                                         M_iCurrentPulseCount;                              // 0x06C8(0x0004)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         M_fCurrentLifetimeAfterPulses;                     // 0x06CC(0x0004)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)

public:
	void OnPulse();
	void OnPulseEnter(const struct FBFGPulseActorData& _rData);
	void OnPulseExit(const struct FBFGPulseActorData& _rData);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"BFGProjectile_PulseField">();
	}
	static class ABFGProjectile_PulseField* GetDefaultObj()
	{
		return GetDefaultObjImpl<ABFGProjectile_PulseField>();
	}
};
static_assert(alignof(ABFGProjectile_PulseField) == 0x000008, "Wrong alignment on ABFGProjectile_PulseField");
static_assert(sizeof(ABFGProjectile_PulseField) == 0x0006D0, "Wrong size on ABFGProjectile_PulseField");
static_assert(offsetof(ABFGProjectile_PulseField, M_fPulseDelay) == 0x000678, "Member 'ABFGProjectile_PulseField::M_fPulseDelay' has a wrong offset!");
static_assert(offsetof(ABFGProjectile_PulseField, M_fPulseInterval) == 0x00067C, "Member 'ABFGProjectile_PulseField::M_fPulseInterval' has a wrong offset!");
static_assert(offsetof(ABFGProjectile_PulseField, M_fPulseExpansionSpeed) == 0x000680, "Member 'ABFGProjectile_PulseField::M_fPulseExpansionSpeed' has a wrong offset!");
static_assert(offsetof(ABFGProjectile_PulseField, M_fPulseThickness) == 0x000684, "Member 'ABFGProjectile_PulseField::M_fPulseThickness' has a wrong offset!");
static_assert(offsetof(ABFGProjectile_PulseField, M_fPulseHeight) == 0x000688, "Member 'ABFGProjectile_PulseField::M_fPulseHeight' has a wrong offset!");
static_assert(offsetof(ABFGProjectile_PulseField, M_iPulseChargeCount) == 0x00068C, "Member 'ABFGProjectile_PulseField::M_iPulseChargeCount' has a wrong offset!");
static_assert(offsetof(ABFGProjectile_PulseField, M_fMaxPulseRadius) == 0x000690, "Member 'ABFGProjectile_PulseField::M_fMaxPulseRadius' has a wrong offset!");
static_assert(offsetof(ABFGProjectile_PulseField, M_vPulseOffset) == 0x000694, "Member 'ABFGProjectile_PulseField::M_vPulseOffset' has a wrong offset!");
static_assert(offsetof(ABFGProjectile_PulseField, M_bAutoPulse) == 0x0006A0, "Member 'ABFGProjectile_PulseField::M_bAutoPulse' has a wrong offset!");
static_assert(offsetof(ABFGProjectile_PulseField, M_bDestroyWhenFinishedPulsing) == 0x0006A1, "Member 'ABFGProjectile_PulseField::M_bDestroyWhenFinishedPulsing' has a wrong offset!");
static_assert(offsetof(ABFGProjectile_PulseField, M_fPulseDamage) == 0x0006A4, "Member 'ABFGProjectile_PulseField::M_fPulseDamage' has a wrong offset!");
static_assert(offsetof(ABFGProjectile_PulseField, M_bApplyDamageToFriendlyActors) == 0x0006A8, "Member 'ABFGProjectile_PulseField::M_bApplyDamageToFriendlyActors' has a wrong offset!");
static_assert(offsetof(ABFGProjectile_PulseField, M_bDamageInterruptsMentalAbilities) == 0x0006A9, "Member 'ABFGProjectile_PulseField::M_bDamageInterruptsMentalAbilities' has a wrong offset!");
static_assert(offsetof(ABFGProjectile_PulseField, M_fLifetimeAfterPulses) == 0x0006AC, "Member 'ABFGProjectile_PulseField::M_fLifetimeAfterPulses' has a wrong offset!");
static_assert(offsetof(ABFGProjectile_PulseField, M_bIsPulsing) == 0x0006B0, "Member 'ABFGProjectile_PulseField::M_bIsPulsing' has a wrong offset!");
static_assert(offsetof(ABFGProjectile_PulseField, M_fPulseTimer) == 0x0006B4, "Member 'ABFGProjectile_PulseField::M_fPulseTimer' has a wrong offset!");
static_assert(offsetof(ABFGProjectile_PulseField, M_aPulseData) == 0x0006B8, "Member 'ABFGProjectile_PulseField::M_aPulseData' has a wrong offset!");
static_assert(offsetof(ABFGProjectile_PulseField, M_iCurrentPulseCount) == 0x0006C8, "Member 'ABFGProjectile_PulseField::M_iCurrentPulseCount' has a wrong offset!");
static_assert(offsetof(ABFGProjectile_PulseField, M_fCurrentLifetimeAfterPulses) == 0x0006CC, "Member 'ABFGProjectile_PulseField::M_fCurrentLifetimeAfterPulses' has a wrong offset!");

// Class BFGCore.BFGProjectile_PsiGrenade
// 0x0018 (0x06E8 - 0x06D0)
class ABFGProjectile_PsiGrenade final : public ABFGProjectile_PulseField
{
public:
	float                                         M_fFuseTime;                                       // 0x06D0(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         M_fFuseTimer;                                      // 0x06D4(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TSubclassOf<class ABFGEffectActor>            M_pEffectTelegraphClass;                           // 0x06D8(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class ABFGEffectActor*                        M_pEffectTelegraphComp;                            // 0x06E0(0x0008)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)

public:
	void OnFuseDone();
	void OnFuseUpdated();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"BFGProjectile_PsiGrenade">();
	}
	static class ABFGProjectile_PsiGrenade* GetDefaultObj()
	{
		return GetDefaultObjImpl<ABFGProjectile_PsiGrenade>();
	}
};
static_assert(alignof(ABFGProjectile_PsiGrenade) == 0x000008, "Wrong alignment on ABFGProjectile_PsiGrenade");
static_assert(sizeof(ABFGProjectile_PsiGrenade) == 0x0006E8, "Wrong size on ABFGProjectile_PsiGrenade");
static_assert(offsetof(ABFGProjectile_PsiGrenade, M_fFuseTime) == 0x0006D0, "Member 'ABFGProjectile_PsiGrenade::M_fFuseTime' has a wrong offset!");
static_assert(offsetof(ABFGProjectile_PsiGrenade, M_fFuseTimer) == 0x0006D4, "Member 'ABFGProjectile_PsiGrenade::M_fFuseTimer' has a wrong offset!");
static_assert(offsetof(ABFGProjectile_PsiGrenade, M_pEffectTelegraphClass) == 0x0006D8, "Member 'ABFGProjectile_PsiGrenade::M_pEffectTelegraphClass' has a wrong offset!");
static_assert(offsetof(ABFGProjectile_PsiGrenade, M_pEffectTelegraphComp) == 0x0006E0, "Member 'ABFGProjectile_PsiGrenade::M_pEffectTelegraphComp' has a wrong offset!");

// Class BFGCore.BFGVariableType
// 0x0068 (0x0090 - 0x0028)
class UBFGVariableType : public UObject
{
public:
	struct FGuid                                  M_guid;                                            // 0x0028(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   M_strTypeName;                                     // 0x0038(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TMap<int32, class FName>                      M_aValueSet;                                       // 0x0040(0x0050)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"BFGVariableType">();
	}
	static class UBFGVariableType* GetDefaultObj()
	{
		return GetDefaultObjImpl<UBFGVariableType>();
	}
};
static_assert(alignof(UBFGVariableType) == 0x000008, "Wrong alignment on UBFGVariableType");
static_assert(sizeof(UBFGVariableType) == 0x000090, "Wrong size on UBFGVariableType");
static_assert(offsetof(UBFGVariableType, M_guid) == 0x000028, "Member 'UBFGVariableType::M_guid' has a wrong offset!");
static_assert(offsetof(UBFGVariableType, M_strTypeName) == 0x000038, "Member 'UBFGVariableType::M_strTypeName' has a wrong offset!");
static_assert(offsetof(UBFGVariableType, M_aValueSet) == 0x000040, "Member 'UBFGVariableType::M_aValueSet' has a wrong offset!");

// Class BFGCore.BFGVariableType_Dialog
// 0x0000 (0x0090 - 0x0090)
class UBFGVariableType_Dialog final : public UBFGVariableType
{
public:
	static const class FName GetState_DialogFinishedDoMultiple();
	static const class FName GetState_DialogFinishedDoOnce();
	static const class FName GetState_DialogNewDoMultiple();
	static const class FName GetState_DialogNewDoOnce();
	static const class FName GetTypeName_Dialog();
	static TArray<class FName> GetValueNamesForFinished();
	static TArray<class FName> GetValueNamesForNew();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"BFGVariableType_Dialog">();
	}
	static class UBFGVariableType_Dialog* GetDefaultObj()
	{
		return GetDefaultObjImpl<UBFGVariableType_Dialog>();
	}
};
static_assert(alignof(UBFGVariableType_Dialog) == 0x000008, "Wrong alignment on UBFGVariableType_Dialog");
static_assert(sizeof(UBFGVariableType_Dialog) == 0x000090, "Wrong size on UBFGVariableType_Dialog");

// Class BFGCore.BFGDecorator_InRange
// 0x0038 (0x00A8 - 0x0070)
class UBFGDecorator_InRange final : public UBFGBTBaseDecorator
{
public:
	struct FBlackboardKeySelector                 M_BBKey;                                           // 0x0070(0x0028)(Edit, NativeAccessSpecifierPublic)
	float                                         M_fMinRange;                                       // 0x0098(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         M_fMaxRange;                                       // 0x009C(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          M_fUse2DDistance;                                  // 0x00A0(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_A1[0x7];                                       // 0x00A1(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"BFGDecorator_InRange">();
	}
	static class UBFGDecorator_InRange* GetDefaultObj()
	{
		return GetDefaultObjImpl<UBFGDecorator_InRange>();
	}
};
static_assert(alignof(UBFGDecorator_InRange) == 0x000008, "Wrong alignment on UBFGDecorator_InRange");
static_assert(sizeof(UBFGDecorator_InRange) == 0x0000A8, "Wrong size on UBFGDecorator_InRange");
static_assert(offsetof(UBFGDecorator_InRange, M_BBKey) == 0x000070, "Member 'UBFGDecorator_InRange::M_BBKey' has a wrong offset!");
static_assert(offsetof(UBFGDecorator_InRange, M_fMinRange) == 0x000098, "Member 'UBFGDecorator_InRange::M_fMinRange' has a wrong offset!");
static_assert(offsetof(UBFGDecorator_InRange, M_fMaxRange) == 0x00009C, "Member 'UBFGDecorator_InRange::M_fMaxRange' has a wrong offset!");
static_assert(offsetof(UBFGDecorator_InRange, M_fUse2DDistance) == 0x0000A0, "Member 'UBFGDecorator_InRange::M_fUse2DDistance' has a wrong offset!");

// Class BFGCore.BFGBoss_TransitionPath
// 0x0010 (0x03E8 - 0x03D8)
class ABFGBoss_TransitionPath final : public AActor
{
public:
	int32                                         M_iRelatedPhase;                                   // 0x03D8(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_3DC[0x4];                                      // 0x03DC(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class USplineComponent*                       M_pPathSpline;                                     // 0x03E0(0x0008)(Edit, ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"BFGBoss_TransitionPath">();
	}
	static class ABFGBoss_TransitionPath* GetDefaultObj()
	{
		return GetDefaultObjImpl<ABFGBoss_TransitionPath>();
	}
};
static_assert(alignof(ABFGBoss_TransitionPath) == 0x000008, "Wrong alignment on ABFGBoss_TransitionPath");
static_assert(sizeof(ABFGBoss_TransitionPath) == 0x0003E8, "Wrong size on ABFGBoss_TransitionPath");
static_assert(offsetof(ABFGBoss_TransitionPath, M_iRelatedPhase) == 0x0003D8, "Member 'ABFGBoss_TransitionPath::M_iRelatedPhase' has a wrong offset!");
static_assert(offsetof(ABFGBoss_TransitionPath, M_pPathSpline) == 0x0003E0, "Member 'ABFGBoss_TransitionPath::M_pPathSpline' has a wrong offset!");

// Class BFGCore.BFGNetworkPathAgent_Move
// 0x0618 (0x0640 - 0x0028)
#pragma pack(push, 0x1)
class alignas(0x10) UBFGNetworkPathAgent_Move : public UObject
{
public:
	class UBFGNetworkPathAgent*                   M_pAgent;                                          // 0x0028(0x0008)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         M_fSpeed;                                          // 0x0030(0x0004)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         M_fCurrentTargetSpeed;                             // 0x0034(0x0004)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	struct FBFGNetworkPathAgentBlending           M_blending;                                        // 0x0038(0x0054)(Transient, NoDestructor, Protected, NativeAccessSpecifierProtected)
	uint8                                         Pad_8C[0x4];                                       // 0x008C(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	struct FBFGMoveAlongCurve                     M_moveAlongCurve;                                  // 0x0090(0x0590)(Transient, Protected, NativeAccessSpecifierProtected)
	EBFGNetworkAgentPathCenterMode                M_ePathCenterMode;                                 // 0x0620(0x0001)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_621[0x3];                                      // 0x0621(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         M_fAdditionalOffsetFromCenter;                     // 0x0624(0x0004)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UBFGNetworkPathAgent*                   M_pOvertakingAgent;                                // 0x0628(0x0008)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UBFGNetworkPathAgent*                   M_pFaceToFaceAgent;                                // 0x0630(0x0008)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"BFGNetworkPathAgent_Move">();
	}
	static class UBFGNetworkPathAgent_Move* GetDefaultObj()
	{
		return GetDefaultObjImpl<UBFGNetworkPathAgent_Move>();
	}
};
#pragma pack(pop)
static_assert(alignof(UBFGNetworkPathAgent_Move) == 0x000010, "Wrong alignment on UBFGNetworkPathAgent_Move");
static_assert(sizeof(UBFGNetworkPathAgent_Move) == 0x000640, "Wrong size on UBFGNetworkPathAgent_Move");
static_assert(offsetof(UBFGNetworkPathAgent_Move, M_pAgent) == 0x000028, "Member 'UBFGNetworkPathAgent_Move::M_pAgent' has a wrong offset!");
static_assert(offsetof(UBFGNetworkPathAgent_Move, M_fSpeed) == 0x000030, "Member 'UBFGNetworkPathAgent_Move::M_fSpeed' has a wrong offset!");
static_assert(offsetof(UBFGNetworkPathAgent_Move, M_fCurrentTargetSpeed) == 0x000034, "Member 'UBFGNetworkPathAgent_Move::M_fCurrentTargetSpeed' has a wrong offset!");
static_assert(offsetof(UBFGNetworkPathAgent_Move, M_blending) == 0x000038, "Member 'UBFGNetworkPathAgent_Move::M_blending' has a wrong offset!");
static_assert(offsetof(UBFGNetworkPathAgent_Move, M_moveAlongCurve) == 0x000090, "Member 'UBFGNetworkPathAgent_Move::M_moveAlongCurve' has a wrong offset!");
static_assert(offsetof(UBFGNetworkPathAgent_Move, M_ePathCenterMode) == 0x000620, "Member 'UBFGNetworkPathAgent_Move::M_ePathCenterMode' has a wrong offset!");
static_assert(offsetof(UBFGNetworkPathAgent_Move, M_fAdditionalOffsetFromCenter) == 0x000624, "Member 'UBFGNetworkPathAgent_Move::M_fAdditionalOffsetFromCenter' has a wrong offset!");
static_assert(offsetof(UBFGNetworkPathAgent_Move, M_pOvertakingAgent) == 0x000628, "Member 'UBFGNetworkPathAgent_Move::M_pOvertakingAgent' has a wrong offset!");
static_assert(offsetof(UBFGNetworkPathAgent_Move, M_pFaceToFaceAgent) == 0x000630, "Member 'UBFGNetworkPathAgent_Move::M_pFaceToFaceAgent' has a wrong offset!");

// Class BFGCore.BFGBoss_TriggerBox
// 0x0000 (0x03E0 - 0x03E0)
class ABFGBoss_TriggerBox final : public ATriggerBox
{
public:
	void OnBeginOverlap(class AActor* _pOverlappedActor, class AActor* _pOtherActor);
	void OnEndOverlap(class AActor* _pOverlappedActor, class AActor* _pOtherActor);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"BFGBoss_TriggerBox">();
	}
	static class ABFGBoss_TriggerBox* GetDefaultObj()
	{
		return GetDefaultObjImpl<ABFGBoss_TriggerBox>();
	}
};
static_assert(alignof(ABFGBoss_TriggerBox) == 0x000008, "Wrong alignment on ABFGBoss_TriggerBox");
static_assert(sizeof(ABFGBoss_TriggerBox) == 0x0003E0, "Wrong size on ABFGBoss_TriggerBox");

// Class BFGCore.BFGBossHealthHUDManager
// 0x0020 (0x0050 - 0x0030)
class UBFGBossHealthHUDManager final : public UBFGGameSystem
{
public:
	class UBFGWidget_HUD_BossHealthbar*           M_pCurrentBossHealthBar;                           // 0x0030(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class ABFGGameState*                          M_pCurrentGameState;                               // 0x0038(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class ABFGNPCCharacterBoss*                   M_pCurrentBossCharacter;                           // 0x0040(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          M_bPhaseRegistered;                                // 0x0048(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_49[0x7];                                       // 0x0049(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	class ABFGNPCCharacterBoss* GetCurrentBossChracter() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"BFGBossHealthHUDManager">();
	}
	static class UBFGBossHealthHUDManager* GetDefaultObj()
	{
		return GetDefaultObjImpl<UBFGBossHealthHUDManager>();
	}
};
static_assert(alignof(UBFGBossHealthHUDManager) == 0x000008, "Wrong alignment on UBFGBossHealthHUDManager");
static_assert(sizeof(UBFGBossHealthHUDManager) == 0x000050, "Wrong size on UBFGBossHealthHUDManager");
static_assert(offsetof(UBFGBossHealthHUDManager, M_pCurrentBossHealthBar) == 0x000030, "Member 'UBFGBossHealthHUDManager::M_pCurrentBossHealthBar' has a wrong offset!");
static_assert(offsetof(UBFGBossHealthHUDManager, M_pCurrentGameState) == 0x000038, "Member 'UBFGBossHealthHUDManager::M_pCurrentGameState' has a wrong offset!");
static_assert(offsetof(UBFGBossHealthHUDManager, M_pCurrentBossCharacter) == 0x000040, "Member 'UBFGBossHealthHUDManager::M_pCurrentBossCharacter' has a wrong offset!");
static_assert(offsetof(UBFGBossHealthHUDManager, M_bPhaseRegistered) == 0x000048, "Member 'UBFGBossHealthHUDManager::M_bPhaseRegistered' has a wrong offset!");

// Class BFGCore.BFGMothershipTransitionManager
// 0x00B8 (0x00E8 - 0x0030)
class UBFGMothershipTransitionManager : public UBFGGameSystem
{
public:
	UMulticastDelegateProperty_                   M_OnLayerIndexChanged;                             // 0x0030(0x0018)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	UMulticastDelegateProperty_                   M_OnSubRoomChanged;                                // 0x0048(0x0018)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	UMulticastDelegateProperty_                   M_OnLerpPositionChanged;                           // 0x0060(0x0018)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	UMulticastDelegateProperty_                   M_OnPlayerRotation;                                // 0x0078(0x0018)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	UMulticastDelegateProperty_                   M_OnBackgroundEnabled;                             // 0x0090(0x0018)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	UMulticastDelegateProperty_                   M_OnHaltPoxNarrative;                              // 0x00A8(0x0018)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	float                                         M_fLerpSpeed;                                      // 0x00C0(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	EBFGMothershipTransitionMethod                M_eInterpolationMethod;                            // 0x00C4(0x0001)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_C5[0x3];                                       // 0x00C5(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	class UCurveFloat*                            M_pCustomInterpolationCurve;                       // 0x00C8(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_D0[0x18];                                      // 0x00D0(0x0018)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"BFGMothershipTransitionManager">();
	}
	static class UBFGMothershipTransitionManager* GetDefaultObj()
	{
		return GetDefaultObjImpl<UBFGMothershipTransitionManager>();
	}
};
static_assert(alignof(UBFGMothershipTransitionManager) == 0x000008, "Wrong alignment on UBFGMothershipTransitionManager");
static_assert(sizeof(UBFGMothershipTransitionManager) == 0x0000E8, "Wrong size on UBFGMothershipTransitionManager");
static_assert(offsetof(UBFGMothershipTransitionManager, M_OnLayerIndexChanged) == 0x000030, "Member 'UBFGMothershipTransitionManager::M_OnLayerIndexChanged' has a wrong offset!");
static_assert(offsetof(UBFGMothershipTransitionManager, M_OnSubRoomChanged) == 0x000048, "Member 'UBFGMothershipTransitionManager::M_OnSubRoomChanged' has a wrong offset!");
static_assert(offsetof(UBFGMothershipTransitionManager, M_OnLerpPositionChanged) == 0x000060, "Member 'UBFGMothershipTransitionManager::M_OnLerpPositionChanged' has a wrong offset!");
static_assert(offsetof(UBFGMothershipTransitionManager, M_OnPlayerRotation) == 0x000078, "Member 'UBFGMothershipTransitionManager::M_OnPlayerRotation' has a wrong offset!");
static_assert(offsetof(UBFGMothershipTransitionManager, M_OnBackgroundEnabled) == 0x000090, "Member 'UBFGMothershipTransitionManager::M_OnBackgroundEnabled' has a wrong offset!");
static_assert(offsetof(UBFGMothershipTransitionManager, M_OnHaltPoxNarrative) == 0x0000A8, "Member 'UBFGMothershipTransitionManager::M_OnHaltPoxNarrative' has a wrong offset!");
static_assert(offsetof(UBFGMothershipTransitionManager, M_fLerpSpeed) == 0x0000C0, "Member 'UBFGMothershipTransitionManager::M_fLerpSpeed' has a wrong offset!");
static_assert(offsetof(UBFGMothershipTransitionManager, M_eInterpolationMethod) == 0x0000C4, "Member 'UBFGMothershipTransitionManager::M_eInterpolationMethod' has a wrong offset!");
static_assert(offsetof(UBFGMothershipTransitionManager, M_pCustomInterpolationCurve) == 0x0000C8, "Member 'UBFGMothershipTransitionManager::M_pCustomInterpolationCurve' has a wrong offset!");

// Class BFGCore.BFGBossReinforcementSpawner
// 0x00E0 (0x04B8 - 0x03D8)
class ABFGBossReinforcementSpawner : public AActor
{
public:
	uint8                                         Pad_3D8[0x1];                                      // 0x03D8(0x0001)(Fixing Size After Last Property [ Dumper-7 ])
	EReinforcementType                            M_eSpawnerType;                                    // 0x03D9(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          M_bJoinTraffic;                                    // 0x03DA(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_3DB[0x1];                                      // 0x03DB(0x0001)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         M_fProbabilityToSpawn;                             // 0x03DC(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         M_fReinforcementThreatValue;                       // 0x03E0(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	int32                                         M_iActiveBossPhase;                                // 0x03E4(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TArray<TSoftObjectPtr<class AActor>>          M_aspVisibilityProxies;                            // 0x03E8(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Protected, UObjectWrapper, NativeAccessSpecifierProtected)
	TSubclassOf<class AActor>                     M_pNPCClass;                                       // 0x03F8(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	struct FBFGAgentAIData                        M_agentAIData;                                     // 0x0400(0x00B0)(Edit, BlueprintVisible, BlueprintReadOnly, ContainsInstancedReference, Protected, NativeAccessSpecifierProtected)
	class ABFGNPCCharacterBoss*                   M_pOwnerCharacterBoss;                             // 0x04B0(0x0008)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)

public:
	void OnReinforcementDeathStatChanged(class AActor* _pActor, class UBFGActorStat_Bool* _pStat);
	void SetActive(bool _bActive);
	class AActor* TrySpawnNPC(bool _bAdjustSpawnLocation);

	bool IsActive() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"BFGBossReinforcementSpawner">();
	}
	static class ABFGBossReinforcementSpawner* GetDefaultObj()
	{
		return GetDefaultObjImpl<ABFGBossReinforcementSpawner>();
	}
};
static_assert(alignof(ABFGBossReinforcementSpawner) == 0x000008, "Wrong alignment on ABFGBossReinforcementSpawner");
static_assert(sizeof(ABFGBossReinforcementSpawner) == 0x0004B8, "Wrong size on ABFGBossReinforcementSpawner");
static_assert(offsetof(ABFGBossReinforcementSpawner, M_eSpawnerType) == 0x0003D9, "Member 'ABFGBossReinforcementSpawner::M_eSpawnerType' has a wrong offset!");
static_assert(offsetof(ABFGBossReinforcementSpawner, M_bJoinTraffic) == 0x0003DA, "Member 'ABFGBossReinforcementSpawner::M_bJoinTraffic' has a wrong offset!");
static_assert(offsetof(ABFGBossReinforcementSpawner, M_fProbabilityToSpawn) == 0x0003DC, "Member 'ABFGBossReinforcementSpawner::M_fProbabilityToSpawn' has a wrong offset!");
static_assert(offsetof(ABFGBossReinforcementSpawner, M_fReinforcementThreatValue) == 0x0003E0, "Member 'ABFGBossReinforcementSpawner::M_fReinforcementThreatValue' has a wrong offset!");
static_assert(offsetof(ABFGBossReinforcementSpawner, M_iActiveBossPhase) == 0x0003E4, "Member 'ABFGBossReinforcementSpawner::M_iActiveBossPhase' has a wrong offset!");
static_assert(offsetof(ABFGBossReinforcementSpawner, M_aspVisibilityProxies) == 0x0003E8, "Member 'ABFGBossReinforcementSpawner::M_aspVisibilityProxies' has a wrong offset!");
static_assert(offsetof(ABFGBossReinforcementSpawner, M_pNPCClass) == 0x0003F8, "Member 'ABFGBossReinforcementSpawner::M_pNPCClass' has a wrong offset!");
static_assert(offsetof(ABFGBossReinforcementSpawner, M_agentAIData) == 0x000400, "Member 'ABFGBossReinforcementSpawner::M_agentAIData' has a wrong offset!");
static_assert(offsetof(ABFGBossReinforcementSpawner, M_pOwnerCharacterBoss) == 0x0004B0, "Member 'ABFGBossReinforcementSpawner::M_pOwnerCharacterBoss' has a wrong offset!");

// Class BFGCore.BFGClothEnvironmentObject
// 0x0030 (0x0408 - 0x03D8)
class ABFGClothEnvironmentObject : public AActor
{
public:
	class USkeletalMeshComponent*                 M_pSkeletalClothMesh;                              // 0x03D8(0x0008)(Edit, BlueprintVisible, ExportObject, ZeroConstructor, DisableEditOnInstance, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UStaticMeshComponent*                   M_pStaticClothMesh;                                // 0x03E0(0x0008)(Edit, BlueprintVisible, ExportObject, ZeroConstructor, DisableEditOnInstance, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         M_fWakeUpDistance;                                 // 0x03E8(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         M_fCheckFrequency;                                 // 0x03EC(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         M_fFadeSpeed;                                      // 0x03F0(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_3F4[0x4];                                      // 0x03F4(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class UBFGClothAnimInstance*                  M_pAnimInstance;                                   // 0x03F8(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_400[0x8];                                      // 0x0400(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"BFGClothEnvironmentObject">();
	}
	static class ABFGClothEnvironmentObject* GetDefaultObj()
	{
		return GetDefaultObjImpl<ABFGClothEnvironmentObject>();
	}
};
static_assert(alignof(ABFGClothEnvironmentObject) == 0x000008, "Wrong alignment on ABFGClothEnvironmentObject");
static_assert(sizeof(ABFGClothEnvironmentObject) == 0x000408, "Wrong size on ABFGClothEnvironmentObject");
static_assert(offsetof(ABFGClothEnvironmentObject, M_pSkeletalClothMesh) == 0x0003D8, "Member 'ABFGClothEnvironmentObject::M_pSkeletalClothMesh' has a wrong offset!");
static_assert(offsetof(ABFGClothEnvironmentObject, M_pStaticClothMesh) == 0x0003E0, "Member 'ABFGClothEnvironmentObject::M_pStaticClothMesh' has a wrong offset!");
static_assert(offsetof(ABFGClothEnvironmentObject, M_fWakeUpDistance) == 0x0003E8, "Member 'ABFGClothEnvironmentObject::M_fWakeUpDistance' has a wrong offset!");
static_assert(offsetof(ABFGClothEnvironmentObject, M_fCheckFrequency) == 0x0003EC, "Member 'ABFGClothEnvironmentObject::M_fCheckFrequency' has a wrong offset!");
static_assert(offsetof(ABFGClothEnvironmentObject, M_fFadeSpeed) == 0x0003F0, "Member 'ABFGClothEnvironmentObject::M_fFadeSpeed' has a wrong offset!");
static_assert(offsetof(ABFGClothEnvironmentObject, M_pAnimInstance) == 0x0003F8, "Member 'ABFGClothEnvironmentObject::M_pAnimInstance' has a wrong offset!");

// Class BFGCore.BFGWidget_Overhead
// 0x0000 (0x02F8 - 0x02F8)
class UBFGWidget_Overhead : public UBFGWidget_HUD
{
public:
	void SetRichTextString(const class FString& _strText);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"BFGWidget_Overhead">();
	}
	static class UBFGWidget_Overhead* GetDefaultObj()
	{
		return GetDefaultObjImpl<UBFGWidget_Overhead>();
	}
};
static_assert(alignof(UBFGWidget_Overhead) == 0x000008, "Wrong alignment on UBFGWidget_Overhead");
static_assert(sizeof(UBFGWidget_Overhead) == 0x0002F8, "Wrong size on UBFGWidget_Overhead");

// Class BFGCore.BFGBossReinforcementSpawner_Armquist
// 0x0000 (0x04B8 - 0x04B8)
class ABFGBossReinforcementSpawner_Armquist final : public ABFGBossReinforcementSpawner
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"BFGBossReinforcementSpawner_Armquist">();
	}
	static class ABFGBossReinforcementSpawner_Armquist* GetDefaultObj()
	{
		return GetDefaultObjImpl<ABFGBossReinforcementSpawner_Armquist>();
	}
};
static_assert(alignof(ABFGBossReinforcementSpawner_Armquist) == 0x000008, "Wrong alignment on ABFGBossReinforcementSpawner_Armquist");
static_assert(sizeof(ABFGBossReinforcementSpawner_Armquist) == 0x0004B8, "Wrong size on ABFGBossReinforcementSpawner_Armquist");

// Class BFGCore.BFGBossReinforcementSpawner_Roboprez
// 0x0008 (0x04C0 - 0x04B8)
class ABFGBossReinforcementSpawner_Roboprez final : public ABFGBossReinforcementSpawner
{
public:
	float                                         M_fSpawnerMinRadiusforPlayerFrustrum;              // 0x04B8(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_4BC[0x4];                                      // 0x04BC(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"BFGBossReinforcementSpawner_Roboprez">();
	}
	static class ABFGBossReinforcementSpawner_Roboprez* GetDefaultObj()
	{
		return GetDefaultObjImpl<ABFGBossReinforcementSpawner_Roboprez>();
	}
};
static_assert(alignof(ABFGBossReinforcementSpawner_Roboprez) == 0x000008, "Wrong alignment on ABFGBossReinforcementSpawner_Roboprez");
static_assert(sizeof(ABFGBossReinforcementSpawner_Roboprez) == 0x0004C0, "Wrong size on ABFGBossReinforcementSpawner_Roboprez");
static_assert(offsetof(ABFGBossReinforcementSpawner_Roboprez, M_fSpawnerMinRadiusforPlayerFrustrum) == 0x0004B8, "Member 'ABFGBossReinforcementSpawner_Roboprez::M_fSpawnerMinRadiusforPlayerFrustrum' has a wrong offset!");

// Class BFGCore.BFGObjectiveMarkerGroup
// 0x0160 (0x0188 - 0x0028)
class UBFGObjectiveMarkerGroup final : public UObject
{
public:
	class UBFGObjectiveMarkerSystem*              M_pSystem;                                         // 0x0028(0x0008)(ExportObject, ZeroConstructor, Transient, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_30[0x10];                                      // 0x0030(0x0010)(Fixing Size After Last Property [ Dumper-7 ])
	struct FBFGObjectiveMarkerGroupContext        M_context;                                         // 0x0040(0x00C8)(Transient, ContainsInstancedReference, Protected, NativeAccessSpecifierProtected)
	class UBFGVariable*                           M_pVariable;                                       // 0x0108(0x0008)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TArray<class AActor*>                         M_aNewObjectives;                                  // 0x0110(0x0010)(ZeroConstructor, Transient, Protected, NativeAccessSpecifierProtected)
	TMap<class AActor*, class UBFGObjectiveMarkerInstanceList*> M_aObjectiveMarkers;                               // 0x0120(0x0050)(ZeroConstructor, Transient, Protected, NativeAccessSpecifierProtected)
	uint8                                         Pad_170[0x18];                                     // 0x0170(0x0018)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"BFGObjectiveMarkerGroup">();
	}
	static class UBFGObjectiveMarkerGroup* GetDefaultObj()
	{
		return GetDefaultObjImpl<UBFGObjectiveMarkerGroup>();
	}
};
static_assert(alignof(UBFGObjectiveMarkerGroup) == 0x000008, "Wrong alignment on UBFGObjectiveMarkerGroup");
static_assert(sizeof(UBFGObjectiveMarkerGroup) == 0x000188, "Wrong size on UBFGObjectiveMarkerGroup");
static_assert(offsetof(UBFGObjectiveMarkerGroup, M_pSystem) == 0x000028, "Member 'UBFGObjectiveMarkerGroup::M_pSystem' has a wrong offset!");
static_assert(offsetof(UBFGObjectiveMarkerGroup, M_context) == 0x000040, "Member 'UBFGObjectiveMarkerGroup::M_context' has a wrong offset!");
static_assert(offsetof(UBFGObjectiveMarkerGroup, M_pVariable) == 0x000108, "Member 'UBFGObjectiveMarkerGroup::M_pVariable' has a wrong offset!");
static_assert(offsetof(UBFGObjectiveMarkerGroup, M_aNewObjectives) == 0x000110, "Member 'UBFGObjectiveMarkerGroup::M_aNewObjectives' has a wrong offset!");
static_assert(offsetof(UBFGObjectiveMarkerGroup, M_aObjectiveMarkers) == 0x000120, "Member 'UBFGObjectiveMarkerGroup::M_aObjectiveMarkers' has a wrong offset!");

// Class BFGCore.BFGTransitionManager
// 0x00A8 (0x00D0 - 0x0028)
class UBFGTransitionManager final : public UObject
{
public:
	UMulticastDelegateProperty_                   M_onFadeStarted;                                   // 0x0028(0x0018)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	UMulticastDelegateProperty_                   M_onFadeFinished;                                  // 0x0040(0x0018)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	uint8                                         Pad_58[0x40];                                      // 0x0058(0x0040)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<class UObject*>                        M_apWorldRenderingDisabledRequests;                // 0x0098(0x0010)(ZeroConstructor, NativeAccessSpecifierPrivate)
	uint8                                         Pad_A8[0x18];                                      // 0x00A8(0x0018)(Fixing Size After Last Property [ Dumper-7 ])
	class UBFGGameInstance*                       M_pGameInstance;                                   // 0x00C0(0x0008)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UBFGFadeSystem*                         M_pFadeSystem;                                     // 0x00C8(0x0008)(ExportObject, ZeroConstructor, Transient, InstancedReference, IsPlainOldData, NoDestructor, PersistentInstance, HasGetValueTypeHash, NativeAccessSpecifierPrivate)

public:
	void AddWorldRenderingDisabledRequest(class UObject* _pObject);
	class UBFGFadeSystem* GetFadeSystem();
	class UBFGGameInstance* GetGameInstance();
	void RemoveWorldRenderingDisabledRequest(class UObject* _pObject);

	bool IsControlEnabled() const;
	bool IsFadeOut() const;
	bool IsFading() const;
	bool IsHidden() const;
	bool IsLoadingScreenShown() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"BFGTransitionManager">();
	}
	static class UBFGTransitionManager* GetDefaultObj()
	{
		return GetDefaultObjImpl<UBFGTransitionManager>();
	}
};
static_assert(alignof(UBFGTransitionManager) == 0x000008, "Wrong alignment on UBFGTransitionManager");
static_assert(sizeof(UBFGTransitionManager) == 0x0000D0, "Wrong size on UBFGTransitionManager");
static_assert(offsetof(UBFGTransitionManager, M_onFadeStarted) == 0x000028, "Member 'UBFGTransitionManager::M_onFadeStarted' has a wrong offset!");
static_assert(offsetof(UBFGTransitionManager, M_onFadeFinished) == 0x000040, "Member 'UBFGTransitionManager::M_onFadeFinished' has a wrong offset!");
static_assert(offsetof(UBFGTransitionManager, M_apWorldRenderingDisabledRequests) == 0x000098, "Member 'UBFGTransitionManager::M_apWorldRenderingDisabledRequests' has a wrong offset!");
static_assert(offsetof(UBFGTransitionManager, M_pGameInstance) == 0x0000C0, "Member 'UBFGTransitionManager::M_pGameInstance' has a wrong offset!");
static_assert(offsetof(UBFGTransitionManager, M_pFadeSystem) == 0x0000C8, "Member 'UBFGTransitionManager::M_pFadeSystem' has a wrong offset!");

// Class BFGCore.BFGDecorator_IsWeaponEquipped
// 0x0028 (0x0098 - 0x0070)
class UBFGDecorator_IsWeaponEquipped final : public UBFGBTBaseDecorator
{
public:
	TSoftClassPtr<class UClass>                   M_pSpecificWeapon;                                 // 0x0070(0x0028)(Edit, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"BFGDecorator_IsWeaponEquipped">();
	}
	static class UBFGDecorator_IsWeaponEquipped* GetDefaultObj()
	{
		return GetDefaultObjImpl<UBFGDecorator_IsWeaponEquipped>();
	}
};
static_assert(alignof(UBFGDecorator_IsWeaponEquipped) == 0x000008, "Wrong alignment on UBFGDecorator_IsWeaponEquipped");
static_assert(sizeof(UBFGDecorator_IsWeaponEquipped) == 0x000098, "Wrong size on UBFGDecorator_IsWeaponEquipped");
static_assert(offsetof(UBFGDecorator_IsWeaponEquipped, M_pSpecificWeapon) == 0x000070, "Member 'UBFGDecorator_IsWeaponEquipped::M_pSpecificWeapon' has a wrong offset!");

// Class BFGCore.BFGBossReinforcementSpawner_Silhouette
// 0x0088 (0x0540 - 0x04B8)
class ABFGBossReinforcementSpawner_Silhouette final : public ABFGBossReinforcementSpawner
{
public:
	class USkeletalMeshComponent*                 M_pSkeletalMesh;                                   // 0x04B8(0x0008)(Edit, BlueprintVisible, ExportObject, ZeroConstructor, EditConst, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         M_fTimeToTargetHeightReached;                      // 0x04C0(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         M_tTargetHeightDelta;                              // 0x04C4(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         M_fTimeDelayToReset;                               // 0x04C8(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         M_fTimeDelayToGoDown;                              // 0x04CC(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UCurveFloat*                            M_pHeightSpeedCurve;                               // 0x04D0(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          M_bCanSpawnPickups;                                // 0x04D8(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_4D9[0x3];                                      // 0x04D9(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         M_fTimeDelayToSpawnNewPickup;                      // 0x04DC(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TSubclassOf<class ABFGItemValuePack>          M_pPickupClass;                                    // 0x04E0(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UBoxComponent*                          M_pBoxCollision;                                   // 0x04E8(0x0008)(Edit, BlueprintVisible, ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class ABFGItemValuePack*                      M_pPickup;                                         // 0x04F0(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TArray<class ABFGBossReinforcementSpawner*>   M_apReinforcementSpawners;                         // 0x04F8(0x0010)(ZeroConstructor, Protected, NativeAccessSpecifierProtected)
	TArray<class AActor*>                         M_apReinforcementActors;                           // 0x0508(0x0010)(ZeroConstructor, Protected, NativeAccessSpecifierProtected)
	class FName                                   M_AttachmentSocket;                                // 0x0518(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_520[0x20];                                     // 0x0520(0x0020)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void DestroyPickup();
	bool GetIsAscending();
	bool GetIsDescending();
	bool GetIsInUse();
	void OnAnimationFinished();
	void OnBeginElevatorAscent();
	void OnBeginElevatorDescent();
	void OnBoxOverlapBegin(class UPrimitiveComponent* OverlappedComp, class AActor* OtherActor, class UPrimitiveComponent* OtherComp, int32 OtherBodyIndex, bool bFromSweep, const struct FHitResult& SweepResult);
	void OnBoxOverlapEnd(class UPrimitiveComponent* OverlappedComp, class AActor* OtherActor, class UPrimitiveComponent* OtherComp, int32 OtherBodyIndex);
	void OnElevatorStopAscent();
	void OnElevatorStopDescent();
	void SetupChildReinforcementSpawners();
	void StartSpawningSequence();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"BFGBossReinforcementSpawner_Silhouette">();
	}
	static class ABFGBossReinforcementSpawner_Silhouette* GetDefaultObj()
	{
		return GetDefaultObjImpl<ABFGBossReinforcementSpawner_Silhouette>();
	}
};
static_assert(alignof(ABFGBossReinforcementSpawner_Silhouette) == 0x000008, "Wrong alignment on ABFGBossReinforcementSpawner_Silhouette");
static_assert(sizeof(ABFGBossReinforcementSpawner_Silhouette) == 0x000540, "Wrong size on ABFGBossReinforcementSpawner_Silhouette");
static_assert(offsetof(ABFGBossReinforcementSpawner_Silhouette, M_pSkeletalMesh) == 0x0004B8, "Member 'ABFGBossReinforcementSpawner_Silhouette::M_pSkeletalMesh' has a wrong offset!");
static_assert(offsetof(ABFGBossReinforcementSpawner_Silhouette, M_fTimeToTargetHeightReached) == 0x0004C0, "Member 'ABFGBossReinforcementSpawner_Silhouette::M_fTimeToTargetHeightReached' has a wrong offset!");
static_assert(offsetof(ABFGBossReinforcementSpawner_Silhouette, M_tTargetHeightDelta) == 0x0004C4, "Member 'ABFGBossReinforcementSpawner_Silhouette::M_tTargetHeightDelta' has a wrong offset!");
static_assert(offsetof(ABFGBossReinforcementSpawner_Silhouette, M_fTimeDelayToReset) == 0x0004C8, "Member 'ABFGBossReinforcementSpawner_Silhouette::M_fTimeDelayToReset' has a wrong offset!");
static_assert(offsetof(ABFGBossReinforcementSpawner_Silhouette, M_fTimeDelayToGoDown) == 0x0004CC, "Member 'ABFGBossReinforcementSpawner_Silhouette::M_fTimeDelayToGoDown' has a wrong offset!");
static_assert(offsetof(ABFGBossReinforcementSpawner_Silhouette, M_pHeightSpeedCurve) == 0x0004D0, "Member 'ABFGBossReinforcementSpawner_Silhouette::M_pHeightSpeedCurve' has a wrong offset!");
static_assert(offsetof(ABFGBossReinforcementSpawner_Silhouette, M_bCanSpawnPickups) == 0x0004D8, "Member 'ABFGBossReinforcementSpawner_Silhouette::M_bCanSpawnPickups' has a wrong offset!");
static_assert(offsetof(ABFGBossReinforcementSpawner_Silhouette, M_fTimeDelayToSpawnNewPickup) == 0x0004DC, "Member 'ABFGBossReinforcementSpawner_Silhouette::M_fTimeDelayToSpawnNewPickup' has a wrong offset!");
static_assert(offsetof(ABFGBossReinforcementSpawner_Silhouette, M_pPickupClass) == 0x0004E0, "Member 'ABFGBossReinforcementSpawner_Silhouette::M_pPickupClass' has a wrong offset!");
static_assert(offsetof(ABFGBossReinforcementSpawner_Silhouette, M_pBoxCollision) == 0x0004E8, "Member 'ABFGBossReinforcementSpawner_Silhouette::M_pBoxCollision' has a wrong offset!");
static_assert(offsetof(ABFGBossReinforcementSpawner_Silhouette, M_pPickup) == 0x0004F0, "Member 'ABFGBossReinforcementSpawner_Silhouette::M_pPickup' has a wrong offset!");
static_assert(offsetof(ABFGBossReinforcementSpawner_Silhouette, M_apReinforcementSpawners) == 0x0004F8, "Member 'ABFGBossReinforcementSpawner_Silhouette::M_apReinforcementSpawners' has a wrong offset!");
static_assert(offsetof(ABFGBossReinforcementSpawner_Silhouette, M_apReinforcementActors) == 0x000508, "Member 'ABFGBossReinforcementSpawner_Silhouette::M_apReinforcementActors' has a wrong offset!");
static_assert(offsetof(ABFGBossReinforcementSpawner_Silhouette, M_AttachmentSocket) == 0x000518, "Member 'ABFGBossReinforcementSpawner_Silhouette::M_AttachmentSocket' has a wrong offset!");

// Class BFGCore.BFGBossSupportActor
// 0x0040 (0x0BD0 - 0x0B90)
class ABFGBossSupportActor : public ABFGNPCCharacterGameplay
{
public:
	EBFGBossSupport                               M_eBossSupportType;                                // 0x0B88(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_B89[0x7];                                      // 0x0B89(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	struct FTimerHandle                           M_tActionDelayTimer;                               // 0x0B90(0x0008)(NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	struct FTimerHandle                           M_tActionTimer;                                    // 0x0B98(0x0008)(NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         M_fActionDelay;                                    // 0x0BA0(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         M_fActionDuration;                                 // 0x0BA4(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TArray<TSubclassOf<class ABFGPattern_AOE>>    M_aPatternClasses;                                 // 0x0BA8(0x0010)(Edit, ZeroConstructor, Protected, UObjectWrapper, NativeAccessSpecifierProtected)
	class ABFGWeapon_BossAOE*                     M_pAOEWeapon;                                      // 0x0BB8(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_BC0[0x10];                                     // 0x0BC0(0x0010)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void BeginSupportAction();
	void BeginSupportTelegraph();
	void EndSupportAction();
	bool IsSupportAvailable();
	bool RequestSupport(class AActor* _pTargetActor, int32 _iPhaseNumber, int32 _iStepIndex);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"BFGBossSupportActor">();
	}
	static class ABFGBossSupportActor* GetDefaultObj()
	{
		return GetDefaultObjImpl<ABFGBossSupportActor>();
	}
};
static_assert(alignof(ABFGBossSupportActor) == 0x000010, "Wrong alignment on ABFGBossSupportActor");
static_assert(sizeof(ABFGBossSupportActor) == 0x000BD0, "Wrong size on ABFGBossSupportActor");
static_assert(offsetof(ABFGBossSupportActor, M_eBossSupportType) == 0x000B88, "Member 'ABFGBossSupportActor::M_eBossSupportType' has a wrong offset!");
static_assert(offsetof(ABFGBossSupportActor, M_tActionDelayTimer) == 0x000B90, "Member 'ABFGBossSupportActor::M_tActionDelayTimer' has a wrong offset!");
static_assert(offsetof(ABFGBossSupportActor, M_tActionTimer) == 0x000B98, "Member 'ABFGBossSupportActor::M_tActionTimer' has a wrong offset!");
static_assert(offsetof(ABFGBossSupportActor, M_fActionDelay) == 0x000BA0, "Member 'ABFGBossSupportActor::M_fActionDelay' has a wrong offset!");
static_assert(offsetof(ABFGBossSupportActor, M_fActionDuration) == 0x000BA4, "Member 'ABFGBossSupportActor::M_fActionDuration' has a wrong offset!");
static_assert(offsetof(ABFGBossSupportActor, M_aPatternClasses) == 0x000BA8, "Member 'ABFGBossSupportActor::M_aPatternClasses' has a wrong offset!");
static_assert(offsetof(ABFGBossSupportActor, M_pAOEWeapon) == 0x000BB8, "Member 'ABFGBossSupportActor::M_pAOEWeapon' has a wrong offset!");

// Class BFGCore.BFGTextWrapper
// 0x0000 (0x0240 - 0x0240)
class UBFGTextWrapper final : public UUserWidget
{
public:
	void SetText(const class FText& _pText);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"BFGTextWrapper">();
	}
	static class UBFGTextWrapper* GetDefaultObj()
	{
		return GetDefaultObjImpl<UBFGTextWrapper>();
	}
};
static_assert(alignof(UBFGTextWrapper) == 0x000008, "Wrong alignment on UBFGTextWrapper");
static_assert(sizeof(UBFGTextWrapper) == 0x000240, "Wrong size on UBFGTextWrapper");

// Class BFGCore.BFGCortexScanResponsePool
// 0x0090 (0x00B8 - 0x0028)
class UBFGCortexScanResponsePool final : public UObject
{
public:
	uint8                                         Pad_28[0x10];                                      // 0x0028(0x0010)(Fixing Size After Last Property [ Dumper-7 ])
	class UStringTable*                           M_pStringTableInstance;                            // 0x0038(0x0008)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_40[0x8];                                       // 0x0040(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	TMap<struct FGuid, struct FBFGCortexScanResponse> M_aResponsesByGuid;                                // 0x0048(0x0050)(ZeroConstructor, Transient, Protected, NativeAccessSpecifierProtected)
	TArray<struct FGuid>                          M_aEntryResponses;                                 // 0x0098(0x0010)(ZeroConstructor, Transient, Protected, NativeAccessSpecifierProtected)
	TArray<struct FGuid>                          M_aValidEntryResponses;                            // 0x00A8(0x0010)(ZeroConstructor, Transient, Protected, NativeAccessSpecifierProtected)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"BFGCortexScanResponsePool">();
	}
	static class UBFGCortexScanResponsePool* GetDefaultObj()
	{
		return GetDefaultObjImpl<UBFGCortexScanResponsePool>();
	}
};
static_assert(alignof(UBFGCortexScanResponsePool) == 0x000008, "Wrong alignment on UBFGCortexScanResponsePool");
static_assert(sizeof(UBFGCortexScanResponsePool) == 0x0000B8, "Wrong size on UBFGCortexScanResponsePool");
static_assert(offsetof(UBFGCortexScanResponsePool, M_pStringTableInstance) == 0x000038, "Member 'UBFGCortexScanResponsePool::M_pStringTableInstance' has a wrong offset!");
static_assert(offsetof(UBFGCortexScanResponsePool, M_aResponsesByGuid) == 0x000048, "Member 'UBFGCortexScanResponsePool::M_aResponsesByGuid' has a wrong offset!");
static_assert(offsetof(UBFGCortexScanResponsePool, M_aEntryResponses) == 0x000098, "Member 'UBFGCortexScanResponsePool::M_aEntryResponses' has a wrong offset!");
static_assert(offsetof(UBFGCortexScanResponsePool, M_aValidEntryResponses) == 0x0000A8, "Member 'UBFGCortexScanResponsePool::M_aValidEntryResponses' has a wrong offset!");

// Class BFGCore.BFGBossSupportActor_Navy
// 0x0000 (0x0BD0 - 0x0BD0)
class ABFGBossSupportActor_Navy final : public ABFGBossSupportActor
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"BFGBossSupportActor_Navy">();
	}
	static class ABFGBossSupportActor_Navy* GetDefaultObj()
	{
		return GetDefaultObjImpl<ABFGBossSupportActor_Navy>();
	}
};
static_assert(alignof(ABFGBossSupportActor_Navy) == 0x000010, "Wrong alignment on ABFGBossSupportActor_Navy");
static_assert(sizeof(ABFGBossSupportActor_Navy) == 0x000BD0, "Wrong size on ABFGBossSupportActor_Navy");

// Class BFGCore.BFGNarrativeSequenceNode_PlayerOption
// 0x0020 (0x00E0 - 0x00C0)
class UBFGNarrativeSequenceNode_PlayerOption : public UBFGNarrativeSequenceNode
{
public:
	class FText                                   M_strUIText;                                       // 0x00C0(0x0018)(Edit, DisableEditOnInstance, Protected, NativeAccessSpecifierProtected)
	EUBFGNarrativeSequence_Assessment             M_eAssessment;                                     // 0x00D8(0x0001)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          M_bDropHolobob;                                    // 0x00D9(0x0001)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          M_bHideMoodBar;                                    // 0x00DA(0x0001)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          M_bDeferMoodChange;                                // 0x00DB(0x0001)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          M_bDeferFail;                                      // 0x00DC(0x0001)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_DD[0x3];                                       // 0x00DD(0x0003)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"BFGNarrativeSequenceNode_PlayerOption">();
	}
	static class UBFGNarrativeSequenceNode_PlayerOption* GetDefaultObj()
	{
		return GetDefaultObjImpl<UBFGNarrativeSequenceNode_PlayerOption>();
	}
};
static_assert(alignof(UBFGNarrativeSequenceNode_PlayerOption) == 0x000008, "Wrong alignment on UBFGNarrativeSequenceNode_PlayerOption");
static_assert(sizeof(UBFGNarrativeSequenceNode_PlayerOption) == 0x0000E0, "Wrong size on UBFGNarrativeSequenceNode_PlayerOption");
static_assert(offsetof(UBFGNarrativeSequenceNode_PlayerOption, M_strUIText) == 0x0000C0, "Member 'UBFGNarrativeSequenceNode_PlayerOption::M_strUIText' has a wrong offset!");
static_assert(offsetof(UBFGNarrativeSequenceNode_PlayerOption, M_eAssessment) == 0x0000D8, "Member 'UBFGNarrativeSequenceNode_PlayerOption::M_eAssessment' has a wrong offset!");
static_assert(offsetof(UBFGNarrativeSequenceNode_PlayerOption, M_bDropHolobob) == 0x0000D9, "Member 'UBFGNarrativeSequenceNode_PlayerOption::M_bDropHolobob' has a wrong offset!");
static_assert(offsetof(UBFGNarrativeSequenceNode_PlayerOption, M_bHideMoodBar) == 0x0000DA, "Member 'UBFGNarrativeSequenceNode_PlayerOption::M_bHideMoodBar' has a wrong offset!");
static_assert(offsetof(UBFGNarrativeSequenceNode_PlayerOption, M_bDeferMoodChange) == 0x0000DB, "Member 'UBFGNarrativeSequenceNode_PlayerOption::M_bDeferMoodChange' has a wrong offset!");
static_assert(offsetof(UBFGNarrativeSequenceNode_PlayerOption, M_bDeferFail) == 0x0000DC, "Member 'UBFGNarrativeSequenceNode_PlayerOption::M_bDeferFail' has a wrong offset!");

// Class BFGCore.BFGNarrativeSequenceNode_PlayLevelSequence
// 0x0050 (0x0130 - 0x00E0)
class UBFGNarrativeSequenceNode_PlayLevelSequence final : public UBFGNarrativeSequenceNode_PlayerOption
{
public:
	TSoftObjectPtr<class ULevelSequence>          M_spLevelSequence;                                 // 0x00E0(0x0028)(Edit, DisableEditOnInstance, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TArray<struct FBFGSequence_DynamicActorBinding> M_aSequenceActorBinding;                           // 0x0108(0x0010)(Edit, ZeroConstructor, DisableEditOnInstance, Protected, NativeAccessSpecifierProtected)
	TArray<TSoftObjectPtr<class AActor>>          M_aHideActors;                                     // 0x0118(0x0010)(Edit, ZeroConstructor, DisableEditOnInstance, Protected, UObjectWrapper, NativeAccessSpecifierProtected)
	bool                                          M_bBreakSkippingChain;                             // 0x0128(0x0001)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_129[0x7];                                      // 0x0129(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void FinishedSequence(class ALevelSequenceActor* _pActor, bool _bWasCutscene);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"BFGNarrativeSequenceNode_PlayLevelSequence">();
	}
	static class UBFGNarrativeSequenceNode_PlayLevelSequence* GetDefaultObj()
	{
		return GetDefaultObjImpl<UBFGNarrativeSequenceNode_PlayLevelSequence>();
	}
};
static_assert(alignof(UBFGNarrativeSequenceNode_PlayLevelSequence) == 0x000008, "Wrong alignment on UBFGNarrativeSequenceNode_PlayLevelSequence");
static_assert(sizeof(UBFGNarrativeSequenceNode_PlayLevelSequence) == 0x000130, "Wrong size on UBFGNarrativeSequenceNode_PlayLevelSequence");
static_assert(offsetof(UBFGNarrativeSequenceNode_PlayLevelSequence, M_spLevelSequence) == 0x0000E0, "Member 'UBFGNarrativeSequenceNode_PlayLevelSequence::M_spLevelSequence' has a wrong offset!");
static_assert(offsetof(UBFGNarrativeSequenceNode_PlayLevelSequence, M_aSequenceActorBinding) == 0x000108, "Member 'UBFGNarrativeSequenceNode_PlayLevelSequence::M_aSequenceActorBinding' has a wrong offset!");
static_assert(offsetof(UBFGNarrativeSequenceNode_PlayLevelSequence, M_aHideActors) == 0x000118, "Member 'UBFGNarrativeSequenceNode_PlayLevelSequence::M_aHideActors' has a wrong offset!");
static_assert(offsetof(UBFGNarrativeSequenceNode_PlayLevelSequence, M_bBreakSkippingChain) == 0x000128, "Member 'UBFGNarrativeSequenceNode_PlayLevelSequence::M_bBreakSkippingChain' has a wrong offset!");

// Class BFGCore.BFGBoundariesTriggerInterface
// 0x0000 (0x0028 - 0x0028)
class IBFGBoundariesTriggerInterface final : public IInterface
{
public:
	class UStaticMeshComponent* GetTriggerZoneIndicator();
	class UPrimitiveComponent* GetTriggerZoneIndicatorComponent();
	void TriggerZoneMessage(bool _bOut);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"BFGBoundariesTriggerInterface">();
	}
	static class IBFGBoundariesTriggerInterface* GetDefaultObj()
	{
		return GetDefaultObjImpl<IBFGBoundariesTriggerInterface>();
	}
};
static_assert(alignof(IBFGBoundariesTriggerInterface) == 0x000008, "Wrong alignment on IBFGBoundariesTriggerInterface");
static_assert(sizeof(IBFGBoundariesTriggerInterface) == 0x000028, "Wrong size on IBFGBoundariesTriggerInterface");

// Class BFGCore.BFGChunkManager
// 0x0010 (0x0038 - 0x0028)
class UBFGChunkManager final : public UObject
{
public:
	class UBFGGameInstance*                       M_pGameInstance;                                   // 0x0028(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_30[0x8];                                       // 0x0030(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"BFGChunkManager">();
	}
	static class UBFGChunkManager* GetDefaultObj()
	{
		return GetDefaultObjImpl<UBFGChunkManager>();
	}
};
static_assert(alignof(UBFGChunkManager) == 0x000008, "Wrong alignment on UBFGChunkManager");
static_assert(sizeof(UBFGChunkManager) == 0x000038, "Wrong size on UBFGChunkManager");
static_assert(offsetof(UBFGChunkManager, M_pGameInstance) == 0x000028, "Member 'UBFGChunkManager::M_pGameInstance' has a wrong offset!");

// Class BFGCore.BFGWidget_Newspaper_Content
// 0x0098 (0x02D8 - 0x0240)
class UBFGWidget_Newspaper_Content final : public UUserWidget
{
public:
	uint8                                         Pad_240[0x38];                                     // 0x0240(0x0038)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<class FName>                           M_aoIDs;                                           // 0x0278(0x0010)(ZeroConstructor, Protected, NativeAccessSpecifierProtected)
	TArray<class UTextureRenderTarget2D*>         M_apRenderTargets;                                 // 0x0288(0x0010)(ZeroConstructor, Protected, NativeAccessSpecifierProtected)
	TArray<class UWidget*>                        M_apTextWidgets;                                   // 0x0298(0x0010)(ExportObject, ZeroConstructor, ContainsInstancedReference, Protected, NativeAccessSpecifierProtected)
	TArray<struct FVector2D>                      M_avDrawSizes;                                     // 0x02A8(0x0010)(ZeroConstructor, Protected, NativeAccessSpecifierProtected)
	class UDataTable*                             M_apTextStyleSet;                                  // 0x02B8(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_2C0[0x4];                                      // 0x02C0(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	struct FGuid                                  M_oGuid;                                           // 0x02C4(0x0010)(ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_2D4[0x4];                                      // 0x02D4(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void GenerateTextImage(const class FText& _strText, const class FString& _styleName, class FName _oTextID, ETextJustify _eTextJustification, bool bBlockAlignment);
	struct FVector2D GetDrawSizeForTextID(class FName _oName);
	class FName GetObjectName();
	void SetAdvertisement(const struct FSlateBrush& _oImage, int32 IIndex);
	void SetFrontImage(const struct FSlateBrush& _oImage);
	void SetTextImage(class UTextureRenderTarget2D* _pImage, class FName _oName);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"BFGWidget_Newspaper_Content">();
	}
	static class UBFGWidget_Newspaper_Content* GetDefaultObj()
	{
		return GetDefaultObjImpl<UBFGWidget_Newspaper_Content>();
	}
};
static_assert(alignof(UBFGWidget_Newspaper_Content) == 0x000008, "Wrong alignment on UBFGWidget_Newspaper_Content");
static_assert(sizeof(UBFGWidget_Newspaper_Content) == 0x0002D8, "Wrong size on UBFGWidget_Newspaper_Content");
static_assert(offsetof(UBFGWidget_Newspaper_Content, M_aoIDs) == 0x000278, "Member 'UBFGWidget_Newspaper_Content::M_aoIDs' has a wrong offset!");
static_assert(offsetof(UBFGWidget_Newspaper_Content, M_apRenderTargets) == 0x000288, "Member 'UBFGWidget_Newspaper_Content::M_apRenderTargets' has a wrong offset!");
static_assert(offsetof(UBFGWidget_Newspaper_Content, M_apTextWidgets) == 0x000298, "Member 'UBFGWidget_Newspaper_Content::M_apTextWidgets' has a wrong offset!");
static_assert(offsetof(UBFGWidget_Newspaper_Content, M_avDrawSizes) == 0x0002A8, "Member 'UBFGWidget_Newspaper_Content::M_avDrawSizes' has a wrong offset!");
static_assert(offsetof(UBFGWidget_Newspaper_Content, M_apTextStyleSet) == 0x0002B8, "Member 'UBFGWidget_Newspaper_Content::M_apTextStyleSet' has a wrong offset!");
static_assert(offsetof(UBFGWidget_Newspaper_Content, M_oGuid) == 0x0002C4, "Member 'UBFGWidget_Newspaper_Content::M_oGuid' has a wrong offset!");

// Class BFGCore.BFGBroadphaseManager
// 0x0170 (0x01A0 - 0x0030)
class UBFGBroadphaseManager final : public UBFGGameSystem
{
public:
	class ABFGGameState*                          M_pGameState;                                      // 0x0030(0x0008)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_38[0x1C];                                      // 0x0038(0x001C)(Fixing Size After Last Property [ Dumper-7 ])
	int32                                         M_iSubdivisions;                                   // 0x0054(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	TMap<class AActor*, struct FBFGActorHandle>   M_aActorToHandle;                                  // 0x0058(0x0050)(ZeroConstructor, Transient, NativeAccessSpecifierPrivate)
	TArray<struct FBFGBroadphaseEntry>            M_aEntries;                                        // 0x00A8(0x0010)(ZeroConstructor, Transient, NativeAccessSpecifierPrivate)
	uint8                                         Pad_B8[0xE8];                                      // 0x00B8(0x00E8)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"BFGBroadphaseManager">();
	}
	static class UBFGBroadphaseManager* GetDefaultObj()
	{
		return GetDefaultObjImpl<UBFGBroadphaseManager>();
	}
};
static_assert(alignof(UBFGBroadphaseManager) == 0x000008, "Wrong alignment on UBFGBroadphaseManager");
static_assert(sizeof(UBFGBroadphaseManager) == 0x0001A0, "Wrong size on UBFGBroadphaseManager");
static_assert(offsetof(UBFGBroadphaseManager, M_pGameState) == 0x000030, "Member 'UBFGBroadphaseManager::M_pGameState' has a wrong offset!");
static_assert(offsetof(UBFGBroadphaseManager, M_iSubdivisions) == 0x000054, "Member 'UBFGBroadphaseManager::M_iSubdivisions' has a wrong offset!");
static_assert(offsetof(UBFGBroadphaseManager, M_aActorToHandle) == 0x000058, "Member 'UBFGBroadphaseManager::M_aActorToHandle' has a wrong offset!");
static_assert(offsetof(UBFGBroadphaseManager, M_aEntries) == 0x0000A8, "Member 'UBFGBroadphaseManager::M_aEntries' has a wrong offset!");

// Class BFGCore.BFGUFOAbility_EMP
// 0x0048 (0x0210 - 0x01C8)
class UBFGUFOAbility_EMP : public UBFGMentalAbilityBase
{
public:
	TArray<TSubclassOf<class ABFGProjectile_Object>> M_aEMPAbleClassList;                               // 0x01C8(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, UObjectWrapper, NativeAccessSpecifierPublic)
	TArray<TSubclassOf<class ABFGNPCCharacterGameplay>> M_aEMPAbleNPCClassList;                            // 0x01D8(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, UObjectWrapper, NativeAccessSpecifierPublic)
	struct FGameplayTag                           M_tUpgradeTagPulseFieldAmplifiers;                 // 0x01E8(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, DisableEditOnInstance, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FGameplayTag                           M_tUpgradeTagPulseFieldMaximizers;                 // 0x01F0(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, DisableEditOnInstance, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FGameplayTag                           M_tUpgradeTagPulsotronicReversalChannels;          // 0x01F8(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, DisableEditOnInstance, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         M_fPulseFieldAmplifiers_MaxRange;                  // 0x0200(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         M_fPulseFieldMaximizers_MaxRange;                  // 0x0204(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         M_fPulsotronicReversalChannels_DeflectFriction;    // 0x0208(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         M_fPulsotronicReversalChannels_DeflectRestitution; // 0x020C(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

public:
	void OnProjectileEMPd(class ABFGProjectile* PProjectile);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"BFGUFOAbility_EMP">();
	}
	static class UBFGUFOAbility_EMP* GetDefaultObj()
	{
		return GetDefaultObjImpl<UBFGUFOAbility_EMP>();
	}
};
static_assert(alignof(UBFGUFOAbility_EMP) == 0x000008, "Wrong alignment on UBFGUFOAbility_EMP");
static_assert(sizeof(UBFGUFOAbility_EMP) == 0x000210, "Wrong size on UBFGUFOAbility_EMP");
static_assert(offsetof(UBFGUFOAbility_EMP, M_aEMPAbleClassList) == 0x0001C8, "Member 'UBFGUFOAbility_EMP::M_aEMPAbleClassList' has a wrong offset!");
static_assert(offsetof(UBFGUFOAbility_EMP, M_aEMPAbleNPCClassList) == 0x0001D8, "Member 'UBFGUFOAbility_EMP::M_aEMPAbleNPCClassList' has a wrong offset!");
static_assert(offsetof(UBFGUFOAbility_EMP, M_tUpgradeTagPulseFieldAmplifiers) == 0x0001E8, "Member 'UBFGUFOAbility_EMP::M_tUpgradeTagPulseFieldAmplifiers' has a wrong offset!");
static_assert(offsetof(UBFGUFOAbility_EMP, M_tUpgradeTagPulseFieldMaximizers) == 0x0001F0, "Member 'UBFGUFOAbility_EMP::M_tUpgradeTagPulseFieldMaximizers' has a wrong offset!");
static_assert(offsetof(UBFGUFOAbility_EMP, M_tUpgradeTagPulsotronicReversalChannels) == 0x0001F8, "Member 'UBFGUFOAbility_EMP::M_tUpgradeTagPulsotronicReversalChannels' has a wrong offset!");
static_assert(offsetof(UBFGUFOAbility_EMP, M_fPulseFieldAmplifiers_MaxRange) == 0x000200, "Member 'UBFGUFOAbility_EMP::M_fPulseFieldAmplifiers_MaxRange' has a wrong offset!");
static_assert(offsetof(UBFGUFOAbility_EMP, M_fPulseFieldMaximizers_MaxRange) == 0x000204, "Member 'UBFGUFOAbility_EMP::M_fPulseFieldMaximizers_MaxRange' has a wrong offset!");
static_assert(offsetof(UBFGUFOAbility_EMP, M_fPulsotronicReversalChannels_DeflectFriction) == 0x000208, "Member 'UBFGUFOAbility_EMP::M_fPulsotronicReversalChannels_DeflectFriction' has a wrong offset!");
static_assert(offsetof(UBFGUFOAbility_EMP, M_fPulsotronicReversalChannels_DeflectRestitution) == 0x00020C, "Member 'UBFGUFOAbility_EMP::M_fPulsotronicReversalChannels_DeflectRestitution' has a wrong offset!");

// Class BFGCore.BFGDestructionEffect
// 0x0018 (0x03F0 - 0x03D8)
class ABFGDestructionEffect : public AActor
{
public:
	class UParticleSystemComponent*               M_pParticleSystem;                                 // 0x03D8(0x0008)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_3E0[0x4];                                      // 0x03E0(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         M_fDisablingEffect_DelayBeforeSettingPfxInactive;  // 0x03E4(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         M_fDisablingEffect_DelayBeforeDestroyingActor;     // 0x03E8(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_3EC[0x4];                                      // 0x03EC(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void StartDisablingEffect();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"BFGDestructionEffect">();
	}
	static class ABFGDestructionEffect* GetDefaultObj()
	{
		return GetDefaultObjImpl<ABFGDestructionEffect>();
	}
};
static_assert(alignof(ABFGDestructionEffect) == 0x000008, "Wrong alignment on ABFGDestructionEffect");
static_assert(sizeof(ABFGDestructionEffect) == 0x0003F0, "Wrong size on ABFGDestructionEffect");
static_assert(offsetof(ABFGDestructionEffect, M_pParticleSystem) == 0x0003D8, "Member 'ABFGDestructionEffect::M_pParticleSystem' has a wrong offset!");
static_assert(offsetof(ABFGDestructionEffect, M_fDisablingEffect_DelayBeforeSettingPfxInactive) == 0x0003E4, "Member 'ABFGDestructionEffect::M_fDisablingEffect_DelayBeforeSettingPfxInactive' has a wrong offset!");
static_assert(offsetof(ABFGDestructionEffect, M_fDisablingEffect_DelayBeforeDestroyingActor) == 0x0003E8, "Member 'ABFGDestructionEffect::M_fDisablingEffect_DelayBeforeDestroyingActor' has a wrong offset!");

// Class BFGCore.BFGDestructionEffect_Propagation
// 0x0070 (0x0460 - 0x03F0)
class ABFGDestructionEffect_Propagation final : public ABFGDestructionEffect
{
public:
	struct FBFGBuildingDestructionPropagationEffects M_EffectData;                                      // 0x03F0(0x0060)(BlueprintVisible, NoDestructor, ExposeOnSpawn, NativeAccessSpecifierPublic)
	float                                         M_fWallSize_Factor;                                // 0x0450(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_454[0xC];                                      // 0x0454(0x000C)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void SetupPFX();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"BFGDestructionEffect_Propagation">();
	}
	static class ABFGDestructionEffect_Propagation* GetDefaultObj()
	{
		return GetDefaultObjImpl<ABFGDestructionEffect_Propagation>();
	}
};
static_assert(alignof(ABFGDestructionEffect_Propagation) == 0x000010, "Wrong alignment on ABFGDestructionEffect_Propagation");
static_assert(sizeof(ABFGDestructionEffect_Propagation) == 0x000460, "Wrong size on ABFGDestructionEffect_Propagation");
static_assert(offsetof(ABFGDestructionEffect_Propagation, M_EffectData) == 0x0003F0, "Member 'ABFGDestructionEffect_Propagation::M_EffectData' has a wrong offset!");
static_assert(offsetof(ABFGDestructionEffect_Propagation, M_fWallSize_Factor) == 0x000450, "Member 'ABFGDestructionEffect_Propagation::M_fWallSize_Factor' has a wrong offset!");

// Class BFGCore.BFGTrafficPathFinder
// 0x0020 (0x0048 - 0x0028)
class UBFGTrafficPathFinder final : public UObject
{
public:
	class UBFGTrafficPathFinder_Network*          M_pNetwork;                                        // 0x0028(0x0008)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UBFGTrafficPathFinder_Parser*           M_pParser;                                         // 0x0030(0x0008)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UBFGTrafficPathFinder_Stack*            M_pStack;                                          // 0x0038(0x0008)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UBFGTrafficPathFinder_Visitor*          M_pVisitor;                                        // 0x0040(0x0008)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"BFGTrafficPathFinder">();
	}
	static class UBFGTrafficPathFinder* GetDefaultObj()
	{
		return GetDefaultObjImpl<UBFGTrafficPathFinder>();
	}
};
static_assert(alignof(UBFGTrafficPathFinder) == 0x000008, "Wrong alignment on UBFGTrafficPathFinder");
static_assert(sizeof(UBFGTrafficPathFinder) == 0x000048, "Wrong size on UBFGTrafficPathFinder");
static_assert(offsetof(UBFGTrafficPathFinder, M_pNetwork) == 0x000028, "Member 'UBFGTrafficPathFinder::M_pNetwork' has a wrong offset!");
static_assert(offsetof(UBFGTrafficPathFinder, M_pParser) == 0x000030, "Member 'UBFGTrafficPathFinder::M_pParser' has a wrong offset!");
static_assert(offsetof(UBFGTrafficPathFinder, M_pStack) == 0x000038, "Member 'UBFGTrafficPathFinder::M_pStack' has a wrong offset!");
static_assert(offsetof(UBFGTrafficPathFinder, M_pVisitor) == 0x000040, "Member 'UBFGTrafficPathFinder::M_pVisitor' has a wrong offset!");

// Class BFGCore.BFGDecorator_LocationsInRange
// 0x0060 (0x00D0 - 0x0070)
class UBFGDecorator_LocationsInRange final : public UBFGDecorator_ObservingBase
{
public:
	struct FBlackboardKeySelector                 M_BBKeyTo;                                         // 0x0070(0x0028)(Edit, NativeAccessSpecifierPublic)
	float                                         M_fMinRange;                                       // 0x0098(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         M_fMaxRange;                                       // 0x009C(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          M_bInverse;                                        // 0x00A0(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          M_bFrom;                                           // 0x00A1(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_A2[0x6];                                       // 0x00A2(0x0006)(Fixing Size After Last Property [ Dumper-7 ])
	struct FBlackboardKeySelector                 M_BBKeyFrom;                                       // 0x00A8(0x0028)(Edit, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"BFGDecorator_LocationsInRange">();
	}
	static class UBFGDecorator_LocationsInRange* GetDefaultObj()
	{
		return GetDefaultObjImpl<UBFGDecorator_LocationsInRange>();
	}
};
static_assert(alignof(UBFGDecorator_LocationsInRange) == 0x000008, "Wrong alignment on UBFGDecorator_LocationsInRange");
static_assert(sizeof(UBFGDecorator_LocationsInRange) == 0x0000D0, "Wrong size on UBFGDecorator_LocationsInRange");
static_assert(offsetof(UBFGDecorator_LocationsInRange, M_BBKeyTo) == 0x000070, "Member 'UBFGDecorator_LocationsInRange::M_BBKeyTo' has a wrong offset!");
static_assert(offsetof(UBFGDecorator_LocationsInRange, M_fMinRange) == 0x000098, "Member 'UBFGDecorator_LocationsInRange::M_fMinRange' has a wrong offset!");
static_assert(offsetof(UBFGDecorator_LocationsInRange, M_fMaxRange) == 0x00009C, "Member 'UBFGDecorator_LocationsInRange::M_fMaxRange' has a wrong offset!");
static_assert(offsetof(UBFGDecorator_LocationsInRange, M_bInverse) == 0x0000A0, "Member 'UBFGDecorator_LocationsInRange::M_bInverse' has a wrong offset!");
static_assert(offsetof(UBFGDecorator_LocationsInRange, M_bFrom) == 0x0000A1, "Member 'UBFGDecorator_LocationsInRange::M_bFrom' has a wrong offset!");
static_assert(offsetof(UBFGDecorator_LocationsInRange, M_BBKeyFrom) == 0x0000A8, "Member 'UBFGDecorator_LocationsInRange::M_BBKeyFrom' has a wrong offset!");

// Class BFGCore.BFGDecorator_IsEquippingWeapon
// 0x0000 (0x0070 - 0x0070)
class UBFGDecorator_IsEquippingWeapon final : public UBFGBTBaseDecorator
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"BFGDecorator_IsEquippingWeapon">();
	}
	static class UBFGDecorator_IsEquippingWeapon* GetDefaultObj()
	{
		return GetDefaultObjImpl<UBFGDecorator_IsEquippingWeapon>();
	}
};
static_assert(alignof(UBFGDecorator_IsEquippingWeapon) == 0x000008, "Wrong alignment on UBFGDecorator_IsEquippingWeapon");
static_assert(sizeof(UBFGDecorator_IsEquippingWeapon) == 0x000070, "Wrong size on UBFGDecorator_IsEquippingWeapon");

// Class BFGCore.BFGWidget_SelectPlayerOption
// 0x0000 (0x0428 - 0x0428)
class UBFGWidget_SelectPlayerOption final : public UBFGWidget_GenericDialog
{
public:
	void SetQuestion(const class FText& _strQuestion);

	const TArray<class UBFGWidget_DialogOption*> GetOptions() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"BFGWidget_SelectPlayerOption">();
	}
	static class UBFGWidget_SelectPlayerOption* GetDefaultObj()
	{
		return GetDefaultObjImpl<UBFGWidget_SelectPlayerOption>();
	}
};
static_assert(alignof(UBFGWidget_SelectPlayerOption) == 0x000008, "Wrong alignment on UBFGWidget_SelectPlayerOption");
static_assert(sizeof(UBFGWidget_SelectPlayerOption) == 0x000428, "Wrong size on UBFGWidget_SelectPlayerOption");

// Class BFGCore.BFGBTService_AlertSystemReporter
// 0x0060 (0x00D8 - 0x0078)
class UBFGBTService_AlertSystemReporter final : public UBFGBTBaseService
{
public:
	TArray<class UBFGAlertSystemReportCheck*>     M_apChecks;                                        // 0x0078(0x0010)(Edit, ExportObject, ZeroConstructor, ContainsInstancedReference, NativeAccessSpecifierPublic)
	struct FBlackboardKeySelector                 M_BBKeyNPCState;                                   // 0x0088(0x0028)(Edit, NativeAccessSpecifierPublic)
	struct FBlackboardKeySelector                 M_bbKeyStunned;                                    // 0x00B0(0x0028)(Edit, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"BFGBTService_AlertSystemReporter">();
	}
	static class UBFGBTService_AlertSystemReporter* GetDefaultObj()
	{
		return GetDefaultObjImpl<UBFGBTService_AlertSystemReporter>();
	}
};
static_assert(alignof(UBFGBTService_AlertSystemReporter) == 0x000008, "Wrong alignment on UBFGBTService_AlertSystemReporter");
static_assert(sizeof(UBFGBTService_AlertSystemReporter) == 0x0000D8, "Wrong size on UBFGBTService_AlertSystemReporter");
static_assert(offsetof(UBFGBTService_AlertSystemReporter, M_apChecks) == 0x000078, "Member 'UBFGBTService_AlertSystemReporter::M_apChecks' has a wrong offset!");
static_assert(offsetof(UBFGBTService_AlertSystemReporter, M_BBKeyNPCState) == 0x000088, "Member 'UBFGBTService_AlertSystemReporter::M_BBKeyNPCState' has a wrong offset!");
static_assert(offsetof(UBFGBTService_AlertSystemReporter, M_bbKeyStunned) == 0x0000B0, "Member 'UBFGBTService_AlertSystemReporter::M_bbKeyStunned' has a wrong offset!");

// Class BFGCore.BFGDestructionEffect_Clouds
// 0x0060 (0x0450 - 0x03F0)
class ABFGDestructionEffect_Clouds final : public ABFGDestructionEffect
{
public:
	struct FBFGBuildingDestructionCloudEffects    M_EffectData;                                      // 0x03F0(0x0060)(BlueprintVisible, NoDestructor, ExposeOnSpawn, NativeAccessSpecifierPublic)

public:
	void SetupPFX();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"BFGDestructionEffect_Clouds">();
	}
	static class ABFGDestructionEffect_Clouds* GetDefaultObj()
	{
		return GetDefaultObjImpl<ABFGDestructionEffect_Clouds>();
	}
};
static_assert(alignof(ABFGDestructionEffect_Clouds) == 0x000010, "Wrong alignment on ABFGDestructionEffect_Clouds");
static_assert(sizeof(ABFGDestructionEffect_Clouds) == 0x000450, "Wrong size on ABFGDestructionEffect_Clouds");
static_assert(offsetof(ABFGDestructionEffect_Clouds, M_EffectData) == 0x0003F0, "Member 'ABFGDestructionEffect_Clouds::M_EffectData' has a wrong offset!");

// Class BFGCore.BFGWidget_HUD_BossHealthbar
// 0x0030 (0x0328 - 0x02F8)
class UBFGWidget_HUD_BossHealthbar : public UBFGWidget_HUD
{
public:
	float                                         M_fhealthValue;                                    // 0x02F8(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         M_iPhaseValue;                                     // 0x02FC(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         M_iNumberofPhases;                                 // 0x0300(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_304[0x4];                                      // 0x0304(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class FText                                   M_strBossName;                                     // 0x0308(0x0018)(BlueprintVisible, BlueprintReadOnly, NativeAccessSpecifierPublic)
	EBFGBossPhaseWidget                           M_ePhaseValue;                                     // 0x0320(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_321[0x7];                                      // 0x0321(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void OnHealthChanged(float _fHealth);
	void OnPhaseChanged(int32 _iPhase);
	void OnSetMaxBossPhases(int32 _iMaxPhases);
	void OnSetupPhase();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"BFGWidget_HUD_BossHealthbar">();
	}
	static class UBFGWidget_HUD_BossHealthbar* GetDefaultObj()
	{
		return GetDefaultObjImpl<UBFGWidget_HUD_BossHealthbar>();
	}
};
static_assert(alignof(UBFGWidget_HUD_BossHealthbar) == 0x000008, "Wrong alignment on UBFGWidget_HUD_BossHealthbar");
static_assert(sizeof(UBFGWidget_HUD_BossHealthbar) == 0x000328, "Wrong size on UBFGWidget_HUD_BossHealthbar");
static_assert(offsetof(UBFGWidget_HUD_BossHealthbar, M_fhealthValue) == 0x0002F8, "Member 'UBFGWidget_HUD_BossHealthbar::M_fhealthValue' has a wrong offset!");
static_assert(offsetof(UBFGWidget_HUD_BossHealthbar, M_iPhaseValue) == 0x0002FC, "Member 'UBFGWidget_HUD_BossHealthbar::M_iPhaseValue' has a wrong offset!");
static_assert(offsetof(UBFGWidget_HUD_BossHealthbar, M_iNumberofPhases) == 0x000300, "Member 'UBFGWidget_HUD_BossHealthbar::M_iNumberofPhases' has a wrong offset!");
static_assert(offsetof(UBFGWidget_HUD_BossHealthbar, M_strBossName) == 0x000308, "Member 'UBFGWidget_HUD_BossHealthbar::M_strBossName' has a wrong offset!");
static_assert(offsetof(UBFGWidget_HUD_BossHealthbar, M_ePhaseValue) == 0x000320, "Member 'UBFGWidget_HUD_BossHealthbar::M_ePhaseValue' has a wrong offset!");

// Class BFGCore.BFGAlertSystemReportCheck
// 0x0008 (0x0030 - 0x0028)
class UBFGAlertSystemReportCheck : public UObject
{
public:
	bool                                          M_bInversCondition;                                // 0x0028(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_29[0x7];                                       // 0x0029(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"BFGAlertSystemReportCheck">();
	}
	static class UBFGAlertSystemReportCheck* GetDefaultObj()
	{
		return GetDefaultObjImpl<UBFGAlertSystemReportCheck>();
	}
};
static_assert(alignof(UBFGAlertSystemReportCheck) == 0x000008, "Wrong alignment on UBFGAlertSystemReportCheck");
static_assert(sizeof(UBFGAlertSystemReportCheck) == 0x000030, "Wrong size on UBFGAlertSystemReportCheck");
static_assert(offsetof(UBFGAlertSystemReportCheck, M_bInversCondition) == 0x000028, "Member 'UBFGAlertSystemReportCheck::M_bInversCondition' has a wrong offset!");

// Class BFGCore.BFGAlertSystemReportCheck_Distance
// 0x0028 (0x0058 - 0x0030)
class UBFGAlertSystemReportCheck_Distance final : public UBFGAlertSystemReportCheck
{
public:
	struct FBlackboardKeySelector                 M_BBKeySuspisciousTarget;                          // 0x0030(0x0028)(Edit, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"BFGAlertSystemReportCheck_Distance">();
	}
	static class UBFGAlertSystemReportCheck_Distance* GetDefaultObj()
	{
		return GetDefaultObjImpl<UBFGAlertSystemReportCheck_Distance>();
	}
};
static_assert(alignof(UBFGAlertSystemReportCheck_Distance) == 0x000008, "Wrong alignment on UBFGAlertSystemReportCheck_Distance");
static_assert(sizeof(UBFGAlertSystemReportCheck_Distance) == 0x000058, "Wrong size on UBFGAlertSystemReportCheck_Distance");
static_assert(offsetof(UBFGAlertSystemReportCheck_Distance, M_BBKeySuspisciousTarget) == 0x000030, "Member 'UBFGAlertSystemReportCheck_Distance::M_BBKeySuspisciousTarget' has a wrong offset!");

// Class BFGCore.BFGNetworkPathAgent_AttachedEntity
// 0x0408 (0x0430 - 0x0028)
#pragma pack(push, 0x1)
class alignas(0x10) UBFGNetworkPathAgent_AttachedEntity : public UObject
{
public:
	UMulticastDelegateProperty_                   M_onAttachedActorChange;                           // 0x0028(0x0018)(ZeroConstructor, InstancedReference, NativeAccessSpecifierPublic)
	UMulticastDelegateProperty_                   M_onAttachedActorDead;                             // 0x0040(0x0018)(ZeroConstructor, InstancedReference, NativeAccessSpecifierPublic)
	uint8                                         Pad_58[0x10];                                      // 0x0058(0x0010)(Fixing Size After Last Property [ Dumper-7 ])
	struct FBFGAgentInstanceSaveRestoreData       M_agentSaveRestoreData;                            // 0x0068(0x0240)(Transient, Protected, NativeAccessSpecifierProtected)
	class UBFGNetworkPathAgent*                   M_pAgent;                                          // 0x02A8(0x0008)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class AActor*                                 M_pAttachedActor;                                  // 0x02B0(0x0008)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class AActor*                                 M_pHibernatedActor;                                // 0x02B8(0x0008)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TArray<class UActorComponent*>                M_apComponentsToThaw;                              // 0x02C0(0x0010)(ExportObject, ZeroConstructor, Transient, ContainsInstancedReference, Protected, NativeAccessSpecifierProtected)
	uint8                                         Pad_2D0[0x20];                                     // 0x02D0(0x0020)(Fixing Size After Last Property [ Dumper-7 ])
	TSubclassOf<class AActor>                     M_pActorType;                                      // 0x02F0(0x0008)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         M_fLastViewDistance;                               // 0x02F8(0x0004)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_2FC[0x4];                                      // 0x02FC(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	struct FBFGNetworkPathAgentLODInfo            M_lodInfo;                                         // 0x0300(0x0010)(Transient, Protected, NativeAccessSpecifierProtected)
	uint8                                         Pad_310[0x20];                                     // 0x0310(0x0020)(Fixing Size After Last Property [ Dumper-7 ])
	TMap<class UObject*, bool>                    M_aLODEnabledWithContext;                          // 0x0330(0x0050)(ZeroConstructor, Transient, Protected, NativeAccessSpecifierProtected)
	TArray<class UObject*>                        M_apResetLODEnabledContextsWhenDead;               // 0x0380(0x0010)(ZeroConstructor, Transient, Protected, NativeAccessSpecifierProtected)
	uint8                                         Pad_390[0x10];                                     // 0x0390(0x0010)(Fixing Size After Last Property [ Dumper-7 ])
	struct FBFGAgentAttachedEntityDamage          M_lastReceivedDamage;                              // 0x03A0(0x0018)(Transient, NoDestructor, Protected, NativeAccessSpecifierProtected)
	class AController*                            M_pController;                                     // 0x03B8(0x0008)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_3C0[0x4];                                      // 0x03C0(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	EBFGBehaviourState_NPC                        M_behaviorStateNPC;                                // 0x03C4(0x0001)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_3C5[0xB];                                      // 0x03C5(0x000B)(Fixing Size After Last Property [ Dumper-7 ])
	class UBFGRadarManager*                       M_pRadarManager;                                   // 0x03D0(0x0008)(ExportObject, ZeroConstructor, Transient, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         M_fSpeakingRemainingTime;                          // 0x03D8(0x0004)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_3DC[0x4];                                      // 0x03DC(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	struct FTransform                             M_LocalComponentTransform;                         // 0x03E0(0x0030)(Transient, IsPlainOldData, NoDestructor, Protected, NativeAccessSpecifierProtected)
	uint8                                         Pad_410[0x4];                                      // 0x0410(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         M_fAgentWidth;                                     // 0x0414(0x0004)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         M_fAgentLength;                                    // 0x0418(0x0004)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_41C[0x4];                                      // 0x041C(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class UBFGTrafficCrowdManager*                M_pCrowdManager;                                   // 0x0420(0x0008)(ExportObject, ZeroConstructor, Transient, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)

public:
	void OnActorSpawned(class AActor* _pActor, bool _bPreFinalize);
	void OnAIStateChanged(EBFGBehaviourState_NPC _newState);
	void OnAttachedActorDestroyed(class AActor* _pActor);
	void OnDeadStatusChanged(class AActor* _pActor, class UBFGActorStat_Bool* _pStat);
	void OnHealthChanged(class AActor* _pActor, class UBFGActorStat_Float* _pStat);
	void OnHealthDamaged(class UBFGActorComponent_PawnDamage* _pPawnDamage, float _fDamage, class AActor* _pDamageCauser, const class UBFGDamageType* _pDamageType, const struct FVector& _rShotDirection, const struct FHitResult& _oHitResult);

	int32 GetLightweightActorHandle() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"BFGNetworkPathAgent_AttachedEntity">();
	}
	static class UBFGNetworkPathAgent_AttachedEntity* GetDefaultObj()
	{
		return GetDefaultObjImpl<UBFGNetworkPathAgent_AttachedEntity>();
	}
};
#pragma pack(pop)
static_assert(alignof(UBFGNetworkPathAgent_AttachedEntity) == 0x000010, "Wrong alignment on UBFGNetworkPathAgent_AttachedEntity");
static_assert(sizeof(UBFGNetworkPathAgent_AttachedEntity) == 0x000430, "Wrong size on UBFGNetworkPathAgent_AttachedEntity");
static_assert(offsetof(UBFGNetworkPathAgent_AttachedEntity, M_onAttachedActorChange) == 0x000028, "Member 'UBFGNetworkPathAgent_AttachedEntity::M_onAttachedActorChange' has a wrong offset!");
static_assert(offsetof(UBFGNetworkPathAgent_AttachedEntity, M_onAttachedActorDead) == 0x000040, "Member 'UBFGNetworkPathAgent_AttachedEntity::M_onAttachedActorDead' has a wrong offset!");
static_assert(offsetof(UBFGNetworkPathAgent_AttachedEntity, M_agentSaveRestoreData) == 0x000068, "Member 'UBFGNetworkPathAgent_AttachedEntity::M_agentSaveRestoreData' has a wrong offset!");
static_assert(offsetof(UBFGNetworkPathAgent_AttachedEntity, M_pAgent) == 0x0002A8, "Member 'UBFGNetworkPathAgent_AttachedEntity::M_pAgent' has a wrong offset!");
static_assert(offsetof(UBFGNetworkPathAgent_AttachedEntity, M_pAttachedActor) == 0x0002B0, "Member 'UBFGNetworkPathAgent_AttachedEntity::M_pAttachedActor' has a wrong offset!");
static_assert(offsetof(UBFGNetworkPathAgent_AttachedEntity, M_pHibernatedActor) == 0x0002B8, "Member 'UBFGNetworkPathAgent_AttachedEntity::M_pHibernatedActor' has a wrong offset!");
static_assert(offsetof(UBFGNetworkPathAgent_AttachedEntity, M_apComponentsToThaw) == 0x0002C0, "Member 'UBFGNetworkPathAgent_AttachedEntity::M_apComponentsToThaw' has a wrong offset!");
static_assert(offsetof(UBFGNetworkPathAgent_AttachedEntity, M_pActorType) == 0x0002F0, "Member 'UBFGNetworkPathAgent_AttachedEntity::M_pActorType' has a wrong offset!");
static_assert(offsetof(UBFGNetworkPathAgent_AttachedEntity, M_fLastViewDistance) == 0x0002F8, "Member 'UBFGNetworkPathAgent_AttachedEntity::M_fLastViewDistance' has a wrong offset!");
static_assert(offsetof(UBFGNetworkPathAgent_AttachedEntity, M_lodInfo) == 0x000300, "Member 'UBFGNetworkPathAgent_AttachedEntity::M_lodInfo' has a wrong offset!");
static_assert(offsetof(UBFGNetworkPathAgent_AttachedEntity, M_aLODEnabledWithContext) == 0x000330, "Member 'UBFGNetworkPathAgent_AttachedEntity::M_aLODEnabledWithContext' has a wrong offset!");
static_assert(offsetof(UBFGNetworkPathAgent_AttachedEntity, M_apResetLODEnabledContextsWhenDead) == 0x000380, "Member 'UBFGNetworkPathAgent_AttachedEntity::M_apResetLODEnabledContextsWhenDead' has a wrong offset!");
static_assert(offsetof(UBFGNetworkPathAgent_AttachedEntity, M_lastReceivedDamage) == 0x0003A0, "Member 'UBFGNetworkPathAgent_AttachedEntity::M_lastReceivedDamage' has a wrong offset!");
static_assert(offsetof(UBFGNetworkPathAgent_AttachedEntity, M_pController) == 0x0003B8, "Member 'UBFGNetworkPathAgent_AttachedEntity::M_pController' has a wrong offset!");
static_assert(offsetof(UBFGNetworkPathAgent_AttachedEntity, M_behaviorStateNPC) == 0x0003C4, "Member 'UBFGNetworkPathAgent_AttachedEntity::M_behaviorStateNPC' has a wrong offset!");
static_assert(offsetof(UBFGNetworkPathAgent_AttachedEntity, M_pRadarManager) == 0x0003D0, "Member 'UBFGNetworkPathAgent_AttachedEntity::M_pRadarManager' has a wrong offset!");
static_assert(offsetof(UBFGNetworkPathAgent_AttachedEntity, M_fSpeakingRemainingTime) == 0x0003D8, "Member 'UBFGNetworkPathAgent_AttachedEntity::M_fSpeakingRemainingTime' has a wrong offset!");
static_assert(offsetof(UBFGNetworkPathAgent_AttachedEntity, M_LocalComponentTransform) == 0x0003E0, "Member 'UBFGNetworkPathAgent_AttachedEntity::M_LocalComponentTransform' has a wrong offset!");
static_assert(offsetof(UBFGNetworkPathAgent_AttachedEntity, M_fAgentWidth) == 0x000414, "Member 'UBFGNetworkPathAgent_AttachedEntity::M_fAgentWidth' has a wrong offset!");
static_assert(offsetof(UBFGNetworkPathAgent_AttachedEntity, M_fAgentLength) == 0x000418, "Member 'UBFGNetworkPathAgent_AttachedEntity::M_fAgentLength' has a wrong offset!");
static_assert(offsetof(UBFGNetworkPathAgent_AttachedEntity, M_pCrowdManager) == 0x000420, "Member 'UBFGNetworkPathAgent_AttachedEntity::M_pCrowdManager' has a wrong offset!");

// Class BFGCore.BFGNetworkPathAgent_AttachedEntityNpc
// 0x0040 (0x0470 - 0x0430)
class UBFGNetworkPathAgent_AttachedEntityNpc final : public UBFGNetworkPathAgent_AttachedEntity
{
public:
	uint8                                         Pad_428[0x28];                                     // 0x0428(0x0028)(Fixing Size After Last Property [ Dumper-7 ])
	class UDataTable*                             M_pInteractAnimationTable;                         // 0x0450(0x0008)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          M_bApplyRotationOffsetOnSkeleton;                  // 0x0458(0x0001)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_459[0x3];                                      // 0x0459(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	struct FRotator                               M_vSkeletonRotationOffset;                         // 0x045C(0x000C)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, NativeAccessSpecifierProtected)
	uint8                                         Pad_468[0x8];                                      // 0x0468(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"BFGNetworkPathAgent_AttachedEntityNpc">();
	}
	static class UBFGNetworkPathAgent_AttachedEntityNpc* GetDefaultObj()
	{
		return GetDefaultObjImpl<UBFGNetworkPathAgent_AttachedEntityNpc>();
	}
};
static_assert(alignof(UBFGNetworkPathAgent_AttachedEntityNpc) == 0x000010, "Wrong alignment on UBFGNetworkPathAgent_AttachedEntityNpc");
static_assert(sizeof(UBFGNetworkPathAgent_AttachedEntityNpc) == 0x000470, "Wrong size on UBFGNetworkPathAgent_AttachedEntityNpc");
static_assert(offsetof(UBFGNetworkPathAgent_AttachedEntityNpc, M_pInteractAnimationTable) == 0x000450, "Member 'UBFGNetworkPathAgent_AttachedEntityNpc::M_pInteractAnimationTable' has a wrong offset!");
static_assert(offsetof(UBFGNetworkPathAgent_AttachedEntityNpc, M_bApplyRotationOffsetOnSkeleton) == 0x000458, "Member 'UBFGNetworkPathAgent_AttachedEntityNpc::M_bApplyRotationOffsetOnSkeleton' has a wrong offset!");
static_assert(offsetof(UBFGNetworkPathAgent_AttachedEntityNpc, M_vSkeletonRotationOffset) == 0x00045C, "Member 'UBFGNetworkPathAgent_AttachedEntityNpc::M_vSkeletonRotationOffset' has a wrong offset!");

// Class BFGCore.BFGVoiceoverPlaybackComponent_NoSoundWave
// 0x0008 (0x0280 - 0x0278)
class UBFGVoiceoverPlaybackComponent_NoSoundWave final : public UBFGVoiceoverPlaybackComponent
{
public:
	float                                         M_fShowDuration;                                   // 0x0278(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_27C[0x4];                                      // 0x027C(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"BFGVoiceoverPlaybackComponent_NoSoundWave">();
	}
	static class UBFGVoiceoverPlaybackComponent_NoSoundWave* GetDefaultObj()
	{
		return GetDefaultObjImpl<UBFGVoiceoverPlaybackComponent_NoSoundWave>();
	}
};
static_assert(alignof(UBFGVoiceoverPlaybackComponent_NoSoundWave) == 0x000008, "Wrong alignment on UBFGVoiceoverPlaybackComponent_NoSoundWave");
static_assert(sizeof(UBFGVoiceoverPlaybackComponent_NoSoundWave) == 0x000280, "Wrong size on UBFGVoiceoverPlaybackComponent_NoSoundWave");
static_assert(offsetof(UBFGVoiceoverPlaybackComponent_NoSoundWave, M_fShowDuration) == 0x000278, "Member 'UBFGVoiceoverPlaybackComponent_NoSoundWave::M_fShowDuration' has a wrong offset!");

// Class BFGCore.BFGAlertSystemReportCheck_Cower
// 0x0050 (0x0080 - 0x0030)
class UBFGAlertSystemReportCheck_Cower final : public UBFGAlertSystemReportCheck
{
public:
	struct FBlackboardKeySelector                 M_BBKeyNPCCowering;                                // 0x0030(0x0028)(Edit, NativeAccessSpecifierPublic)
	struct FBlackboardKeySelector                 M_BBKeyAlertSystemReportTimer;                     // 0x0058(0x0028)(Edit, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"BFGAlertSystemReportCheck_Cower">();
	}
	static class UBFGAlertSystemReportCheck_Cower* GetDefaultObj()
	{
		return GetDefaultObjImpl<UBFGAlertSystemReportCheck_Cower>();
	}
};
static_assert(alignof(UBFGAlertSystemReportCheck_Cower) == 0x000008, "Wrong alignment on UBFGAlertSystemReportCheck_Cower");
static_assert(sizeof(UBFGAlertSystemReportCheck_Cower) == 0x000080, "Wrong size on UBFGAlertSystemReportCheck_Cower");
static_assert(offsetof(UBFGAlertSystemReportCheck_Cower, M_BBKeyNPCCowering) == 0x000030, "Member 'UBFGAlertSystemReportCheck_Cower::M_BBKeyNPCCowering' has a wrong offset!");
static_assert(offsetof(UBFGAlertSystemReportCheck_Cower, M_BBKeyAlertSystemReportTimer) == 0x000058, "Member 'UBFGAlertSystemReportCheck_Cower::M_BBKeyAlertSystemReportTimer' has a wrong offset!");

// Class BFGCore.BFGAlertSystemReportCheck_Timer
// 0x0028 (0x0058 - 0x0030)
class UBFGAlertSystemReportCheck_Timer final : public UBFGAlertSystemReportCheck
{
public:
	struct FBlackboardKeySelector                 M_BBKeyAlertSystemReportTimer;                     // 0x0030(0x0028)(Edit, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"BFGAlertSystemReportCheck_Timer">();
	}
	static class UBFGAlertSystemReportCheck_Timer* GetDefaultObj()
	{
		return GetDefaultObjImpl<UBFGAlertSystemReportCheck_Timer>();
	}
};
static_assert(alignof(UBFGAlertSystemReportCheck_Timer) == 0x000008, "Wrong alignment on UBFGAlertSystemReportCheck_Timer");
static_assert(sizeof(UBFGAlertSystemReportCheck_Timer) == 0x000058, "Wrong size on UBFGAlertSystemReportCheck_Timer");
static_assert(offsetof(UBFGAlertSystemReportCheck_Timer, M_BBKeyAlertSystemReportTimer) == 0x000030, "Member 'UBFGAlertSystemReportCheck_Timer::M_BBKeyAlertSystemReportTimer' has a wrong offset!");

// Class BFGCore.BFGTransmogrifyTargetInterface
// 0x0000 (0x0028 - 0x0028)
class IBFGTransmogrifyTargetInterface final : public IInterface
{
public:
	void OnTransmogrifyComplete();
	void OnTransmogrifyStart();

	bool IsImmuneToTransmog() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"BFGTransmogrifyTargetInterface">();
	}
	static class IBFGTransmogrifyTargetInterface* GetDefaultObj()
	{
		return GetDefaultObjImpl<IBFGTransmogrifyTargetInterface>();
	}
};
static_assert(alignof(IBFGTransmogrifyTargetInterface) == 0x000008, "Wrong alignment on IBFGTransmogrifyTargetInterface");
static_assert(sizeof(IBFGTransmogrifyTargetInterface) == 0x000028, "Wrong size on IBFGTransmogrifyTargetInterface");

// Class BFGCore.BFGDetectionPostprocessor_AnimalMovementSpeed
// 0x0058 (0x0080 - 0x0028)
class UBFGDetectionPostprocessor_AnimalMovementSpeed final : public UBFGDetectionPostProcessor
{
public:
	float                                         M_fRunDuration;                                    // 0x0028(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         M_fRunDurationRandomizationFactor;                 // 0x002C(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         M_fTrotDuration;                                   // 0x0030(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         M_fTrotDurationRandomizationFactor;                // 0x0034(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FGameplayTagQuery                      M_oForceRunGameplayEffectQuery;                    // 0x0038(0x0048)(Edit, BlueprintVisible, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"BFGDetectionPostprocessor_AnimalMovementSpeed">();
	}
	static class UBFGDetectionPostprocessor_AnimalMovementSpeed* GetDefaultObj()
	{
		return GetDefaultObjImpl<UBFGDetectionPostprocessor_AnimalMovementSpeed>();
	}
};
static_assert(alignof(UBFGDetectionPostprocessor_AnimalMovementSpeed) == 0x000008, "Wrong alignment on UBFGDetectionPostprocessor_AnimalMovementSpeed");
static_assert(sizeof(UBFGDetectionPostprocessor_AnimalMovementSpeed) == 0x000080, "Wrong size on UBFGDetectionPostprocessor_AnimalMovementSpeed");
static_assert(offsetof(UBFGDetectionPostprocessor_AnimalMovementSpeed, M_fRunDuration) == 0x000028, "Member 'UBFGDetectionPostprocessor_AnimalMovementSpeed::M_fRunDuration' has a wrong offset!");
static_assert(offsetof(UBFGDetectionPostprocessor_AnimalMovementSpeed, M_fRunDurationRandomizationFactor) == 0x00002C, "Member 'UBFGDetectionPostprocessor_AnimalMovementSpeed::M_fRunDurationRandomizationFactor' has a wrong offset!");
static_assert(offsetof(UBFGDetectionPostprocessor_AnimalMovementSpeed, M_fTrotDuration) == 0x000030, "Member 'UBFGDetectionPostprocessor_AnimalMovementSpeed::M_fTrotDuration' has a wrong offset!");
static_assert(offsetof(UBFGDetectionPostprocessor_AnimalMovementSpeed, M_fTrotDurationRandomizationFactor) == 0x000034, "Member 'UBFGDetectionPostprocessor_AnimalMovementSpeed::M_fTrotDurationRandomizationFactor' has a wrong offset!");
static_assert(offsetof(UBFGDetectionPostprocessor_AnimalMovementSpeed, M_oForceRunGameplayEffectQuery) == 0x000038, "Member 'UBFGDetectionPostprocessor_AnimalMovementSpeed::M_oForceRunGameplayEffectQuery' has a wrong offset!");

// Class BFGCore.BFGNetworkPath_RelativeDistanceCalculator
// 0x0020 (0x0048 - 0x0028)
class UBFGNetworkPath_RelativeDistanceCalculator final : public UObject
{
public:
	class UBFGNetworkPath_RelativeDistanceCalculator_StartSegment* M_pStartSegment;                                   // 0x0028(0x0008)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UBFGNetworkPath_RelativeDistanceCalculator_Transition* M_pStartTransition;                                // 0x0030(0x0008)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UBFGNetworkPath_RelativeDistanceCalculator_Transition* M_pEndTransition;                                  // 0x0038(0x0008)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UBFGNetworkPath_RelativeDistanceCalculator_EndSegment* M_pEndSegment;                                     // 0x0040(0x0008)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"BFGNetworkPath_RelativeDistanceCalculator">();
	}
	static class UBFGNetworkPath_RelativeDistanceCalculator* GetDefaultObj()
	{
		return GetDefaultObjImpl<UBFGNetworkPath_RelativeDistanceCalculator>();
	}
};
static_assert(alignof(UBFGNetworkPath_RelativeDistanceCalculator) == 0x000008, "Wrong alignment on UBFGNetworkPath_RelativeDistanceCalculator");
static_assert(sizeof(UBFGNetworkPath_RelativeDistanceCalculator) == 0x000048, "Wrong size on UBFGNetworkPath_RelativeDistanceCalculator");
static_assert(offsetof(UBFGNetworkPath_RelativeDistanceCalculator, M_pStartSegment) == 0x000028, "Member 'UBFGNetworkPath_RelativeDistanceCalculator::M_pStartSegment' has a wrong offset!");
static_assert(offsetof(UBFGNetworkPath_RelativeDistanceCalculator, M_pStartTransition) == 0x000030, "Member 'UBFGNetworkPath_RelativeDistanceCalculator::M_pStartTransition' has a wrong offset!");
static_assert(offsetof(UBFGNetworkPath_RelativeDistanceCalculator, M_pEndTransition) == 0x000038, "Member 'UBFGNetworkPath_RelativeDistanceCalculator::M_pEndTransition' has a wrong offset!");
static_assert(offsetof(UBFGNetworkPath_RelativeDistanceCalculator, M_pEndSegment) == 0x000040, "Member 'UBFGNetworkPath_RelativeDistanceCalculator::M_pEndSegment' has a wrong offset!");

// Class BFGCore.BFGBTService_CivilianCombat
// 0x0080 (0x00F8 - 0x0078)
class UBFGBTService_CivilianCombat final : public UBFGBTBaseService
{
public:
	struct FBlackboardKeySelector                 M_BBKeyIsAbleToAttack;                             // 0x0078(0x0028)(Edit, BlueprintVisible, NativeAccessSpecifierPublic)
	struct FBlackboardKeySelector                 M_BBKeyInAttackTarget;                             // 0x00A0(0x0028)(Edit, BlueprintVisible, NativeAccessSpecifierPublic)
	uint8                                         Pad_C8[0x30];                                      // 0x00C8(0x0030)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"BFGBTService_CivilianCombat">();
	}
	static class UBFGBTService_CivilianCombat* GetDefaultObj()
	{
		return GetDefaultObjImpl<UBFGBTService_CivilianCombat>();
	}
};
static_assert(alignof(UBFGBTService_CivilianCombat) == 0x000008, "Wrong alignment on UBFGBTService_CivilianCombat");
static_assert(sizeof(UBFGBTService_CivilianCombat) == 0x0000F8, "Wrong size on UBFGBTService_CivilianCombat");
static_assert(offsetof(UBFGBTService_CivilianCombat, M_BBKeyIsAbleToAttack) == 0x000078, "Member 'UBFGBTService_CivilianCombat::M_BBKeyIsAbleToAttack' has a wrong offset!");
static_assert(offsetof(UBFGBTService_CivilianCombat, M_BBKeyInAttackTarget) == 0x0000A0, "Member 'UBFGBTService_CivilianCombat::M_BBKeyInAttackTarget' has a wrong offset!");

// Class BFGCore.BFGDataAssetGenericMenuDescription
// 0x0050 (0x0080 - 0x0030)
class UBFGDataAssetGenericMenuDescription final : public UDataAsset
{
public:
	class FText                                   M_strAcceptButtonDescription;                      // 0x0030(0x0018)(Edit, BlueprintVisible, BlueprintReadOnly, DisableEditOnInstance, NativeAccessSpecifierPublic)
	class FText                                   M_strBackButtonDescription;                        // 0x0048(0x0018)(Edit, BlueprintVisible, BlueprintReadOnly, DisableEditOnInstance, NativeAccessSpecifierPublic)
	class FText                                   M_strMenuTopic;                                    // 0x0060(0x0018)(Edit, BlueprintVisible, BlueprintReadOnly, DisableEditOnInstance, NativeAccessSpecifierPublic)
	bool                                          M_bShowAcceptButton;                               // 0x0078(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_79[0x7];                                       // 0x0079(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"BFGDataAssetGenericMenuDescription">();
	}
	static class UBFGDataAssetGenericMenuDescription* GetDefaultObj()
	{
		return GetDefaultObjImpl<UBFGDataAssetGenericMenuDescription>();
	}
};
static_assert(alignof(UBFGDataAssetGenericMenuDescription) == 0x000008, "Wrong alignment on UBFGDataAssetGenericMenuDescription");
static_assert(sizeof(UBFGDataAssetGenericMenuDescription) == 0x000080, "Wrong size on UBFGDataAssetGenericMenuDescription");
static_assert(offsetof(UBFGDataAssetGenericMenuDescription, M_strAcceptButtonDescription) == 0x000030, "Member 'UBFGDataAssetGenericMenuDescription::M_strAcceptButtonDescription' has a wrong offset!");
static_assert(offsetof(UBFGDataAssetGenericMenuDescription, M_strBackButtonDescription) == 0x000048, "Member 'UBFGDataAssetGenericMenuDescription::M_strBackButtonDescription' has a wrong offset!");
static_assert(offsetof(UBFGDataAssetGenericMenuDescription, M_strMenuTopic) == 0x000060, "Member 'UBFGDataAssetGenericMenuDescription::M_strMenuTopic' has a wrong offset!");
static_assert(offsetof(UBFGDataAssetGenericMenuDescription, M_bShowAcceptButton) == 0x000078, "Member 'UBFGDataAssetGenericMenuDescription::M_bShowAcceptButton' has a wrong offset!");

// Class BFGCore.BFGBTService_CivilianFleeState
// 0x0060 (0x00D8 - 0x0078)
class UBFGBTService_CivilianFleeState final : public UBFGBTBaseService
{
public:
	struct FBlackboardKeySelector                 M_BBKeyCowerRequested;                             // 0x0078(0x0028)(Edit, NativeAccessSpecifierPublic)
	struct FBlackboardKeySelector                 M_BBKeySuspiciousTarget;                           // 0x00A0(0x0028)(Edit, NativeAccessSpecifierPublic)
	float                                         M_fStartRangeWithLoS;                              // 0x00C8(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         M_fStartRangeNoLoS;                                // 0x00CC(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         M_fStopRangeWithLoS;                               // 0x00D0(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         M_fStopRangeNoLoS;                                 // 0x00D4(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"BFGBTService_CivilianFleeState">();
	}
	static class UBFGBTService_CivilianFleeState* GetDefaultObj()
	{
		return GetDefaultObjImpl<UBFGBTService_CivilianFleeState>();
	}
};
static_assert(alignof(UBFGBTService_CivilianFleeState) == 0x000008, "Wrong alignment on UBFGBTService_CivilianFleeState");
static_assert(sizeof(UBFGBTService_CivilianFleeState) == 0x0000D8, "Wrong size on UBFGBTService_CivilianFleeState");
static_assert(offsetof(UBFGBTService_CivilianFleeState, M_BBKeyCowerRequested) == 0x000078, "Member 'UBFGBTService_CivilianFleeState::M_BBKeyCowerRequested' has a wrong offset!");
static_assert(offsetof(UBFGBTService_CivilianFleeState, M_BBKeySuspiciousTarget) == 0x0000A0, "Member 'UBFGBTService_CivilianFleeState::M_BBKeySuspiciousTarget' has a wrong offset!");
static_assert(offsetof(UBFGBTService_CivilianFleeState, M_fStartRangeWithLoS) == 0x0000C8, "Member 'UBFGBTService_CivilianFleeState::M_fStartRangeWithLoS' has a wrong offset!");
static_assert(offsetof(UBFGBTService_CivilianFleeState, M_fStartRangeNoLoS) == 0x0000CC, "Member 'UBFGBTService_CivilianFleeState::M_fStartRangeNoLoS' has a wrong offset!");
static_assert(offsetof(UBFGBTService_CivilianFleeState, M_fStopRangeWithLoS) == 0x0000D0, "Member 'UBFGBTService_CivilianFleeState::M_fStopRangeWithLoS' has a wrong offset!");
static_assert(offsetof(UBFGBTService_CivilianFleeState, M_fStopRangeNoLoS) == 0x0000D4, "Member 'UBFGBTService_CivilianFleeState::M_fStopRangeNoLoS' has a wrong offset!");

// Class BFGCore.BFGWidget_HUD_ProximityMonitors
// 0x0010 (0x0308 - 0x02F8)
class UBFGWidget_HUD_ProximityMonitors : public UBFGWidget_HUD
{
public:
	TArray<class UBFGWidget_HUD_ProximityMonitor*> M_aMonitorWidgets;                                 // 0x02F8(0x0010)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, ContainsInstancedReference, Protected, NativeAccessSpecifierProtected)

public:
	void OnLayoutChanged();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"BFGWidget_HUD_ProximityMonitors">();
	}
	static class UBFGWidget_HUD_ProximityMonitors* GetDefaultObj()
	{
		return GetDefaultObjImpl<UBFGWidget_HUD_ProximityMonitors>();
	}
};
static_assert(alignof(UBFGWidget_HUD_ProximityMonitors) == 0x000008, "Wrong alignment on UBFGWidget_HUD_ProximityMonitors");
static_assert(sizeof(UBFGWidget_HUD_ProximityMonitors) == 0x000308, "Wrong size on UBFGWidget_HUD_ProximityMonitors");
static_assert(offsetof(UBFGWidget_HUD_ProximityMonitors, M_aMonitorWidgets) == 0x0002F8, "Member 'UBFGWidget_HUD_ProximityMonitors::M_aMonitorWidgets' has a wrong offset!");

// Class BFGCore.BFGBTService_CluckthulhuCombat
// 0x00F8 (0x04B0 - 0x03B8)
class UBFGBTService_CluckthulhuCombat final : public UBFGBTService_NPCCombat
{
public:
	struct FBlackboardKeySelector                 M_BBKeyShouldBasicGunAttack;                       // 0x03B8(0x0028)(Edit, Protected, NativeAccessSpecifierProtected)
	TSoftClassPtr<class UClass>                   M_pBasicGunWeapon;                                 // 0x03E0(0x0028)(Edit, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	struct FBlackboardKeySelector                 M_BBKeyShouldLaserEyeAttack;                       // 0x0408(0x0028)(Edit, Protected, NativeAccessSpecifierProtected)
	TSoftClassPtr<class UClass>                   M_pLaserEyeWeapon;                                 // 0x0430(0x0028)(Edit, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	struct FBlackboardKeySelector                 M_BBKeyProximityEggAttack;                         // 0x0458(0x0028)(Edit, Protected, NativeAccessSpecifierProtected)
	TSoftClassPtr<class UClass>                   M_pProximityEggsWeapon;                            // 0x0480(0x0028)(Edit, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_4A8[0x8];                                      // 0x04A8(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"BFGBTService_CluckthulhuCombat">();
	}
	static class UBFGBTService_CluckthulhuCombat* GetDefaultObj()
	{
		return GetDefaultObjImpl<UBFGBTService_CluckthulhuCombat>();
	}
};
static_assert(alignof(UBFGBTService_CluckthulhuCombat) == 0x000008, "Wrong alignment on UBFGBTService_CluckthulhuCombat");
static_assert(sizeof(UBFGBTService_CluckthulhuCombat) == 0x0004B0, "Wrong size on UBFGBTService_CluckthulhuCombat");
static_assert(offsetof(UBFGBTService_CluckthulhuCombat, M_BBKeyShouldBasicGunAttack) == 0x0003B8, "Member 'UBFGBTService_CluckthulhuCombat::M_BBKeyShouldBasicGunAttack' has a wrong offset!");
static_assert(offsetof(UBFGBTService_CluckthulhuCombat, M_pBasicGunWeapon) == 0x0003E0, "Member 'UBFGBTService_CluckthulhuCombat::M_pBasicGunWeapon' has a wrong offset!");
static_assert(offsetof(UBFGBTService_CluckthulhuCombat, M_BBKeyShouldLaserEyeAttack) == 0x000408, "Member 'UBFGBTService_CluckthulhuCombat::M_BBKeyShouldLaserEyeAttack' has a wrong offset!");
static_assert(offsetof(UBFGBTService_CluckthulhuCombat, M_pLaserEyeWeapon) == 0x000430, "Member 'UBFGBTService_CluckthulhuCombat::M_pLaserEyeWeapon' has a wrong offset!");
static_assert(offsetof(UBFGBTService_CluckthulhuCombat, M_BBKeyProximityEggAttack) == 0x000458, "Member 'UBFGBTService_CluckthulhuCombat::M_BBKeyProximityEggAttack' has a wrong offset!");
static_assert(offsetof(UBFGBTService_CluckthulhuCombat, M_pProximityEggsWeapon) == 0x000480, "Member 'UBFGBTService_CluckthulhuCombat::M_pProximityEggsWeapon' has a wrong offset!");

// Class BFGCore.BFGBTService_ContinuousEQS
// 0x00E0 (0x0158 - 0x0078)
class UBFGBTService_ContinuousEQS final : public UBFGBTBaseService
{
public:
	struct FBlackboardKeySelector                 M_BBKeyTargetLocation;                             // 0x0078(0x0028)(Edit, NativeAccessSpecifierPublic)
	struct FBlackboardKeySelector                 M_BBKeyHasTargetLocation;                          // 0x00A0(0x0028)(Edit, NativeAccessSpecifierPublic)
	class UEnvQuery*                              M_pMainQuery;                                      // 0x00C8(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UEnvQuery*                              M_pFallbackQuery;                                  // 0x00D0(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EEnvQueryRunMode                              M_runMode;                                         // 0x00D8(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_D9[0x7];                                       // 0x00D9(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	struct FEnvQueryRequest                       M_queryRequest;                                    // 0x00E0(0x0068)(Transient, Protected, NativeAccessSpecifierProtected)
	class UBehaviorTreeComponent*                 M_pOwnerComponent;                                 // 0x0148(0x0008)(ExportObject, ZeroConstructor, Transient, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_150[0x8];                                      // 0x0150(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"BFGBTService_ContinuousEQS">();
	}
	static class UBFGBTService_ContinuousEQS* GetDefaultObj()
	{
		return GetDefaultObjImpl<UBFGBTService_ContinuousEQS>();
	}
};
static_assert(alignof(UBFGBTService_ContinuousEQS) == 0x000008, "Wrong alignment on UBFGBTService_ContinuousEQS");
static_assert(sizeof(UBFGBTService_ContinuousEQS) == 0x000158, "Wrong size on UBFGBTService_ContinuousEQS");
static_assert(offsetof(UBFGBTService_ContinuousEQS, M_BBKeyTargetLocation) == 0x000078, "Member 'UBFGBTService_ContinuousEQS::M_BBKeyTargetLocation' has a wrong offset!");
static_assert(offsetof(UBFGBTService_ContinuousEQS, M_BBKeyHasTargetLocation) == 0x0000A0, "Member 'UBFGBTService_ContinuousEQS::M_BBKeyHasTargetLocation' has a wrong offset!");
static_assert(offsetof(UBFGBTService_ContinuousEQS, M_pMainQuery) == 0x0000C8, "Member 'UBFGBTService_ContinuousEQS::M_pMainQuery' has a wrong offset!");
static_assert(offsetof(UBFGBTService_ContinuousEQS, M_pFallbackQuery) == 0x0000D0, "Member 'UBFGBTService_ContinuousEQS::M_pFallbackQuery' has a wrong offset!");
static_assert(offsetof(UBFGBTService_ContinuousEQS, M_runMode) == 0x0000D8, "Member 'UBFGBTService_ContinuousEQS::M_runMode' has a wrong offset!");
static_assert(offsetof(UBFGBTService_ContinuousEQS, M_queryRequest) == 0x0000E0, "Member 'UBFGBTService_ContinuousEQS::M_queryRequest' has a wrong offset!");
static_assert(offsetof(UBFGBTService_ContinuousEQS, M_pOwnerComponent) == 0x000148, "Member 'UBFGBTService_ContinuousEQS::M_pOwnerComponent' has a wrong offset!");

// Class BFGCore.BFGNetworkPathAgent_Navigation
// 0x03D8 (0x0400 - 0x0028)
#pragma pack(push, 0x1)
class alignas(0x10) UBFGNetworkPathAgent_Navigation : public UObject
{
public:
	class UBFGNetworkPathAgent_NavModeBase*       M_pCurrentNavigation;                              // 0x0028(0x0008)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UBFGNetworkPathAgent_NavModeNetworkPathRandom* M_pRandomPathNavigation;                           // 0x0030(0x0008)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UBFGNetworkPathAgent_NavModeNetworkPathScriptedPath* M_pScriptedPathNavigation;                         // 0x0038(0x0008)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UBFGNetworkPathAgent_NavModeTargetLocation* M_pNavModeTargetLocation;                          // 0x0040(0x0008)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UBFGNetworkPathAgent_NavModeStationary* M_pStationaryNavigation;                           // 0x0048(0x0008)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UBFGNetworkPathAgent*                   M_pAgent;                                          // 0x0050(0x0008)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_58[0x8];                                       // 0x0058(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	struct FBFGNetworkPathNavigationData          M_navigationData;                                  // 0x0060(0x0370)(Transient, Protected, NativeAccessSpecifierProtected)
	class AActor*                                 M_pGoal;                                           // 0x03D0(0x0008)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          M_bIntersectionAlwaysGranted;                      // 0x03D8(0x0001)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          M_bJoiningNetwork;                                 // 0x03D9(0x0001)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          M_bAutoUpdateLocationOnSpline;                     // 0x03DA(0x0001)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	EBFGNetworkPathLocalization                   M_eLocalization;                                   // 0x03DB(0x0001)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	struct FVector                                M_vSegmentDirection;                               // 0x03DC(0x000C)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          M_bAllowsPathShortcut;                             // 0x03E8(0x0001)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_3E9[0x3];                                      // 0x03E9(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         M_fDefaultExtension;                               // 0x03EC(0x0004)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          M_bTrackerDrivenNavigation;                        // 0x03F0(0x0001)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_3F1[0x7];                                      // 0x03F1(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"BFGNetworkPathAgent_Navigation">();
	}
	static class UBFGNetworkPathAgent_Navigation* GetDefaultObj()
	{
		return GetDefaultObjImpl<UBFGNetworkPathAgent_Navigation>();
	}
};
#pragma pack(pop)
static_assert(alignof(UBFGNetworkPathAgent_Navigation) == 0x000010, "Wrong alignment on UBFGNetworkPathAgent_Navigation");
static_assert(sizeof(UBFGNetworkPathAgent_Navigation) == 0x000400, "Wrong size on UBFGNetworkPathAgent_Navigation");
static_assert(offsetof(UBFGNetworkPathAgent_Navigation, M_pCurrentNavigation) == 0x000028, "Member 'UBFGNetworkPathAgent_Navigation::M_pCurrentNavigation' has a wrong offset!");
static_assert(offsetof(UBFGNetworkPathAgent_Navigation, M_pRandomPathNavigation) == 0x000030, "Member 'UBFGNetworkPathAgent_Navigation::M_pRandomPathNavigation' has a wrong offset!");
static_assert(offsetof(UBFGNetworkPathAgent_Navigation, M_pScriptedPathNavigation) == 0x000038, "Member 'UBFGNetworkPathAgent_Navigation::M_pScriptedPathNavigation' has a wrong offset!");
static_assert(offsetof(UBFGNetworkPathAgent_Navigation, M_pNavModeTargetLocation) == 0x000040, "Member 'UBFGNetworkPathAgent_Navigation::M_pNavModeTargetLocation' has a wrong offset!");
static_assert(offsetof(UBFGNetworkPathAgent_Navigation, M_pStationaryNavigation) == 0x000048, "Member 'UBFGNetworkPathAgent_Navigation::M_pStationaryNavigation' has a wrong offset!");
static_assert(offsetof(UBFGNetworkPathAgent_Navigation, M_pAgent) == 0x000050, "Member 'UBFGNetworkPathAgent_Navigation::M_pAgent' has a wrong offset!");
static_assert(offsetof(UBFGNetworkPathAgent_Navigation, M_navigationData) == 0x000060, "Member 'UBFGNetworkPathAgent_Navigation::M_navigationData' has a wrong offset!");
static_assert(offsetof(UBFGNetworkPathAgent_Navigation, M_pGoal) == 0x0003D0, "Member 'UBFGNetworkPathAgent_Navigation::M_pGoal' has a wrong offset!");
static_assert(offsetof(UBFGNetworkPathAgent_Navigation, M_bIntersectionAlwaysGranted) == 0x0003D8, "Member 'UBFGNetworkPathAgent_Navigation::M_bIntersectionAlwaysGranted' has a wrong offset!");
static_assert(offsetof(UBFGNetworkPathAgent_Navigation, M_bJoiningNetwork) == 0x0003D9, "Member 'UBFGNetworkPathAgent_Navigation::M_bJoiningNetwork' has a wrong offset!");
static_assert(offsetof(UBFGNetworkPathAgent_Navigation, M_bAutoUpdateLocationOnSpline) == 0x0003DA, "Member 'UBFGNetworkPathAgent_Navigation::M_bAutoUpdateLocationOnSpline' has a wrong offset!");
static_assert(offsetof(UBFGNetworkPathAgent_Navigation, M_eLocalization) == 0x0003DB, "Member 'UBFGNetworkPathAgent_Navigation::M_eLocalization' has a wrong offset!");
static_assert(offsetof(UBFGNetworkPathAgent_Navigation, M_vSegmentDirection) == 0x0003DC, "Member 'UBFGNetworkPathAgent_Navigation::M_vSegmentDirection' has a wrong offset!");
static_assert(offsetof(UBFGNetworkPathAgent_Navigation, M_bAllowsPathShortcut) == 0x0003E8, "Member 'UBFGNetworkPathAgent_Navigation::M_bAllowsPathShortcut' has a wrong offset!");
static_assert(offsetof(UBFGNetworkPathAgent_Navigation, M_fDefaultExtension) == 0x0003EC, "Member 'UBFGNetworkPathAgent_Navigation::M_fDefaultExtension' has a wrong offset!");
static_assert(offsetof(UBFGNetworkPathAgent_Navigation, M_bTrackerDrivenNavigation) == 0x0003F0, "Member 'UBFGNetworkPathAgent_Navigation::M_bTrackerDrivenNavigation' has a wrong offset!");

// Class BFGCore.BFGNetworkPathAgent_NavigationNpc
// 0x0000 (0x0400 - 0x0400)
class UBFGNetworkPathAgent_NavigationNpc final : public UBFGNetworkPathAgent_Navigation
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"BFGNetworkPathAgent_NavigationNpc">();
	}
	static class UBFGNetworkPathAgent_NavigationNpc* GetDefaultObj()
	{
		return GetDefaultObjImpl<UBFGNetworkPathAgent_NavigationNpc>();
	}
};
static_assert(alignof(UBFGNetworkPathAgent_NavigationNpc) == 0x000010, "Wrong alignment on UBFGNetworkPathAgent_NavigationNpc");
static_assert(sizeof(UBFGNetworkPathAgent_NavigationNpc) == 0x000400, "Wrong size on UBFGNetworkPathAgent_NavigationNpc");

// Class BFGCore.BFGVoiceoverSoundProxy
// 0x0020 (0x0118 - 0x00F8)
class UBFGVoiceoverSoundProxy final : public USoundBase
{
public:
	class USoundBase*                             SoundWave;                                         // 0x00F8(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_100[0x18];                                     // 0x0100(0x0018)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"BFGVoiceoverSoundProxy">();
	}
	static class UBFGVoiceoverSoundProxy* GetDefaultObj()
	{
		return GetDefaultObjImpl<UBFGVoiceoverSoundProxy>();
	}
};
static_assert(alignof(UBFGVoiceoverSoundProxy) == 0x000008, "Wrong alignment on UBFGVoiceoverSoundProxy");
static_assert(sizeof(UBFGVoiceoverSoundProxy) == 0x000118, "Wrong size on UBFGVoiceoverSoundProxy");
static_assert(offsetof(UBFGVoiceoverSoundProxy, SoundWave) == 0x0000F8, "Member 'UBFGVoiceoverSoundProxy::SoundWave' has a wrong offset!");

// Class BFGCore.BFGDynamicObstacle_Sphere
// 0x0008 (0x03E0 - 0x03D8)
class ABFGDynamicObstacle_Sphere final : public AActor
{
public:
	class USphereComponent*                       M_pSphereComponent;                                // 0x03D8(0x0008)(Edit, ExportObject, ZeroConstructor, EditConst, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"BFGDynamicObstacle_Sphere">();
	}
	static class ABFGDynamicObstacle_Sphere* GetDefaultObj()
	{
		return GetDefaultObjImpl<ABFGDynamicObstacle_Sphere>();
	}
};
static_assert(alignof(ABFGDynamicObstacle_Sphere) == 0x000008, "Wrong alignment on ABFGDynamicObstacle_Sphere");
static_assert(sizeof(ABFGDynamicObstacle_Sphere) == 0x0003E0, "Wrong size on ABFGDynamicObstacle_Sphere");
static_assert(offsetof(ABFGDynamicObstacle_Sphere, M_pSphereComponent) == 0x0003D8, "Member 'ABFGDynamicObstacle_Sphere::M_pSphereComponent' has a wrong offset!");

// Class BFGCore.BFGBTService_Defend
// 0x01D0 (0x0248 - 0x0078)
class UBFGBTService_Defend final : public UBFGBTBaseService
{
public:
	struct FBlackboardKeySelector                 M_BBKeyDefendState;                                // 0x0078(0x0028)(Edit, BlueprintVisible, NativeAccessSpecifierPublic)
	struct FBlackboardKeySelector                 M_BBKeyOutDefendTargetActor;                       // 0x00A0(0x0028)(Edit, BlueprintVisible, NativeAccessSpecifierPublic)
	struct FBlackboardKeySelector                 M_BBKeyOutDefendTargetLocation;                    // 0x00C8(0x0028)(Edit, BlueprintVisible, NativeAccessSpecifierPublic)
	struct FBlackboardKeySelector                 M_BBKeyOutAttackTargetActor;                       // 0x00F0(0x0028)(Edit, BlueprintVisible, NativeAccessSpecifierPublic)
	struct FBlackboardKeySelector                 M_BBKeyOutAttackTargetLocation;                    // 0x0118(0x0028)(Edit, BlueprintVisible, NativeAccessSpecifierPublic)
	struct FBlackboardKeySelector                 M_BBKeyIsAbleToAttack;                             // 0x0140(0x0028)(Edit, BlueprintVisible, NativeAccessSpecifierPublic)
	float                                         M_fResetOnLoSTimeout;                              // 0x0168(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         M_fNeverResetBelowDistance;                        // 0x016C(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         M_fForceFollowDistance;                            // 0x0170(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_174[0x4];                                      // 0x0174(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	TSoftClassPtr<class UClass>                   M_pBrainExtractClass;                              // 0x0178(0x0028)(Edit, BlueprintVisible, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TSoftClassPtr<class UClass>                   M_pHypnotizeClass;                                 // 0x01A0(0x0028)(Edit, BlueprintVisible, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TSoftClassPtr<class UClass>                   M_pHypnotizeForgetClass;                           // 0x01C8(0x0028)(Edit, BlueprintVisible, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1F0[0x58];                                     // 0x01F0(0x0058)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"BFGBTService_Defend">();
	}
	static class UBFGBTService_Defend* GetDefaultObj()
	{
		return GetDefaultObjImpl<UBFGBTService_Defend>();
	}
};
static_assert(alignof(UBFGBTService_Defend) == 0x000008, "Wrong alignment on UBFGBTService_Defend");
static_assert(sizeof(UBFGBTService_Defend) == 0x000248, "Wrong size on UBFGBTService_Defend");
static_assert(offsetof(UBFGBTService_Defend, M_BBKeyDefendState) == 0x000078, "Member 'UBFGBTService_Defend::M_BBKeyDefendState' has a wrong offset!");
static_assert(offsetof(UBFGBTService_Defend, M_BBKeyOutDefendTargetActor) == 0x0000A0, "Member 'UBFGBTService_Defend::M_BBKeyOutDefendTargetActor' has a wrong offset!");
static_assert(offsetof(UBFGBTService_Defend, M_BBKeyOutDefendTargetLocation) == 0x0000C8, "Member 'UBFGBTService_Defend::M_BBKeyOutDefendTargetLocation' has a wrong offset!");
static_assert(offsetof(UBFGBTService_Defend, M_BBKeyOutAttackTargetActor) == 0x0000F0, "Member 'UBFGBTService_Defend::M_BBKeyOutAttackTargetActor' has a wrong offset!");
static_assert(offsetof(UBFGBTService_Defend, M_BBKeyOutAttackTargetLocation) == 0x000118, "Member 'UBFGBTService_Defend::M_BBKeyOutAttackTargetLocation' has a wrong offset!");
static_assert(offsetof(UBFGBTService_Defend, M_BBKeyIsAbleToAttack) == 0x000140, "Member 'UBFGBTService_Defend::M_BBKeyIsAbleToAttack' has a wrong offset!");
static_assert(offsetof(UBFGBTService_Defend, M_fResetOnLoSTimeout) == 0x000168, "Member 'UBFGBTService_Defend::M_fResetOnLoSTimeout' has a wrong offset!");
static_assert(offsetof(UBFGBTService_Defend, M_fNeverResetBelowDistance) == 0x00016C, "Member 'UBFGBTService_Defend::M_fNeverResetBelowDistance' has a wrong offset!");
static_assert(offsetof(UBFGBTService_Defend, M_fForceFollowDistance) == 0x000170, "Member 'UBFGBTService_Defend::M_fForceFollowDistance' has a wrong offset!");
static_assert(offsetof(UBFGBTService_Defend, M_pBrainExtractClass) == 0x000178, "Member 'UBFGBTService_Defend::M_pBrainExtractClass' has a wrong offset!");
static_assert(offsetof(UBFGBTService_Defend, M_pHypnotizeClass) == 0x0001A0, "Member 'UBFGBTService_Defend::M_pHypnotizeClass' has a wrong offset!");
static_assert(offsetof(UBFGBTService_Defend, M_pHypnotizeForgetClass) == 0x0001C8, "Member 'UBFGBTService_Defend::M_pHypnotizeForgetClass' has a wrong offset!");

// Class BFGCore.BFGBTService_EQSWithFallback
// 0x00E0 (0x0158 - 0x0078)
class UBFGBTService_EQSWithFallback final : public UBFGBTBaseService
{
public:
	struct FBlackboardKeySelector                 M_BBKeyTargetLocation;                             // 0x0078(0x0028)(Edit, NativeAccessSpecifierPublic)
	struct FBlackboardKeySelector                 M_BBKeyReferenceTarget;                            // 0x00A0(0x0028)(Edit, NativeAccessSpecifierPublic)
	TArray<struct FEQSParametrizedQueryExecutionRequest> M_aEQSChain;                                       // 0x00C8(0x0010)(Edit, ZeroConstructor, NativeAccessSpecifierPublic)
	EBFGEQSWithFallbackType                       M_eFallbackType;                                   // 0x00D8(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_D9[0x3];                                       // 0x00D9(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         M_fMinResultLifetime;                              // 0x00DC(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         M_fMinResultLifetimeRandomDerivation;              // 0x00E0(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         M_fMaxResultLifetime;                              // 0x00E4(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         M_fMaxResultLifetimeRandomDerivation;              // 0x00E8(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         M_fMaxReferenceTargetOffset;                       // 0x00EC(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          M_bSnakePath;                                      // 0x00F0(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_F1[0x3];                                       // 0x00F1(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         M_fFallbackRandomAngleOffset;                      // 0x00F4(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          M_bCheckForWeaponRange;                            // 0x00F8(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_F9[0x7];                                       // 0x00F9(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<struct FBFGEQSWithFallbackRequest>     M_aCurrentRequests;                                // 0x0100(0x0010)(ZeroConstructor, Transient, Protected, NativeAccessSpecifierProtected)
	class UBehaviorTreeComponent*                 M_pOwnerComponent;                                 // 0x0110(0x0008)(ExportObject, ZeroConstructor, Transient, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UBFGAICombatMediator*                   M_pCombatMediator;                                 // 0x0118(0x0008)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class APawn*                                  M_pSelfPawn;                                       // 0x0120(0x0008)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_128[0x30];                                     // 0x0128(0x0030)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"BFGBTService_EQSWithFallback">();
	}
	static class UBFGBTService_EQSWithFallback* GetDefaultObj()
	{
		return GetDefaultObjImpl<UBFGBTService_EQSWithFallback>();
	}
};
static_assert(alignof(UBFGBTService_EQSWithFallback) == 0x000008, "Wrong alignment on UBFGBTService_EQSWithFallback");
static_assert(sizeof(UBFGBTService_EQSWithFallback) == 0x000158, "Wrong size on UBFGBTService_EQSWithFallback");
static_assert(offsetof(UBFGBTService_EQSWithFallback, M_BBKeyTargetLocation) == 0x000078, "Member 'UBFGBTService_EQSWithFallback::M_BBKeyTargetLocation' has a wrong offset!");
static_assert(offsetof(UBFGBTService_EQSWithFallback, M_BBKeyReferenceTarget) == 0x0000A0, "Member 'UBFGBTService_EQSWithFallback::M_BBKeyReferenceTarget' has a wrong offset!");
static_assert(offsetof(UBFGBTService_EQSWithFallback, M_aEQSChain) == 0x0000C8, "Member 'UBFGBTService_EQSWithFallback::M_aEQSChain' has a wrong offset!");
static_assert(offsetof(UBFGBTService_EQSWithFallback, M_eFallbackType) == 0x0000D8, "Member 'UBFGBTService_EQSWithFallback::M_eFallbackType' has a wrong offset!");
static_assert(offsetof(UBFGBTService_EQSWithFallback, M_fMinResultLifetime) == 0x0000DC, "Member 'UBFGBTService_EQSWithFallback::M_fMinResultLifetime' has a wrong offset!");
static_assert(offsetof(UBFGBTService_EQSWithFallback, M_fMinResultLifetimeRandomDerivation) == 0x0000E0, "Member 'UBFGBTService_EQSWithFallback::M_fMinResultLifetimeRandomDerivation' has a wrong offset!");
static_assert(offsetof(UBFGBTService_EQSWithFallback, M_fMaxResultLifetime) == 0x0000E4, "Member 'UBFGBTService_EQSWithFallback::M_fMaxResultLifetime' has a wrong offset!");
static_assert(offsetof(UBFGBTService_EQSWithFallback, M_fMaxResultLifetimeRandomDerivation) == 0x0000E8, "Member 'UBFGBTService_EQSWithFallback::M_fMaxResultLifetimeRandomDerivation' has a wrong offset!");
static_assert(offsetof(UBFGBTService_EQSWithFallback, M_fMaxReferenceTargetOffset) == 0x0000EC, "Member 'UBFGBTService_EQSWithFallback::M_fMaxReferenceTargetOffset' has a wrong offset!");
static_assert(offsetof(UBFGBTService_EQSWithFallback, M_bSnakePath) == 0x0000F0, "Member 'UBFGBTService_EQSWithFallback::M_bSnakePath' has a wrong offset!");
static_assert(offsetof(UBFGBTService_EQSWithFallback, M_fFallbackRandomAngleOffset) == 0x0000F4, "Member 'UBFGBTService_EQSWithFallback::M_fFallbackRandomAngleOffset' has a wrong offset!");
static_assert(offsetof(UBFGBTService_EQSWithFallback, M_bCheckForWeaponRange) == 0x0000F8, "Member 'UBFGBTService_EQSWithFallback::M_bCheckForWeaponRange' has a wrong offset!");
static_assert(offsetof(UBFGBTService_EQSWithFallback, M_aCurrentRequests) == 0x000100, "Member 'UBFGBTService_EQSWithFallback::M_aCurrentRequests' has a wrong offset!");
static_assert(offsetof(UBFGBTService_EQSWithFallback, M_pOwnerComponent) == 0x000110, "Member 'UBFGBTService_EQSWithFallback::M_pOwnerComponent' has a wrong offset!");
static_assert(offsetof(UBFGBTService_EQSWithFallback, M_pCombatMediator) == 0x000118, "Member 'UBFGBTService_EQSWithFallback::M_pCombatMediator' has a wrong offset!");
static_assert(offsetof(UBFGBTService_EQSWithFallback, M_pSelfPawn) == 0x000120, "Member 'UBFGBTService_EQSWithFallback::M_pSelfPawn' has a wrong offset!");

// Class BFGCore.BFGVoiceoverGroup
// 0x0130 (0x0160 - 0x0030)
class UBFGVoiceoverGroup final : public UDataAsset
{
public:
	class FString                                 M_strDescription;                                  // 0x0030(0x0010)(Edit, BlueprintVisible, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          M_bAllowNoWave;                                    // 0x0040(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          M_bAllowNoSpeaker;                                 // 0x0041(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_42[0x2];                                       // 0x0042(0x0002)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         M_fMaxTimeInQueue;                                 // 0x0044(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TMap<TSoftObjectPtr<class UBFGVoiceoverGroup>, EBFGVoiceoverGroupCancelPolicy> M_aCancelPolicies;                                 // 0x0048(0x0050)(Edit, BlueprintVisible, ZeroConstructor, NativeAccessSpecifierPublic)
	TMap<TSoftObjectPtr<class UBFGVoiceoverGroup>, float> M_aSilencePeriods;                                 // 0x0098(0x0050)(Edit, BlueprintVisible, ZeroConstructor, NativeAccessSpecifierPublic)
	TSoftClassPtr<class UClass>                   M_pDefaultPlaybackComponent;                       // 0x00E8(0x0028)(Edit, BlueprintVisible, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TSoftObjectPtr<class UBFGVoiceoverQueueDefinition> M_pQueue;                                          // 0x0110(0x0028)(Edit, BlueprintVisible, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TSoftObjectPtr<class USoundClass>             M_pOverrideSoundClass;                             // 0x0138(0x0028)(Edit, BlueprintVisible, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"BFGVoiceoverGroup">();
	}
	static class UBFGVoiceoverGroup* GetDefaultObj()
	{
		return GetDefaultObjImpl<UBFGVoiceoverGroup>();
	}
};
static_assert(alignof(UBFGVoiceoverGroup) == 0x000008, "Wrong alignment on UBFGVoiceoverGroup");
static_assert(sizeof(UBFGVoiceoverGroup) == 0x000160, "Wrong size on UBFGVoiceoverGroup");
static_assert(offsetof(UBFGVoiceoverGroup, M_strDescription) == 0x000030, "Member 'UBFGVoiceoverGroup::M_strDescription' has a wrong offset!");
static_assert(offsetof(UBFGVoiceoverGroup, M_bAllowNoWave) == 0x000040, "Member 'UBFGVoiceoverGroup::M_bAllowNoWave' has a wrong offset!");
static_assert(offsetof(UBFGVoiceoverGroup, M_bAllowNoSpeaker) == 0x000041, "Member 'UBFGVoiceoverGroup::M_bAllowNoSpeaker' has a wrong offset!");
static_assert(offsetof(UBFGVoiceoverGroup, M_fMaxTimeInQueue) == 0x000044, "Member 'UBFGVoiceoverGroup::M_fMaxTimeInQueue' has a wrong offset!");
static_assert(offsetof(UBFGVoiceoverGroup, M_aCancelPolicies) == 0x000048, "Member 'UBFGVoiceoverGroup::M_aCancelPolicies' has a wrong offset!");
static_assert(offsetof(UBFGVoiceoverGroup, M_aSilencePeriods) == 0x000098, "Member 'UBFGVoiceoverGroup::M_aSilencePeriods' has a wrong offset!");
static_assert(offsetof(UBFGVoiceoverGroup, M_pDefaultPlaybackComponent) == 0x0000E8, "Member 'UBFGVoiceoverGroup::M_pDefaultPlaybackComponent' has a wrong offset!");
static_assert(offsetof(UBFGVoiceoverGroup, M_pQueue) == 0x000110, "Member 'UBFGVoiceoverGroup::M_pQueue' has a wrong offset!");
static_assert(offsetof(UBFGVoiceoverGroup, M_pOverrideSoundClass) == 0x000138, "Member 'UBFGVoiceoverGroup::M_pOverrideSoundClass' has a wrong offset!");

// Class BFGCore.BFGDialogOptionHandler_PrintText
// 0x0018 (0x0068 - 0x0050)
class UBFGDialogOptionHandler_PrintText final : public UBFGDialogOptionHandler_Base
{
public:
	class FText                                   M_strTextToPrint;                                  // 0x0050(0x0018)(Edit, BlueprintVisible, BlueprintReadOnly, DisableEditOnInstance, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"BFGDialogOptionHandler_PrintText">();
	}
	static class UBFGDialogOptionHandler_PrintText* GetDefaultObj()
	{
		return GetDefaultObjImpl<UBFGDialogOptionHandler_PrintText>();
	}
};
static_assert(alignof(UBFGDialogOptionHandler_PrintText) == 0x000008, "Wrong alignment on UBFGDialogOptionHandler_PrintText");
static_assert(sizeof(UBFGDialogOptionHandler_PrintText) == 0x000068, "Wrong size on UBFGDialogOptionHandler_PrintText");
static_assert(offsetof(UBFGDialogOptionHandler_PrintText, M_strTextToPrint) == 0x000050, "Member 'UBFGDialogOptionHandler_PrintText::M_strTextToPrint' has a wrong offset!");

// Class BFGCore.BFGBTService_MonitorCrowdFlowAgent
// 0x0058 (0x00D0 - 0x0078)
class UBFGBTService_MonitorCrowdFlowAgent final : public UBFGBTBaseService
{
public:
	struct FBlackboardKeySelector                 M_BBKey_CrowdFlowAgent;                            // 0x0078(0x0028)(Edit, NativeAccessSpecifierPublic)
	struct FBlackboardKeySelector                 M_BBKey_AutoAssignToTrafficSystem;                 // 0x00A0(0x0028)(Edit, NativeAccessSpecifierPublic)
	bool                                          M_bActivateCeaseRelevant;                          // 0x00C8(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_C9[0x7];                                       // 0x00C9(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"BFGBTService_MonitorCrowdFlowAgent">();
	}
	static class UBFGBTService_MonitorCrowdFlowAgent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UBFGBTService_MonitorCrowdFlowAgent>();
	}
};
static_assert(alignof(UBFGBTService_MonitorCrowdFlowAgent) == 0x000008, "Wrong alignment on UBFGBTService_MonitorCrowdFlowAgent");
static_assert(sizeof(UBFGBTService_MonitorCrowdFlowAgent) == 0x0000D0, "Wrong size on UBFGBTService_MonitorCrowdFlowAgent");
static_assert(offsetof(UBFGBTService_MonitorCrowdFlowAgent, M_BBKey_CrowdFlowAgent) == 0x000078, "Member 'UBFGBTService_MonitorCrowdFlowAgent::M_BBKey_CrowdFlowAgent' has a wrong offset!");
static_assert(offsetof(UBFGBTService_MonitorCrowdFlowAgent, M_BBKey_AutoAssignToTrafficSystem) == 0x0000A0, "Member 'UBFGBTService_MonitorCrowdFlowAgent::M_BBKey_AutoAssignToTrafficSystem' has a wrong offset!");
static_assert(offsetof(UBFGBTService_MonitorCrowdFlowAgent, M_bActivateCeaseRelevant) == 0x0000C8, "Member 'UBFGBTService_MonitorCrowdFlowAgent::M_bActivateCeaseRelevant' has a wrong offset!");

// Class BFGCore.BFGNPCCharacterEnemy_PSIStation
// 0x0040 (0x0C20 - 0x0BE0)
class ABFGNPCCharacterEnemy_PSIStation final : public ABFGNPCCharacterEnemy
{
public:
	class UBFGActorComponent_DamageListener*      M_pDamageListener;                                 // 0x0BD8(0x0008)(Edit, ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         M_iPhase;                                          // 0x0BE0(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         M_fTickRate;                                       // 0x0BE4(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TSubclassOf<class UDamageType>                M_pDamageType;                                     // 0x0BE8(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          M_fUseDrainPercent;                                // 0x0BF0(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_BF1[0x3];                                      // 0x0BF1(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         M_fDrainPercentPerTick_Passive;                    // 0x0BF4(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         M_fDrainPercentPerTick_Active;                     // 0x0BF8(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         M_fDrainPerTick_Passive;                           // 0x0BFC(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         M_fDrainPerTick_Active;                            // 0x0C00(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         M_fTickTimer;                                      // 0x0C04(0x0004)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          M_bIsActive;                                       // 0x0C08(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          M_bIsBeingActivelyDrained;                         // 0x0C09(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_C0A[0x6];                                      // 0x0C0A(0x0006)(Fixing Size After Last Property [ Dumper-7 ])
	class AActor*                                 M_pLinkedActor;                                    // 0x0C10(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_C18[0x8];                                      // 0x0C18(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void OnDrainStateChanged(bool _bIsBeingDrained);
	void OnStationActivation();

	bool GetIsBeingActivelyDrained() const;
	bool IsActive() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"BFGNPCCharacterEnemy_PSIStation">();
	}
	static class ABFGNPCCharacterEnemy_PSIStation* GetDefaultObj()
	{
		return GetDefaultObjImpl<ABFGNPCCharacterEnemy_PSIStation>();
	}
};
static_assert(alignof(ABFGNPCCharacterEnemy_PSIStation) == 0x000010, "Wrong alignment on ABFGNPCCharacterEnemy_PSIStation");
static_assert(sizeof(ABFGNPCCharacterEnemy_PSIStation) == 0x000C20, "Wrong size on ABFGNPCCharacterEnemy_PSIStation");
static_assert(offsetof(ABFGNPCCharacterEnemy_PSIStation, M_pDamageListener) == 0x000BD8, "Member 'ABFGNPCCharacterEnemy_PSIStation::M_pDamageListener' has a wrong offset!");
static_assert(offsetof(ABFGNPCCharacterEnemy_PSIStation, M_iPhase) == 0x000BE0, "Member 'ABFGNPCCharacterEnemy_PSIStation::M_iPhase' has a wrong offset!");
static_assert(offsetof(ABFGNPCCharacterEnemy_PSIStation, M_fTickRate) == 0x000BE4, "Member 'ABFGNPCCharacterEnemy_PSIStation::M_fTickRate' has a wrong offset!");
static_assert(offsetof(ABFGNPCCharacterEnemy_PSIStation, M_pDamageType) == 0x000BE8, "Member 'ABFGNPCCharacterEnemy_PSIStation::M_pDamageType' has a wrong offset!");
static_assert(offsetof(ABFGNPCCharacterEnemy_PSIStation, M_fUseDrainPercent) == 0x000BF0, "Member 'ABFGNPCCharacterEnemy_PSIStation::M_fUseDrainPercent' has a wrong offset!");
static_assert(offsetof(ABFGNPCCharacterEnemy_PSIStation, M_fDrainPercentPerTick_Passive) == 0x000BF4, "Member 'ABFGNPCCharacterEnemy_PSIStation::M_fDrainPercentPerTick_Passive' has a wrong offset!");
static_assert(offsetof(ABFGNPCCharacterEnemy_PSIStation, M_fDrainPercentPerTick_Active) == 0x000BF8, "Member 'ABFGNPCCharacterEnemy_PSIStation::M_fDrainPercentPerTick_Active' has a wrong offset!");
static_assert(offsetof(ABFGNPCCharacterEnemy_PSIStation, M_fDrainPerTick_Passive) == 0x000BFC, "Member 'ABFGNPCCharacterEnemy_PSIStation::M_fDrainPerTick_Passive' has a wrong offset!");
static_assert(offsetof(ABFGNPCCharacterEnemy_PSIStation, M_fDrainPerTick_Active) == 0x000C00, "Member 'ABFGNPCCharacterEnemy_PSIStation::M_fDrainPerTick_Active' has a wrong offset!");
static_assert(offsetof(ABFGNPCCharacterEnemy_PSIStation, M_fTickTimer) == 0x000C04, "Member 'ABFGNPCCharacterEnemy_PSIStation::M_fTickTimer' has a wrong offset!");
static_assert(offsetof(ABFGNPCCharacterEnemy_PSIStation, M_bIsActive) == 0x000C08, "Member 'ABFGNPCCharacterEnemy_PSIStation::M_bIsActive' has a wrong offset!");
static_assert(offsetof(ABFGNPCCharacterEnemy_PSIStation, M_bIsBeingActivelyDrained) == 0x000C09, "Member 'ABFGNPCCharacterEnemy_PSIStation::M_bIsBeingActivelyDrained' has a wrong offset!");
static_assert(offsetof(ABFGNPCCharacterEnemy_PSIStation, M_pLinkedActor) == 0x000C10, "Member 'ABFGNPCCharacterEnemy_PSIStation::M_pLinkedActor' has a wrong offset!");

// Class BFGCore.BFGBTService_MonitorCrowdLifeStation
// 0x0050 (0x00C8 - 0x0078)
class UBFGBTService_MonitorCrowdLifeStation final : public UBFGBTBaseService
{
public:
	struct FBlackboardKeySelector                 M_BBKey_CrowdFlowAgent;                            // 0x0078(0x0028)(Edit, NativeAccessSpecifierPublic)
	struct FBlackboardKeySelector                 M_BBKey_CrowdLifeStation;                          // 0x00A0(0x0028)(Edit, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"BFGBTService_MonitorCrowdLifeStation">();
	}
	static class UBFGBTService_MonitorCrowdLifeStation* GetDefaultObj()
	{
		return GetDefaultObjImpl<UBFGBTService_MonitorCrowdLifeStation>();
	}
};
static_assert(alignof(UBFGBTService_MonitorCrowdLifeStation) == 0x000008, "Wrong alignment on UBFGBTService_MonitorCrowdLifeStation");
static_assert(sizeof(UBFGBTService_MonitorCrowdLifeStation) == 0x0000C8, "Wrong size on UBFGBTService_MonitorCrowdLifeStation");
static_assert(offsetof(UBFGBTService_MonitorCrowdLifeStation, M_BBKey_CrowdFlowAgent) == 0x000078, "Member 'UBFGBTService_MonitorCrowdLifeStation::M_BBKey_CrowdFlowAgent' has a wrong offset!");
static_assert(offsetof(UBFGBTService_MonitorCrowdLifeStation, M_BBKey_CrowdLifeStation) == 0x0000A0, "Member 'UBFGBTService_MonitorCrowdLifeStation::M_BBKey_CrowdLifeStation' has a wrong offset!");

// Class BFGCore.BFGDetectionPostprocessor_VehicleState
// 0x0028 (0x0050 - 0x0028)
class UBFGDetectionPostprocessor_VehicleState final : public UBFGDetectionPostProcessor
{
public:
	struct FBlackboardKeySelector                 M_BBKeyDrivingMode;                                // 0x0028(0x0028)(Edit, BlueprintVisible, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"BFGDetectionPostprocessor_VehicleState">();
	}
	static class UBFGDetectionPostprocessor_VehicleState* GetDefaultObj()
	{
		return GetDefaultObjImpl<UBFGDetectionPostprocessor_VehicleState>();
	}
};
static_assert(alignof(UBFGDetectionPostprocessor_VehicleState) == 0x000008, "Wrong alignment on UBFGDetectionPostprocessor_VehicleState");
static_assert(sizeof(UBFGDetectionPostprocessor_VehicleState) == 0x000050, "Wrong size on UBFGDetectionPostprocessor_VehicleState");
static_assert(offsetof(UBFGDetectionPostprocessor_VehicleState, M_BBKeyDrivingMode) == 0x000028, "Member 'UBFGDetectionPostprocessor_VehicleState::M_BBKeyDrivingMode' has a wrong offset!");

// Class BFGCore.BFGWidget_HUD_PlayerStats
// 0x0050 (0x0348 - 0x02F8)
class UBFGWidget_HUD_PlayerStats : public UBFGWidget_HUD
{
public:
	uint8                                         Pad_2F8[0x8];                                      // 0x02F8(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         M_fHealth;                                         // 0x0300(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         M_fShieldState;                                    // 0x0304(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         M_fShieldStateDeltaDegradeSpeed;                   // 0x0308(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         M_fShieldStateDeltaDegradeSpeedSlow;               // 0x030C(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         M_fShieldStateDegradeDelayDuration;                // 0x0310(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         M_fShieldStateDelta;                               // 0x0314(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         M_fShieldStateDeltaSlow;                           // 0x0318(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         M_fShieldStateDegradeDelayTimer;                   // 0x031C(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_320[0x28];                                     // 0x0320(0x0028)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void OnRegainShield();
	void UpdateVisuals(float InDeltaTime);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"BFGWidget_HUD_PlayerStats">();
	}
	static class UBFGWidget_HUD_PlayerStats* GetDefaultObj()
	{
		return GetDefaultObjImpl<UBFGWidget_HUD_PlayerStats>();
	}
};
static_assert(alignof(UBFGWidget_HUD_PlayerStats) == 0x000008, "Wrong alignment on UBFGWidget_HUD_PlayerStats");
static_assert(sizeof(UBFGWidget_HUD_PlayerStats) == 0x000348, "Wrong size on UBFGWidget_HUD_PlayerStats");
static_assert(offsetof(UBFGWidget_HUD_PlayerStats, M_fHealth) == 0x000300, "Member 'UBFGWidget_HUD_PlayerStats::M_fHealth' has a wrong offset!");
static_assert(offsetof(UBFGWidget_HUD_PlayerStats, M_fShieldState) == 0x000304, "Member 'UBFGWidget_HUD_PlayerStats::M_fShieldState' has a wrong offset!");
static_assert(offsetof(UBFGWidget_HUD_PlayerStats, M_fShieldStateDeltaDegradeSpeed) == 0x000308, "Member 'UBFGWidget_HUD_PlayerStats::M_fShieldStateDeltaDegradeSpeed' has a wrong offset!");
static_assert(offsetof(UBFGWidget_HUD_PlayerStats, M_fShieldStateDeltaDegradeSpeedSlow) == 0x00030C, "Member 'UBFGWidget_HUD_PlayerStats::M_fShieldStateDeltaDegradeSpeedSlow' has a wrong offset!");
static_assert(offsetof(UBFGWidget_HUD_PlayerStats, M_fShieldStateDegradeDelayDuration) == 0x000310, "Member 'UBFGWidget_HUD_PlayerStats::M_fShieldStateDegradeDelayDuration' has a wrong offset!");
static_assert(offsetof(UBFGWidget_HUD_PlayerStats, M_fShieldStateDelta) == 0x000314, "Member 'UBFGWidget_HUD_PlayerStats::M_fShieldStateDelta' has a wrong offset!");
static_assert(offsetof(UBFGWidget_HUD_PlayerStats, M_fShieldStateDeltaSlow) == 0x000318, "Member 'UBFGWidget_HUD_PlayerStats::M_fShieldStateDeltaSlow' has a wrong offset!");
static_assert(offsetof(UBFGWidget_HUD_PlayerStats, M_fShieldStateDegradeDelayTimer) == 0x00031C, "Member 'UBFGWidget_HUD_PlayerStats::M_fShieldStateDegradeDelayTimer' has a wrong offset!");

// Class BFGCore.BFGBTService_NPCBoss
// 0x0448 (0x04C0 - 0x0078)
class UBFGBTService_NPCBoss final : public UBFGBTBaseService
{
public:
	struct FBlackboardKeySelector                 M_BBKeyIsOutOfBounds;                              // 0x0078(0x0028)(Edit, BlueprintVisible, NativeAccessSpecifierPublic)
	struct FBlackboardKeySelector                 M_BBKeyResetLocation;                              // 0x00A0(0x0028)(Edit, BlueprintVisible, NativeAccessSpecifierPublic)
	struct FBlackboardKeySelector                 M_BBKeyIsInWeakState;                              // 0x00C8(0x0028)(Edit, BlueprintVisible, NativeAccessSpecifierPublic)
	struct FBlackboardKeySelector                 M_BBKeyIsStaggered;                                // 0x00F0(0x0028)(Edit, BlueprintVisible, NativeAccessSpecifierPublic)
	struct FBlackboardKeySelector                 M_BBKeyIsInOperationalArea;                        // 0x0118(0x0028)(Edit, BlueprintVisible, NativeAccessSpecifierPublic)
	struct FBlackboardKeySelector                 M_BBKeyIsInAir;                                    // 0x0140(0x0028)(Edit, BlueprintVisible, NativeAccessSpecifierPublic)
	struct FBlackboardKeySelector                 M_BBKeyCanCallReinforcements;                      // 0x0168(0x0028)(Edit, BlueprintVisible, NativeAccessSpecifierPublic)
	struct FBlackboardKeySelector                 M_BBKeyReinforcementCooldownActive;                // 0x0190(0x0028)(Edit, BlueprintVisible, NativeAccessSpecifierPublic)
	struct FBlackboardKeySelector                 M_BBKeyTriggerPhaseChange;                         // 0x01B8(0x0028)(Edit, BlueprintVisible, NativeAccessSpecifierPublic)
	struct FBlackboardKeySelector                 M_BBKeyNextPhaseAnchorLocation;                    // 0x01E0(0x0028)(Edit, BlueprintVisible, NativeAccessSpecifierPublic)
	struct FBlackboardKeySelector                 M_BBKeyPhaseAnchorLocation;                        // 0x0208(0x0028)(Edit, BlueprintVisible, NativeAccessSpecifierPublic)
	struct FBlackboardKeySelector                 M_BBKeyPhaseReinforcementLocation;                 // 0x0230(0x0028)(Edit, BlueprintVisible, NativeAccessSpecifierPublic)
	struct FBlackboardKeySelector                 M_BBKeyMaxDistanceToAnchorLocation;                // 0x0258(0x0028)(Edit, BlueprintVisible, NativeAccessSpecifierPublic)
	struct FBlackboardKeySelector                 M_BBKeyCurrentStepDuration;                        // 0x0280(0x0028)(Edit, BlueprintVisible, NativeAccessSpecifierPublic)
	struct FBlackboardKeySelector                 M_BBKeyCurrentPhaseIndex;                          // 0x02A8(0x0028)(Edit, BlueprintVisible, NativeAccessSpecifierPublic)
	struct FBlackboardKeySelector                 M_BBKeyEnableRelocationIfTooFar;                   // 0x02D0(0x0028)(Edit, BlueprintVisible, NativeAccessSpecifierPublic)
	struct FBlackboardKeySelector                 M_BBKeyDisableStompAction;                         // 0x02F8(0x0028)(Edit, BlueprintVisible, NativeAccessSpecifierPublic)
	struct FBlackboardKeySelector                 M_BBKeyCurrentLocationIndex;                       // 0x0320(0x0028)(Edit, BlueprintVisible, NativeAccessSpecifierPublic)
	struct FBlackboardKeySelector                 M_BBKeyIsEvading;                                  // 0x0348(0x0028)(Edit, BlueprintVisible, NativeAccessSpecifierPublic)
	struct FBlackboardKeySelector                 M_BBKeyIsSpinning;                                 // 0x0370(0x0028)(Edit, BlueprintVisible, NativeAccessSpecifierPublic)
	struct FBlackboardKeySelector                 M_bbKeyMaxDistanceInnerRadius;                     // 0x0398(0x0028)(Edit, BlueprintVisible, NativeAccessSpecifierPublic)
	struct FBlackboardKeySelector                 M_bbKeyMaxDistanceOuterRadius;                     // 0x03C0(0x0028)(Edit, BlueprintVisible, NativeAccessSpecifierPublic)
	struct FBlackboardKeySelector                 M_bbKeyHoverState;                                 // 0x03E8(0x0028)(Edit, BlueprintVisible, NativeAccessSpecifierPublic)
	struct FBlackboardKeySelector                 M_BBKeyIsBeingAttacked;                            // 0x0410(0x0028)(Edit, BlueprintVisible, NativeAccessSpecifierPublic)
	struct FBlackboardKeySelector                 M_BBKeyIsPSIStationBeingAttacked;                  // 0x0438(0x0028)(Edit, BlueprintVisible, NativeAccessSpecifierPublic)
	struct FBlackboardKeySelector                 M_BBKeyIsPSIStationActive;                         // 0x0460(0x0028)(Edit, BlueprintVisible, NativeAccessSpecifierPublic)
	class UBehaviorTreeComponent*                 M_pOwnerComp;                                      // 0x0488(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class ABFGNPCCharacterBoss*                   M_pSelfCharacterBoss;                              // 0x0490(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_498[0x28];                                     // 0x0498(0x0028)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"BFGBTService_NPCBoss">();
	}
	static class UBFGBTService_NPCBoss* GetDefaultObj()
	{
		return GetDefaultObjImpl<UBFGBTService_NPCBoss>();
	}
};
static_assert(alignof(UBFGBTService_NPCBoss) == 0x000008, "Wrong alignment on UBFGBTService_NPCBoss");
static_assert(sizeof(UBFGBTService_NPCBoss) == 0x0004C0, "Wrong size on UBFGBTService_NPCBoss");
static_assert(offsetof(UBFGBTService_NPCBoss, M_BBKeyIsOutOfBounds) == 0x000078, "Member 'UBFGBTService_NPCBoss::M_BBKeyIsOutOfBounds' has a wrong offset!");
static_assert(offsetof(UBFGBTService_NPCBoss, M_BBKeyResetLocation) == 0x0000A0, "Member 'UBFGBTService_NPCBoss::M_BBKeyResetLocation' has a wrong offset!");
static_assert(offsetof(UBFGBTService_NPCBoss, M_BBKeyIsInWeakState) == 0x0000C8, "Member 'UBFGBTService_NPCBoss::M_BBKeyIsInWeakState' has a wrong offset!");
static_assert(offsetof(UBFGBTService_NPCBoss, M_BBKeyIsStaggered) == 0x0000F0, "Member 'UBFGBTService_NPCBoss::M_BBKeyIsStaggered' has a wrong offset!");
static_assert(offsetof(UBFGBTService_NPCBoss, M_BBKeyIsInOperationalArea) == 0x000118, "Member 'UBFGBTService_NPCBoss::M_BBKeyIsInOperationalArea' has a wrong offset!");
static_assert(offsetof(UBFGBTService_NPCBoss, M_BBKeyIsInAir) == 0x000140, "Member 'UBFGBTService_NPCBoss::M_BBKeyIsInAir' has a wrong offset!");
static_assert(offsetof(UBFGBTService_NPCBoss, M_BBKeyCanCallReinforcements) == 0x000168, "Member 'UBFGBTService_NPCBoss::M_BBKeyCanCallReinforcements' has a wrong offset!");
static_assert(offsetof(UBFGBTService_NPCBoss, M_BBKeyReinforcementCooldownActive) == 0x000190, "Member 'UBFGBTService_NPCBoss::M_BBKeyReinforcementCooldownActive' has a wrong offset!");
static_assert(offsetof(UBFGBTService_NPCBoss, M_BBKeyTriggerPhaseChange) == 0x0001B8, "Member 'UBFGBTService_NPCBoss::M_BBKeyTriggerPhaseChange' has a wrong offset!");
static_assert(offsetof(UBFGBTService_NPCBoss, M_BBKeyNextPhaseAnchorLocation) == 0x0001E0, "Member 'UBFGBTService_NPCBoss::M_BBKeyNextPhaseAnchorLocation' has a wrong offset!");
static_assert(offsetof(UBFGBTService_NPCBoss, M_BBKeyPhaseAnchorLocation) == 0x000208, "Member 'UBFGBTService_NPCBoss::M_BBKeyPhaseAnchorLocation' has a wrong offset!");
static_assert(offsetof(UBFGBTService_NPCBoss, M_BBKeyPhaseReinforcementLocation) == 0x000230, "Member 'UBFGBTService_NPCBoss::M_BBKeyPhaseReinforcementLocation' has a wrong offset!");
static_assert(offsetof(UBFGBTService_NPCBoss, M_BBKeyMaxDistanceToAnchorLocation) == 0x000258, "Member 'UBFGBTService_NPCBoss::M_BBKeyMaxDistanceToAnchorLocation' has a wrong offset!");
static_assert(offsetof(UBFGBTService_NPCBoss, M_BBKeyCurrentStepDuration) == 0x000280, "Member 'UBFGBTService_NPCBoss::M_BBKeyCurrentStepDuration' has a wrong offset!");
static_assert(offsetof(UBFGBTService_NPCBoss, M_BBKeyCurrentPhaseIndex) == 0x0002A8, "Member 'UBFGBTService_NPCBoss::M_BBKeyCurrentPhaseIndex' has a wrong offset!");
static_assert(offsetof(UBFGBTService_NPCBoss, M_BBKeyEnableRelocationIfTooFar) == 0x0002D0, "Member 'UBFGBTService_NPCBoss::M_BBKeyEnableRelocationIfTooFar' has a wrong offset!");
static_assert(offsetof(UBFGBTService_NPCBoss, M_BBKeyDisableStompAction) == 0x0002F8, "Member 'UBFGBTService_NPCBoss::M_BBKeyDisableStompAction' has a wrong offset!");
static_assert(offsetof(UBFGBTService_NPCBoss, M_BBKeyCurrentLocationIndex) == 0x000320, "Member 'UBFGBTService_NPCBoss::M_BBKeyCurrentLocationIndex' has a wrong offset!");
static_assert(offsetof(UBFGBTService_NPCBoss, M_BBKeyIsEvading) == 0x000348, "Member 'UBFGBTService_NPCBoss::M_BBKeyIsEvading' has a wrong offset!");
static_assert(offsetof(UBFGBTService_NPCBoss, M_BBKeyIsSpinning) == 0x000370, "Member 'UBFGBTService_NPCBoss::M_BBKeyIsSpinning' has a wrong offset!");
static_assert(offsetof(UBFGBTService_NPCBoss, M_bbKeyMaxDistanceInnerRadius) == 0x000398, "Member 'UBFGBTService_NPCBoss::M_bbKeyMaxDistanceInnerRadius' has a wrong offset!");
static_assert(offsetof(UBFGBTService_NPCBoss, M_bbKeyMaxDistanceOuterRadius) == 0x0003C0, "Member 'UBFGBTService_NPCBoss::M_bbKeyMaxDistanceOuterRadius' has a wrong offset!");
static_assert(offsetof(UBFGBTService_NPCBoss, M_bbKeyHoverState) == 0x0003E8, "Member 'UBFGBTService_NPCBoss::M_bbKeyHoverState' has a wrong offset!");
static_assert(offsetof(UBFGBTService_NPCBoss, M_BBKeyIsBeingAttacked) == 0x000410, "Member 'UBFGBTService_NPCBoss::M_BBKeyIsBeingAttacked' has a wrong offset!");
static_assert(offsetof(UBFGBTService_NPCBoss, M_BBKeyIsPSIStationBeingAttacked) == 0x000438, "Member 'UBFGBTService_NPCBoss::M_BBKeyIsPSIStationBeingAttacked' has a wrong offset!");
static_assert(offsetof(UBFGBTService_NPCBoss, M_BBKeyIsPSIStationActive) == 0x000460, "Member 'UBFGBTService_NPCBoss::M_BBKeyIsPSIStationActive' has a wrong offset!");
static_assert(offsetof(UBFGBTService_NPCBoss, M_pOwnerComp) == 0x000488, "Member 'UBFGBTService_NPCBoss::M_pOwnerComp' has a wrong offset!");
static_assert(offsetof(UBFGBTService_NPCBoss, M_pSelfCharacterBoss) == 0x000490, "Member 'UBFGBTService_NPCBoss::M_pSelfCharacterBoss' has a wrong offset!");

// Class BFGCore.BFGBTService_PowersuitSoldierCombat
// 0x0180 (0x0538 - 0x03B8)
class UBFGBTService_PowersuitSoldierCombat final : public UBFGBTService_NPCCombat
{
public:
	struct FBlackboardKeySelector                 M_BBKeyShouldGroundstomp;                          // 0x03B8(0x0028)(Edit, NativeAccessSpecifierPublic)
	struct FBlackboardKeySelector                 M_BBKeyGrenadesPossible;                           // 0x03E0(0x0028)(Edit, NativeAccessSpecifierPublic)
	struct FBlackboardKeySelector                 M_BBKeyCannonNeedReload;                           // 0x0408(0x0028)(Edit, NativeAccessSpecifierPublic)
	struct FBlackboardKeySelector                 M_BBKeyCannonWantReload;                           // 0x0430(0x0028)(Edit, NativeAccessSpecifierPublic)
	struct FBlackboardKeySelector                 M_BBKeyInStartShootingCone;                        // 0x0458(0x0028)(Edit, NativeAccessSpecifierPublic)
	struct FBlackboardKeySelector                 M_BBKeyInSustainShootingCone;                      // 0x0480(0x0028)(Edit, NativeAccessSpecifierPublic)
	float                                         M_fCannonAmmoRatioRequiredToAttack;                // 0x04A8(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         M_fShootStartConeHalfAngle;                        // 0x04AC(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         M_fShootSustainConeHalfAngle;                      // 0x04B0(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         M_fShootSustainConeTimeout;                        // 0x04B4(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TSoftClassPtr<class UClass>                   M_pGroundStompWeapon;                              // 0x04B8(0x0028)(Edit, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TSoftClassPtr<class UClass>                   M_pCannonWeapon;                                   // 0x04E0(0x0028)(Edit, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TSoftClassPtr<class UClass>                   M_pGrenadeWeapon;                                  // 0x0508(0x0028)(Edit, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_530[0x8];                                      // 0x0530(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"BFGBTService_PowersuitSoldierCombat">();
	}
	static class UBFGBTService_PowersuitSoldierCombat* GetDefaultObj()
	{
		return GetDefaultObjImpl<UBFGBTService_PowersuitSoldierCombat>();
	}
};
static_assert(alignof(UBFGBTService_PowersuitSoldierCombat) == 0x000008, "Wrong alignment on UBFGBTService_PowersuitSoldierCombat");
static_assert(sizeof(UBFGBTService_PowersuitSoldierCombat) == 0x000538, "Wrong size on UBFGBTService_PowersuitSoldierCombat");
static_assert(offsetof(UBFGBTService_PowersuitSoldierCombat, M_BBKeyShouldGroundstomp) == 0x0003B8, "Member 'UBFGBTService_PowersuitSoldierCombat::M_BBKeyShouldGroundstomp' has a wrong offset!");
static_assert(offsetof(UBFGBTService_PowersuitSoldierCombat, M_BBKeyGrenadesPossible) == 0x0003E0, "Member 'UBFGBTService_PowersuitSoldierCombat::M_BBKeyGrenadesPossible' has a wrong offset!");
static_assert(offsetof(UBFGBTService_PowersuitSoldierCombat, M_BBKeyCannonNeedReload) == 0x000408, "Member 'UBFGBTService_PowersuitSoldierCombat::M_BBKeyCannonNeedReload' has a wrong offset!");
static_assert(offsetof(UBFGBTService_PowersuitSoldierCombat, M_BBKeyCannonWantReload) == 0x000430, "Member 'UBFGBTService_PowersuitSoldierCombat::M_BBKeyCannonWantReload' has a wrong offset!");
static_assert(offsetof(UBFGBTService_PowersuitSoldierCombat, M_BBKeyInStartShootingCone) == 0x000458, "Member 'UBFGBTService_PowersuitSoldierCombat::M_BBKeyInStartShootingCone' has a wrong offset!");
static_assert(offsetof(UBFGBTService_PowersuitSoldierCombat, M_BBKeyInSustainShootingCone) == 0x000480, "Member 'UBFGBTService_PowersuitSoldierCombat::M_BBKeyInSustainShootingCone' has a wrong offset!");
static_assert(offsetof(UBFGBTService_PowersuitSoldierCombat, M_fCannonAmmoRatioRequiredToAttack) == 0x0004A8, "Member 'UBFGBTService_PowersuitSoldierCombat::M_fCannonAmmoRatioRequiredToAttack' has a wrong offset!");
static_assert(offsetof(UBFGBTService_PowersuitSoldierCombat, M_fShootStartConeHalfAngle) == 0x0004AC, "Member 'UBFGBTService_PowersuitSoldierCombat::M_fShootStartConeHalfAngle' has a wrong offset!");
static_assert(offsetof(UBFGBTService_PowersuitSoldierCombat, M_fShootSustainConeHalfAngle) == 0x0004B0, "Member 'UBFGBTService_PowersuitSoldierCombat::M_fShootSustainConeHalfAngle' has a wrong offset!");
static_assert(offsetof(UBFGBTService_PowersuitSoldierCombat, M_fShootSustainConeTimeout) == 0x0004B4, "Member 'UBFGBTService_PowersuitSoldierCombat::M_fShootSustainConeTimeout' has a wrong offset!");
static_assert(offsetof(UBFGBTService_PowersuitSoldierCombat, M_pGroundStompWeapon) == 0x0004B8, "Member 'UBFGBTService_PowersuitSoldierCombat::M_pGroundStompWeapon' has a wrong offset!");
static_assert(offsetof(UBFGBTService_PowersuitSoldierCombat, M_pCannonWeapon) == 0x0004E0, "Member 'UBFGBTService_PowersuitSoldierCombat::M_pCannonWeapon' has a wrong offset!");
static_assert(offsetof(UBFGBTService_PowersuitSoldierCombat, M_pGrenadeWeapon) == 0x000508, "Member 'UBFGBTService_PowersuitSoldierCombat::M_pGrenadeWeapon' has a wrong offset!");

// Class BFGCore.BFGInputAxis
// 0x0000 (0x0028 - 0x0028)
class UBFGInputAxis : public UObject
{
public:
	void OnUpdate(class UBFGActorComponent_InputActions* _pInputAxissComponent, float _fValue);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"BFGInputAxis">();
	}
	static class UBFGInputAxis* GetDefaultObj()
	{
		return GetDefaultObjImpl<UBFGInputAxis>();
	}
};
static_assert(alignof(UBFGInputAxis) == 0x000008, "Wrong alignment on UBFGInputAxis");
static_assert(sizeof(UBFGInputAxis) == 0x000028, "Wrong size on UBFGInputAxis");

// Class BFGCore.BFGInputAxis_UFOAimOrMoveVertical
// 0x0000 (0x0028 - 0x0028)
class UBFGInputAxis_UFOAimOrMoveVertical final : public UBFGInputAxis
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"BFGInputAxis_UFOAimOrMoveVertical">();
	}
	static class UBFGInputAxis_UFOAimOrMoveVertical* GetDefaultObj()
	{
		return GetDefaultObjImpl<UBFGInputAxis_UFOAimOrMoveVertical>();
	}
};
static_assert(alignof(UBFGInputAxis_UFOAimOrMoveVertical) == 0x000008, "Wrong alignment on UBFGInputAxis_UFOAimOrMoveVertical");
static_assert(sizeof(UBFGInputAxis_UFOAimOrMoveVertical) == 0x000028, "Wrong size on UBFGInputAxis_UFOAimOrMoveVertical");

// Class BFGCore.BFGBTService_SubBehaviorHelper
// 0x0030 (0x00A8 - 0x0078)
class UBFGBTService_SubBehaviorHelper final : public UBFGBTBaseService
{
public:
	TSoftClassPtr<class UClass>                   M_pEquipWeapon;                                    // 0x0078(0x0028)(Edit, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          M_bSetAimingOnEnter;                               // 0x00A0(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          M_bSetAimingOnLeave;                               // 0x00A1(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          M_bSetAimingOnAllEquippedWeapons;                  // 0x00A2(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EBFGNPCCharacter_MoveSpeed                    M_moveSpeed;                                       // 0x00A3(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_A4[0x4];                                       // 0x00A4(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"BFGBTService_SubBehaviorHelper">();
	}
	static class UBFGBTService_SubBehaviorHelper* GetDefaultObj()
	{
		return GetDefaultObjImpl<UBFGBTService_SubBehaviorHelper>();
	}
};
static_assert(alignof(UBFGBTService_SubBehaviorHelper) == 0x000008, "Wrong alignment on UBFGBTService_SubBehaviorHelper");
static_assert(sizeof(UBFGBTService_SubBehaviorHelper) == 0x0000A8, "Wrong size on UBFGBTService_SubBehaviorHelper");
static_assert(offsetof(UBFGBTService_SubBehaviorHelper, M_pEquipWeapon) == 0x000078, "Member 'UBFGBTService_SubBehaviorHelper::M_pEquipWeapon' has a wrong offset!");
static_assert(offsetof(UBFGBTService_SubBehaviorHelper, M_bSetAimingOnEnter) == 0x0000A0, "Member 'UBFGBTService_SubBehaviorHelper::M_bSetAimingOnEnter' has a wrong offset!");
static_assert(offsetof(UBFGBTService_SubBehaviorHelper, M_bSetAimingOnLeave) == 0x0000A1, "Member 'UBFGBTService_SubBehaviorHelper::M_bSetAimingOnLeave' has a wrong offset!");
static_assert(offsetof(UBFGBTService_SubBehaviorHelper, M_bSetAimingOnAllEquippedWeapons) == 0x0000A2, "Member 'UBFGBTService_SubBehaviorHelper::M_bSetAimingOnAllEquippedWeapons' has a wrong offset!");
static_assert(offsetof(UBFGBTService_SubBehaviorHelper, M_moveSpeed) == 0x0000A3, "Member 'UBFGBTService_SubBehaviorHelper::M_moveSpeed' has a wrong offset!");

// Class BFGCore.BFGInputAction
// 0x0008 (0x0030 - 0x0028)
class UBFGInputAction : public UObject
{
public:
	uint8                                         Pad_28[0x8];                                       // 0x0028(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	bool OnActionInvalid(class UBFGActorComponent_InputActions* _pInputActionsComponent);
	bool OnActionValid(class UBFGActorComponent_InputActions* _pInputActionsComponent);
	bool OnCheckCanceled(class UBFGActorComponent_InputActions* _pInputActionsComponent);
	bool OnInputInvalid(class UBFGActorComponent_InputActions* _pInputActionsComponent);
	bool OnInputValid(class UBFGActorComponent_InputActions* _pInputActionsComponent);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"BFGInputAction">();
	}
	static class UBFGInputAction* GetDefaultObj()
	{
		return GetDefaultObjImpl<UBFGInputAction>();
	}
};
static_assert(alignof(UBFGInputAction) == 0x000008, "Wrong alignment on UBFGInputAction");
static_assert(sizeof(UBFGInputAction) == 0x000030, "Wrong size on UBFGInputAction");

// Class BFGCore.BFGInputAction_UI
// 0x0000 (0x0030 - 0x0030)
class UBFGInputAction_UI : public UBFGInputAction
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"BFGInputAction_UI">();
	}
	static class UBFGInputAction_UI* GetDefaultObj()
	{
		return GetDefaultObjImpl<UBFGInputAction_UI>();
	}
};
static_assert(alignof(UBFGInputAction_UI) == 0x000008, "Wrong alignment on UBFGInputAction_UI");
static_assert(sizeof(UBFGInputAction_UI) == 0x000030, "Wrong size on UBFGInputAction_UI");

// Class BFGCore.BFGInputAction_UIAnyKey
// 0x0000 (0x0030 - 0x0030)
class UBFGInputAction_UIAnyKey final : public UBFGInputAction_UI
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"BFGInputAction_UIAnyKey">();
	}
	static class UBFGInputAction_UIAnyKey* GetDefaultObj()
	{
		return GetDefaultObjImpl<UBFGInputAction_UIAnyKey>();
	}
};
static_assert(alignof(UBFGInputAction_UIAnyKey) == 0x000008, "Wrong alignment on UBFGInputAction_UIAnyKey");
static_assert(sizeof(UBFGInputAction_UIAnyKey) == 0x000030, "Wrong size on UBFGInputAction_UIAnyKey");

// Class BFGCore.BFGBTService_TurretCombat
// 0x0000 (0x03B8 - 0x03B8)
class UBFGBTService_TurretCombat final : public UBFGBTService_NPCCombat
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"BFGBTService_TurretCombat">();
	}
	static class UBFGBTService_TurretCombat* GetDefaultObj()
	{
		return GetDefaultObjImpl<UBFGBTService_TurretCombat>();
	}
};
static_assert(alignof(UBFGBTService_TurretCombat) == 0x000008, "Wrong alignment on UBFGBTService_TurretCombat");
static_assert(sizeof(UBFGBTService_TurretCombat) == 0x0003B8, "Wrong size on UBFGBTService_TurretCombat");

// Class BFGCore.BFGBTService_VehicleStateEnemy
// 0x0000 (0x0208 - 0x0208)
class UBFGBTService_VehicleStateEnemy final : public UBFGBTService_VehicleState
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"BFGBTService_VehicleStateEnemy">();
	}
	static class UBFGBTService_VehicleStateEnemy* GetDefaultObj()
	{
		return GetDefaultObjImpl<UBFGBTService_VehicleStateEnemy>();
	}
};
static_assert(alignof(UBFGBTService_VehicleStateEnemy) == 0x000008, "Wrong alignment on UBFGBTService_VehicleStateEnemy");
static_assert(sizeof(UBFGBTService_VehicleStateEnemy) == 0x000208, "Wrong size on UBFGBTService_VehicleStateEnemy");

// Class BFGCore.BFGBTUtils
// 0x0000 (0x0028 - 0x0028)
class UBFGBTUtils final : public UBlueprintFunctionLibrary
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"BFGBTUtils">();
	}
	static class UBFGBTUtils* GetDefaultObj()
	{
		return GetDefaultObjImpl<UBFGBTUtils>();
	}
};
static_assert(alignof(UBFGBTUtils) == 0x000008, "Wrong alignment on UBFGBTUtils");
static_assert(sizeof(UBFGBTUtils) == 0x000028, "Wrong size on UBFGBTUtils");

// Class BFGCore.BFGInputComponent
// 0x0000 (0x01B0 - 0x01B0)
class UBFGInputComponent : public UInputComponent
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"BFGInputComponent">();
	}
	static class UBFGInputComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UBFGInputComponent>();
	}
};
static_assert(alignof(UBFGInputComponent) == 0x000008, "Wrong alignment on UBFGInputComponent");
static_assert(sizeof(UBFGInputComponent) == 0x0001B0, "Wrong size on UBFGInputComponent");

// Class BFGCore.BFGBuildingElementDataAsset
// 0x0050 (0x0080 - 0x0030)
class UBFGBuildingElementDataAsset final : public UDataAsset
{
public:
	struct FLightingChannels                      LightingChannels;                                  // 0x0030(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, NoDestructor, NativeAccessSpecifierPublic)
	uint8                                         Pad_31[0x7];                                       // 0x0031(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	class UStaticMesh*                            M_pMainMesh;                                       // 0x0038(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TSoftObjectPtr<class UBlastMesh>              M_pDestructibleMesh;                               // 0x0040(0x0028)(Edit, BlueprintVisible, BlueprintReadOnly, DisableEditOnInstance, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UBlastMesh*                             M_pDestructibleMesh_RuntimeCached;                 // 0x0068(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UGeometryCache*                         M_pGeometryCache;                                  // 0x0070(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EBFGBuilding_DestructionPhase                 M_ePhase;                                          // 0x0078(0x0001)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EBFGBuilding_DestructionBehavior              M_eDestructionBehavior;                            // 0x0079(0x0001)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_7A[0x6];                                       // 0x007A(0x0006)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"BFGBuildingElementDataAsset">();
	}
	static class UBFGBuildingElementDataAsset* GetDefaultObj()
	{
		return GetDefaultObjImpl<UBFGBuildingElementDataAsset>();
	}
};
static_assert(alignof(UBFGBuildingElementDataAsset) == 0x000008, "Wrong alignment on UBFGBuildingElementDataAsset");
static_assert(sizeof(UBFGBuildingElementDataAsset) == 0x000080, "Wrong size on UBFGBuildingElementDataAsset");
static_assert(offsetof(UBFGBuildingElementDataAsset, LightingChannels) == 0x000030, "Member 'UBFGBuildingElementDataAsset::LightingChannels' has a wrong offset!");
static_assert(offsetof(UBFGBuildingElementDataAsset, M_pMainMesh) == 0x000038, "Member 'UBFGBuildingElementDataAsset::M_pMainMesh' has a wrong offset!");
static_assert(offsetof(UBFGBuildingElementDataAsset, M_pDestructibleMesh) == 0x000040, "Member 'UBFGBuildingElementDataAsset::M_pDestructibleMesh' has a wrong offset!");
static_assert(offsetof(UBFGBuildingElementDataAsset, M_pDestructibleMesh_RuntimeCached) == 0x000068, "Member 'UBFGBuildingElementDataAsset::M_pDestructibleMesh_RuntimeCached' has a wrong offset!");
static_assert(offsetof(UBFGBuildingElementDataAsset, M_pGeometryCache) == 0x000070, "Member 'UBFGBuildingElementDataAsset::M_pGeometryCache' has a wrong offset!");
static_assert(offsetof(UBFGBuildingElementDataAsset, M_ePhase) == 0x000078, "Member 'UBFGBuildingElementDataAsset::M_ePhase' has a wrong offset!");
static_assert(offsetof(UBFGBuildingElementDataAsset, M_eDestructionBehavior) == 0x000079, "Member 'UBFGBuildingElementDataAsset::M_eDestructionBehavior' has a wrong offset!");

// Class BFGCore.BFGMentallyInteractableCheck
// 0x0028 (0x0050 - 0x0028)
class UBFGMentallyInteractableCheck : public UObject
{
public:
	bool                                          M_bEnabled;                                        // 0x0028(0x0001)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnTemplate, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_29[0x7];                                       // 0x0029(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	class FText                                   M_strFailReason;                                   // 0x0030(0x0018)(Edit, BlueprintVisible, DisableEditOnTemplate, Protected, NativeAccessSpecifierProtected)
	class AActor*                                 M_pOwner;                                          // 0x0048(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"BFGMentallyInteractableCheck">();
	}
	static class UBFGMentallyInteractableCheck* GetDefaultObj()
	{
		return GetDefaultObjImpl<UBFGMentallyInteractableCheck>();
	}
};
static_assert(alignof(UBFGMentallyInteractableCheck) == 0x000008, "Wrong alignment on UBFGMentallyInteractableCheck");
static_assert(sizeof(UBFGMentallyInteractableCheck) == 0x000050, "Wrong size on UBFGMentallyInteractableCheck");
static_assert(offsetof(UBFGMentallyInteractableCheck, M_bEnabled) == 0x000028, "Member 'UBFGMentallyInteractableCheck::M_bEnabled' has a wrong offset!");
static_assert(offsetof(UBFGMentallyInteractableCheck, M_strFailReason) == 0x000030, "Member 'UBFGMentallyInteractableCheck::M_strFailReason' has a wrong offset!");
static_assert(offsetof(UBFGMentallyInteractableCheck, M_pOwner) == 0x000048, "Member 'UBFGMentallyInteractableCheck::M_pOwner' has a wrong offset!");

// Class BFGCore.BFGMentallyInteractableCheck_Disguise
// 0x0090 (0x00E0 - 0x0050)
class UBFGMentallyInteractableCheck_Disguise final : public UBFGMentallyInteractableCheck
{
public:
	struct FBFGActorBinding                       M_disguiseBinding;                                 // 0x0050(0x0090)(Edit, BlueprintVisible, DisableEditOnTemplate, Protected, NativeAccessSpecifierProtected)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"BFGMentallyInteractableCheck_Disguise">();
	}
	static class UBFGMentallyInteractableCheck_Disguise* GetDefaultObj()
	{
		return GetDefaultObjImpl<UBFGMentallyInteractableCheck_Disguise>();
	}
};
static_assert(alignof(UBFGMentallyInteractableCheck_Disguise) == 0x000008, "Wrong alignment on UBFGMentallyInteractableCheck_Disguise");
static_assert(sizeof(UBFGMentallyInteractableCheck_Disguise) == 0x0000E0, "Wrong size on UBFGMentallyInteractableCheck_Disguise");
static_assert(offsetof(UBFGMentallyInteractableCheck_Disguise, M_disguiseBinding) == 0x000050, "Member 'UBFGMentallyInteractableCheck_Disguise::M_disguiseBinding' has a wrong offset!");

// Class BFGCore.BFGBuildingPropsManager
// 0x0108 (0x0138 - 0x0030)
class UBFGBuildingPropsManager final : public UBFGGameSystem
{
public:
	uint8                                         Pad_30[0x70];                                      // 0x0030(0x0070)(Fixing Size After Last Property [ Dumper-7 ])
	class ABFGGameState*                          M_pGameState;                                      // 0x00A0(0x0008)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_A8[0x8];                                       // 0x00A8(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	struct FWidgetPool                            M_DebugWidgetPool;                                 // 0x00B0(0x0070)(ContainsInstancedReference, Protected, NativeAccessSpecifierProtected)
	class UCanvasPanel*                           M_pDebugCanvasPanel;                               // 0x0120(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TArray<struct FRadarWidgetPair>               M_aDebugWidgetsInUse;                              // 0x0128(0x0010)(ZeroConstructor, ContainsInstancedReference, Protected, NativeAccessSpecifierProtected)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"BFGBuildingPropsManager">();
	}
	static class UBFGBuildingPropsManager* GetDefaultObj()
	{
		return GetDefaultObjImpl<UBFGBuildingPropsManager>();
	}
};
static_assert(alignof(UBFGBuildingPropsManager) == 0x000008, "Wrong alignment on UBFGBuildingPropsManager");
static_assert(sizeof(UBFGBuildingPropsManager) == 0x000138, "Wrong size on UBFGBuildingPropsManager");
static_assert(offsetof(UBFGBuildingPropsManager, M_pGameState) == 0x0000A0, "Member 'UBFGBuildingPropsManager::M_pGameState' has a wrong offset!");
static_assert(offsetof(UBFGBuildingPropsManager, M_DebugWidgetPool) == 0x0000B0, "Member 'UBFGBuildingPropsManager::M_DebugWidgetPool' has a wrong offset!");
static_assert(offsetof(UBFGBuildingPropsManager, M_pDebugCanvasPanel) == 0x000120, "Member 'UBFGBuildingPropsManager::M_pDebugCanvasPanel' has a wrong offset!");
static_assert(offsetof(UBFGBuildingPropsManager, M_aDebugWidgetsInUse) == 0x000128, "Member 'UBFGBuildingPropsManager::M_aDebugWidgetsInUse' has a wrong offset!");

// Class BFGCore.BFGBurningGroundManager
// 0x0160 (0x0190 - 0x0030)
class UBFGBurningGroundManager final : public UBFGGameSystem
{
public:
	class ABFGGameState*                          M_pGameState;                                      // 0x0030(0x0008)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UWorld*                                 M_pWorld;                                          // 0x0038(0x0008)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	TArray<class ABFGBurningGround*>              M_aBurningGroundStack;                             // 0x0040(0x0010)(ZeroConstructor, Transient, NativeAccessSpecifierPrivate)
	class UTextureRenderTarget2D*                 M_pRT_Ping;                                        // 0x0050(0x0008)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UTextureRenderTarget2D*                 M_pRT_Pong;                                        // 0x0058(0x0008)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UMaterialInstanceDynamic*               M_pMaterialChanneled;                              // 0x0060(0x0008)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UMaterialInstanceDynamic*               M_pMaterialSplash;                                 // 0x0068(0x0008)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UMaterialInstanceDynamic*               M_pMaterialGlowDecay;                              // 0x0070(0x0008)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_78[0x28];                                      // 0x0078(0x0028)(Fixing Size After Last Property [ Dumper-7 ])
	TMap<class UFoliageInstancedStaticMeshComponent*, struct FBFGRemovedFoliageTable> M_aRemovedFoliageTable;                            // 0x00A0(0x0050)(ZeroConstructor, Transient, ContainsInstancedReference, NativeAccessSpecifierPrivate)
	TArray<class UBFGFoliageDitheredMeshTransition*> M_apTransitionMeshes;                              // 0x00F0(0x0010)(ExportObject, ZeroConstructor, Transient, ContainsInstancedReference, NativeAccessSpecifierPrivate)
	TMap<class UStaticMesh*, struct FBFGBurntFoliageTable> M_aBurntFoliageTable;                              // 0x0100(0x0050)(ZeroConstructor, Transient, ContainsInstancedReference, NativeAccessSpecifierPrivate)
	TArray<struct FBFGSystemData_BurningGround_Event> M_aWriteEvents;                                    // 0x0150(0x0010)(ZeroConstructor, Transient, NativeAccessSpecifierPrivate)
	uint8                                         Pad_160[0x30];                                     // 0x0160(0x0030)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	class UBFGFoliageBurnt* AddBurntInstance(class UStaticMesh* _pMesh, const struct FTransform& _Transform, bool _bAddToPendingCheckpointList);
	void AddWriteEvent(const struct FVector2D& _vPosition, float _fDrawSize, bool _bChanneled, float _fAngle, float _fGlow, float _fBurningDuration);
	class ABFGBurningGround* GetBurningGroundActor();
	void GetRenderTargetSize(int32* _iOutWidth, int32* _iOutHeight);
	void Initialize(class UTextureRenderTarget2D* _pRTPing, class UTextureRenderTarget2D* _pRTPong, class UMaterialInstanceDynamic* _pWriteChanneled, class UMaterialInstanceDynamic* _pWriteSplash, class UMaterialInstanceDynamic* _pMaterialGlowDecay, class FName _GlowParam, class FName _GlowDecaySourceParam, class FName _TransitionMeshEnabledParam, class FName _TransitionMeshLocationParam, float _fMaxGlowTime);
	bool IsActorTouchingBurningGround(const struct FVector& _vLocation);
	void RegisterTransitionMesh(class UBFGFoliageDitheredMeshTransition* _pComponent);
	void RemoveNormalInstance(class UFoliageInstancedStaticMeshComponent* _pComponent, int32 _iInstanceId);

	class ABFGBurningGround* GetCurrentBurningGroundActor() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"BFGBurningGroundManager">();
	}
	static class UBFGBurningGroundManager* GetDefaultObj()
	{
		return GetDefaultObjImpl<UBFGBurningGroundManager>();
	}
};
static_assert(alignof(UBFGBurningGroundManager) == 0x000008, "Wrong alignment on UBFGBurningGroundManager");
static_assert(sizeof(UBFGBurningGroundManager) == 0x000190, "Wrong size on UBFGBurningGroundManager");
static_assert(offsetof(UBFGBurningGroundManager, M_pGameState) == 0x000030, "Member 'UBFGBurningGroundManager::M_pGameState' has a wrong offset!");
static_assert(offsetof(UBFGBurningGroundManager, M_pWorld) == 0x000038, "Member 'UBFGBurningGroundManager::M_pWorld' has a wrong offset!");
static_assert(offsetof(UBFGBurningGroundManager, M_aBurningGroundStack) == 0x000040, "Member 'UBFGBurningGroundManager::M_aBurningGroundStack' has a wrong offset!");
static_assert(offsetof(UBFGBurningGroundManager, M_pRT_Ping) == 0x000050, "Member 'UBFGBurningGroundManager::M_pRT_Ping' has a wrong offset!");
static_assert(offsetof(UBFGBurningGroundManager, M_pRT_Pong) == 0x000058, "Member 'UBFGBurningGroundManager::M_pRT_Pong' has a wrong offset!");
static_assert(offsetof(UBFGBurningGroundManager, M_pMaterialChanneled) == 0x000060, "Member 'UBFGBurningGroundManager::M_pMaterialChanneled' has a wrong offset!");
static_assert(offsetof(UBFGBurningGroundManager, M_pMaterialSplash) == 0x000068, "Member 'UBFGBurningGroundManager::M_pMaterialSplash' has a wrong offset!");
static_assert(offsetof(UBFGBurningGroundManager, M_pMaterialGlowDecay) == 0x000070, "Member 'UBFGBurningGroundManager::M_pMaterialGlowDecay' has a wrong offset!");
static_assert(offsetof(UBFGBurningGroundManager, M_aRemovedFoliageTable) == 0x0000A0, "Member 'UBFGBurningGroundManager::M_aRemovedFoliageTable' has a wrong offset!");
static_assert(offsetof(UBFGBurningGroundManager, M_apTransitionMeshes) == 0x0000F0, "Member 'UBFGBurningGroundManager::M_apTransitionMeshes' has a wrong offset!");
static_assert(offsetof(UBFGBurningGroundManager, M_aBurntFoliageTable) == 0x000100, "Member 'UBFGBurningGroundManager::M_aBurntFoliageTable' has a wrong offset!");
static_assert(offsetof(UBFGBurningGroundManager, M_aWriteEvents) == 0x000150, "Member 'UBFGBurningGroundManager::M_aWriteEvents' has a wrong offset!");

// Class BFGCore.BFGChallengeStartingPointManager
// 0x0020 (0x0050 - 0x0030)
class UBFGChallengeStartingPointManager final : public UBFGGameSystem
{
public:
	class ABFGGameState*                          M_pGameState;                                      // 0x0030(0x0008)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TArray<TWeakObjectPtr<class ABFGChallengeStartingPoint>> M_apStartingPoints;                                // 0x0038(0x0010)(ZeroConstructor, Transient, Protected, UObjectWrapper, NativeAccessSpecifierProtected)
	uint8                                         Pad_48[0x8];                                       // 0x0048(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"BFGChallengeStartingPointManager">();
	}
	static class UBFGChallengeStartingPointManager* GetDefaultObj()
	{
		return GetDefaultObjImpl<UBFGChallengeStartingPointManager>();
	}
};
static_assert(alignof(UBFGChallengeStartingPointManager) == 0x000008, "Wrong alignment on UBFGChallengeStartingPointManager");
static_assert(sizeof(UBFGChallengeStartingPointManager) == 0x000050, "Wrong size on UBFGChallengeStartingPointManager");
static_assert(offsetof(UBFGChallengeStartingPointManager, M_pGameState) == 0x000030, "Member 'UBFGChallengeStartingPointManager::M_pGameState' has a wrong offset!");
static_assert(offsetof(UBFGChallengeStartingPointManager, M_apStartingPoints) == 0x000038, "Member 'UBFGChallengeStartingPointManager::M_apStartingPoints' has a wrong offset!");

// Class BFGCore.BFGInputAction_JetpackPilotSkate
// 0x0008 (0x0038 - 0x0030)
class UBFGInputAction_JetpackPilotSkate : public UBFGInputAction
{
public:
	uint8                                         Pad_30[0x8];                                       // 0x0030(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"BFGInputAction_JetpackPilotSkate">();
	}
	static class UBFGInputAction_JetpackPilotSkate* GetDefaultObj()
	{
		return GetDefaultObjImpl<UBFGInputAction_JetpackPilotSkate>();
	}
};
static_assert(alignof(UBFGInputAction_JetpackPilotSkate) == 0x000008, "Wrong alignment on UBFGInputAction_JetpackPilotSkate");
static_assert(sizeof(UBFGInputAction_JetpackPilotSkate) == 0x000038, "Wrong size on UBFGInputAction_JetpackPilotSkate");

// Class BFGCore.BFGInputAction_JetpackPilotSkateInHolobob
// 0x0000 (0x0038 - 0x0038)
class UBFGInputAction_JetpackPilotSkateInHolobob final : public UBFGInputAction_JetpackPilotSkate
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"BFGInputAction_JetpackPilotSkateInHolobob">();
	}
	static class UBFGInputAction_JetpackPilotSkateInHolobob* GetDefaultObj()
	{
		return GetDefaultObjImpl<UBFGInputAction_JetpackPilotSkateInHolobob>();
	}
};
static_assert(alignof(UBFGInputAction_JetpackPilotSkateInHolobob) == 0x000008, "Wrong alignment on UBFGInputAction_JetpackPilotSkateInHolobob");
static_assert(sizeof(UBFGInputAction_JetpackPilotSkateInHolobob) == 0x000038, "Wrong size on UBFGInputAction_JetpackPilotSkateInHolobob");

// Class BFGCore.BFGCheatSettings
// 0x0280 (0x02B8 - 0x0038)
class UBFGCheatSettings final : public UDeveloperSettings
{
public:
	float                                         M_fFreeCamOrbitradius;                             // 0x0038(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Config, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          M_bFreeCamCollisionEnabled;                        // 0x003C(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Config, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          M_bFreeCamPlayerCharacterCollisionEnabled;         // 0x003D(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Config, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_3E[0x2];                                       // 0x003E(0x0002)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         M_fFreeCamSpeedMultiplier;                         // 0x0040(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Config, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         M_fFreeCamHighSpeedMultiplier;                     // 0x0044(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Config, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TSoftClassPtr<class UClass>                   M_CheatUIWidgetClass;                              // 0x0048(0x0028)(Edit, BlueprintVisible, BlueprintReadOnly, Config, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TSoftClassPtr<class UClass>                   M_FreeCamUIWidgetClass;                            // 0x0070(0x0028)(Edit, BlueprintVisible, BlueprintReadOnly, Config, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TSoftObjectPtr<class UDataTable>              M_CheatsDefinitionDataTable;                       // 0x0098(0x0028)(Edit, BlueprintVisible, BlueprintReadOnly, Config, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         M_fCheat_NukeEnemies_RangeCrypto;                  // 0x00C0(0x0004)(Edit, ZeroConstructor, Config, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         M_fCheat_NukeEnemies_RangeUFO;                     // 0x00C4(0x0004)(Edit, ZeroConstructor, Config, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TSoftClassPtr<class UClass>                   M_softCheat_NukeEnemies_DamageType;                // 0x00C8(0x0028)(Edit, Config, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TArray<TSoftObjectPtr<class UDataTable>>      M_aUnlockTableList;                                // 0x00F0(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Config, UObjectWrapper, NativeAccessSpecifierPublic)
	TSoftClassPtr<class UClass>                   M_pDisintegratorClass;                             // 0x0100(0x0028)(Edit, Config, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TSoftClassPtr<class UClass>                   M_pIonDetonatorClass;                              // 0x0128(0x0028)(Edit, Config, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TSoftClassPtr<class UClass>                   M_pSonicBoomClass;                                 // 0x0150(0x0028)(Edit, Config, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TSoftClassPtr<class UClass>                   M_pQuantumDeconstructorClass;                      // 0x0178(0x0028)(Edit, Config, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TSoftClassPtr<class UClass>                   M_pCowActorClass;                                  // 0x01A0(0x0028)(Edit, Config, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TSoftClassPtr<class UClass>                   M_pSoldierActorClass;                              // 0x01C8(0x0028)(Edit, Config, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TSoftClassPtr<class UClass>                   M_pMajesticActorClass;                             // 0x01F0(0x0028)(Edit, Config, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TSoftClassPtr<class UClass>                   M_pCopActorClass;                                  // 0x0218(0x0028)(Edit, Config, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TSoftClassPtr<class UClass>                   M_pFarmerActorClass;                               // 0x0240(0x0028)(Edit, Config, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TSoftClassPtr<class UClass>                   M_pCivilianActorClass;                             // 0x0268(0x0028)(Edit, Config, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TSoftClassPtr<class UClass>                   M_pPowersuitActorClass;                            // 0x0290(0x0028)(Edit, Config, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"BFGCheatSettings">();
	}
	static class UBFGCheatSettings* GetDefaultObj()
	{
		return GetDefaultObjImpl<UBFGCheatSettings>();
	}
};
static_assert(alignof(UBFGCheatSettings) == 0x000008, "Wrong alignment on UBFGCheatSettings");
static_assert(sizeof(UBFGCheatSettings) == 0x0002B8, "Wrong size on UBFGCheatSettings");
static_assert(offsetof(UBFGCheatSettings, M_fFreeCamOrbitradius) == 0x000038, "Member 'UBFGCheatSettings::M_fFreeCamOrbitradius' has a wrong offset!");
static_assert(offsetof(UBFGCheatSettings, M_bFreeCamCollisionEnabled) == 0x00003C, "Member 'UBFGCheatSettings::M_bFreeCamCollisionEnabled' has a wrong offset!");
static_assert(offsetof(UBFGCheatSettings, M_bFreeCamPlayerCharacterCollisionEnabled) == 0x00003D, "Member 'UBFGCheatSettings::M_bFreeCamPlayerCharacterCollisionEnabled' has a wrong offset!");
static_assert(offsetof(UBFGCheatSettings, M_fFreeCamSpeedMultiplier) == 0x000040, "Member 'UBFGCheatSettings::M_fFreeCamSpeedMultiplier' has a wrong offset!");
static_assert(offsetof(UBFGCheatSettings, M_fFreeCamHighSpeedMultiplier) == 0x000044, "Member 'UBFGCheatSettings::M_fFreeCamHighSpeedMultiplier' has a wrong offset!");
static_assert(offsetof(UBFGCheatSettings, M_CheatUIWidgetClass) == 0x000048, "Member 'UBFGCheatSettings::M_CheatUIWidgetClass' has a wrong offset!");
static_assert(offsetof(UBFGCheatSettings, M_FreeCamUIWidgetClass) == 0x000070, "Member 'UBFGCheatSettings::M_FreeCamUIWidgetClass' has a wrong offset!");
static_assert(offsetof(UBFGCheatSettings, M_CheatsDefinitionDataTable) == 0x000098, "Member 'UBFGCheatSettings::M_CheatsDefinitionDataTable' has a wrong offset!");
static_assert(offsetof(UBFGCheatSettings, M_fCheat_NukeEnemies_RangeCrypto) == 0x0000C0, "Member 'UBFGCheatSettings::M_fCheat_NukeEnemies_RangeCrypto' has a wrong offset!");
static_assert(offsetof(UBFGCheatSettings, M_fCheat_NukeEnemies_RangeUFO) == 0x0000C4, "Member 'UBFGCheatSettings::M_fCheat_NukeEnemies_RangeUFO' has a wrong offset!");
static_assert(offsetof(UBFGCheatSettings, M_softCheat_NukeEnemies_DamageType) == 0x0000C8, "Member 'UBFGCheatSettings::M_softCheat_NukeEnemies_DamageType' has a wrong offset!");
static_assert(offsetof(UBFGCheatSettings, M_aUnlockTableList) == 0x0000F0, "Member 'UBFGCheatSettings::M_aUnlockTableList' has a wrong offset!");
static_assert(offsetof(UBFGCheatSettings, M_pDisintegratorClass) == 0x000100, "Member 'UBFGCheatSettings::M_pDisintegratorClass' has a wrong offset!");
static_assert(offsetof(UBFGCheatSettings, M_pIonDetonatorClass) == 0x000128, "Member 'UBFGCheatSettings::M_pIonDetonatorClass' has a wrong offset!");
static_assert(offsetof(UBFGCheatSettings, M_pSonicBoomClass) == 0x000150, "Member 'UBFGCheatSettings::M_pSonicBoomClass' has a wrong offset!");
static_assert(offsetof(UBFGCheatSettings, M_pQuantumDeconstructorClass) == 0x000178, "Member 'UBFGCheatSettings::M_pQuantumDeconstructorClass' has a wrong offset!");
static_assert(offsetof(UBFGCheatSettings, M_pCowActorClass) == 0x0001A0, "Member 'UBFGCheatSettings::M_pCowActorClass' has a wrong offset!");
static_assert(offsetof(UBFGCheatSettings, M_pSoldierActorClass) == 0x0001C8, "Member 'UBFGCheatSettings::M_pSoldierActorClass' has a wrong offset!");
static_assert(offsetof(UBFGCheatSettings, M_pMajesticActorClass) == 0x0001F0, "Member 'UBFGCheatSettings::M_pMajesticActorClass' has a wrong offset!");
static_assert(offsetof(UBFGCheatSettings, M_pCopActorClass) == 0x000218, "Member 'UBFGCheatSettings::M_pCopActorClass' has a wrong offset!");
static_assert(offsetof(UBFGCheatSettings, M_pFarmerActorClass) == 0x000240, "Member 'UBFGCheatSettings::M_pFarmerActorClass' has a wrong offset!");
static_assert(offsetof(UBFGCheatSettings, M_pCivilianActorClass) == 0x000268, "Member 'UBFGCheatSettings::M_pCivilianActorClass' has a wrong offset!");
static_assert(offsetof(UBFGCheatSettings, M_pPowersuitActorClass) == 0x000290, "Member 'UBFGCheatSettings::M_pPowersuitActorClass' has a wrong offset!");

// Class BFGCore.BFGMissionTriggerZone
// 0x00A0 (0x0478 - 0x03D8)
class ABFGMissionTriggerZone : public AActor
{
public:
	uint8                                         Pad_3D8[0x10];                                     // 0x03D8(0x0010)(Fixing Size After Last Property [ Dumper-7 ])
	UMulticastDelegateProperty_                   M_onOverlapActor;                                  // 0x03E8(0x0018)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	UMulticastDelegateProperty_                   M_onOverlapEndActor;                               // 0x0400(0x0018)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	class UBFGActorComponent_Objective*           M_pObjectiveComponent;                             // 0x0418(0x0008)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, EditConst, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EBFGTriggerShape                              M_eShape;                                          // 0x0420(0x0001)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_421[0x3];                                      // 0x0421(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	struct FVector                                M_vLocalExtents;                                   // 0x0424(0x000C)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FGameplayTagContainer                  M_gameplayTags;                                    // 0x0430(0x0020)(Edit, BlueprintVisible, BlueprintReadOnly, Protected, NativeAccessSpecifierProtected)
	TArray<struct FBFGActorBinding>               M_aActivateWith;                                   // 0x0450(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Protected, NativeAccessSpecifierProtected)
	class USceneComponent*                        M_pObjectiveMarkerParentComponent;                 // 0x0460(0x0008)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, EditConst, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TArray<class AActor*>                         M_apActiveOverlapping;                             // 0x0468(0x0010)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, Protected, NativeAccessSpecifierProtected)

public:
	void ActivateEndTrigger(class AActor* _pWithActor);
	void ActivateTrigger(class AActor* _pWithActor);

	bool CanActivateWith(class AActor* _pActor) const;
	const TArray<class AActor*> GetActiveOverlappingActors() const;
	bool IsIntersectingSlow(const struct FVector& _vLocation) const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"BFGMissionTriggerZone">();
	}
	static class ABFGMissionTriggerZone* GetDefaultObj()
	{
		return GetDefaultObjImpl<ABFGMissionTriggerZone>();
	}
};
static_assert(alignof(ABFGMissionTriggerZone) == 0x000008, "Wrong alignment on ABFGMissionTriggerZone");
static_assert(sizeof(ABFGMissionTriggerZone) == 0x000478, "Wrong size on ABFGMissionTriggerZone");
static_assert(offsetof(ABFGMissionTriggerZone, M_onOverlapActor) == 0x0003E8, "Member 'ABFGMissionTriggerZone::M_onOverlapActor' has a wrong offset!");
static_assert(offsetof(ABFGMissionTriggerZone, M_onOverlapEndActor) == 0x000400, "Member 'ABFGMissionTriggerZone::M_onOverlapEndActor' has a wrong offset!");
static_assert(offsetof(ABFGMissionTriggerZone, M_pObjectiveComponent) == 0x000418, "Member 'ABFGMissionTriggerZone::M_pObjectiveComponent' has a wrong offset!");
static_assert(offsetof(ABFGMissionTriggerZone, M_eShape) == 0x000420, "Member 'ABFGMissionTriggerZone::M_eShape' has a wrong offset!");
static_assert(offsetof(ABFGMissionTriggerZone, M_vLocalExtents) == 0x000424, "Member 'ABFGMissionTriggerZone::M_vLocalExtents' has a wrong offset!");
static_assert(offsetof(ABFGMissionTriggerZone, M_gameplayTags) == 0x000430, "Member 'ABFGMissionTriggerZone::M_gameplayTags' has a wrong offset!");
static_assert(offsetof(ABFGMissionTriggerZone, M_aActivateWith) == 0x000450, "Member 'ABFGMissionTriggerZone::M_aActivateWith' has a wrong offset!");
static_assert(offsetof(ABFGMissionTriggerZone, M_pObjectiveMarkerParentComponent) == 0x000460, "Member 'ABFGMissionTriggerZone::M_pObjectiveMarkerParentComponent' has a wrong offset!");
static_assert(offsetof(ABFGMissionTriggerZone, M_apActiveOverlapping) == 0x000468, "Member 'ABFGMissionTriggerZone::M_apActiveOverlapping' has a wrong offset!");

// Class BFGCore.BFGCheatUIMenu
// 0x00C0 (0x0300 - 0x0240)
class UBFGCheatUIMenu final : public UUserWidget
{
public:
	TMap<class FString, class UUserWidget*>       M_aCategoriesMap;                                  // 0x0240(0x0050)(ExportObject, ZeroConstructor, ContainsInstancedReference, NativeAccessSpecifierPrivate)
	TMap<class FString, class UUserWidget*>       M_aButtonsMap;                                     // 0x0290(0x0050)(ExportObject, ZeroConstructor, ContainsInstancedReference, NativeAccessSpecifierPrivate)
	class UVerticalBox*                           M_pMainVerticalBox;                                // 0x02E0(0x0008)(BlueprintVisible, ExportObject, ZeroConstructor, Transient, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FString                                 M_strCurrActiveCategory;                           // 0x02E8(0x0010)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UDataTable*                             M_pCheatDataTable;                                 // 0x02F8(0x0008)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)

public:
	void AddUIEelement(const class FString& _strCategoryName);
	class UUserWidget* CreateCheatCategoryButton(const class FString& _strTitleText);
	class UUserWidget* CreateCheatCommandButton(const struct FBFGCheatTableEntry& _entry);
	bool GoToPreviousMenu();
	void RefreshUIElements(const class FString& _strCategoryName);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"BFGCheatUIMenu">();
	}
	static class UBFGCheatUIMenu* GetDefaultObj()
	{
		return GetDefaultObjImpl<UBFGCheatUIMenu>();
	}
};
static_assert(alignof(UBFGCheatUIMenu) == 0x000008, "Wrong alignment on UBFGCheatUIMenu");
static_assert(sizeof(UBFGCheatUIMenu) == 0x000300, "Wrong size on UBFGCheatUIMenu");
static_assert(offsetof(UBFGCheatUIMenu, M_aCategoriesMap) == 0x000240, "Member 'UBFGCheatUIMenu::M_aCategoriesMap' has a wrong offset!");
static_assert(offsetof(UBFGCheatUIMenu, M_aButtonsMap) == 0x000290, "Member 'UBFGCheatUIMenu::M_aButtonsMap' has a wrong offset!");
static_assert(offsetof(UBFGCheatUIMenu, M_pMainVerticalBox) == 0x0002E0, "Member 'UBFGCheatUIMenu::M_pMainVerticalBox' has a wrong offset!");
static_assert(offsetof(UBFGCheatUIMenu, M_strCurrActiveCategory) == 0x0002E8, "Member 'UBFGCheatUIMenu::M_strCurrActiveCategory' has a wrong offset!");
static_assert(offsetof(UBFGCheatUIMenu, M_pCheatDataTable) == 0x0002F8, "Member 'UBFGCheatUIMenu::M_pCheatDataTable' has a wrong offset!");

// Class BFGCore.BFGClothAnimInstance
// 0x0018 (0x02B0 - 0x0298)
class UBFGClothAnimInstance : public UAnimInstance
{
public:
	struct FVector                                M_vDummyPlayerPosition;                            // 0x0298(0x000C)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_2A4[0xC];                                      // 0x02A4(0x000C)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"BFGClothAnimInstance">();
	}
	static class UBFGClothAnimInstance* GetDefaultObj()
	{
		return GetDefaultObjImpl<UBFGClothAnimInstance>();
	}
};
static_assert(alignof(UBFGClothAnimInstance) == 0x000008, "Wrong alignment on UBFGClothAnimInstance");
static_assert(sizeof(UBFGClothAnimInstance) == 0x0002B0, "Wrong size on UBFGClothAnimInstance");
static_assert(offsetof(UBFGClothAnimInstance, M_vDummyPlayerPosition) == 0x000298, "Member 'UBFGClothAnimInstance::M_vDummyPlayerPosition' has a wrong offset!");

// Class BFGCore.BFGCollisionUtils
// 0x0000 (0x0028 - 0x0028)
class UBFGCollisionUtils final : public UBlueprintFunctionLibrary
{
public:
	static EBFGCollisionChannel ConvertCollisionChannelToBFG(ECollisionChannel _eCollisionChannel);
	static ECollisionChannel ConvertCollisionChannelToECC(EBFGCollisionChannel _eBFGCollisionChannel);
	static bool IsCollisionProfileName(class FName _name, const struct FCollisionProfileName& _profileName);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"BFGCollisionUtils">();
	}
	static class UBFGCollisionUtils* GetDefaultObj()
	{
		return GetDefaultObjImpl<UBFGCollisionUtils>();
	}
};
static_assert(alignof(UBFGCollisionUtils) == 0x000008, "Wrong alignment on UBFGCollisionUtils");
static_assert(sizeof(UBFGCollisionUtils) == 0x000028, "Wrong size on UBFGCollisionUtils");

// Class BFGCore.BFGInputAction_MentalAbilityToggleHolobob
// 0x0000 (0x0030 - 0x0030)
class UBFGInputAction_MentalAbilityToggleHolobob final : public UBFGInputAction
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"BFGInputAction_MentalAbilityToggleHolobob">();
	}
	static class UBFGInputAction_MentalAbilityToggleHolobob* GetDefaultObj()
	{
		return GetDefaultObjImpl<UBFGInputAction_MentalAbilityToggleHolobob>();
	}
};
static_assert(alignof(UBFGInputAction_MentalAbilityToggleHolobob) == 0x000008, "Wrong alignment on UBFGInputAction_MentalAbilityToggleHolobob");
static_assert(sizeof(UBFGInputAction_MentalAbilityToggleHolobob) == 0x000030, "Wrong size on UBFGInputAction_MentalAbilityToggleHolobob");

// Class BFGCore.BFGCortexScanOverrideRule_Alerted
// 0x0000 (0x0028 - 0x0028)
class UBFGCortexScanOverrideRule_Alerted final : public UBFGCortexScanOverrideRule
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"BFGCortexScanOverrideRule_Alerted">();
	}
	static class UBFGCortexScanOverrideRule_Alerted* GetDefaultObj()
	{
		return GetDefaultObjImpl<UBFGCortexScanOverrideRule_Alerted>();
	}
};
static_assert(alignof(UBFGCortexScanOverrideRule_Alerted) == 0x000008, "Wrong alignment on UBFGCortexScanOverrideRule_Alerted");
static_assert(sizeof(UBFGCortexScanOverrideRule_Alerted) == 0x000028, "Wrong size on UBFGCortexScanOverrideRule_Alerted");

// Class BFGCore.BFGMissionConsequenceCollection
// 0x0010 (0x0038 - 0x0028)
class UBFGMissionConsequenceCollection final : public UObject
{
public:
	TArray<class UBFGMissionConsequence*>         M_apActiveConsequences;                            // 0x0028(0x0010)(ExportObject, ZeroConstructor, Transient, ContainsInstancedReference, Protected, NativeAccessSpecifierProtected)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"BFGMissionConsequenceCollection">();
	}
	static class UBFGMissionConsequenceCollection* GetDefaultObj()
	{
		return GetDefaultObjImpl<UBFGMissionConsequenceCollection>();
	}
};
static_assert(alignof(UBFGMissionConsequenceCollection) == 0x000008, "Wrong alignment on UBFGMissionConsequenceCollection");
static_assert(sizeof(UBFGMissionConsequenceCollection) == 0x000038, "Wrong size on UBFGMissionConsequenceCollection");
static_assert(offsetof(UBFGMissionConsequenceCollection, M_apActiveConsequences) == 0x000028, "Member 'UBFGMissionConsequenceCollection::M_apActiveConsequences' has a wrong offset!");

// Class BFGCore.BFGCortexScanResponseSet
// 0x0120 (0x0148 - 0x0028)
class UBFGCortexScanResponseSet final : public UObject
{
public:
	class ABFGGameState*                          M_pGameState;                                      // 0x0028(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	struct FBFGCortexScanResponseConfig           M_config;                                          // 0x0030(0x00E0)(Protected, NativeAccessSpecifierProtected)
	TArray<struct FBFGCortexScanResponseConfig>   M_aSharedConfigs;                                  // 0x0110(0x0010)(ZeroConstructor, Protected, NativeAccessSpecifierProtected)
	class UBFGDataAsset_CortexScan*               M_pDataAsset;                                      // 0x0120(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TArray<class UBFGCortexScanResponsePool*>     M_apPools;                                         // 0x0128(0x0010)(ZeroConstructor, Protected, NativeAccessSpecifierProtected)
	class UBFGVariable*                           M_pVariable;                                       // 0x0138(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_140[0x8];                                      // 0x0140(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"BFGCortexScanResponseSet">();
	}
	static class UBFGCortexScanResponseSet* GetDefaultObj()
	{
		return GetDefaultObjImpl<UBFGCortexScanResponseSet>();
	}
};
static_assert(alignof(UBFGCortexScanResponseSet) == 0x000008, "Wrong alignment on UBFGCortexScanResponseSet");
static_assert(sizeof(UBFGCortexScanResponseSet) == 0x000148, "Wrong size on UBFGCortexScanResponseSet");
static_assert(offsetof(UBFGCortexScanResponseSet, M_pGameState) == 0x000028, "Member 'UBFGCortexScanResponseSet::M_pGameState' has a wrong offset!");
static_assert(offsetof(UBFGCortexScanResponseSet, M_config) == 0x000030, "Member 'UBFGCortexScanResponseSet::M_config' has a wrong offset!");
static_assert(offsetof(UBFGCortexScanResponseSet, M_aSharedConfigs) == 0x000110, "Member 'UBFGCortexScanResponseSet::M_aSharedConfigs' has a wrong offset!");
static_assert(offsetof(UBFGCortexScanResponseSet, M_pDataAsset) == 0x000120, "Member 'UBFGCortexScanResponseSet::M_pDataAsset' has a wrong offset!");
static_assert(offsetof(UBFGCortexScanResponseSet, M_apPools) == 0x000128, "Member 'UBFGCortexScanResponseSet::M_apPools' has a wrong offset!");
static_assert(offsetof(UBFGCortexScanResponseSet, M_pVariable) == 0x000138, "Member 'UBFGCortexScanResponseSet::M_pVariable' has a wrong offset!");

// Class BFGCore.BFGCreditsDestructableLetter
// 0x0008 (0x03E0 - 0x03D8)
class ABFGCreditsDestructableLetter final : public AActor
{
public:
	class UBlastMeshComponent*                    M_pMesh;                                           // 0x03D8(0x0008)(Edit, ExportObject, ZeroConstructor, EditConst, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"BFGCreditsDestructableLetter">();
	}
	static class ABFGCreditsDestructableLetter* GetDefaultObj()
	{
		return GetDefaultObjImpl<ABFGCreditsDestructableLetter>();
	}
};
static_assert(alignof(ABFGCreditsDestructableLetter) == 0x000008, "Wrong alignment on ABFGCreditsDestructableLetter");
static_assert(sizeof(ABFGCreditsDestructableLetter) == 0x0003E0, "Wrong size on ABFGCreditsDestructableLetter");
static_assert(offsetof(ABFGCreditsDestructableLetter, M_pMesh) == 0x0003D8, "Member 'ABFGCreditsDestructableLetter::M_pMesh' has a wrong offset!");

// Class BFGCore.BFGCreditsLine
// 0x0030 (0x0408 - 0x03D8)
class ABFGCreditsLine final : public AActor
{
public:
	class ABFGCredits*                            M_pCredits;                                        // 0x03D8(0x0008)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class FString                                 M_strText;                                         // 0x03E0(0x0010)(ZeroConstructor, Transient, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TArray<class ABFGCreditsLetter*>              M_apLetters;                                       // 0x03F0(0x0010)(ZeroConstructor, Transient, Protected, NativeAccessSpecifierProtected)
	uint8                                         Pad_400[0x8];                                      // 0x0400(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"BFGCreditsLine">();
	}
	static class ABFGCreditsLine* GetDefaultObj()
	{
		return GetDefaultObjImpl<ABFGCreditsLine>();
	}
};
static_assert(alignof(ABFGCreditsLine) == 0x000008, "Wrong alignment on ABFGCreditsLine");
static_assert(sizeof(ABFGCreditsLine) == 0x000408, "Wrong size on ABFGCreditsLine");
static_assert(offsetof(ABFGCreditsLine, M_pCredits) == 0x0003D8, "Member 'ABFGCreditsLine::M_pCredits' has a wrong offset!");
static_assert(offsetof(ABFGCreditsLine, M_strText) == 0x0003E0, "Member 'ABFGCreditsLine::M_strText' has a wrong offset!");
static_assert(offsetof(ABFGCreditsLine, M_apLetters) == 0x0003F0, "Member 'ABFGCreditsLine::M_apLetters' has a wrong offset!");

// Class BFGCore.BFGGameFlowState_MenuBase
// 0x0018 (0x0080 - 0x0068)
class UBFGGameFlowState_MenuBase : public UBFGGameFlowState
{
public:
	class UBFGWidget_MenuBase*                    M_pMenu;                                           // 0x0068(0x0008)(ExportObject, ZeroConstructor, Transient, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UObject*                                M_pMenuContext;                                    // 0x0070(0x0008)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_78[0x8];                                       // 0x0078(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"BFGGameFlowState_MenuBase">();
	}
	static class UBFGGameFlowState_MenuBase* GetDefaultObj()
	{
		return GetDefaultObjImpl<UBFGGameFlowState_MenuBase>();
	}
};
static_assert(alignof(UBFGGameFlowState_MenuBase) == 0x000008, "Wrong alignment on UBFGGameFlowState_MenuBase");
static_assert(sizeof(UBFGGameFlowState_MenuBase) == 0x000080, "Wrong size on UBFGGameFlowState_MenuBase");
static_assert(offsetof(UBFGGameFlowState_MenuBase, M_pMenu) == 0x000068, "Member 'UBFGGameFlowState_MenuBase::M_pMenu' has a wrong offset!");
static_assert(offsetof(UBFGGameFlowState_MenuBase, M_pMenuContext) == 0x000070, "Member 'UBFGGameFlowState_MenuBase::M_pMenuContext' has a wrong offset!");

// Class BFGCore.BFGGameFlowState_GenericDialog
// 0x0078 (0x00F8 - 0x0080)
class UBFGGameFlowState_GenericDialog : public UBFGGameFlowState_MenuBase
{
public:
	TSoftClassPtr<class UClass>                   M_pMenuClass;                                      // 0x0080(0x0028)(Edit, BlueprintVisible, BlueprintReadOnly, DisableEditOnInstance, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          M_bAllowCancel;                                    // 0x00A8(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          M_bHandleUserSignInChanges;                        // 0x00A9(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          M_bIsGameplay;                                     // 0x00AA(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_AB[0x5];                                       // 0x00AB(0x0005)(Fixing Size After Last Property [ Dumper-7 ])
	UMulticastDelegateProperty_                   M_OnDialogMessage;                                 // 0x00B0(0x0018)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	UMulticastDelegateProperty_                   M_OnMenuOpened;                                    // 0x00C8(0x0018)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	EBFGGenericDialogFlowSubState                 M_eSubState;                                       // 0x00E0(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_E1[0x7];                                       // 0x00E1(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<class UBFGDialogOptionHandler_Base*>   M_apDialogOptionHandlers;                          // 0x00E8(0x0010)(ExportObject, ZeroConstructor, ContainsInstancedReference, NativeAccessSpecifierPrivate)

public:
	void Action__DelegateSignature();
	void ActionDialogMessage__DelegateSignature(EBFGDialogMessage _eMessage);
	void ActionGenericDialog__DelegateSignature(class UBFGWidget_GenericDialog* _pDialog);
	void ActionIndex__DelegateSignature(int32 _iIndex);
	void OnDialogCancel();
	void OnDialogChangedSelection();
	void OnDialogOption(int32 IIndex);
	void OnOptionHandlerMessage(class UBFGDialogOptionHandler_Base* _pHandler, EBFGDialogMessage _eMessage);

	class UBFGDialogOptionHandler_Base* FindOptionHandlerByName(class FName _name) const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"BFGGameFlowState_GenericDialog">();
	}
	static class UBFGGameFlowState_GenericDialog* GetDefaultObj()
	{
		return GetDefaultObjImpl<UBFGGameFlowState_GenericDialog>();
	}
};
static_assert(alignof(UBFGGameFlowState_GenericDialog) == 0x000008, "Wrong alignment on UBFGGameFlowState_GenericDialog");
static_assert(sizeof(UBFGGameFlowState_GenericDialog) == 0x0000F8, "Wrong size on UBFGGameFlowState_GenericDialog");
static_assert(offsetof(UBFGGameFlowState_GenericDialog, M_pMenuClass) == 0x000080, "Member 'UBFGGameFlowState_GenericDialog::M_pMenuClass' has a wrong offset!");
static_assert(offsetof(UBFGGameFlowState_GenericDialog, M_bAllowCancel) == 0x0000A8, "Member 'UBFGGameFlowState_GenericDialog::M_bAllowCancel' has a wrong offset!");
static_assert(offsetof(UBFGGameFlowState_GenericDialog, M_bHandleUserSignInChanges) == 0x0000A9, "Member 'UBFGGameFlowState_GenericDialog::M_bHandleUserSignInChanges' has a wrong offset!");
static_assert(offsetof(UBFGGameFlowState_GenericDialog, M_bIsGameplay) == 0x0000AA, "Member 'UBFGGameFlowState_GenericDialog::M_bIsGameplay' has a wrong offset!");
static_assert(offsetof(UBFGGameFlowState_GenericDialog, M_OnDialogMessage) == 0x0000B0, "Member 'UBFGGameFlowState_GenericDialog::M_OnDialogMessage' has a wrong offset!");
static_assert(offsetof(UBFGGameFlowState_GenericDialog, M_OnMenuOpened) == 0x0000C8, "Member 'UBFGGameFlowState_GenericDialog::M_OnMenuOpened' has a wrong offset!");
static_assert(offsetof(UBFGGameFlowState_GenericDialog, M_eSubState) == 0x0000E0, "Member 'UBFGGameFlowState_GenericDialog::M_eSubState' has a wrong offset!");
static_assert(offsetof(UBFGGameFlowState_GenericDialog, M_apDialogOptionHandlers) == 0x0000E8, "Member 'UBFGGameFlowState_GenericDialog::M_apDialogOptionHandlers' has a wrong offset!");

// Class BFGCore.BFGGameFlowState_GenericDialog_Customizable
// 0x0010 (0x0108 - 0x00F8)
class UBFGGameFlowState_GenericDialog_Customizable : public UBFGGameFlowState_GenericDialog
{
public:
	TArray<class UBFGDialogOptionHandler_Base*>   M_apCustomOptionHandlers;                          // 0x00F8(0x0010)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, ContainsInstancedReference, NativeAccessSpecifierPublic)

public:
	void OnCustomOptionRegistered(int32 _iIndex);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"BFGGameFlowState_GenericDialog_Customizable">();
	}
	static class UBFGGameFlowState_GenericDialog_Customizable* GetDefaultObj()
	{
		return GetDefaultObjImpl<UBFGGameFlowState_GenericDialog_Customizable>();
	}
};
static_assert(alignof(UBFGGameFlowState_GenericDialog_Customizable) == 0x000008, "Wrong alignment on UBFGGameFlowState_GenericDialog_Customizable");
static_assert(sizeof(UBFGGameFlowState_GenericDialog_Customizable) == 0x000108, "Wrong size on UBFGGameFlowState_GenericDialog_Customizable");
static_assert(offsetof(UBFGGameFlowState_GenericDialog_Customizable, M_apCustomOptionHandlers) == 0x0000F8, "Member 'UBFGGameFlowState_GenericDialog_Customizable::M_apCustomOptionHandlers' has a wrong offset!");

// Class BFGCore.BFGGameFlowState_WaitForChunkload
// 0x0050 (0x0158 - 0x0108)
class UBFGGameFlowState_WaitForChunkload final : public UBFGGameFlowState_GenericDialog_Customizable
{
public:
	TSoftClassPtr<class UClass>                   M_pMenuClassDemo;                                  // 0x0108(0x0028)(Edit, BlueprintVisible, BlueprintReadOnly, DisableEditOnInstance, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_130[0x8];                                      // 0x0130(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	class UBFGWidget_MenuBase*                    M_pMenuMessageBox;                                 // 0x0138(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_140[0x18];                                     // 0x0140(0x0018)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void OnPurchaseScreenClosed(bool _bPurchased);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"BFGGameFlowState_WaitForChunkload">();
	}
	static class UBFGGameFlowState_WaitForChunkload* GetDefaultObj()
	{
		return GetDefaultObjImpl<UBFGGameFlowState_WaitForChunkload>();
	}
};
static_assert(alignof(UBFGGameFlowState_WaitForChunkload) == 0x000008, "Wrong alignment on UBFGGameFlowState_WaitForChunkload");
static_assert(sizeof(UBFGGameFlowState_WaitForChunkload) == 0x000158, "Wrong size on UBFGGameFlowState_WaitForChunkload");
static_assert(offsetof(UBFGGameFlowState_WaitForChunkload, M_pMenuClassDemo) == 0x000108, "Member 'UBFGGameFlowState_WaitForChunkload::M_pMenuClassDemo' has a wrong offset!");
static_assert(offsetof(UBFGGameFlowState_WaitForChunkload, M_pMenuMessageBox) == 0x000138, "Member 'UBFGGameFlowState_WaitForChunkload::M_pMenuMessageBox' has a wrong offset!");

// Class BFGCore.BFGCrowdLifeAnimationSequenceDefinitionAsset
// 0x01D8 (0x0208 - 0x0030)
class UBFGCrowdLifeAnimationSequenceDefinitionAsset final : public UDataAsset
{
public:
	struct FBFGCrowdLifeAnimationSequenceDefinition M_definition;                                      // 0x0030(0x01D8)(Edit, BlueprintVisible, BlueprintReadOnly, DisableEditOnInstance, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"BFGCrowdLifeAnimationSequenceDefinitionAsset">();
	}
	static class UBFGCrowdLifeAnimationSequenceDefinitionAsset* GetDefaultObj()
	{
		return GetDefaultObjImpl<UBFGCrowdLifeAnimationSequenceDefinitionAsset>();
	}
};
static_assert(alignof(UBFGCrowdLifeAnimationSequenceDefinitionAsset) == 0x000008, "Wrong alignment on UBFGCrowdLifeAnimationSequenceDefinitionAsset");
static_assert(sizeof(UBFGCrowdLifeAnimationSequenceDefinitionAsset) == 0x000208, "Wrong size on UBFGCrowdLifeAnimationSequenceDefinitionAsset");
static_assert(offsetof(UBFGCrowdLifeAnimationSequenceDefinitionAsset, M_definition) == 0x000030, "Member 'UBFGCrowdLifeAnimationSequenceDefinitionAsset::M_definition' has a wrong offset!");

// Class BFGCore.BFGQuest_ElementInsideTriggerTimer
// 0x01E8 (0x0528 - 0x0340)
class UBFGQuest_ElementInsideTriggerTimer final : public UBFGQuest_ElementObjectiveBase
{
public:
	struct FBFGActorBinding                       M_trigger;                                         // 0x0340(0x0090)(Edit, DisableEditOnInstance, NativeAccessSpecifierPublic)
	struct FBFGActorBinding                       M_pawns;                                           // 0x03D0(0x0090)(Edit, DisableEditOnInstance, NativeAccessSpecifierPublic)
	struct FBFGQuest_UIProvider                   M_descriptionProvider;                             // 0x0460(0x0050)(Edit, BlueprintVisible, BlueprintReadOnly, DisableEditOnInstance, NativeAccessSpecifierPublic)
	struct FTimespan                              M_duration;                                        // 0x04B0(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          M_bAddTimePerActor;                                // 0x04B8(0x0001)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          M_bShouldReset;                                    // 0x04B9(0x0001)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_4BA[0x6];                                      // 0x04BA(0x0006)(Fixing Size After Last Property [ Dumper-7 ])
	UMulticastDelegateProperty_                   M_OnTimerReset;                                    // 0x04C0(0x0018)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	UMulticastDelegateProperty_                   M_OnTimerFull;                                     // 0x04D8(0x0018)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	UMulticastDelegateProperty_                   M_OnActorAmountChangedTrigger;                     // 0x04F0(0x0018)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	UMulticastDelegateProperty_                   M_OnPercentChanged;                                // 0x0508(0x0018)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	class UBFGQuest_TriggerInTriggerTimer*        M_pTrigger;                                        // 0x0520(0x0008)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)

public:
	void OnEnterdQuestStep(class UBFGQuest_Element* _pElement);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"BFGQuest_ElementInsideTriggerTimer">();
	}
	static class UBFGQuest_ElementInsideTriggerTimer* GetDefaultObj()
	{
		return GetDefaultObjImpl<UBFGQuest_ElementInsideTriggerTimer>();
	}
};
static_assert(alignof(UBFGQuest_ElementInsideTriggerTimer) == 0x000008, "Wrong alignment on UBFGQuest_ElementInsideTriggerTimer");
static_assert(sizeof(UBFGQuest_ElementInsideTriggerTimer) == 0x000528, "Wrong size on UBFGQuest_ElementInsideTriggerTimer");
static_assert(offsetof(UBFGQuest_ElementInsideTriggerTimer, M_trigger) == 0x000340, "Member 'UBFGQuest_ElementInsideTriggerTimer::M_trigger' has a wrong offset!");
static_assert(offsetof(UBFGQuest_ElementInsideTriggerTimer, M_pawns) == 0x0003D0, "Member 'UBFGQuest_ElementInsideTriggerTimer::M_pawns' has a wrong offset!");
static_assert(offsetof(UBFGQuest_ElementInsideTriggerTimer, M_descriptionProvider) == 0x000460, "Member 'UBFGQuest_ElementInsideTriggerTimer::M_descriptionProvider' has a wrong offset!");
static_assert(offsetof(UBFGQuest_ElementInsideTriggerTimer, M_duration) == 0x0004B0, "Member 'UBFGQuest_ElementInsideTriggerTimer::M_duration' has a wrong offset!");
static_assert(offsetof(UBFGQuest_ElementInsideTriggerTimer, M_bAddTimePerActor) == 0x0004B8, "Member 'UBFGQuest_ElementInsideTriggerTimer::M_bAddTimePerActor' has a wrong offset!");
static_assert(offsetof(UBFGQuest_ElementInsideTriggerTimer, M_bShouldReset) == 0x0004B9, "Member 'UBFGQuest_ElementInsideTriggerTimer::M_bShouldReset' has a wrong offset!");
static_assert(offsetof(UBFGQuest_ElementInsideTriggerTimer, M_OnTimerReset) == 0x0004C0, "Member 'UBFGQuest_ElementInsideTriggerTimer::M_OnTimerReset' has a wrong offset!");
static_assert(offsetof(UBFGQuest_ElementInsideTriggerTimer, M_OnTimerFull) == 0x0004D8, "Member 'UBFGQuest_ElementInsideTriggerTimer::M_OnTimerFull' has a wrong offset!");
static_assert(offsetof(UBFGQuest_ElementInsideTriggerTimer, M_OnActorAmountChangedTrigger) == 0x0004F0, "Member 'UBFGQuest_ElementInsideTriggerTimer::M_OnActorAmountChangedTrigger' has a wrong offset!");
static_assert(offsetof(UBFGQuest_ElementInsideTriggerTimer, M_OnPercentChanged) == 0x000508, "Member 'UBFGQuest_ElementInsideTriggerTimer::M_OnPercentChanged' has a wrong offset!");
static_assert(offsetof(UBFGQuest_ElementInsideTriggerTimer, M_pTrigger) == 0x000520, "Member 'UBFGQuest_ElementInsideTriggerTimer::M_pTrigger' has a wrong offset!");

// Class BFGCore.BFGInputScheme
// 0x0038 (0x0060 - 0x0028)
class UBFGInputScheme final : public UObject
{
public:
	class FString                                 M_strName;                                         // 0x0028(0x0010)(Edit, ZeroConstructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UTexture2D*                             M_pLayoutTexture;                                  // 0x0038(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TArray<struct FBFGInputActionMap>             M_aInputActionMaps;                                // 0x0040(0x0010)(Edit, ZeroConstructor, Protected, NativeAccessSpecifierProtected)
	TArray<struct FBFGInputAxisMap>               M_aInputAxisMaps;                                  // 0x0050(0x0010)(Edit, ZeroConstructor, Protected, NativeAccessSpecifierProtected)

public:
	class UTexture2D* GetLayoutTexture() const;
	class FString GetName() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"BFGInputScheme">();
	}
	static class UBFGInputScheme* GetDefaultObj()
	{
		return GetDefaultObjImpl<UBFGInputScheme>();
	}
};
static_assert(alignof(UBFGInputScheme) == 0x000008, "Wrong alignment on UBFGInputScheme");
static_assert(sizeof(UBFGInputScheme) == 0x000060, "Wrong size on UBFGInputScheme");
static_assert(offsetof(UBFGInputScheme, M_strName) == 0x000028, "Member 'UBFGInputScheme::M_strName' has a wrong offset!");
static_assert(offsetof(UBFGInputScheme, M_pLayoutTexture) == 0x000038, "Member 'UBFGInputScheme::M_pLayoutTexture' has a wrong offset!");
static_assert(offsetof(UBFGInputScheme, M_aInputActionMaps) == 0x000040, "Member 'UBFGInputScheme::M_aInputActionMaps' has a wrong offset!");
static_assert(offsetof(UBFGInputScheme, M_aInputAxisMaps) == 0x000050, "Member 'UBFGInputScheme::M_aInputAxisMaps' has a wrong offset!");

// Class BFGCore.BFGCrowdLifeStationComponent
// 0x02F8 (0x0960 - 0x0668)
class UBFGCrowdLifeStationComponent final : public UPrimitiveComponent
{
public:
	uint8                                         Pad_668[0x8];                                      // 0x0668(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	UMulticastDelegateProperty_                   M_onAnimationSequenceChanged;                      // 0x0670(0x0018)(ZeroConstructor, InstancedReference, BlueprintAssignable, BlueprintCallable, NativeAccessSpecifierPublic)
	uint8                                         Pad_688[0x8];                                      // 0x0688(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<struct FBFGCrowdLifeStationAcquisitionSphere> M_aAcquisitionSpheres;                             // 0x0690(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Protected, NativeAccessSpecifierProtected)
	bool                                          M_bSpawnAtStart;                                   // 0x06A0(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_6A1[0x7];                                      // 0x06A1(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	TSubclassOf<class ABFGNPCCharacter>           SpawnType;                                         // 0x06A8(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UBFGSpawningComposition*                M_pSpawningComposition;                            // 0x06B0(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          M_bSpawnEquipped;                                  // 0x06B8(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_6B9[0x7];                                      // 0x06B9(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	class UBFGSpawningComposition*                M_pRuntimeSpawningCompositionAsset;                // 0x06C0(0x0008)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UBFGCrowdLifeRecruitmentAsset*          M_pRecruitmentAsset;                               // 0x06C8(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UBFGCrowdLifeRecruitmentAsset*          M_pRuntimeRecruitmentAsset;                        // 0x06D0(0x0008)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	struct FBFGCrowdLifeAnimationSequenceDefinition M_animationSequenceDefinition;                     // 0x06D8(0x01D8)(Edit, BlueprintVisible, BlueprintReadOnly, Protected, NativeAccessSpecifierProtected)
	bool                                          M_bCanRecruit;                                     // 0x08B0(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_8B1[0x3];                                      // 0x08B1(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         M_fCooldDown;                                      // 0x08B4(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         M_fStationRadius;                                  // 0x08B8(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         M_fAcquisitionDuration;                            // 0x08BC(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          M_bStationEnabled;                                 // 0x08C0(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_8C1[0x7];                                      // 0x08C1(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	struct FGameplayTagContainer                  M_gameplayTags;                                    // 0x08C8(0x0020)(Edit, BlueprintVisible, Protected, NativeAccessSpecifierProtected)
	EBFGCrowdScriptConAsset_Participant           M_eScriptParticipantID;                            // 0x08E8(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_8E9[0x7];                                      // 0x08E9(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	class UAnimationAsset*                        M_pEntryAnimationToPlay;                           // 0x08F0(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UAnimationAsset*                        M_pAnimationToPlay;                                // 0x08F8(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          M_bLoopAnimation;                                  // 0x0900(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_901[0x3];                                      // 0x0901(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	int32                                         M_iAnimationNumLoops;                              // 0x0904(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         M_fTimeSinceOccupied;                              // 0x0908(0x0004)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         M_fTimeSinceStationFree;                           // 0x090C(0x0004)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          M_bStationIsRegistered;                            // 0x0910(0x0001)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          M_bIsWaitingJoinConfirm;                           // 0x0911(0x0001)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          M_bAnimationPlayed;                                // 0x0912(0x0001)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          M_bNPCShouldLeaveStation;                          // 0x0913(0x0001)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_914[0x4];                                      // 0x0914(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class UBFGNetworkPathAgent*                   M_pAgent;                                          // 0x0918(0x0008)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          M_bWaitingSpawnAtStart;                            // 0x0920(0x0001)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_921[0x7];                                      // 0x0921(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	class UBFGNetworkPathAgent*                   M_pSpawnedAtStartAgent;                            // 0x0928(0x0008)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          M_bDespawnedByCombatBubble;                        // 0x0930(0x0001)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_931[0x3];                                      // 0x0931(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         M_fMaxReserveTime;                                 // 0x0934(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UBFGNetworkPathAgent*                   M_pReservedForAgent;                               // 0x0938(0x0008)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          M_bReserveTimerLocked;                             // 0x0940(0x0001)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_941[0x3];                                      // 0x0941(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	int32                                         M_iDebugComponentID;                               // 0x0944(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, NonPIEDuplicateTransient, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UBFGTrafficCrowdManager*                M_pManager;                                        // 0x0948(0x0008)(ExportObject, ZeroConstructor, Transient, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UBFG_AISettings*                        M_pSettings;                                       // 0x0950(0x0008)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_958[0x8];                                      // 0x0958(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void SetStationEnabled(bool _bEnabled);

	bool IsStationEnabled() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"BFGCrowdLifeStationComponent">();
	}
	static class UBFGCrowdLifeStationComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UBFGCrowdLifeStationComponent>();
	}
};
static_assert(alignof(UBFGCrowdLifeStationComponent) == 0x000008, "Wrong alignment on UBFGCrowdLifeStationComponent");
static_assert(sizeof(UBFGCrowdLifeStationComponent) == 0x000960, "Wrong size on UBFGCrowdLifeStationComponent");
static_assert(offsetof(UBFGCrowdLifeStationComponent, M_onAnimationSequenceChanged) == 0x000670, "Member 'UBFGCrowdLifeStationComponent::M_onAnimationSequenceChanged' has a wrong offset!");
static_assert(offsetof(UBFGCrowdLifeStationComponent, M_aAcquisitionSpheres) == 0x000690, "Member 'UBFGCrowdLifeStationComponent::M_aAcquisitionSpheres' has a wrong offset!");
static_assert(offsetof(UBFGCrowdLifeStationComponent, M_bSpawnAtStart) == 0x0006A0, "Member 'UBFGCrowdLifeStationComponent::M_bSpawnAtStart' has a wrong offset!");
static_assert(offsetof(UBFGCrowdLifeStationComponent, SpawnType) == 0x0006A8, "Member 'UBFGCrowdLifeStationComponent::SpawnType' has a wrong offset!");
static_assert(offsetof(UBFGCrowdLifeStationComponent, M_pSpawningComposition) == 0x0006B0, "Member 'UBFGCrowdLifeStationComponent::M_pSpawningComposition' has a wrong offset!");
static_assert(offsetof(UBFGCrowdLifeStationComponent, M_bSpawnEquipped) == 0x0006B8, "Member 'UBFGCrowdLifeStationComponent::M_bSpawnEquipped' has a wrong offset!");
static_assert(offsetof(UBFGCrowdLifeStationComponent, M_pRuntimeSpawningCompositionAsset) == 0x0006C0, "Member 'UBFGCrowdLifeStationComponent::M_pRuntimeSpawningCompositionAsset' has a wrong offset!");
static_assert(offsetof(UBFGCrowdLifeStationComponent, M_pRecruitmentAsset) == 0x0006C8, "Member 'UBFGCrowdLifeStationComponent::M_pRecruitmentAsset' has a wrong offset!");
static_assert(offsetof(UBFGCrowdLifeStationComponent, M_pRuntimeRecruitmentAsset) == 0x0006D0, "Member 'UBFGCrowdLifeStationComponent::M_pRuntimeRecruitmentAsset' has a wrong offset!");
static_assert(offsetof(UBFGCrowdLifeStationComponent, M_animationSequenceDefinition) == 0x0006D8, "Member 'UBFGCrowdLifeStationComponent::M_animationSequenceDefinition' has a wrong offset!");
static_assert(offsetof(UBFGCrowdLifeStationComponent, M_bCanRecruit) == 0x0008B0, "Member 'UBFGCrowdLifeStationComponent::M_bCanRecruit' has a wrong offset!");
static_assert(offsetof(UBFGCrowdLifeStationComponent, M_fCooldDown) == 0x0008B4, "Member 'UBFGCrowdLifeStationComponent::M_fCooldDown' has a wrong offset!");
static_assert(offsetof(UBFGCrowdLifeStationComponent, M_fStationRadius) == 0x0008B8, "Member 'UBFGCrowdLifeStationComponent::M_fStationRadius' has a wrong offset!");
static_assert(offsetof(UBFGCrowdLifeStationComponent, M_fAcquisitionDuration) == 0x0008BC, "Member 'UBFGCrowdLifeStationComponent::M_fAcquisitionDuration' has a wrong offset!");
static_assert(offsetof(UBFGCrowdLifeStationComponent, M_bStationEnabled) == 0x0008C0, "Member 'UBFGCrowdLifeStationComponent::M_bStationEnabled' has a wrong offset!");
static_assert(offsetof(UBFGCrowdLifeStationComponent, M_gameplayTags) == 0x0008C8, "Member 'UBFGCrowdLifeStationComponent::M_gameplayTags' has a wrong offset!");
static_assert(offsetof(UBFGCrowdLifeStationComponent, M_eScriptParticipantID) == 0x0008E8, "Member 'UBFGCrowdLifeStationComponent::M_eScriptParticipantID' has a wrong offset!");
static_assert(offsetof(UBFGCrowdLifeStationComponent, M_pEntryAnimationToPlay) == 0x0008F0, "Member 'UBFGCrowdLifeStationComponent::M_pEntryAnimationToPlay' has a wrong offset!");
static_assert(offsetof(UBFGCrowdLifeStationComponent, M_pAnimationToPlay) == 0x0008F8, "Member 'UBFGCrowdLifeStationComponent::M_pAnimationToPlay' has a wrong offset!");
static_assert(offsetof(UBFGCrowdLifeStationComponent, M_bLoopAnimation) == 0x000900, "Member 'UBFGCrowdLifeStationComponent::M_bLoopAnimation' has a wrong offset!");
static_assert(offsetof(UBFGCrowdLifeStationComponent, M_iAnimationNumLoops) == 0x000904, "Member 'UBFGCrowdLifeStationComponent::M_iAnimationNumLoops' has a wrong offset!");
static_assert(offsetof(UBFGCrowdLifeStationComponent, M_fTimeSinceOccupied) == 0x000908, "Member 'UBFGCrowdLifeStationComponent::M_fTimeSinceOccupied' has a wrong offset!");
static_assert(offsetof(UBFGCrowdLifeStationComponent, M_fTimeSinceStationFree) == 0x00090C, "Member 'UBFGCrowdLifeStationComponent::M_fTimeSinceStationFree' has a wrong offset!");
static_assert(offsetof(UBFGCrowdLifeStationComponent, M_bStationIsRegistered) == 0x000910, "Member 'UBFGCrowdLifeStationComponent::M_bStationIsRegistered' has a wrong offset!");
static_assert(offsetof(UBFGCrowdLifeStationComponent, M_bIsWaitingJoinConfirm) == 0x000911, "Member 'UBFGCrowdLifeStationComponent::M_bIsWaitingJoinConfirm' has a wrong offset!");
static_assert(offsetof(UBFGCrowdLifeStationComponent, M_bAnimationPlayed) == 0x000912, "Member 'UBFGCrowdLifeStationComponent::M_bAnimationPlayed' has a wrong offset!");
static_assert(offsetof(UBFGCrowdLifeStationComponent, M_bNPCShouldLeaveStation) == 0x000913, "Member 'UBFGCrowdLifeStationComponent::M_bNPCShouldLeaveStation' has a wrong offset!");
static_assert(offsetof(UBFGCrowdLifeStationComponent, M_pAgent) == 0x000918, "Member 'UBFGCrowdLifeStationComponent::M_pAgent' has a wrong offset!");
static_assert(offsetof(UBFGCrowdLifeStationComponent, M_bWaitingSpawnAtStart) == 0x000920, "Member 'UBFGCrowdLifeStationComponent::M_bWaitingSpawnAtStart' has a wrong offset!");
static_assert(offsetof(UBFGCrowdLifeStationComponent, M_pSpawnedAtStartAgent) == 0x000928, "Member 'UBFGCrowdLifeStationComponent::M_pSpawnedAtStartAgent' has a wrong offset!");
static_assert(offsetof(UBFGCrowdLifeStationComponent, M_bDespawnedByCombatBubble) == 0x000930, "Member 'UBFGCrowdLifeStationComponent::M_bDespawnedByCombatBubble' has a wrong offset!");
static_assert(offsetof(UBFGCrowdLifeStationComponent, M_fMaxReserveTime) == 0x000934, "Member 'UBFGCrowdLifeStationComponent::M_fMaxReserveTime' has a wrong offset!");
static_assert(offsetof(UBFGCrowdLifeStationComponent, M_pReservedForAgent) == 0x000938, "Member 'UBFGCrowdLifeStationComponent::M_pReservedForAgent' has a wrong offset!");
static_assert(offsetof(UBFGCrowdLifeStationComponent, M_bReserveTimerLocked) == 0x000940, "Member 'UBFGCrowdLifeStationComponent::M_bReserveTimerLocked' has a wrong offset!");
static_assert(offsetof(UBFGCrowdLifeStationComponent, M_iDebugComponentID) == 0x000944, "Member 'UBFGCrowdLifeStationComponent::M_iDebugComponentID' has a wrong offset!");
static_assert(offsetof(UBFGCrowdLifeStationComponent, M_pManager) == 0x000948, "Member 'UBFGCrowdLifeStationComponent::M_pManager' has a wrong offset!");
static_assert(offsetof(UBFGCrowdLifeStationComponent, M_pSettings) == 0x000950, "Member 'UBFGCrowdLifeStationComponent::M_pSettings' has a wrong offset!");

// Class BFGCore.BFGCrowdLifeTaskNodeStrategyHighRes
// 0x0000 (0x0028 - 0x0028)
class UBFGCrowdLifeTaskNodeStrategyHighRes final : public UBFGCrowdLifeTaskNodeStrategyBase
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"BFGCrowdLifeTaskNodeStrategyHighRes">();
	}
	static class UBFGCrowdLifeTaskNodeStrategyHighRes* GetDefaultObj()
	{
		return GetDefaultObjImpl<UBFGCrowdLifeTaskNodeStrategyHighRes>();
	}
};
static_assert(alignof(UBFGCrowdLifeTaskNodeStrategyHighRes) == 0x000008, "Wrong alignment on UBFGCrowdLifeTaskNodeStrategyHighRes");
static_assert(sizeof(UBFGCrowdLifeTaskNodeStrategyHighRes) == 0x000028, "Wrong size on UBFGCrowdLifeTaskNodeStrategyHighRes");

// Class BFGCore.BFGCrowdManagerSettings
// 0x0010 (0x03E8 - 0x03D8)
class ABFGCrowdManagerSettings final : public AInfo
{
public:
	struct FBFGCrowdManagerPlatformSettings       M_settings_PC;                                     // 0x03D8(0x0004)(Edit, BlueprintVisible, NoDestructor, NativeAccessSpecifierPublic)
	struct FBFGCrowdManagerPlatformSettings       M_settings_XboxOne;                                // 0x03DC(0x0004)(Edit, BlueprintVisible, NoDestructor, NativeAccessSpecifierPublic)
	struct FBFGCrowdManagerPlatformSettings       M_settings_PS4;                                    // 0x03E0(0x0004)(Edit, BlueprintVisible, NoDestructor, NativeAccessSpecifierPublic)
	uint8                                         Pad_3E4[0x4];                                      // 0x03E4(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"BFGCrowdManagerSettings">();
	}
	static class ABFGCrowdManagerSettings* GetDefaultObj()
	{
		return GetDefaultObjImpl<ABFGCrowdManagerSettings>();
	}
};
static_assert(alignof(ABFGCrowdManagerSettings) == 0x000008, "Wrong alignment on ABFGCrowdManagerSettings");
static_assert(sizeof(ABFGCrowdManagerSettings) == 0x0003E8, "Wrong size on ABFGCrowdManagerSettings");
static_assert(offsetof(ABFGCrowdManagerSettings, M_settings_PC) == 0x0003D8, "Member 'ABFGCrowdManagerSettings::M_settings_PC' has a wrong offset!");
static_assert(offsetof(ABFGCrowdManagerSettings, M_settings_XboxOne) == 0x0003DC, "Member 'ABFGCrowdManagerSettings::M_settings_XboxOne' has a wrong offset!");
static_assert(offsetof(ABFGCrowdManagerSettings, M_settings_PS4) == 0x0003E0, "Member 'ABFGCrowdManagerSettings::M_settings_PS4' has a wrong offset!");

// Class BFGCore.BFGGameplayEffectResponse
// 0x0058 (0x0080 - 0x0028)
class UBFGGameplayEffectResponse : public UObject
{
public:
	struct FGameplayTagQuery                      M_oTagQuery;                                       // 0x0028(0x0048)(Edit, BlueprintVisible, BlueprintReadOnly, Protected, NativeAccessSpecifierProtected)
	class UBFGActorComponent_GameplayEffectResponses* M_pResponseComponent;                              // 0x0070(0x0008)(ExportObject, ZeroConstructor, Transient, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_78[0x8];                                       // 0x0078(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void OnActivate();
	void OnDeactivate();
	void OnSustain();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"BFGGameplayEffectResponse">();
	}
	static class UBFGGameplayEffectResponse* GetDefaultObj()
	{
		return GetDefaultObjImpl<UBFGGameplayEffectResponse>();
	}
};
static_assert(alignof(UBFGGameplayEffectResponse) == 0x000008, "Wrong alignment on UBFGGameplayEffectResponse");
static_assert(sizeof(UBFGGameplayEffectResponse) == 0x000080, "Wrong size on UBFGGameplayEffectResponse");
static_assert(offsetof(UBFGGameplayEffectResponse, M_oTagQuery) == 0x000028, "Member 'UBFGGameplayEffectResponse::M_oTagQuery' has a wrong offset!");
static_assert(offsetof(UBFGGameplayEffectResponse, M_pResponseComponent) == 0x000070, "Member 'UBFGGameplayEffectResponse::M_pResponseComponent' has a wrong offset!");

// Class BFGCore.BFGGameplayEffectResponse_BlockAirDash
// 0x0000 (0x0080 - 0x0080)
class UBFGGameplayEffectResponse_BlockAirDash : public UBFGGameplayEffectResponse
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"BFGGameplayEffectResponse_BlockAirDash">();
	}
	static class UBFGGameplayEffectResponse_BlockAirDash* GetDefaultObj()
	{
		return GetDefaultObjImpl<UBFGGameplayEffectResponse_BlockAirDash>();
	}
};
static_assert(alignof(UBFGGameplayEffectResponse_BlockAirDash) == 0x000008, "Wrong alignment on UBFGGameplayEffectResponse_BlockAirDash");
static_assert(sizeof(UBFGGameplayEffectResponse_BlockAirDash) == 0x000080, "Wrong size on UBFGGameplayEffectResponse_BlockAirDash");

// Class BFGCore.BFGCrowdScriptConComponent
// 0x00A0 (0x01C8 - 0x0128)
class UBFGCrowdScriptConComponent final : public UActorComponent
{
public:
	uint8                                         Pad_128[0x8];                                      // 0x0128(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	class UBFGCrowdScriptConAsset*                M_softScriptAsset;                                 // 0x0130(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	int32                                         M_iCurrentLine;                                    // 0x0138(0x0004)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          M_bIsEnabled;                                      // 0x013C(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	EBFG_CrowdScriptConTriggeringBehaviour        M_eTriggeringBehaviour;                            // 0x013D(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_13E[0x2];                                      // 0x013E(0x0002)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         M_fTriggeringCooldDown;                            // 0x0140(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         M_fActivationRadius;                               // 0x0144(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          M_bReleaseNPCWhenFinished;                         // 0x0148(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_149[0x7];                                      // 0x0149(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	struct FGameplayTagContainer                  M_gameplayTags;                                    // 0x0150(0x0020)(Edit, BlueprintVisible, Protected, NativeAccessSpecifierProtected)
	bool                                          M_bActivatedByTrigger;                             // 0x0170(0x0001)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_171[0x7];                                      // 0x0171(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<struct FBFGCrowdScriptConParticipant>  M_aParticipants;                                   // 0x0178(0x0010)(ZeroConstructor, Transient, ContainsInstancedReference, Protected, NativeAccessSpecifierProtected)
	TArray<EBFGCrowdScriptConAsset_Participant>   M_aMissingParticipants;                            // 0x0188(0x0010)(ZeroConstructor, Transient, Protected, NativeAccessSpecifierProtected)
	class UAudioComponent*                        M_pAudioComponent;                                 // 0x0198(0x0008)(ExportObject, ZeroConstructor, Transient, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          M_bIsPlaying;                                      // 0x01A0(0x0001)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          M_bIsFinishedPlaying;                              // 0x01A1(0x0001)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	EBFG_CrowdScriptConPhase                      M_ePhase;                                          // 0x01A2(0x0001)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_1A3[0x1];                                      // 0x01A3(0x0001)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         M_fCoolDownTimer;                                  // 0x01A4(0x0004)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          M_bInterruptRequested;                             // 0x01A8(0x0001)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_1A9[0x7];                                      // 0x01A9(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	class UBFGCrowdScriptConAsset*                M_pCachedScriptConAsset;                           // 0x01B0(0x0008)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UBFGTrafficCrowdManager*                M_pManager;                                        // 0x01B8(0x0008)(ExportObject, ZeroConstructor, Transient, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	bool                                          M_bRegisteredToManager;                            // 0x01C0(0x0001)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_1C1[0x7];                                      // 0x01C1(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void OnParticipantDead(class UBFGNetworkPathAgent* _pAgent, class AActor* _pActor, bool _bIsAttached);
	void OnParticipantDestroyed(class UBFGNetworkPathAgent* _pAgent);
	void SetEnabled(bool _bEnabled);

	bool IsEnabled() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"BFGCrowdScriptConComponent">();
	}
	static class UBFGCrowdScriptConComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UBFGCrowdScriptConComponent>();
	}
};
static_assert(alignof(UBFGCrowdScriptConComponent) == 0x000008, "Wrong alignment on UBFGCrowdScriptConComponent");
static_assert(sizeof(UBFGCrowdScriptConComponent) == 0x0001C8, "Wrong size on UBFGCrowdScriptConComponent");
static_assert(offsetof(UBFGCrowdScriptConComponent, M_softScriptAsset) == 0x000130, "Member 'UBFGCrowdScriptConComponent::M_softScriptAsset' has a wrong offset!");
static_assert(offsetof(UBFGCrowdScriptConComponent, M_iCurrentLine) == 0x000138, "Member 'UBFGCrowdScriptConComponent::M_iCurrentLine' has a wrong offset!");
static_assert(offsetof(UBFGCrowdScriptConComponent, M_bIsEnabled) == 0x00013C, "Member 'UBFGCrowdScriptConComponent::M_bIsEnabled' has a wrong offset!");
static_assert(offsetof(UBFGCrowdScriptConComponent, M_eTriggeringBehaviour) == 0x00013D, "Member 'UBFGCrowdScriptConComponent::M_eTriggeringBehaviour' has a wrong offset!");
static_assert(offsetof(UBFGCrowdScriptConComponent, M_fTriggeringCooldDown) == 0x000140, "Member 'UBFGCrowdScriptConComponent::M_fTriggeringCooldDown' has a wrong offset!");
static_assert(offsetof(UBFGCrowdScriptConComponent, M_fActivationRadius) == 0x000144, "Member 'UBFGCrowdScriptConComponent::M_fActivationRadius' has a wrong offset!");
static_assert(offsetof(UBFGCrowdScriptConComponent, M_bReleaseNPCWhenFinished) == 0x000148, "Member 'UBFGCrowdScriptConComponent::M_bReleaseNPCWhenFinished' has a wrong offset!");
static_assert(offsetof(UBFGCrowdScriptConComponent, M_gameplayTags) == 0x000150, "Member 'UBFGCrowdScriptConComponent::M_gameplayTags' has a wrong offset!");
static_assert(offsetof(UBFGCrowdScriptConComponent, M_bActivatedByTrigger) == 0x000170, "Member 'UBFGCrowdScriptConComponent::M_bActivatedByTrigger' has a wrong offset!");
static_assert(offsetof(UBFGCrowdScriptConComponent, M_aParticipants) == 0x000178, "Member 'UBFGCrowdScriptConComponent::M_aParticipants' has a wrong offset!");
static_assert(offsetof(UBFGCrowdScriptConComponent, M_aMissingParticipants) == 0x000188, "Member 'UBFGCrowdScriptConComponent::M_aMissingParticipants' has a wrong offset!");
static_assert(offsetof(UBFGCrowdScriptConComponent, M_pAudioComponent) == 0x000198, "Member 'UBFGCrowdScriptConComponent::M_pAudioComponent' has a wrong offset!");
static_assert(offsetof(UBFGCrowdScriptConComponent, M_bIsPlaying) == 0x0001A0, "Member 'UBFGCrowdScriptConComponent::M_bIsPlaying' has a wrong offset!");
static_assert(offsetof(UBFGCrowdScriptConComponent, M_bIsFinishedPlaying) == 0x0001A1, "Member 'UBFGCrowdScriptConComponent::M_bIsFinishedPlaying' has a wrong offset!");
static_assert(offsetof(UBFGCrowdScriptConComponent, M_ePhase) == 0x0001A2, "Member 'UBFGCrowdScriptConComponent::M_ePhase' has a wrong offset!");
static_assert(offsetof(UBFGCrowdScriptConComponent, M_fCoolDownTimer) == 0x0001A4, "Member 'UBFGCrowdScriptConComponent::M_fCoolDownTimer' has a wrong offset!");
static_assert(offsetof(UBFGCrowdScriptConComponent, M_bInterruptRequested) == 0x0001A8, "Member 'UBFGCrowdScriptConComponent::M_bInterruptRequested' has a wrong offset!");
static_assert(offsetof(UBFGCrowdScriptConComponent, M_pCachedScriptConAsset) == 0x0001B0, "Member 'UBFGCrowdScriptConComponent::M_pCachedScriptConAsset' has a wrong offset!");
static_assert(offsetof(UBFGCrowdScriptConComponent, M_pManager) == 0x0001B8, "Member 'UBFGCrowdScriptConComponent::M_pManager' has a wrong offset!");
static_assert(offsetof(UBFGCrowdScriptConComponent, M_bRegisteredToManager) == 0x0001C0, "Member 'UBFGCrowdScriptConComponent::M_bRegisteredToManager' has a wrong offset!");

// Class BFGCore.BFGQuest_ElementRoot
// 0x01B0 (0x04A8 - 0x02F8)
class UBFGQuest_ElementRoot final : public UBFGQuest_Element
{
public:
	UMulticastDelegateProperty_                   M_OnAvailableEvent;                                // 0x02F8(0x0018)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	TSoftObjectPtr<class UBFGEnvironment>         M_softEnvironment;                                 // 0x0310(0x0028)(Edit, BlueprintVisible, BlueprintReadOnly, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          M_bAutoGenerateKillPlayerCondition;                // 0x0338(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          M_bAutoStartQuest;                                 // 0x0339(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          M_bLevelEnterStartQuest;                           // 0x033A(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          M_bStartWithTrigger;                               // 0x033B(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_33C[0x4];                                      // 0x033C(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	struct FBFGActorBinding                       M_StartWithActor;                                  // 0x0340(0x0090)(Edit, BlueprintVisible, BlueprintReadOnly, Protected, NativeAccessSpecifierProtected)
	struct FBFGActorBinding                       M_PawnForStartTrigger;                             // 0x03D0(0x0090)(Edit, BlueprintVisible, BlueprintReadOnly, Protected, NativeAccessSpecifierProtected)
	bool                                          M_bStartOnEnter;                                   // 0x0460(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          M_bStartOnExit;                                    // 0x0461(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          M_bStartOnInteract;                                // 0x0462(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_463[0x5];                                      // 0x0463(0x0005)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<TSoftObjectPtr<class UWorld>>          M_aIntroLevels;                                    // 0x0468(0x0010)(Edit, ZeroConstructor, DisableEditOnInstance, Protected, UObjectWrapper, NativeAccessSpecifierProtected)
	bool                                          M_bIntroLevelsRemainActive;                        // 0x0478(0x0001)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_479[0x7];                                      // 0x0479(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<TSoftObjectPtr<class UWorld>>          M_aBodyLevels;                                     // 0x0480(0x0010)(Edit, ZeroConstructor, DisableEditOnInstance, Protected, UObjectWrapper, NativeAccessSpecifierProtected)
	bool                                          M_bBodyLevelsRemainActive;                         // 0x0490(0x0001)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_491[0x7];                                      // 0x0491(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	class UBFGQuest_StreamingLevels*              M_pIntroTracker;                                   // 0x0498(0x0008)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UBFGQuest_StreamingLevels*              M_pBodyTracker;                                    // 0x04A0(0x0008)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"BFGQuest_ElementRoot">();
	}
	static class UBFGQuest_ElementRoot* GetDefaultObj()
	{
		return GetDefaultObjImpl<UBFGQuest_ElementRoot>();
	}
};
static_assert(alignof(UBFGQuest_ElementRoot) == 0x000008, "Wrong alignment on UBFGQuest_ElementRoot");
static_assert(sizeof(UBFGQuest_ElementRoot) == 0x0004A8, "Wrong size on UBFGQuest_ElementRoot");
static_assert(offsetof(UBFGQuest_ElementRoot, M_OnAvailableEvent) == 0x0002F8, "Member 'UBFGQuest_ElementRoot::M_OnAvailableEvent' has a wrong offset!");
static_assert(offsetof(UBFGQuest_ElementRoot, M_softEnvironment) == 0x000310, "Member 'UBFGQuest_ElementRoot::M_softEnvironment' has a wrong offset!");
static_assert(offsetof(UBFGQuest_ElementRoot, M_bAutoGenerateKillPlayerCondition) == 0x000338, "Member 'UBFGQuest_ElementRoot::M_bAutoGenerateKillPlayerCondition' has a wrong offset!");
static_assert(offsetof(UBFGQuest_ElementRoot, M_bAutoStartQuest) == 0x000339, "Member 'UBFGQuest_ElementRoot::M_bAutoStartQuest' has a wrong offset!");
static_assert(offsetof(UBFGQuest_ElementRoot, M_bLevelEnterStartQuest) == 0x00033A, "Member 'UBFGQuest_ElementRoot::M_bLevelEnterStartQuest' has a wrong offset!");
static_assert(offsetof(UBFGQuest_ElementRoot, M_bStartWithTrigger) == 0x00033B, "Member 'UBFGQuest_ElementRoot::M_bStartWithTrigger' has a wrong offset!");
static_assert(offsetof(UBFGQuest_ElementRoot, M_StartWithActor) == 0x000340, "Member 'UBFGQuest_ElementRoot::M_StartWithActor' has a wrong offset!");
static_assert(offsetof(UBFGQuest_ElementRoot, M_PawnForStartTrigger) == 0x0003D0, "Member 'UBFGQuest_ElementRoot::M_PawnForStartTrigger' has a wrong offset!");
static_assert(offsetof(UBFGQuest_ElementRoot, M_bStartOnEnter) == 0x000460, "Member 'UBFGQuest_ElementRoot::M_bStartOnEnter' has a wrong offset!");
static_assert(offsetof(UBFGQuest_ElementRoot, M_bStartOnExit) == 0x000461, "Member 'UBFGQuest_ElementRoot::M_bStartOnExit' has a wrong offset!");
static_assert(offsetof(UBFGQuest_ElementRoot, M_bStartOnInteract) == 0x000462, "Member 'UBFGQuest_ElementRoot::M_bStartOnInteract' has a wrong offset!");
static_assert(offsetof(UBFGQuest_ElementRoot, M_aIntroLevels) == 0x000468, "Member 'UBFGQuest_ElementRoot::M_aIntroLevels' has a wrong offset!");
static_assert(offsetof(UBFGQuest_ElementRoot, M_bIntroLevelsRemainActive) == 0x000478, "Member 'UBFGQuest_ElementRoot::M_bIntroLevelsRemainActive' has a wrong offset!");
static_assert(offsetof(UBFGQuest_ElementRoot, M_aBodyLevels) == 0x000480, "Member 'UBFGQuest_ElementRoot::M_aBodyLevels' has a wrong offset!");
static_assert(offsetof(UBFGQuest_ElementRoot, M_bBodyLevelsRemainActive) == 0x000490, "Member 'UBFGQuest_ElementRoot::M_bBodyLevelsRemainActive' has a wrong offset!");
static_assert(offsetof(UBFGQuest_ElementRoot, M_pIntroTracker) == 0x000498, "Member 'UBFGQuest_ElementRoot::M_pIntroTracker' has a wrong offset!");
static_assert(offsetof(UBFGQuest_ElementRoot, M_pBodyTracker) == 0x0004A0, "Member 'UBFGQuest_ElementRoot::M_pBodyTracker' has a wrong offset!");

// Class BFGCore.BFGInputAction_MentalAbility
// 0x0018 (0x0048 - 0x0030)
class UBFGInputAction_MentalAbility : public UBFGInputAction
{
public:
	TArray<TSubclassOf<class UBFGMentalAbilityBase>> M_apMentalAbilityClasses;                          // 0x0030(0x0010)(Edit, ZeroConstructor, Protected, UObjectWrapper, NativeAccessSpecifierProtected)
	TSubclassOf<class UBFGMentalAbilityBase>      M_pActivatedMentalAbility;                         // 0x0040(0x0008)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"BFGInputAction_MentalAbility">();
	}
	static class UBFGInputAction_MentalAbility* GetDefaultObj()
	{
		return GetDefaultObjImpl<UBFGInputAction_MentalAbility>();
	}
};
static_assert(alignof(UBFGInputAction_MentalAbility) == 0x000008, "Wrong alignment on UBFGInputAction_MentalAbility");
static_assert(sizeof(UBFGInputAction_MentalAbility) == 0x000048, "Wrong size on UBFGInputAction_MentalAbility");
static_assert(offsetof(UBFGInputAction_MentalAbility, M_apMentalAbilityClasses) == 0x000030, "Member 'UBFGInputAction_MentalAbility::M_apMentalAbilityClasses' has a wrong offset!");
static_assert(offsetof(UBFGInputAction_MentalAbility, M_pActivatedMentalAbility) == 0x000040, "Member 'UBFGInputAction_MentalAbility::M_pActivatedMentalAbility' has a wrong offset!");

// Class BFGCore.BFGCustomDataVariable
// 0x0018 (0x0040 - 0x0028)
class UBFGCustomDataVariable final : public UObject
{
public:
	uint8                                         Pad_28[0x10];                                      // 0x0028(0x0010)(Fixing Size After Last Property [ Dumper-7 ])
	class UBFGVariableMirror*                     M_pVarMirror;                                      // 0x0038(0x0008)(ExportObject, ZeroConstructor, Transient, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)

public:
	void SetDataValue(float _fValue);

	float GetDataValue() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"BFGCustomDataVariable">();
	}
	static class UBFGCustomDataVariable* GetDefaultObj()
	{
		return GetDefaultObjImpl<UBFGCustomDataVariable>();
	}
};
static_assert(alignof(UBFGCustomDataVariable) == 0x000008, "Wrong alignment on UBFGCustomDataVariable");
static_assert(sizeof(UBFGCustomDataVariable) == 0x000040, "Wrong size on UBFGCustomDataVariable");
static_assert(offsetof(UBFGCustomDataVariable, M_pVarMirror) == 0x000038, "Member 'UBFGCustomDataVariable::M_pVarMirror' has a wrong offset!");

// Class BFGCore.BFGDamageModifierCache_Entry
// 0x0050 (0x0078 - 0x0028)
class UBFGDamageModifierCache_Entry final : public UObject
{
public:
	TMap<uint32, float>                           M_aModifersByArmorType;                            // 0x0028(0x0050)(ZeroConstructor, Transient, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"BFGDamageModifierCache_Entry">();
	}
	static class UBFGDamageModifierCache_Entry* GetDefaultObj()
	{
		return GetDefaultObjImpl<UBFGDamageModifierCache_Entry>();
	}
};
static_assert(alignof(UBFGDamageModifierCache_Entry) == 0x000008, "Wrong alignment on UBFGDamageModifierCache_Entry");
static_assert(sizeof(UBFGDamageModifierCache_Entry) == 0x000078, "Wrong size on UBFGDamageModifierCache_Entry");
static_assert(offsetof(UBFGDamageModifierCache_Entry, M_aModifersByArmorType) == 0x000028, "Member 'UBFGDamageModifierCache_Entry::M_aModifersByArmorType' has a wrong offset!");

// Class BFGCore.BFGQuest_ProximityMonitorManager
// 0x0030 (0x0058 - 0x0028)
class UBFGQuest_ProximityMonitorManager final : public UObject
{
public:
	class ABFGGameState*                          M_pGameState;                                      // 0x0028(0x0008)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_30[0x10];                                      // 0x0030(0x0010)(Fixing Size After Last Property [ Dumper-7 ])
	class UBFGWidget_HUD_ProximityMonitors*       M_pHudWidget;                                      // 0x0040(0x0008)(ExportObject, ZeroConstructor, Transient, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_48[0x10];                                      // 0x0048(0x0010)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"BFGQuest_ProximityMonitorManager">();
	}
	static class UBFGQuest_ProximityMonitorManager* GetDefaultObj()
	{
		return GetDefaultObjImpl<UBFGQuest_ProximityMonitorManager>();
	}
};
static_assert(alignof(UBFGQuest_ProximityMonitorManager) == 0x000008, "Wrong alignment on UBFGQuest_ProximityMonitorManager");
static_assert(sizeof(UBFGQuest_ProximityMonitorManager) == 0x000058, "Wrong size on UBFGQuest_ProximityMonitorManager");
static_assert(offsetof(UBFGQuest_ProximityMonitorManager, M_pGameState) == 0x000028, "Member 'UBFGQuest_ProximityMonitorManager::M_pGameState' has a wrong offset!");
static_assert(offsetof(UBFGQuest_ProximityMonitorManager, M_pHudWidget) == 0x000040, "Member 'UBFGQuest_ProximityMonitorManager::M_pHudWidget' has a wrong offset!");

// Class BFGCore.BFGInputAction_PlayerControllerCheatMenu
// 0x0000 (0x0030 - 0x0030)
class UBFGInputAction_PlayerControllerCheatMenu final : public UBFGInputAction
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"BFGInputAction_PlayerControllerCheatMenu">();
	}
	static class UBFGInputAction_PlayerControllerCheatMenu* GetDefaultObj()
	{
		return GetDefaultObjImpl<UBFGInputAction_PlayerControllerCheatMenu>();
	}
};
static_assert(alignof(UBFGInputAction_PlayerControllerCheatMenu) == 0x000008, "Wrong alignment on UBFGInputAction_PlayerControllerCheatMenu");
static_assert(sizeof(UBFGInputAction_PlayerControllerCheatMenu) == 0x000030, "Wrong size on UBFGInputAction_PlayerControllerCheatMenu");

// Class BFGCore.BFGDataAsset_BossData_Roboprez
// 0x0020 (0x0078 - 0x0058)
class UBFGDataAsset_BossData_Roboprez final : public UBFGDataAsset_BossData
{
public:
	class UDataTable*                             M_oMetaPattern_CryptoCloseToSaucer;                // 0x0058(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         M_fTransitionBufferDuration;                       // 0x0060(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         M_fWeakSpotDamageMultiplier;                       // 0x0064(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TArray<TSubclassOf<class UDamageType>>        M_aDamageTypesThatCauseFlinch;                     // 0x0068(0x0010)(Edit, ZeroConstructor, Protected, UObjectWrapper, NativeAccessSpecifierProtected)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"BFGDataAsset_BossData_Roboprez">();
	}
	static class UBFGDataAsset_BossData_Roboprez* GetDefaultObj()
	{
		return GetDefaultObjImpl<UBFGDataAsset_BossData_Roboprez>();
	}
};
static_assert(alignof(UBFGDataAsset_BossData_Roboprez) == 0x000008, "Wrong alignment on UBFGDataAsset_BossData_Roboprez");
static_assert(sizeof(UBFGDataAsset_BossData_Roboprez) == 0x000078, "Wrong size on UBFGDataAsset_BossData_Roboprez");
static_assert(offsetof(UBFGDataAsset_BossData_Roboprez, M_oMetaPattern_CryptoCloseToSaucer) == 0x000058, "Member 'UBFGDataAsset_BossData_Roboprez::M_oMetaPattern_CryptoCloseToSaucer' has a wrong offset!");
static_assert(offsetof(UBFGDataAsset_BossData_Roboprez, M_fTransitionBufferDuration) == 0x000060, "Member 'UBFGDataAsset_BossData_Roboprez::M_fTransitionBufferDuration' has a wrong offset!");
static_assert(offsetof(UBFGDataAsset_BossData_Roboprez, M_fWeakSpotDamageMultiplier) == 0x000064, "Member 'UBFGDataAsset_BossData_Roboprez::M_fWeakSpotDamageMultiplier' has a wrong offset!");
static_assert(offsetof(UBFGDataAsset_BossData_Roboprez, M_aDamageTypesThatCauseFlinch) == 0x000068, "Member 'UBFGDataAsset_BossData_Roboprez::M_aDamageTypesThatCauseFlinch' has a wrong offset!");

// Class BFGCore.BFGDataAsset_BossPhase_Roboprez
// 0x0030 (0x00B8 - 0x0088)
class UBFGDataAsset_BossPhase_Roboprez final : public UBFGDataAsset_BossPhase
{
public:
	class UDataTable*                             M_oMetaPattern_TooFar;                             // 0x0088(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UDataTable*                             M_oMetaPattern_RearQuadrant;                       // 0x0090(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UDataTable*                             M_oMetaPattern_TooClose;                           // 0x0098(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UDataTable*                             M_oMetaPattern_OutOfBeam;                          // 0x00A0(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class ABFGBoss_TransitionPath*                M_pTransitionPath;                                 // 0x00A8(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         M_fTransitionAirMinePatternDelay;                  // 0x00B0(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_B4[0x4];                                       // 0x00B4(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"BFGDataAsset_BossPhase_Roboprez">();
	}
	static class UBFGDataAsset_BossPhase_Roboprez* GetDefaultObj()
	{
		return GetDefaultObjImpl<UBFGDataAsset_BossPhase_Roboprez>();
	}
};
static_assert(alignof(UBFGDataAsset_BossPhase_Roboprez) == 0x000008, "Wrong alignment on UBFGDataAsset_BossPhase_Roboprez");
static_assert(sizeof(UBFGDataAsset_BossPhase_Roboprez) == 0x0000B8, "Wrong size on UBFGDataAsset_BossPhase_Roboprez");
static_assert(offsetof(UBFGDataAsset_BossPhase_Roboprez, M_oMetaPattern_TooFar) == 0x000088, "Member 'UBFGDataAsset_BossPhase_Roboprez::M_oMetaPattern_TooFar' has a wrong offset!");
static_assert(offsetof(UBFGDataAsset_BossPhase_Roboprez, M_oMetaPattern_RearQuadrant) == 0x000090, "Member 'UBFGDataAsset_BossPhase_Roboprez::M_oMetaPattern_RearQuadrant' has a wrong offset!");
static_assert(offsetof(UBFGDataAsset_BossPhase_Roboprez, M_oMetaPattern_TooClose) == 0x000098, "Member 'UBFGDataAsset_BossPhase_Roboprez::M_oMetaPattern_TooClose' has a wrong offset!");
static_assert(offsetof(UBFGDataAsset_BossPhase_Roboprez, M_oMetaPattern_OutOfBeam) == 0x0000A0, "Member 'UBFGDataAsset_BossPhase_Roboprez::M_oMetaPattern_OutOfBeam' has a wrong offset!");
static_assert(offsetof(UBFGDataAsset_BossPhase_Roboprez, M_pTransitionPath) == 0x0000A8, "Member 'UBFGDataAsset_BossPhase_Roboprez::M_pTransitionPath' has a wrong offset!");
static_assert(offsetof(UBFGDataAsset_BossPhase_Roboprez, M_fTransitionAirMinePatternDelay) == 0x0000B0, "Member 'UBFGDataAsset_BossPhase_Roboprez::M_fTransitionAirMinePatternDelay' has a wrong offset!");

// Class BFGCore.BFGInputAxis_PawnLookUpAtRate
// 0x0008 (0x0030 - 0x0028)
class UBFGInputAxis_PawnLookUpAtRate final : public UBFGInputAxis
{
public:
	float                                         M_fLookUpRate;                                     // 0x0028(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_2C[0x4];                                       // 0x002C(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"BFGInputAxis_PawnLookUpAtRate">();
	}
	static class UBFGInputAxis_PawnLookUpAtRate* GetDefaultObj()
	{
		return GetDefaultObjImpl<UBFGInputAxis_PawnLookUpAtRate>();
	}
};
static_assert(alignof(UBFGInputAxis_PawnLookUpAtRate) == 0x000008, "Wrong alignment on UBFGInputAxis_PawnLookUpAtRate");
static_assert(sizeof(UBFGInputAxis_PawnLookUpAtRate) == 0x000030, "Wrong size on UBFGInputAxis_PawnLookUpAtRate");
static_assert(offsetof(UBFGInputAxis_PawnLookUpAtRate, M_fLookUpRate) == 0x000028, "Member 'UBFGInputAxis_PawnLookUpAtRate::M_fLookUpRate' has a wrong offset!");

// Class BFGCore.BFGDataAsset_ChallengeInfo
// 0x00D0 (0x0100 - 0x0030)
class UBFGDataAsset_ChallengeInfo final : public UDataAsset
{
public:
	EBFGChallengeType                             M_eType;                                           // 0x0030(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_31[0x7];                                       // 0x0031(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	class FText                                   M_strTitle;                                        // 0x0038(0x0018)(Edit, BlueprintVisible, BlueprintReadOnly, DisableEditOnInstance, NativeAccessSpecifierPublic)
	class FText                                   M_strBriefing;                                     // 0x0050(0x0018)(Edit, BlueprintVisible, BlueprintReadOnly, DisableEditOnInstance, NativeAccessSpecifierPublic)
	class FText                                   M_strObjective;                                    // 0x0068(0x0018)(Edit, BlueprintVisible, BlueprintReadOnly, DisableEditOnInstance, NativeAccessSpecifierPublic)
	struct FTimespan                              M_timeLimit;                                       // 0x0080(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TArray<struct FBFGDataAsset_ChallengeInfo_Objective> M_aConstraints;                                    // 0x0088(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, NativeAccessSpecifierPublic)
	int32                                         M_iReward;                                         // 0x0098(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EBFGDataAsset_ChallengeFailureMethod          M_failureMethod;                                   // 0x009C(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_9D[0x3];                                       // 0x009D(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<class FText>                           M_aEndVOs_NoStar;                                  // 0x00A0(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, NativeAccessSpecifierPublic)
	struct FBFGDataAsset_ChallengeInfo_StarDetails M_Star1;                                           // 0x00B0(0x0018)(Edit, BlueprintVisible, BlueprintReadOnly, DisableEditOnInstance, NativeAccessSpecifierPublic)
	struct FBFGDataAsset_ChallengeInfo_StarDetails M_Star2;                                           // 0x00C8(0x0018)(Edit, BlueprintVisible, BlueprintReadOnly, DisableEditOnInstance, NativeAccessSpecifierPublic)
	struct FBFGDataAsset_ChallengeInfo_StarDetails M_Star3;                                           // 0x00E0(0x0018)(Edit, BlueprintVisible, BlueprintReadOnly, DisableEditOnInstance, NativeAccessSpecifierPublic)
	class UBFGQuest*                              M_pQuest;                                          // 0x00F8(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)

public:
	float GetCurrentHighscore();

	int32 GetMinimumValue() const;
	int32 GetStarValue(float _fScore) const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"BFGDataAsset_ChallengeInfo">();
	}
	static class UBFGDataAsset_ChallengeInfo* GetDefaultObj()
	{
		return GetDefaultObjImpl<UBFGDataAsset_ChallengeInfo>();
	}
};
static_assert(alignof(UBFGDataAsset_ChallengeInfo) == 0x000008, "Wrong alignment on UBFGDataAsset_ChallengeInfo");
static_assert(sizeof(UBFGDataAsset_ChallengeInfo) == 0x000100, "Wrong size on UBFGDataAsset_ChallengeInfo");
static_assert(offsetof(UBFGDataAsset_ChallengeInfo, M_eType) == 0x000030, "Member 'UBFGDataAsset_ChallengeInfo::M_eType' has a wrong offset!");
static_assert(offsetof(UBFGDataAsset_ChallengeInfo, M_strTitle) == 0x000038, "Member 'UBFGDataAsset_ChallengeInfo::M_strTitle' has a wrong offset!");
static_assert(offsetof(UBFGDataAsset_ChallengeInfo, M_strBriefing) == 0x000050, "Member 'UBFGDataAsset_ChallengeInfo::M_strBriefing' has a wrong offset!");
static_assert(offsetof(UBFGDataAsset_ChallengeInfo, M_strObjective) == 0x000068, "Member 'UBFGDataAsset_ChallengeInfo::M_strObjective' has a wrong offset!");
static_assert(offsetof(UBFGDataAsset_ChallengeInfo, M_timeLimit) == 0x000080, "Member 'UBFGDataAsset_ChallengeInfo::M_timeLimit' has a wrong offset!");
static_assert(offsetof(UBFGDataAsset_ChallengeInfo, M_aConstraints) == 0x000088, "Member 'UBFGDataAsset_ChallengeInfo::M_aConstraints' has a wrong offset!");
static_assert(offsetof(UBFGDataAsset_ChallengeInfo, M_iReward) == 0x000098, "Member 'UBFGDataAsset_ChallengeInfo::M_iReward' has a wrong offset!");
static_assert(offsetof(UBFGDataAsset_ChallengeInfo, M_failureMethod) == 0x00009C, "Member 'UBFGDataAsset_ChallengeInfo::M_failureMethod' has a wrong offset!");
static_assert(offsetof(UBFGDataAsset_ChallengeInfo, M_aEndVOs_NoStar) == 0x0000A0, "Member 'UBFGDataAsset_ChallengeInfo::M_aEndVOs_NoStar' has a wrong offset!");
static_assert(offsetof(UBFGDataAsset_ChallengeInfo, M_Star1) == 0x0000B0, "Member 'UBFGDataAsset_ChallengeInfo::M_Star1' has a wrong offset!");
static_assert(offsetof(UBFGDataAsset_ChallengeInfo, M_Star2) == 0x0000C8, "Member 'UBFGDataAsset_ChallengeInfo::M_Star2' has a wrong offset!");
static_assert(offsetof(UBFGDataAsset_ChallengeInfo, M_Star3) == 0x0000E0, "Member 'UBFGDataAsset_ChallengeInfo::M_Star3' has a wrong offset!");
static_assert(offsetof(UBFGDataAsset_ChallengeInfo, M_pQuest) == 0x0000F8, "Member 'UBFGDataAsset_ChallengeInfo::M_pQuest' has a wrong offset!");

// Class BFGCore.BFGQuestGraph
// 0x0010 (0x00A8 - 0x0098)
class UBFGQuestGraph final : public UGenericGraph
{
public:
	struct FGuid                                  M_guid;                                            // 0x0098(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"BFGQuestGraph">();
	}
	static class UBFGQuestGraph* GetDefaultObj()
	{
		return GetDefaultObjImpl<UBFGQuestGraph>();
	}
};
static_assert(alignof(UBFGQuestGraph) == 0x000008, "Wrong alignment on UBFGQuestGraph");
static_assert(sizeof(UBFGQuestGraph) == 0x0000A8, "Wrong size on UBFGQuestGraph");
static_assert(offsetof(UBFGQuestGraph, M_guid) == 0x000098, "Member 'UBFGQuestGraph::M_guid' has a wrong offset!");

// Class BFGCore.BFGInputAction_PlayerTutorialExpand
// 0x0000 (0x0030 - 0x0030)
class UBFGInputAction_PlayerTutorialExpand final : public UBFGInputAction
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"BFGInputAction_PlayerTutorialExpand">();
	}
	static class UBFGInputAction_PlayerTutorialExpand* GetDefaultObj()
	{
		return GetDefaultObjImpl<UBFGInputAction_PlayerTutorialExpand>();
	}
};
static_assert(alignof(UBFGInputAction_PlayerTutorialExpand) == 0x000008, "Wrong alignment on UBFGInputAction_PlayerTutorialExpand");
static_assert(sizeof(UBFGInputAction_PlayerTutorialExpand) == 0x000030, "Wrong size on UBFGInputAction_PlayerTutorialExpand");

// Class BFGCore.BFGDataAsset_DashParams
// 0x0050 (0x0080 - 0x0030)
class UBFGDataAsset_DashParams final : public UDataAsset
{
public:
	TArray<struct FDashPhaseParameters>           M_aDashPhases;                                     // 0x0030(0x0010)(Edit, ZeroConstructor, NativeAccessSpecifierPublic)
	float                                         M_fDashInterpSpeed;                                // 0x0040(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         M_iAirDashCount;                                   // 0x0044(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         M_fDashCooldown;                                   // 0x0048(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FBFGPlayerCharacterMovementSettings    M_oDashMovementSettings;                           // 0x004C(0x001C)(Edit, NoDestructor, NativeAccessSpecifierPublic)
	class UCurveFloat*                            M_pArmOriginSpeedCurve;                            // 0x0068(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         M_fFuelConsumption;                                // 0x0070(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FGameplayTag                           M_oDashUnlockTag;                                  // 0x0074(0x0008)(Edit, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_7C[0x4];                                       // 0x007C(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"BFGDataAsset_DashParams">();
	}
	static class UBFGDataAsset_DashParams* GetDefaultObj()
	{
		return GetDefaultObjImpl<UBFGDataAsset_DashParams>();
	}
};
static_assert(alignof(UBFGDataAsset_DashParams) == 0x000008, "Wrong alignment on UBFGDataAsset_DashParams");
static_assert(sizeof(UBFGDataAsset_DashParams) == 0x000080, "Wrong size on UBFGDataAsset_DashParams");
static_assert(offsetof(UBFGDataAsset_DashParams, M_aDashPhases) == 0x000030, "Member 'UBFGDataAsset_DashParams::M_aDashPhases' has a wrong offset!");
static_assert(offsetof(UBFGDataAsset_DashParams, M_fDashInterpSpeed) == 0x000040, "Member 'UBFGDataAsset_DashParams::M_fDashInterpSpeed' has a wrong offset!");
static_assert(offsetof(UBFGDataAsset_DashParams, M_iAirDashCount) == 0x000044, "Member 'UBFGDataAsset_DashParams::M_iAirDashCount' has a wrong offset!");
static_assert(offsetof(UBFGDataAsset_DashParams, M_fDashCooldown) == 0x000048, "Member 'UBFGDataAsset_DashParams::M_fDashCooldown' has a wrong offset!");
static_assert(offsetof(UBFGDataAsset_DashParams, M_oDashMovementSettings) == 0x00004C, "Member 'UBFGDataAsset_DashParams::M_oDashMovementSettings' has a wrong offset!");
static_assert(offsetof(UBFGDataAsset_DashParams, M_pArmOriginSpeedCurve) == 0x000068, "Member 'UBFGDataAsset_DashParams::M_pArmOriginSpeedCurve' has a wrong offset!");
static_assert(offsetof(UBFGDataAsset_DashParams, M_fFuelConsumption) == 0x000070, "Member 'UBFGDataAsset_DashParams::M_fFuelConsumption' has a wrong offset!");
static_assert(offsetof(UBFGDataAsset_DashParams, M_oDashUnlockTag) == 0x000074, "Member 'UBFGDataAsset_DashParams::M_oDashUnlockTag' has a wrong offset!");

// Class BFGCore.BFGDataAsset_PausedTutorial
// 0x0030 (0x0060 - 0x0030)
class UBFGDataAsset_PausedTutorial final : public UDataAsset
{
public:
	class FText                                   M_strTitle;                                        // 0x0030(0x0018)(Edit, BlueprintVisible, BlueprintReadOnly, DisableEditOnInstance, NativeAccessSpecifierPublic)
	TArray<struct FBFGDataPausedTutorialStep>     M_aoSteps;                                         // 0x0048(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, NativeAccessSpecifierPublic)
	class FName                                   M_oUnlockName;                                     // 0x0058(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"BFGDataAsset_PausedTutorial">();
	}
	static class UBFGDataAsset_PausedTutorial* GetDefaultObj()
	{
		return GetDefaultObjImpl<UBFGDataAsset_PausedTutorial>();
	}
};
static_assert(alignof(UBFGDataAsset_PausedTutorial) == 0x000008, "Wrong alignment on UBFGDataAsset_PausedTutorial");
static_assert(sizeof(UBFGDataAsset_PausedTutorial) == 0x000060, "Wrong size on UBFGDataAsset_PausedTutorial");
static_assert(offsetof(UBFGDataAsset_PausedTutorial, M_strTitle) == 0x000030, "Member 'UBFGDataAsset_PausedTutorial::M_strTitle' has a wrong offset!");
static_assert(offsetof(UBFGDataAsset_PausedTutorial, M_aoSteps) == 0x000048, "Member 'UBFGDataAsset_PausedTutorial::M_aoSteps' has a wrong offset!");
static_assert(offsetof(UBFGDataAsset_PausedTutorial, M_oUnlockName) == 0x000058, "Member 'UBFGDataAsset_PausedTutorial::M_oUnlockName' has a wrong offset!");

// Class BFGCore.BFGDataAsset_RadarObjectStaticInfo
// 0x0128 (0x0158 - 0x0030)
class UBFGDataAsset_RadarObjectStaticInfo final : public UDataAsset
{
public:
	int32                                         M_iDrawOrder;                                      // 0x0030(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          M_bPolygon_InRange;                                // 0x0034(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_35[0x3];                                       // 0x0035(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	struct FSlateBrush                            M_brush;                                           // 0x0038(0x0088)(Edit, BlueprintVisible, BlueprintReadOnly, NativeAccessSpecifierPublic)
	struct FSlateBrush                            M_brushOffRange;                                   // 0x00C0(0x0088)(Edit, BlueprintVisible, BlueprintReadOnly, NativeAccessSpecifierPublic)
	bool                                          M_bClipObjectsOffRange;                            // 0x0148(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          M_bRotateObjects;                                  // 0x0149(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          M_bRotateObjectsOffRange;                          // 0x014A(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          M_bShowOnlyClosestObject;                          // 0x014B(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          M_bHideForCrypto;                                  // 0x014C(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          M_bHideForSaucer;                                  // 0x014D(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_14E[0x2];                                      // 0x014E(0x0002)(Fixing Size After Last Property [ Dumper-7 ])
	class UMaterialInterface*                     PolygonMaterial;                                   // 0x0150(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"BFGDataAsset_RadarObjectStaticInfo">();
	}
	static class UBFGDataAsset_RadarObjectStaticInfo* GetDefaultObj()
	{
		return GetDefaultObjImpl<UBFGDataAsset_RadarObjectStaticInfo>();
	}
};
static_assert(alignof(UBFGDataAsset_RadarObjectStaticInfo) == 0x000008, "Wrong alignment on UBFGDataAsset_RadarObjectStaticInfo");
static_assert(sizeof(UBFGDataAsset_RadarObjectStaticInfo) == 0x000158, "Wrong size on UBFGDataAsset_RadarObjectStaticInfo");
static_assert(offsetof(UBFGDataAsset_RadarObjectStaticInfo, M_iDrawOrder) == 0x000030, "Member 'UBFGDataAsset_RadarObjectStaticInfo::M_iDrawOrder' has a wrong offset!");
static_assert(offsetof(UBFGDataAsset_RadarObjectStaticInfo, M_bPolygon_InRange) == 0x000034, "Member 'UBFGDataAsset_RadarObjectStaticInfo::M_bPolygon_InRange' has a wrong offset!");
static_assert(offsetof(UBFGDataAsset_RadarObjectStaticInfo, M_brush) == 0x000038, "Member 'UBFGDataAsset_RadarObjectStaticInfo::M_brush' has a wrong offset!");
static_assert(offsetof(UBFGDataAsset_RadarObjectStaticInfo, M_brushOffRange) == 0x0000C0, "Member 'UBFGDataAsset_RadarObjectStaticInfo::M_brushOffRange' has a wrong offset!");
static_assert(offsetof(UBFGDataAsset_RadarObjectStaticInfo, M_bClipObjectsOffRange) == 0x000148, "Member 'UBFGDataAsset_RadarObjectStaticInfo::M_bClipObjectsOffRange' has a wrong offset!");
static_assert(offsetof(UBFGDataAsset_RadarObjectStaticInfo, M_bRotateObjects) == 0x000149, "Member 'UBFGDataAsset_RadarObjectStaticInfo::M_bRotateObjects' has a wrong offset!");
static_assert(offsetof(UBFGDataAsset_RadarObjectStaticInfo, M_bRotateObjectsOffRange) == 0x00014A, "Member 'UBFGDataAsset_RadarObjectStaticInfo::M_bRotateObjectsOffRange' has a wrong offset!");
static_assert(offsetof(UBFGDataAsset_RadarObjectStaticInfo, M_bShowOnlyClosestObject) == 0x00014B, "Member 'UBFGDataAsset_RadarObjectStaticInfo::M_bShowOnlyClosestObject' has a wrong offset!");
static_assert(offsetof(UBFGDataAsset_RadarObjectStaticInfo, M_bHideForCrypto) == 0x00014C, "Member 'UBFGDataAsset_RadarObjectStaticInfo::M_bHideForCrypto' has a wrong offset!");
static_assert(offsetof(UBFGDataAsset_RadarObjectStaticInfo, M_bHideForSaucer) == 0x00014D, "Member 'UBFGDataAsset_RadarObjectStaticInfo::M_bHideForSaucer' has a wrong offset!");
static_assert(offsetof(UBFGDataAsset_RadarObjectStaticInfo, PolygonMaterial) == 0x000150, "Member 'UBFGDataAsset_RadarObjectStaticInfo::PolygonMaterial' has a wrong offset!");

// Class BFGCore.BFGMissionConsequence
// 0x0040 (0x0068 - 0x0028)
class UBFGMissionConsequence : public UObject
{
public:
	class FName                                   M_strDevName;                                      // 0x0028(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         M_fDuration;                                       // 0x0030(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          M_bContextSenstive;                                // 0x0034(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_35[0x3];                                       // 0x0035(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	class UBFGMissionConsequence*                 M_pSourceTemplate;                                 // 0x0038(0x0008)(ExportObject, ZeroConstructor, Transient, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class ABFGGameState*                          M_pGameState;                                      // 0x0040(0x0008)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UObject*                                M_pOwner;                                          // 0x0048(0x0008)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	struct FBFGMissionConsequence_Context         M_context;                                         // 0x0050(0x0010)(Transient, NoDestructor, Protected, NativeAccessSpecifierProtected)
	uint8                                         Pad_60[0x8];                                       // 0x0060(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	const struct FBFGMissionConsequence_Context GetContext() const;
	const class FName GetDevName() const;
	float GetDuration() const;
	class ABFGGameState* GetGameState() const;
	class UObject* GetOwner(TSubclassOf<class UObject> _pClass) const;
	float GetTimeActive() const;
	bool IsExpired() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"BFGMissionConsequence">();
	}
	static class UBFGMissionConsequence* GetDefaultObj()
	{
		return GetDefaultObjImpl<UBFGMissionConsequence>();
	}
};
static_assert(alignof(UBFGMissionConsequence) == 0x000008, "Wrong alignment on UBFGMissionConsequence");
static_assert(sizeof(UBFGMissionConsequence) == 0x000068, "Wrong size on UBFGMissionConsequence");
static_assert(offsetof(UBFGMissionConsequence, M_strDevName) == 0x000028, "Member 'UBFGMissionConsequence::M_strDevName' has a wrong offset!");
static_assert(offsetof(UBFGMissionConsequence, M_fDuration) == 0x000030, "Member 'UBFGMissionConsequence::M_fDuration' has a wrong offset!");
static_assert(offsetof(UBFGMissionConsequence, M_bContextSenstive) == 0x000034, "Member 'UBFGMissionConsequence::M_bContextSenstive' has a wrong offset!");
static_assert(offsetof(UBFGMissionConsequence, M_pSourceTemplate) == 0x000038, "Member 'UBFGMissionConsequence::M_pSourceTemplate' has a wrong offset!");
static_assert(offsetof(UBFGMissionConsequence, M_pGameState) == 0x000040, "Member 'UBFGMissionConsequence::M_pGameState' has a wrong offset!");
static_assert(offsetof(UBFGMissionConsequence, M_pOwner) == 0x000048, "Member 'UBFGMissionConsequence::M_pOwner' has a wrong offset!");
static_assert(offsetof(UBFGMissionConsequence, M_context) == 0x000050, "Member 'UBFGMissionConsequence::M_context' has a wrong offset!");

// Class BFGCore.BFGDataAsset_StaticMeshBurning
// 0x0018 (0x0048 - 0x0030)
class UBFGDataAsset_StaticMeshBurning final : public UDataAsset
{
public:
	class UParticleSystem*                        M_pPFX;                                            // 0x0030(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TArray<struct FBFGBuildingMaterialVariation>  M_aMaterialVariation;                              // 0x0038(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, NativeAccessSpecifierPublic)

public:
	bool IsValid() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"BFGDataAsset_StaticMeshBurning">();
	}
	static class UBFGDataAsset_StaticMeshBurning* GetDefaultObj()
	{
		return GetDefaultObjImpl<UBFGDataAsset_StaticMeshBurning>();
	}
};
static_assert(alignof(UBFGDataAsset_StaticMeshBurning) == 0x000008, "Wrong alignment on UBFGDataAsset_StaticMeshBurning");
static_assert(sizeof(UBFGDataAsset_StaticMeshBurning) == 0x000048, "Wrong size on UBFGDataAsset_StaticMeshBurning");
static_assert(offsetof(UBFGDataAsset_StaticMeshBurning, M_pPFX) == 0x000030, "Member 'UBFGDataAsset_StaticMeshBurning::M_pPFX' has a wrong offset!");
static_assert(offsetof(UBFGDataAsset_StaticMeshBurning, M_aMaterialVariation) == 0x000038, "Member 'UBFGDataAsset_StaticMeshBurning::M_aMaterialVariation' has a wrong offset!");

// Class BFGCore.BFGMentalAbility_Hypnotize_Follow
// 0x0000 (0x0200 - 0x0200)
class UBFGMentalAbility_Hypnotize_Follow : public UBFGMentalAbility_Hypnotize
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"BFGMentalAbility_Hypnotize_Follow">();
	}
	static class UBFGMentalAbility_Hypnotize_Follow* GetDefaultObj()
	{
		return GetDefaultObjImpl<UBFGMentalAbility_Hypnotize_Follow>();
	}
};
static_assert(alignof(UBFGMentalAbility_Hypnotize_Follow) == 0x000008, "Wrong alignment on UBFGMentalAbility_Hypnotize_Follow");
static_assert(sizeof(UBFGMentalAbility_Hypnotize_Follow) == 0x000200, "Wrong size on UBFGMentalAbility_Hypnotize_Follow");

// Class BFGCore.BFGDataAsset_TutorialChapter
// 0x0020 (0x0050 - 0x0030)
class UBFGDataAsset_TutorialChapter final : public UDataAsset
{
public:
	class FText                                   M_chapterTitle;                                    // 0x0030(0x0018)(Edit, BlueprintVisible, BlueprintReadOnly, NativeAccessSpecifierPublic)
	class UDataTable*                             M_pPagesTable;                                     // 0x0048(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"BFGDataAsset_TutorialChapter">();
	}
	static class UBFGDataAsset_TutorialChapter* GetDefaultObj()
	{
		return GetDefaultObjImpl<UBFGDataAsset_TutorialChapter>();
	}
};
static_assert(alignof(UBFGDataAsset_TutorialChapter) == 0x000008, "Wrong alignment on UBFGDataAsset_TutorialChapter");
static_assert(sizeof(UBFGDataAsset_TutorialChapter) == 0x000050, "Wrong size on UBFGDataAsset_TutorialChapter");
static_assert(offsetof(UBFGDataAsset_TutorialChapter, M_chapterTitle) == 0x000030, "Member 'UBFGDataAsset_TutorialChapter::M_chapterTitle' has a wrong offset!");
static_assert(offsetof(UBFGDataAsset_TutorialChapter, M_pPagesTable) == 0x000048, "Member 'UBFGDataAsset_TutorialChapter::M_pPagesTable' has a wrong offset!");

// Class BFGCore.BFGDataAsset_TutorialPage
// 0x0198 (0x01C8 - 0x0030)
class UBFGDataAsset_TutorialPage final : public UDataAsset
{
public:
	class FText                                   M_strTitle;                                        // 0x0030(0x0018)(Edit, BlueprintVisible, BlueprintReadOnly, NativeAccessSpecifierPublic)
	class FText                                   M_strTitleShort;                                   // 0x0048(0x0018)(Edit, BlueprintVisible, BlueprintReadOnly, NativeAccessSpecifierPublic)
	class FText                                   M_strDetails;                                      // 0x0060(0x0018)(Edit, BlueprintVisible, BlueprintReadOnly, NativeAccessSpecifierPublic)
	class FText                                   M_strQuote;                                        // 0x0078(0x0018)(Edit, BlueprintVisible, BlueprintReadOnly, NativeAccessSpecifierPublic)
	TArray<TSoftObjectPtr<class UTexture2D>>      M_apImageSlides;                                   // 0x0090(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, UObjectWrapper, NativeAccessSpecifierPublic)
	TSoftObjectPtr<class UMediaSource>            M_pMediaSource;                                    // 0x00A0(0x0028)(Edit, BlueprintVisible, BlueprintReadOnly, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FText                                   M_strDescription;                                  // 0x00C8(0x0018)(Edit, BlueprintVisible, BlueprintReadOnly, NativeAccessSpecifierPublic)
	class FText                                   M_strDescriptionShort;                             // 0x00E0(0x0018)(Edit, BlueprintVisible, BlueprintReadOnly, NativeAccessSpecifierPublic)
	struct FSlateBrush                            M_iconSprite;                                      // 0x00F8(0x0088)(Edit, BlueprintVisible, BlueprintReadOnly, NativeAccessSpecifierPublic)
	TArray<class UBFGDataAsset_TutorialInputAction*> M_aHintsGamepad;                                   // 0x0180(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, NativeAccessSpecifierPublic)
	TSoftClassPtr<class UClass>                   M_pCustomHintOverrideClass;                        // 0x0190(0x0028)(Edit, BlueprintVisible, BlueprintReadOnly, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          M_bSeparateHintsByArrows;                          // 0x01B8(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          M_bSupportsFuronhandbook;                          // 0x01B9(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          M_bSupportsDismiss;                                // 0x01BA(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          M_bShowIndicatorBeforeShow;                        // 0x01BB(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          M_bSupportsKeyboard;                               // 0x01BC(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1BD[0x3];                                      // 0x01BD(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	struct FGameplayTag                           M_oUnlockTag;                                      // 0x01C0(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"BFGDataAsset_TutorialPage">();
	}
	static class UBFGDataAsset_TutorialPage* GetDefaultObj()
	{
		return GetDefaultObjImpl<UBFGDataAsset_TutorialPage>();
	}
};
static_assert(alignof(UBFGDataAsset_TutorialPage) == 0x000008, "Wrong alignment on UBFGDataAsset_TutorialPage");
static_assert(sizeof(UBFGDataAsset_TutorialPage) == 0x0001C8, "Wrong size on UBFGDataAsset_TutorialPage");
static_assert(offsetof(UBFGDataAsset_TutorialPage, M_strTitle) == 0x000030, "Member 'UBFGDataAsset_TutorialPage::M_strTitle' has a wrong offset!");
static_assert(offsetof(UBFGDataAsset_TutorialPage, M_strTitleShort) == 0x000048, "Member 'UBFGDataAsset_TutorialPage::M_strTitleShort' has a wrong offset!");
static_assert(offsetof(UBFGDataAsset_TutorialPage, M_strDetails) == 0x000060, "Member 'UBFGDataAsset_TutorialPage::M_strDetails' has a wrong offset!");
static_assert(offsetof(UBFGDataAsset_TutorialPage, M_strQuote) == 0x000078, "Member 'UBFGDataAsset_TutorialPage::M_strQuote' has a wrong offset!");
static_assert(offsetof(UBFGDataAsset_TutorialPage, M_apImageSlides) == 0x000090, "Member 'UBFGDataAsset_TutorialPage::M_apImageSlides' has a wrong offset!");
static_assert(offsetof(UBFGDataAsset_TutorialPage, M_pMediaSource) == 0x0000A0, "Member 'UBFGDataAsset_TutorialPage::M_pMediaSource' has a wrong offset!");
static_assert(offsetof(UBFGDataAsset_TutorialPage, M_strDescription) == 0x0000C8, "Member 'UBFGDataAsset_TutorialPage::M_strDescription' has a wrong offset!");
static_assert(offsetof(UBFGDataAsset_TutorialPage, M_strDescriptionShort) == 0x0000E0, "Member 'UBFGDataAsset_TutorialPage::M_strDescriptionShort' has a wrong offset!");
static_assert(offsetof(UBFGDataAsset_TutorialPage, M_iconSprite) == 0x0000F8, "Member 'UBFGDataAsset_TutorialPage::M_iconSprite' has a wrong offset!");
static_assert(offsetof(UBFGDataAsset_TutorialPage, M_aHintsGamepad) == 0x000180, "Member 'UBFGDataAsset_TutorialPage::M_aHintsGamepad' has a wrong offset!");
static_assert(offsetof(UBFGDataAsset_TutorialPage, M_pCustomHintOverrideClass) == 0x000190, "Member 'UBFGDataAsset_TutorialPage::M_pCustomHintOverrideClass' has a wrong offset!");
static_assert(offsetof(UBFGDataAsset_TutorialPage, M_bSeparateHintsByArrows) == 0x0001B8, "Member 'UBFGDataAsset_TutorialPage::M_bSeparateHintsByArrows' has a wrong offset!");
static_assert(offsetof(UBFGDataAsset_TutorialPage, M_bSupportsFuronhandbook) == 0x0001B9, "Member 'UBFGDataAsset_TutorialPage::M_bSupportsFuronhandbook' has a wrong offset!");
static_assert(offsetof(UBFGDataAsset_TutorialPage, M_bSupportsDismiss) == 0x0001BA, "Member 'UBFGDataAsset_TutorialPage::M_bSupportsDismiss' has a wrong offset!");
static_assert(offsetof(UBFGDataAsset_TutorialPage, M_bShowIndicatorBeforeShow) == 0x0001BB, "Member 'UBFGDataAsset_TutorialPage::M_bShowIndicatorBeforeShow' has a wrong offset!");
static_assert(offsetof(UBFGDataAsset_TutorialPage, M_bSupportsKeyboard) == 0x0001BC, "Member 'UBFGDataAsset_TutorialPage::M_bSupportsKeyboard' has a wrong offset!");
static_assert(offsetof(UBFGDataAsset_TutorialPage, M_oUnlockTag) == 0x0001C0, "Member 'UBFGDataAsset_TutorialPage::M_oUnlockTag' has a wrong offset!");

// Class BFGCore.BFGDataAssetPoxLabUpgrade
// 0x0118 (0x0148 - 0x0030)
class UBFGDataAssetPoxLabUpgrade final : public UDataAsset
{
public:
	struct FGameplayTag                           M_oUpgradeTag;                                     // 0x0030(0x0008)(Edit, DisableEditOnInstance, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FGuid                                  M_guid;                                            // 0x0038(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	EBFGDataAssetPoxLabUpgradeType                M_eType;                                           // 0x0048(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_49[0x7];                                       // 0x0049(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	struct FGameplayTagContainer                  M_oGeneralTags;                                    // 0x0050(0x0020)(Edit, DisableEditOnInstance, Protected, NativeAccessSpecifierProtected)
	class FText                                   M_strWeaponName;                                   // 0x0070(0x0018)(Edit, DisableEditOnInstance, Protected, NativeAccessSpecifierProtected)
	class FText                                   M_strUpgradeName;                                  // 0x0088(0x0018)(Edit, BlueprintVisible, BlueprintReadOnly, DisableEditOnInstance, Protected, NativeAccessSpecifierProtected)
	struct FSlateBrush                            M_iconSprite;                                      // 0x00A0(0x0088)(Edit, BlueprintVisible, BlueprintReadOnly, DisableEditOnInstance, Protected, NativeAccessSpecifierProtected)
	class FText                                   M_strUpgradeDescription;                           // 0x0128(0x0018)(Edit, BlueprintVisible, BlueprintReadOnly, DisableEditOnInstance, Protected, NativeAccessSpecifierProtected)
	int32                                         M_iUpgradeCost;                                    // 0x0140(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_144[0x4];                                      // 0x0144(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"BFGDataAssetPoxLabUpgrade">();
	}
	static class UBFGDataAssetPoxLabUpgrade* GetDefaultObj()
	{
		return GetDefaultObjImpl<UBFGDataAssetPoxLabUpgrade>();
	}
};
static_assert(alignof(UBFGDataAssetPoxLabUpgrade) == 0x000008, "Wrong alignment on UBFGDataAssetPoxLabUpgrade");
static_assert(sizeof(UBFGDataAssetPoxLabUpgrade) == 0x000148, "Wrong size on UBFGDataAssetPoxLabUpgrade");
static_assert(offsetof(UBFGDataAssetPoxLabUpgrade, M_oUpgradeTag) == 0x000030, "Member 'UBFGDataAssetPoxLabUpgrade::M_oUpgradeTag' has a wrong offset!");
static_assert(offsetof(UBFGDataAssetPoxLabUpgrade, M_guid) == 0x000038, "Member 'UBFGDataAssetPoxLabUpgrade::M_guid' has a wrong offset!");
static_assert(offsetof(UBFGDataAssetPoxLabUpgrade, M_eType) == 0x000048, "Member 'UBFGDataAssetPoxLabUpgrade::M_eType' has a wrong offset!");
static_assert(offsetof(UBFGDataAssetPoxLabUpgrade, M_oGeneralTags) == 0x000050, "Member 'UBFGDataAssetPoxLabUpgrade::M_oGeneralTags' has a wrong offset!");
static_assert(offsetof(UBFGDataAssetPoxLabUpgrade, M_strWeaponName) == 0x000070, "Member 'UBFGDataAssetPoxLabUpgrade::M_strWeaponName' has a wrong offset!");
static_assert(offsetof(UBFGDataAssetPoxLabUpgrade, M_strUpgradeName) == 0x000088, "Member 'UBFGDataAssetPoxLabUpgrade::M_strUpgradeName' has a wrong offset!");
static_assert(offsetof(UBFGDataAssetPoxLabUpgrade, M_iconSprite) == 0x0000A0, "Member 'UBFGDataAssetPoxLabUpgrade::M_iconSprite' has a wrong offset!");
static_assert(offsetof(UBFGDataAssetPoxLabUpgrade, M_strUpgradeDescription) == 0x000128, "Member 'UBFGDataAssetPoxLabUpgrade::M_strUpgradeDescription' has a wrong offset!");
static_assert(offsetof(UBFGDataAssetPoxLabUpgrade, M_iUpgradeCost) == 0x000140, "Member 'UBFGDataAssetPoxLabUpgrade::M_iUpgradeCost' has a wrong offset!");

// Class BFGCore.BFGMissionLevelSwitcher
// 0x0028 (0x0400 - 0x03D8)
class ABFGMissionLevelSwitcher final : public AActor
{
public:
	TSoftObjectPtr<class UWorld>                  M_pSwitchToLevel;                                  // 0x03D8(0x0028)(Edit, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)

public:
	class FString GetLevelName() const;
	class FString GetLevelPath() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"BFGMissionLevelSwitcher">();
	}
	static class ABFGMissionLevelSwitcher* GetDefaultObj()
	{
		return GetDefaultObjImpl<ABFGMissionLevelSwitcher>();
	}
};
static_assert(alignof(ABFGMissionLevelSwitcher) == 0x000008, "Wrong alignment on ABFGMissionLevelSwitcher");
static_assert(sizeof(ABFGMissionLevelSwitcher) == 0x000400, "Wrong size on ABFGMissionLevelSwitcher");
static_assert(offsetof(ABFGMissionLevelSwitcher, M_pSwitchToLevel) == 0x0003D8, "Member 'ABFGMissionLevelSwitcher::M_pSwitchToLevel' has a wrong offset!");

// Class BFGCore.BFGDebugUtils
// 0x0000 (0x0028 - 0x0028)
class UBFGDebugUtils final : public UBlueprintFunctionLibrary
{
public:
	static void DebugBreak(bool bEnabled);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"BFGDebugUtils">();
	}
	static class UBFGDebugUtils* GetDefaultObj()
	{
		return GetDefaultObjImpl<UBFGDebugUtils>();
	}
};
static_assert(alignof(UBFGDebugUtils) == 0x000008, "Wrong alignment on UBFGDebugUtils");
static_assert(sizeof(UBFGDebugUtils) == 0x000028, "Wrong size on UBFGDebugUtils");

// Class BFGCore.BFGDecorator_AllowRelocate
// 0x0000 (0x0070 - 0x0070)
class UBFGDecorator_AllowRelocate final : public UBFGBTBaseDecorator
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"BFGDecorator_AllowRelocate">();
	}
	static class UBFGDecorator_AllowRelocate* GetDefaultObj()
	{
		return GetDefaultObjImpl<UBFGDecorator_AllowRelocate>();
	}
};
static_assert(alignof(UBFGDecorator_AllowRelocate) == 0x000008, "Wrong alignment on UBFGDecorator_AllowRelocate");
static_assert(sizeof(UBFGDecorator_AllowRelocate) == 0x000070, "Wrong size on UBFGDecorator_AllowRelocate");

// Class BFGCore.BFGInteractAnimationObject
// 0x0080 (0x00A8 - 0x0028)
class UBFGInteractAnimationObject : public UObject
{
public:
	struct FBFGInteractAnimationData              M_lastAnimationData;                               // 0x0028(0x0060)(Transient, NoDestructor, Protected, NativeAccessSpecifierProtected)
	int32                                         M_iNumLoops;                                       // 0x0088(0x0004)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          M_bIsInfiniteLoop;                                 // 0x008C(0x0001)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          M_bIsFinished;                                     // 0x008D(0x0001)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_8E[0x2];                                       // 0x008E(0x0002)(Fixing Size After Last Property [ Dumper-7 ])
	class UBFGNetworkPathAgent*                   M_pAgent;                                          // 0x0090(0x0008)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UBFGInteractAnimationObject*            M_pSynchronizeWith;                                // 0x0098(0x0008)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          M_bAnimationAssetRequired;                         // 0x00A0(0x0001)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_A1[0x7];                                       // 0x00A1(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"BFGInteractAnimationObject">();
	}
	static class UBFGInteractAnimationObject* GetDefaultObj()
	{
		return GetDefaultObjImpl<UBFGInteractAnimationObject>();
	}
};
static_assert(alignof(UBFGInteractAnimationObject) == 0x000008, "Wrong alignment on UBFGInteractAnimationObject");
static_assert(sizeof(UBFGInteractAnimationObject) == 0x0000A8, "Wrong size on UBFGInteractAnimationObject");
static_assert(offsetof(UBFGInteractAnimationObject, M_lastAnimationData) == 0x000028, "Member 'UBFGInteractAnimationObject::M_lastAnimationData' has a wrong offset!");
static_assert(offsetof(UBFGInteractAnimationObject, M_iNumLoops) == 0x000088, "Member 'UBFGInteractAnimationObject::M_iNumLoops' has a wrong offset!");
static_assert(offsetof(UBFGInteractAnimationObject, M_bIsInfiniteLoop) == 0x00008C, "Member 'UBFGInteractAnimationObject::M_bIsInfiniteLoop' has a wrong offset!");
static_assert(offsetof(UBFGInteractAnimationObject, M_bIsFinished) == 0x00008D, "Member 'UBFGInteractAnimationObject::M_bIsFinished' has a wrong offset!");
static_assert(offsetof(UBFGInteractAnimationObject, M_pAgent) == 0x000090, "Member 'UBFGInteractAnimationObject::M_pAgent' has a wrong offset!");
static_assert(offsetof(UBFGInteractAnimationObject, M_pSynchronizeWith) == 0x000098, "Member 'UBFGInteractAnimationObject::M_pSynchronizeWith' has a wrong offset!");
static_assert(offsetof(UBFGInteractAnimationObject, M_bAnimationAssetRequired) == 0x0000A0, "Member 'UBFGInteractAnimationObject::M_bAnimationAssetRequired' has a wrong offset!");

// Class BFGCore.BFGDecorator_CheckGlobalCooldown
// 0x0030 (0x00A0 - 0x0070)
class UBFGDecorator_CheckGlobalCooldown final : public UBFGBTBaseDecorator
{
public:
	struct FBlackboardKeySelector                 M_BBKeyAttackTarget;                               // 0x0070(0x0028)(Edit, NativeAccessSpecifierPublic)
	EBFGGlobalCooldown                            M_cooldown;                                        // 0x0098(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          M_bReserveSlot;                                    // 0x0099(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_9A[0x6];                                       // 0x009A(0x0006)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"BFGDecorator_CheckGlobalCooldown">();
	}
	static class UBFGDecorator_CheckGlobalCooldown* GetDefaultObj()
	{
		return GetDefaultObjImpl<UBFGDecorator_CheckGlobalCooldown>();
	}
};
static_assert(alignof(UBFGDecorator_CheckGlobalCooldown) == 0x000008, "Wrong alignment on UBFGDecorator_CheckGlobalCooldown");
static_assert(sizeof(UBFGDecorator_CheckGlobalCooldown) == 0x0000A0, "Wrong size on UBFGDecorator_CheckGlobalCooldown");
static_assert(offsetof(UBFGDecorator_CheckGlobalCooldown, M_BBKeyAttackTarget) == 0x000070, "Member 'UBFGDecorator_CheckGlobalCooldown::M_BBKeyAttackTarget' has a wrong offset!");
static_assert(offsetof(UBFGDecorator_CheckGlobalCooldown, M_cooldown) == 0x000098, "Member 'UBFGDecorator_CheckGlobalCooldown::M_cooldown' has a wrong offset!");
static_assert(offsetof(UBFGDecorator_CheckGlobalCooldown, M_bReserveSlot) == 0x000099, "Member 'UBFGDecorator_CheckGlobalCooldown::M_bReserveSlot' has a wrong offset!");

// Class BFGCore.BFGVariableAction_ScriptedSequence_Aborted
// 0x0000 (0x00F0 - 0x00F0)
class UBFGVariableAction_ScriptedSequence_Aborted final : public UBFGVariableAction
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"BFGVariableAction_ScriptedSequence_Aborted">();
	}
	static class UBFGVariableAction_ScriptedSequence_Aborted* GetDefaultObj()
	{
		return GetDefaultObjImpl<UBFGVariableAction_ScriptedSequence_Aborted>();
	}
};
static_assert(alignof(UBFGVariableAction_ScriptedSequence_Aborted) == 0x000008, "Wrong alignment on UBFGVariableAction_ScriptedSequence_Aborted");
static_assert(sizeof(UBFGVariableAction_ScriptedSequence_Aborted) == 0x0000F0, "Wrong size on UBFGVariableAction_ScriptedSequence_Aborted");

// Class BFGCore.BFGDecorator_CheckVariant
// 0x0038 (0x00A8 - 0x0070)
class UBFGDecorator_CheckVariant final : public UBFGBTBaseDecorator
{
public:
	struct FBlackboardKeySelector                 M_BBKeyCombatAttackTarget;                         // 0x0070(0x0028)(Edit, NativeAccessSpecifierPublic)
	TArray<struct FBFGBTVariant_ConditionSet>     M_aConditionSets;                                  // 0x0098(0x0010)(Edit, ZeroConstructor, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"BFGDecorator_CheckVariant">();
	}
	static class UBFGDecorator_CheckVariant* GetDefaultObj()
	{
		return GetDefaultObjImpl<UBFGDecorator_CheckVariant>();
	}
};
static_assert(alignof(UBFGDecorator_CheckVariant) == 0x000008, "Wrong alignment on UBFGDecorator_CheckVariant");
static_assert(sizeof(UBFGDecorator_CheckVariant) == 0x0000A8, "Wrong size on UBFGDecorator_CheckVariant");
static_assert(offsetof(UBFGDecorator_CheckVariant, M_BBKeyCombatAttackTarget) == 0x000070, "Member 'UBFGDecorator_CheckVariant::M_BBKeyCombatAttackTarget' has a wrong offset!");
static_assert(offsetof(UBFGDecorator_CheckVariant, M_aConditionSets) == 0x000098, "Member 'UBFGDecorator_CheckVariant::M_aConditionSets' has a wrong offset!");

// Class BFGCore.BFGDecorator_CivilianDrawGun
// 0x0008 (0x0078 - 0x0070)
class UBFGDecorator_CivilianDrawGun final : public UBFGBTBaseDecorator
{
public:
	float                                         M_fProbability;                                    // 0x0070(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_74[0x4];                                       // 0x0074(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"BFGDecorator_CivilianDrawGun">();
	}
	static class UBFGDecorator_CivilianDrawGun* GetDefaultObj()
	{
		return GetDefaultObjImpl<UBFGDecorator_CivilianDrawGun>();
	}
};
static_assert(alignof(UBFGDecorator_CivilianDrawGun) == 0x000008, "Wrong alignment on UBFGDecorator_CivilianDrawGun");
static_assert(sizeof(UBFGDecorator_CivilianDrawGun) == 0x000078, "Wrong size on UBFGDecorator_CivilianDrawGun");
static_assert(offsetof(UBFGDecorator_CivilianDrawGun, M_fProbability) == 0x000070, "Member 'UBFGDecorator_CivilianDrawGun::M_fProbability' has a wrong offset!");

// Class BFGCore.BFGSequencePlaybackManager
// 0x0070 (0x00A0 - 0x0030)
class UBFGSequencePlaybackManager final : public UBFGGameSystem
{
public:
	uint8                                         Pad_30[0x8];                                       // 0x0030(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	UMulticastDelegateProperty_                   M_onSequenceFinished;                              // 0x0038(0x0018)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	UMulticastDelegateProperty_                   M_onSequencePaused;                                // 0x0050(0x0018)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	class ABFGGameState*                          M_pGameState;                                      // 0x0068(0x0008)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UBFGSequencePlayer*                     M_pCutscene;                                       // 0x0070(0x0008)(ExportObject, ZeroConstructor, Transient, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TArray<class UBFGSequencePlayer*>             M_aSequences;                                      // 0x0078(0x0010)(ExportObject, ZeroConstructor, Transient, ContainsInstancedReference, Protected, NativeAccessSpecifierProtected)
	class UClass*                                 M_pCutsceneStateClass;                             // 0x0088(0x0008)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TArray<class UBFGSequenceRequest*>            M_apRequests;                                      // 0x0090(0x0010)(ZeroConstructor, Transient, Protected, NativeAccessSpecifierProtected)

public:
	void GameSystem_LevelSequenceLog() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"BFGSequencePlaybackManager">();
	}
	static class UBFGSequencePlaybackManager* GetDefaultObj()
	{
		return GetDefaultObjImpl<UBFGSequencePlaybackManager>();
	}
};
static_assert(alignof(UBFGSequencePlaybackManager) == 0x000008, "Wrong alignment on UBFGSequencePlaybackManager");
static_assert(sizeof(UBFGSequencePlaybackManager) == 0x0000A0, "Wrong size on UBFGSequencePlaybackManager");
static_assert(offsetof(UBFGSequencePlaybackManager, M_onSequenceFinished) == 0x000038, "Member 'UBFGSequencePlaybackManager::M_onSequenceFinished' has a wrong offset!");
static_assert(offsetof(UBFGSequencePlaybackManager, M_onSequencePaused) == 0x000050, "Member 'UBFGSequencePlaybackManager::M_onSequencePaused' has a wrong offset!");
static_assert(offsetof(UBFGSequencePlaybackManager, M_pGameState) == 0x000068, "Member 'UBFGSequencePlaybackManager::M_pGameState' has a wrong offset!");
static_assert(offsetof(UBFGSequencePlaybackManager, M_pCutscene) == 0x000070, "Member 'UBFGSequencePlaybackManager::M_pCutscene' has a wrong offset!");
static_assert(offsetof(UBFGSequencePlaybackManager, M_aSequences) == 0x000078, "Member 'UBFGSequencePlaybackManager::M_aSequences' has a wrong offset!");
static_assert(offsetof(UBFGSequencePlaybackManager, M_pCutsceneStateClass) == 0x000088, "Member 'UBFGSequencePlaybackManager::M_pCutsceneStateClass' has a wrong offset!");
static_assert(offsetof(UBFGSequencePlaybackManager, M_apRequests) == 0x000090, "Member 'UBFGSequencePlaybackManager::M_apRequests' has a wrong offset!");

// Class BFGCore.BFGFactionResolver
// 0x0000 (0x0028 - 0x0028)
class UBFGFactionResolver final : public UObject
{
public:
	static ETeamAttitude ResolveActorAttitute(class AActor* _pActorA, class AActor* _pActorB, bool _bAllowNoFaction);
	static ETeamAttitude ResolveAttitute(const struct FGenericTeamId& _teamA, const struct FGenericTeamId& _teamB);
	static bool SetFactionForActor(class AActor* _pActor, EBFGFaction _faction);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"BFGFactionResolver">();
	}
	static class UBFGFactionResolver* GetDefaultObj()
	{
		return GetDefaultObjImpl<UBFGFactionResolver>();
	}
};
static_assert(alignof(UBFGFactionResolver) == 0x000008, "Wrong alignment on UBFGFactionResolver");
static_assert(sizeof(UBFGFactionResolver) == 0x000028, "Wrong size on UBFGFactionResolver");

// Class BFGCore.BFGDecorator_CloseToSaucer
// 0x0030 (0x00A0 - 0x0070)
class UBFGDecorator_CloseToSaucer final : public UBFGBTBaseDecorator
{
public:
	struct FBlackboardKeySelector                 M_BBKey;                                           // 0x0070(0x0028)(Edit, NativeAccessSpecifierPublic)
	float                                         M_fRange;                                          // 0x0098(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_9C[0x4];                                       // 0x009C(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"BFGDecorator_CloseToSaucer">();
	}
	static class UBFGDecorator_CloseToSaucer* GetDefaultObj()
	{
		return GetDefaultObjImpl<UBFGDecorator_CloseToSaucer>();
	}
};
static_assert(alignof(UBFGDecorator_CloseToSaucer) == 0x000008, "Wrong alignment on UBFGDecorator_CloseToSaucer");
static_assert(sizeof(UBFGDecorator_CloseToSaucer) == 0x0000A0, "Wrong size on UBFGDecorator_CloseToSaucer");
static_assert(offsetof(UBFGDecorator_CloseToSaucer, M_BBKey) == 0x000070, "Member 'UBFGDecorator_CloseToSaucer::M_BBKey' has a wrong offset!");
static_assert(offsetof(UBFGDecorator_CloseToSaucer, M_fRange) == 0x000098, "Member 'UBFGDecorator_CloseToSaucer::M_fRange' has a wrong offset!");

// Class BFGCore.BFGDecorator_Escort_CanMove
// 0x0030 (0x00A0 - 0x0070)
class UBFGDecorator_Escort_CanMove final : public UBFGBTBaseDecorator
{
public:
	struct FBlackboardKeySelector                 M_BBKey_TaskData;                                  // 0x0070(0x0028)(Edit, NativeAccessSpecifierPublic)
	float                                         M_fGoalInRange;                                    // 0x0098(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_9C[0x4];                                       // 0x009C(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"BFGDecorator_Escort_CanMove">();
	}
	static class UBFGDecorator_Escort_CanMove* GetDefaultObj()
	{
		return GetDefaultObjImpl<UBFGDecorator_Escort_CanMove>();
	}
};
static_assert(alignof(UBFGDecorator_Escort_CanMove) == 0x000008, "Wrong alignment on UBFGDecorator_Escort_CanMove");
static_assert(sizeof(UBFGDecorator_Escort_CanMove) == 0x0000A0, "Wrong size on UBFGDecorator_Escort_CanMove");
static_assert(offsetof(UBFGDecorator_Escort_CanMove, M_BBKey_TaskData) == 0x000070, "Member 'UBFGDecorator_Escort_CanMove::M_BBKey_TaskData' has a wrong offset!");
static_assert(offsetof(UBFGDecorator_Escort_CanMove, M_fGoalInRange) == 0x000098, "Member 'UBFGDecorator_Escort_CanMove::M_fGoalInRange' has a wrong offset!");

// Class BFGCore.BFGSpawnPoolManager
// 0x0018 (0x0048 - 0x0030)
class UBFGSpawnPoolManager : public UBFGGameSystem
{
public:
	TSubclassOf<class ABFGSpawnPool>              M_pSpawnPoolClass;                                 // 0x0030(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class ABFGGameState*                          M_pGameState;                                      // 0x0038(0x0008)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class ABFGSpawnPool*                          M_pActor;                                          // 0x0040(0x0008)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"BFGSpawnPoolManager">();
	}
	static class UBFGSpawnPoolManager* GetDefaultObj()
	{
		return GetDefaultObjImpl<UBFGSpawnPoolManager>();
	}
};
static_assert(alignof(UBFGSpawnPoolManager) == 0x000008, "Wrong alignment on UBFGSpawnPoolManager");
static_assert(sizeof(UBFGSpawnPoolManager) == 0x000048, "Wrong size on UBFGSpawnPoolManager");
static_assert(offsetof(UBFGSpawnPoolManager, M_pSpawnPoolClass) == 0x000030, "Member 'UBFGSpawnPoolManager::M_pSpawnPoolClass' has a wrong offset!");
static_assert(offsetof(UBFGSpawnPoolManager, M_pGameState) == 0x000038, "Member 'UBFGSpawnPoolManager::M_pGameState' has a wrong offset!");
static_assert(offsetof(UBFGSpawnPoolManager, M_pActor) == 0x000040, "Member 'UBFGSpawnPoolManager::M_pActor' has a wrong offset!");

// Class BFGCore.BFGGameFlowState_FuronHandbook
// 0x0008 (0x0110 - 0x0108)
class UBFGGameFlowState_FuronHandbook final : public UBFGGameFlowState_GenericDialog_Customizable
{
public:
	class UBFGDataAsset_TutorialPage*             M_pInitialPage;                                    // 0x0108(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"BFGGameFlowState_FuronHandbook">();
	}
	static class UBFGGameFlowState_FuronHandbook* GetDefaultObj()
	{
		return GetDefaultObjImpl<UBFGGameFlowState_FuronHandbook>();
	}
};
static_assert(alignof(UBFGGameFlowState_FuronHandbook) == 0x000008, "Wrong alignment on UBFGGameFlowState_FuronHandbook");
static_assert(sizeof(UBFGGameFlowState_FuronHandbook) == 0x000110, "Wrong size on UBFGGameFlowState_FuronHandbook");
static_assert(offsetof(UBFGGameFlowState_FuronHandbook, M_pInitialPage) == 0x000108, "Member 'UBFGGameFlowState_FuronHandbook::M_pInitialPage' has a wrong offset!");

// Class BFGCore.BFGDecorator_GameplayEffectTags
// 0x0068 (0x00D0 - 0x0068)
class UBFGDecorator_GameplayEffectTags final : public UBTDecorator
{
public:
	struct FGameplayTagContainer                  M_aObservedGameplayEffectTags;                     // 0x0068(0x0020)(Edit, NativeAccessSpecifierPublic)
	struct FGameplayTagQuery                      M_gameplayEffectTagQuery;                          // 0x0088(0x0048)(Edit, NativeAccessSpecifierPublic)

public:
	void OnPawnChanged(class APawn* _pPawn);
	void OnTagChanged(const struct FGameplayTag& _rTag, class AActor* _pTargetActor);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"BFGDecorator_GameplayEffectTags">();
	}
	static class UBFGDecorator_GameplayEffectTags* GetDefaultObj()
	{
		return GetDefaultObjImpl<UBFGDecorator_GameplayEffectTags>();
	}
};
static_assert(alignof(UBFGDecorator_GameplayEffectTags) == 0x000008, "Wrong alignment on UBFGDecorator_GameplayEffectTags");
static_assert(sizeof(UBFGDecorator_GameplayEffectTags) == 0x0000D0, "Wrong size on UBFGDecorator_GameplayEffectTags");
static_assert(offsetof(UBFGDecorator_GameplayEffectTags, M_aObservedGameplayEffectTags) == 0x000068, "Member 'UBFGDecorator_GameplayEffectTags::M_aObservedGameplayEffectTags' has a wrong offset!");
static_assert(offsetof(UBFGDecorator_GameplayEffectTags, M_gameplayEffectTagQuery) == 0x000088, "Member 'UBFGDecorator_GameplayEffectTags::M_gameplayEffectTagQuery' has a wrong offset!");

// Class BFGCore.BFGDecorator_InQuadrant
// 0x0008 (0x0078 - 0x0070)
class UBFGDecorator_InQuadrant final : public UBFGBTBaseDecorator
{
public:
	EBFGAttackQuadrant                            M_eQuadrant;                                       // 0x0070(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_71[0x7];                                       // 0x0071(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"BFGDecorator_InQuadrant">();
	}
	static class UBFGDecorator_InQuadrant* GetDefaultObj()
	{
		return GetDefaultObjImpl<UBFGDecorator_InQuadrant>();
	}
};
static_assert(alignof(UBFGDecorator_InQuadrant) == 0x000008, "Wrong alignment on UBFGDecorator_InQuadrant");
static_assert(sizeof(UBFGDecorator_InQuadrant) == 0x000078, "Wrong size on UBFGDecorator_InQuadrant");
static_assert(offsetof(UBFGDecorator_InQuadrant, M_eQuadrant) == 0x000070, "Member 'UBFGDecorator_InQuadrant::M_eQuadrant' has a wrong offset!");

// Class BFGCore.BFGItemDestructable
// 0x0040 (0x0BD0 - 0x0B90)
class ABFGItemDestructable : public ABFGNPCCharacterGameplay
{
public:
	uint8                                         Pad_B88[0x8];                                      // 0x0B88(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	class UBFGActorComponent_ExplosiveItem*       M_pExplosiveComponent;                             // 0x0B90(0x0008)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, EditConst, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FSoftClassPath                         M_ActorToSpawn;                                    // 0x0B98(0x0018)(Edit, ZeroConstructor, NativeAccessSpecifierPublic)
	class UStaticMesh*                            M_pDeathMeshOverride;                              // 0x0BB0(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UStaticMeshComponent*                   M_pCachedStaticMeshComponent;                      // 0x0BB8(0x0008)(ExportObject, ZeroConstructor, Transient, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         M_fLifetimeWhenFakingDeath;                        // 0x0BC0(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_BC4[0xC];                                      // 0x0BC4(0x000C)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void OnDeathStateChanged(class AActor* _pActor, class UBFGActorStat_Bool* _pStat);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"BFGItemDestructable">();
	}
	static class ABFGItemDestructable* GetDefaultObj()
	{
		return GetDefaultObjImpl<ABFGItemDestructable>();
	}
};
static_assert(alignof(ABFGItemDestructable) == 0x000010, "Wrong alignment on ABFGItemDestructable");
static_assert(sizeof(ABFGItemDestructable) == 0x000BD0, "Wrong size on ABFGItemDestructable");
static_assert(offsetof(ABFGItemDestructable, M_pExplosiveComponent) == 0x000B90, "Member 'ABFGItemDestructable::M_pExplosiveComponent' has a wrong offset!");
static_assert(offsetof(ABFGItemDestructable, M_ActorToSpawn) == 0x000B98, "Member 'ABFGItemDestructable::M_ActorToSpawn' has a wrong offset!");
static_assert(offsetof(ABFGItemDestructable, M_pDeathMeshOverride) == 0x000BB0, "Member 'ABFGItemDestructable::M_pDeathMeshOverride' has a wrong offset!");
static_assert(offsetof(ABFGItemDestructable, M_pCachedStaticMeshComponent) == 0x000BB8, "Member 'ABFGItemDestructable::M_pCachedStaticMeshComponent' has a wrong offset!");
static_assert(offsetof(ABFGItemDestructable, M_fLifetimeWhenFakingDeath) == 0x000BC0, "Member 'ABFGItemDestructable::M_fLifetimeWhenFakingDeath' has a wrong offset!");

// Class BFGCore.BFGDecorator_InRange_Blackboard
// 0x0058 (0x00C8 - 0x0070)
class UBFGDecorator_InRange_Blackboard final : public UBFGBTBaseDecorator
{
public:
	struct FBlackboardKeySelector                 M_BBKey;                                           // 0x0070(0x0028)(Edit, NativeAccessSpecifierPublic)
	float                                         M_fMinRange;                                       // 0x0098(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_9C[0x4];                                       // 0x009C(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	struct FBlackboardKeySelector                 M_BBKeyMaxRange;                                   // 0x00A0(0x0028)(Edit, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"BFGDecorator_InRange_Blackboard">();
	}
	static class UBFGDecorator_InRange_Blackboard* GetDefaultObj()
	{
		return GetDefaultObjImpl<UBFGDecorator_InRange_Blackboard>();
	}
};
static_assert(alignof(UBFGDecorator_InRange_Blackboard) == 0x000008, "Wrong alignment on UBFGDecorator_InRange_Blackboard");
static_assert(sizeof(UBFGDecorator_InRange_Blackboard) == 0x0000C8, "Wrong size on UBFGDecorator_InRange_Blackboard");
static_assert(offsetof(UBFGDecorator_InRange_Blackboard, M_BBKey) == 0x000070, "Member 'UBFGDecorator_InRange_Blackboard::M_BBKey' has a wrong offset!");
static_assert(offsetof(UBFGDecorator_InRange_Blackboard, M_fMinRange) == 0x000098, "Member 'UBFGDecorator_InRange_Blackboard::M_fMinRange' has a wrong offset!");
static_assert(offsetof(UBFGDecorator_InRange_Blackboard, M_BBKeyMaxRange) == 0x0000A0, "Member 'UBFGDecorator_InRange_Blackboard::M_BBKeyMaxRange' has a wrong offset!");

// Class BFGCore.BFGVariableMessageServer
// 0x0018 (0x00A0 - 0x0088)
class UBFGVariableMessageServer final : public UBFGMessageServer
{
public:
	uint8                                         Pad_88[0x18];                                      // 0x0088(0x0018)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void OnVariableChanged(class UBFGVariableMirror* _pVarMirror, const class UBFGVariable* _pVariable, int32 _oldValue, int32 _newValue);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"BFGVariableMessageServer">();
	}
	static class UBFGVariableMessageServer* GetDefaultObj()
	{
		return GetDefaultObjImpl<UBFGVariableMessageServer>();
	}
};
static_assert(alignof(UBFGVariableMessageServer) == 0x000008, "Wrong alignment on UBFGVariableMessageServer");
static_assert(sizeof(UBFGVariableMessageServer) == 0x0000A0, "Wrong size on UBFGVariableMessageServer");

// Class BFGCore.BFGDecorator_InRange_IonDetonator
// 0x0010 (0x0080 - 0x0070)
class UBFGDecorator_InRange_IonDetonator final : public UBFGBTBaseDecorator
{
public:
	uint8                                         Pad_70[0x10];                                      // 0x0070(0x0010)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"BFGDecorator_InRange_IonDetonator">();
	}
	static class UBFGDecorator_InRange_IonDetonator* GetDefaultObj()
	{
		return GetDefaultObjImpl<UBFGDecorator_InRange_IonDetonator>();
	}
};
static_assert(alignof(UBFGDecorator_InRange_IonDetonator) == 0x000008, "Wrong alignment on UBFGDecorator_InRange_IonDetonator");
static_assert(sizeof(UBFGDecorator_InRange_IonDetonator) == 0x000080, "Wrong size on UBFGDecorator_InRange_IonDetonator");

// Class BFGCore.BFGDecorator_IsActorDisabled
// 0x0028 (0x0098 - 0x0070)
class UBFGDecorator_IsActorDisabled final : public UBFGBTBaseDecorator
{
public:
	struct FBlackboardKeySelector                 M_BBKey;                                           // 0x0070(0x0028)(Edit, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"BFGDecorator_IsActorDisabled">();
	}
	static class UBFGDecorator_IsActorDisabled* GetDefaultObj()
	{
		return GetDefaultObjImpl<UBFGDecorator_IsActorDisabled>();
	}
};
static_assert(alignof(UBFGDecorator_IsActorDisabled) == 0x000008, "Wrong alignment on UBFGDecorator_IsActorDisabled");
static_assert(sizeof(UBFGDecorator_IsActorDisabled) == 0x000098, "Wrong size on UBFGDecorator_IsActorDisabled");
static_assert(offsetof(UBFGDecorator_IsActorDisabled, M_BBKey) == 0x000070, "Member 'UBFGDecorator_IsActorDisabled::M_BBKey' has a wrong offset!");

// Class BFGCore.BFGSpawningComposition
// 0x0030 (0x0058 - 0x0028)
class UBFGSpawningComposition : public UObject
{
public:
	class FName                                   M_nameID;                                          // 0x0028(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         M_fSpawnDensity;                                   // 0x0030(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_34[0x4];                                       // 0x0034(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<struct FGameplayTagQuery>              M_aExclusionList;                                  // 0x0038(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, Protected, NativeAccessSpecifierProtected)
	bool                                          M_bCheckUnlocks;                                   // 0x0048(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_49[0x7];                                       // 0x0049(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	class UBFGTrafficCrowdManager*                M_pManager;                                        // 0x0050(0x0008)(ExportObject, ZeroConstructor, Transient, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"BFGSpawningComposition">();
	}
	static class UBFGSpawningComposition* GetDefaultObj()
	{
		return GetDefaultObjImpl<UBFGSpawningComposition>();
	}
};
static_assert(alignof(UBFGSpawningComposition) == 0x000008, "Wrong alignment on UBFGSpawningComposition");
static_assert(sizeof(UBFGSpawningComposition) == 0x000058, "Wrong size on UBFGSpawningComposition");
static_assert(offsetof(UBFGSpawningComposition, M_nameID) == 0x000028, "Member 'UBFGSpawningComposition::M_nameID' has a wrong offset!");
static_assert(offsetof(UBFGSpawningComposition, M_fSpawnDensity) == 0x000030, "Member 'UBFGSpawningComposition::M_fSpawnDensity' has a wrong offset!");
static_assert(offsetof(UBFGSpawningComposition, M_aExclusionList) == 0x000038, "Member 'UBFGSpawningComposition::M_aExclusionList' has a wrong offset!");
static_assert(offsetof(UBFGSpawningComposition, M_bCheckUnlocks) == 0x000048, "Member 'UBFGSpawningComposition::M_bCheckUnlocks' has a wrong offset!");
static_assert(offsetof(UBFGSpawningComposition, M_pManager) == 0x000050, "Member 'UBFGSpawningComposition::M_pManager' has a wrong offset!");

// Class BFGCore.BFGSpawningCompositionVehicle
// 0x0038 (0x0090 - 0x0058)
class UBFGSpawningCompositionVehicle final : public UBFGSpawningComposition
{
public:
	TSoftObjectPtr<class UDataTable>              M_pVehicleTable;                                   // 0x0058(0x0028)(Edit, BlueprintVisible, BlueprintReadOnly, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TArray<struct FBFGSpawningCompositionItemVehicle> M_aItems;                                          // 0x0080(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, Protected, NativeAccessSpecifierProtected)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"BFGSpawningCompositionVehicle">();
	}
	static class UBFGSpawningCompositionVehicle* GetDefaultObj()
	{
		return GetDefaultObjImpl<UBFGSpawningCompositionVehicle>();
	}
};
static_assert(alignof(UBFGSpawningCompositionVehicle) == 0x000008, "Wrong alignment on UBFGSpawningCompositionVehicle");
static_assert(sizeof(UBFGSpawningCompositionVehicle) == 0x000090, "Wrong size on UBFGSpawningCompositionVehicle");
static_assert(offsetof(UBFGSpawningCompositionVehicle, M_pVehicleTable) == 0x000058, "Member 'UBFGSpawningCompositionVehicle::M_pVehicleTable' has a wrong offset!");
static_assert(offsetof(UBFGSpawningCompositionVehicle, M_aItems) == 0x000080, "Member 'UBFGSpawningCompositionVehicle::M_aItems' has a wrong offset!");

// Class BFGCore.BFGDecorator_IsRelocateLocationValid
// 0x0050 (0x00C0 - 0x0070)
class UBFGDecorator_IsRelocateLocationValid final : public UBFGDecorator_ObservingBase
{
public:
	struct FBlackboardKeySelector                 M_BBKeyLocation;                                   // 0x0070(0x0028)(Edit, NativeAccessSpecifierPublic)
	struct FBlackboardKeySelector                 M_BBKeyAttackTarget;                               // 0x0098(0x0028)(Edit, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"BFGDecorator_IsRelocateLocationValid">();
	}
	static class UBFGDecorator_IsRelocateLocationValid* GetDefaultObj()
	{
		return GetDefaultObjImpl<UBFGDecorator_IsRelocateLocationValid>();
	}
};
static_assert(alignof(UBFGDecorator_IsRelocateLocationValid) == 0x000008, "Wrong alignment on UBFGDecorator_IsRelocateLocationValid");
static_assert(sizeof(UBFGDecorator_IsRelocateLocationValid) == 0x0000C0, "Wrong size on UBFGDecorator_IsRelocateLocationValid");
static_assert(offsetof(UBFGDecorator_IsRelocateLocationValid, M_BBKeyLocation) == 0x000070, "Member 'UBFGDecorator_IsRelocateLocationValid::M_BBKeyLocation' has a wrong offset!");
static_assert(offsetof(UBFGDecorator_IsRelocateLocationValid, M_BBKeyAttackTarget) == 0x000098, "Member 'UBFGDecorator_IsRelocateLocationValid::M_BBKeyAttackTarget' has a wrong offset!");

// Class BFGCore.BFGDecorator_IsStepInRange
// 0x0018 (0x0088 - 0x0070)
class UBFGDecorator_IsStepInRange final : public UBFGBTBaseDecorator
{
public:
	TArray<struct FPhaseStepRange>                M_aPhaseStepRanges;                                // 0x0070(0x0010)(Edit, ZeroConstructor, NativeAccessSpecifierPublic)
	bool                                          M_bShowDebugInfo;                                  // 0x0080(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_81[0x7];                                       // 0x0081(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"BFGDecorator_IsStepInRange">();
	}
	static class UBFGDecorator_IsStepInRange* GetDefaultObj()
	{
		return GetDefaultObjImpl<UBFGDecorator_IsStepInRange>();
	}
};
static_assert(alignof(UBFGDecorator_IsStepInRange) == 0x000008, "Wrong alignment on UBFGDecorator_IsStepInRange");
static_assert(sizeof(UBFGDecorator_IsStepInRange) == 0x000088, "Wrong size on UBFGDecorator_IsStepInRange");
static_assert(offsetof(UBFGDecorator_IsStepInRange, M_aPhaseStepRanges) == 0x000070, "Member 'UBFGDecorator_IsStepInRange::M_aPhaseStepRanges' has a wrong offset!");
static_assert(offsetof(UBFGDecorator_IsStepInRange, M_bShowDebugInfo) == 0x000080, "Member 'UBFGDecorator_IsStepInRange::M_bShowDebugInfo' has a wrong offset!");

// Class BFGCore.BFGDecorator_IsTargetInAir
// 0x0028 (0x0098 - 0x0070)
class UBFGDecorator_IsTargetInAir final : public UBFGBTBaseDecorator
{
public:
	struct FBlackboardKeySelector                 M_bbKeyTarget;                                     // 0x0070(0x0028)(Edit, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"BFGDecorator_IsTargetInAir">();
	}
	static class UBFGDecorator_IsTargetInAir* GetDefaultObj()
	{
		return GetDefaultObjImpl<UBFGDecorator_IsTargetInAir>();
	}
};
static_assert(alignof(UBFGDecorator_IsTargetInAir) == 0x000008, "Wrong alignment on UBFGDecorator_IsTargetInAir");
static_assert(sizeof(UBFGDecorator_IsTargetInAir) == 0x000098, "Wrong size on UBFGDecorator_IsTargetInAir");
static_assert(offsetof(UBFGDecorator_IsTargetInAir, M_bbKeyTarget) == 0x000070, "Member 'UBFGDecorator_IsTargetInAir::M_bbKeyTarget' has a wrong offset!");

// Class BFGCore.BFGInputAction_PlayerSelectNextWeapon
// 0x0000 (0x0030 - 0x0030)
class UBFGInputAction_PlayerSelectNextWeapon final : public UBFGInputAction
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"BFGInputAction_PlayerSelectNextWeapon">();
	}
	static class UBFGInputAction_PlayerSelectNextWeapon* GetDefaultObj()
	{
		return GetDefaultObjImpl<UBFGInputAction_PlayerSelectNextWeapon>();
	}
};
static_assert(alignof(UBFGInputAction_PlayerSelectNextWeapon) == 0x000008, "Wrong alignment on UBFGInputAction_PlayerSelectNextWeapon");
static_assert(sizeof(UBFGInputAction_PlayerSelectNextWeapon) == 0x000030, "Wrong size on UBFGInputAction_PlayerSelectNextWeapon");

// Class BFGCore.BFGDecorator_IsWeaponTriggerable
// 0x0080 (0x00F0 - 0x0070)
class UBFGDecorator_IsWeaponTriggerable final : public UBFGBTBaseDecorator
{
public:
	struct FBlackboardKeySelector                 M_BBKeyAttackTarget;                               // 0x0070(0x0028)(Edit, NativeAccessSpecifierPublic)
	struct FBlackboardKeySelector                 M_BBKeyHasLoS;                                     // 0x0098(0x0028)(Edit, NativeAccessSpecifierPublic)
	TSoftClassPtr<class UClass>                   M_pSpecificWeapon;                                 // 0x00C0(0x0028)(Edit, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         M_fAllowedAttackDelay;                             // 0x00E8(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_EC[0x4];                                       // 0x00EC(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"BFGDecorator_IsWeaponTriggerable">();
	}
	static class UBFGDecorator_IsWeaponTriggerable* GetDefaultObj()
	{
		return GetDefaultObjImpl<UBFGDecorator_IsWeaponTriggerable>();
	}
};
static_assert(alignof(UBFGDecorator_IsWeaponTriggerable) == 0x000008, "Wrong alignment on UBFGDecorator_IsWeaponTriggerable");
static_assert(sizeof(UBFGDecorator_IsWeaponTriggerable) == 0x0000F0, "Wrong size on UBFGDecorator_IsWeaponTriggerable");
static_assert(offsetof(UBFGDecorator_IsWeaponTriggerable, M_BBKeyAttackTarget) == 0x000070, "Member 'UBFGDecorator_IsWeaponTriggerable::M_BBKeyAttackTarget' has a wrong offset!");
static_assert(offsetof(UBFGDecorator_IsWeaponTriggerable, M_BBKeyHasLoS) == 0x000098, "Member 'UBFGDecorator_IsWeaponTriggerable::M_BBKeyHasLoS' has a wrong offset!");
static_assert(offsetof(UBFGDecorator_IsWeaponTriggerable, M_pSpecificWeapon) == 0x0000C0, "Member 'UBFGDecorator_IsWeaponTriggerable::M_pSpecificWeapon' has a wrong offset!");
static_assert(offsetof(UBFGDecorator_IsWeaponTriggerable, M_fAllowedAttackDelay) == 0x0000E8, "Member 'UBFGDecorator_IsWeaponTriggerable::M_fAllowedAttackDelay' has a wrong offset!");

// Class BFGCore.BFGMissionSpawner
// 0x0168 (0x0540 - 0x03D8)
class ABFGMissionSpawner final : public AActor
{
public:
	float                                         M_fDelay;                                          // 0x03D8(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_3DC[0x4];                                      // 0x03DC(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<TSoftObjectPtr<class AActor>>          M_aspVisibilityProxies;                            // 0x03E0(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Protected, UObjectWrapper, NativeAccessSpecifierProtected)
	bool                                          M_bEnabled;                                        // 0x03F0(0x0001)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_3F1[0x3];                                      // 0x03F1(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         M_fCurrentDelay;                                   // 0x03F4(0x0004)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	struct FBFGMissionSpawnRequest                M_spawnRequest;                                    // 0x03F8(0x0148)(Transient, ContainsInstancedReference, Protected, NativeAccessSpecifierProtected)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"BFGMissionSpawner">();
	}
	static class ABFGMissionSpawner* GetDefaultObj()
	{
		return GetDefaultObjImpl<ABFGMissionSpawner>();
	}
};
static_assert(alignof(ABFGMissionSpawner) == 0x000008, "Wrong alignment on ABFGMissionSpawner");
static_assert(sizeof(ABFGMissionSpawner) == 0x000540, "Wrong size on ABFGMissionSpawner");
static_assert(offsetof(ABFGMissionSpawner, M_fDelay) == 0x0003D8, "Member 'ABFGMissionSpawner::M_fDelay' has a wrong offset!");
static_assert(offsetof(ABFGMissionSpawner, M_aspVisibilityProxies) == 0x0003E0, "Member 'ABFGMissionSpawner::M_aspVisibilityProxies' has a wrong offset!");
static_assert(offsetof(ABFGMissionSpawner, M_bEnabled) == 0x0003F0, "Member 'ABFGMissionSpawner::M_bEnabled' has a wrong offset!");
static_assert(offsetof(ABFGMissionSpawner, M_fCurrentDelay) == 0x0003F4, "Member 'ABFGMissionSpawner::M_fCurrentDelay' has a wrong offset!");
static_assert(offsetof(ABFGMissionSpawner, M_spawnRequest) == 0x0003F8, "Member 'ABFGMissionSpawner::M_spawnRequest' has a wrong offset!");

// Class BFGCore.BFGDeferredActorSpawnSystem
// 0x0018 (0x03F0 - 0x03D8)
class ABFGDeferredActorSpawnSystem final : public AActor
{
public:
	TArray<struct FBFGDeferredActor>              M_aActorQueue;                                     // 0x03D8(0x0010)(ZeroConstructor, Transient, NativeAccessSpecifierPrivate)
	uint8                                         Pad_3E8[0x8];                                      // 0x03E8(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"BFGDeferredActorSpawnSystem">();
	}
	static class ABFGDeferredActorSpawnSystem* GetDefaultObj()
	{
		return GetDefaultObjImpl<ABFGDeferredActorSpawnSystem>();
	}
};
static_assert(alignof(ABFGDeferredActorSpawnSystem) == 0x000008, "Wrong alignment on ABFGDeferredActorSpawnSystem");
static_assert(sizeof(ABFGDeferredActorSpawnSystem) == 0x0003F0, "Wrong size on ABFGDeferredActorSpawnSystem");
static_assert(offsetof(ABFGDeferredActorSpawnSystem, M_aActorQueue) == 0x0003D8, "Member 'ABFGDeferredActorSpawnSystem::M_aActorQueue' has a wrong offset!");

// Class BFGCore.BFGDestructionEffect_BuildingFluff
// 0x0060 (0x0450 - 0x03F0)
class ABFGDestructionEffect_BuildingFluff final : public ABFGDestructionEffect
{
public:
	struct FBFGBuildingFluffEffects               M_EffectData;                                      // 0x03F0(0x0060)(BlueprintVisible, NoDestructor, ExposeOnSpawn, NativeAccessSpecifierPublic)

public:
	void SetupPFX();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"BFGDestructionEffect_BuildingFluff">();
	}
	static class ABFGDestructionEffect_BuildingFluff* GetDefaultObj()
	{
		return GetDefaultObjImpl<ABFGDestructionEffect_BuildingFluff>();
	}
};
static_assert(alignof(ABFGDestructionEffect_BuildingFluff) == 0x000010, "Wrong alignment on ABFGDestructionEffect_BuildingFluff");
static_assert(sizeof(ABFGDestructionEffect_BuildingFluff) == 0x000450, "Wrong size on ABFGDestructionEffect_BuildingFluff");
static_assert(offsetof(ABFGDestructionEffect_BuildingFluff, M_EffectData) == 0x0003F0, "Member 'ABFGDestructionEffect_BuildingFluff::M_EffectData' has a wrong offset!");

// Class BFGCore.BFGDestructionEffect_Details
// 0x0090 (0x0480 - 0x03F0)
class ABFGDestructionEffect_Details final : public ABFGDestructionEffect
{
public:
	struct FBFGBuildingDestructionDetailEffects   M_EffectData;                                      // 0x03F0(0x0080)(BlueprintVisible, NoDestructor, ExposeOnSpawn, NativeAccessSpecifierPublic)
	EBFGBuilding_DestructionState                 M_eDestructionState;                               // 0x0470(0x0001)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, ExposeOnSpawn, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_471[0xF];                                      // 0x0471(0x000F)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void SetupPFX();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"BFGDestructionEffect_Details">();
	}
	static class ABFGDestructionEffect_Details* GetDefaultObj()
	{
		return GetDefaultObjImpl<ABFGDestructionEffect_Details>();
	}
};
static_assert(alignof(ABFGDestructionEffect_Details) == 0x000010, "Wrong alignment on ABFGDestructionEffect_Details");
static_assert(sizeof(ABFGDestructionEffect_Details) == 0x000480, "Wrong size on ABFGDestructionEffect_Details");
static_assert(offsetof(ABFGDestructionEffect_Details, M_EffectData) == 0x0003F0, "Member 'ABFGDestructionEffect_Details::M_EffectData' has a wrong offset!");
static_assert(offsetof(ABFGDestructionEffect_Details, M_eDestructionState) == 0x000470, "Member 'ABFGDestructionEffect_Details::M_eDestructionState' has a wrong offset!");

// Class BFGCore.BFGInputAction_PlayerUFOToggleAbductMode
// 0x0000 (0x0030 - 0x0030)
class UBFGInputAction_PlayerUFOToggleAbductMode final : public UBFGInputAction
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"BFGInputAction_PlayerUFOToggleAbductMode">();
	}
	static class UBFGInputAction_PlayerUFOToggleAbductMode* GetDefaultObj()
	{
		return GetDefaultObjImpl<UBFGInputAction_PlayerUFOToggleAbductMode>();
	}
};
static_assert(alignof(UBFGInputAction_PlayerUFOToggleAbductMode) == 0x000008, "Wrong alignment on UBFGInputAction_PlayerUFOToggleAbductMode");
static_assert(sizeof(UBFGInputAction_PlayerUFOToggleAbductMode) == 0x000030, "Wrong size on UBFGInputAction_PlayerUFOToggleAbductMode");

// Class BFGCore.BFGDestructionStreamingManager
// 0x00A8 (0x00D8 - 0x0030)
class UBFGDestructionStreamingManager final : public UBFGGameSystem
{
public:
	class ABFGGameState*                          M_pGameState;                                      // 0x0030(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	struct FWidgetPool                            M_DebugWidgetPool;                                 // 0x0038(0x0070)(ContainsInstancedReference, NativeAccessSpecifierPrivate)
	class UCanvasPanel*                           M_pDebugCanvasPanel;                               // 0x00A8(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	TArray<struct FRadarWidgetPair>               M_aDebugWidgetsInUse;                              // 0x00B0(0x0010)(ZeroConstructor, ContainsInstancedReference, NativeAccessSpecifierPrivate)
	TArray<struct FBFGDestructionStreamingEntry>  M_aRegisteredEntires;                              // 0x00C0(0x0010)(ZeroConstructor, ContainsInstancedReference, NativeAccessSpecifierPrivate)
	uint8                                         Pad_D0[0x8];                                       // 0x00D0(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"BFGDestructionStreamingManager">();
	}
	static class UBFGDestructionStreamingManager* GetDefaultObj()
	{
		return GetDefaultObjImpl<UBFGDestructionStreamingManager>();
	}
};
static_assert(alignof(UBFGDestructionStreamingManager) == 0x000008, "Wrong alignment on UBFGDestructionStreamingManager");
static_assert(sizeof(UBFGDestructionStreamingManager) == 0x0000D8, "Wrong size on UBFGDestructionStreamingManager");
static_assert(offsetof(UBFGDestructionStreamingManager, M_pGameState) == 0x000030, "Member 'UBFGDestructionStreamingManager::M_pGameState' has a wrong offset!");
static_assert(offsetof(UBFGDestructionStreamingManager, M_DebugWidgetPool) == 0x000038, "Member 'UBFGDestructionStreamingManager::M_DebugWidgetPool' has a wrong offset!");
static_assert(offsetof(UBFGDestructionStreamingManager, M_pDebugCanvasPanel) == 0x0000A8, "Member 'UBFGDestructionStreamingManager::M_pDebugCanvasPanel' has a wrong offset!");
static_assert(offsetof(UBFGDestructionStreamingManager, M_aDebugWidgetsInUse) == 0x0000B0, "Member 'UBFGDestructionStreamingManager::M_aDebugWidgetsInUse' has a wrong offset!");
static_assert(offsetof(UBFGDestructionStreamingManager, M_aRegisteredEntires) == 0x0000C0, "Member 'UBFGDestructionStreamingManager::M_aRegisteredEntires' has a wrong offset!");

// Class BFGCore.BFGInterLevelSoundManager
// 0x0008 (0x0030 - 0x0028)
class UBFGInterLevelSoundManager final : public UObject
{
public:
	class UBFGGameInstance*                       M_pGameInstance;                                   // 0x0028(0x0008)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)

public:
	void AddSound(class USoundBase* _pSound);
	void Flush(class UWorld* _pWorldToFlush, bool _bClearActivatedReverb);
	void StopAllActiveSounds();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"BFGInterLevelSoundManager">();
	}
	static class UBFGInterLevelSoundManager* GetDefaultObj()
	{
		return GetDefaultObjImpl<UBFGInterLevelSoundManager>();
	}
};
static_assert(alignof(UBFGInterLevelSoundManager) == 0x000008, "Wrong alignment on UBFGInterLevelSoundManager");
static_assert(sizeof(UBFGInterLevelSoundManager) == 0x000030, "Wrong size on UBFGInterLevelSoundManager");
static_assert(offsetof(UBFGInterLevelSoundManager, M_pGameInstance) == 0x000028, "Member 'UBFGInterLevelSoundManager::M_pGameInstance' has a wrong offset!");

// Class BFGCore.BFGDetectionPostprocessor_UpdateSensesAny
// 0x0048 (0x0070 - 0x0028)
class UBFGDetectionPostprocessor_UpdateSensesAny final : public UBFGDetectionPostProcessor
{
public:
	struct FBlackboardKeySelector                 M_BBKeyAlertSensesAny;                             // 0x0028(0x0028)(Edit, BlueprintVisible, NativeAccessSpecifierPublic)
	TArray<EBFGBehaviourState_NPC>                M_aStates;                                         // 0x0050(0x0010)(Edit, ZeroConstructor, NativeAccessSpecifierPublic)
	TArray<TSubclassOf<class UAISense>>           M_aAlertSensesAny;                                 // 0x0060(0x0010)(Edit, ZeroConstructor, UObjectWrapper, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"BFGDetectionPostprocessor_UpdateSensesAny">();
	}
	static class UBFGDetectionPostprocessor_UpdateSensesAny* GetDefaultObj()
	{
		return GetDefaultObjImpl<UBFGDetectionPostprocessor_UpdateSensesAny>();
	}
};
static_assert(alignof(UBFGDetectionPostprocessor_UpdateSensesAny) == 0x000008, "Wrong alignment on UBFGDetectionPostprocessor_UpdateSensesAny");
static_assert(sizeof(UBFGDetectionPostprocessor_UpdateSensesAny) == 0x000070, "Wrong size on UBFGDetectionPostprocessor_UpdateSensesAny");
static_assert(offsetof(UBFGDetectionPostprocessor_UpdateSensesAny, M_BBKeyAlertSensesAny) == 0x000028, "Member 'UBFGDetectionPostprocessor_UpdateSensesAny::M_BBKeyAlertSensesAny' has a wrong offset!");
static_assert(offsetof(UBFGDetectionPostprocessor_UpdateSensesAny, M_aStates) == 0x000050, "Member 'UBFGDetectionPostprocessor_UpdateSensesAny::M_aStates' has a wrong offset!");
static_assert(offsetof(UBFGDetectionPostprocessor_UpdateSensesAny, M_aAlertSensesAny) == 0x000060, "Member 'UBFGDetectionPostprocessor_UpdateSensesAny::M_aAlertSensesAny' has a wrong offset!");

// Class BFGCore.BFGDialogOptionHandler_DebugStartMenu_Entry
// 0x0050 (0x00A8 - 0x0058)
class UBFGDialogOptionHandler_DebugStartMenu_Entry final : public UBFGDialogOptionHandler_Message
{
public:
	struct FBFGDebugStartMenu_EntryData           M_Data;                                            // 0x0058(0x0050)(NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"BFGDialogOptionHandler_DebugStartMenu_Entry">();
	}
	static class UBFGDialogOptionHandler_DebugStartMenu_Entry* GetDefaultObj()
	{
		return GetDefaultObjImpl<UBFGDialogOptionHandler_DebugStartMenu_Entry>();
	}
};
static_assert(alignof(UBFGDialogOptionHandler_DebugStartMenu_Entry) == 0x000008, "Wrong alignment on UBFGDialogOptionHandler_DebugStartMenu_Entry");
static_assert(sizeof(UBFGDialogOptionHandler_DebugStartMenu_Entry) == 0x0000A8, "Wrong size on UBFGDialogOptionHandler_DebugStartMenu_Entry");
static_assert(offsetof(UBFGDialogOptionHandler_DebugStartMenu_Entry, M_Data) == 0x000058, "Member 'UBFGDialogOptionHandler_DebugStartMenu_Entry::M_Data' has a wrong offset!");

// Class BFGCore.BFGMentalAbility_Psychokinesis
// 0x0298 (0x0460 - 0x01C8)
class UBFGMentalAbility_Psychokinesis : public UBFGMentalAbilityBase
{
public:
	float                                         M_fPKDamageAmount;                                 // 0x01C8(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1CC[0x4];                                      // 0x01CC(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	TMap<EObjectWeightClass, float>               M_aWeightClassDamageModifiers;                     // 0x01D0(0x0050)(Edit, ZeroConstructor, DisableEditOnInstance, NativeAccessSpecifierPublic)
	float                                         M_fPullImpulseStrength;                            // 0x0220(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         M_fMaximumPullImpulse;                             // 0x0224(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         M_fNonMainBonePullFactor;                          // 0x0228(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         M_fNonMainBonePullFactorRandomness;                // 0x022C(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                M_vPullForceFakeGravity;                           // 0x0230(0x000C)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         M_fPKMinimumForce;                                 // 0x023C(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         M_fPKMaximumForce;                                 // 0x0240(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         M_fPKChargeTime;                                   // 0x0244(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         M_fChargeUpDelay;                                  // 0x0248(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         M_fDangerousVelocity;                              // 0x024C(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         M_fMaximumThrowTargetRange;                        // 0x0250(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         M_fMaximumDamageVelocity;                          // 0x0254(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         M_fMaximumTimeInTheAir;                            // 0x0258(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         M_fMinimumVelocityStillConsideredAsMoving;         // 0x025C(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         M_fMinimumLowMovementSpeedTime;                    // 0x0260(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         M_fCollisionRelevantForce;                         // 0x0264(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          M_bUsesContinuousCollisionDetection;               // 0x0268(0x0001)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_269[0x3];                                      // 0x0269(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         M_fPickShakeFactor;                                // 0x026C(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         M_fPickupDurationHeavy;                            // 0x0270(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          M_bDebug_ShowDamageNumbers;                        // 0x0274(0x0001)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          M_bSurfEnabled;                                    // 0x0275(0x0001)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_276[0x2];                                      // 0x0276(0x0002)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         M_fSurfSpeed;                                      // 0x0278(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         M_fStaticObjectAngularDampening;                   // 0x027C(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TMap<class AActor*, struct FThrownActorInformation> M_aThrownActorList;                                // 0x0280(0x0050)(ZeroConstructor, Transient, NativeAccessSpecifierPublic)
	UMulticastDelegateProperty_                   M_OnActorReleasedFromPK;                           // 0x02D0(0x0018)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	UMulticastDelegateProperty_                   M_OnActorAttachedToPK;                             // 0x02E8(0x0018)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	struct FGameplayTag                           M_tUpgradeTagSizeCompensationTherapy;              // 0x0300(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, DisableEditOnInstance, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FGameplayTag                           M_tUpgradeTagIntensificationTherapy;               // 0x0308(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, DisableEditOnInstance, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FGameplayTag                           M_tUpgradeTagLongDistancePituaryGlandElectrodes;   // 0x0310(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, DisableEditOnInstance, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         M_fSizeCompensationTherapy_ThrowSpeed;             // 0x0318(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         M_fSizeCompensationTherapy_DamageMultiplier;       // 0x031C(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         M_fIntensificationTherapy_ThrowSpeed;              // 0x0320(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         M_fIntensificationTherapy_DamageMultiplier;        // 0x0324(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         M_fMinDelayBetweenNoiseEvents;                     // 0x0328(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_32C[0x4];                                      // 0x032C(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	TSubclassOf<class UDamageType>                M_pFatalDamageType;                                // 0x0330(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	struct FSoftClassPath                         M_cStaticWithPhysicsBP;                            // 0x0338(0x0018)(Edit, ZeroConstructor, DisableEditOnInstance, Protected, NativeAccessSpecifierProtected)
	uint8                                         Pad_350[0x90];                                     // 0x0350(0x0090)(Fixing Size After Last Property [ Dumper-7 ])
	TMap<class AActor*, struct FBFG2DActorArrayInner> M_aHasCollidedList;                                // 0x03E0(0x0050)(ZeroConstructor, Transient, Protected, NativeAccessSpecifierProtected)
	uint8                                         Pad_430[0x18];                                     // 0x0430(0x0018)(Fixing Size After Last Property [ Dumper-7 ])
	class AActor*                                 M_pHoveredActor;                                   // 0x0448(0x0008)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_450[0x10];                                     // 0x0450(0x0010)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	class UPrimitiveComponent* GetPKAbleComponentFromActor(class AActor* _pActor);
	void OnHit(class AActor* _pSelfActor, class AActor* _pOtherActor, const struct FVector& _vNormalImpulse, const struct FHitResult& _hitResult);
	void OnObjectPickup(class AActor* PActor);
	void OnObjectReleased(class AActor* PThrownActor, bool bWasThrowOrDrop);
	void OnThrownObjectImpact(class AActor* PThrownActor, class AActor* PHitActor, const struct FHitResult& OHitResult);

	float GetCurrentChargeRatio() const;
	class AActor* GetCurrentHoveredActor() const;
	class UBFGNetworkPathAgent_AttachedEntity* GetVehicleAttachedEntity(class AActor* _pActor) const;
	bool GetWillBeThrowOrDrop() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"BFGMentalAbility_Psychokinesis">();
	}
	static class UBFGMentalAbility_Psychokinesis* GetDefaultObj()
	{
		return GetDefaultObjImpl<UBFGMentalAbility_Psychokinesis>();
	}
};
static_assert(alignof(UBFGMentalAbility_Psychokinesis) == 0x000008, "Wrong alignment on UBFGMentalAbility_Psychokinesis");
static_assert(sizeof(UBFGMentalAbility_Psychokinesis) == 0x000460, "Wrong size on UBFGMentalAbility_Psychokinesis");
static_assert(offsetof(UBFGMentalAbility_Psychokinesis, M_fPKDamageAmount) == 0x0001C8, "Member 'UBFGMentalAbility_Psychokinesis::M_fPKDamageAmount' has a wrong offset!");
static_assert(offsetof(UBFGMentalAbility_Psychokinesis, M_aWeightClassDamageModifiers) == 0x0001D0, "Member 'UBFGMentalAbility_Psychokinesis::M_aWeightClassDamageModifiers' has a wrong offset!");
static_assert(offsetof(UBFGMentalAbility_Psychokinesis, M_fPullImpulseStrength) == 0x000220, "Member 'UBFGMentalAbility_Psychokinesis::M_fPullImpulseStrength' has a wrong offset!");
static_assert(offsetof(UBFGMentalAbility_Psychokinesis, M_fMaximumPullImpulse) == 0x000224, "Member 'UBFGMentalAbility_Psychokinesis::M_fMaximumPullImpulse' has a wrong offset!");
static_assert(offsetof(UBFGMentalAbility_Psychokinesis, M_fNonMainBonePullFactor) == 0x000228, "Member 'UBFGMentalAbility_Psychokinesis::M_fNonMainBonePullFactor' has a wrong offset!");
static_assert(offsetof(UBFGMentalAbility_Psychokinesis, M_fNonMainBonePullFactorRandomness) == 0x00022C, "Member 'UBFGMentalAbility_Psychokinesis::M_fNonMainBonePullFactorRandomness' has a wrong offset!");
static_assert(offsetof(UBFGMentalAbility_Psychokinesis, M_vPullForceFakeGravity) == 0x000230, "Member 'UBFGMentalAbility_Psychokinesis::M_vPullForceFakeGravity' has a wrong offset!");
static_assert(offsetof(UBFGMentalAbility_Psychokinesis, M_fPKMinimumForce) == 0x00023C, "Member 'UBFGMentalAbility_Psychokinesis::M_fPKMinimumForce' has a wrong offset!");
static_assert(offsetof(UBFGMentalAbility_Psychokinesis, M_fPKMaximumForce) == 0x000240, "Member 'UBFGMentalAbility_Psychokinesis::M_fPKMaximumForce' has a wrong offset!");
static_assert(offsetof(UBFGMentalAbility_Psychokinesis, M_fPKChargeTime) == 0x000244, "Member 'UBFGMentalAbility_Psychokinesis::M_fPKChargeTime' has a wrong offset!");
static_assert(offsetof(UBFGMentalAbility_Psychokinesis, M_fChargeUpDelay) == 0x000248, "Member 'UBFGMentalAbility_Psychokinesis::M_fChargeUpDelay' has a wrong offset!");
static_assert(offsetof(UBFGMentalAbility_Psychokinesis, M_fDangerousVelocity) == 0x00024C, "Member 'UBFGMentalAbility_Psychokinesis::M_fDangerousVelocity' has a wrong offset!");
static_assert(offsetof(UBFGMentalAbility_Psychokinesis, M_fMaximumThrowTargetRange) == 0x000250, "Member 'UBFGMentalAbility_Psychokinesis::M_fMaximumThrowTargetRange' has a wrong offset!");
static_assert(offsetof(UBFGMentalAbility_Psychokinesis, M_fMaximumDamageVelocity) == 0x000254, "Member 'UBFGMentalAbility_Psychokinesis::M_fMaximumDamageVelocity' has a wrong offset!");
static_assert(offsetof(UBFGMentalAbility_Psychokinesis, M_fMaximumTimeInTheAir) == 0x000258, "Member 'UBFGMentalAbility_Psychokinesis::M_fMaximumTimeInTheAir' has a wrong offset!");
static_assert(offsetof(UBFGMentalAbility_Psychokinesis, M_fMinimumVelocityStillConsideredAsMoving) == 0x00025C, "Member 'UBFGMentalAbility_Psychokinesis::M_fMinimumVelocityStillConsideredAsMoving' has a wrong offset!");
static_assert(offsetof(UBFGMentalAbility_Psychokinesis, M_fMinimumLowMovementSpeedTime) == 0x000260, "Member 'UBFGMentalAbility_Psychokinesis::M_fMinimumLowMovementSpeedTime' has a wrong offset!");
static_assert(offsetof(UBFGMentalAbility_Psychokinesis, M_fCollisionRelevantForce) == 0x000264, "Member 'UBFGMentalAbility_Psychokinesis::M_fCollisionRelevantForce' has a wrong offset!");
static_assert(offsetof(UBFGMentalAbility_Psychokinesis, M_bUsesContinuousCollisionDetection) == 0x000268, "Member 'UBFGMentalAbility_Psychokinesis::M_bUsesContinuousCollisionDetection' has a wrong offset!");
static_assert(offsetof(UBFGMentalAbility_Psychokinesis, M_fPickShakeFactor) == 0x00026C, "Member 'UBFGMentalAbility_Psychokinesis::M_fPickShakeFactor' has a wrong offset!");
static_assert(offsetof(UBFGMentalAbility_Psychokinesis, M_fPickupDurationHeavy) == 0x000270, "Member 'UBFGMentalAbility_Psychokinesis::M_fPickupDurationHeavy' has a wrong offset!");
static_assert(offsetof(UBFGMentalAbility_Psychokinesis, M_bDebug_ShowDamageNumbers) == 0x000274, "Member 'UBFGMentalAbility_Psychokinesis::M_bDebug_ShowDamageNumbers' has a wrong offset!");
static_assert(offsetof(UBFGMentalAbility_Psychokinesis, M_bSurfEnabled) == 0x000275, "Member 'UBFGMentalAbility_Psychokinesis::M_bSurfEnabled' has a wrong offset!");
static_assert(offsetof(UBFGMentalAbility_Psychokinesis, M_fSurfSpeed) == 0x000278, "Member 'UBFGMentalAbility_Psychokinesis::M_fSurfSpeed' has a wrong offset!");
static_assert(offsetof(UBFGMentalAbility_Psychokinesis, M_fStaticObjectAngularDampening) == 0x00027C, "Member 'UBFGMentalAbility_Psychokinesis::M_fStaticObjectAngularDampening' has a wrong offset!");
static_assert(offsetof(UBFGMentalAbility_Psychokinesis, M_aThrownActorList) == 0x000280, "Member 'UBFGMentalAbility_Psychokinesis::M_aThrownActorList' has a wrong offset!");
static_assert(offsetof(UBFGMentalAbility_Psychokinesis, M_OnActorReleasedFromPK) == 0x0002D0, "Member 'UBFGMentalAbility_Psychokinesis::M_OnActorReleasedFromPK' has a wrong offset!");
static_assert(offsetof(UBFGMentalAbility_Psychokinesis, M_OnActorAttachedToPK) == 0x0002E8, "Member 'UBFGMentalAbility_Psychokinesis::M_OnActorAttachedToPK' has a wrong offset!");
static_assert(offsetof(UBFGMentalAbility_Psychokinesis, M_tUpgradeTagSizeCompensationTherapy) == 0x000300, "Member 'UBFGMentalAbility_Psychokinesis::M_tUpgradeTagSizeCompensationTherapy' has a wrong offset!");
static_assert(offsetof(UBFGMentalAbility_Psychokinesis, M_tUpgradeTagIntensificationTherapy) == 0x000308, "Member 'UBFGMentalAbility_Psychokinesis::M_tUpgradeTagIntensificationTherapy' has a wrong offset!");
static_assert(offsetof(UBFGMentalAbility_Psychokinesis, M_tUpgradeTagLongDistancePituaryGlandElectrodes) == 0x000310, "Member 'UBFGMentalAbility_Psychokinesis::M_tUpgradeTagLongDistancePituaryGlandElectrodes' has a wrong offset!");
static_assert(offsetof(UBFGMentalAbility_Psychokinesis, M_fSizeCompensationTherapy_ThrowSpeed) == 0x000318, "Member 'UBFGMentalAbility_Psychokinesis::M_fSizeCompensationTherapy_ThrowSpeed' has a wrong offset!");
static_assert(offsetof(UBFGMentalAbility_Psychokinesis, M_fSizeCompensationTherapy_DamageMultiplier) == 0x00031C, "Member 'UBFGMentalAbility_Psychokinesis::M_fSizeCompensationTherapy_DamageMultiplier' has a wrong offset!");
static_assert(offsetof(UBFGMentalAbility_Psychokinesis, M_fIntensificationTherapy_ThrowSpeed) == 0x000320, "Member 'UBFGMentalAbility_Psychokinesis::M_fIntensificationTherapy_ThrowSpeed' has a wrong offset!");
static_assert(offsetof(UBFGMentalAbility_Psychokinesis, M_fIntensificationTherapy_DamageMultiplier) == 0x000324, "Member 'UBFGMentalAbility_Psychokinesis::M_fIntensificationTherapy_DamageMultiplier' has a wrong offset!");
static_assert(offsetof(UBFGMentalAbility_Psychokinesis, M_fMinDelayBetweenNoiseEvents) == 0x000328, "Member 'UBFGMentalAbility_Psychokinesis::M_fMinDelayBetweenNoiseEvents' has a wrong offset!");
static_assert(offsetof(UBFGMentalAbility_Psychokinesis, M_pFatalDamageType) == 0x000330, "Member 'UBFGMentalAbility_Psychokinesis::M_pFatalDamageType' has a wrong offset!");
static_assert(offsetof(UBFGMentalAbility_Psychokinesis, M_cStaticWithPhysicsBP) == 0x000338, "Member 'UBFGMentalAbility_Psychokinesis::M_cStaticWithPhysicsBP' has a wrong offset!");
static_assert(offsetof(UBFGMentalAbility_Psychokinesis, M_aHasCollidedList) == 0x0003E0, "Member 'UBFGMentalAbility_Psychokinesis::M_aHasCollidedList' has a wrong offset!");
static_assert(offsetof(UBFGMentalAbility_Psychokinesis, M_pHoveredActor) == 0x000448, "Member 'UBFGMentalAbility_Psychokinesis::M_pHoveredActor' has a wrong offset!");

// Class BFGCore.BFGDialogOptionHandler_DebugStartMenu_MenuEntries
// 0x0058 (0x00E0 - 0x0088)
class UBFGDialogOptionHandler_DebugStartMenu_MenuEntries final : public UBFGDialogOptionHandler_SubDialogState
{
public:
	struct FBFGDebugStartMenu_EntryData           M_partialData;                                     // 0x0088(0x0050)(NativeAccessSpecifierPublic)
	EBFGDebugStartMenu_Mode                       M_menuMode;                                        // 0x00D8(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_D9[0x7];                                       // 0x00D9(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"BFGDialogOptionHandler_DebugStartMenu_MenuEntries">();
	}
	static class UBFGDialogOptionHandler_DebugStartMenu_MenuEntries* GetDefaultObj()
	{
		return GetDefaultObjImpl<UBFGDialogOptionHandler_DebugStartMenu_MenuEntries>();
	}
};
static_assert(alignof(UBFGDialogOptionHandler_DebugStartMenu_MenuEntries) == 0x000008, "Wrong alignment on UBFGDialogOptionHandler_DebugStartMenu_MenuEntries");
static_assert(sizeof(UBFGDialogOptionHandler_DebugStartMenu_MenuEntries) == 0x0000E0, "Wrong size on UBFGDialogOptionHandler_DebugStartMenu_MenuEntries");
static_assert(offsetof(UBFGDialogOptionHandler_DebugStartMenu_MenuEntries, M_partialData) == 0x000088, "Member 'UBFGDialogOptionHandler_DebugStartMenu_MenuEntries::M_partialData' has a wrong offset!");
static_assert(offsetof(UBFGDialogOptionHandler_DebugStartMenu_MenuEntries, M_menuMode) == 0x0000D8, "Member 'UBFGDialogOptionHandler_DebugStartMenu_MenuEntries::M_menuMode' has a wrong offset!");

// Class BFGCore.BFGLevelMissions
// 0x0020 (0x03F8 - 0x03D8)
class ABFGLevelMissions final : public AActor
{
public:
	TArray<class UBFGMissionGroup*>               M_aMissionGroups;                                  // 0x03D8(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, NativeAccessSpecifierPublic)
	TArray<class UBFGMissionGroup*>               M_aRuntimeMissionGroups;                           // 0x03E8(0x0010)(ExportObject, ZeroConstructor, Transient, ContainsInstancedReference, NativeAccessSpecifierPrivate)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"BFGLevelMissions">();
	}
	static class ABFGLevelMissions* GetDefaultObj()
	{
		return GetDefaultObjImpl<ABFGLevelMissions>();
	}
};
static_assert(alignof(ABFGLevelMissions) == 0x000008, "Wrong alignment on ABFGLevelMissions");
static_assert(sizeof(ABFGLevelMissions) == 0x0003F8, "Wrong size on ABFGLevelMissions");
static_assert(offsetof(ABFGLevelMissions, M_aMissionGroups) == 0x0003D8, "Member 'ABFGLevelMissions::M_aMissionGroups' has a wrong offset!");
static_assert(offsetof(ABFGLevelMissions, M_aRuntimeMissionGroups) == 0x0003E8, "Member 'ABFGLevelMissions::M_aRuntimeMissionGroups' has a wrong offset!");

// Class BFGCore.BFGDialogOptionHandler_Savegame
// 0x0030 (0x0080 - 0x0050)
class UBFGDialogOptionHandler_Savegame final : public UBFGDialogOptionHandler_Base
{
public:
	TSoftClassPtr<class UClass>                   M_pDialogStateClass;                               // 0x0050(0x0028)(Edit, BlueprintVisible, BlueprintReadOnly, DisableEditOnInstance, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TWeakObjectPtr<class UBFGGameFlowState_DialogPickSavegame> M_pDialogState;                                    // 0x0078(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)

public:
	void OnDialogMessage(EBFGDialogMessage _eMessage);
	void OnSavegameSlotPicked(int32 _iIndex, EBFGDialogOptionHandler_SavegameSlotMode _eSlotMode);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"BFGDialogOptionHandler_Savegame">();
	}
	static class UBFGDialogOptionHandler_Savegame* GetDefaultObj()
	{
		return GetDefaultObjImpl<UBFGDialogOptionHandler_Savegame>();
	}
};
static_assert(alignof(UBFGDialogOptionHandler_Savegame) == 0x000008, "Wrong alignment on UBFGDialogOptionHandler_Savegame");
static_assert(sizeof(UBFGDialogOptionHandler_Savegame) == 0x000080, "Wrong size on UBFGDialogOptionHandler_Savegame");
static_assert(offsetof(UBFGDialogOptionHandler_Savegame, M_pDialogStateClass) == 0x000050, "Member 'UBFGDialogOptionHandler_Savegame::M_pDialogStateClass' has a wrong offset!");
static_assert(offsetof(UBFGDialogOptionHandler_Savegame, M_pDialogState) == 0x000078, "Member 'UBFGDialogOptionHandler_Savegame::M_pDialogState' has a wrong offset!");

// Class BFGCore.BFGDLCSettings
// 0x0010 (0x0048 - 0x0038)
class UBFGDLCSettings final : public UDeveloperSettings
{
public:
	TArray<struct FBFGDLCLayout>                  M_aDLCData;                                        // 0x0038(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Config, DisableEditOnInstance, GlobalConfig, NativeAccessSpecifierPublic)

public:
	static class UBFGDLCSettings* GetSettings();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"BFGDLCSettings">();
	}
	static class UBFGDLCSettings* GetDefaultObj()
	{
		return GetDefaultObjImpl<UBFGDLCSettings>();
	}
};
static_assert(alignof(UBFGDLCSettings) == 0x000008, "Wrong alignment on UBFGDLCSettings");
static_assert(sizeof(UBFGDLCSettings) == 0x000048, "Wrong size on UBFGDLCSettings");
static_assert(offsetof(UBFGDLCSettings, M_aDLCData) == 0x000038, "Member 'UBFGDLCSettings::M_aDLCData' has a wrong offset!");

// Class BFGCore.BFGDynamicObstaclePool_Box
// 0x0020 (0x0048 - 0x0028)
class UBFGDynamicObstaclePool_Box final : public UObject
{
public:
	TArray<class ABFGDynamicObstacle_Box*>        M_aLockedInstances;                                // 0x0028(0x0010)(ZeroConstructor, Protected, NativeAccessSpecifierProtected)
	TArray<class ABFGDynamicObstacle_Box*>        M_aReleasedInstances;                              // 0x0038(0x0010)(ZeroConstructor, Protected, NativeAccessSpecifierProtected)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"BFGDynamicObstaclePool_Box">();
	}
	static class UBFGDynamicObstaclePool_Box* GetDefaultObj()
	{
		return GetDefaultObjImpl<UBFGDynamicObstaclePool_Box>();
	}
};
static_assert(alignof(UBFGDynamicObstaclePool_Box) == 0x000008, "Wrong alignment on UBFGDynamicObstaclePool_Box");
static_assert(sizeof(UBFGDynamicObstaclePool_Box) == 0x000048, "Wrong size on UBFGDynamicObstaclePool_Box");
static_assert(offsetof(UBFGDynamicObstaclePool_Box, M_aLockedInstances) == 0x000028, "Member 'UBFGDynamicObstaclePool_Box::M_aLockedInstances' has a wrong offset!");
static_assert(offsetof(UBFGDynamicObstaclePool_Box, M_aReleasedInstances) == 0x000038, "Member 'UBFGDynamicObstaclePool_Box::M_aReleasedInstances' has a wrong offset!");

// Class BFGCore.BFGData_MenuFactoryEntry
// 0x0030 (0x0060 - 0x0030)
class UBFGData_MenuFactoryEntry final : public UDataAsset
{
public:
	class FName                                   M_name;                                            // 0x0030(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TSoftClassPtr<class UClass>                   M_pClassReference;                                 // 0x0038(0x0028)(Edit, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"BFGData_MenuFactoryEntry">();
	}
	static class UBFGData_MenuFactoryEntry* GetDefaultObj()
	{
		return GetDefaultObjImpl<UBFGData_MenuFactoryEntry>();
	}
};
static_assert(alignof(UBFGData_MenuFactoryEntry) == 0x000008, "Wrong alignment on UBFGData_MenuFactoryEntry");
static_assert(sizeof(UBFGData_MenuFactoryEntry) == 0x000060, "Wrong size on UBFGData_MenuFactoryEntry");
static_assert(offsetof(UBFGData_MenuFactoryEntry, M_name) == 0x000030, "Member 'UBFGData_MenuFactoryEntry::M_name' has a wrong offset!");
static_assert(offsetof(UBFGData_MenuFactoryEntry, M_pClassReference) == 0x000038, "Member 'UBFGData_MenuFactoryEntry::M_pClassReference' has a wrong offset!");

// Class BFGCore.BFGDynamicObstaclePool_Sphere
// 0x0038 (0x0060 - 0x0028)
class UBFGDynamicObstaclePool_Sphere final : public UObject
{
public:
	UMulticastDelegateProperty_                   M_OnInstanceObtained;                              // 0x0028(0x0018)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	TArray<class ABFGDynamicObstacle_Sphere*>     M_aLockedInstances;                                // 0x0040(0x0010)(ZeroConstructor, Protected, NativeAccessSpecifierProtected)
	TArray<class ABFGDynamicObstacle_Sphere*>     M_aReleasedInstances;                              // 0x0050(0x0010)(ZeroConstructor, Protected, NativeAccessSpecifierProtected)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"BFGDynamicObstaclePool_Sphere">();
	}
	static class UBFGDynamicObstaclePool_Sphere* GetDefaultObj()
	{
		return GetDefaultObjImpl<UBFGDynamicObstaclePool_Sphere>();
	}
};
static_assert(alignof(UBFGDynamicObstaclePool_Sphere) == 0x000008, "Wrong alignment on UBFGDynamicObstaclePool_Sphere");
static_assert(sizeof(UBFGDynamicObstaclePool_Sphere) == 0x000060, "Wrong size on UBFGDynamicObstaclePool_Sphere");
static_assert(offsetof(UBFGDynamicObstaclePool_Sphere, M_OnInstanceObtained) == 0x000028, "Member 'UBFGDynamicObstaclePool_Sphere::M_OnInstanceObtained' has a wrong offset!");
static_assert(offsetof(UBFGDynamicObstaclePool_Sphere, M_aLockedInstances) == 0x000040, "Member 'UBFGDynamicObstaclePool_Sphere::M_aLockedInstances' has a wrong offset!");
static_assert(offsetof(UBFGDynamicObstaclePool_Sphere, M_aReleasedInstances) == 0x000050, "Member 'UBFGDynamicObstaclePool_Sphere::M_aReleasedInstances' has a wrong offset!");

// Class BFGCore.BFGMentalAbility_CortexScan
// 0x0080 (0x0248 - 0x01C8)
class UBFGMentalAbility_CortexScan : public UBFGMentalAbilityBase
{
public:
	struct FGameplayTag                           M_tUpgradeTagNeocorticalAnalyzer;                  // 0x01C8(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, DisableEditOnInstance, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FGameplayTag                           M_tUpgradeTagCorticalVictimizer;                   // 0x01D0(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, DisableEditOnInstance, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FGameplayTag                           M_tUpgradeTagCorticalAntagonizer;                  // 0x01D8(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, DisableEditOnInstance, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         M_fNeocorticalAnalyzer_ExtraConcentration;         // 0x01E0(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FGameplayTag                           M_oCivilianTag;                                    // 0x01E4(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, DisableEditOnInstance, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         M_fCorticalVictimizer_ExtraConcentration;          // 0x01EC(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FGameplayTag                           M_oEnemyTag;                                       // 0x01F0(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, DisableEditOnInstance, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         M_fCorticalAntagonizer_ExtraConcentration;         // 0x01F8(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1FC[0x4];                                      // 0x01FC(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	TSoftObjectPtr<class UBFGDataAsset_CortexScan> M_oSilencedResponseSetSoft;                        // 0x0200(0x0028)(Edit, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UBFGCortexScanResponseSet*              M_pSilencedResponseSet;                            // 0x0228(0x0008)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UBFGMentalAbility_Holobob*              M_pHolobob;                                        // 0x0230(0x0008)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_238[0x10];                                     // 0x0238(0x0010)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"BFGMentalAbility_CortexScan">();
	}
	static class UBFGMentalAbility_CortexScan* GetDefaultObj()
	{
		return GetDefaultObjImpl<UBFGMentalAbility_CortexScan>();
	}
};
static_assert(alignof(UBFGMentalAbility_CortexScan) == 0x000008, "Wrong alignment on UBFGMentalAbility_CortexScan");
static_assert(sizeof(UBFGMentalAbility_CortexScan) == 0x000248, "Wrong size on UBFGMentalAbility_CortexScan");
static_assert(offsetof(UBFGMentalAbility_CortexScan, M_tUpgradeTagNeocorticalAnalyzer) == 0x0001C8, "Member 'UBFGMentalAbility_CortexScan::M_tUpgradeTagNeocorticalAnalyzer' has a wrong offset!");
static_assert(offsetof(UBFGMentalAbility_CortexScan, M_tUpgradeTagCorticalVictimizer) == 0x0001D0, "Member 'UBFGMentalAbility_CortexScan::M_tUpgradeTagCorticalVictimizer' has a wrong offset!");
static_assert(offsetof(UBFGMentalAbility_CortexScan, M_tUpgradeTagCorticalAntagonizer) == 0x0001D8, "Member 'UBFGMentalAbility_CortexScan::M_tUpgradeTagCorticalAntagonizer' has a wrong offset!");
static_assert(offsetof(UBFGMentalAbility_CortexScan, M_fNeocorticalAnalyzer_ExtraConcentration) == 0x0001E0, "Member 'UBFGMentalAbility_CortexScan::M_fNeocorticalAnalyzer_ExtraConcentration' has a wrong offset!");
static_assert(offsetof(UBFGMentalAbility_CortexScan, M_oCivilianTag) == 0x0001E4, "Member 'UBFGMentalAbility_CortexScan::M_oCivilianTag' has a wrong offset!");
static_assert(offsetof(UBFGMentalAbility_CortexScan, M_fCorticalVictimizer_ExtraConcentration) == 0x0001EC, "Member 'UBFGMentalAbility_CortexScan::M_fCorticalVictimizer_ExtraConcentration' has a wrong offset!");
static_assert(offsetof(UBFGMentalAbility_CortexScan, M_oEnemyTag) == 0x0001F0, "Member 'UBFGMentalAbility_CortexScan::M_oEnemyTag' has a wrong offset!");
static_assert(offsetof(UBFGMentalAbility_CortexScan, M_fCorticalAntagonizer_ExtraConcentration) == 0x0001F8, "Member 'UBFGMentalAbility_CortexScan::M_fCorticalAntagonizer_ExtraConcentration' has a wrong offset!");
static_assert(offsetof(UBFGMentalAbility_CortexScan, M_oSilencedResponseSetSoft) == 0x000200, "Member 'UBFGMentalAbility_CortexScan::M_oSilencedResponseSetSoft' has a wrong offset!");
static_assert(offsetof(UBFGMentalAbility_CortexScan, M_pSilencedResponseSet) == 0x000228, "Member 'UBFGMentalAbility_CortexScan::M_pSilencedResponseSet' has a wrong offset!");
static_assert(offsetof(UBFGMentalAbility_CortexScan, M_pHolobob) == 0x000230, "Member 'UBFGMentalAbility_CortexScan::M_pHolobob' has a wrong offset!");

// Class BFGCore.BFGDynamicStaticObjectManager
// 0x00D0 (0x0100 - 0x0030)
class UBFGDynamicStaticObjectManager : public UBFGGameSystem
{
public:
	TArray<class ABFGProjectile_Object*>          M_aProjectileList;                                 // 0x0030(0x0010)(ZeroConstructor, Transient, NativeAccessSpecifierPublic)
	uint8                                         Pad_40[0x4];                                       // 0x0040(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         M_fOffScreenRemoveTimeThreshhold;                  // 0x0044(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	int32                                         M_iMaximumActiveObjectCount;                       // 0x0048(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         M_fPrematureDeletionRange;                         // 0x004C(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         M_fPrematureDeletionVelocity;                      // 0x0050(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_54[0x4];                                       // 0x0054(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	struct FSoftClassPath                         M_cStaticWithPhysicsBP;                            // 0x0058(0x0018)(Edit, ZeroConstructor, DisableEditOnInstance, Protected, NativeAccessSpecifierProtected)
	float                                         M_fCollisionFrequency;                             // 0x0070(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	struct FGameplayTag                           M_DontRespawnGamepayTag;                           // 0x0074(0x0008)(Edit, DisableEditOnInstance, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_7C[0x4];                                       // 0x007C(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class UClass*                                 M_pCachedStaticWithPhysicsBP;                      // 0x0080(0x0008)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TArray<struct FBFGActiveDynamicObjectData>    M_aActiveObjectList;                               // 0x0088(0x0010)(ZeroConstructor, Transient, Protected, NativeAccessSpecifierProtected)
	class ABFGGameState*                          M_pGameState;                                      // 0x0098(0x0008)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TMap<class AActor*, struct FBFGCollisionEvent> M_aLatestCollisionEvents;                          // 0x00A0(0x0050)(ZeroConstructor, Transient, Protected, NativeAccessSpecifierProtected)
	TArray<struct FBFGDeferredActorActivationEntry> M_aDeferredActivations;                            // 0x00F0(0x0010)(ZeroConstructor, Transient, Protected, NativeAccessSpecifierProtected)

public:
	void ForceDeletionOfObject(class ABFGObject_StaticWithPhysics* _pObject);
	void ForceDeletionOfObjectsInBounds(struct FVector* _vOrigin, struct FVector* _vExtend);
	void OnRelevantActorCollision(class AActor* HitActor, class AActor* CollidingActor, const struct FHitResult& Hit, float Velocity);
	void SetForceObjectToStayAlive(class ABFGObject_StaticWithPhysics* _pObject, bool _bForceStayAlive);
	class ABFGObject_StaticWithPhysics* SwapActorWithDynamic(class AStaticMeshActor* _pOldActor, bool _bForceActive);
	class ABFGObject_StaticWithPhysics* SwapComponentWithDynamic(class UStaticMeshComponent* _pOldComponent, const struct FTransform& _tTransform, bool _bForceActive);

	int32 GetCurrentActiveObjectCount() const;
	int32 GetForcedActiveObjectCount() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"BFGDynamicStaticObjectManager">();
	}
	static class UBFGDynamicStaticObjectManager* GetDefaultObj()
	{
		return GetDefaultObjImpl<UBFGDynamicStaticObjectManager>();
	}
};
static_assert(alignof(UBFGDynamicStaticObjectManager) == 0x000008, "Wrong alignment on UBFGDynamicStaticObjectManager");
static_assert(sizeof(UBFGDynamicStaticObjectManager) == 0x000100, "Wrong size on UBFGDynamicStaticObjectManager");
static_assert(offsetof(UBFGDynamicStaticObjectManager, M_aProjectileList) == 0x000030, "Member 'UBFGDynamicStaticObjectManager::M_aProjectileList' has a wrong offset!");
static_assert(offsetof(UBFGDynamicStaticObjectManager, M_fOffScreenRemoveTimeThreshhold) == 0x000044, "Member 'UBFGDynamicStaticObjectManager::M_fOffScreenRemoveTimeThreshhold' has a wrong offset!");
static_assert(offsetof(UBFGDynamicStaticObjectManager, M_iMaximumActiveObjectCount) == 0x000048, "Member 'UBFGDynamicStaticObjectManager::M_iMaximumActiveObjectCount' has a wrong offset!");
static_assert(offsetof(UBFGDynamicStaticObjectManager, M_fPrematureDeletionRange) == 0x00004C, "Member 'UBFGDynamicStaticObjectManager::M_fPrematureDeletionRange' has a wrong offset!");
static_assert(offsetof(UBFGDynamicStaticObjectManager, M_fPrematureDeletionVelocity) == 0x000050, "Member 'UBFGDynamicStaticObjectManager::M_fPrematureDeletionVelocity' has a wrong offset!");
static_assert(offsetof(UBFGDynamicStaticObjectManager, M_cStaticWithPhysicsBP) == 0x000058, "Member 'UBFGDynamicStaticObjectManager::M_cStaticWithPhysicsBP' has a wrong offset!");
static_assert(offsetof(UBFGDynamicStaticObjectManager, M_fCollisionFrequency) == 0x000070, "Member 'UBFGDynamicStaticObjectManager::M_fCollisionFrequency' has a wrong offset!");
static_assert(offsetof(UBFGDynamicStaticObjectManager, M_DontRespawnGamepayTag) == 0x000074, "Member 'UBFGDynamicStaticObjectManager::M_DontRespawnGamepayTag' has a wrong offset!");
static_assert(offsetof(UBFGDynamicStaticObjectManager, M_pCachedStaticWithPhysicsBP) == 0x000080, "Member 'UBFGDynamicStaticObjectManager::M_pCachedStaticWithPhysicsBP' has a wrong offset!");
static_assert(offsetof(UBFGDynamicStaticObjectManager, M_aActiveObjectList) == 0x000088, "Member 'UBFGDynamicStaticObjectManager::M_aActiveObjectList' has a wrong offset!");
static_assert(offsetof(UBFGDynamicStaticObjectManager, M_pGameState) == 0x000098, "Member 'UBFGDynamicStaticObjectManager::M_pGameState' has a wrong offset!");
static_assert(offsetof(UBFGDynamicStaticObjectManager, M_aLatestCollisionEvents) == 0x0000A0, "Member 'UBFGDynamicStaticObjectManager::M_aLatestCollisionEvents' has a wrong offset!");
static_assert(offsetof(UBFGDynamicStaticObjectManager, M_aDeferredActivations) == 0x0000F0, "Member 'UBFGDynamicStaticObjectManager::M_aDeferredActivations' has a wrong offset!");

// Class BFGCore.BFGEffectActor_FallingLeaves
// 0x0010 (0x0458 - 0x0448)
class ABFGEffectActor_FallingLeaves final : public ABFGEffectActor
{
public:
	struct FVector                                M_vParticleSize;                                   // 0x0448(0x000C)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         M_fRateOfParticle;                                 // 0x0454(0x0004)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

public:
	void UpdateParticle();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"BFGEffectActor_FallingLeaves">();
	}
	static class ABFGEffectActor_FallingLeaves* GetDefaultObj()
	{
		return GetDefaultObjImpl<ABFGEffectActor_FallingLeaves>();
	}
};
static_assert(alignof(ABFGEffectActor_FallingLeaves) == 0x000008, "Wrong alignment on ABFGEffectActor_FallingLeaves");
static_assert(sizeof(ABFGEffectActor_FallingLeaves) == 0x000458, "Wrong size on ABFGEffectActor_FallingLeaves");
static_assert(offsetof(ABFGEffectActor_FallingLeaves, M_vParticleSize) == 0x000448, "Member 'ABFGEffectActor_FallingLeaves::M_vParticleSize' has a wrong offset!");
static_assert(offsetof(ABFGEffectActor_FallingLeaves, M_fRateOfParticle) == 0x000454, "Member 'ABFGEffectActor_FallingLeaves::M_fRateOfParticle' has a wrong offset!");

// Class BFGCore.BFGShockwave
// 0x00D8 (0x04B0 - 0x03D8)
class ABFGShockwave : public AActor
{
public:
	uint8                                         Pad_3D8[0x8];                                      // 0x03D8(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	UMulticastDelegateProperty_                   M_oShockWaveTriggered;                             // 0x03E0(0x0018)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	UMulticastDelegateProperty_                   M_oShockWaveStopped;                               // 0x03F8(0x0018)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	class UProjectileMovementComponent*           M_pMovementComponent;                              // 0x0410(0x0008)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, EditConst, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UBFGActorComponent_Effect*              M_pEffectComponent;                                // 0x0418(0x0008)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, EditConst, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         M_fShockwaveRadius;                                // 0x0420(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_424[0x4];                                      // 0x0424(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	TMap<EObjectWeightClass, float>               M_aWeightClassImpulseStrength;                     // 0x0428(0x0050)(Edit, ZeroConstructor, DisableEditOnInstance, Protected, NativeAccessSpecifierProtected)
	float                                         M_fMaxDistance;                                    // 0x0478(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         M_fDestroyDelay;                                   // 0x047C(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_480[0x18];                                     // 0x0480(0x0018)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<class AActor*>                         M_apImpactedActors;                                // 0x0498(0x0010)(ZeroConstructor, Transient, Protected, NativeAccessSpecifierProtected)
	uint8                                         Pad_4A8[0x1];                                      // 0x04A8(0x0001)(Fixing Size After Last Property [ Dumper-7 ])
	EBFGFaction                                   M_eFaction;                                        // 0x04A9(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_4AA[0x6];                                      // 0x04AA(0x0006)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"BFGShockwave">();
	}
	static class ABFGShockwave* GetDefaultObj()
	{
		return GetDefaultObjImpl<ABFGShockwave>();
	}
};
static_assert(alignof(ABFGShockwave) == 0x000008, "Wrong alignment on ABFGShockwave");
static_assert(sizeof(ABFGShockwave) == 0x0004B0, "Wrong size on ABFGShockwave");
static_assert(offsetof(ABFGShockwave, M_oShockWaveTriggered) == 0x0003E0, "Member 'ABFGShockwave::M_oShockWaveTriggered' has a wrong offset!");
static_assert(offsetof(ABFGShockwave, M_oShockWaveStopped) == 0x0003F8, "Member 'ABFGShockwave::M_oShockWaveStopped' has a wrong offset!");
static_assert(offsetof(ABFGShockwave, M_pMovementComponent) == 0x000410, "Member 'ABFGShockwave::M_pMovementComponent' has a wrong offset!");
static_assert(offsetof(ABFGShockwave, M_pEffectComponent) == 0x000418, "Member 'ABFGShockwave::M_pEffectComponent' has a wrong offset!");
static_assert(offsetof(ABFGShockwave, M_fShockwaveRadius) == 0x000420, "Member 'ABFGShockwave::M_fShockwaveRadius' has a wrong offset!");
static_assert(offsetof(ABFGShockwave, M_aWeightClassImpulseStrength) == 0x000428, "Member 'ABFGShockwave::M_aWeightClassImpulseStrength' has a wrong offset!");
static_assert(offsetof(ABFGShockwave, M_fMaxDistance) == 0x000478, "Member 'ABFGShockwave::M_fMaxDistance' has a wrong offset!");
static_assert(offsetof(ABFGShockwave, M_fDestroyDelay) == 0x00047C, "Member 'ABFGShockwave::M_fDestroyDelay' has a wrong offset!");
static_assert(offsetof(ABFGShockwave, M_apImpactedActors) == 0x000498, "Member 'ABFGShockwave::M_apImpactedActors' has a wrong offset!");
static_assert(offsetof(ABFGShockwave, M_eFaction) == 0x0004A9, "Member 'ABFGShockwave::M_eFaction' has a wrong offset!");

// Class BFGCore.BFGEffectActor_ForceField
// 0x0008 (0x0450 - 0x0448)
class ABFGEffectActor_ForceField : public ABFGEffectActor
{
public:
	int32                                         M_iSlotCount;                                      // 0x0448(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_44C[0x4];                                      // 0x044C(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void OnTriggerEffectSlot(int32 _iSlot);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"BFGEffectActor_ForceField">();
	}
	static class ABFGEffectActor_ForceField* GetDefaultObj()
	{
		return GetDefaultObjImpl<ABFGEffectActor_ForceField>();
	}
};
static_assert(alignof(ABFGEffectActor_ForceField) == 0x000008, "Wrong alignment on ABFGEffectActor_ForceField");
static_assert(sizeof(ABFGEffectActor_ForceField) == 0x000450, "Wrong size on ABFGEffectActor_ForceField");
static_assert(offsetof(ABFGEffectActor_ForceField, M_iSlotCount) == 0x000448, "Member 'ABFGEffectActor_ForceField::M_iSlotCount' has a wrong offset!");

// Class BFGCore.BFGEffectActor_ProjectileImpact
// 0x0000 (0x0448 - 0x0448)
class ABFGEffectActor_ProjectileImpact : public ABFGEffectActor
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"BFGEffectActor_ProjectileImpact">();
	}
	static class ABFGEffectActor_ProjectileImpact* GetDefaultObj()
	{
		return GetDefaultObjImpl<ABFGEffectActor_ProjectileImpact>();
	}
};
static_assert(alignof(ABFGEffectActor_ProjectileImpact) == 0x000008, "Wrong alignment on ABFGEffectActor_ProjectileImpact");
static_assert(sizeof(ABFGEffectActor_ProjectileImpact) == 0x000448, "Wrong size on ABFGEffectActor_ProjectileImpact");

// Class BFGCore.BFGEffectBank
// 0x0010 (0x0038 - 0x0028)
class UBFGEffectBank final : public UObject
{
public:
	TArray<struct FBFGEffectBankEntry>            M_aEntries;                                        // 0x0028(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, Protected, NativeAccessSpecifierProtected)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"BFGEffectBank">();
	}
	static class UBFGEffectBank* GetDefaultObj()
	{
		return GetDefaultObjImpl<UBFGEffectBank>();
	}
};
static_assert(alignof(UBFGEffectBank) == 0x000008, "Wrong alignment on UBFGEffectBank");
static_assert(sizeof(UBFGEffectBank) == 0x000038, "Wrong size on UBFGEffectBank");
static_assert(offsetof(UBFGEffectBank, M_aEntries) == 0x000028, "Member 'UBFGEffectBank::M_aEntries' has a wrong offset!");

// Class BFGCore.BFGGameFlowState_IIS
// 0x0000 (0x0108 - 0x0108)
class UBFGGameFlowState_IIS final : public UBFGGameFlowState_GenericDialog_Customizable
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"BFGGameFlowState_IIS">();
	}
	static class UBFGGameFlowState_IIS* GetDefaultObj()
	{
		return GetDefaultObjImpl<UBFGGameFlowState_IIS>();
	}
};
static_assert(alignof(UBFGGameFlowState_IIS) == 0x000008, "Wrong alignment on UBFGGameFlowState_IIS");
static_assert(sizeof(UBFGGameFlowState_IIS) == 0x000108, "Wrong size on UBFGGameFlowState_IIS");

// Class BFGCore.BFGEffectBlackboard
// 0x04F0 (0x0518 - 0x0028)
class UBFGEffectBlackboard final : public UObject
{
public:
	uint8                                         Pad_28[0xD0];                                      // 0x0028(0x00D0)(Fixing Size After Last Property [ Dumper-7 ])
	class UBFGActorComponent_Effect*              M_pEffectComponent;                                // 0x00F8(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TMap<class FName, struct FBFGEffectBlackboardParameterSlots_Float> M_aFloatValues;                                    // 0x0100(0x0050)(ZeroConstructor, Protected, NativeAccessSpecifierProtected)
	TMap<class FName, struct FBFGEffectBlackboardParameterSlots_RandFloat> M_aRandFloatValues;                                // 0x0150(0x0050)(ZeroConstructor, Protected, NativeAccessSpecifierProtected)
	TMap<class FName, struct FBFGEffectBlackboardParameterSlots_Vector> M_aVectorValues;                                   // 0x01A0(0x0050)(ZeroConstructor, Protected, NativeAccessSpecifierProtected)
	TMap<class FName, struct FBFGEffectBlackboardParameterSlots_RandVector> M_aRandVectorValues;                               // 0x01F0(0x0050)(ZeroConstructor, Protected, NativeAccessSpecifierProtected)
	TMap<class FName, struct FBFGEffectBlackboardParameterSlots_Rotator> M_aRotatorValues;                                  // 0x0240(0x0050)(ZeroConstructor, Protected, NativeAccessSpecifierProtected)
	TMap<class FName, struct FBFGEffectBlackboardParameterSlots_Color> M_aColorValues;                                    // 0x0290(0x0050)(ZeroConstructor, Protected, NativeAccessSpecifierProtected)
	TMap<class FName, struct FBFGEffectBlackboardParameterSlots_Bool> M_aBoolValues;                                     // 0x02E0(0x0050)(ZeroConstructor, Protected, NativeAccessSpecifierProtected)
	TMap<class FName, struct FBFGEffectBlackboardParameterSlots_Int> M_aIntValues;                                      // 0x0330(0x0050)(ZeroConstructor, Protected, NativeAccessSpecifierProtected)
	TMap<class FName, struct FBFGEffectBlackboardParameterSlots_Actor> M_aActorValues;                                    // 0x0380(0x0050)(ZeroConstructor, Protected, NativeAccessSpecifierProtected)
	TMap<class FName, struct FBFGEffectBlackboardParameterSlots_Object> M_aObjectValues;                                   // 0x03D0(0x0050)(ZeroConstructor, Protected, NativeAccessSpecifierProtected)
	TMap<class FName, struct FBFGEffectBlackboardParameterSlots_ActorComponent> M_aActorComponentValues;                           // 0x0420(0x0050)(ZeroConstructor, ContainsInstancedReference, Protected, NativeAccessSpecifierProtected)
	TMap<class FName, struct FBFGEffectBlackboardParameterSlots_Name> M_aNameValues;                                     // 0x0470(0x0050)(ZeroConstructor, Protected, NativeAccessSpecifierProtected)
	TMap<class FName, struct FBFGEffectBlackboardParameterSlots_DataTable> M_aDataTableValues;                                // 0x04C0(0x0050)(ZeroConstructor, Protected, NativeAccessSpecifierProtected)
	int32                                         M_iNextSlotIndex;                                  // 0x0510(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_514[0x4];                                      // 0x0514(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	int32 ComputeFreeSlot();
	bool HasActorComponentSlot(const class FName _rName, int32 _iSlot);
	bool HasActorSlot(const class FName _rName, int32 _iSlot);
	bool HasBoolSlot(const class FName _rName, int32 _iSlot);
	bool HasColorSlot(const class FName _rName, int32 _iSlot);
	bool HasDataTableSlot(const class FName _rName, int32 _iSlot);
	bool HasFloatSlot(const class FName _rName, int32 _iSlot);
	bool HasIntSlot(const class FName _rName, int32 _iSlot);
	bool HasNameSlot(const class FName _rName, int32 _iSlot);
	bool HasObjectSlot(const class FName _rName, int32 _iSlot);
	bool HasRandFloatSlot(const class FName _rName, int32 _iSlot);
	bool HasRandVectorSlot(const class FName _rName, int32 _iSlot);
	bool HasRotatorSlot(const class FName _rName, int32 _iSlot);
	bool HasVectorSlot(const class FName _rName, int32 _iSlot);
	void SetActor(const class FName _rName, class AActor* _iValue, int32 _iSlot);
	void SetActorComponent(const class FName _rName, class UActorComponent* _pComponent, int32 _iSlot);
	void SetBool(const class FName _rName, bool _bValue, int32 _iSlot);
	void SetColor(const class FName _rName, const struct FColor& _rValue, int32 _iSlot);
	void SetDataTable(const class FName _rName, class UDataTable* _pValue, int32 _iSlot);
	void SetFloat(const class FName _rName, float _fValue, int32 _iSlot);
	void SetInt(const class FName _rName, int32 _iValue, int32 _iSlot);
	void SetName(const class FName _rName, class FName _iValue, int32 _iSlot);
	void SetObject(const class FName _rName, class UObject* _pValue, int32 _iSlot);
	void SetRandFloat(const class FName _rName, float _fMin, float _fMax, int32 _iSlot);
	void SetRandVector(const class FName _rName, const struct FVector& _rMin, const struct FVector& _rMax, int32 _iSlot);
	void SetRotator(const class FName _rName, const struct FRotator& _rValue, int32 _iSlot);
	void SetVector(const class FName _rName, const struct FVector& _rValue, int32 _iSlot);

	class AActor* GetActor(const class FName _rName, int32 _iSlot) const;
	class UActorComponent* GetActorComponent(const class FName _rName, int32 _iSlot) const;
	bool GetBool(const class FName _rName, int32 _iSlot) const;
	struct FColor GetColor(const class FName _rName, int32 _iSlot) const;
	class UDataTable* GetDataTable(const class FName _rName, int32 _iSlot) const;
	class UBFGActorComponent_Effect* GetEffectComponent() const;
	float GetFloat(const class FName _rName, int32 _iSlot) const;
	int32 GetInt(const class FName _rName, int32 _iSlot) const;
	class FName GetName(const class FName _rName, int32 _iSlot) const;
	class UObject* GetObject(const class FName _rName, int32 _iSlot) const;
	struct FBFGEffectBlackboardParameter_RandFloat GetRandFloat(const class FName _rName, int32 _iSlot) const;
	struct FBFGEffectBlackboardParameter_RandVector GetRandVector(const class FName _rName, int32 _iSlot) const;
	struct FRotator GetRotator(const class FName _rName, int32 _iSlot) const;
	struct FVector GetVector(const class FName _rName, int32 _iSlot) const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"BFGEffectBlackboard">();
	}
	static class UBFGEffectBlackboard* GetDefaultObj()
	{
		return GetDefaultObjImpl<UBFGEffectBlackboard>();
	}
};
static_assert(alignof(UBFGEffectBlackboard) == 0x000008, "Wrong alignment on UBFGEffectBlackboard");
static_assert(sizeof(UBFGEffectBlackboard) == 0x000518, "Wrong size on UBFGEffectBlackboard");
static_assert(offsetof(UBFGEffectBlackboard, M_pEffectComponent) == 0x0000F8, "Member 'UBFGEffectBlackboard::M_pEffectComponent' has a wrong offset!");
static_assert(offsetof(UBFGEffectBlackboard, M_aFloatValues) == 0x000100, "Member 'UBFGEffectBlackboard::M_aFloatValues' has a wrong offset!");
static_assert(offsetof(UBFGEffectBlackboard, M_aRandFloatValues) == 0x000150, "Member 'UBFGEffectBlackboard::M_aRandFloatValues' has a wrong offset!");
static_assert(offsetof(UBFGEffectBlackboard, M_aVectorValues) == 0x0001A0, "Member 'UBFGEffectBlackboard::M_aVectorValues' has a wrong offset!");
static_assert(offsetof(UBFGEffectBlackboard, M_aRandVectorValues) == 0x0001F0, "Member 'UBFGEffectBlackboard::M_aRandVectorValues' has a wrong offset!");
static_assert(offsetof(UBFGEffectBlackboard, M_aRotatorValues) == 0x000240, "Member 'UBFGEffectBlackboard::M_aRotatorValues' has a wrong offset!");
static_assert(offsetof(UBFGEffectBlackboard, M_aColorValues) == 0x000290, "Member 'UBFGEffectBlackboard::M_aColorValues' has a wrong offset!");
static_assert(offsetof(UBFGEffectBlackboard, M_aBoolValues) == 0x0002E0, "Member 'UBFGEffectBlackboard::M_aBoolValues' has a wrong offset!");
static_assert(offsetof(UBFGEffectBlackboard, M_aIntValues) == 0x000330, "Member 'UBFGEffectBlackboard::M_aIntValues' has a wrong offset!");
static_assert(offsetof(UBFGEffectBlackboard, M_aActorValues) == 0x000380, "Member 'UBFGEffectBlackboard::M_aActorValues' has a wrong offset!");
static_assert(offsetof(UBFGEffectBlackboard, M_aObjectValues) == 0x0003D0, "Member 'UBFGEffectBlackboard::M_aObjectValues' has a wrong offset!");
static_assert(offsetof(UBFGEffectBlackboard, M_aActorComponentValues) == 0x000420, "Member 'UBFGEffectBlackboard::M_aActorComponentValues' has a wrong offset!");
static_assert(offsetof(UBFGEffectBlackboard, M_aNameValues) == 0x000470, "Member 'UBFGEffectBlackboard::M_aNameValues' has a wrong offset!");
static_assert(offsetof(UBFGEffectBlackboard, M_aDataTableValues) == 0x0004C0, "Member 'UBFGEffectBlackboard::M_aDataTableValues' has a wrong offset!");
static_assert(offsetof(UBFGEffectBlackboard, M_iNextSlotIndex) == 0x000510, "Member 'UBFGEffectBlackboard::M_iNextSlotIndex' has a wrong offset!");

// Class BFGCore.BFGEffectContainer
// 0x0248 (0x0270 - 0x0028)
class UBFGEffectContainer final : public UObject
{
public:
	UMulticastDelegateProperty_                   M_Dead;                                            // 0x0028(0x0018)(ZeroConstructor, InstancedReference, BlueprintAssignable, BlueprintCallable, NativeAccessSpecifierPublic)
	int32                                         M_iSlot;                                           // 0x0040(0x0004)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_44[0x4];                                       // 0x0044(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class ABFGEffectActor*                        M_pSpawnedActor;                                   // 0x0048(0x0008)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UBFGEffectObject*                       M_pCreatedObject;                                  // 0x0050(0x0008)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UParticleSystemComponent*               M_pParticleComponent;                              // 0x0058(0x0008)(ExportObject, ZeroConstructor, Transient, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UAudioComponent*                        M_pAudioComponent;                                 // 0x0060(0x0008)(ExportObject, ZeroConstructor, Transient, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UForceFeedbackComponent*                M_pForceFeedbackComponent;                         // 0x0068(0x0008)(ExportObject, ZeroConstructor, Transient, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UForceFeedbackEffect*                   M_pForceFeedbackEffect;                            // 0x0070(0x0008)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UParticleSystemComponent*               M_pSustainParticleComponent;                       // 0x0078(0x0008)(ExportObject, ZeroConstructor, Transient, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UAudioComponent*                        M_pSustainAudioComponent;                          // 0x0080(0x0008)(ExportObject, ZeroConstructor, Transient, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UForceFeedbackComponent*                M_pSustainForceFeedbackComponent;                  // 0x0088(0x0008)(ExportObject, ZeroConstructor, Transient, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UForceFeedbackEffect*                   M_pSustainForceFeedbackEffect;                     // 0x0090(0x0008)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UParticleSystemComponent*               M_pReleaseParticleComponent;                       // 0x0098(0x0008)(ExportObject, ZeroConstructor, Transient, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UAudioComponent*                        M_pReleaseAudioComponent;                          // 0x00A0(0x0008)(ExportObject, ZeroConstructor, Transient, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UForceFeedbackComponent*                M_pReleaseForceFeedbackComponent;                  // 0x00A8(0x0008)(ExportObject, ZeroConstructor, Transient, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UForceFeedbackEffect*                   M_pReleaseForceFeedbackEffect;                     // 0x00B0(0x0008)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	struct FGuid                                  M_entryId;                                         // 0x00B8(0x0010)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UBFGEffectBlackboard*                   M_pBlackboard;                                     // 0x00C8(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	struct FBFGEffectBankEntry                    M_eEntry;                                          // 0x00D0(0x0118)(Protected, NativeAccessSpecifierProtected)
	uint8                                         Pad_1E8[0x8];                                      // 0x01E8(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	struct FBFGEffectContainerDescriptor          M_eDescriptor;                                     // 0x01F0(0x0060)(NoDestructor, ContainsInstancedReference, Protected, NativeAccessSpecifierProtected)
	class UWorld*                                 M_pWorld;                                          // 0x0250(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class USceneComponent*                        M_pAttachToComponent;                              // 0x0258(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	EBFGEffect_Identifier                         M_eIdentifier;                                     // 0x0260(0x0001)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          M_bIsPersistent;                                   // 0x0261(0x0001)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          M_bIsDead;                                         // 0x0262(0x0001)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          M_bIsActive;                                       // 0x0263(0x0001)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	int32                                         M_iSustainIterations;                              // 0x0264(0x0004)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_268[0x8];                                      // 0x0268(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void CreateDescribedObject();
	void HandleActorFinished(class ABFGEffectActor* _pActor);
	void HandleAudioFinished();
	void HandleForceFeedbackFinished(class UForceFeedbackComponent* _pComponent);
	void HandleObjectFinished(class UBFGEffectObject* _pObject);
	void HandleParticlesFinished(class UParticleSystemComponent* _pComponent);
	void HandleReleaseAudioFinished();
	void HandleReleaseForceFeedbackFinished(class UForceFeedbackComponent* _pComponent);
	void HandleReleaseParticlesFinished(class UParticleSystemComponent* _pComponent);
	void HandleSustainAudioFinished();
	void HandleSustainForceFeedbackFinished(class UForceFeedbackComponent* _pComponent);
	void HandleSustainParticlesFinished(class UParticleSystemComponent* _pComponent);
	void SpawnDescribedActor();

	class UAudioComponent* GetAudioComponent() const;
	class UParticleSystemComponent* GetParticleComponent() const;
	class UAudioComponent* GetReleaseAudioComponent() const;
	class UParticleSystemComponent* GetReleaseParticleComponent() const;
	class ABFGEffectActor* GetSpawnedActor() const;
	class UAudioComponent* GetSustainAudioComponent() const;
	class UParticleSystemComponent* GetSustainParticleComponent() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"BFGEffectContainer">();
	}
	static class UBFGEffectContainer* GetDefaultObj()
	{
		return GetDefaultObjImpl<UBFGEffectContainer>();
	}
};
static_assert(alignof(UBFGEffectContainer) == 0x000010, "Wrong alignment on UBFGEffectContainer");
static_assert(sizeof(UBFGEffectContainer) == 0x000270, "Wrong size on UBFGEffectContainer");
static_assert(offsetof(UBFGEffectContainer, M_Dead) == 0x000028, "Member 'UBFGEffectContainer::M_Dead' has a wrong offset!");
static_assert(offsetof(UBFGEffectContainer, M_iSlot) == 0x000040, "Member 'UBFGEffectContainer::M_iSlot' has a wrong offset!");
static_assert(offsetof(UBFGEffectContainer, M_pSpawnedActor) == 0x000048, "Member 'UBFGEffectContainer::M_pSpawnedActor' has a wrong offset!");
static_assert(offsetof(UBFGEffectContainer, M_pCreatedObject) == 0x000050, "Member 'UBFGEffectContainer::M_pCreatedObject' has a wrong offset!");
static_assert(offsetof(UBFGEffectContainer, M_pParticleComponent) == 0x000058, "Member 'UBFGEffectContainer::M_pParticleComponent' has a wrong offset!");
static_assert(offsetof(UBFGEffectContainer, M_pAudioComponent) == 0x000060, "Member 'UBFGEffectContainer::M_pAudioComponent' has a wrong offset!");
static_assert(offsetof(UBFGEffectContainer, M_pForceFeedbackComponent) == 0x000068, "Member 'UBFGEffectContainer::M_pForceFeedbackComponent' has a wrong offset!");
static_assert(offsetof(UBFGEffectContainer, M_pForceFeedbackEffect) == 0x000070, "Member 'UBFGEffectContainer::M_pForceFeedbackEffect' has a wrong offset!");
static_assert(offsetof(UBFGEffectContainer, M_pSustainParticleComponent) == 0x000078, "Member 'UBFGEffectContainer::M_pSustainParticleComponent' has a wrong offset!");
static_assert(offsetof(UBFGEffectContainer, M_pSustainAudioComponent) == 0x000080, "Member 'UBFGEffectContainer::M_pSustainAudioComponent' has a wrong offset!");
static_assert(offsetof(UBFGEffectContainer, M_pSustainForceFeedbackComponent) == 0x000088, "Member 'UBFGEffectContainer::M_pSustainForceFeedbackComponent' has a wrong offset!");
static_assert(offsetof(UBFGEffectContainer, M_pSustainForceFeedbackEffect) == 0x000090, "Member 'UBFGEffectContainer::M_pSustainForceFeedbackEffect' has a wrong offset!");
static_assert(offsetof(UBFGEffectContainer, M_pReleaseParticleComponent) == 0x000098, "Member 'UBFGEffectContainer::M_pReleaseParticleComponent' has a wrong offset!");
static_assert(offsetof(UBFGEffectContainer, M_pReleaseAudioComponent) == 0x0000A0, "Member 'UBFGEffectContainer::M_pReleaseAudioComponent' has a wrong offset!");
static_assert(offsetof(UBFGEffectContainer, M_pReleaseForceFeedbackComponent) == 0x0000A8, "Member 'UBFGEffectContainer::M_pReleaseForceFeedbackComponent' has a wrong offset!");
static_assert(offsetof(UBFGEffectContainer, M_pReleaseForceFeedbackEffect) == 0x0000B0, "Member 'UBFGEffectContainer::M_pReleaseForceFeedbackEffect' has a wrong offset!");
static_assert(offsetof(UBFGEffectContainer, M_entryId) == 0x0000B8, "Member 'UBFGEffectContainer::M_entryId' has a wrong offset!");
static_assert(offsetof(UBFGEffectContainer, M_pBlackboard) == 0x0000C8, "Member 'UBFGEffectContainer::M_pBlackboard' has a wrong offset!");
static_assert(offsetof(UBFGEffectContainer, M_eEntry) == 0x0000D0, "Member 'UBFGEffectContainer::M_eEntry' has a wrong offset!");
static_assert(offsetof(UBFGEffectContainer, M_eDescriptor) == 0x0001F0, "Member 'UBFGEffectContainer::M_eDescriptor' has a wrong offset!");
static_assert(offsetof(UBFGEffectContainer, M_pWorld) == 0x000250, "Member 'UBFGEffectContainer::M_pWorld' has a wrong offset!");
static_assert(offsetof(UBFGEffectContainer, M_pAttachToComponent) == 0x000258, "Member 'UBFGEffectContainer::M_pAttachToComponent' has a wrong offset!");
static_assert(offsetof(UBFGEffectContainer, M_eIdentifier) == 0x000260, "Member 'UBFGEffectContainer::M_eIdentifier' has a wrong offset!");
static_assert(offsetof(UBFGEffectContainer, M_bIsPersistent) == 0x000261, "Member 'UBFGEffectContainer::M_bIsPersistent' has a wrong offset!");
static_assert(offsetof(UBFGEffectContainer, M_bIsDead) == 0x000262, "Member 'UBFGEffectContainer::M_bIsDead' has a wrong offset!");
static_assert(offsetof(UBFGEffectContainer, M_bIsActive) == 0x000263, "Member 'UBFGEffectContainer::M_bIsActive' has a wrong offset!");
static_assert(offsetof(UBFGEffectContainer, M_iSustainIterations) == 0x000264, "Member 'UBFGEffectContainer::M_iSustainIterations' has a wrong offset!");

// Class BFGCore.BFGSensor_SeeOrHear
// 0x0050 (0x0090 - 0x0040)
class UBFGSensor_SeeOrHear final : public UBFGSensor
{
public:
	EBFGBehaviourState_NPC                        M_targetState;                                     // 0x0040(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          M_bOnlyHostile;                                    // 0x0041(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_42[0x2];                                       // 0x0042(0x0002)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         M_fMaxDistance;                                    // 0x0044(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FGameplayTagQuery                      M_ExcludeQuery;                                    // 0x0048(0x0048)(Edit, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"BFGSensor_SeeOrHear">();
	}
	static class UBFGSensor_SeeOrHear* GetDefaultObj()
	{
		return GetDefaultObjImpl<UBFGSensor_SeeOrHear>();
	}
};
static_assert(alignof(UBFGSensor_SeeOrHear) == 0x000008, "Wrong alignment on UBFGSensor_SeeOrHear");
static_assert(sizeof(UBFGSensor_SeeOrHear) == 0x000090, "Wrong size on UBFGSensor_SeeOrHear");
static_assert(offsetof(UBFGSensor_SeeOrHear, M_targetState) == 0x000040, "Member 'UBFGSensor_SeeOrHear::M_targetState' has a wrong offset!");
static_assert(offsetof(UBFGSensor_SeeOrHear, M_bOnlyHostile) == 0x000041, "Member 'UBFGSensor_SeeOrHear::M_bOnlyHostile' has a wrong offset!");
static_assert(offsetof(UBFGSensor_SeeOrHear, M_fMaxDistance) == 0x000044, "Member 'UBFGSensor_SeeOrHear::M_fMaxDistance' has a wrong offset!");
static_assert(offsetof(UBFGSensor_SeeOrHear, M_ExcludeQuery) == 0x000048, "Member 'UBFGSensor_SeeOrHear::M_ExcludeQuery' has a wrong offset!");

// Class BFGCore.BFGEffectObject
// 0x0028 (0x0050 - 0x0028)
class UBFGEffectObject : public UObject
{
public:
	UMulticastDelegateProperty_                   M_EffectStopped;                                   // 0x0028(0x0018)(ZeroConstructor, InstancedReference, BlueprintAssignable, BlueprintCallable, NativeAccessSpecifierPublic)
	class UBFGEffectBlackboard*                   M_pBlackboard;                                     // 0x0040(0x0008)(ExportObject, ZeroConstructor, Transient, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_48[0x8];                                       // 0x0048(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void HandleActorChanged(const class FName _rName, class AActor* _iValue);
	void HandleBoolChanged(const class FName _rName, bool _bValue);
	void HandleColorChanged(const class FName _rName, const struct FColor& _rValue);
	void HandleDataTableChanged(const class FName _rName, class UDataTable* _pValue);
	void HandleFloatChanged(const class FName _rName, float _fValue);
	void HandleIntChanged(const class FName _rName, int32 _iValue);
	void HandleNameChanged(const class FName _rName, class FName _iValue);
	void HandleObjectChanged(const class FName _rName, class UObject* _pValue);
	void HandleRotatorChanged(const class FName _rName, const struct FRotator& _rValue);
	void HandleVectorChanged(const class FName _rName, const struct FVector& _rValue);
	bool IsEffectActive();
	void OnStopEffect();
	void OnTriggerEffect();
	void SetBlackboard(class UBFGEffectBlackboard* _pBlackboard);
	void StopEffect();
	void TriggerEffect();

	class UBFGEffectBlackboard* GetBlackboard() const;
	class UBFGActorComponent_Effect* GetEffectComponent() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"BFGEffectObject">();
	}
	static class UBFGEffectObject* GetDefaultObj()
	{
		return GetDefaultObjImpl<UBFGEffectObject>();
	}
};
static_assert(alignof(UBFGEffectObject) == 0x000008, "Wrong alignment on UBFGEffectObject");
static_assert(sizeof(UBFGEffectObject) == 0x000050, "Wrong size on UBFGEffectObject");
static_assert(offsetof(UBFGEffectObject, M_EffectStopped) == 0x000028, "Member 'UBFGEffectObject::M_EffectStopped' has a wrong offset!");
static_assert(offsetof(UBFGEffectObject, M_pBlackboard) == 0x000040, "Member 'UBFGEffectObject::M_pBlackboard' has a wrong offset!");

// Class BFGCore.BFGEffects
// 0x0000 (0x0028 - 0x0028)
class UBFGEffects final : public UBlueprintFunctionLibrary
{
public:
	static EBFGLightweightCamera GetNextCameraMaskForPK();
	static class FString GetScrambledTextForFurocom(const class FString& _strInputText, float _fScrambleRatio);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"BFGEffects">();
	}
	static class UBFGEffects* GetDefaultObj()
	{
		return GetDefaultObjImpl<UBFGEffects>();
	}
};
static_assert(alignof(UBFGEffects) == 0x000008, "Wrong alignment on UBFGEffects");
static_assert(sizeof(UBFGEffects) == 0x000028, "Wrong size on UBFGEffects");

// Class BFGCore.BFGEventTrigger_VoiceoverQueueChanged
// 0x0000 (0x0040 - 0x0040)
class UBFGEventTrigger_VoiceoverQueueChanged final : public UBFGEventTrigger
{
public:
	void OnItemEvent(const struct FBFGVoiceoverItem& _item, const EBFGVoiceoverItemEventType _type);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"BFGEventTrigger_VoiceoverQueueChanged">();
	}
	static class UBFGEventTrigger_VoiceoverQueueChanged* GetDefaultObj()
	{
		return GetDefaultObjImpl<UBFGEventTrigger_VoiceoverQueueChanged>();
	}
};
static_assert(alignof(UBFGEventTrigger_VoiceoverQueueChanged) == 0x000008, "Wrong alignment on UBFGEventTrigger_VoiceoverQueueChanged");
static_assert(sizeof(UBFGEventTrigger_VoiceoverQueueChanged) == 0x000040, "Wrong size on UBFGEventTrigger_VoiceoverQueueChanged");

// Class BFGCore.BFGEffectSystem
// 0x0028 (0x0058 - 0x0030)
class UBFGEffectSystem final : public UBFGGameSystem
{
public:
	class ABFGGameState*                          M_pGameState;                                      // 0x0030(0x0008)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TArray<class UBFGEffectBank_DataProvider*>    M_apProviders;                                     // 0x0038(0x0010)(ZeroConstructor, Transient, Protected, NativeAccessSpecifierProtected)
	TArray<class UBFGActorComponent_Effect*>      M_apEffectComponentRegistry;                       // 0x0048(0x0010)(ExportObject, ZeroConstructor, ContainsInstancedReference, Protected, NativeAccessSpecifierProtected)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"BFGEffectSystem">();
	}
	static class UBFGEffectSystem* GetDefaultObj()
	{
		return GetDefaultObjImpl<UBFGEffectSystem>();
	}
};
static_assert(alignof(UBFGEffectSystem) == 0x000008, "Wrong alignment on UBFGEffectSystem");
static_assert(sizeof(UBFGEffectSystem) == 0x000058, "Wrong size on UBFGEffectSystem");
static_assert(offsetof(UBFGEffectSystem, M_pGameState) == 0x000030, "Member 'UBFGEffectSystem::M_pGameState' has a wrong offset!");
static_assert(offsetof(UBFGEffectSystem, M_apProviders) == 0x000038, "Member 'UBFGEffectSystem::M_apProviders' has a wrong offset!");
static_assert(offsetof(UBFGEffectSystem, M_apEffectComponentRegistry) == 0x000048, "Member 'UBFGEffectSystem::M_apEffectComponentRegistry' has a wrong offset!");

// Class BFGCore.BFGEnvInCameraViewQueryTest
// 0x0000 (0x01C0 - 0x01C0)
class UBFGEnvInCameraViewQueryTest final : public UEnvQueryTest
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"BFGEnvInCameraViewQueryTest">();
	}
	static class UBFGEnvInCameraViewQueryTest* GetDefaultObj()
	{
		return GetDefaultObjImpl<UBFGEnvInCameraViewQueryTest>();
	}
};
static_assert(alignof(UBFGEnvInCameraViewQueryTest) == 0x000008, "Wrong alignment on UBFGEnvInCameraViewQueryTest");
static_assert(sizeof(UBFGEnvInCameraViewQueryTest) == 0x0001C0, "Wrong size on UBFGEnvInCameraViewQueryTest");

// Class BFGCore.BFGSensor_SeeFriendlyAlertedActor
// 0x0008 (0x0048 - 0x0040)
class UBFGSensor_SeeFriendlyAlertedActor final : public UBFGSensor
{
public:
	EBFGBehaviourState_NPC                        M_targetState;                                     // 0x0040(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_41[0x3];                                       // 0x0041(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         M_fMaxDistToNPC;                                   // 0x0044(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"BFGSensor_SeeFriendlyAlertedActor">();
	}
	static class UBFGSensor_SeeFriendlyAlertedActor* GetDefaultObj()
	{
		return GetDefaultObjImpl<UBFGSensor_SeeFriendlyAlertedActor>();
	}
};
static_assert(alignof(UBFGSensor_SeeFriendlyAlertedActor) == 0x000008, "Wrong alignment on UBFGSensor_SeeFriendlyAlertedActor");
static_assert(sizeof(UBFGSensor_SeeFriendlyAlertedActor) == 0x000048, "Wrong size on UBFGSensor_SeeFriendlyAlertedActor");
static_assert(offsetof(UBFGSensor_SeeFriendlyAlertedActor, M_targetState) == 0x000040, "Member 'UBFGSensor_SeeFriendlyAlertedActor::M_targetState' has a wrong offset!");
static_assert(offsetof(UBFGSensor_SeeFriendlyAlertedActor, M_fMaxDistToNPC) == 0x000044, "Member 'UBFGSensor_SeeFriendlyAlertedActor::M_fMaxDistToNPC' has a wrong offset!");

// Class BFGCore.BFGEnvironment
// 0x0018 (0x0048 - 0x0030)
class UBFGEnvironment final : public UDataAsset
{
public:
	TArray<TSoftObjectPtr<class UWorld>>          M_aLevels;                                         // 0x0030(0x0010)(Edit, ZeroConstructor, UObjectWrapper, NativeAccessSpecifierPublic)
	struct FGameplayTag                           M_fTimeOfDay;                                      // 0x0040(0x0008)(Edit, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

public:
	const struct FGameplayTag GetTimeOfDay() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"BFGEnvironment">();
	}
	static class UBFGEnvironment* GetDefaultObj()
	{
		return GetDefaultObjImpl<UBFGEnvironment>();
	}
};
static_assert(alignof(UBFGEnvironment) == 0x000008, "Wrong alignment on UBFGEnvironment");
static_assert(sizeof(UBFGEnvironment) == 0x000048, "Wrong size on UBFGEnvironment");
static_assert(offsetof(UBFGEnvironment, M_aLevels) == 0x000030, "Member 'UBFGEnvironment::M_aLevels' has a wrong offset!");
static_assert(offsetof(UBFGEnvironment, M_fTimeOfDay) == 0x000040, "Member 'UBFGEnvironment::M_fTimeOfDay' has a wrong offset!");

// Class BFGCore.BFGTaskNode_MoveToWithPhysics
// 0x0000 (0x00B0 - 0x00B0)
class UBFGTaskNode_MoveToWithPhysics final : public UBTTask_MoveTo
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"BFGTaskNode_MoveToWithPhysics">();
	}
	static class UBFGTaskNode_MoveToWithPhysics* GetDefaultObj()
	{
		return GetDefaultObjImpl<UBFGTaskNode_MoveToWithPhysics>();
	}
};
static_assert(alignof(UBFGTaskNode_MoveToWithPhysics) == 0x000008, "Wrong alignment on UBFGTaskNode_MoveToWithPhysics");
static_assert(sizeof(UBFGTaskNode_MoveToWithPhysics) == 0x0000B0, "Wrong size on UBFGTaskNode_MoveToWithPhysics");

// Class BFGCore.BFGEnvironmentSystem
// 0x00A0 (0x00D0 - 0x0030)
class UBFGEnvironmentSystem final : public UBFGGameSystem
{
public:
	uint8                                         Pad_30[0x8];                                       // 0x0030(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	class ABFGGameState*                          M_pGameState;                                      // 0x0038(0x0008)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TArray<class AActor*>                         M_apMonitors;                                      // 0x0040(0x0010)(ZeroConstructor, Transient, Protected, NativeAccessSpecifierProtected)
	TArray<class AActor*>                         M_apNewMonitors;                                   // 0x0050(0x0010)(ZeroConstructor, Transient, Protected, NativeAccessSpecifierProtected)
	class UBFGEnvironment*                        M_pActiveEnvironment;                              // 0x0060(0x0008)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_68[0x8];                                       // 0x0068(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	class UBFGEnvironment*                        M_pNextEnvironment;                                // 0x0070(0x0008)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_78[0x8];                                       // 0x0078(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	TMap<class FName, TSoftObjectPtr<class UBFGEnvironment>> M_aLevelEnvironments;                              // 0x0080(0x0050)(ZeroConstructor, Transient, Protected, UObjectWrapper, NativeAccessSpecifierProtected)

public:
	void ApplyActiveEnvironment();
	void OnWorldLoaded(class UBFGGameInstance* _pGameInstance, class UWorld* _pWorld);
	void SetNextEnvironment(class UBFGEnvironment* _pEnvironment);
	bool SetNextEnvironmentSoft(TSoftObjectPtr<class UBFGEnvironment> _softEnvironment);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"BFGEnvironmentSystem">();
	}
	static class UBFGEnvironmentSystem* GetDefaultObj()
	{
		return GetDefaultObjImpl<UBFGEnvironmentSystem>();
	}
};
static_assert(alignof(UBFGEnvironmentSystem) == 0x000008, "Wrong alignment on UBFGEnvironmentSystem");
static_assert(sizeof(UBFGEnvironmentSystem) == 0x0000D0, "Wrong size on UBFGEnvironmentSystem");
static_assert(offsetof(UBFGEnvironmentSystem, M_pGameState) == 0x000038, "Member 'UBFGEnvironmentSystem::M_pGameState' has a wrong offset!");
static_assert(offsetof(UBFGEnvironmentSystem, M_apMonitors) == 0x000040, "Member 'UBFGEnvironmentSystem::M_apMonitors' has a wrong offset!");
static_assert(offsetof(UBFGEnvironmentSystem, M_apNewMonitors) == 0x000050, "Member 'UBFGEnvironmentSystem::M_apNewMonitors' has a wrong offset!");
static_assert(offsetof(UBFGEnvironmentSystem, M_pActiveEnvironment) == 0x000060, "Member 'UBFGEnvironmentSystem::M_pActiveEnvironment' has a wrong offset!");
static_assert(offsetof(UBFGEnvironmentSystem, M_pNextEnvironment) == 0x000070, "Member 'UBFGEnvironmentSystem::M_pNextEnvironment' has a wrong offset!");
static_assert(offsetof(UBFGEnvironmentSystem, M_aLevelEnvironments) == 0x000080, "Member 'UBFGEnvironmentSystem::M_aLevelEnvironments' has a wrong offset!");

// Class BFGCore.BFGSystem
// 0x0000 (0x0028 - 0x0028)
class UBFGSystem final : public UBlueprintFunctionLibrary
{
public:
	static void ApplyAndReportDamage(class AActor* _pDamagedActor, float _fDamage, class AController* _pInstigator, class AActor* _pDamageSource, TSubclassOf<class UDamageType> _damageType);
	static class UObject* CastObjectToClass(class UObject* _pObjectToCast, class UClass* Class_0);
	static void ClipboardCopy(const class FString& _strCopy);
	static class FString ClipboardPaste();
	static struct FColor ComputeDebugColor(const class UObject* _pObject);
	static class FString DumpObjectToString(class UObject* _pObject, bool _bRecurse);
	static class UObject* GetClassDefaultObject(class UClass* Class_0);
	static int32 GetConsoleInt(const class FString& _strVariableName);
	static class FString GetCurrentLanguage();
	static class FString GetDefaultLanguage();
	static int32 GetDemoPlayTime();
	static int32 GetGameIniInt(const class FString& _strName);
	static class FString GetMemoryLocationAsString(const class UObject* _pObject);
	static TArray<class UObject*> GetObjectsSlow(class UClass* _pClass, const class FString& _strPath);
	static ENetRole GetRole(class AActor* _pActor);
	static TArray<class UClass*> GetSubclassesSlow(class UClass* _pClass);
	static class FString GetVersionString();
	static class FString GetWorldType();
	static void IncreaseStatistic(EBFGGameStatistic _eGameStat, float _fAmount);
	static bool IsEditor(class AActor* _pActor);
	static bool IsObjectPendingKill(class UObject* _pObject);
	static bool IsPublicDemoVersion();
	static bool IsShippingBuild();
	static bool IsShippingCustomerBuild();
	static bool IsStandalone();
	static bool IsWithEditorPreprocessor();
	static bool SetCurrentCulture(const class FString& _cultureName);
	static void SetFixedTimeStep(bool _bFixedStep, float _fFixedStepInSeconds);
	static void SetGameIniIntOverride(const class FString& _strName, int32 _iValue);
	static bool ShouldShowUpsellButton();
	static TArray<class AActor*> SortActorArrayByName(const TArray<class AActor*>& _aActorList, bool _bSortByParentName);
	static class UObject* SpawnActorNoReplicate(class UObject* WorldContextObject, class UClass* ActorClass, const struct FTransform& _Transform, class AActor* _pOwner, class APawn* _pInstigator, ESpawnActorCollisionHandlingMethod _collisionHandlingOverride);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"BFGSystem">();
	}
	static class UBFGSystem* GetDefaultObj()
	{
		return GetDefaultObjImpl<UBFGSystem>();
	}
};
static_assert(alignof(UBFGSystem) == 0x000008, "Wrong alignment on UBFGSystem");
static_assert(sizeof(UBFGSystem) == 0x000028, "Wrong size on UBFGSystem");

// Class BFGCore.BFGEnvQueryContext_BBActor
// 0x0008 (0x0030 - 0x0028)
class UBFGEnvQueryContext_BBActor : public UEnvQueryContext
{
public:
	class FName                                   M_strBBKey;                                        // 0x0028(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"BFGEnvQueryContext_BBActor">();
	}
	static class UBFGEnvQueryContext_BBActor* GetDefaultObj()
	{
		return GetDefaultObjImpl<UBFGEnvQueryContext_BBActor>();
	}
};
static_assert(alignof(UBFGEnvQueryContext_BBActor) == 0x000008, "Wrong alignment on UBFGEnvQueryContext_BBActor");
static_assert(sizeof(UBFGEnvQueryContext_BBActor) == 0x000030, "Wrong size on UBFGEnvQueryContext_BBActor");
static_assert(offsetof(UBFGEnvQueryContext_BBActor, M_strBBKey) == 0x000028, "Member 'UBFGEnvQueryContext_BBActor::M_strBBKey' has a wrong offset!");

// Class BFGCore.BFGEnvQueryContext_BBAimingAtLocation
// 0x0000 (0x0028 - 0x0028)
class UBFGEnvQueryContext_BBAimingAtLocation : public UEnvQueryContext
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"BFGEnvQueryContext_BBAimingAtLocation">();
	}
	static class UBFGEnvQueryContext_BBAimingAtLocation* GetDefaultObj()
	{
		return GetDefaultObjImpl<UBFGEnvQueryContext_BBAimingAtLocation>();
	}
};
static_assert(alignof(UBFGEnvQueryContext_BBAimingAtLocation) == 0x000008, "Wrong alignment on UBFGEnvQueryContext_BBAimingAtLocation");
static_assert(sizeof(UBFGEnvQueryContext_BBAimingAtLocation) == 0x000028, "Wrong size on UBFGEnvQueryContext_BBAimingAtLocation");

// Class BFGCore.BFGSpinningWidgetOption
// 0x0018 (0x0258 - 0x0240)
class UBFGSpinningWidgetOption : public UUserWidget
{
public:
	class UCanvasPanelSlot*                       M_pSlot;                                           // 0x0240(0x0008)(BlueprintVisible, ExportObject, ZeroConstructor, Transient, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_248[0x10];                                     // 0x0248(0x0010)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void GetBrush(struct FSlateBrush* _oBrush);
	void GetHint(class FText* _oHint);
	struct FVector2D GetOptionSize();
	void GetTitle(class FText* _oTitle);
	void OnDisabled(bool _bDisabled);
	void SetBrush(const struct FSlateBrush& _oBrush);
	void SetHint(const class FText& _oHint);
	void SetNotificationEnabled(bool _bEnabled);
	void SetTitle(const class FText& _oTitle);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"BFGSpinningWidgetOption">();
	}
	static class UBFGSpinningWidgetOption* GetDefaultObj()
	{
		return GetDefaultObjImpl<UBFGSpinningWidgetOption>();
	}
};
static_assert(alignof(UBFGSpinningWidgetOption) == 0x000008, "Wrong alignment on UBFGSpinningWidgetOption");
static_assert(sizeof(UBFGSpinningWidgetOption) == 0x000258, "Wrong size on UBFGSpinningWidgetOption");
static_assert(offsetof(UBFGSpinningWidgetOption, M_pSlot) == 0x000240, "Member 'UBFGSpinningWidgetOption::M_pSlot' has a wrong offset!");

// Class BFGCore.BFGSpinningWidgetOption_PoxLabUpgrade
// 0x0008 (0x0260 - 0x0258)
class UBFGSpinningWidgetOption_PoxLabUpgrade final : public UBFGSpinningWidgetOption
{
public:
	bool                                          M_bIsHasUpgradeAvailable;                          // 0x0258(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_259[0x7];                                      // 0x0259(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void ShowStar(bool _bShow);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"BFGSpinningWidgetOption_PoxLabUpgrade">();
	}
	static class UBFGSpinningWidgetOption_PoxLabUpgrade* GetDefaultObj()
	{
		return GetDefaultObjImpl<UBFGSpinningWidgetOption_PoxLabUpgrade>();
	}
};
static_assert(alignof(UBFGSpinningWidgetOption_PoxLabUpgrade) == 0x000008, "Wrong alignment on UBFGSpinningWidgetOption_PoxLabUpgrade");
static_assert(sizeof(UBFGSpinningWidgetOption_PoxLabUpgrade) == 0x000260, "Wrong size on UBFGSpinningWidgetOption_PoxLabUpgrade");
static_assert(offsetof(UBFGSpinningWidgetOption_PoxLabUpgrade, M_bIsHasUpgradeAvailable) == 0x000258, "Member 'UBFGSpinningWidgetOption_PoxLabUpgrade::M_bIsHasUpgradeAvailable' has a wrong offset!");

// Class BFGCore.BFGEnvQueryContext_BBAttackTargetOfActor
// 0x0008 (0x0030 - 0x0028)
class UBFGEnvQueryContext_BBAttackTargetOfActor : public UEnvQueryContext
{
public:
	class FName                                   M_strBBKey;                                        // 0x0028(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"BFGEnvQueryContext_BBAttackTargetOfActor">();
	}
	static class UBFGEnvQueryContext_BBAttackTargetOfActor* GetDefaultObj()
	{
		return GetDefaultObjImpl<UBFGEnvQueryContext_BBAttackTargetOfActor>();
	}
};
static_assert(alignof(UBFGEnvQueryContext_BBAttackTargetOfActor) == 0x000008, "Wrong alignment on UBFGEnvQueryContext_BBAttackTargetOfActor");
static_assert(sizeof(UBFGEnvQueryContext_BBAttackTargetOfActor) == 0x000030, "Wrong size on UBFGEnvQueryContext_BBAttackTargetOfActor");
static_assert(offsetof(UBFGEnvQueryContext_BBAttackTargetOfActor, M_strBBKey) == 0x000028, "Member 'UBFGEnvQueryContext_BBAttackTargetOfActor::M_strBBKey' has a wrong offset!");

// Class BFGCore.BFGGameFlowState_Mothership_Main
// 0x0150 (0x0258 - 0x0108)
class UBFGGameFlowState_Mothership_Main final : public UBFGGameFlowState_GenericDialog_Customizable
{
public:
	class FName                                   M_oActionHandlerName_MissionSelection;             // 0x0108(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class FName                                   M_oActionHandlerName_PoxLab;                       // 0x0110(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class FName                                   M_oActionHandlerName_Archives;                     // 0x0118(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class FName                                   M_oActionHandlerName_InvasionReport;               // 0x0120(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class ULevelSequence*                         M_pMissionStartSequence;                           // 0x0128(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class ULevelSequence*                         M_pOutroSequence;                                  // 0x0130(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class ULevelSequence*                         M_pDemoTrailerSequence;                            // 0x0138(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TSoftClassPtr<class UClass>                   M_scpCredits;                                      // 0x0140(0x0028)(Edit, BlueprintVisible, BlueprintReadOnly, DisableEditOnInstance, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TSoftClassPtr<class UClass>                   M_scpUpsellDialog;                                 // 0x0168(0x0028)(Edit, BlueprintVisible, BlueprintReadOnly, DisableEditOnInstance, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class ULevelSequence*                         M_pMission01HistorySequence;                       // 0x0190(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TSoftClassPtr<class UClass>                   M_pOptionHandlerClass;                             // 0x0198(0x0028)(Edit, BlueprintVisible, BlueprintReadOnly, DisableEditOnInstance, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TArray<TSoftClassPtr<class UClass>>           M_pSubstateObjectClasses;                          // 0x01C0(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, Protected, UObjectWrapper, NativeAccessSpecifierProtected)
	TSoftClassPtr<class UClass>                   M_pExitGamePromptClass;                            // 0x01D0(0x0028)(Edit, BlueprintVisible, BlueprintReadOnly, DisableEditOnInstance, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TArray<class UBFGMothershipSubstate*>         M_apStates;                                        // 0x01F8(0x0010)(ZeroConstructor, Protected, NativeAccessSpecifierProtected)
	uint8                                         Pad_208[0x40];                                     // 0x0208(0x0040)(Fixing Size After Last Property [ Dumper-7 ])
	class UBFGMothershipTransitionManager*        M_pTransitionManager;                              // 0x0248(0x0008)(ExportObject, ZeroConstructor, Transient, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_250[0x8];                                      // 0x0250(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void CutsceneFinished(class ALevelSequenceActor* _pActor, bool _bWasCutscene);
	void CutsceneFinishedOutro(class ALevelSequenceActor* _pActor, bool _bWasCutscene);
	void CutsceneFinishedTrailer(class ALevelSequenceActor* _pActor, bool _bWasCutscene);
	void OnExitPromptMessage(EBFGDialogMessage _eMessage);
	void OnLayerChanged(int32 _iOld, int32 _iNew);
	void OnMenuPostConstruct();
	void OnSubRoomChanged(int32 _iOld, int32 _iNew);
	void TriggerLevelSwitch(class ALevelSequenceActor* _pActor, bool _bWasCutscene);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"BFGGameFlowState_Mothership_Main">();
	}
	static class UBFGGameFlowState_Mothership_Main* GetDefaultObj()
	{
		return GetDefaultObjImpl<UBFGGameFlowState_Mothership_Main>();
	}
};
static_assert(alignof(UBFGGameFlowState_Mothership_Main) == 0x000008, "Wrong alignment on UBFGGameFlowState_Mothership_Main");
static_assert(sizeof(UBFGGameFlowState_Mothership_Main) == 0x000258, "Wrong size on UBFGGameFlowState_Mothership_Main");
static_assert(offsetof(UBFGGameFlowState_Mothership_Main, M_oActionHandlerName_MissionSelection) == 0x000108, "Member 'UBFGGameFlowState_Mothership_Main::M_oActionHandlerName_MissionSelection' has a wrong offset!");
static_assert(offsetof(UBFGGameFlowState_Mothership_Main, M_oActionHandlerName_PoxLab) == 0x000110, "Member 'UBFGGameFlowState_Mothership_Main::M_oActionHandlerName_PoxLab' has a wrong offset!");
static_assert(offsetof(UBFGGameFlowState_Mothership_Main, M_oActionHandlerName_Archives) == 0x000118, "Member 'UBFGGameFlowState_Mothership_Main::M_oActionHandlerName_Archives' has a wrong offset!");
static_assert(offsetof(UBFGGameFlowState_Mothership_Main, M_oActionHandlerName_InvasionReport) == 0x000120, "Member 'UBFGGameFlowState_Mothership_Main::M_oActionHandlerName_InvasionReport' has a wrong offset!");
static_assert(offsetof(UBFGGameFlowState_Mothership_Main, M_pMissionStartSequence) == 0x000128, "Member 'UBFGGameFlowState_Mothership_Main::M_pMissionStartSequence' has a wrong offset!");
static_assert(offsetof(UBFGGameFlowState_Mothership_Main, M_pOutroSequence) == 0x000130, "Member 'UBFGGameFlowState_Mothership_Main::M_pOutroSequence' has a wrong offset!");
static_assert(offsetof(UBFGGameFlowState_Mothership_Main, M_pDemoTrailerSequence) == 0x000138, "Member 'UBFGGameFlowState_Mothership_Main::M_pDemoTrailerSequence' has a wrong offset!");
static_assert(offsetof(UBFGGameFlowState_Mothership_Main, M_scpCredits) == 0x000140, "Member 'UBFGGameFlowState_Mothership_Main::M_scpCredits' has a wrong offset!");
static_assert(offsetof(UBFGGameFlowState_Mothership_Main, M_scpUpsellDialog) == 0x000168, "Member 'UBFGGameFlowState_Mothership_Main::M_scpUpsellDialog' has a wrong offset!");
static_assert(offsetof(UBFGGameFlowState_Mothership_Main, M_pMission01HistorySequence) == 0x000190, "Member 'UBFGGameFlowState_Mothership_Main::M_pMission01HistorySequence' has a wrong offset!");
static_assert(offsetof(UBFGGameFlowState_Mothership_Main, M_pOptionHandlerClass) == 0x000198, "Member 'UBFGGameFlowState_Mothership_Main::M_pOptionHandlerClass' has a wrong offset!");
static_assert(offsetof(UBFGGameFlowState_Mothership_Main, M_pSubstateObjectClasses) == 0x0001C0, "Member 'UBFGGameFlowState_Mothership_Main::M_pSubstateObjectClasses' has a wrong offset!");
static_assert(offsetof(UBFGGameFlowState_Mothership_Main, M_pExitGamePromptClass) == 0x0001D0, "Member 'UBFGGameFlowState_Mothership_Main::M_pExitGamePromptClass' has a wrong offset!");
static_assert(offsetof(UBFGGameFlowState_Mothership_Main, M_apStates) == 0x0001F8, "Member 'UBFGGameFlowState_Mothership_Main::M_apStates' has a wrong offset!");
static_assert(offsetof(UBFGGameFlowState_Mothership_Main, M_pTransitionManager) == 0x000248, "Member 'UBFGGameFlowState_Mothership_Main::M_pTransitionManager' has a wrong offset!");

// Class BFGCore.BFGEnvQueryContext_BBLocation
// 0x0008 (0x0030 - 0x0028)
class UBFGEnvQueryContext_BBLocation : public UEnvQueryContext
{
public:
	class FName                                   M_strBBKey;                                        // 0x0028(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"BFGEnvQueryContext_BBLocation">();
	}
	static class UBFGEnvQueryContext_BBLocation* GetDefaultObj()
	{
		return GetDefaultObjImpl<UBFGEnvQueryContext_BBLocation>();
	}
};
static_assert(alignof(UBFGEnvQueryContext_BBLocation) == 0x000008, "Wrong alignment on UBFGEnvQueryContext_BBLocation");
static_assert(sizeof(UBFGEnvQueryContext_BBLocation) == 0x000030, "Wrong size on UBFGEnvQueryContext_BBLocation");
static_assert(offsetof(UBFGEnvQueryContext_BBLocation, M_strBBKey) == 0x000028, "Member 'UBFGEnvQueryContext_BBLocation::M_strBBKey' has a wrong offset!");

// Class BFGCore.BFGEnvQueryContext_BBSense
// 0x0010 (0x0038 - 0x0028)
class UBFGEnvQueryContext_BBSense : public UEnvQueryContext
{
public:
	TArray<TSubclassOf<class UAISense>>           M_aSenses;                                         // 0x0028(0x0010)(Edit, ZeroConstructor, UObjectWrapper, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"BFGEnvQueryContext_BBSense">();
	}
	static class UBFGEnvQueryContext_BBSense* GetDefaultObj()
	{
		return GetDefaultObjImpl<UBFGEnvQueryContext_BBSense>();
	}
};
static_assert(alignof(UBFGEnvQueryContext_BBSense) == 0x000008, "Wrong alignment on UBFGEnvQueryContext_BBSense");
static_assert(sizeof(UBFGEnvQueryContext_BBSense) == 0x000038, "Wrong size on UBFGEnvQueryContext_BBSense");
static_assert(offsetof(UBFGEnvQueryContext_BBSense, M_aSenses) == 0x000028, "Member 'UBFGEnvQueryContext_BBSense::M_aSenses' has a wrong offset!");

// Class BFGCore.BFGEnvQueryContextPlayerClosestNetworkPathLocation
// 0x0000 (0x0028 - 0x0028)
class UBFGEnvQueryContextPlayerClosestNetworkPathLocation final : public UEnvQueryContext
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"BFGEnvQueryContextPlayerClosestNetworkPathLocation">();
	}
	static class UBFGEnvQueryContextPlayerClosestNetworkPathLocation* GetDefaultObj()
	{
		return GetDefaultObjImpl<UBFGEnvQueryContextPlayerClosestNetworkPathLocation>();
	}
};
static_assert(alignof(UBFGEnvQueryContextPlayerClosestNetworkPathLocation) == 0x000008, "Wrong alignment on UBFGEnvQueryContextPlayerClosestNetworkPathLocation");
static_assert(sizeof(UBFGEnvQueryContextPlayerClosestNetworkPathLocation) == 0x000028, "Wrong size on UBFGEnvQueryContextPlayerClosestNetworkPathLocation");

// Class BFGCore.BFGTaskNode_SafeRotateToFaceBBEntry
// 0x0030 (0x00A8 - 0x0078)
class UBFGTaskNode_SafeRotateToFaceBBEntry final : public UBFGBTBaseTaskNode
{
public:
	struct FBlackboardKeySelector                 M_bbKeyTarget;                                     // 0x0078(0x0028)(Edit, BlueprintVisible, NativeAccessSpecifierPublic)
	float                                         M_fPrecision;                                      // 0x00A0(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_A4[0x4];                                       // 0x00A4(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"BFGTaskNode_SafeRotateToFaceBBEntry">();
	}
	static class UBFGTaskNode_SafeRotateToFaceBBEntry* GetDefaultObj()
	{
		return GetDefaultObjImpl<UBFGTaskNode_SafeRotateToFaceBBEntry>();
	}
};
static_assert(alignof(UBFGTaskNode_SafeRotateToFaceBBEntry) == 0x000008, "Wrong alignment on UBFGTaskNode_SafeRotateToFaceBBEntry");
static_assert(sizeof(UBFGTaskNode_SafeRotateToFaceBBEntry) == 0x0000A8, "Wrong size on UBFGTaskNode_SafeRotateToFaceBBEntry");
static_assert(offsetof(UBFGTaskNode_SafeRotateToFaceBBEntry, M_bbKeyTarget) == 0x000078, "Member 'UBFGTaskNode_SafeRotateToFaceBBEntry::M_bbKeyTarget' has a wrong offset!");
static_assert(offsetof(UBFGTaskNode_SafeRotateToFaceBBEntry, M_fPrecision) == 0x0000A0, "Member 'UBFGTaskNode_SafeRotateToFaceBBEntry::M_fPrecision' has a wrong offset!");

// Class BFGCore.BFGEnvQueryContextPlayerLocationOnGround
// 0x0000 (0x0028 - 0x0028)
class UBFGEnvQueryContextPlayerLocationOnGround final : public UEnvQueryContext
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"BFGEnvQueryContextPlayerLocationOnGround">();
	}
	static class UBFGEnvQueryContextPlayerLocationOnGround* GetDefaultObj()
	{
		return GetDefaultObjImpl<UBFGEnvQueryContextPlayerLocationOnGround>();
	}
};
static_assert(alignof(UBFGEnvQueryContextPlayerLocationOnGround) == 0x000008, "Wrong alignment on UBFGEnvQueryContextPlayerLocationOnGround");
static_assert(sizeof(UBFGEnvQueryContextPlayerLocationOnGround) == 0x000028, "Wrong size on UBFGEnvQueryContextPlayerLocationOnGround");

// Class BFGCore.BFGEnvQueryContextPlayerPawn
// 0x0000 (0x0028 - 0x0028)
class UBFGEnvQueryContextPlayerPawn final : public UEnvQueryContext
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"BFGEnvQueryContextPlayerPawn">();
	}
	static class UBFGEnvQueryContextPlayerPawn* GetDefaultObj()
	{
		return GetDefaultObjImpl<UBFGEnvQueryContextPlayerPawn>();
	}
};
static_assert(alignof(UBFGEnvQueryContextPlayerPawn) == 0x000008, "Wrong alignment on UBFGEnvQueryContextPlayerPawn");
static_assert(sizeof(UBFGEnvQueryContextPlayerPawn) == 0x000028, "Wrong size on UBFGEnvQueryContextPlayerPawn");

// Class BFGCore.BFGHolobobReplicator
// 0x0018 (0x03F0 - 0x03D8)
class ABFGHolobobReplicator final : public AActor
{
public:
	class USkeletalMeshComponent*                 M_pMesh;                                           // 0x03D8(0x0008)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, EditConst, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TArray<class UStaticMeshComponent*>           M_apAccessories;                                   // 0x03E0(0x0010)(ExportObject, ZeroConstructor, ContainsInstancedReference, Protected, NativeAccessSpecifierProtected)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"BFGHolobobReplicator">();
	}
	static class ABFGHolobobReplicator* GetDefaultObj()
	{
		return GetDefaultObjImpl<ABFGHolobobReplicator>();
	}
};
static_assert(alignof(ABFGHolobobReplicator) == 0x000008, "Wrong alignment on ABFGHolobobReplicator");
static_assert(sizeof(ABFGHolobobReplicator) == 0x0003F0, "Wrong size on ABFGHolobobReplicator");
static_assert(offsetof(ABFGHolobobReplicator, M_pMesh) == 0x0003D8, "Member 'ABFGHolobobReplicator::M_pMesh' has a wrong offset!");
static_assert(offsetof(ABFGHolobobReplicator, M_apAccessories) == 0x0003E0, "Member 'ABFGHolobobReplicator::M_apAccessories' has a wrong offset!");

// Class BFGCore.BFGEnvQueryContextPlayerVelocityDir
// 0x0000 (0x0028 - 0x0028)
class UBFGEnvQueryContextPlayerVelocityDir final : public UEnvQueryContext
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"BFGEnvQueryContextPlayerVelocityDir">();
	}
	static class UBFGEnvQueryContextPlayerVelocityDir* GetDefaultObj()
	{
		return GetDefaultObjImpl<UBFGEnvQueryContextPlayerVelocityDir>();
	}
};
static_assert(alignof(UBFGEnvQueryContextPlayerVelocityDir) == 0x000008, "Wrong alignment on UBFGEnvQueryContextPlayerVelocityDir");
static_assert(sizeof(UBFGEnvQueryContextPlayerVelocityDir) == 0x000028, "Wrong size on UBFGEnvQueryContextPlayerVelocityDir");

// Class BFGCore.BFGEnvQueryGenerator_Boss_SilhouetteCoverLocations
// 0x0008 (0x0088 - 0x0080)
class UBFGEnvQueryGenerator_Boss_SilhouetteCoverLocations final : public UEnvQueryGenerator_ProjectedPoints
{
public:
	TSubclassOf<class UEnvQueryContext>           M_oSilhouette;                                     // 0x0080(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"BFGEnvQueryGenerator_Boss_SilhouetteCoverLocations">();
	}
	static class UBFGEnvQueryGenerator_Boss_SilhouetteCoverLocations* GetDefaultObj()
	{
		return GetDefaultObjImpl<UBFGEnvQueryGenerator_Boss_SilhouetteCoverLocations>();
	}
};
static_assert(alignof(UBFGEnvQueryGenerator_Boss_SilhouetteCoverLocations) == 0x000008, "Wrong alignment on UBFGEnvQueryGenerator_Boss_SilhouetteCoverLocations");
static_assert(sizeof(UBFGEnvQueryGenerator_Boss_SilhouetteCoverLocations) == 0x000088, "Wrong size on UBFGEnvQueryGenerator_Boss_SilhouetteCoverLocations");
static_assert(offsetof(UBFGEnvQueryGenerator_Boss_SilhouetteCoverLocations, M_oSilhouette) == 0x000080, "Member 'UBFGEnvQueryGenerator_Boss_SilhouetteCoverLocations::M_oSilhouette' has a wrong offset!");

// Class BFGCore.BFGFadeSystemUserWidget
// 0x0000 (0x0240 - 0x0240)
class UBFGFadeSystemUserWidget : public UUserWidget
{
public:
	void SetSpinnerOpacity(float _fOpacity);
	void SetSpinnerType(EBFGSaveSystem_UIThrobber _eType);
	void ShowSpinner(bool _bShow);
	void UpdateFade(float _fValue);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"BFGFadeSystemUserWidget">();
	}
	static class UBFGFadeSystemUserWidget* GetDefaultObj()
	{
		return GetDefaultObjImpl<UBFGFadeSystemUserWidget>();
	}
};
static_assert(alignof(UBFGFadeSystemUserWidget) == 0x000008, "Wrong alignment on UBFGFadeSystemUserWidget");
static_assert(sizeof(UBFGFadeSystemUserWidget) == 0x000240, "Wrong size on UBFGFadeSystemUserWidget");

// Class BFGCore.BFGTaskNode_Relocate
// 0x0030 (0x00D0 - 0x00A0)
class UBFGTaskNode_Relocate final : public UBFGTaskNode_BossBase
{
public:
	bool                                          M_bRandomCover;                                    // 0x00A0(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_A1[0x3];                                       // 0x00A1(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         M_fMinunumDistance;                                // 0x00A4(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	struct FBlackboardKeySelector                 M_BBKeyPhaseRelocateLocation;                      // 0x00A8(0x0028)(Edit, BlueprintVisible, Protected, NativeAccessSpecifierProtected)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"BFGTaskNode_Relocate">();
	}
	static class UBFGTaskNode_Relocate* GetDefaultObj()
	{
		return GetDefaultObjImpl<UBFGTaskNode_Relocate>();
	}
};
static_assert(alignof(UBFGTaskNode_Relocate) == 0x000008, "Wrong alignment on UBFGTaskNode_Relocate");
static_assert(sizeof(UBFGTaskNode_Relocate) == 0x0000D0, "Wrong size on UBFGTaskNode_Relocate");
static_assert(offsetof(UBFGTaskNode_Relocate, M_bRandomCover) == 0x0000A0, "Member 'UBFGTaskNode_Relocate::M_bRandomCover' has a wrong offset!");
static_assert(offsetof(UBFGTaskNode_Relocate, M_fMinunumDistance) == 0x0000A4, "Member 'UBFGTaskNode_Relocate::M_fMinunumDistance' has a wrong offset!");
static_assert(offsetof(UBFGTaskNode_Relocate, M_BBKeyPhaseRelocateLocation) == 0x0000A8, "Member 'UBFGTaskNode_Relocate::M_BBKeyPhaseRelocateLocation' has a wrong offset!");

// Class BFGCore.BFGEnvQueryGenerator_Fireline
// 0x0070 (0x00F0 - 0x0080)
class UBFGEnvQueryGenerator_Fireline final : public UEnvQueryGenerator_ProjectedPoints
{
public:
	struct FAIDataProviderFloatValue              SpaceBetween;                                      // 0x0080(0x0030)(Edit, DisableEditOnInstance, ContainsInstancedReference, NativeAccessSpecifierPublic)
	struct FAIDataProviderFloatValue              DistanceFromGenerators;                            // 0x00B0(0x0030)(Edit, DisableEditOnInstance, ContainsInstancedReference, NativeAccessSpecifierPublic)
	TSubclassOf<class UEnvQueryContext>           GenerateFrom;                                      // 0x00E0(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TSubclassOf<class UEnvQueryContext>           GenerateTo;                                        // 0x00E8(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"BFGEnvQueryGenerator_Fireline">();
	}
	static class UBFGEnvQueryGenerator_Fireline* GetDefaultObj()
	{
		return GetDefaultObjImpl<UBFGEnvQueryGenerator_Fireline>();
	}
};
static_assert(alignof(UBFGEnvQueryGenerator_Fireline) == 0x000008, "Wrong alignment on UBFGEnvQueryGenerator_Fireline");
static_assert(sizeof(UBFGEnvQueryGenerator_Fireline) == 0x0000F0, "Wrong size on UBFGEnvQueryGenerator_Fireline");
static_assert(offsetof(UBFGEnvQueryGenerator_Fireline, SpaceBetween) == 0x000080, "Member 'UBFGEnvQueryGenerator_Fireline::SpaceBetween' has a wrong offset!");
static_assert(offsetof(UBFGEnvQueryGenerator_Fireline, DistanceFromGenerators) == 0x0000B0, "Member 'UBFGEnvQueryGenerator_Fireline::DistanceFromGenerators' has a wrong offset!");
static_assert(offsetof(UBFGEnvQueryGenerator_Fireline, GenerateFrom) == 0x0000E0, "Member 'UBFGEnvQueryGenerator_Fireline::GenerateFrom' has a wrong offset!");
static_assert(offsetof(UBFGEnvQueryGenerator_Fireline, GenerateTo) == 0x0000E8, "Member 'UBFGEnvQueryGenerator_Fireline::GenerateTo' has a wrong offset!");

// Class BFGCore.BFGEnvQueryTest_DistanceToClosestFireline
// 0x0008 (0x01C8 - 0x01C0)
class UBFGEnvQueryTest_DistanceToClosestFireline final : public UEnvQueryTest
{
public:
	TSubclassOf<class UEnvQueryContext>           AttackTarget;                                      // 0x01C0(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"BFGEnvQueryTest_DistanceToClosestFireline">();
	}
	static class UBFGEnvQueryTest_DistanceToClosestFireline* GetDefaultObj()
	{
		return GetDefaultObjImpl<UBFGEnvQueryTest_DistanceToClosestFireline>();
	}
};
static_assert(alignof(UBFGEnvQueryTest_DistanceToClosestFireline) == 0x000008, "Wrong alignment on UBFGEnvQueryTest_DistanceToClosestFireline");
static_assert(sizeof(UBFGEnvQueryTest_DistanceToClosestFireline) == 0x0001C8, "Wrong size on UBFGEnvQueryTest_DistanceToClosestFireline");
static_assert(offsetof(UBFGEnvQueryTest_DistanceToClosestFireline, AttackTarget) == 0x0001C0, "Member 'UBFGEnvQueryTest_DistanceToClosestFireline::AttackTarget' has a wrong offset!");

// Class BFGCore.BFGEnvQueryTest_DistanceToClosestParticipant
// 0x0018 (0x01D8 - 0x01C0)
class UBFGEnvQueryTest_DistanceToClosestParticipant final : public UEnvQueryTest
{
public:
	TSubclassOf<class UEnvQueryContext>           AttackTarget;                                      // 0x01C0(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         M_fEnableOwnLocationRadiusCheck;                   // 0x01C8(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         M_fBoostOwnLocationRadius;                         // 0x01CC(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         M_fBoostOwnLocationScore;                          // 0x01D0(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          M_bBoostOwnLocation;                               // 0x01D4(0x0001)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1D5[0x3];                                      // 0x01D5(0x0003)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"BFGEnvQueryTest_DistanceToClosestParticipant">();
	}
	static class UBFGEnvQueryTest_DistanceToClosestParticipant* GetDefaultObj()
	{
		return GetDefaultObjImpl<UBFGEnvQueryTest_DistanceToClosestParticipant>();
	}
};
static_assert(alignof(UBFGEnvQueryTest_DistanceToClosestParticipant) == 0x000008, "Wrong alignment on UBFGEnvQueryTest_DistanceToClosestParticipant");
static_assert(sizeof(UBFGEnvQueryTest_DistanceToClosestParticipant) == 0x0001D8, "Wrong size on UBFGEnvQueryTest_DistanceToClosestParticipant");
static_assert(offsetof(UBFGEnvQueryTest_DistanceToClosestParticipant, AttackTarget) == 0x0001C0, "Member 'UBFGEnvQueryTest_DistanceToClosestParticipant::AttackTarget' has a wrong offset!");
static_assert(offsetof(UBFGEnvQueryTest_DistanceToClosestParticipant, M_fEnableOwnLocationRadiusCheck) == 0x0001C8, "Member 'UBFGEnvQueryTest_DistanceToClosestParticipant::M_fEnableOwnLocationRadiusCheck' has a wrong offset!");
static_assert(offsetof(UBFGEnvQueryTest_DistanceToClosestParticipant, M_fBoostOwnLocationRadius) == 0x0001CC, "Member 'UBFGEnvQueryTest_DistanceToClosestParticipant::M_fBoostOwnLocationRadius' has a wrong offset!");
static_assert(offsetof(UBFGEnvQueryTest_DistanceToClosestParticipant, M_fBoostOwnLocationScore) == 0x0001D0, "Member 'UBFGEnvQueryTest_DistanceToClosestParticipant::M_fBoostOwnLocationScore' has a wrong offset!");
static_assert(offsetof(UBFGEnvQueryTest_DistanceToClosestParticipant, M_bBoostOwnLocation) == 0x0001D4, "Member 'UBFGEnvQueryTest_DistanceToClosestParticipant::M_bBoostOwnLocation' has a wrong offset!");

// Class BFGCore.BFGQuest
// 0x0208 (0x0238 - 0x0030)
class UBFGQuest : public UBFGGenericGraphOwner
{
public:
	uint8                                         Pad_30[0x18];                                      // 0x0030(0x0018)(Fixing Size After Last Property [ Dumper-7 ])
	TSoftObjectPtr<class UBFGLoadingScreenInfo>   M_spLoadingscreenInfo;                             // 0x0048(0x0028)(Edit, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TSoftObjectPtr<class UBFGDataAsset_ChallengeInfo> M_spDataAssetChallenge;                            // 0x0070(0x0028)(Edit, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         M_iBudgetOverrideNPC;                              // 0x0098(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          M_bIsIntroduction;                                 // 0x009C(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_9D[0x3];                                       // 0x009D(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	class FName                                   M_strQuestName;                                    // 0x00A0(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class FString                                 M_strDisplayName_Internal;                         // 0x00A8(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	struct FBFGMissionCondition                   M_unlockCondition;                                 // 0x00B8(0x0020)(Edit, BlueprintVisible, BlueprintReadOnly, DisableEditOnInstance, Protected, NativeAccessSpecifierProtected)
	bool                                          M_bIsAutoRepeatable;                               // 0x00D8(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_D9[0x7];                                       // 0x00D9(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	class UBFGDataAsset_QuestRewards*             M_pCompletionRating_Rewards;                       // 0x00E0(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         M_fCompletionRatingBase;                           // 0x00E8(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_EC[0x4];                                       // 0x00EC(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class FText                                   M_oMissionSelectionTitle;                          // 0x00F0(0x0018)(Edit, BlueprintVisible, BlueprintReadOnly, DisableEditOnInstance, Protected, NativeAccessSpecifierProtected)
	class FText                                   M_oMissionSelectionDescription;                    // 0x0108(0x0018)(Edit, BlueprintVisible, BlueprintReadOnly, DisableEditOnInstance, Protected, NativeAccessSpecifierProtected)
	struct FSlateBrush                            M_oMissionSelectionImage;                          // 0x0120(0x0088)(Edit, BlueprintVisible, BlueprintReadOnly, DisableEditOnInstance, Protected, NativeAccessSpecifierProtected)
	int32                                         M_iSortIDUI;                                       // 0x01A8(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_1AC[0x4];                                      // 0x01AC(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class UBFGMissionGroup*                       M_pMissionGroup;                                   // 0x01B0(0x0008)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class ABFGGameState*                          M_pGameState;                                      // 0x01B8(0x0008)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UBFGVariable*                           M_pVariable;                                       // 0x01C0(0x0008)(ExportObject, ZeroConstructor, Transient, InstancedReference, IsPlainOldData, NoDestructor, Protected, PersistentInstance, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UBFGVariable*                           M_pCompletedVariable;                              // 0x01C8(0x0008)(ExportObject, ZeroConstructor, Transient, InstancedReference, IsPlainOldData, NoDestructor, Protected, PersistentInstance, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TArray<class UBFGEvent*>                      M_aEvents;                                         // 0x01D0(0x0010)(ExportObject, ZeroConstructor, Transient, ContainsInstancedReference, Protected, NativeAccessSpecifierProtected)
	TArray<class UBFGSubQuest*>                   M_apSubQuests;                                     // 0x01E0(0x0010)(ExportObject, ZeroConstructor, Transient, ContainsInstancedReference, Protected, NativeAccessSpecifierProtected)
	TArray<class UBFGEventAction*>                M_aEndQuestActions;                                // 0x01F0(0x0010)(ExportObject, ZeroConstructor, Transient, ContainsInstancedReference, Protected, NativeAccessSpecifierProtected)
	TArray<class FName>                           M_aEndQuestAction_StreamingLevelVariables;         // 0x0200(0x0010)(ZeroConstructor, Transient, Protected, NativeAccessSpecifierProtected)
	class UBFGQuest_StartupMode*                  M_pStartupMode;                                    // 0x0210(0x0008)(ExportObject, ZeroConstructor, Transient, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UBFGQuest_Challenge*                    M_pChallenge;                                      // 0x0218(0x0008)(ExportObject, ZeroConstructor, Transient, InstancedReference, IsPlainOldData, NoDestructor, Protected, PersistentInstance, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_220[0x8];                                      // 0x0220(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<class UBFGQuest_StreamingLevels*>      M_apQuestStreaming;                                // 0x0228(0x0010)(ZeroConstructor, Transient, Protected, NativeAccessSpecifierProtected)

public:
	void OnStartForWorld(class ABFGGameState* _pGameState, class UBFGQuest_Manager* _pQuestManager);
	void OnVariableChanged(class UBFGVariableMirror* _pVarMirror, const class UBFGVariable* _pVariable, int32 _oldValue, int32 _newValue);
	class UBFGCustomDataVariable* RegisterDataVariable(const class FName& _strVarName, float _fDefaultValue);
	void RegisterEvent(class UBFGEvent* _pEvent, bool bPrioritize);

	class FName GenerateQuestVariableName() const;
	const TArray<class UBFGEvent*> GetActiveEvents() const;
	class ABFGGameState* GetGameState() const;
	class UBFGMissionGroup* GetMissionGroup() const;
	class UBFGQuest_Element* GetRunningElement() const;
	class UBFGVariable* GetVariable() const;
	bool IsMainQuest() const;
	bool IsQuestInProgress() const;
	bool IsQuestToBeStarted() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"BFGQuest">();
	}
	static class UBFGQuest* GetDefaultObj()
	{
		return GetDefaultObjImpl<UBFGQuest>();
	}
};
static_assert(alignof(UBFGQuest) == 0x000008, "Wrong alignment on UBFGQuest");
static_assert(sizeof(UBFGQuest) == 0x000238, "Wrong size on UBFGQuest");
static_assert(offsetof(UBFGQuest, M_spLoadingscreenInfo) == 0x000048, "Member 'UBFGQuest::M_spLoadingscreenInfo' has a wrong offset!");
static_assert(offsetof(UBFGQuest, M_spDataAssetChallenge) == 0x000070, "Member 'UBFGQuest::M_spDataAssetChallenge' has a wrong offset!");
static_assert(offsetof(UBFGQuest, M_iBudgetOverrideNPC) == 0x000098, "Member 'UBFGQuest::M_iBudgetOverrideNPC' has a wrong offset!");
static_assert(offsetof(UBFGQuest, M_bIsIntroduction) == 0x00009C, "Member 'UBFGQuest::M_bIsIntroduction' has a wrong offset!");
static_assert(offsetof(UBFGQuest, M_strQuestName) == 0x0000A0, "Member 'UBFGQuest::M_strQuestName' has a wrong offset!");
static_assert(offsetof(UBFGQuest, M_strDisplayName_Internal) == 0x0000A8, "Member 'UBFGQuest::M_strDisplayName_Internal' has a wrong offset!");
static_assert(offsetof(UBFGQuest, M_unlockCondition) == 0x0000B8, "Member 'UBFGQuest::M_unlockCondition' has a wrong offset!");
static_assert(offsetof(UBFGQuest, M_bIsAutoRepeatable) == 0x0000D8, "Member 'UBFGQuest::M_bIsAutoRepeatable' has a wrong offset!");
static_assert(offsetof(UBFGQuest, M_pCompletionRating_Rewards) == 0x0000E0, "Member 'UBFGQuest::M_pCompletionRating_Rewards' has a wrong offset!");
static_assert(offsetof(UBFGQuest, M_fCompletionRatingBase) == 0x0000E8, "Member 'UBFGQuest::M_fCompletionRatingBase' has a wrong offset!");
static_assert(offsetof(UBFGQuest, M_oMissionSelectionTitle) == 0x0000F0, "Member 'UBFGQuest::M_oMissionSelectionTitle' has a wrong offset!");
static_assert(offsetof(UBFGQuest, M_oMissionSelectionDescription) == 0x000108, "Member 'UBFGQuest::M_oMissionSelectionDescription' has a wrong offset!");
static_assert(offsetof(UBFGQuest, M_oMissionSelectionImage) == 0x000120, "Member 'UBFGQuest::M_oMissionSelectionImage' has a wrong offset!");
static_assert(offsetof(UBFGQuest, M_iSortIDUI) == 0x0001A8, "Member 'UBFGQuest::M_iSortIDUI' has a wrong offset!");
static_assert(offsetof(UBFGQuest, M_pMissionGroup) == 0x0001B0, "Member 'UBFGQuest::M_pMissionGroup' has a wrong offset!");
static_assert(offsetof(UBFGQuest, M_pGameState) == 0x0001B8, "Member 'UBFGQuest::M_pGameState' has a wrong offset!");
static_assert(offsetof(UBFGQuest, M_pVariable) == 0x0001C0, "Member 'UBFGQuest::M_pVariable' has a wrong offset!");
static_assert(offsetof(UBFGQuest, M_pCompletedVariable) == 0x0001C8, "Member 'UBFGQuest::M_pCompletedVariable' has a wrong offset!");
static_assert(offsetof(UBFGQuest, M_aEvents) == 0x0001D0, "Member 'UBFGQuest::M_aEvents' has a wrong offset!");
static_assert(offsetof(UBFGQuest, M_apSubQuests) == 0x0001E0, "Member 'UBFGQuest::M_apSubQuests' has a wrong offset!");
static_assert(offsetof(UBFGQuest, M_aEndQuestActions) == 0x0001F0, "Member 'UBFGQuest::M_aEndQuestActions' has a wrong offset!");
static_assert(offsetof(UBFGQuest, M_aEndQuestAction_StreamingLevelVariables) == 0x000200, "Member 'UBFGQuest::M_aEndQuestAction_StreamingLevelVariables' has a wrong offset!");
static_assert(offsetof(UBFGQuest, M_pStartupMode) == 0x000210, "Member 'UBFGQuest::M_pStartupMode' has a wrong offset!");
static_assert(offsetof(UBFGQuest, M_pChallenge) == 0x000218, "Member 'UBFGQuest::M_pChallenge' has a wrong offset!");
static_assert(offsetof(UBFGQuest, M_apQuestStreaming) == 0x000228, "Member 'UBFGQuest::M_apQuestStreaming' has a wrong offset!");

// Class BFGCore.BFGSubQuest
// 0x00D8 (0x0310 - 0x0238)
class UBFGSubQuest final : public UBFGQuest
{
public:
	uint8                                         Pad_238[0x18];                                     // 0x0238(0x0018)(Fixing Size After Last Property [ Dumper-7 ])
	class UBFGQuest*                              M_pParentQuest;                                    // 0x0250(0x0008)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_258[0x8];                                      // 0x0258(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	class UBFGQuest_ElementRoot*                  M_pSubQuestEntryNode;                              // 0x0260(0x0008)(ExportObject, ZeroConstructor, Transient, InstancedReference, IsPlainOldData, NoDestructor, Protected, PersistentInstance, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UBFGQuest_ElementEnd*                   M_pSubQuestEndNode;                                // 0x0268(0x0008)(ExportObject, ZeroConstructor, Transient, InstancedReference, IsPlainOldData, NoDestructor, Protected, PersistentInstance, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UBFGVariable*                           M_pVariable_UIVisible;                             // 0x0270(0x0008)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UBFGQuest_Element*                      M_pParentSourceElement;                            // 0x0278(0x0008)(ExportObject, ZeroConstructor, Transient, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_280[0x8];                                      // 0x0280(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	struct FBFGQuest_Failure                      M_infoFailure;                                     // 0x0288(0x0088)(Transient, Protected, NativeAccessSpecifierProtected)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"BFGSubQuest">();
	}
	static class UBFGSubQuest* GetDefaultObj()
	{
		return GetDefaultObjImpl<UBFGSubQuest>();
	}
};
static_assert(alignof(UBFGSubQuest) == 0x000008, "Wrong alignment on UBFGSubQuest");
static_assert(sizeof(UBFGSubQuest) == 0x000310, "Wrong size on UBFGSubQuest");
static_assert(offsetof(UBFGSubQuest, M_pParentQuest) == 0x000250, "Member 'UBFGSubQuest::M_pParentQuest' has a wrong offset!");
static_assert(offsetof(UBFGSubQuest, M_pSubQuestEntryNode) == 0x000260, "Member 'UBFGSubQuest::M_pSubQuestEntryNode' has a wrong offset!");
static_assert(offsetof(UBFGSubQuest, M_pSubQuestEndNode) == 0x000268, "Member 'UBFGSubQuest::M_pSubQuestEndNode' has a wrong offset!");
static_assert(offsetof(UBFGSubQuest, M_pVariable_UIVisible) == 0x000270, "Member 'UBFGSubQuest::M_pVariable_UIVisible' has a wrong offset!");
static_assert(offsetof(UBFGSubQuest, M_pParentSourceElement) == 0x000278, "Member 'UBFGSubQuest::M_pParentSourceElement' has a wrong offset!");
static_assert(offsetof(UBFGSubQuest, M_infoFailure) == 0x000288, "Member 'UBFGSubQuest::M_infoFailure' has a wrong offset!");

// Class BFGCore.BFGGameFlowState_MainMenu
// 0x0078 (0x0180 - 0x0108)
class UBFGGameFlowState_MainMenu final : public UBFGGameFlowState_GenericDialog_Customizable
{
public:
	class FName                                   M_strHandlerName_Continue;                         // 0x0108(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class FName                                   M_strHandlerName_LoadSavegame;                     // 0x0110(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class FName                                   M_strDebugStartMenuName;                           // 0x0118(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class FName                                   M_strHandlerName_Options;                          // 0x0120(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class FName                                   M_strHandlerName_Credits;                          // 0x0128(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class FName                                   M_strHandlerName_Quit;                             // 0x0130(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class FName                                   M_strHandlerName_DebugStartMenu;                   // 0x0138(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class FName                                   M_strHandlerName_GateMap;                          // 0x0140(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class FName                                   M_strHandlerName_SwitchUser;                       // 0x0148(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class USoundBase*                             M_pMusicToPlay;                                    // 0x0150(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UBFGSaveSystem*                         M_pSaveSystem;                                     // 0x0158(0x0008)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_160[0x8];                                      // 0x0160(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	EBFGGameFlowState_MainMenu_Action             M_action;                                          // 0x0168(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_169[0x7];                                      // 0x0169(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	class UBFGSaveSystem_Action*                  M_pSaveAction;                                     // 0x0170(0x0008)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_178[0x8];                                      // 0x0178(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void OnSaveSystemActionComplete(class UBFGSaveSystem* _pSaveSystem, class UBFGSaveSystem_Action* _pAction, EBFGSaveSystem_ActionResult _result);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"BFGGameFlowState_MainMenu">();
	}
	static class UBFGGameFlowState_MainMenu* GetDefaultObj()
	{
		return GetDefaultObjImpl<UBFGGameFlowState_MainMenu>();
	}
};
static_assert(alignof(UBFGGameFlowState_MainMenu) == 0x000008, "Wrong alignment on UBFGGameFlowState_MainMenu");
static_assert(sizeof(UBFGGameFlowState_MainMenu) == 0x000180, "Wrong size on UBFGGameFlowState_MainMenu");
static_assert(offsetof(UBFGGameFlowState_MainMenu, M_strHandlerName_Continue) == 0x000108, "Member 'UBFGGameFlowState_MainMenu::M_strHandlerName_Continue' has a wrong offset!");
static_assert(offsetof(UBFGGameFlowState_MainMenu, M_strHandlerName_LoadSavegame) == 0x000110, "Member 'UBFGGameFlowState_MainMenu::M_strHandlerName_LoadSavegame' has a wrong offset!");
static_assert(offsetof(UBFGGameFlowState_MainMenu, M_strDebugStartMenuName) == 0x000118, "Member 'UBFGGameFlowState_MainMenu::M_strDebugStartMenuName' has a wrong offset!");
static_assert(offsetof(UBFGGameFlowState_MainMenu, M_strHandlerName_Options) == 0x000120, "Member 'UBFGGameFlowState_MainMenu::M_strHandlerName_Options' has a wrong offset!");
static_assert(offsetof(UBFGGameFlowState_MainMenu, M_strHandlerName_Credits) == 0x000128, "Member 'UBFGGameFlowState_MainMenu::M_strHandlerName_Credits' has a wrong offset!");
static_assert(offsetof(UBFGGameFlowState_MainMenu, M_strHandlerName_Quit) == 0x000130, "Member 'UBFGGameFlowState_MainMenu::M_strHandlerName_Quit' has a wrong offset!");
static_assert(offsetof(UBFGGameFlowState_MainMenu, M_strHandlerName_DebugStartMenu) == 0x000138, "Member 'UBFGGameFlowState_MainMenu::M_strHandlerName_DebugStartMenu' has a wrong offset!");
static_assert(offsetof(UBFGGameFlowState_MainMenu, M_strHandlerName_GateMap) == 0x000140, "Member 'UBFGGameFlowState_MainMenu::M_strHandlerName_GateMap' has a wrong offset!");
static_assert(offsetof(UBFGGameFlowState_MainMenu, M_strHandlerName_SwitchUser) == 0x000148, "Member 'UBFGGameFlowState_MainMenu::M_strHandlerName_SwitchUser' has a wrong offset!");
static_assert(offsetof(UBFGGameFlowState_MainMenu, M_pMusicToPlay) == 0x000150, "Member 'UBFGGameFlowState_MainMenu::M_pMusicToPlay' has a wrong offset!");
static_assert(offsetof(UBFGGameFlowState_MainMenu, M_pSaveSystem) == 0x000158, "Member 'UBFGGameFlowState_MainMenu::M_pSaveSystem' has a wrong offset!");
static_assert(offsetof(UBFGGameFlowState_MainMenu, M_action) == 0x000168, "Member 'UBFGGameFlowState_MainMenu::M_action' has a wrong offset!");
static_assert(offsetof(UBFGGameFlowState_MainMenu, M_pSaveAction) == 0x000170, "Member 'UBFGGameFlowState_MainMenu::M_pSaveAction' has a wrong offset!");

// Class BFGCore.BFGEnvQueryTest_InMissionBoundaries
// 0x0000 (0x01C0 - 0x01C0)
class UBFGEnvQueryTest_InMissionBoundaries final : public UEnvQueryTest
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"BFGEnvQueryTest_InMissionBoundaries">();
	}
	static class UBFGEnvQueryTest_InMissionBoundaries* GetDefaultObj()
	{
		return GetDefaultObjImpl<UBFGEnvQueryTest_InMissionBoundaries>();
	}
};
static_assert(alignof(UBFGEnvQueryTest_InMissionBoundaries) == 0x000008, "Wrong alignment on UBFGEnvQueryTest_InMissionBoundaries");
static_assert(sizeof(UBFGEnvQueryTest_InMissionBoundaries) == 0x0001C0, "Wrong size on UBFGEnvQueryTest_InMissionBoundaries");

// Class BFGCore.BFGVariationDressingComponent
// 0x0070 (0x0198 - 0x0128)
class UBFGVariationDressingComponent final : public UActorComponent
{
public:
	class FName                                   M_VariationForStartup;                             // 0x0128(0x0008)(BlueprintVisible, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         M_iVariationSubIdForStartup;                       // 0x0130(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         M_iPreferredVariationIndex;                        // 0x0134(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UDataTable*                             M_pDataTable;                                      // 0x0138(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TArray<struct FBFGDataTableRowReference>      M_aVariationPool;                                  // 0x0140(0x0010)(Edit, BlueprintVisible, ZeroConstructor, Protected, NativeAccessSpecifierProtected)
	class FName                                   M_ActiveVariation;                                 // 0x0150(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TArray<class UStaticMeshComponent*>           M_apDynamicallySpawnedAttachments;                 // 0x0158(0x0010)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, Transient, ContainsInstancedReference, Protected, NativeAccessSpecifierProtected)
	struct FGameplayTagContainer                  M_apCachedAdditionalTags;                          // 0x0168(0x0020)(BlueprintVisible, BlueprintReadOnly, Transient, Protected, NativeAccessSpecifierProtected)
	uint8                                         Pad_188[0x10];                                     // 0x0188(0x0010)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void AssignVariation(class FName _nVariationName);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"BFGVariationDressingComponent">();
	}
	static class UBFGVariationDressingComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UBFGVariationDressingComponent>();
	}
};
static_assert(alignof(UBFGVariationDressingComponent) == 0x000008, "Wrong alignment on UBFGVariationDressingComponent");
static_assert(sizeof(UBFGVariationDressingComponent) == 0x000198, "Wrong size on UBFGVariationDressingComponent");
static_assert(offsetof(UBFGVariationDressingComponent, M_VariationForStartup) == 0x000128, "Member 'UBFGVariationDressingComponent::M_VariationForStartup' has a wrong offset!");
static_assert(offsetof(UBFGVariationDressingComponent, M_iVariationSubIdForStartup) == 0x000130, "Member 'UBFGVariationDressingComponent::M_iVariationSubIdForStartup' has a wrong offset!");
static_assert(offsetof(UBFGVariationDressingComponent, M_iPreferredVariationIndex) == 0x000134, "Member 'UBFGVariationDressingComponent::M_iPreferredVariationIndex' has a wrong offset!");
static_assert(offsetof(UBFGVariationDressingComponent, M_pDataTable) == 0x000138, "Member 'UBFGVariationDressingComponent::M_pDataTable' has a wrong offset!");
static_assert(offsetof(UBFGVariationDressingComponent, M_aVariationPool) == 0x000140, "Member 'UBFGVariationDressingComponent::M_aVariationPool' has a wrong offset!");
static_assert(offsetof(UBFGVariationDressingComponent, M_ActiveVariation) == 0x000150, "Member 'UBFGVariationDressingComponent::M_ActiveVariation' has a wrong offset!");
static_assert(offsetof(UBFGVariationDressingComponent, M_apDynamicallySpawnedAttachments) == 0x000158, "Member 'UBFGVariationDressingComponent::M_apDynamicallySpawnedAttachments' has a wrong offset!");
static_assert(offsetof(UBFGVariationDressingComponent, M_apCachedAdditionalTags) == 0x000168, "Member 'UBFGVariationDressingComponent::M_apCachedAdditionalTags' has a wrong offset!");

// Class BFGCore.BFGEnvQueryTest_TargetTracker
// 0x0038 (0x01F8 - 0x01C0)
class UBFGEnvQueryTest_TargetTracker final : public UEnvQueryTest
{
public:
	TSubclassOf<class UEnvQueryContext>           M_pAttackTarget;                                   // 0x01C0(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FBFGTargetTracker_QueryParams          M_queryParams;                                     // 0x01C8(0x0010)(Edit, DisableEditOnInstance, NoDestructor, NativeAccessSpecifierPublic)
	float                                         M_fBaseScore;                                      // 0x01D8(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          M_bScoreDistanceToFireline;                        // 0x01DC(0x0001)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          M_bScoreDistanceToParticipant;                     // 0x01DD(0x0001)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1DE[0x2];                                      // 0x01DE(0x0002)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         M_fScoreLOSTarget;                                 // 0x01E0(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         M_fScoreNoLOSTarget;                               // 0x01E4(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         M_fScoreLOSOrigin;                                 // 0x01E8(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         M_fScoreNoLOSOrigin;                               // 0x01EC(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         M_fScoreDistanceToOrigin;                          // 0x01F0(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          M_bIsPreprojected;                                 // 0x01F4(0x0001)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1F5[0x3];                                      // 0x01F5(0x0003)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"BFGEnvQueryTest_TargetTracker">();
	}
	static class UBFGEnvQueryTest_TargetTracker* GetDefaultObj()
	{
		return GetDefaultObjImpl<UBFGEnvQueryTest_TargetTracker>();
	}
};
static_assert(alignof(UBFGEnvQueryTest_TargetTracker) == 0x000008, "Wrong alignment on UBFGEnvQueryTest_TargetTracker");
static_assert(sizeof(UBFGEnvQueryTest_TargetTracker) == 0x0001F8, "Wrong size on UBFGEnvQueryTest_TargetTracker");
static_assert(offsetof(UBFGEnvQueryTest_TargetTracker, M_pAttackTarget) == 0x0001C0, "Member 'UBFGEnvQueryTest_TargetTracker::M_pAttackTarget' has a wrong offset!");
static_assert(offsetof(UBFGEnvQueryTest_TargetTracker, M_queryParams) == 0x0001C8, "Member 'UBFGEnvQueryTest_TargetTracker::M_queryParams' has a wrong offset!");
static_assert(offsetof(UBFGEnvQueryTest_TargetTracker, M_fBaseScore) == 0x0001D8, "Member 'UBFGEnvQueryTest_TargetTracker::M_fBaseScore' has a wrong offset!");
static_assert(offsetof(UBFGEnvQueryTest_TargetTracker, M_bScoreDistanceToFireline) == 0x0001DC, "Member 'UBFGEnvQueryTest_TargetTracker::M_bScoreDistanceToFireline' has a wrong offset!");
static_assert(offsetof(UBFGEnvQueryTest_TargetTracker, M_bScoreDistanceToParticipant) == 0x0001DD, "Member 'UBFGEnvQueryTest_TargetTracker::M_bScoreDistanceToParticipant' has a wrong offset!");
static_assert(offsetof(UBFGEnvQueryTest_TargetTracker, M_fScoreLOSTarget) == 0x0001E0, "Member 'UBFGEnvQueryTest_TargetTracker::M_fScoreLOSTarget' has a wrong offset!");
static_assert(offsetof(UBFGEnvQueryTest_TargetTracker, M_fScoreNoLOSTarget) == 0x0001E4, "Member 'UBFGEnvQueryTest_TargetTracker::M_fScoreNoLOSTarget' has a wrong offset!");
static_assert(offsetof(UBFGEnvQueryTest_TargetTracker, M_fScoreLOSOrigin) == 0x0001E8, "Member 'UBFGEnvQueryTest_TargetTracker::M_fScoreLOSOrigin' has a wrong offset!");
static_assert(offsetof(UBFGEnvQueryTest_TargetTracker, M_fScoreNoLOSOrigin) == 0x0001EC, "Member 'UBFGEnvQueryTest_TargetTracker::M_fScoreNoLOSOrigin' has a wrong offset!");
static_assert(offsetof(UBFGEnvQueryTest_TargetTracker, M_fScoreDistanceToOrigin) == 0x0001F0, "Member 'UBFGEnvQueryTest_TargetTracker::M_fScoreDistanceToOrigin' has a wrong offset!");
static_assert(offsetof(UBFGEnvQueryTest_TargetTracker, M_bIsPreprojected) == 0x0001F4, "Member 'UBFGEnvQueryTest_TargetTracker::M_bIsPreprojected' has a wrong offset!");

// Class BFGCore.BFGVariableType_Quest
// 0x0000 (0x0090 - 0x0090)
class UBFGVariableType_Quest final : public UBFGVariableType
{
public:
	static int32 GetMaxSupported_QuestSteps();
	static const class FName GetState_QuestAborted();
	static const class FName GetState_QuestAvailable();
	static const class FName GetState_QuestFailed();
	static const class FName GetState_QuestFinished();
	static const class FName GetState_QuestUnavailable();
	static const class FName GetTypeName_Quest();
	static int32 GetValueFromQuestStep(int32 _iQuestStep);
	static class FName GetValueNameFromQuestStep(int32 _iQuestStep);
	static void GetValueNamesForEndStates(TArray<class FName>* _aValueNames);
	static void GetValueNamesForInProgress(TArray<class FName>* _aValueNames);
	static void GetValueNamesForNotInProgress(TArray<class FName>* _aValueNames, bool _bIncludeAvailable);
	static TArray<class FName> GetValueNamesFromQuestSteps(const TArray<int32>& _aQuestSteps);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"BFGVariableType_Quest">();
	}
	static class UBFGVariableType_Quest* GetDefaultObj()
	{
		return GetDefaultObjImpl<UBFGVariableType_Quest>();
	}
};
static_assert(alignof(UBFGVariableType_Quest) == 0x000008, "Wrong alignment on UBFGVariableType_Quest");
static_assert(sizeof(UBFGVariableType_Quest) == 0x000090, "Wrong size on UBFGVariableType_Quest");

// Class BFGCore.BFGEQSTestingPawn
// 0x0010 (0x08B0 - 0x08A0)
class ABFGEQSTestingPawn : public AEQSTestingPawn
{
public:
	uint8                                         Pad_8A0[0x8];                                      // 0x08A0(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	EBFGFaction                                   M_faction;                                         // 0x08A8(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_8A9[0x7];                                      // 0x08A9(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"BFGEQSTestingPawn">();
	}
	static class ABFGEQSTestingPawn* GetDefaultObj()
	{
		return GetDefaultObjImpl<ABFGEQSTestingPawn>();
	}
};
static_assert(alignof(ABFGEQSTestingPawn) == 0x000010, "Wrong alignment on ABFGEQSTestingPawn");
static_assert(sizeof(ABFGEQSTestingPawn) == 0x0008B0, "Wrong size on ABFGEQSTestingPawn");
static_assert(offsetof(ABFGEQSTestingPawn, M_faction) == 0x0008A8, "Member 'ABFGEQSTestingPawn::M_faction' has a wrong offset!");

// Class BFGCore.BFGEvent
// 0x0048 (0x0070 - 0x0028)
class UBFGEvent final : public UObject
{
public:
	uint8                                         Pad_28[0x8];                                       // 0x0028(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<class UBFGEventTrigger*>               M_aTriggers;                                       // 0x0030(0x0010)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, Transient, DisableEditOnInstance, ContainsInstancedReference, NativeAccessSpecifierPublic)
	class UBFGEventTest*                          M_PTEST;                                           // 0x0040(0x0008)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, Transient, DisableEditOnInstance, InstancedReference, IsPlainOldData, NoDestructor, PersistentInstance, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TArray<class UBFGEventAction*>                M_aActions;                                        // 0x0048(0x0010)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, Transient, DisableEditOnInstance, ContainsInstancedReference, NativeAccessSpecifierPublic)
	class FName                                   M_strDebugName;                                    // 0x0058(0x0008)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class ABFGGameState*                          M_pGameState;                                      // 0x0060(0x0008)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UObject*                                M_pConstructionContext;                            // 0x0068(0x0008)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"BFGEvent">();
	}
	static class UBFGEvent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UBFGEvent>();
	}
};
static_assert(alignof(UBFGEvent) == 0x000008, "Wrong alignment on UBFGEvent");
static_assert(sizeof(UBFGEvent) == 0x000070, "Wrong size on UBFGEvent");
static_assert(offsetof(UBFGEvent, M_aTriggers) == 0x000030, "Member 'UBFGEvent::M_aTriggers' has a wrong offset!");
static_assert(offsetof(UBFGEvent, M_PTEST) == 0x000040, "Member 'UBFGEvent::M_PTEST' has a wrong offset!");
static_assert(offsetof(UBFGEvent, M_aActions) == 0x000048, "Member 'UBFGEvent::M_aActions' has a wrong offset!");
static_assert(offsetof(UBFGEvent, M_strDebugName) == 0x000058, "Member 'UBFGEvent::M_strDebugName' has a wrong offset!");
static_assert(offsetof(UBFGEvent, M_pGameState) == 0x000060, "Member 'UBFGEvent::M_pGameState' has a wrong offset!");
static_assert(offsetof(UBFGEvent, M_pConstructionContext) == 0x000068, "Member 'UBFGEvent::M_pConstructionContext' has a wrong offset!");

// Class BFGCore.BFGStreamingLevelHandle
// 0x0058 (0x0080 - 0x0028)
class UBFGStreamingLevelHandle final : public UObject
{
public:
	TSoftObjectPtr<class UWorld>                  M_pLevel;                                          // 0x0028(0x0028)(Transient, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UBFGVariable*                           M_pRequestedState;                                 // 0x0050(0x0008)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UBFGVariable*                           M_pLoadedState;                                    // 0x0058(0x0008)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class ABFGGameState*                          M_pGameState;                                      // 0x0060(0x0008)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_68[0x18];                                      // 0x0068(0x0018)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	bool RequestState(bool _bLoaded, bool _bSkipAutoSave);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"BFGStreamingLevelHandle">();
	}
	static class UBFGStreamingLevelHandle* GetDefaultObj()
	{
		return GetDefaultObjImpl<UBFGStreamingLevelHandle>();
	}
};
static_assert(alignof(UBFGStreamingLevelHandle) == 0x000008, "Wrong alignment on UBFGStreamingLevelHandle");
static_assert(sizeof(UBFGStreamingLevelHandle) == 0x000080, "Wrong size on UBFGStreamingLevelHandle");
static_assert(offsetof(UBFGStreamingLevelHandle, M_pLevel) == 0x000028, "Member 'UBFGStreamingLevelHandle::M_pLevel' has a wrong offset!");
static_assert(offsetof(UBFGStreamingLevelHandle, M_pRequestedState) == 0x000050, "Member 'UBFGStreamingLevelHandle::M_pRequestedState' has a wrong offset!");
static_assert(offsetof(UBFGStreamingLevelHandle, M_pLoadedState) == 0x000058, "Member 'UBFGStreamingLevelHandle::M_pLoadedState' has a wrong offset!");
static_assert(offsetof(UBFGStreamingLevelHandle, M_pGameState) == 0x000060, "Member 'UBFGStreamingLevelHandle::M_pGameState' has a wrong offset!");

// Class BFGCore.BFGWidget_TutorialPage
// 0x0148 (0x0388 - 0x0240)
class UBFGWidget_TutorialPage : public UUserWidget
{
public:
	UMulticastDelegateProperty_                   M_OnDisplayStyleTransitionDone;                    // 0x0240(0x0018)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	EBFGTutorialPageDisplayStyle                  M_eCurrentDisplayStyle;                            // 0x0258(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EBFGTutorialPageDisplayStyle                  M_ePreviousDisplayStyle;                           // 0x0259(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EBFGTutorialPageDisplayStyle                  M_ePendingDisplayStyle;                            // 0x025A(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EBFGTutorialPageFadingState                   M_eFadingState;                                    // 0x025B(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_25C[0x4];                                      // 0x025C(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class UBFGDataAsset_TutorialPage*             M_pDataAsset;                                      // 0x0260(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         M_fFadingSpeed;                                    // 0x0268(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         M_fFadingTimer;                                    // 0x026C(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          M_bUseGamepadHints;                                // 0x0270(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_271[0x7];                                      // 0x0271(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<class UBFGWidgetAnimationState*>       M_apFadingStates;                                  // 0x0278(0x0010)(ZeroConstructor, NativeAccessSpecifierPublic)
	struct FSlateBrush                            M_arrowBrush;                                      // 0x0288(0x0088)(Edit, BlueprintVisible, BlueprintReadOnly, DisableEditOnInstance, NativeAccessSpecifierPublic)
	TSoftClassPtr<class UClass>                   M_pInputActionContentClass;                        // 0x0310(0x0028)(Edit, BlueprintVisible, BlueprintReadOnly, DisableEditOnInstance, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TSoftClassPtr<class UClass>                   M_pInputAxisHintContentClass;                      // 0x0338(0x0028)(Edit, BlueprintVisible, BlueprintReadOnly, DisableEditOnInstance, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TArray<class UBFGLabeledImage_InputAction*>   M_apInputHints;                                    // 0x0360(0x0010)(ExportObject, ZeroConstructor, ContainsInstancedReference, Protected, NativeAccessSpecifierProtected)
	class UBFGWidget_Tutorial_CustomInputHint*    M_pCustomInputHint;                                // 0x0370(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          M_bHintInitialized;                                // 0x0378(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_379[0x7];                                      // 0x0379(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	int32                                         M_iCurrentKnownInputPack;                          // 0x0380(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_384[0x4];                                      // 0x0384(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void ActionTutorialPage__DelegateSignature(const class UBFGWidget_TutorialPage* _pPage);
	void ActionTutorialPageEvent__DelegateSignature(class UBFGWidget_TutorialPage* _pSource, EBFGTutorialPageDisplayStyle _eDisplayStyle);
	class UBFGWidgetAnimationState* AddFadingState();
	void CacheWidgetSize(class UWidget* _pWidget, struct FVector2D* _vSize);
	void ChangeDisplayStyle(EBFGTutorialPageDisplayStyle _eNewDisplayStyle, bool _bForce);
	void ChangeStyleCollapsed(bool _bForce);
	void ChangeStyleCompact(bool _bForce);
	void ChangeStyleDetailed(bool _bForce);
	void ChangeStyleHinted(bool _bForce);
	void ChangeStyleNormal(bool _bForce);
	void ClearMedia();
	void CustomInit();
	void EnableContentVisibility(bool _bValue);
	void EnableDetailedHint(bool _bEnabled);
	void EnableDismissHint(bool _bEnabled);
	void EnableFrameVisibility(bool _bValue);
	void EnableOrnamentVisibility(bool _bValue);
	class FText GetInputActionUseTypeText(EBFGInputActionWidgetType _eType, float _holdTime);
	void OnInputDeviceChanged(bool _bIsGamepad);
	void RebuildLayout();
	void Scroll(float _fAmount);
	void ScrollToTop();
	void SetContext(class UBFGDataAsset_TutorialPage* _pDataAsset);
	void SetInputActions(class UOverlay* _pOverlayInputActions);
	void UpdateDescriptionText(const class FText& _strText);
	void UpdateDetailText(const class FText& _strText, const class FText& _strQuote);
	void UpdateIconBrush(const struct FSlateBrush& _iconBrush);
	void UpdateImage(const struct FSlateBrush& _oImage);
	void UpdateLongTitle(const class FText& _strTitle);
	void UpdateMedia(class UMediaSource* _pMediaSource);
	void UpdateShortDescriptionText(const class FText& _strText);
	void UpdateShortTitle(const class FText& _strTitle);

	struct FVector2D ComputeAbsoluteIconPosition() const;
	class UBFGDataAsset_TutorialPage* GetContext() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"BFGWidget_TutorialPage">();
	}
	static class UBFGWidget_TutorialPage* GetDefaultObj()
	{
		return GetDefaultObjImpl<UBFGWidget_TutorialPage>();
	}
};
static_assert(alignof(UBFGWidget_TutorialPage) == 0x000008, "Wrong alignment on UBFGWidget_TutorialPage");
static_assert(sizeof(UBFGWidget_TutorialPage) == 0x000388, "Wrong size on UBFGWidget_TutorialPage");
static_assert(offsetof(UBFGWidget_TutorialPage, M_OnDisplayStyleTransitionDone) == 0x000240, "Member 'UBFGWidget_TutorialPage::M_OnDisplayStyleTransitionDone' has a wrong offset!");
static_assert(offsetof(UBFGWidget_TutorialPage, M_eCurrentDisplayStyle) == 0x000258, "Member 'UBFGWidget_TutorialPage::M_eCurrentDisplayStyle' has a wrong offset!");
static_assert(offsetof(UBFGWidget_TutorialPage, M_ePreviousDisplayStyle) == 0x000259, "Member 'UBFGWidget_TutorialPage::M_ePreviousDisplayStyle' has a wrong offset!");
static_assert(offsetof(UBFGWidget_TutorialPage, M_ePendingDisplayStyle) == 0x00025A, "Member 'UBFGWidget_TutorialPage::M_ePendingDisplayStyle' has a wrong offset!");
static_assert(offsetof(UBFGWidget_TutorialPage, M_eFadingState) == 0x00025B, "Member 'UBFGWidget_TutorialPage::M_eFadingState' has a wrong offset!");
static_assert(offsetof(UBFGWidget_TutorialPage, M_pDataAsset) == 0x000260, "Member 'UBFGWidget_TutorialPage::M_pDataAsset' has a wrong offset!");
static_assert(offsetof(UBFGWidget_TutorialPage, M_fFadingSpeed) == 0x000268, "Member 'UBFGWidget_TutorialPage::M_fFadingSpeed' has a wrong offset!");
static_assert(offsetof(UBFGWidget_TutorialPage, M_fFadingTimer) == 0x00026C, "Member 'UBFGWidget_TutorialPage::M_fFadingTimer' has a wrong offset!");
static_assert(offsetof(UBFGWidget_TutorialPage, M_bUseGamepadHints) == 0x000270, "Member 'UBFGWidget_TutorialPage::M_bUseGamepadHints' has a wrong offset!");
static_assert(offsetof(UBFGWidget_TutorialPage, M_apFadingStates) == 0x000278, "Member 'UBFGWidget_TutorialPage::M_apFadingStates' has a wrong offset!");
static_assert(offsetof(UBFGWidget_TutorialPage, M_arrowBrush) == 0x000288, "Member 'UBFGWidget_TutorialPage::M_arrowBrush' has a wrong offset!");
static_assert(offsetof(UBFGWidget_TutorialPage, M_pInputActionContentClass) == 0x000310, "Member 'UBFGWidget_TutorialPage::M_pInputActionContentClass' has a wrong offset!");
static_assert(offsetof(UBFGWidget_TutorialPage, M_pInputAxisHintContentClass) == 0x000338, "Member 'UBFGWidget_TutorialPage::M_pInputAxisHintContentClass' has a wrong offset!");
static_assert(offsetof(UBFGWidget_TutorialPage, M_apInputHints) == 0x000360, "Member 'UBFGWidget_TutorialPage::M_apInputHints' has a wrong offset!");
static_assert(offsetof(UBFGWidget_TutorialPage, M_pCustomInputHint) == 0x000370, "Member 'UBFGWidget_TutorialPage::M_pCustomInputHint' has a wrong offset!");
static_assert(offsetof(UBFGWidget_TutorialPage, M_bHintInitialized) == 0x000378, "Member 'UBFGWidget_TutorialPage::M_bHintInitialized' has a wrong offset!");
static_assert(offsetof(UBFGWidget_TutorialPage, M_iCurrentKnownInputPack) == 0x000380, "Member 'UBFGWidget_TutorialPage::M_iCurrentKnownInputPack' has a wrong offset!");

// Class BFGCore.BFGGameEdSettings
// 0x0070 (0x00A8 - 0x0038)
class UBFGGameEdSettings final : public UDeveloperSettings
{
public:
	bool                                          M_bSaveWriteGameProgressFiles;                     // 0x0038(0x0001)(Edit, ZeroConstructor, Config, DisableEditOnInstance, GlobalConfig, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          M_bSelectRandomPIEStartEnvironments;               // 0x0039(0x0001)(Edit, ZeroConstructor, Config, DisableEditOnInstance, GlobalConfig, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          M_bSimulateQuests;                                 // 0x003A(0x0001)(Edit, ZeroConstructor, Config, DisableEditOnInstance, GlobalConfig, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_3B[0x5];                                       // 0x003B(0x0005)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<TSoftClassPtr<class UClass>>           M_aQuests;                                         // 0x0040(0x0010)(Edit, ZeroConstructor, Config, DisableEditOnInstance, GlobalConfig, UObjectWrapper, NativeAccessSpecifierPublic)
	TArray<TSoftClassPtr<class UClass>>           M_aDevDebugQuests;                                 // 0x0050(0x0010)(Edit, ZeroConstructor, Config, DisableEditOnInstance, GlobalConfig, UObjectWrapper, NativeAccessSpecifierPublic)
	TArray<TSoftObjectPtr<class UBFGMissionGroup>> M_aDevDebugMissions;                               // 0x0060(0x0010)(Edit, ZeroConstructor, Config, DisableEditOnInstance, GlobalConfig, UObjectWrapper, NativeAccessSpecifierPublic)
	struct FBFGQuest_DevDebug                     M_devDebugQuests;                                  // 0x0070(0x0007)(Edit, Config, DisableEditOnInstance, GlobalConfig, NoDestructor, NativeAccessSpecifierPublic)
	bool                                          M_bTreadAllTagsUnlocked;                           // 0x0077(0x0001)(Edit, ZeroConstructor, Config, DisableEditOnInstance, GlobalConfig, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          M_bUseEditorUnlockedTags;                          // 0x0078(0x0001)(Edit, ZeroConstructor, Config, DisableEditOnInstance, GlobalConfig, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_79[0x7];                                       // 0x0079(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	struct FGameplayTagContainer                  M_UnlockedTags;                                    // 0x0080(0x0020)(Edit, Config, DisableEditOnInstance, GlobalConfig, NativeAccessSpecifierPublic)
	bool                                          M_bIsVibrationEnabled;                             // 0x00A0(0x0001)(Edit, ZeroConstructor, Config, DisableEditOnInstance, GlobalConfig, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_A1[0x7];                                       // 0x00A1(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"BFGGameEdSettings">();
	}
	static class UBFGGameEdSettings* GetDefaultObj()
	{
		return GetDefaultObjImpl<UBFGGameEdSettings>();
	}
};
static_assert(alignof(UBFGGameEdSettings) == 0x000008, "Wrong alignment on UBFGGameEdSettings");
static_assert(sizeof(UBFGGameEdSettings) == 0x0000A8, "Wrong size on UBFGGameEdSettings");
static_assert(offsetof(UBFGGameEdSettings, M_bSaveWriteGameProgressFiles) == 0x000038, "Member 'UBFGGameEdSettings::M_bSaveWriteGameProgressFiles' has a wrong offset!");
static_assert(offsetof(UBFGGameEdSettings, M_bSelectRandomPIEStartEnvironments) == 0x000039, "Member 'UBFGGameEdSettings::M_bSelectRandomPIEStartEnvironments' has a wrong offset!");
static_assert(offsetof(UBFGGameEdSettings, M_bSimulateQuests) == 0x00003A, "Member 'UBFGGameEdSettings::M_bSimulateQuests' has a wrong offset!");
static_assert(offsetof(UBFGGameEdSettings, M_aQuests) == 0x000040, "Member 'UBFGGameEdSettings::M_aQuests' has a wrong offset!");
static_assert(offsetof(UBFGGameEdSettings, M_aDevDebugQuests) == 0x000050, "Member 'UBFGGameEdSettings::M_aDevDebugQuests' has a wrong offset!");
static_assert(offsetof(UBFGGameEdSettings, M_aDevDebugMissions) == 0x000060, "Member 'UBFGGameEdSettings::M_aDevDebugMissions' has a wrong offset!");
static_assert(offsetof(UBFGGameEdSettings, M_devDebugQuests) == 0x000070, "Member 'UBFGGameEdSettings::M_devDebugQuests' has a wrong offset!");
static_assert(offsetof(UBFGGameEdSettings, M_bTreadAllTagsUnlocked) == 0x000077, "Member 'UBFGGameEdSettings::M_bTreadAllTagsUnlocked' has a wrong offset!");
static_assert(offsetof(UBFGGameEdSettings, M_bUseEditorUnlockedTags) == 0x000078, "Member 'UBFGGameEdSettings::M_bUseEditorUnlockedTags' has a wrong offset!");
static_assert(offsetof(UBFGGameEdSettings, M_UnlockedTags) == 0x000080, "Member 'UBFGGameEdSettings::M_UnlockedTags' has a wrong offset!");
static_assert(offsetof(UBFGGameEdSettings, M_bIsVibrationEnabled) == 0x0000A0, "Member 'UBFGGameEdSettings::M_bIsVibrationEnabled' has a wrong offset!");

// Class BFGCore.BFGEvent_DelegateForwarding
// 0x0008 (0x0030 - 0x0028)
class UBFGEvent_DelegateForwarding final : public UObject
{
public:
	class ABFGGameState*                          M_pGameState;                                      // 0x0028(0x0008)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)

public:
	void Forward_BossObjectiveReached(class AActor* _pBoss, EBFGQuest_BossObjective _objective);
	void Forward_CortexScanVOPlayed(class AActor* _pOwner, const struct FBFGCortexScanResponse& _response, class UBFGCortexScanResponseSet* _pResponseSet);
	void Forward_CutsceneStarted();
	void Forward_DestroyedStaticObject(class ABFGObject_StaticWithPhysics* _pDestroyedObject);
	void Forward_EnterWater(class AActor* _pActor);
	void Forward_FellOutOfWorld(class AActor* _pActor);
	void Forward_HealthChanged(class AActor* _pOwner);
	void Forward_InitialWaveAmountReached(class ABFGMissionSpawnManager* _pSpawnManager);
	void Forward_Interact(class AActor* _pOwner, class AActor* _pIteractedWith, class UObject* _pFocusedOn);
	void Forward_KilledActor(class AController* _pInstigator, class AActor* _pDamageSource, class AActor* _pKilled, TSubclassOf<class UDamageType> _damageType);
	void Forward_MainMissionOrChallengeEnded();
	void Forward_MentalAbilityActivity(class AActor* _pOnwer, class UBFGMentalAbilityBase* _pAbility, class AActor* _pTarget, EMentalAbility_EventState _eState);
	void Forward_NarrativeSequenceEnd(class UBFGNarrativeSequence* _pSequence);
	void Forward_NarrativeSequenceFailed(class UBFGNarrativeSequence* _pSequence);
	void Forward_OverlapActor(class AActor* _pActor, class AActor* _pOverlap);
	void Forward_OverlapEndActor(class AActor* _pActor, class AActor* _pOverlap);
	void Forward_PickupItem(class AActor* _pOwner, class AActor* _pItem);
	void Forward_PlayerStateMonetaryValueChanged(class ABFGPlayerState* _pPlayerState);
	void Forward_ProximityGoalReached(const class UBFGQuest_ProximityMonitor* _pProximityMonitor);
	void Forward_ProximitySubgoalReached(const class UBFGQuest_ProximityMonitor* _pProximityMonitor, int32 _iLimit);
	void Forward_ResourceValueChanged(EItemValueTypeEnum _eType, float _fNewValue, float _fOldValue);
	void Forward_SpawnManagerEveryoneDead(class ABFGMissionSpawnManager* _pSpawnManager);
	void Forward_SpawnManagerLoaded(class ABFGMissionSpawnManager* _pSpawnManager);
	void Forward_StreamingLevelStateChanged(class UBFGStreamingLevelHandle* _pHandle, bool _bIsLoaded);
	void Forward_TickPlayerControllingUFO(class AActor* _pPlayerCharacter, class AActor* _PlayerUFO);
	void Forward_TimerSubgoalReached(const class UBFGQuest_Timer* _pTimer, const struct FTimespan& _tsLimit);
	void Forward_TransportToOrbitAttempt(class ABFGMissionOrbitalTransporter* _pTransporter, class AActor* _pTarget, bool _bSuccess);
	void Forward_VariableMirrorValueChanged(class UBFGVariableMirror* _pVarMirror, const class UBFGVariable* _pVariable, int32 _oldValue, int32 _newValue);
	void Forward_WaveStarted(class ABFGMissionSpawnManager* _pSpawnManager);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"BFGEvent_DelegateForwarding">();
	}
	static class UBFGEvent_DelegateForwarding* GetDefaultObj()
	{
		return GetDefaultObjImpl<UBFGEvent_DelegateForwarding>();
	}
};
static_assert(alignof(UBFGEvent_DelegateForwarding) == 0x000008, "Wrong alignment on UBFGEvent_DelegateForwarding");
static_assert(sizeof(UBFGEvent_DelegateForwarding) == 0x000030, "Wrong size on UBFGEvent_DelegateForwarding");
static_assert(offsetof(UBFGEvent_DelegateForwarding, M_pGameState) == 0x000028, "Member 'UBFGEvent_DelegateForwarding::M_pGameState' has a wrong offset!");

// Class BFGCore.BFGEventAction_ActivateSpawnManager
// 0x0018 (0x0048 - 0x0030)
class UBFGEventAction_ActivateSpawnManager final : public UBFGEventAction
{
public:
	uint8                                         Pad_30[0x18];                                      // 0x0030(0x0018)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"BFGEventAction_ActivateSpawnManager">();
	}
	static class UBFGEventAction_ActivateSpawnManager* GetDefaultObj()
	{
		return GetDefaultObjImpl<UBFGEventAction_ActivateSpawnManager>();
	}
};
static_assert(alignof(UBFGEventAction_ActivateSpawnManager) == 0x000008, "Wrong alignment on UBFGEventAction_ActivateSpawnManager");
static_assert(sizeof(UBFGEventAction_ActivateSpawnManager) == 0x000048, "Wrong size on UBFGEventAction_ActivateSpawnManager");

// Class BFGCore.BFGGameFlowState_MissionResults
// 0x00F8 (0x0200 - 0x0108)
class UBFGGameFlowState_MissionResults final : public UBFGGameFlowState_GenericDialog_Customizable
{
public:
	class FName                                   M_strHandlerName_Accept;                           // 0x0108(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class FText                                   M_strTextMissionFailed_Death;                      // 0x0110(0x0018)(Edit, Protected, NativeAccessSpecifierProtected)
	class FText                                   M_strTextMissionFailed_Quest;                      // 0x0128(0x0018)(Edit, Protected, NativeAccessSpecifierProtected)
	class FText                                   M_strTextMissionFailed_BoundariesLeft;             // 0x0140(0x0018)(Edit, Protected, NativeAccessSpecifierProtected)
	uint8                                         Pad_158[0x98];                                     // 0x0158(0x0098)(Fixing Size After Last Property [ Dumper-7 ])
	class UBFGGameFlowState_GameplayEndSequence*  M_pGameplayEndGFS;                                 // 0x01F0(0x0008)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          M_bGotoMothership;                                 // 0x01F8(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          M_bReplay;                                         // 0x01F9(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_1FA[0x6];                                      // 0x01FA(0x0006)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"BFGGameFlowState_MissionResults">();
	}
	static class UBFGGameFlowState_MissionResults* GetDefaultObj()
	{
		return GetDefaultObjImpl<UBFGGameFlowState_MissionResults>();
	}
};
static_assert(alignof(UBFGGameFlowState_MissionResults) == 0x000008, "Wrong alignment on UBFGGameFlowState_MissionResults");
static_assert(sizeof(UBFGGameFlowState_MissionResults) == 0x000200, "Wrong size on UBFGGameFlowState_MissionResults");
static_assert(offsetof(UBFGGameFlowState_MissionResults, M_strHandlerName_Accept) == 0x000108, "Member 'UBFGGameFlowState_MissionResults::M_strHandlerName_Accept' has a wrong offset!");
static_assert(offsetof(UBFGGameFlowState_MissionResults, M_strTextMissionFailed_Death) == 0x000110, "Member 'UBFGGameFlowState_MissionResults::M_strTextMissionFailed_Death' has a wrong offset!");
static_assert(offsetof(UBFGGameFlowState_MissionResults, M_strTextMissionFailed_Quest) == 0x000128, "Member 'UBFGGameFlowState_MissionResults::M_strTextMissionFailed_Quest' has a wrong offset!");
static_assert(offsetof(UBFGGameFlowState_MissionResults, M_strTextMissionFailed_BoundariesLeft) == 0x000140, "Member 'UBFGGameFlowState_MissionResults::M_strTextMissionFailed_BoundariesLeft' has a wrong offset!");
static_assert(offsetof(UBFGGameFlowState_MissionResults, M_pGameplayEndGFS) == 0x0001F0, "Member 'UBFGGameFlowState_MissionResults::M_pGameplayEndGFS' has a wrong offset!");
static_assert(offsetof(UBFGGameFlowState_MissionResults, M_bGotoMothership) == 0x0001F8, "Member 'UBFGGameFlowState_MissionResults::M_bGotoMothership' has a wrong offset!");
static_assert(offsetof(UBFGGameFlowState_MissionResults, M_bReplay) == 0x0001F9, "Member 'UBFGGameFlowState_MissionResults::M_bReplay' has a wrong offset!");

// Class BFGCore.BFGWidget_QuestEntry
// 0x0038 (0x0278 - 0x0240)
class UBFGWidget_QuestEntry : public UUserWidget
{
public:
	UMulticastDelegateProperty_                   M_OnHideAnimationFinished;                         // 0x0240(0x0018)(ZeroConstructor, InstancedReference, BlueprintCallable, NativeAccessSpecifierPublic)
	TArray<class UBFGWidget_SubquestEntry*>       M_apSubquestEntries;                               // 0x0258(0x0010)(ExportObject, ZeroConstructor, ContainsInstancedReference, Protected, NativeAccessSpecifierProtected)
	uint8                                         Pad_268[0x10];                                     // 0x0268(0x0010)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void ActionQuestEntry__DelegateSignature(class UBFGWidget_QuestEntry* _pQuestEntry);
	void AddSubquestEntry(class UBFGWidget_SubquestEntry* _pSubquestEntry);
	void ClearSubquestEntries();
	void Hide();
	void RebuildLayoutNative();
	void SetSpacerSize(const struct FVector2D& _vSize);
	void SetTitle(const class FText& _title);
	void Show();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"BFGWidget_QuestEntry">();
	}
	static class UBFGWidget_QuestEntry* GetDefaultObj()
	{
		return GetDefaultObjImpl<UBFGWidget_QuestEntry>();
	}
};
static_assert(alignof(UBFGWidget_QuestEntry) == 0x000008, "Wrong alignment on UBFGWidget_QuestEntry");
static_assert(sizeof(UBFGWidget_QuestEntry) == 0x000278, "Wrong size on UBFGWidget_QuestEntry");
static_assert(offsetof(UBFGWidget_QuestEntry, M_OnHideAnimationFinished) == 0x000240, "Member 'UBFGWidget_QuestEntry::M_OnHideAnimationFinished' has a wrong offset!");
static_assert(offsetof(UBFGWidget_QuestEntry, M_apSubquestEntries) == 0x000258, "Member 'UBFGWidget_QuestEntry::M_apSubquestEntries' has a wrong offset!");

// Class BFGCore.BFGGameFlowState_Cutscene
// 0x00C0 (0x0128 - 0x0068)
class UBFGGameFlowState_Cutscene final : public UBFGGameFlowState
{
public:
	class UBFGSequencePlayer*                     M_pPlayer;                                         // 0x0068(0x0008)(ExportObject, ZeroConstructor, Transient, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class ALevelSequenceActor*                    M_pSequence;                                       // 0x0070(0x0008)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_78[0x68];                                      // 0x0078(0x0068)(Fixing Size After Last Property [ Dumper-7 ])
	class UClass*                                 M_pCachedWidgetClass;                              // 0x00E0(0x0008)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UBFGWidget_Cutscene*                    M_pWidget;                                         // 0x00E8(0x0008)(ExportObject, ZeroConstructor, Transient, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_F0[0x38];                                      // 0x00F0(0x0038)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static bool IsPlayingCutscene();

	void SequenceInfo_Reset(class UBFGSequencePlayer* _pInfo);
	void VoiceoverLineComplete();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"BFGGameFlowState_Cutscene">();
	}
	static class UBFGGameFlowState_Cutscene* GetDefaultObj()
	{
		return GetDefaultObjImpl<UBFGGameFlowState_Cutscene>();
	}
};
static_assert(alignof(UBFGGameFlowState_Cutscene) == 0x000008, "Wrong alignment on UBFGGameFlowState_Cutscene");
static_assert(sizeof(UBFGGameFlowState_Cutscene) == 0x000128, "Wrong size on UBFGGameFlowState_Cutscene");
static_assert(offsetof(UBFGGameFlowState_Cutscene, M_pPlayer) == 0x000068, "Member 'UBFGGameFlowState_Cutscene::M_pPlayer' has a wrong offset!");
static_assert(offsetof(UBFGGameFlowState_Cutscene, M_pSequence) == 0x000070, "Member 'UBFGGameFlowState_Cutscene::M_pSequence' has a wrong offset!");
static_assert(offsetof(UBFGGameFlowState_Cutscene, M_pCachedWidgetClass) == 0x0000E0, "Member 'UBFGGameFlowState_Cutscene::M_pCachedWidgetClass' has a wrong offset!");
static_assert(offsetof(UBFGGameFlowState_Cutscene, M_pWidget) == 0x0000E8, "Member 'UBFGGameFlowState_Cutscene::M_pWidget' has a wrong offset!");

// Class BFGCore.BFGVisibilityCheckerPool_Box
// 0x0020 (0x0048 - 0x0028)
class UBFGVisibilityCheckerPool_Box final : public UObject
{
public:
	TArray<class ABFGVisibilityChecker_Box*>      M_aLockedInstances;                                // 0x0028(0x0010)(ZeroConstructor, Protected, NativeAccessSpecifierProtected)
	TArray<class ABFGVisibilityChecker_Box*>      M_aReleasedInstances;                              // 0x0038(0x0010)(ZeroConstructor, Protected, NativeAccessSpecifierProtected)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"BFGVisibilityCheckerPool_Box">();
	}
	static class UBFGVisibilityCheckerPool_Box* GetDefaultObj()
	{
		return GetDefaultObjImpl<UBFGVisibilityCheckerPool_Box>();
	}
};
static_assert(alignof(UBFGVisibilityCheckerPool_Box) == 0x000008, "Wrong alignment on UBFGVisibilityCheckerPool_Box");
static_assert(sizeof(UBFGVisibilityCheckerPool_Box) == 0x000048, "Wrong size on UBFGVisibilityCheckerPool_Box");
static_assert(offsetof(UBFGVisibilityCheckerPool_Box, M_aLockedInstances) == 0x000028, "Member 'UBFGVisibilityCheckerPool_Box::M_aLockedInstances' has a wrong offset!");
static_assert(offsetof(UBFGVisibilityCheckerPool_Box, M_aReleasedInstances) == 0x000038, "Member 'UBFGVisibilityCheckerPool_Box::M_aReleasedInstances' has a wrong offset!");

// Class BFGCore.BFGEventAction_CallDelegate
// 0x00F0 (0x0120 - 0x0030)
class UBFGEventAction_CallDelegate final : public UBFGEventAction
{
public:
	UMulticastDelegateProperty_                   M_delegate;                                        // 0x0030(0x0018)(ZeroConstructor, Transient, InstancedReference, Protected, NativeAccessSpecifierProtected)
	UMulticastDelegateProperty_                   M_waveCounterDelegate;                             // 0x0048(0x0018)(ZeroConstructor, Transient, InstancedReference, Protected, NativeAccessSpecifierProtected)
	UMulticastDelegateProperty_                   M_counterDelegate;                                 // 0x0060(0x0018)(ZeroConstructor, Transient, InstancedReference, Protected, NativeAccessSpecifierProtected)
	UMulticastDelegateProperty_                   M_narrativeDelegate;                               // 0x0078(0x0018)(ZeroConstructor, Transient, InstancedReference, Protected, NativeAccessSpecifierProtected)
	UMulticastDelegateProperty_                   M_defendDelegate;                                  // 0x0090(0x0018)(ZeroConstructor, Transient, InstancedReference, Protected, NativeAccessSpecifierProtected)
	UMulticastDelegateProperty_                   M_LimitCrossedDelegate;                            // 0x00A8(0x0018)(ZeroConstructor, Transient, InstancedReference, Protected, NativeAccessSpecifierProtected)
	UMulticastDelegateProperty_                   M_VandalizeAmountChangedDelegate;                  // 0x00C0(0x0018)(ZeroConstructor, Transient, InstancedReference, Protected, NativeAccessSpecifierProtected)
	UMulticastDelegateProperty_                   M_TimerSubgoalReachedDelegate;                     // 0x00D8(0x0018)(ZeroConstructor, Transient, InstancedReference, Protected, NativeAccessSpecifierProtected)
	TWeakObjectPtr<class UBFGQuest_Element>       M_pElement;                                        // 0x00F0(0x0008)(ExportObject, ZeroConstructor, Transient, InstancedReference, IsPlainOldData, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_F8[0x28];                                      // 0x00F8(0x0028)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"BFGEventAction_CallDelegate">();
	}
	static class UBFGEventAction_CallDelegate* GetDefaultObj()
	{
		return GetDefaultObjImpl<UBFGEventAction_CallDelegate>();
	}
};
static_assert(alignof(UBFGEventAction_CallDelegate) == 0x000008, "Wrong alignment on UBFGEventAction_CallDelegate");
static_assert(sizeof(UBFGEventAction_CallDelegate) == 0x000120, "Wrong size on UBFGEventAction_CallDelegate");
static_assert(offsetof(UBFGEventAction_CallDelegate, M_delegate) == 0x000030, "Member 'UBFGEventAction_CallDelegate::M_delegate' has a wrong offset!");
static_assert(offsetof(UBFGEventAction_CallDelegate, M_waveCounterDelegate) == 0x000048, "Member 'UBFGEventAction_CallDelegate::M_waveCounterDelegate' has a wrong offset!");
static_assert(offsetof(UBFGEventAction_CallDelegate, M_counterDelegate) == 0x000060, "Member 'UBFGEventAction_CallDelegate::M_counterDelegate' has a wrong offset!");
static_assert(offsetof(UBFGEventAction_CallDelegate, M_narrativeDelegate) == 0x000078, "Member 'UBFGEventAction_CallDelegate::M_narrativeDelegate' has a wrong offset!");
static_assert(offsetof(UBFGEventAction_CallDelegate, M_defendDelegate) == 0x000090, "Member 'UBFGEventAction_CallDelegate::M_defendDelegate' has a wrong offset!");
static_assert(offsetof(UBFGEventAction_CallDelegate, M_LimitCrossedDelegate) == 0x0000A8, "Member 'UBFGEventAction_CallDelegate::M_LimitCrossedDelegate' has a wrong offset!");
static_assert(offsetof(UBFGEventAction_CallDelegate, M_VandalizeAmountChangedDelegate) == 0x0000C0, "Member 'UBFGEventAction_CallDelegate::M_VandalizeAmountChangedDelegate' has a wrong offset!");
static_assert(offsetof(UBFGEventAction_CallDelegate, M_TimerSubgoalReachedDelegate) == 0x0000D8, "Member 'UBFGEventAction_CallDelegate::M_TimerSubgoalReachedDelegate' has a wrong offset!");
static_assert(offsetof(UBFGEventAction_CallDelegate, M_pElement) == 0x0000F0, "Member 'UBFGEventAction_CallDelegate::M_pElement' has a wrong offset!");

// Class BFGCore.BFGVehicleDeformation
// 0x0060 (0x0188 - 0x0128)
class UBFGVehicleDeformation : public UActorComponent
{
public:
	class UTextureRenderTarget2D*                 RenderTarget;                                      // 0x0128(0x0008)(Edit, BlueprintVisible, ZeroConstructor, Transient, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         RenderTargetResolution;                            // 0x0130(0x0004)(Edit, BlueprintVisible, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                LastWorldSpaceHitLocation;                         // 0x0134(0x000C)(Edit, BlueprintVisible, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         HistoryRadiusJitter;                               // 0x0140(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         breakableComponentRadius;                          // 0x0144(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         DeformationVelocityThreshold;                      // 0x0148(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         OnReleaseChance;                                   // 0x014C(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         OnDetachChance;                                    // 0x0150(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         SpotlightFrontThreshold;                           // 0x0154(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         SpotlightSideThreshold;                            // 0x0158(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_15C[0x4];                                      // 0x015C(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class UTexture*                               DeformerPaintTexture;                              // 0x0160(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         DeformationMaxAmplitude;                           // 0x0168(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         DeformationWeight;                                 // 0x016C(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FLinearColor                           M_renderColor;                                     // 0x0170(0x0010)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EBlendMode                                    M_eBlendMode;                                      // 0x0180(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_181[0x7];                                      // 0x0181(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void AddDeformerWeight(const struct FHitResult& _result, struct FVector2D* _vHitAxisClamped, struct FVector* _vHitWorldLocation);
	void CheckSpotLight(const struct FVector2D& _vHitAxis);
	void GetBreakablePartFromHit(const struct FVector& _vHitLocation);
	void OnSkeletalHit(class AActor* _pSelf, class AActor* _pOther, const struct FVector& _vNormal, const struct FHitResult& _hitResult);

	bool CheckHitValid(class AActor* _pSelf, class AActor* _pOther) const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"BFGVehicleDeformation">();
	}
	static class UBFGVehicleDeformation* GetDefaultObj()
	{
		return GetDefaultObjImpl<UBFGVehicleDeformation>();
	}
};
static_assert(alignof(UBFGVehicleDeformation) == 0x000008, "Wrong alignment on UBFGVehicleDeformation");
static_assert(sizeof(UBFGVehicleDeformation) == 0x000188, "Wrong size on UBFGVehicleDeformation");
static_assert(offsetof(UBFGVehicleDeformation, RenderTarget) == 0x000128, "Member 'UBFGVehicleDeformation::RenderTarget' has a wrong offset!");
static_assert(offsetof(UBFGVehicleDeformation, RenderTargetResolution) == 0x000130, "Member 'UBFGVehicleDeformation::RenderTargetResolution' has a wrong offset!");
static_assert(offsetof(UBFGVehicleDeformation, LastWorldSpaceHitLocation) == 0x000134, "Member 'UBFGVehicleDeformation::LastWorldSpaceHitLocation' has a wrong offset!");
static_assert(offsetof(UBFGVehicleDeformation, HistoryRadiusJitter) == 0x000140, "Member 'UBFGVehicleDeformation::HistoryRadiusJitter' has a wrong offset!");
static_assert(offsetof(UBFGVehicleDeformation, breakableComponentRadius) == 0x000144, "Member 'UBFGVehicleDeformation::breakableComponentRadius' has a wrong offset!");
static_assert(offsetof(UBFGVehicleDeformation, DeformationVelocityThreshold) == 0x000148, "Member 'UBFGVehicleDeformation::DeformationVelocityThreshold' has a wrong offset!");
static_assert(offsetof(UBFGVehicleDeformation, OnReleaseChance) == 0x00014C, "Member 'UBFGVehicleDeformation::OnReleaseChance' has a wrong offset!");
static_assert(offsetof(UBFGVehicleDeformation, OnDetachChance) == 0x000150, "Member 'UBFGVehicleDeformation::OnDetachChance' has a wrong offset!");
static_assert(offsetof(UBFGVehicleDeformation, SpotlightFrontThreshold) == 0x000154, "Member 'UBFGVehicleDeformation::SpotlightFrontThreshold' has a wrong offset!");
static_assert(offsetof(UBFGVehicleDeformation, SpotlightSideThreshold) == 0x000158, "Member 'UBFGVehicleDeformation::SpotlightSideThreshold' has a wrong offset!");
static_assert(offsetof(UBFGVehicleDeformation, DeformerPaintTexture) == 0x000160, "Member 'UBFGVehicleDeformation::DeformerPaintTexture' has a wrong offset!");
static_assert(offsetof(UBFGVehicleDeformation, DeformationMaxAmplitude) == 0x000168, "Member 'UBFGVehicleDeformation::DeformationMaxAmplitude' has a wrong offset!");
static_assert(offsetof(UBFGVehicleDeformation, DeformationWeight) == 0x00016C, "Member 'UBFGVehicleDeformation::DeformationWeight' has a wrong offset!");
static_assert(offsetof(UBFGVehicleDeformation, M_renderColor) == 0x000170, "Member 'UBFGVehicleDeformation::M_renderColor' has a wrong offset!");
static_assert(offsetof(UBFGVehicleDeformation, M_eBlendMode) == 0x000180, "Member 'UBFGVehicleDeformation::M_eBlendMode' has a wrong offset!");

// Class BFGCore.BFGEventAction_ChallengeAddScore
// 0x0010 (0x0040 - 0x0030)
class UBFGEventAction_ChallengeAddScore final : public UBFGEventAction
{
public:
	uint8                                         Pad_30[0x10];                                      // 0x0030(0x0010)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"BFGEventAction_ChallengeAddScore">();
	}
	static class UBFGEventAction_ChallengeAddScore* GetDefaultObj()
	{
		return GetDefaultObjImpl<UBFGEventAction_ChallengeAddScore>();
	}
};
static_assert(alignof(UBFGEventAction_ChallengeAddScore) == 0x000008, "Wrong alignment on UBFGEventAction_ChallengeAddScore");
static_assert(sizeof(UBFGEventAction_ChallengeAddScore) == 0x000040, "Wrong size on UBFGEventAction_ChallengeAddScore");

// Class BFGCore.BTTask_WaitForAirMineDelay
// 0x0000 (0x0078 - 0x0078)
class UBTTask_WaitForAirMineDelay final : public UBTTask_Wait
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"BTTask_WaitForAirMineDelay">();
	}
	static class UBTTask_WaitForAirMineDelay* GetDefaultObj()
	{
		return GetDefaultObjImpl<UBTTask_WaitForAirMineDelay>();
	}
};
static_assert(alignof(UBTTask_WaitForAirMineDelay) == 0x000008, "Wrong alignment on UBTTask_WaitForAirMineDelay");
static_assert(sizeof(UBTTask_WaitForAirMineDelay) == 0x000078, "Wrong size on UBTTask_WaitForAirMineDelay");

// Class BFGCore.BFGGameFlowState_ChallengeEnd
// 0x01B0 (0x02B8 - 0x0108)
class UBFGGameFlowState_ChallengeEnd final : public UBFGGameFlowState_GenericDialog_Customizable
{
public:
	class FName                                   M_strAccept;                                       // 0x0108(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   M_strContinue;                                     // 0x0110(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_118[0x198];                                    // 0x0118(0x0198)(Fixing Size After Last Property [ Dumper-7 ])
	class UBFGGameFlowState_GameplayEndSequence*  M_pGameplayEndGFS;                                 // 0x02B0(0x0008)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"BFGGameFlowState_ChallengeEnd">();
	}
	static class UBFGGameFlowState_ChallengeEnd* GetDefaultObj()
	{
		return GetDefaultObjImpl<UBFGGameFlowState_ChallengeEnd>();
	}
};
static_assert(alignof(UBFGGameFlowState_ChallengeEnd) == 0x000008, "Wrong alignment on UBFGGameFlowState_ChallengeEnd");
static_assert(sizeof(UBFGGameFlowState_ChallengeEnd) == 0x0002B8, "Wrong size on UBFGGameFlowState_ChallengeEnd");
static_assert(offsetof(UBFGGameFlowState_ChallengeEnd, M_strAccept) == 0x000108, "Member 'UBFGGameFlowState_ChallengeEnd::M_strAccept' has a wrong offset!");
static_assert(offsetof(UBFGGameFlowState_ChallengeEnd, M_strContinue) == 0x000110, "Member 'UBFGGameFlowState_ChallengeEnd::M_strContinue' has a wrong offset!");
static_assert(offsetof(UBFGGameFlowState_ChallengeEnd, M_pGameplayEndGFS) == 0x0002B0, "Member 'UBFGGameFlowState_ChallengeEnd::M_pGameplayEndGFS' has a wrong offset!");

// Class BFGCore.BFGEventAction_CleanUpFade
// 0x0010 (0x0040 - 0x0030)
class UBFGEventAction_CleanUpFade final : public UBFGEventAction
{
public:
	uint8                                         Pad_30[0x10];                                      // 0x0030(0x0010)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"BFGEventAction_CleanUpFade">();
	}
	static class UBFGEventAction_CleanUpFade* GetDefaultObj()
	{
		return GetDefaultObjImpl<UBFGEventAction_CleanUpFade>();
	}
};
static_assert(alignof(UBFGEventAction_CleanUpFade) == 0x000008, "Wrong alignment on UBFGEventAction_CleanUpFade");
static_assert(sizeof(UBFGEventAction_CleanUpFade) == 0x000040, "Wrong size on UBFGEventAction_CleanUpFade");

// Class BFGCore.BFGEventTrigger_WorldLoaded
// 0x0000 (0x0040 - 0x0040)
class UBFGEventTrigger_WorldLoaded final : public UBFGEventTrigger
{
public:
	void OnWorldLoaded(class UBFGGameInstance* _pGameInstance, class UWorld* _pWorld);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"BFGEventTrigger_WorldLoaded">();
	}
	static class UBFGEventTrigger_WorldLoaded* GetDefaultObj()
	{
		return GetDefaultObjImpl<UBFGEventTrigger_WorldLoaded>();
	}
};
static_assert(alignof(UBFGEventTrigger_WorldLoaded) == 0x000008, "Wrong alignment on UBFGEventTrigger_WorldLoaded");
static_assert(sizeof(UBFGEventTrigger_WorldLoaded) == 0x000040, "Wrong size on UBFGEventTrigger_WorldLoaded");

// Class BFGCore.BFGEventAction_ResetCortexScanVOTracker
// 0x0008 (0x0038 - 0x0030)
class UBFGEventAction_ResetCortexScanVOTracker final : public UBFGEventAction
{
public:
	class UBFGQuest_CortexScanObjectiveTracker*   M_pTracker;                                        // 0x0030(0x0008)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"BFGEventAction_ResetCortexScanVOTracker">();
	}
	static class UBFGEventAction_ResetCortexScanVOTracker* GetDefaultObj()
	{
		return GetDefaultObjImpl<UBFGEventAction_ResetCortexScanVOTracker>();
	}
};
static_assert(alignof(UBFGEventAction_ResetCortexScanVOTracker) == 0x000008, "Wrong alignment on UBFGEventAction_ResetCortexScanVOTracker");
static_assert(sizeof(UBFGEventAction_ResetCortexScanVOTracker) == 0x000038, "Wrong size on UBFGEventAction_ResetCortexScanVOTracker");
static_assert(offsetof(UBFGEventAction_ResetCortexScanVOTracker, M_pTracker) == 0x000030, "Member 'UBFGEventAction_ResetCortexScanVOTracker::M_pTracker' has a wrong offset!");

// Class BFGCore.BFGWidget_HUD_TextNotification
// 0x0008 (0x0300 - 0x02F8)
class UBFGWidget_HUD_TextNotification : public UBFGWidget_HUD
{
public:
	uint8                                         Pad_2F8[0x8];                                      // 0x02F8(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void OnHideMessage();
	void OnShowMessage(const class FText& Text, EBFGTextNotification_Severity Severity);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"BFGWidget_HUD_TextNotification">();
	}
	static class UBFGWidget_HUD_TextNotification* GetDefaultObj()
	{
		return GetDefaultObjImpl<UBFGWidget_HUD_TextNotification>();
	}
};
static_assert(alignof(UBFGWidget_HUD_TextNotification) == 0x000008, "Wrong alignment on UBFGWidget_HUD_TextNotification");
static_assert(sizeof(UBFGWidget_HUD_TextNotification) == 0x000300, "Wrong size on UBFGWidget_HUD_TextNotification");

// Class BFGCore.BFGGameFlowState_DialogPickSavegame
// 0x0070 (0x0178 - 0x0108)
class UBFGGameFlowState_DialogPickSavegame final : public UBFGGameFlowState_GenericDialog_Customizable
{
public:
	TSoftClassPtr<class UClass>                   M_pSlotOptionClass;                                // 0x0108(0x0028)(Edit, BlueprintVisible, BlueprintReadOnly, DisableEditOnInstance, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TSoftClassPtr<class UClass>                   M_pSlotOptionHandlerClass;                         // 0x0130(0x0028)(Edit, BlueprintVisible, BlueprintReadOnly, DisableEditOnInstance, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	UMulticastDelegateProperty_                   M_OnSavegameSlotAction;                            // 0x0158(0x0018)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	EBFGDialogOptionHandler_SavegameSlotMode      M_eSlotMode;                                       // 0x0170(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_171[0x7];                                      // 0x0171(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"BFGGameFlowState_DialogPickSavegame">();
	}
	static class UBFGGameFlowState_DialogPickSavegame* GetDefaultObj()
	{
		return GetDefaultObjImpl<UBFGGameFlowState_DialogPickSavegame>();
	}
};
static_assert(alignof(UBFGGameFlowState_DialogPickSavegame) == 0x000008, "Wrong alignment on UBFGGameFlowState_DialogPickSavegame");
static_assert(sizeof(UBFGGameFlowState_DialogPickSavegame) == 0x000178, "Wrong size on UBFGGameFlowState_DialogPickSavegame");
static_assert(offsetof(UBFGGameFlowState_DialogPickSavegame, M_pSlotOptionClass) == 0x000108, "Member 'UBFGGameFlowState_DialogPickSavegame::M_pSlotOptionClass' has a wrong offset!");
static_assert(offsetof(UBFGGameFlowState_DialogPickSavegame, M_pSlotOptionHandlerClass) == 0x000130, "Member 'UBFGGameFlowState_DialogPickSavegame::M_pSlotOptionHandlerClass' has a wrong offset!");
static_assert(offsetof(UBFGGameFlowState_DialogPickSavegame, M_OnSavegameSlotAction) == 0x000158, "Member 'UBFGGameFlowState_DialogPickSavegame::M_OnSavegameSlotAction' has a wrong offset!");
static_assert(offsetof(UBFGGameFlowState_DialogPickSavegame, M_eSlotMode) == 0x000170, "Member 'UBFGGameFlowState_DialogPickSavegame::M_eSlotMode' has a wrong offset!");

// Class BFGCore.BFGEventAction_EffectAction
// 0x0010 (0x0040 - 0x0030)
class UBFGEventAction_EffectAction final : public UBFGEventAction
{
public:
	uint8                                         Pad_30[0x8];                                       // 0x0030(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	class UObject*                                M_pContext;                                        // 0x0038(0x0008)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"BFGEventAction_EffectAction">();
	}
	static class UBFGEventAction_EffectAction* GetDefaultObj()
	{
		return GetDefaultObjImpl<UBFGEventAction_EffectAction>();
	}
};
static_assert(alignof(UBFGEventAction_EffectAction) == 0x000008, "Wrong alignment on UBFGEventAction_EffectAction");
static_assert(sizeof(UBFGEventAction_EffectAction) == 0x000040, "Wrong size on UBFGEventAction_EffectAction");
static_assert(offsetof(UBFGEventAction_EffectAction, M_pContext) == 0x000038, "Member 'UBFGEventAction_EffectAction::M_pContext' has a wrong offset!");

// Class BFGCore.BFGEventAction_LockCombat
// 0x0008 (0x0038 - 0x0030)
class UBFGEventAction_LockCombat final : public UBFGEventAction
{
public:
	uint8                                         Pad_30[0x8];                                       // 0x0030(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"BFGEventAction_LockCombat">();
	}
	static class UBFGEventAction_LockCombat* GetDefaultObj()
	{
		return GetDefaultObjImpl<UBFGEventAction_LockCombat>();
	}
};
static_assert(alignof(UBFGEventAction_LockCombat) == 0x000008, "Wrong alignment on UBFGEventAction_LockCombat");
static_assert(sizeof(UBFGEventAction_LockCombat) == 0x000038, "Wrong size on UBFGEventAction_LockCombat");

// Class BFGCore.BFGEventAction_UnlockInput
// 0x0008 (0x0038 - 0x0030)
class UBFGEventAction_UnlockInput final : public UBFGEventAction
{
public:
	uint8                                         Pad_30[0x8];                                       // 0x0030(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"BFGEventAction_UnlockInput">();
	}
	static class UBFGEventAction_UnlockInput* GetDefaultObj()
	{
		return GetDefaultObjImpl<UBFGEventAction_UnlockInput>();
	}
};
static_assert(alignof(UBFGEventAction_UnlockInput) == 0x000008, "Wrong alignment on UBFGEventAction_UnlockInput");
static_assert(sizeof(UBFGEventAction_UnlockInput) == 0x000038, "Wrong size on UBFGEventAction_UnlockInput");

// Class BFGCore.BFGEventAction_MenuFactory
// 0x0018 (0x0048 - 0x0030)
class UBFGEventAction_MenuFactory final : public UBFGEventAction
{
public:
	uint8                                         Pad_30[0x10];                                      // 0x0030(0x0010)(Fixing Size After Last Property [ Dumper-7 ])
	class UObject*                                M_pMenuContext;                                    // 0x0040(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"BFGEventAction_MenuFactory">();
	}
	static class UBFGEventAction_MenuFactory* GetDefaultObj()
	{
		return GetDefaultObjImpl<UBFGEventAction_MenuFactory>();
	}
};
static_assert(alignof(UBFGEventAction_MenuFactory) == 0x000008, "Wrong alignment on UBFGEventAction_MenuFactory");
static_assert(sizeof(UBFGEventAction_MenuFactory) == 0x000048, "Wrong size on UBFGEventAction_MenuFactory");
static_assert(offsetof(UBFGEventAction_MenuFactory, M_pMenuContext) == 0x000040, "Member 'UBFGEventAction_MenuFactory::M_pMenuContext' has a wrong offset!");

// Class BFGCore.BFGGameFlowState_LevelSwitchToMainMenu
// 0x0040 (0x0160 - 0x0120)
class UBFGGameFlowState_LevelSwitchToMainMenu final : public UBFGGameFlowState_LevelSwitch
{
public:
	uint8                                         Pad_120[0x8];                                      // 0x0120(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	struct FBFGSavedMapDescription                M_currentMap;                                      // 0x0128(0x0038)(Protected, NativeAccessSpecifierProtected)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"BFGGameFlowState_LevelSwitchToMainMenu">();
	}
	static class UBFGGameFlowState_LevelSwitchToMainMenu* GetDefaultObj()
	{
		return GetDefaultObjImpl<UBFGGameFlowState_LevelSwitchToMainMenu>();
	}
};
static_assert(alignof(UBFGGameFlowState_LevelSwitchToMainMenu) == 0x000008, "Wrong alignment on UBFGGameFlowState_LevelSwitchToMainMenu");
static_assert(sizeof(UBFGGameFlowState_LevelSwitchToMainMenu) == 0x000160, "Wrong size on UBFGGameFlowState_LevelSwitchToMainMenu");
static_assert(offsetof(UBFGGameFlowState_LevelSwitchToMainMenu, M_currentMap) == 0x000128, "Member 'UBFGGameFlowState_LevelSwitchToMainMenu::M_currentMap' has a wrong offset!");

// Class BFGCore.BFGEventAction_MonetaryValue
// 0x0010 (0x0040 - 0x0030)
class UBFGEventAction_MonetaryValue final : public UBFGEventAction
{
public:
	uint8                                         Pad_30[0x10];                                      // 0x0030(0x0010)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"BFGEventAction_MonetaryValue">();
	}
	static class UBFGEventAction_MonetaryValue* GetDefaultObj()
	{
		return GetDefaultObjImpl<UBFGEventAction_MonetaryValue>();
	}
};
static_assert(alignof(UBFGEventAction_MonetaryValue) == 0x000008, "Wrong alignment on UBFGEventAction_MonetaryValue");
static_assert(sizeof(UBFGEventAction_MonetaryValue) == 0x000040, "Wrong size on UBFGEventAction_MonetaryValue");

// Class BFGCore.BFGEventAction_ObjectiveConsume
// 0x0010 (0x0040 - 0x0030)
class UBFGEventAction_ObjectiveConsume final : public UBFGEventAction
{
public:
	uint8                                         Pad_30[0x10];                                      // 0x0030(0x0010)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"BFGEventAction_ObjectiveConsume">();
	}
	static class UBFGEventAction_ObjectiveConsume* GetDefaultObj()
	{
		return GetDefaultObjImpl<UBFGEventAction_ObjectiveConsume>();
	}
};
static_assert(alignof(UBFGEventAction_ObjectiveConsume) == 0x000008, "Wrong alignment on UBFGEventAction_ObjectiveConsume");
static_assert(sizeof(UBFGEventAction_ObjectiveConsume) == 0x000040, "Wrong size on UBFGEventAction_ObjectiveConsume");

// Class BFGCore.BFGGameFlowState_DebugStartMenu
// 0x0078 (0x0180 - 0x0108)
class UBFGGameFlowState_DebugStartMenu final : public UBFGGameFlowState_GenericDialog_Customizable
{
public:
	class FName                                   M_strHandlerName_NewGame;                          // 0x0108(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class FName                                   M_strHandlerName_MainMenu;                         // 0x0110(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class FName                                   M_strHandlerName_Mothership;                       // 0x0118(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class FName                                   M_strHandlerName_GateMap;                          // 0x0120(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	EBFGGameFlowState_DebugStartMenu_Actions      M_action;                                          // 0x0128(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_129[0x7];                                      // 0x0129(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	struct FBFGDebugStartMenu_EntryData           M_dataStartAt;                                     // 0x0130(0x0050)(Transient, Protected, NativeAccessSpecifierProtected)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"BFGGameFlowState_DebugStartMenu">();
	}
	static class UBFGGameFlowState_DebugStartMenu* GetDefaultObj()
	{
		return GetDefaultObjImpl<UBFGGameFlowState_DebugStartMenu>();
	}
};
static_assert(alignof(UBFGGameFlowState_DebugStartMenu) == 0x000008, "Wrong alignment on UBFGGameFlowState_DebugStartMenu");
static_assert(sizeof(UBFGGameFlowState_DebugStartMenu) == 0x000180, "Wrong size on UBFGGameFlowState_DebugStartMenu");
static_assert(offsetof(UBFGGameFlowState_DebugStartMenu, M_strHandlerName_NewGame) == 0x000108, "Member 'UBFGGameFlowState_DebugStartMenu::M_strHandlerName_NewGame' has a wrong offset!");
static_assert(offsetof(UBFGGameFlowState_DebugStartMenu, M_strHandlerName_MainMenu) == 0x000110, "Member 'UBFGGameFlowState_DebugStartMenu::M_strHandlerName_MainMenu' has a wrong offset!");
static_assert(offsetof(UBFGGameFlowState_DebugStartMenu, M_strHandlerName_Mothership) == 0x000118, "Member 'UBFGGameFlowState_DebugStartMenu::M_strHandlerName_Mothership' has a wrong offset!");
static_assert(offsetof(UBFGGameFlowState_DebugStartMenu, M_strHandlerName_GateMap) == 0x000120, "Member 'UBFGGameFlowState_DebugStartMenu::M_strHandlerName_GateMap' has a wrong offset!");
static_assert(offsetof(UBFGGameFlowState_DebugStartMenu, M_action) == 0x000128, "Member 'UBFGGameFlowState_DebugStartMenu::M_action' has a wrong offset!");
static_assert(offsetof(UBFGGameFlowState_DebugStartMenu, M_dataStartAt) == 0x000130, "Member 'UBFGGameFlowState_DebugStartMenu::M_dataStartAt' has a wrong offset!");

// Class BFGCore.BFGEventAction_ResourceValue
// 0x0018 (0x0048 - 0x0030)
class UBFGEventAction_ResourceValue final : public UBFGEventAction
{
public:
	uint8                                         Pad_30[0x8];                                       // 0x0030(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	class UBFGQuest_Challenge*                    M_pQuestChallenge;                                 // 0x0038(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UBFGQuest_ElementCollectResource*       M_pCollectRessourceElement;                        // 0x0040(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"BFGEventAction_ResourceValue">();
	}
	static class UBFGEventAction_ResourceValue* GetDefaultObj()
	{
		return GetDefaultObjImpl<UBFGEventAction_ResourceValue>();
	}
};
static_assert(alignof(UBFGEventAction_ResourceValue) == 0x000008, "Wrong alignment on UBFGEventAction_ResourceValue");
static_assert(sizeof(UBFGEventAction_ResourceValue) == 0x000048, "Wrong size on UBFGEventAction_ResourceValue");
static_assert(offsetof(UBFGEventAction_ResourceValue, M_pQuestChallenge) == 0x000038, "Member 'UBFGEventAction_ResourceValue::M_pQuestChallenge' has a wrong offset!");
static_assert(offsetof(UBFGEventAction_ResourceValue, M_pCollectRessourceElement) == 0x000040, "Member 'UBFGEventAction_ResourceValue::M_pCollectRessourceElement' has a wrong offset!");

// Class BFGCore.BFGNetworkPathActor
// 0x0030 (0x0408 - 0x03D8)
class ABFGNetworkPathActor : public AActor
{
public:
	uint8                                         Pad_3D8[0x8];                                      // 0x03D8(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	class UBFGNetworkPathComponent*               NetworkPathComponent;                              // 0x03E0(0x0008)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, EditConst, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FGameplayTagContainer                  M_gameplayTags;                                    // 0x03E8(0x0020)(Edit, BlueprintVisible, BlueprintReadOnly, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"BFGNetworkPathActor">();
	}
	static class ABFGNetworkPathActor* GetDefaultObj()
	{
		return GetDefaultObjImpl<ABFGNetworkPathActor>();
	}
};
static_assert(alignof(ABFGNetworkPathActor) == 0x000008, "Wrong alignment on ABFGNetworkPathActor");
static_assert(sizeof(ABFGNetworkPathActor) == 0x000408, "Wrong size on ABFGNetworkPathActor");
static_assert(offsetof(ABFGNetworkPathActor, NetworkPathComponent) == 0x0003E0, "Member 'ABFGNetworkPathActor::NetworkPathComponent' has a wrong offset!");
static_assert(offsetof(ABFGNetworkPathActor, M_gameplayTags) == 0x0003E8, "Member 'ABFGNetworkPathActor::M_gameplayTags' has a wrong offset!");

// Class BFGCore.BFGEventAction_SaveSystem
// 0x0028 (0x0058 - 0x0030)
class UBFGEventAction_SaveSystem final : public UBFGEventAction
{
public:
	class UBFGSaveContext*                        M_pSaveContext;                                    // 0x0030(0x0008)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_38[0x8];                                       // 0x0038(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	class UBFGQuest*                              M_pQuest;                                          // 0x0040(0x0008)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_48[0x10];                                      // 0x0048(0x0010)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"BFGEventAction_SaveSystem">();
	}
	static class UBFGEventAction_SaveSystem* GetDefaultObj()
	{
		return GetDefaultObjImpl<UBFGEventAction_SaveSystem>();
	}
};
static_assert(alignof(UBFGEventAction_SaveSystem) == 0x000008, "Wrong alignment on UBFGEventAction_SaveSystem");
static_assert(sizeof(UBFGEventAction_SaveSystem) == 0x000058, "Wrong size on UBFGEventAction_SaveSystem");
static_assert(offsetof(UBFGEventAction_SaveSystem, M_pSaveContext) == 0x000030, "Member 'UBFGEventAction_SaveSystem::M_pSaveContext' has a wrong offset!");
static_assert(offsetof(UBFGEventAction_SaveSystem, M_pQuest) == 0x000040, "Member 'UBFGEventAction_SaveSystem::M_pQuest' has a wrong offset!");

// Class BFGCore.BFGGameFlowStateManager
// 0x0060 (0x0088 - 0x0028)
class UBFGGameFlowStateManager final : public UObject
{
public:
	uint8                                         Pad_28[0x8];                                       // 0x0028(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	TWeakObjectPtr<class UBFGGameInstance>        M_pGameInstance;                                   // 0x0030(0x0008)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	TArray<class UBFGGameFlowState*>              M_aspStateList;                                    // 0x0038(0x0010)(ZeroConstructor, Transient, NativeAccessSpecifierPrivate)
	TArray<struct FBFGGameFlowStateInfo>          M_aTargetState;                                    // 0x0048(0x0010)(ZeroConstructor, Transient, NativeAccessSpecifierPrivate)
	uint8                                         Pad_58[0x30];                                      // 0x0058(0x0030)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void AddStateToStack(class UBFGGameFlowState* _pState, bool _bKeepCurrent);
	void ClearStateStack();
	class UBFGGameFlowState* FindStateByType(const class UClass* _pClass, bool _bPendingStates);
	void ForceLeaveStatesUntil(class UBFGGameFlowState* _pState);

	class UBFGGameFlowState* GetBottomGameState() const;
	class UBFGGameFlowState* GetCurrentState() const;
	class UBFGGameInstance* GetGameInstance() const;
	class UBFGGameFlowState* GetPreviousState() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"BFGGameFlowStateManager">();
	}
	static class UBFGGameFlowStateManager* GetDefaultObj()
	{
		return GetDefaultObjImpl<UBFGGameFlowStateManager>();
	}
};
static_assert(alignof(UBFGGameFlowStateManager) == 0x000008, "Wrong alignment on UBFGGameFlowStateManager");
static_assert(sizeof(UBFGGameFlowStateManager) == 0x000088, "Wrong size on UBFGGameFlowStateManager");
static_assert(offsetof(UBFGGameFlowStateManager, M_pGameInstance) == 0x000030, "Member 'UBFGGameFlowStateManager::M_pGameInstance' has a wrong offset!");
static_assert(offsetof(UBFGGameFlowStateManager, M_aspStateList) == 0x000038, "Member 'UBFGGameFlowStateManager::M_aspStateList' has a wrong offset!");
static_assert(offsetof(UBFGGameFlowStateManager, M_aTargetState) == 0x000048, "Member 'UBFGGameFlowStateManager::M_aTargetState' has a wrong offset!");

// Class BFGCore.BFGEventAction_StartAITask
// 0x0018 (0x0048 - 0x0030)
class UBFGEventAction_StartAITask final : public UBFGEventAction
{
public:
	uint8                                         Pad_30[0x10];                                      // 0x0030(0x0010)(Fixing Size After Last Property [ Dumper-7 ])
	TWeakObjectPtr<class UBFG_AITask>             M_pTask;                                           // 0x0040(0x0008)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"BFGEventAction_StartAITask">();
	}
	static class UBFGEventAction_StartAITask* GetDefaultObj()
	{
		return GetDefaultObjImpl<UBFGEventAction_StartAITask>();
	}
};
static_assert(alignof(UBFGEventAction_StartAITask) == 0x000008, "Wrong alignment on UBFGEventAction_StartAITask");
static_assert(sizeof(UBFGEventAction_StartAITask) == 0x000048, "Wrong size on UBFGEventAction_StartAITask");
static_assert(offsetof(UBFGEventAction_StartAITask, M_pTask) == 0x000040, "Member 'UBFGEventAction_StartAITask::M_pTask' has a wrong offset!");

// Class BFGCore.BFGInputAction_CameraHandleDefaultRotation
// 0x0000 (0x0030 - 0x0030)
class UBFGInputAction_CameraHandleDefaultRotation final : public UBFGInputAction
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"BFGInputAction_CameraHandleDefaultRotation">();
	}
	static class UBFGInputAction_CameraHandleDefaultRotation* GetDefaultObj()
	{
		return GetDefaultObjImpl<UBFGInputAction_CameraHandleDefaultRotation>();
	}
};
static_assert(alignof(UBFGInputAction_CameraHandleDefaultRotation) == 0x000008, "Wrong alignment on UBFGInputAction_CameraHandleDefaultRotation");
static_assert(sizeof(UBFGInputAction_CameraHandleDefaultRotation) == 0x000030, "Wrong size on UBFGInputAction_CameraHandleDefaultRotation");

// Class BFGCore.BFGEventAction_StartFade
// 0x0020 (0x0050 - 0x0030)
class UBFGEventAction_StartFade final : public UBFGEventAction
{
public:
	uint8                                         Pad_30[0x20];                                      // 0x0030(0x0020)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"BFGEventAction_StartFade">();
	}
	static class UBFGEventAction_StartFade* GetDefaultObj()
	{
		return GetDefaultObjImpl<UBFGEventAction_StartFade>();
	}
};
static_assert(alignof(UBFGEventAction_StartFade) == 0x000008, "Wrong alignment on UBFGEventAction_StartFade");
static_assert(sizeof(UBFGEventAction_StartFade) == 0x000050, "Wrong size on UBFGEventAction_StartFade");

// Class BFGCore.BFGEventAction_StopChallenge
// 0x0008 (0x0038 - 0x0030)
class UBFGEventAction_StopChallenge final : public UBFGEventAction
{
public:
	uint8                                         Pad_30[0x8];                                       // 0x0030(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"BFGEventAction_StopChallenge">();
	}
	static class UBFGEventAction_StopChallenge* GetDefaultObj()
	{
		return GetDefaultObjImpl<UBFGEventAction_StopChallenge>();
	}
};
static_assert(alignof(UBFGEventAction_StopChallenge) == 0x000008, "Wrong alignment on UBFGEventAction_StopChallenge");
static_assert(sizeof(UBFGEventAction_StopChallenge) == 0x000038, "Wrong size on UBFGEventAction_StopChallenge");

// Class BFGCore.BFGNetworkPathAgent_AIStateGotoLocation
// 0x0018 (0x0070 - 0x0058)
class UBFGNetworkPathAgent_AIStateGotoLocation final : public UBFGNetworkPathAgent_AIStateBase
{
public:
	uint8                                         Pad_58[0x18];                                      // 0x0058(0x0018)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"BFGNetworkPathAgent_AIStateGotoLocation">();
	}
	static class UBFGNetworkPathAgent_AIStateGotoLocation* GetDefaultObj()
	{
		return GetDefaultObjImpl<UBFGNetworkPathAgent_AIStateGotoLocation>();
	}
};
static_assert(alignof(UBFGNetworkPathAgent_AIStateGotoLocation) == 0x000008, "Wrong alignment on UBFGNetworkPathAgent_AIStateGotoLocation");
static_assert(sizeof(UBFGNetworkPathAgent_AIStateGotoLocation) == 0x000070, "Wrong size on UBFGNetworkPathAgent_AIStateGotoLocation");

// Class BFGCore.BFGEventAction_Streaming
// 0x0020 (0x0050 - 0x0030)
class UBFGEventAction_Streaming final : public UBFGEventAction
{
public:
	uint8                                         Pad_30[0x8];                                       // 0x0030(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	class UBFGQuest*                              M_pQuest;                                          // 0x0038(0x0008)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_40[0x10];                                      // 0x0040(0x0010)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"BFGEventAction_Streaming">();
	}
	static class UBFGEventAction_Streaming* GetDefaultObj()
	{
		return GetDefaultObjImpl<UBFGEventAction_Streaming>();
	}
};
static_assert(alignof(UBFGEventAction_Streaming) == 0x000008, "Wrong alignment on UBFGEventAction_Streaming");
static_assert(sizeof(UBFGEventAction_Streaming) == 0x000050, "Wrong size on UBFGEventAction_Streaming");
static_assert(offsetof(UBFGEventAction_Streaming, M_pQuest) == 0x000038, "Member 'UBFGEventAction_Streaming::M_pQuest' has a wrong offset!");

// Class BFGCore.BFGGameplayEffectResponse_BlockFuel
// 0x0000 (0x0080 - 0x0080)
class UBFGGameplayEffectResponse_BlockFuel : public UBFGGameplayEffectResponse
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"BFGGameplayEffectResponse_BlockFuel">();
	}
	static class UBFGGameplayEffectResponse_BlockFuel* GetDefaultObj()
	{
		return GetDefaultObjImpl<UBFGGameplayEffectResponse_BlockFuel>();
	}
};
static_assert(alignof(UBFGGameplayEffectResponse_BlockFuel) == 0x000008, "Wrong alignment on UBFGGameplayEffectResponse_BlockFuel");
static_assert(sizeof(UBFGGameplayEffectResponse_BlockFuel) == 0x000080, "Wrong size on UBFGGameplayEffectResponse_BlockFuel");

// Class BFGCore.BFGEventAction_UpdateQuestUI
// 0x0010 (0x0040 - 0x0030)
class UBFGEventAction_UpdateQuestUI final : public UBFGEventAction
{
public:
	class UBFGQuest*                              M_pQuest;                                          // 0x0030(0x0008)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UBFGQuest_Element*                      M_pElement;                                        // 0x0038(0x0008)(ExportObject, ZeroConstructor, Transient, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"BFGEventAction_UpdateQuestUI">();
	}
	static class UBFGEventAction_UpdateQuestUI* GetDefaultObj()
	{
		return GetDefaultObjImpl<UBFGEventAction_UpdateQuestUI>();
	}
};
static_assert(alignof(UBFGEventAction_UpdateQuestUI) == 0x000008, "Wrong alignment on UBFGEventAction_UpdateQuestUI");
static_assert(sizeof(UBFGEventAction_UpdateQuestUI) == 0x000040, "Wrong size on UBFGEventAction_UpdateQuestUI");
static_assert(offsetof(UBFGEventAction_UpdateQuestUI, M_pQuest) == 0x000030, "Member 'UBFGEventAction_UpdateQuestUI::M_pQuest' has a wrong offset!");
static_assert(offsetof(UBFGEventAction_UpdateQuestUI, M_pElement) == 0x000038, "Member 'UBFGEventAction_UpdateQuestUI::M_pElement' has a wrong offset!");

// Class BFGCore.BFGEventAction_VariableAction
// 0x0018 (0x0048 - 0x0030)
class UBFGEventAction_VariableAction final : public UBFGEventAction
{
public:
	uint8                                         Pad_30[0x8];                                       // 0x0030(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	class UBFGVariable*                           M_pVariable;                                       // 0x0038(0x0008)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_40[0x8];                                       // 0x0040(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"BFGEventAction_VariableAction">();
	}
	static class UBFGEventAction_VariableAction* GetDefaultObj()
	{
		return GetDefaultObjImpl<UBFGEventAction_VariableAction>();
	}
};
static_assert(alignof(UBFGEventAction_VariableAction) == 0x000008, "Wrong alignment on UBFGEventAction_VariableAction");
static_assert(sizeof(UBFGEventAction_VariableAction) == 0x000048, "Wrong size on UBFGEventAction_VariableAction");
static_assert(offsetof(UBFGEventAction_VariableAction, M_pVariable) == 0x000038, "Member 'UBFGEventAction_VariableAction::M_pVariable' has a wrong offset!");

// Class BFGCore.BFGInputAction_EquipmentSelect
// 0x0008 (0x0038 - 0x0030)
class UBFGInputAction_EquipmentSelect : public UBFGInputAction
{
public:
	uint8                                         Pad_30[0x8];                                       // 0x0030(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"BFGInputAction_EquipmentSelect">();
	}
	static class UBFGInputAction_EquipmentSelect* GetDefaultObj()
	{
		return GetDefaultObjImpl<UBFGInputAction_EquipmentSelect>();
	}
};
static_assert(alignof(UBFGInputAction_EquipmentSelect) == 0x000008, "Wrong alignment on UBFGInputAction_EquipmentSelect");
static_assert(sizeof(UBFGInputAction_EquipmentSelect) == 0x000038, "Wrong size on UBFGInputAction_EquipmentSelect");

// Class BFGCore.BFGInputAction_EquipmentSelectDeathRay
// 0x0000 (0x0038 - 0x0038)
class UBFGInputAction_EquipmentSelectDeathRay final : public UBFGInputAction_EquipmentSelect
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"BFGInputAction_EquipmentSelectDeathRay">();
	}
	static class UBFGInputAction_EquipmentSelectDeathRay* GetDefaultObj()
	{
		return GetDefaultObjImpl<UBFGInputAction_EquipmentSelectDeathRay>();
	}
};
static_assert(alignof(UBFGInputAction_EquipmentSelectDeathRay) == 0x000008, "Wrong alignment on UBFGInputAction_EquipmentSelectDeathRay");
static_assert(sizeof(UBFGInputAction_EquipmentSelectDeathRay) == 0x000038, "Wrong size on UBFGInputAction_EquipmentSelectDeathRay");

// Class BFGCore.BFGEventAction_VariableSet
// 0x0010 (0x0040 - 0x0030)
class UBFGEventAction_VariableSet final : public UBFGEventAction
{
public:
	uint8                                         Pad_30[0x10];                                      // 0x0030(0x0010)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"BFGEventAction_VariableSet">();
	}
	static class UBFGEventAction_VariableSet* GetDefaultObj()
	{
		return GetDefaultObjImpl<UBFGEventAction_VariableSet>();
	}
};
static_assert(alignof(UBFGEventAction_VariableSet) == 0x000008, "Wrong alignment on UBFGEventAction_VariableSet");
static_assert(sizeof(UBFGEventAction_VariableSet) == 0x000040, "Wrong size on UBFGEventAction_VariableSet");

// Class BFGCore.BFGEventManager
// 0x0038 (0x0068 - 0x0030)
class UBFGEventManager final : public UBFGGameSystem
{
public:
	uint8                                         Pad_30[0x8];                                       // 0x0030(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	class ABFGGameState*                          M_pGameState;                                      // 0x0038(0x0008)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	TArray<class UBFGEvent*>                      M_aActiveEvents;                                   // 0x0040(0x0010)(ZeroConstructor, Transient, NativeAccessSpecifierPrivate)
	TArray<struct FBFGEventContext>               M_aTriggeredEvents;                                // 0x0050(0x0010)(ZeroConstructor, Transient, NativeAccessSpecifierPrivate)
	class UBFGEvent_DelegateForwarding*           M_pDelegateForwarding;                             // 0x0060(0x0008)(ExportObject, ZeroConstructor, Transient, InstancedReference, IsPlainOldData, NoDestructor, PersistentInstance, HasGetValueTypeHash, NativeAccessSpecifierPrivate)

public:
	void GameSystem_EventsLog() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"BFGEventManager">();
	}
	static class UBFGEventManager* GetDefaultObj()
	{
		return GetDefaultObjImpl<UBFGEventManager>();
	}
};
static_assert(alignof(UBFGEventManager) == 0x000008, "Wrong alignment on UBFGEventManager");
static_assert(sizeof(UBFGEventManager) == 0x000068, "Wrong size on UBFGEventManager");
static_assert(offsetof(UBFGEventManager, M_pGameState) == 0x000038, "Member 'UBFGEventManager::M_pGameState' has a wrong offset!");
static_assert(offsetof(UBFGEventManager, M_aActiveEvents) == 0x000040, "Member 'UBFGEventManager::M_aActiveEvents' has a wrong offset!");
static_assert(offsetof(UBFGEventManager, M_aTriggeredEvents) == 0x000050, "Member 'UBFGEventManager::M_aTriggeredEvents' has a wrong offset!");
static_assert(offsetof(UBFGEventManager, M_pDelegateForwarding) == 0x000060, "Member 'UBFGEventManager::M_pDelegateForwarding' has a wrong offset!");

// Class BFGCore.BFGNetworkPathAgent_AIStateStandBy
// 0x0018 (0x0070 - 0x0058)
class UBFGNetworkPathAgent_AIStateStandBy : public UBFGNetworkPathAgent_AIStateBase
{
public:
	struct FVector                                M_vLocation;                                       // 0x0058(0x000C)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         M_fTolerance;                                      // 0x0064(0x0004)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	EBFGAIStateStandBy_Phase                      M_eCurrentPhase;                                   // 0x0068(0x0001)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_69[0x7];                                       // 0x0069(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"BFGNetworkPathAgent_AIStateStandBy">();
	}
	static class UBFGNetworkPathAgent_AIStateStandBy* GetDefaultObj()
	{
		return GetDefaultObjImpl<UBFGNetworkPathAgent_AIStateStandBy>();
	}
};
static_assert(alignof(UBFGNetworkPathAgent_AIStateStandBy) == 0x000008, "Wrong alignment on UBFGNetworkPathAgent_AIStateStandBy");
static_assert(sizeof(UBFGNetworkPathAgent_AIStateStandBy) == 0x000070, "Wrong size on UBFGNetworkPathAgent_AIStateStandBy");
static_assert(offsetof(UBFGNetworkPathAgent_AIStateStandBy, M_vLocation) == 0x000058, "Member 'UBFGNetworkPathAgent_AIStateStandBy::M_vLocation' has a wrong offset!");
static_assert(offsetof(UBFGNetworkPathAgent_AIStateStandBy, M_fTolerance) == 0x000064, "Member 'UBFGNetworkPathAgent_AIStateStandBy::M_fTolerance' has a wrong offset!");
static_assert(offsetof(UBFGNetworkPathAgent_AIStateStandBy, M_eCurrentPhase) == 0x000068, "Member 'UBFGNetworkPathAgent_AIStateStandBy::M_eCurrentPhase' has a wrong offset!");

// Class BFGCore.BFGEventTest_AITaskCanStart
// 0x0018 (0x0040 - 0x0028)
class UBFGEventTest_AITaskCanStart final : public UBFGEventTest
{
public:
	uint8                                         Pad_28[0x10];                                      // 0x0028(0x0010)(Fixing Size After Last Property [ Dumper-7 ])
	TWeakObjectPtr<class UBFG_AITask>             M_pAITask;                                         // 0x0038(0x0008)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"BFGEventTest_AITaskCanStart">();
	}
	static class UBFGEventTest_AITaskCanStart* GetDefaultObj()
	{
		return GetDefaultObjImpl<UBFGEventTest_AITaskCanStart>();
	}
};
static_assert(alignof(UBFGEventTest_AITaskCanStart) == 0x000008, "Wrong alignment on UBFGEventTest_AITaskCanStart");
static_assert(sizeof(UBFGEventTest_AITaskCanStart) == 0x000040, "Wrong size on UBFGEventTest_AITaskCanStart");
static_assert(offsetof(UBFGEventTest_AITaskCanStart, M_pAITask) == 0x000038, "Member 'UBFGEventTest_AITaskCanStart::M_pAITask' has a wrong offset!");

// Class BFGCore.BFGInputAction_UINull
// 0x0000 (0x0030 - 0x0030)
class UBFGInputAction_UINull final : public UBFGInputAction_UI
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"BFGInputAction_UINull">();
	}
	static class UBFGInputAction_UINull* GetDefaultObj()
	{
		return GetDefaultObjImpl<UBFGInputAction_UINull>();
	}
};
static_assert(alignof(UBFGInputAction_UINull) == 0x000008, "Wrong alignment on UBFGInputAction_UINull");
static_assert(sizeof(UBFGInputAction_UINull) == 0x000030, "Wrong size on UBFGInputAction_UINull");

// Class BFGCore.BFGEventTest_ChallengeCanStart
// 0x0008 (0x0030 - 0x0028)
class UBFGEventTest_ChallengeCanStart final : public UBFGEventTest
{
public:
	uint8                                         Pad_28[0x8];                                       // 0x0028(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"BFGEventTest_ChallengeCanStart">();
	}
	static class UBFGEventTest_ChallengeCanStart* GetDefaultObj()
	{
		return GetDefaultObjImpl<UBFGEventTest_ChallengeCanStart>();
	}
};
static_assert(alignof(UBFGEventTest_ChallengeCanStart) == 0x000008, "Wrong alignment on UBFGEventTest_ChallengeCanStart");
static_assert(sizeof(UBFGEventTest_ChallengeCanStart) == 0x000030, "Wrong size on UBFGEventTest_ChallengeCanStart");

// Class BFGCore.BFGInputAction_IngameMenu
// 0x0000 (0x0030 - 0x0030)
class UBFGInputAction_IngameMenu final : public UBFGInputAction
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"BFGInputAction_IngameMenu">();
	}
	static class UBFGInputAction_IngameMenu* GetDefaultObj()
	{
		return GetDefaultObjImpl<UBFGInputAction_IngameMenu>();
	}
};
static_assert(alignof(UBFGInputAction_IngameMenu) == 0x000008, "Wrong alignment on UBFGInputAction_IngameMenu");
static_assert(sizeof(UBFGInputAction_IngameMenu) == 0x000030, "Wrong size on UBFGInputAction_IngameMenu");

// Class BFGCore.BFGEventTest_CheckpointValid
// 0x0010 (0x0038 - 0x0028)
class UBFGEventTest_CheckpointValid final : public UBFGEventTest
{
public:
	uint8                                         Pad_28[0x10];                                      // 0x0028(0x0010)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"BFGEventTest_CheckpointValid">();
	}
	static class UBFGEventTest_CheckpointValid* GetDefaultObj()
	{
		return GetDefaultObjImpl<UBFGEventTest_CheckpointValid>();
	}
};
static_assert(alignof(UBFGEventTest_CheckpointValid) == 0x000008, "Wrong alignment on UBFGEventTest_CheckpointValid");
static_assert(sizeof(UBFGEventTest_CheckpointValid) == 0x000038, "Wrong size on UBFGEventTest_CheckpointValid");

// Class BFGCore.BFGEventTest_MonetaryValue
// 0x0008 (0x0030 - 0x0028)
class UBFGEventTest_MonetaryValue final : public UBFGEventTest
{
public:
	uint8                                         Pad_28[0x8];                                       // 0x0028(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"BFGEventTest_MonetaryValue">();
	}
	static class UBFGEventTest_MonetaryValue* GetDefaultObj()
	{
		return GetDefaultObjImpl<UBFGEventTest_MonetaryValue>();
	}
};
static_assert(alignof(UBFGEventTest_MonetaryValue) == 0x000008, "Wrong alignment on UBFGEventTest_MonetaryValue");
static_assert(sizeof(UBFGEventTest_MonetaryValue) == 0x000030, "Wrong size on UBFGEventTest_MonetaryValue");

// Class BFGCore.BFGNetworkPathAgent_AIStateWaitPassengers
// 0x0018 (0x0070 - 0x0058)
class UBFGNetworkPathAgent_AIStateWaitPassengers final : public UBFGNetworkPathAgent_AIStateBase
{
public:
	TArray<class UBFGNetworkPathAgent_Human*>     M_aPassengers;                                     // 0x0058(0x0010)(ZeroConstructor, Transient, Protected, NativeAccessSpecifierProtected)
	EBFGAIVehicleWaitPassengersPhase              M_ePhase;                                          // 0x0068(0x0001)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_69[0x7];                                       // 0x0069(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"BFGNetworkPathAgent_AIStateWaitPassengers">();
	}
	static class UBFGNetworkPathAgent_AIStateWaitPassengers* GetDefaultObj()
	{
		return GetDefaultObjImpl<UBFGNetworkPathAgent_AIStateWaitPassengers>();
	}
};
static_assert(alignof(UBFGNetworkPathAgent_AIStateWaitPassengers) == 0x000008, "Wrong alignment on UBFGNetworkPathAgent_AIStateWaitPassengers");
static_assert(sizeof(UBFGNetworkPathAgent_AIStateWaitPassengers) == 0x000070, "Wrong size on UBFGNetworkPathAgent_AIStateWaitPassengers");
static_assert(offsetof(UBFGNetworkPathAgent_AIStateWaitPassengers, M_aPassengers) == 0x000058, "Member 'UBFGNetworkPathAgent_AIStateWaitPassengers::M_aPassengers' has a wrong offset!");
static_assert(offsetof(UBFGNetworkPathAgent_AIStateWaitPassengers, M_ePhase) == 0x000068, "Member 'UBFGNetworkPathAgent_AIStateWaitPassengers::M_ePhase' has a wrong offset!");

// Class BFGCore.BFGEventTest_ResourceValue
// 0x0010 (0x0038 - 0x0028)
class UBFGEventTest_ResourceValue final : public UBFGEventTest
{
public:
	uint8                                         Pad_28[0x8];                                       // 0x0028(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	class UBFGQuest_ElementCollectResource*       M_pCollectResourceElement;                         // 0x0030(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"BFGEventTest_ResourceValue">();
	}
	static class UBFGEventTest_ResourceValue* GetDefaultObj()
	{
		return GetDefaultObjImpl<UBFGEventTest_ResourceValue>();
	}
};
static_assert(alignof(UBFGEventTest_ResourceValue) == 0x000008, "Wrong alignment on UBFGEventTest_ResourceValue");
static_assert(sizeof(UBFGEventTest_ResourceValue) == 0x000038, "Wrong size on UBFGEventTest_ResourceValue");
static_assert(offsetof(UBFGEventTest_ResourceValue, M_pCollectResourceElement) == 0x000030, "Member 'UBFGEventTest_ResourceValue::M_pCollectResourceElement' has a wrong offset!");

// Class BFGCore.BFGInputAxis_PawnMoveForward
// 0x0000 (0x0028 - 0x0028)
class UBFGInputAxis_PawnMoveForward final : public UBFGInputAxis
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"BFGInputAxis_PawnMoveForward">();
	}
	static class UBFGInputAxis_PawnMoveForward* GetDefaultObj()
	{
		return GetDefaultObjImpl<UBFGInputAxis_PawnMoveForward>();
	}
};
static_assert(alignof(UBFGInputAxis_PawnMoveForward) == 0x000008, "Wrong alignment on UBFGInputAxis_PawnMoveForward");
static_assert(sizeof(UBFGInputAxis_PawnMoveForward) == 0x000028, "Wrong size on UBFGInputAxis_PawnMoveForward");

// Class BFGCore.BFGEventTest_SpawnManagerCanActivate
// 0x0010 (0x0038 - 0x0028)
class UBFGEventTest_SpawnManagerCanActivate final : public UBFGEventTest
{
public:
	uint8                                         Pad_28[0x10];                                      // 0x0028(0x0010)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"BFGEventTest_SpawnManagerCanActivate">();
	}
	static class UBFGEventTest_SpawnManagerCanActivate* GetDefaultObj()
	{
		return GetDefaultObjImpl<UBFGEventTest_SpawnManagerCanActivate>();
	}
};
static_assert(alignof(UBFGEventTest_SpawnManagerCanActivate) == 0x000008, "Wrong alignment on UBFGEventTest_SpawnManagerCanActivate");
static_assert(sizeof(UBFGEventTest_SpawnManagerCanActivate) == 0x000038, "Wrong size on UBFGEventTest_SpawnManagerCanActivate");

// Class BFGCore.BFGGameFlowState_PausedTutorial
// 0x0008 (0x0110 - 0x0108)
class UBFGGameFlowState_PausedTutorial final : public UBFGGameFlowState_GenericDialog_Customizable
{
public:
	class UBFGDataAsset_PausedTutorial*           M_pTutorialAsset;                                  // 0x0108(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"BFGGameFlowState_PausedTutorial">();
	}
	static class UBFGGameFlowState_PausedTutorial* GetDefaultObj()
	{
		return GetDefaultObjImpl<UBFGGameFlowState_PausedTutorial>();
	}
};
static_assert(alignof(UBFGGameFlowState_PausedTutorial) == 0x000008, "Wrong alignment on UBFGGameFlowState_PausedTutorial");
static_assert(sizeof(UBFGGameFlowState_PausedTutorial) == 0x000110, "Wrong size on UBFGGameFlowState_PausedTutorial");
static_assert(offsetof(UBFGGameFlowState_PausedTutorial, M_pTutorialAsset) == 0x000108, "Member 'UBFGGameFlowState_PausedTutorial::M_pTutorialAsset' has a wrong offset!");

// Class BFGCore.BFGEventTest_VariableValue
// 0x0028 (0x0050 - 0x0028)
class UBFGEventTest_VariableValue final : public UBFGEventTest
{
public:
	class UBFGVariable*                           M_pVariable;                                       // 0x0028(0x0008)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_30[0x20];                                      // 0x0030(0x0020)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"BFGEventTest_VariableValue">();
	}
	static class UBFGEventTest_VariableValue* GetDefaultObj()
	{
		return GetDefaultObjImpl<UBFGEventTest_VariableValue>();
	}
};
static_assert(alignof(UBFGEventTest_VariableValue) == 0x000008, "Wrong alignment on UBFGEventTest_VariableValue");
static_assert(sizeof(UBFGEventTest_VariableValue) == 0x000050, "Wrong size on UBFGEventTest_VariableValue");
static_assert(offsetof(UBFGEventTest_VariableValue, M_pVariable) == 0x000028, "Member 'UBFGEventTest_VariableValue::M_pVariable' has a wrong offset!");

// Class BFGCore.BFGEventTrigger_AlertLevelReached
// 0x0008 (0x0048 - 0x0040)
class UBFGEventTrigger_AlertLevelReached final : public UBFGEventTrigger
{
public:
	uint8                                         Pad_40[0x8];                                       // 0x0040(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void OnAlertLevelChanged(EBFGAlertSystemState _newState);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"BFGEventTrigger_AlertLevelReached">();
	}
	static class UBFGEventTrigger_AlertLevelReached* GetDefaultObj()
	{
		return GetDefaultObjImpl<UBFGEventTrigger_AlertLevelReached>();
	}
};
static_assert(alignof(UBFGEventTrigger_AlertLevelReached) == 0x000008, "Wrong alignment on UBFGEventTrigger_AlertLevelReached");
static_assert(sizeof(UBFGEventTrigger_AlertLevelReached) == 0x000048, "Wrong size on UBFGEventTrigger_AlertLevelReached");

// Class BFGCore.BFGInputAction_DebugMenu
// 0x0000 (0x0030 - 0x0030)
class UBFGInputAction_DebugMenu final : public UBFGInputAction
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"BFGInputAction_DebugMenu">();
	}
	static class UBFGInputAction_DebugMenu* GetDefaultObj()
	{
		return GetDefaultObjImpl<UBFGInputAction_DebugMenu>();
	}
};
static_assert(alignof(UBFGInputAction_DebugMenu) == 0x000008, "Wrong alignment on UBFGInputAction_DebugMenu");
static_assert(sizeof(UBFGInputAction_DebugMenu) == 0x000030, "Wrong size on UBFGInputAction_DebugMenu");

// Class BFGCore.BFGWidgetSceneObjectHighlighter_MissileMarker
// 0x0000 (0x02A0 - 0x02A0)
class UBFGWidgetSceneObjectHighlighter_MissileMarker : public UBFGWidgetSceneObjectHighlighter
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"BFGWidgetSceneObjectHighlighter_MissileMarker">();
	}
	static class UBFGWidgetSceneObjectHighlighter_MissileMarker* GetDefaultObj()
	{
		return GetDefaultObjImpl<UBFGWidgetSceneObjectHighlighter_MissileMarker>();
	}
};
static_assert(alignof(UBFGWidgetSceneObjectHighlighter_MissileMarker) == 0x000008, "Wrong alignment on UBFGWidgetSceneObjectHighlighter_MissileMarker");
static_assert(sizeof(UBFGWidgetSceneObjectHighlighter_MissileMarker) == 0x0002A0, "Wrong size on UBFGWidgetSceneObjectHighlighter_MissileMarker");

// Class BFGCore.BFGGameFlowState_BumperVideos
// 0x0048 (0x00B0 - 0x0068)
class UBFGGameFlowState_BumperVideos final : public UBFGGameFlowState
{
public:
	TSoftClassPtr<class UClass>                   M_pVideoWidgetClass;                               // 0x0068(0x0028)(Edit, BlueprintVisible, BlueprintReadOnly, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UMediaPlayer*                           M_pMediaPlayer;                                    // 0x0090(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UMediaPlaylist*                         M_pMediaPlaylist;                                  // 0x0098(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UBFGWidget_BumperVideo*                 M_pVideoWidget;                                    // 0x00A0(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_A8[0x8];                                       // 0x00A8(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void OnApplicationPostInputKeyDownEvent(const struct FKeyEvent& _keyEvent);
	void OnMediaEnded();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"BFGGameFlowState_BumperVideos">();
	}
	static class UBFGGameFlowState_BumperVideos* GetDefaultObj()
	{
		return GetDefaultObjImpl<UBFGGameFlowState_BumperVideos>();
	}
};
static_assert(alignof(UBFGGameFlowState_BumperVideos) == 0x000008, "Wrong alignment on UBFGGameFlowState_BumperVideos");
static_assert(sizeof(UBFGGameFlowState_BumperVideos) == 0x0000B0, "Wrong size on UBFGGameFlowState_BumperVideos");
static_assert(offsetof(UBFGGameFlowState_BumperVideos, M_pVideoWidgetClass) == 0x000068, "Member 'UBFGGameFlowState_BumperVideos::M_pVideoWidgetClass' has a wrong offset!");
static_assert(offsetof(UBFGGameFlowState_BumperVideos, M_pMediaPlayer) == 0x000090, "Member 'UBFGGameFlowState_BumperVideos::M_pMediaPlayer' has a wrong offset!");
static_assert(offsetof(UBFGGameFlowState_BumperVideos, M_pMediaPlaylist) == 0x000098, "Member 'UBFGGameFlowState_BumperVideos::M_pMediaPlaylist' has a wrong offset!");
static_assert(offsetof(UBFGGameFlowState_BumperVideos, M_pVideoWidget) == 0x0000A0, "Member 'UBFGGameFlowState_BumperVideos::M_pVideoWidget' has a wrong offset!");

// Class BFGCore.BFGEventTrigger_CortexScanVOPlayed
// 0x0018 (0x0058 - 0x0040)
class UBFGEventTrigger_CortexScanVOPlayed final : public UBFGEventTrigger
{
public:
	TArray<class UBFGCortexScanResponseSet*>      M_apResponseSets;                                  // 0x0040(0x0010)(ZeroConstructor, Transient, Protected, NativeAccessSpecifierProtected)
	class UBFGQuest_CortexScanObjectiveTracker*   M_pTracker;                                        // 0x0050(0x0008)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)

public:
	void OnPlayedVO(class AActor* _pActor, const struct FBFGCortexScanResponse& _response, class UBFGCortexScanResponseSet* _pResponseSet);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"BFGEventTrigger_CortexScanVOPlayed">();
	}
	static class UBFGEventTrigger_CortexScanVOPlayed* GetDefaultObj()
	{
		return GetDefaultObjImpl<UBFGEventTrigger_CortexScanVOPlayed>();
	}
};
static_assert(alignof(UBFGEventTrigger_CortexScanVOPlayed) == 0x000008, "Wrong alignment on UBFGEventTrigger_CortexScanVOPlayed");
static_assert(sizeof(UBFGEventTrigger_CortexScanVOPlayed) == 0x000058, "Wrong size on UBFGEventTrigger_CortexScanVOPlayed");
static_assert(offsetof(UBFGEventTrigger_CortexScanVOPlayed, M_apResponseSets) == 0x000040, "Member 'UBFGEventTrigger_CortexScanVOPlayed::M_apResponseSets' has a wrong offset!");
static_assert(offsetof(UBFGEventTrigger_CortexScanVOPlayed, M_pTracker) == 0x000050, "Member 'UBFGEventTrigger_CortexScanVOPlayed::M_pTracker' has a wrong offset!");

// Class BFGCore.BFGEventTrigger_EnterWater
// 0x0090 (0x00D0 - 0x0040)
class UBFGEventTrigger_EnterWater final : public UBFGEventTrigger
{
public:
	struct FBFGActorBinding                       M_actorBinding;                                    // 0x0040(0x0090)(Transient, Protected, NativeAccessSpecifierProtected)

public:
	void OnFinishedTask(class AActor* _pActor);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"BFGEventTrigger_EnterWater">();
	}
	static class UBFGEventTrigger_EnterWater* GetDefaultObj()
	{
		return GetDefaultObjImpl<UBFGEventTrigger_EnterWater>();
	}
};
static_assert(alignof(UBFGEventTrigger_EnterWater) == 0x000008, "Wrong alignment on UBFGEventTrigger_EnterWater");
static_assert(sizeof(UBFGEventTrigger_EnterWater) == 0x0000D0, "Wrong size on UBFGEventTrigger_EnterWater");
static_assert(offsetof(UBFGEventTrigger_EnterWater, M_actorBinding) == 0x000040, "Member 'UBFGEventTrigger_EnterWater::M_actorBinding' has a wrong offset!");

// Class BFGCore.BFGFoliageInstancedStaticMeshComponent
// 0x0000 (0x08B0 - 0x08B0)
class UBFGFoliageInstancedStaticMeshComponent : public UFoliageInstancedStaticMeshComponent
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"BFGFoliageInstancedStaticMeshComponent">();
	}
	static class UBFGFoliageInstancedStaticMeshComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UBFGFoliageInstancedStaticMeshComponent>();
	}
};
static_assert(alignof(UBFGFoliageInstancedStaticMeshComponent) == 0x000008, "Wrong alignment on UBFGFoliageInstancedStaticMeshComponent");
static_assert(sizeof(UBFGFoliageInstancedStaticMeshComponent) == 0x0008B0, "Wrong size on UBFGFoliageInstancedStaticMeshComponent");

// Class BFGCore.BFGFoliageBurnable
// 0x0000 (0x08B0 - 0x08B0)
class UBFGFoliageBurnable : public UBFGFoliageInstancedStaticMeshComponent
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"BFGFoliageBurnable">();
	}
	static class UBFGFoliageBurnable* GetDefaultObj()
	{
		return GetDefaultObjImpl<UBFGFoliageBurnable>();
	}
};
static_assert(alignof(UBFGFoliageBurnable) == 0x000008, "Wrong alignment on UBFGFoliageBurnable");
static_assert(sizeof(UBFGFoliageBurnable) == 0x0008B0, "Wrong size on UBFGFoliageBurnable");

// Class BFGCore.BFGEventTrigger_FellOutOfWorld
// 0x0098 (0x00D8 - 0x0040)
class UBFGEventTrigger_FellOutOfWorld final : public UBFGEventTrigger
{
public:
	uint8                                         Pad_40[0x8];                                       // 0x0040(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	struct FBFGActorBinding                       M_actorBinding;                                    // 0x0048(0x0090)(Transient, Protected, NativeAccessSpecifierProtected)

public:
	void OnFellOutOfWorld(class AActor* _pActor);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"BFGEventTrigger_FellOutOfWorld">();
	}
	static class UBFGEventTrigger_FellOutOfWorld* GetDefaultObj()
	{
		return GetDefaultObjImpl<UBFGEventTrigger_FellOutOfWorld>();
	}
};
static_assert(alignof(UBFGEventTrigger_FellOutOfWorld) == 0x000008, "Wrong alignment on UBFGEventTrigger_FellOutOfWorld");
static_assert(sizeof(UBFGEventTrigger_FellOutOfWorld) == 0x0000D8, "Wrong size on UBFGEventTrigger_FellOutOfWorld");
static_assert(offsetof(UBFGEventTrigger_FellOutOfWorld, M_actorBinding) == 0x000048, "Member 'UBFGEventTrigger_FellOutOfWorld::M_actorBinding' has a wrong offset!");

// Class BFGCore.BFGEventTrigger_InteractWith
// 0x0130 (0x0170 - 0x0040)
class UBFGEventTrigger_InteractWith final : public UBFGEventTrigger
{
public:
	struct FBFGActorBinding                       M_actorBinding;                                    // 0x0040(0x0090)(Transient, Protected, NativeAccessSpecifierProtected)
	uint8                                         Pad_D0[0x8];                                       // 0x00D0(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	struct FBFGActorBinding                       M_actorBindingUser;                                // 0x00D8(0x0090)(Transient, Protected, NativeAccessSpecifierProtected)
	uint8                                         Pad_168[0x8];                                      // 0x0168(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void OnInteract(class AActor* _pUser, class AActor* _pInteractWith, class UObject* _pFocusedOn);
	void OnTickPlayerControllingUFO(class AActor* _pPlayerCharacter, class AActor* _pUFO);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"BFGEventTrigger_InteractWith">();
	}
	static class UBFGEventTrigger_InteractWith* GetDefaultObj()
	{
		return GetDefaultObjImpl<UBFGEventTrigger_InteractWith>();
	}
};
static_assert(alignof(UBFGEventTrigger_InteractWith) == 0x000008, "Wrong alignment on UBFGEventTrigger_InteractWith");
static_assert(sizeof(UBFGEventTrigger_InteractWith) == 0x000170, "Wrong size on UBFGEventTrigger_InteractWith");
static_assert(offsetof(UBFGEventTrigger_InteractWith, M_actorBinding) == 0x000040, "Member 'UBFGEventTrigger_InteractWith::M_actorBinding' has a wrong offset!");
static_assert(offsetof(UBFGEventTrigger_InteractWith, M_actorBindingUser) == 0x0000D8, "Member 'UBFGEventTrigger_InteractWith::M_actorBindingUser' has a wrong offset!");

// Class BFGCore.BFGInputAction_EquipmentSelectSonicBoom
// 0x0000 (0x0038 - 0x0038)
class UBFGInputAction_EquipmentSelectSonicBoom final : public UBFGInputAction_EquipmentSelect
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"BFGInputAction_EquipmentSelectSonicBoom">();
	}
	static class UBFGInputAction_EquipmentSelectSonicBoom* GetDefaultObj()
	{
		return GetDefaultObjImpl<UBFGInputAction_EquipmentSelectSonicBoom>();
	}
};
static_assert(alignof(UBFGInputAction_EquipmentSelectSonicBoom) == 0x000008, "Wrong alignment on UBFGInputAction_EquipmentSelectSonicBoom");
static_assert(sizeof(UBFGInputAction_EquipmentSelectSonicBoom) == 0x000038, "Wrong size on UBFGInputAction_EquipmentSelectSonicBoom");

// Class BFGCore.BFGEventTrigger_LocateLayer
// 0x0020 (0x0060 - 0x0040)
class UBFGEventTrigger_LocateLayer final : public UBFGEventTrigger
{
public:
	uint8                                         Pad_40[0x8];                                       // 0x0040(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	class UBFGQuest_ElementLocateHint*            M_pLocateElement;                                  // 0x0048(0x0008)(ExportObject, ZeroConstructor, Transient, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_50[0x10];                                      // 0x0050(0x0010)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void OnLocateEvent(EBFGLocateLayer_Operation _operation, class UBFGQuest_ElementLocateHint* _pLocateElement, const class FString& _strSharedLayerIdentifier);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"BFGEventTrigger_LocateLayer">();
	}
	static class UBFGEventTrigger_LocateLayer* GetDefaultObj()
	{
		return GetDefaultObjImpl<UBFGEventTrigger_LocateLayer>();
	}
};
static_assert(alignof(UBFGEventTrigger_LocateLayer) == 0x000008, "Wrong alignment on UBFGEventTrigger_LocateLayer");
static_assert(sizeof(UBFGEventTrigger_LocateLayer) == 0x000060, "Wrong size on UBFGEventTrigger_LocateLayer");
static_assert(offsetof(UBFGEventTrigger_LocateLayer, M_pLocateElement) == 0x000048, "Member 'UBFGEventTrigger_LocateLayer::M_pLocateElement' has a wrong offset!");

// Class BFGCore.BFGEventTrigger_MentalAbility
// 0x00E8 (0x0128 - 0x0040)
class UBFGEventTrigger_MentalAbility final : public UBFGEventTrigger
{
public:
	struct FBFGActorBinding                       M_actorBinding;                                    // 0x0040(0x0090)(Transient, Protected, NativeAccessSpecifierProtected)
	struct FGameplayTagQuery                      M_abilityTagQuery;                                 // 0x00D0(0x0048)(Transient, Protected, NativeAccessSpecifierProtected)
	EMentalAbility_EventState                     M_objectiveState;                                  // 0x0118(0x0001)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_119[0xF];                                      // 0x0119(0x000F)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void OnUsedAbility(class AActor* _pUser, class UBFGMentalAbilityBase* _pAbility, class AActor* _pTarget, EMentalAbility_EventState _eState);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"BFGEventTrigger_MentalAbility">();
	}
	static class UBFGEventTrigger_MentalAbility* GetDefaultObj()
	{
		return GetDefaultObjImpl<UBFGEventTrigger_MentalAbility>();
	}
};
static_assert(alignof(UBFGEventTrigger_MentalAbility) == 0x000008, "Wrong alignment on UBFGEventTrigger_MentalAbility");
static_assert(sizeof(UBFGEventTrigger_MentalAbility) == 0x000128, "Wrong size on UBFGEventTrigger_MentalAbility");
static_assert(offsetof(UBFGEventTrigger_MentalAbility, M_actorBinding) == 0x000040, "Member 'UBFGEventTrigger_MentalAbility::M_actorBinding' has a wrong offset!");
static_assert(offsetof(UBFGEventTrigger_MentalAbility, M_abilityTagQuery) == 0x0000D0, "Member 'UBFGEventTrigger_MentalAbility::M_abilityTagQuery' has a wrong offset!");
static_assert(offsetof(UBFGEventTrigger_MentalAbility, M_objectiveState) == 0x000118, "Member 'UBFGEventTrigger_MentalAbility::M_objectiveState' has a wrong offset!");

// Class BFGCore.BFGEventTrigger_OrbitalTransporter
// 0x0128 (0x0168 - 0x0040)
class UBFGEventTrigger_OrbitalTransporter final : public UBFGEventTrigger
{
public:
	struct FBFGActorBinding                       M_transporterBinding;                              // 0x0040(0x0090)(Protected, NativeAccessSpecifierProtected)
	struct FBFGActorBinding                       M_targetBinding;                                   // 0x00D0(0x0090)(Protected, NativeAccessSpecifierProtected)
	uint8                                         Pad_160[0x8];                                      // 0x0160(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void OnTransportAttempt(class ABFGMissionOrbitalTransporter* _pTransporter, class AActor* _pTarget, bool _bSuccess);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"BFGEventTrigger_OrbitalTransporter">();
	}
	static class UBFGEventTrigger_OrbitalTransporter* GetDefaultObj()
	{
		return GetDefaultObjImpl<UBFGEventTrigger_OrbitalTransporter>();
	}
};
static_assert(alignof(UBFGEventTrigger_OrbitalTransporter) == 0x000008, "Wrong alignment on UBFGEventTrigger_OrbitalTransporter");
static_assert(sizeof(UBFGEventTrigger_OrbitalTransporter) == 0x000168, "Wrong size on UBFGEventTrigger_OrbitalTransporter");
static_assert(offsetof(UBFGEventTrigger_OrbitalTransporter, M_transporterBinding) == 0x000040, "Member 'UBFGEventTrigger_OrbitalTransporter::M_transporterBinding' has a wrong offset!");
static_assert(offsetof(UBFGEventTrigger_OrbitalTransporter, M_targetBinding) == 0x0000D0, "Member 'UBFGEventTrigger_OrbitalTransporter::M_targetBinding' has a wrong offset!");

// Class BFGCore.BFGEventTrigger_PickupItem
// 0x0090 (0x00D0 - 0x0040)
class UBFGEventTrigger_PickupItem final : public UBFGEventTrigger
{
public:
	struct FBFGActorBinding                       M_actorBinding;                                    // 0x0040(0x0090)(Transient, Protected, NativeAccessSpecifierProtected)

public:
	void OnPickupItem(class AActor* _pOwner, class AActor* _pItem);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"BFGEventTrigger_PickupItem">();
	}
	static class UBFGEventTrigger_PickupItem* GetDefaultObj()
	{
		return GetDefaultObjImpl<UBFGEventTrigger_PickupItem>();
	}
};
static_assert(alignof(UBFGEventTrigger_PickupItem) == 0x000008, "Wrong alignment on UBFGEventTrigger_PickupItem");
static_assert(sizeof(UBFGEventTrigger_PickupItem) == 0x0000D0, "Wrong size on UBFGEventTrigger_PickupItem");
static_assert(offsetof(UBFGEventTrigger_PickupItem, M_actorBinding) == 0x000040, "Member 'UBFGEventTrigger_PickupItem::M_actorBinding' has a wrong offset!");

// Class BFGCore.BFGWidget_Mothership_MissionSelection
// 0x0008 (0x0430 - 0x0428)
class UBFGWidget_Mothership_MissionSelection final : public UBFGWidget_GenericDialog
{
public:
	class UBFGMissionWorldState*                  M_pWorldState;                                     // 0x0428(0x0008)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)

public:
	void SetWorldState(class UBFGMissionWorldState* _pWorldState);

	class UBFGMissionWorldState* GetWorldState() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"BFGWidget_Mothership_MissionSelection">();
	}
	static class UBFGWidget_Mothership_MissionSelection* GetDefaultObj()
	{
		return GetDefaultObjImpl<UBFGWidget_Mothership_MissionSelection>();
	}
};
static_assert(alignof(UBFGWidget_Mothership_MissionSelection) == 0x000008, "Wrong alignment on UBFGWidget_Mothership_MissionSelection");
static_assert(sizeof(UBFGWidget_Mothership_MissionSelection) == 0x000430, "Wrong size on UBFGWidget_Mothership_MissionSelection");
static_assert(offsetof(UBFGWidget_Mothership_MissionSelection, M_pWorldState) == 0x000428, "Member 'UBFGWidget_Mothership_MissionSelection::M_pWorldState' has a wrong offset!");

// Class BFGCore.BFGEventTrigger_ProximitySubgoalReached
// 0x0010 (0x0050 - 0x0040)
class UBFGEventTrigger_ProximitySubgoalReached final : public UBFGEventTrigger
{
public:
	uint8                                         Pad_40[0x10];                                      // 0x0040(0x0010)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void OnProximitySubgoalReached(const class UBFGQuest_ProximityMonitor* _pProximityMonitor, int32 _iLimit);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"BFGEventTrigger_ProximitySubgoalReached">();
	}
	static class UBFGEventTrigger_ProximitySubgoalReached* GetDefaultObj()
	{
		return GetDefaultObjImpl<UBFGEventTrigger_ProximitySubgoalReached>();
	}
};
static_assert(alignof(UBFGEventTrigger_ProximitySubgoalReached) == 0x000008, "Wrong alignment on UBFGEventTrigger_ProximitySubgoalReached");
static_assert(sizeof(UBFGEventTrigger_ProximitySubgoalReached) == 0x000050, "Wrong size on UBFGEventTrigger_ProximitySubgoalReached");

// Class BFGCore.BFGEventTrigger_ResourceValueCounted
// 0x0008 (0x0048 - 0x0040)
class UBFGEventTrigger_ResourceValueCounted final : public UBFGEventTrigger
{
public:
	class UBFGQuest_ElementCollectResource*       M_pElement;                                        // 0x0040(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)

public:
	void ValueChanged(class UBFGQuest_Element* _pElement, float _fValueAdded, float FValueTotal);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"BFGEventTrigger_ResourceValueCounted">();
	}
	static class UBFGEventTrigger_ResourceValueCounted* GetDefaultObj()
	{
		return GetDefaultObjImpl<UBFGEventTrigger_ResourceValueCounted>();
	}
};
static_assert(alignof(UBFGEventTrigger_ResourceValueCounted) == 0x000008, "Wrong alignment on UBFGEventTrigger_ResourceValueCounted");
static_assert(sizeof(UBFGEventTrigger_ResourceValueCounted) == 0x000048, "Wrong size on UBFGEventTrigger_ResourceValueCounted");
static_assert(offsetof(UBFGEventTrigger_ResourceValueCounted, M_pElement) == 0x000040, "Member 'UBFGEventTrigger_ResourceValueCounted::M_pElement' has a wrong offset!");

// Class BFGCore.BFGGameFlowState_ControllerDisconnected
// 0x0000 (0x0108 - 0x0108)
class UBFGGameFlowState_ControllerDisconnected final : public UBFGGameFlowState_GenericDialog_Customizable
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"BFGGameFlowState_ControllerDisconnected">();
	}
	static class UBFGGameFlowState_ControllerDisconnected* GetDefaultObj()
	{
		return GetDefaultObjImpl<UBFGGameFlowState_ControllerDisconnected>();
	}
};
static_assert(alignof(UBFGGameFlowState_ControllerDisconnected) == 0x000008, "Wrong alignment on UBFGGameFlowState_ControllerDisconnected");
static_assert(sizeof(UBFGGameFlowState_ControllerDisconnected) == 0x000108, "Wrong size on UBFGGameFlowState_ControllerDisconnected");

// Class BFGCore.BFGEventTrigger_SequenceFailed
// 0x0008 (0x0048 - 0x0040)
class UBFGEventTrigger_SequenceFailed final : public UBFGEventTrigger
{
public:
	class UBFGNarrativeSequence*                  M_pNarrativeSequence;                              // 0x0040(0x0008)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)

public:
	void OnNarrativeSequenceFailed(class UBFGNarrativeSequence* _pSequence);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"BFGEventTrigger_SequenceFailed">();
	}
	static class UBFGEventTrigger_SequenceFailed* GetDefaultObj()
	{
		return GetDefaultObjImpl<UBFGEventTrigger_SequenceFailed>();
	}
};
static_assert(alignof(UBFGEventTrigger_SequenceFailed) == 0x000008, "Wrong alignment on UBFGEventTrigger_SequenceFailed");
static_assert(sizeof(UBFGEventTrigger_SequenceFailed) == 0x000048, "Wrong size on UBFGEventTrigger_SequenceFailed");
static_assert(offsetof(UBFGEventTrigger_SequenceFailed, M_pNarrativeSequence) == 0x000040, "Member 'UBFGEventTrigger_SequenceFailed::M_pNarrativeSequence' has a wrong offset!");

// Class BFGCore.BFGEventTrigger_SpawnFinished
// 0x0010 (0x0050 - 0x0040)
class UBFGEventTrigger_SpawnFinished final : public UBFGEventTrigger
{
public:
	uint8                                         Pad_40[0x10];                                      // 0x0040(0x0010)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void OnSpawnFinished(class ABFGMissionSpawnManager* _pManager);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"BFGEventTrigger_SpawnFinished">();
	}
	static class UBFGEventTrigger_SpawnFinished* GetDefaultObj()
	{
		return GetDefaultObjImpl<UBFGEventTrigger_SpawnFinished>();
	}
};
static_assert(alignof(UBFGEventTrigger_SpawnFinished) == 0x000008, "Wrong alignment on UBFGEventTrigger_SpawnFinished");
static_assert(sizeof(UBFGEventTrigger_SpawnFinished) == 0x000050, "Wrong size on UBFGEventTrigger_SpawnFinished");

// Class BFGCore.BFGGameFlowState_RestartMissionForLoadGame
// 0x0078 (0x0180 - 0x0108)
class UBFGGameFlowState_RestartMissionForLoadGame final : public UBFGGameFlowState_GenericDialog_Customizable
{
public:
	class FText                                   M_strMsgToShow;                                    // 0x0108(0x0018)(Edit, BlueprintVisible, BlueprintReadOnly, DisableEditOnInstance, Protected, NativeAccessSpecifierProtected)
	class UBFGGameInstance*                       M_pGameInstance;                                   // 0x0120(0x0008)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UBFGGameFlowState_LoadGame*             M_pOwnerState;                                     // 0x0128(0x0008)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	struct FBFGSavedMapDescription                M_targetMap;                                       // 0x0130(0x0038)(Transient, Protected, NativeAccessSpecifierProtected)
	class UBFGQuest*                              M_pAbortedQuest;                                   // 0x0168(0x0008)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UBFGLoadingScreenInfo*                  M_pLoadingInfo;                                    // 0x0170(0x0008)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_178[0x8];                                      // 0x0178(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"BFGGameFlowState_RestartMissionForLoadGame">();
	}
	static class UBFGGameFlowState_RestartMissionForLoadGame* GetDefaultObj()
	{
		return GetDefaultObjImpl<UBFGGameFlowState_RestartMissionForLoadGame>();
	}
};
static_assert(alignof(UBFGGameFlowState_RestartMissionForLoadGame) == 0x000008, "Wrong alignment on UBFGGameFlowState_RestartMissionForLoadGame");
static_assert(sizeof(UBFGGameFlowState_RestartMissionForLoadGame) == 0x000180, "Wrong size on UBFGGameFlowState_RestartMissionForLoadGame");
static_assert(offsetof(UBFGGameFlowState_RestartMissionForLoadGame, M_strMsgToShow) == 0x000108, "Member 'UBFGGameFlowState_RestartMissionForLoadGame::M_strMsgToShow' has a wrong offset!");
static_assert(offsetof(UBFGGameFlowState_RestartMissionForLoadGame, M_pGameInstance) == 0x000120, "Member 'UBFGGameFlowState_RestartMissionForLoadGame::M_pGameInstance' has a wrong offset!");
static_assert(offsetof(UBFGGameFlowState_RestartMissionForLoadGame, M_pOwnerState) == 0x000128, "Member 'UBFGGameFlowState_RestartMissionForLoadGame::M_pOwnerState' has a wrong offset!");
static_assert(offsetof(UBFGGameFlowState_RestartMissionForLoadGame, M_targetMap) == 0x000130, "Member 'UBFGGameFlowState_RestartMissionForLoadGame::M_targetMap' has a wrong offset!");
static_assert(offsetof(UBFGGameFlowState_RestartMissionForLoadGame, M_pAbortedQuest) == 0x000168, "Member 'UBFGGameFlowState_RestartMissionForLoadGame::M_pAbortedQuest' has a wrong offset!");
static_assert(offsetof(UBFGGameFlowState_RestartMissionForLoadGame, M_pLoadingInfo) == 0x000170, "Member 'UBFGGameFlowState_RestartMissionForLoadGame::M_pLoadingInfo' has a wrong offset!");

// Class BFGCore.BFGEventTrigger_SpawnManagerLoaded
// 0x0010 (0x0050 - 0x0040)
class UBFGEventTrigger_SpawnManagerLoaded final : public UBFGEventTrigger
{
public:
	uint8                                         Pad_40[0x10];                                      // 0x0040(0x0010)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void OnLoaded(class ABFGMissionSpawnManager* _pSpawnManager);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"BFGEventTrigger_SpawnManagerLoaded">();
	}
	static class UBFGEventTrigger_SpawnManagerLoaded* GetDefaultObj()
	{
		return GetDefaultObjImpl<UBFGEventTrigger_SpawnManagerLoaded>();
	}
};
static_assert(alignof(UBFGEventTrigger_SpawnManagerLoaded) == 0x000008, "Wrong alignment on UBFGEventTrigger_SpawnManagerLoaded");
static_assert(sizeof(UBFGEventTrigger_SpawnManagerLoaded) == 0x000050, "Wrong size on UBFGEventTrigger_SpawnManagerLoaded");

// Class BFGCore.BFGGameState
// 0x08D8 (0x0CF0 - 0x0418)
class ABFGGameState : public AGameStateBase
{
public:
	struct FTimespan                              M_Timespan;                                        // 0x0418(0x0008)(Edit, BlueprintVisible, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	UMulticastDelegateProperty_                   M_OnCutsceneStarted;                               // 0x0420(0x0018)(ZeroConstructor, InstancedReference, BlueprintAssignable, BlueprintCallable, NativeAccessSpecifierPublic)
	uint8                                         Pad_438[0x20];                                     // 0x0438(0x0020)(Fixing Size After Last Property [ Dumper-7 ])
	UMulticastDelegateProperty_                   M_onPlayerDNAChanged;                              // 0x0458(0x0018)(ZeroConstructor, InstancedReference, BlueprintAssignable, BlueprintCallable, NativeAccessSpecifierPublic)
	UMulticastDelegateProperty_                   M_onPlayerStateMonetaryValueChanged;               // 0x0470(0x0018)(ZeroConstructor, InstancedReference, BlueprintAssignable, BlueprintCallable, NativeAccessSpecifierPublic)
	uint8                                         Pad_488[0x20];                                     // 0x0488(0x0020)(Fixing Size After Last Property [ Dumper-7 ])
	UMulticastDelegateProperty_                   M_onHitActor;                                      // 0x04A8(0x0018)(ZeroConstructor, InstancedReference, BlueprintAssignable, BlueprintCallable, NativeAccessSpecifierPublic)
	UMulticastDelegateProperty_                   M_onPickupItem;                                    // 0x04C0(0x0018)(ZeroConstructor, InstancedReference, BlueprintAssignable, BlueprintCallable, NativeAccessSpecifierPublic)
	uint8                                         Pad_4D8[0x20];                                     // 0x04D8(0x0020)(Fixing Size After Last Property [ Dumper-7 ])
	UMulticastDelegateProperty_                   M_onFellOutOfWorld;                                // 0x04F8(0x0018)(ZeroConstructor, InstancedReference, BlueprintAssignable, BlueprintCallable, NativeAccessSpecifierPublic)
	uint8                                         Pad_510[0x20];                                     // 0x0510(0x0020)(Fixing Size After Last Property [ Dumper-7 ])
	UMulticastDelegateProperty_                   M_onHealthChanged;                                 // 0x0530(0x0018)(ZeroConstructor, InstancedReference, BlueprintAssignable, BlueprintCallable, NativeAccessSpecifierPublic)
	uint8                                         Pad_548[0x20];                                     // 0x0548(0x0020)(Fixing Size After Last Property [ Dumper-7 ])
	UMulticastDelegateProperty_                   M_onKilledActor;                                   // 0x0568(0x0018)(ZeroConstructor, InstancedReference, BlueprintAssignable, BlueprintCallable, NativeAccessSpecifierPublic)
	uint8                                         Pad_580[0x20];                                     // 0x0580(0x0020)(Fixing Size After Last Property [ Dumper-7 ])
	UMulticastDelegateProperty_                   M_onDestroyedStaticObject;                         // 0x05A0(0x0018)(ZeroConstructor, InstancedReference, BlueprintAssignable, BlueprintCallable, NativeAccessSpecifierPublic)
	uint8                                         Pad_5B8[0x20];                                     // 0x05B8(0x0020)(Fixing Size After Last Property [ Dumper-7 ])
	UMulticastDelegateProperty_                   M_onLevelMissionStarted;                           // 0x05D8(0x0018)(ZeroConstructor, InstancedReference, BlueprintAssignable, BlueprintCallable, NativeAccessSpecifierPublic)
	UMulticastDelegateProperty_                   M_onOverlapActor;                                  // 0x05F0(0x0018)(ZeroConstructor, InstancedReference, BlueprintAssignable, BlueprintCallable, NativeAccessSpecifierPublic)
	uint8                                         Pad_608[0x20];                                     // 0x0608(0x0020)(Fixing Size After Last Property [ Dumper-7 ])
	UMulticastDelegateProperty_                   M_onOverlapEndActor;                               // 0x0628(0x0018)(ZeroConstructor, InstancedReference, BlueprintAssignable, BlueprintCallable, NativeAccessSpecifierPublic)
	uint8                                         Pad_640[0x20];                                     // 0x0640(0x0020)(Fixing Size After Last Property [ Dumper-7 ])
	UMulticastDelegateProperty_                   M_onMentalAbilityActivity;                         // 0x0660(0x0018)(ZeroConstructor, InstancedReference, BlueprintAssignable, BlueprintCallable, NativeAccessSpecifierPublic)
	uint8                                         Pad_678[0x20];                                     // 0x0678(0x0020)(Fixing Size After Last Property [ Dumper-7 ])
	UMulticastDelegateProperty_                   M_onInteract;                                      // 0x0698(0x0018)(ZeroConstructor, InstancedReference, BlueprintAssignable, BlueprintCallable, NativeAccessSpecifierPublic)
	uint8                                         Pad_6B0[0x20];                                     // 0x06B0(0x0020)(Fixing Size After Last Property [ Dumper-7 ])
	UMulticastDelegateProperty_                   M_onTickPlayerControllingUFO;                      // 0x06D0(0x0018)(ZeroConstructor, InstancedReference, BlueprintAssignable, BlueprintCallable, NativeAccessSpecifierPublic)
	uint8                                         Pad_6E8[0x20];                                     // 0x06E8(0x0020)(Fixing Size After Last Property [ Dumper-7 ])
	UMulticastDelegateProperty_                   M_onAITaskComplete;                                // 0x0708(0x0018)(ZeroConstructor, InstancedReference, BlueprintAssignable, BlueprintCallable, NativeAccessSpecifierPublic)
	UMulticastDelegateProperty_                   M_onAITaskStarted;                                 // 0x0720(0x0018)(ZeroConstructor, InstancedReference, BlueprintAssignable, BlueprintCallable, NativeAccessSpecifierPublic)
	UMulticastDelegateProperty_                   M_onSpawnManagerLoaded;                            // 0x0738(0x0018)(ZeroConstructor, InstancedReference, BlueprintAssignable, BlueprintCallable, NativeAccessSpecifierPublic)
	uint8                                         Pad_750[0x20];                                     // 0x0750(0x0020)(Fixing Size After Last Property [ Dumper-7 ])
	UMulticastDelegateProperty_                   M_onSpawnManagerEveryoneDead;                      // 0x0770(0x0018)(ZeroConstructor, InstancedReference, BlueprintAssignable, BlueprintCallable, NativeAccessSpecifierPublic)
	uint8                                         Pad_788[0x20];                                     // 0x0788(0x0020)(Fixing Size After Last Property [ Dumper-7 ])
	UMulticastDelegateProperty_                   M_onWaveStarted;                                   // 0x07A8(0x0018)(ZeroConstructor, InstancedReference, BlueprintAssignable, BlueprintCallable, NativeAccessSpecifierPublic)
	uint8                                         Pad_7C0[0x20];                                     // 0x07C0(0x0020)(Fixing Size After Last Property [ Dumper-7 ])
	UMulticastDelegateProperty_                   M_onInitialWaveAmountReached;                      // 0x07E0(0x0018)(ZeroConstructor, InstancedReference, BlueprintAssignable, BlueprintCallable, NativeAccessSpecifierPublic)
	uint8                                         Pad_7F8[0x20];                                     // 0x07F8(0x0020)(Fixing Size After Last Property [ Dumper-7 ])
	UMulticastDelegateProperty_                   M_onNarrativeSequenceStart;                        // 0x0818(0x0018)(ZeroConstructor, InstancedReference, BlueprintAssignable, BlueprintCallable, NativeAccessSpecifierPublic)
	UMulticastDelegateProperty_                   M_onNarrativeSequenceEnd;                          // 0x0830(0x0018)(ZeroConstructor, InstancedReference, BlueprintAssignable, BlueprintCallable, NativeAccessSpecifierPublic)
	uint8                                         Pad_848[0x20];                                     // 0x0848(0x0020)(Fixing Size After Last Property [ Dumper-7 ])
	UMulticastDelegateProperty_                   M_onNarrativeSequenceFailed;                       // 0x0868(0x0018)(ZeroConstructor, InstancedReference, BlueprintAssignable, BlueprintCallable, NativeAccessSpecifierPublic)
	uint8                                         Pad_880[0x20];                                     // 0x0880(0x0020)(Fixing Size After Last Property [ Dumper-7 ])
	UMulticastDelegateProperty_                   M_onNarrativeSequenceAborted;                      // 0x08A0(0x0018)(ZeroConstructor, InstancedReference, BlueprintAssignable, BlueprintCallable, NativeAccessSpecifierPublic)
	UMulticastDelegateProperty_                   M_onResourceValueChanged;                          // 0x08B8(0x0018)(ZeroConstructor, InstancedReference, BlueprintAssignable, BlueprintCallable, NativeAccessSpecifierPublic)
	uint8                                         Pad_8D0[0x20];                                     // 0x08D0(0x0020)(Fixing Size After Last Property [ Dumper-7 ])
	UMulticastDelegateProperty_                   M_onGameEndPlay;                                   // 0x08F0(0x0018)(ZeroConstructor, InstancedReference, BlueprintAssignable, BlueprintCallable, NativeAccessSpecifierPublic)
	UMulticastDelegateProperty_                   M_onCortexScanVOPlayed;                            // 0x0908(0x0018)(ZeroConstructor, InstancedReference, BlueprintAssignable, BlueprintCallable, NativeAccessSpecifierPublic)
	uint8                                         Pad_920[0x20];                                     // 0x0920(0x0020)(Fixing Size After Last Property [ Dumper-7 ])
	UMulticastDelegateProperty_                   M_onTransportToOrbitAttempt;                       // 0x0940(0x0018)(ZeroConstructor, InstancedReference, BlueprintAssignable, BlueprintCallable, NativeAccessSpecifierPublic)
	uint8                                         Pad_958[0x20];                                     // 0x0958(0x0020)(Fixing Size After Last Property [ Dumper-7 ])
	UMulticastDelegateProperty_                   M_onPrimaryPlayerPawnChanged;                      // 0x0978(0x0018)(ZeroConstructor, InstancedReference, BlueprintAssignable, BlueprintCallable, NativeAccessSpecifierPublic)
	UMulticastDelegateProperty_                   M_onProximityGoalReached;                          // 0x0990(0x0018)(ZeroConstructor, InstancedReference, BlueprintAssignable, BlueprintCallable, NativeAccessSpecifierPublic)
	uint8                                         Pad_9A8[0x20];                                     // 0x09A8(0x0020)(Fixing Size After Last Property [ Dumper-7 ])
	UMulticastDelegateProperty_                   M_onProximitySubgoalReached;                       // 0x09C8(0x0018)(ZeroConstructor, InstancedReference, BlueprintAssignable, BlueprintCallable, NativeAccessSpecifierPublic)
	uint8                                         Pad_9E0[0x20];                                     // 0x09E0(0x0020)(Fixing Size After Last Property [ Dumper-7 ])
	UMulticastDelegateProperty_                   M_onTimerSubgoalReached;                           // 0x0A00(0x0018)(ZeroConstructor, InstancedReference, BlueprintAssignable, BlueprintCallable, NativeAccessSpecifierPublic)
	uint8                                         Pad_A18[0x20];                                     // 0x0A18(0x0020)(Fixing Size After Last Property [ Dumper-7 ])
	UMulticastDelegateProperty_                   M_onEnterWater;                                    // 0x0A38(0x0018)(ZeroConstructor, InstancedReference, BlueprintAssignable, BlueprintCallable, NativeAccessSpecifierPublic)
	uint8                                         Pad_A50[0x20];                                     // 0x0A50(0x0020)(Fixing Size After Last Property [ Dumper-7 ])
	UMulticastDelegateProperty_                   M_onBossObjectiveReached;                          // 0x0A70(0x0018)(ZeroConstructor, InstancedReference, BlueprintAssignable, BlueprintCallable, NativeAccessSpecifierPublic)
	uint8                                         Pad_A88[0x20];                                     // 0x0A88(0x0020)(Fixing Size After Last Property [ Dumper-7 ])
	UMulticastDelegateProperty_                   M_onOpenWorldStarted;                              // 0x0AA8(0x0018)(ZeroConstructor, InstancedReference, BlueprintAssignable, BlueprintCallable, NativeAccessSpecifierPublic)
	class UBFGActorComponent_Timer*               M_pTimerComponent;                                 // 0x0AC0(0x0008)(BlueprintVisible, ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UPhysicalMaterial*                      M_pWaterPhysicsMaterial;                           // 0x0AC8(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TSubclassOf<class UDamageType>                M_pWaterDamageType;                                // 0x0AD0(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TSubclassOf<class UDamageType>                M_pFalldamageType;                                 // 0x0AD8(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TSubclassOf<class UDamageType>                M_pExplosionDamageType;                            // 0x0AE0(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          M_bIsNonGameplayGameState;                         // 0x0AE8(0x0001)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_AE9[0x7];                                      // 0x0AE9(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	TSubclassOf<class UBFGEventManager>           M_pEventManagerClass;                              // 0x0AF0(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TSubclassOf<class UBFGVariableMirror>         M_pVariableMirrorClass;                            // 0x0AF8(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TSubclassOf<class UBFGQuest_Manager>          M_pQuestManagerClass;                              // 0x0B00(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TSubclassOf<class UBFGUFOManager>             M_pUFOManagerClass;                                // 0x0B08(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TSubclassOf<class UBFGChallengeStartingPointManager> M_pCSPManagerClass;                                // 0x0B10(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TSubclassOf<class UBFGTrafficCrowdManager>    M_pTrafficCrowdManagerClass;                       // 0x0B18(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TSubclassOf<class UBFGStreamingLevelManager>  M_pStreamingLevelManagerClass;                     // 0x0B20(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TSubclassOf<class UBFGSequencePlaybackManager> M_pCutscenePlaybackManagerClass;                   // 0x0B28(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TSubclassOf<class UBFGObjectiveMarkerSystem>  M_pObjectiveMarkerSystemClass;                     // 0x0B30(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TSubclassOf<class UBFGAlertSystemManager>     M_pAlertSystemManagerClass;                        // 0x0B38(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TSubclassOf<class UBFGAimAssistManager>       M_pAimAssistManagerClass;                          // 0x0B40(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TSubclassOf<class UBFGLockOnManager>          M_pLockOnManagerClass;                             // 0x0B48(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TSubclassOf<class UBFGTransmogrifyLootManager> M_pTransmogrifyLootManagerClass;                   // 0x0B50(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TSubclassOf<class UBFGDataHub>                M_pHUDDataHubClass;                                // 0x0B58(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TSubclassOf<class UBFGVoiceoverSystem>        M_pVoiceoverSystemClass;                           // 0x0B60(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TSubclassOf<class UBFGAISystem>               M_pAISystemClass;                                  // 0x0B68(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TSubclassOf<class UBFGAmbientSoundManager>    M_pAmbientSoundManagerClass;                       // 0x0B70(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TSubclassOf<class UBFGTutorialManager>        M_pTutorialManagerClass;                           // 0x0B78(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TSubclassOf<class UBFGWidgetPoolManager>      M_pWidgetPoolManagerClass;                         // 0x0B80(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TSubclassOf<class UBFGRadarManager>           M_pRadarManagerClass;                              // 0x0B88(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TSubclassOf<class UBFGDynamicStaticObjectManager> M_pDynamicStaticObjectManagerClass;                // 0x0B90(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TSubclassOf<class UBFGAchievementManager>     M_pAchievementManagerClass;                        // 0x0B98(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TSubclassOf<class UBFGObjectRespawnManager>   M_pObjectRespawnManagerClass;                      // 0x0BA0(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TSubclassOf<class UAnimationSharingSetup>     M_pAnimationSharingSetupClass;                     // 0x0BA8(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TSubclassOf<class UBFGHighlightableSceneObjectManager> M_pHighlightableSceneObjectManagerClass;           // 0x0BB0(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TSubclassOf<class UBFGBurningGroundManager>   M_pBurningGroundClass;                             // 0x0BB8(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TSubclassOf<class UBFGOceanManager>           M_pOceanClass;                                     // 0x0BC0(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TSubclassOf<class UBFGWaterManager>           M_pWaterClass;                                     // 0x0BC8(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TSubclassOf<class UBFGReadTextureManager>     M_pReadTextureClass;                               // 0x0BD0(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TSubclassOf<class UBFGVirtualCrowdManager>    M_pVirtualCrowdClass;                              // 0x0BD8(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TSubclassOf<class UBFGSpawnPoolManager>       M_pSpawnPoolClass;                                 // 0x0BE0(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TSubclassOf<class UBFGInputRebindingSystem>   M_pInputRebindingSystemClass;                      // 0x0BE8(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TSubclassOf<class UBFGBuildingPropsManager>   M_pBuildingPropsManagerClass;                      // 0x0BF0(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TSubclassOf<class UBFGMothershipTransitionManager> M_pMothershipTransitionManagerClass;               // 0x0BF8(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TSubclassOf<class UBFGStatisticsManager>      M_pStatisticManagerClass;                          // 0x0C00(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TSubclassOf<class UBFGBossHealthHUDManager>   M_pBossHealthBarClass;                             // 0x0C08(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TSubclassOf<class UBFGActorActivationManager> M_pActorActivationManagerClass;                    // 0x0C10(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TSubclassOf<class UBFGInterpolationManager>   M_pInterpolationManagerClass;                      // 0x0C18(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TSubclassOf<class UBFGDestructionStreamingManager> M_pDestructionStreamingManagerClass;               // 0x0C20(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TSubclassOf<class UBFGBroadphaseManager>      M_pBroadphaseManagerClass;                         // 0x0C28(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TSubclassOf<class UBFGOverheadWidgetManager>  M_pOverheadWidgetManagerClass;                     // 0x0C30(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TSubclassOf<class UBFGPhotographySystem>      M_pPhotographySystemClass;                         // 0x0C38(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TArray<class AActor*>                         M_apPausedActors;                                  // 0x0C40(0x0010)(ZeroConstructor, Transient, Protected, NativeAccessSpecifierProtected)
	uint8                                         Pad_C50[0x8];                                      // 0x0C50(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<bool>                                  M_aPauseStateRequests;                             // 0x0C58(0x0010)(ZeroConstructor, Transient, Protected, NativeAccessSpecifierProtected)
	bool                                          M_bSystemsStarted;                                 // 0x0C68(0x0001)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_C69[0x7];                                      // 0x0C69(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	class UBFGDamageModifierCache*                M_pDamageModifiers;                                // 0x0C70(0x0008)(ExportObject, ZeroConstructor, Transient, InstancedReference, IsPlainOldData, NoDestructor, Protected, PersistentInstance, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UAnimationSharingSetup*                 M_pAnimationSharingSetup;                          // 0x0C78(0x0008)(ExportObject, ZeroConstructor, Transient, InstancedReference, IsPlainOldData, NoDestructor, Protected, PersistentInstance, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TArray<class UBFGGameSystem*>                 M_aSystemsInitOrder;                               // 0x0C80(0x0010)(ExportObject, ZeroConstructor, Transient, ContainsInstancedReference, Protected, NativeAccessSpecifierProtected)
	TArray<class UBFGGameSystem*>                 M_aSystemsUpdateOrder;                             // 0x0C90(0x0010)(ExportObject, ZeroConstructor, Transient, ContainsInstancedReference, Protected, NativeAccessSpecifierProtected)
	class ABFGDeferredActorSpawnSystem*           M_pDeferredSpawnSystem;                            // 0x0CA0(0x0008)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          M_bInCredits;                                      // 0x0CA8(0x0001)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_CA9[0x7];                                      // 0x0CA9(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<class AActor*>                         M_apDeliverableActors;                             // 0x0CB0(0x0010)(ZeroConstructor, Transient, Protected, NativeAccessSpecifierProtected)
	TArray<class ABFGProjectile_Object*>          M_apCancelHomingProjectiles;                       // 0x0CC0(0x0010)(ZeroConstructor, Transient, Protected, NativeAccessSpecifierProtected)
	TArray<class ABFGSequencePivot*>              M_apSequencePivotRegistry;                         // 0x0CD0(0x0010)(ZeroConstructor, Transient, Protected, NativeAccessSpecifierProtected)
	class APawn*                                  M_pLastKnownPrimaryPlayerPawn;                     // 0x0CE0(0x0008)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          M_bShouldFadeInOnRespawnState;                     // 0x0CE8(0x0001)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_CE9[0x7];                                      // 0x0CE9(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void GameSystemVLog();
	void OnLevelStateChanged(class UBFGStreamingLevelHandle* _pLevelHandle, bool _bIsLoaded);
	void PopGameActorPause();
	void PushGameActorPause(bool _bGamePaused);

	void AwardAchievement(class UWorld* _pWorldContext, class FName _nAchievementID, float _fAchievementProgress) const;
	class UBFGGameSystem* FindGameSystem(TSubclassOf<class UBFGGameSystem> _pClass) const;
	class UBFGAchievementManager* GetAchievementManager() const;
	class UBFGActorActivationManager* GetActorActivationManager() const;
	class UBFGAimAssistManager* GetAimAssistManager() const;
	class UBFGAISystem* GetAISystem() const;
	class UBFGAlertSystemManager* GetAlertSystemManager() const;
	class UBFGAmbientSoundManager* GetAmbientSoundManager() const;
	class UAnimationSharingSetup* GetAnimSharingSetup() const;
	class UBFGBossHealthHUDManager* GetBossHealthHUDManager() const;
	class UBFGBroadphaseManager* GetBroadphaseManager() const;
	class UBFGBuildingPropsManager* GetBuildingPropsManager() const;
	class UBFGBurningGroundManager* GetBurningGroundManager() const;
	class UBFGChallengeStartingPointManager* GetCSPManager() const;
	class UBFGSequencePlaybackManager* GetCutscenePlaybackManager() const;
	class UBFGDestructionStreamingManager* GetDestructionStreamingManager() const;
	class UBFGDynamicStaticObjectManager* GetDynamicStaticObjectManager() const;
	class UBFGEventManager* GetEventManager() const;
	class UBFGHighlightableSceneObjectManager* GetHighlightableSceneObjectManager() const;
	class UBFGDataHub* GetHUDDataHub() const;
	bool GetInCredits() const;
	class UBFGInputRebindingSystem* GetInputRebindingSystem() const;
	class UBFGInterpolationManager* GetInterpolationManager() const;
	class UBFGLockOnManager* GetLockOnManager() const;
	class UBFGMothershipTransitionManager* GetMothershipTransitionManager() const;
	class UBFGObjectiveMarkerSystem* GetObjectiveMarkerSystem() const;
	class UBFGObjectRespawnManager* GetObjectRespawnManager() const;
	class UBFGOceanManager* GetOceanManager() const;
	class UBFGOverheadWidgetManager* GetOverheadWidgetManager() const;
	class UBFGPhotographySystem* GetPhotographySystem() const;
	class UBFGQuest_Manager* GetQuestManager() const;
	class UBFGRadarManager* GetRadarManager() const;
	class UBFGReadTextureManager* GetReadTextureManager() const;
	class UBFGSpawnPoolManager* GetSpawnPoolManager() const;
	class UBFGStatisticsManager* GetStatisticsManager() const;
	class UBFGStreamingLevelManager* GetStreamingLevelManager() const;
	class UBFGTimeDilationManager* GetTimeDilationManager() const;
	class UBFGTrafficCrowdManager* GetTrafficCrowdManager() const;
	class UBFGTransmogrifyLootManager* GetTransmogrifyLootManager() const;
	class UBFGTutorialManager* GetTutorialManager() const;
	class UBFGUFOManager* GetUFOManager() const;
	class UBFGVariableMirror* GetVariableMirror() const;
	class UBFGVirtualCrowdManager* GetVirtualCrowdManager() const;
	class UBFGVoiceoverSystem* GetVoiceoverSystem() const;
	class UBFGWaterManager* GetWaterManager() const;
	class UBFGWidgetPoolManager* GetWidgetPoolManager() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"BFGGameState">();
	}
	static class ABFGGameState* GetDefaultObj()
	{
		return GetDefaultObjImpl<ABFGGameState>();
	}
};
static_assert(alignof(ABFGGameState) == 0x000008, "Wrong alignment on ABFGGameState");
static_assert(sizeof(ABFGGameState) == 0x000CF0, "Wrong size on ABFGGameState");
static_assert(offsetof(ABFGGameState, M_Timespan) == 0x000418, "Member 'ABFGGameState::M_Timespan' has a wrong offset!");
static_assert(offsetof(ABFGGameState, M_OnCutsceneStarted) == 0x000420, "Member 'ABFGGameState::M_OnCutsceneStarted' has a wrong offset!");
static_assert(offsetof(ABFGGameState, M_onPlayerDNAChanged) == 0x000458, "Member 'ABFGGameState::M_onPlayerDNAChanged' has a wrong offset!");
static_assert(offsetof(ABFGGameState, M_onPlayerStateMonetaryValueChanged) == 0x000470, "Member 'ABFGGameState::M_onPlayerStateMonetaryValueChanged' has a wrong offset!");
static_assert(offsetof(ABFGGameState, M_onHitActor) == 0x0004A8, "Member 'ABFGGameState::M_onHitActor' has a wrong offset!");
static_assert(offsetof(ABFGGameState, M_onPickupItem) == 0x0004C0, "Member 'ABFGGameState::M_onPickupItem' has a wrong offset!");
static_assert(offsetof(ABFGGameState, M_onFellOutOfWorld) == 0x0004F8, "Member 'ABFGGameState::M_onFellOutOfWorld' has a wrong offset!");
static_assert(offsetof(ABFGGameState, M_onHealthChanged) == 0x000530, "Member 'ABFGGameState::M_onHealthChanged' has a wrong offset!");
static_assert(offsetof(ABFGGameState, M_onKilledActor) == 0x000568, "Member 'ABFGGameState::M_onKilledActor' has a wrong offset!");
static_assert(offsetof(ABFGGameState, M_onDestroyedStaticObject) == 0x0005A0, "Member 'ABFGGameState::M_onDestroyedStaticObject' has a wrong offset!");
static_assert(offsetof(ABFGGameState, M_onLevelMissionStarted) == 0x0005D8, "Member 'ABFGGameState::M_onLevelMissionStarted' has a wrong offset!");
static_assert(offsetof(ABFGGameState, M_onOverlapActor) == 0x0005F0, "Member 'ABFGGameState::M_onOverlapActor' has a wrong offset!");
static_assert(offsetof(ABFGGameState, M_onOverlapEndActor) == 0x000628, "Member 'ABFGGameState::M_onOverlapEndActor' has a wrong offset!");
static_assert(offsetof(ABFGGameState, M_onMentalAbilityActivity) == 0x000660, "Member 'ABFGGameState::M_onMentalAbilityActivity' has a wrong offset!");
static_assert(offsetof(ABFGGameState, M_onInteract) == 0x000698, "Member 'ABFGGameState::M_onInteract' has a wrong offset!");
static_assert(offsetof(ABFGGameState, M_onTickPlayerControllingUFO) == 0x0006D0, "Member 'ABFGGameState::M_onTickPlayerControllingUFO' has a wrong offset!");
static_assert(offsetof(ABFGGameState, M_onAITaskComplete) == 0x000708, "Member 'ABFGGameState::M_onAITaskComplete' has a wrong offset!");
static_assert(offsetof(ABFGGameState, M_onAITaskStarted) == 0x000720, "Member 'ABFGGameState::M_onAITaskStarted' has a wrong offset!");
static_assert(offsetof(ABFGGameState, M_onSpawnManagerLoaded) == 0x000738, "Member 'ABFGGameState::M_onSpawnManagerLoaded' has a wrong offset!");
static_assert(offsetof(ABFGGameState, M_onSpawnManagerEveryoneDead) == 0x000770, "Member 'ABFGGameState::M_onSpawnManagerEveryoneDead' has a wrong offset!");
static_assert(offsetof(ABFGGameState, M_onWaveStarted) == 0x0007A8, "Member 'ABFGGameState::M_onWaveStarted' has a wrong offset!");
static_assert(offsetof(ABFGGameState, M_onInitialWaveAmountReached) == 0x0007E0, "Member 'ABFGGameState::M_onInitialWaveAmountReached' has a wrong offset!");
static_assert(offsetof(ABFGGameState, M_onNarrativeSequenceStart) == 0x000818, "Member 'ABFGGameState::M_onNarrativeSequenceStart' has a wrong offset!");
static_assert(offsetof(ABFGGameState, M_onNarrativeSequenceEnd) == 0x000830, "Member 'ABFGGameState::M_onNarrativeSequenceEnd' has a wrong offset!");
static_assert(offsetof(ABFGGameState, M_onNarrativeSequenceFailed) == 0x000868, "Member 'ABFGGameState::M_onNarrativeSequenceFailed' has a wrong offset!");
static_assert(offsetof(ABFGGameState, M_onNarrativeSequenceAborted) == 0x0008A0, "Member 'ABFGGameState::M_onNarrativeSequenceAborted' has a wrong offset!");
static_assert(offsetof(ABFGGameState, M_onResourceValueChanged) == 0x0008B8, "Member 'ABFGGameState::M_onResourceValueChanged' has a wrong offset!");
static_assert(offsetof(ABFGGameState, M_onGameEndPlay) == 0x0008F0, "Member 'ABFGGameState::M_onGameEndPlay' has a wrong offset!");
static_assert(offsetof(ABFGGameState, M_onCortexScanVOPlayed) == 0x000908, "Member 'ABFGGameState::M_onCortexScanVOPlayed' has a wrong offset!");
static_assert(offsetof(ABFGGameState, M_onTransportToOrbitAttempt) == 0x000940, "Member 'ABFGGameState::M_onTransportToOrbitAttempt' has a wrong offset!");
static_assert(offsetof(ABFGGameState, M_onPrimaryPlayerPawnChanged) == 0x000978, "Member 'ABFGGameState::M_onPrimaryPlayerPawnChanged' has a wrong offset!");
static_assert(offsetof(ABFGGameState, M_onProximityGoalReached) == 0x000990, "Member 'ABFGGameState::M_onProximityGoalReached' has a wrong offset!");
static_assert(offsetof(ABFGGameState, M_onProximitySubgoalReached) == 0x0009C8, "Member 'ABFGGameState::M_onProximitySubgoalReached' has a wrong offset!");
static_assert(offsetof(ABFGGameState, M_onTimerSubgoalReached) == 0x000A00, "Member 'ABFGGameState::M_onTimerSubgoalReached' has a wrong offset!");
static_assert(offsetof(ABFGGameState, M_onEnterWater) == 0x000A38, "Member 'ABFGGameState::M_onEnterWater' has a wrong offset!");
static_assert(offsetof(ABFGGameState, M_onBossObjectiveReached) == 0x000A70, "Member 'ABFGGameState::M_onBossObjectiveReached' has a wrong offset!");
static_assert(offsetof(ABFGGameState, M_onOpenWorldStarted) == 0x000AA8, "Member 'ABFGGameState::M_onOpenWorldStarted' has a wrong offset!");
static_assert(offsetof(ABFGGameState, M_pTimerComponent) == 0x000AC0, "Member 'ABFGGameState::M_pTimerComponent' has a wrong offset!");
static_assert(offsetof(ABFGGameState, M_pWaterPhysicsMaterial) == 0x000AC8, "Member 'ABFGGameState::M_pWaterPhysicsMaterial' has a wrong offset!");
static_assert(offsetof(ABFGGameState, M_pWaterDamageType) == 0x000AD0, "Member 'ABFGGameState::M_pWaterDamageType' has a wrong offset!");
static_assert(offsetof(ABFGGameState, M_pFalldamageType) == 0x000AD8, "Member 'ABFGGameState::M_pFalldamageType' has a wrong offset!");
static_assert(offsetof(ABFGGameState, M_pExplosionDamageType) == 0x000AE0, "Member 'ABFGGameState::M_pExplosionDamageType' has a wrong offset!");
static_assert(offsetof(ABFGGameState, M_bIsNonGameplayGameState) == 0x000AE8, "Member 'ABFGGameState::M_bIsNonGameplayGameState' has a wrong offset!");
static_assert(offsetof(ABFGGameState, M_pEventManagerClass) == 0x000AF0, "Member 'ABFGGameState::M_pEventManagerClass' has a wrong offset!");
static_assert(offsetof(ABFGGameState, M_pVariableMirrorClass) == 0x000AF8, "Member 'ABFGGameState::M_pVariableMirrorClass' has a wrong offset!");
static_assert(offsetof(ABFGGameState, M_pQuestManagerClass) == 0x000B00, "Member 'ABFGGameState::M_pQuestManagerClass' has a wrong offset!");
static_assert(offsetof(ABFGGameState, M_pUFOManagerClass) == 0x000B08, "Member 'ABFGGameState::M_pUFOManagerClass' has a wrong offset!");
static_assert(offsetof(ABFGGameState, M_pCSPManagerClass) == 0x000B10, "Member 'ABFGGameState::M_pCSPManagerClass' has a wrong offset!");
static_assert(offsetof(ABFGGameState, M_pTrafficCrowdManagerClass) == 0x000B18, "Member 'ABFGGameState::M_pTrafficCrowdManagerClass' has a wrong offset!");
static_assert(offsetof(ABFGGameState, M_pStreamingLevelManagerClass) == 0x000B20, "Member 'ABFGGameState::M_pStreamingLevelManagerClass' has a wrong offset!");
static_assert(offsetof(ABFGGameState, M_pCutscenePlaybackManagerClass) == 0x000B28, "Member 'ABFGGameState::M_pCutscenePlaybackManagerClass' has a wrong offset!");
static_assert(offsetof(ABFGGameState, M_pObjectiveMarkerSystemClass) == 0x000B30, "Member 'ABFGGameState::M_pObjectiveMarkerSystemClass' has a wrong offset!");
static_assert(offsetof(ABFGGameState, M_pAlertSystemManagerClass) == 0x000B38, "Member 'ABFGGameState::M_pAlertSystemManagerClass' has a wrong offset!");
static_assert(offsetof(ABFGGameState, M_pAimAssistManagerClass) == 0x000B40, "Member 'ABFGGameState::M_pAimAssistManagerClass' has a wrong offset!");
static_assert(offsetof(ABFGGameState, M_pLockOnManagerClass) == 0x000B48, "Member 'ABFGGameState::M_pLockOnManagerClass' has a wrong offset!");
static_assert(offsetof(ABFGGameState, M_pTransmogrifyLootManagerClass) == 0x000B50, "Member 'ABFGGameState::M_pTransmogrifyLootManagerClass' has a wrong offset!");
static_assert(offsetof(ABFGGameState, M_pHUDDataHubClass) == 0x000B58, "Member 'ABFGGameState::M_pHUDDataHubClass' has a wrong offset!");
static_assert(offsetof(ABFGGameState, M_pVoiceoverSystemClass) == 0x000B60, "Member 'ABFGGameState::M_pVoiceoverSystemClass' has a wrong offset!");
static_assert(offsetof(ABFGGameState, M_pAISystemClass) == 0x000B68, "Member 'ABFGGameState::M_pAISystemClass' has a wrong offset!");
static_assert(offsetof(ABFGGameState, M_pAmbientSoundManagerClass) == 0x000B70, "Member 'ABFGGameState::M_pAmbientSoundManagerClass' has a wrong offset!");
static_assert(offsetof(ABFGGameState, M_pTutorialManagerClass) == 0x000B78, "Member 'ABFGGameState::M_pTutorialManagerClass' has a wrong offset!");
static_assert(offsetof(ABFGGameState, M_pWidgetPoolManagerClass) == 0x000B80, "Member 'ABFGGameState::M_pWidgetPoolManagerClass' has a wrong offset!");
static_assert(offsetof(ABFGGameState, M_pRadarManagerClass) == 0x000B88, "Member 'ABFGGameState::M_pRadarManagerClass' has a wrong offset!");
static_assert(offsetof(ABFGGameState, M_pDynamicStaticObjectManagerClass) == 0x000B90, "Member 'ABFGGameState::M_pDynamicStaticObjectManagerClass' has a wrong offset!");
static_assert(offsetof(ABFGGameState, M_pAchievementManagerClass) == 0x000B98, "Member 'ABFGGameState::M_pAchievementManagerClass' has a wrong offset!");
static_assert(offsetof(ABFGGameState, M_pObjectRespawnManagerClass) == 0x000BA0, "Member 'ABFGGameState::M_pObjectRespawnManagerClass' has a wrong offset!");
static_assert(offsetof(ABFGGameState, M_pAnimationSharingSetupClass) == 0x000BA8, "Member 'ABFGGameState::M_pAnimationSharingSetupClass' has a wrong offset!");
static_assert(offsetof(ABFGGameState, M_pHighlightableSceneObjectManagerClass) == 0x000BB0, "Member 'ABFGGameState::M_pHighlightableSceneObjectManagerClass' has a wrong offset!");
static_assert(offsetof(ABFGGameState, M_pBurningGroundClass) == 0x000BB8, "Member 'ABFGGameState::M_pBurningGroundClass' has a wrong offset!");
static_assert(offsetof(ABFGGameState, M_pOceanClass) == 0x000BC0, "Member 'ABFGGameState::M_pOceanClass' has a wrong offset!");
static_assert(offsetof(ABFGGameState, M_pWaterClass) == 0x000BC8, "Member 'ABFGGameState::M_pWaterClass' has a wrong offset!");
static_assert(offsetof(ABFGGameState, M_pReadTextureClass) == 0x000BD0, "Member 'ABFGGameState::M_pReadTextureClass' has a wrong offset!");
static_assert(offsetof(ABFGGameState, M_pVirtualCrowdClass) == 0x000BD8, "Member 'ABFGGameState::M_pVirtualCrowdClass' has a wrong offset!");
static_assert(offsetof(ABFGGameState, M_pSpawnPoolClass) == 0x000BE0, "Member 'ABFGGameState::M_pSpawnPoolClass' has a wrong offset!");
static_assert(offsetof(ABFGGameState, M_pInputRebindingSystemClass) == 0x000BE8, "Member 'ABFGGameState::M_pInputRebindingSystemClass' has a wrong offset!");
static_assert(offsetof(ABFGGameState, M_pBuildingPropsManagerClass) == 0x000BF0, "Member 'ABFGGameState::M_pBuildingPropsManagerClass' has a wrong offset!");
static_assert(offsetof(ABFGGameState, M_pMothershipTransitionManagerClass) == 0x000BF8, "Member 'ABFGGameState::M_pMothershipTransitionManagerClass' has a wrong offset!");
static_assert(offsetof(ABFGGameState, M_pStatisticManagerClass) == 0x000C00, "Member 'ABFGGameState::M_pStatisticManagerClass' has a wrong offset!");
static_assert(offsetof(ABFGGameState, M_pBossHealthBarClass) == 0x000C08, "Member 'ABFGGameState::M_pBossHealthBarClass' has a wrong offset!");
static_assert(offsetof(ABFGGameState, M_pActorActivationManagerClass) == 0x000C10, "Member 'ABFGGameState::M_pActorActivationManagerClass' has a wrong offset!");
static_assert(offsetof(ABFGGameState, M_pInterpolationManagerClass) == 0x000C18, "Member 'ABFGGameState::M_pInterpolationManagerClass' has a wrong offset!");
static_assert(offsetof(ABFGGameState, M_pDestructionStreamingManagerClass) == 0x000C20, "Member 'ABFGGameState::M_pDestructionStreamingManagerClass' has a wrong offset!");
static_assert(offsetof(ABFGGameState, M_pBroadphaseManagerClass) == 0x000C28, "Member 'ABFGGameState::M_pBroadphaseManagerClass' has a wrong offset!");
static_assert(offsetof(ABFGGameState, M_pOverheadWidgetManagerClass) == 0x000C30, "Member 'ABFGGameState::M_pOverheadWidgetManagerClass' has a wrong offset!");
static_assert(offsetof(ABFGGameState, M_pPhotographySystemClass) == 0x000C38, "Member 'ABFGGameState::M_pPhotographySystemClass' has a wrong offset!");
static_assert(offsetof(ABFGGameState, M_apPausedActors) == 0x000C40, "Member 'ABFGGameState::M_apPausedActors' has a wrong offset!");
static_assert(offsetof(ABFGGameState, M_aPauseStateRequests) == 0x000C58, "Member 'ABFGGameState::M_aPauseStateRequests' has a wrong offset!");
static_assert(offsetof(ABFGGameState, M_bSystemsStarted) == 0x000C68, "Member 'ABFGGameState::M_bSystemsStarted' has a wrong offset!");
static_assert(offsetof(ABFGGameState, M_pDamageModifiers) == 0x000C70, "Member 'ABFGGameState::M_pDamageModifiers' has a wrong offset!");
static_assert(offsetof(ABFGGameState, M_pAnimationSharingSetup) == 0x000C78, "Member 'ABFGGameState::M_pAnimationSharingSetup' has a wrong offset!");
static_assert(offsetof(ABFGGameState, M_aSystemsInitOrder) == 0x000C80, "Member 'ABFGGameState::M_aSystemsInitOrder' has a wrong offset!");
static_assert(offsetof(ABFGGameState, M_aSystemsUpdateOrder) == 0x000C90, "Member 'ABFGGameState::M_aSystemsUpdateOrder' has a wrong offset!");
static_assert(offsetof(ABFGGameState, M_pDeferredSpawnSystem) == 0x000CA0, "Member 'ABFGGameState::M_pDeferredSpawnSystem' has a wrong offset!");
static_assert(offsetof(ABFGGameState, M_bInCredits) == 0x000CA8, "Member 'ABFGGameState::M_bInCredits' has a wrong offset!");
static_assert(offsetof(ABFGGameState, M_apDeliverableActors) == 0x000CB0, "Member 'ABFGGameState::M_apDeliverableActors' has a wrong offset!");
static_assert(offsetof(ABFGGameState, M_apCancelHomingProjectiles) == 0x000CC0, "Member 'ABFGGameState::M_apCancelHomingProjectiles' has a wrong offset!");
static_assert(offsetof(ABFGGameState, M_apSequencePivotRegistry) == 0x000CD0, "Member 'ABFGGameState::M_apSequencePivotRegistry' has a wrong offset!");
static_assert(offsetof(ABFGGameState, M_pLastKnownPrimaryPlayerPawn) == 0x000CE0, "Member 'ABFGGameState::M_pLastKnownPrimaryPlayerPawn' has a wrong offset!");
static_assert(offsetof(ABFGGameState, M_bShouldFadeInOnRespawnState) == 0x000CE8, "Member 'ABFGGameState::M_bShouldFadeInOnRespawnState' has a wrong offset!");

// Class BFGCore.BFGEventTrigger_TimerSubgoalReached
// 0x0010 (0x0050 - 0x0040)
class UBFGEventTrigger_TimerSubgoalReached final : public UBFGEventTrigger
{
public:
	uint8                                         Pad_40[0x10];                                      // 0x0040(0x0010)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void OnTimerSubgoalReached(const class UBFGQuest_Timer* _pTimer, const struct FTimespan& _tsLimit);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"BFGEventTrigger_TimerSubgoalReached">();
	}
	static class UBFGEventTrigger_TimerSubgoalReached* GetDefaultObj()
	{
		return GetDefaultObjImpl<UBFGEventTrigger_TimerSubgoalReached>();
	}
};
static_assert(alignof(UBFGEventTrigger_TimerSubgoalReached) == 0x000008, "Wrong alignment on UBFGEventTrigger_TimerSubgoalReached");
static_assert(sizeof(UBFGEventTrigger_TimerSubgoalReached) == 0x000050, "Wrong size on UBFGEventTrigger_TimerSubgoalReached");

// Class BFGCore.BFGEventTrigger_VariableChangeValues
// 0x0030 (0x0070 - 0x0040)
class UBFGEventTrigger_VariableChangeValues final : public UBFGEventTrigger
{
public:
	class UBFGVariable*                           M_pVariable;                                       // 0x0040(0x0008)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_48[0x28];                                      // 0x0048(0x0028)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void OnVariableValueChanged(class UBFGVariableMirror* _pVarMirror, const class UBFGVariable* _pVariable, int32 _oldValue, int32 _newValue);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"BFGEventTrigger_VariableChangeValues">();
	}
	static class UBFGEventTrigger_VariableChangeValues* GetDefaultObj()
	{
		return GetDefaultObjImpl<UBFGEventTrigger_VariableChangeValues>();
	}
};
static_assert(alignof(UBFGEventTrigger_VariableChangeValues) == 0x000008, "Wrong alignment on UBFGEventTrigger_VariableChangeValues");
static_assert(sizeof(UBFGEventTrigger_VariableChangeValues) == 0x000070, "Wrong size on UBFGEventTrigger_VariableChangeValues");
static_assert(offsetof(UBFGEventTrigger_VariableChangeValues, M_pVariable) == 0x000040, "Member 'UBFGEventTrigger_VariableChangeValues::M_pVariable' has a wrong offset!");

// Class BFGCore.BFGEventTrigger_WaveStarted
// 0x0010 (0x0050 - 0x0040)
class UBFGEventTrigger_WaveStarted final : public UBFGEventTrigger
{
public:
	uint8                                         Pad_40[0x10];                                      // 0x0040(0x0010)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void OnWaveStarted(class ABFGMissionSpawnManager* _pSpawnManager);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"BFGEventTrigger_WaveStarted">();
	}
	static class UBFGEventTrigger_WaveStarted* GetDefaultObj()
	{
		return GetDefaultObjImpl<UBFGEventTrigger_WaveStarted>();
	}
};
static_assert(alignof(UBFGEventTrigger_WaveStarted) == 0x000008, "Wrong alignment on UBFGEventTrigger_WaveStarted");
static_assert(sizeof(UBFGEventTrigger_WaveStarted) == 0x000050, "Wrong size on UBFGEventTrigger_WaveStarted");

// Class BFGCore.BFGEventTrigger_GameStart
// 0x0000 (0x0040 - 0x0040)
class UBFGEventTrigger_GameStart final : public UBFGEventTrigger
{
public:
	void OnGameStart(class UBFGGameInstance* _pGameInstance, class UWorld* _pWorld);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"BFGEventTrigger_GameStart">();
	}
	static class UBFGEventTrigger_GameStart* GetDefaultObj()
	{
		return GetDefaultObjImpl<UBFGEventTrigger_GameStart>();
	}
};
static_assert(alignof(UBFGEventTrigger_GameStart) == 0x000008, "Wrong alignment on UBFGEventTrigger_GameStart");
static_assert(sizeof(UBFGEventTrigger_GameStart) == 0x000040, "Wrong size on UBFGEventTrigger_GameStart");

// Class BFGCore.BFGFadeSystem
// 0x0068 (0x0090 - 0x0028)
class UBFGFadeSystem final : public UObject
{
public:
	uint8                                         Pad_28[0x30];                                      // 0x0028(0x0030)(Fixing Size After Last Property [ Dumper-7 ])
	class UBFGGameInstance*                       M_pGameInstance;                                   // 0x0058(0x0008)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UBFGFadeSystemUserWidget*               M_pFadeWidget;                                     // 0x0060(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_68[0x8];                                       // 0x0068(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	class UBFGFadeSystemUserWidget*               M_pSaveWidget;                                     // 0x0070(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	TSubclassOf<class UBFGFadeSystemUserWidget>   M_pSaveWidgetClass;                                // 0x0078(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_80[0x10];                                      // 0x0080(0x0010)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	class UBFGGameInstance* GetGameInstance();
	void ResetAudioFade();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"BFGFadeSystem">();
	}
	static class UBFGFadeSystem* GetDefaultObj()
	{
		return GetDefaultObjImpl<UBFGFadeSystem>();
	}
};
static_assert(alignof(UBFGFadeSystem) == 0x000008, "Wrong alignment on UBFGFadeSystem");
static_assert(sizeof(UBFGFadeSystem) == 0x000090, "Wrong size on UBFGFadeSystem");
static_assert(offsetof(UBFGFadeSystem, M_pGameInstance) == 0x000058, "Member 'UBFGFadeSystem::M_pGameInstance' has a wrong offset!");
static_assert(offsetof(UBFGFadeSystem, M_pFadeWidget) == 0x000060, "Member 'UBFGFadeSystem::M_pFadeWidget' has a wrong offset!");
static_assert(offsetof(UBFGFadeSystem, M_pSaveWidget) == 0x000070, "Member 'UBFGFadeSystem::M_pSaveWidget' has a wrong offset!");
static_assert(offsetof(UBFGFadeSystem, M_pSaveWidgetClass) == 0x000078, "Member 'UBFGFadeSystem::M_pSaveWidgetClass' has a wrong offset!");

// Class BFGCore.BFGFluffPhysicsBase
// 0x0018 (0x03F0 - 0x03D8)
class ABFGFluffPhysicsBase : public AActor
{
public:
	class USkeletalMeshComponent*                 M_pSkeletalMesh;                                   // 0x03D8(0x0008)(ExportObject, ZeroConstructor, Transient, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         M_fWakeUpDistance;                                 // 0x03E0(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         M_fFadeSpeed;                                      // 0x03E4(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_3E8[0x8];                                      // 0x03E8(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"BFGFluffPhysicsBase">();
	}
	static class ABFGFluffPhysicsBase* GetDefaultObj()
	{
		return GetDefaultObjImpl<ABFGFluffPhysicsBase>();
	}
};
static_assert(alignof(ABFGFluffPhysicsBase) == 0x000008, "Wrong alignment on ABFGFluffPhysicsBase");
static_assert(sizeof(ABFGFluffPhysicsBase) == 0x0003F0, "Wrong size on ABFGFluffPhysicsBase");
static_assert(offsetof(ABFGFluffPhysicsBase, M_pSkeletalMesh) == 0x0003D8, "Member 'ABFGFluffPhysicsBase::M_pSkeletalMesh' has a wrong offset!");
static_assert(offsetof(ABFGFluffPhysicsBase, M_fWakeUpDistance) == 0x0003E0, "Member 'ABFGFluffPhysicsBase::M_fWakeUpDistance' has a wrong offset!");
static_assert(offsetof(ABFGFluffPhysicsBase, M_fFadeSpeed) == 0x0003E4, "Member 'ABFGFluffPhysicsBase::M_fFadeSpeed' has a wrong offset!");

// Class BFGCore.BFGFoliageBurnt
// 0x0000 (0x08B0 - 0x08B0)
class UBFGFoliageBurnt final : public UBFGFoliageInstancedStaticMeshComponent
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"BFGFoliageBurnt">();
	}
	static class UBFGFoliageBurnt* GetDefaultObj()
	{
		return GetDefaultObjImpl<UBFGFoliageBurnt>();
	}
};
static_assert(alignof(UBFGFoliageBurnt) == 0x000008, "Wrong alignment on UBFGFoliageBurnt");
static_assert(sizeof(UBFGFoliageBurnt) == 0x0008B0, "Wrong size on UBFGFoliageBurnt");

// Class BFGCore.BFGWidget_TutorialHandbookEntry
// 0x0010 (0x0270 - 0x0260)
class UBFGWidget_TutorialHandbookEntry final : public UBFGWidget_DialogOption
{
public:
	class UBFGDataAsset_TutorialPage*             M_pDataEntry;                                      // 0x0260(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UBFGDataAsset_TutorialChapter*          M_pDataChapter;                                    // 0x0268(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"BFGWidget_TutorialHandbookEntry">();
	}
	static class UBFGWidget_TutorialHandbookEntry* GetDefaultObj()
	{
		return GetDefaultObjImpl<UBFGWidget_TutorialHandbookEntry>();
	}
};
static_assert(alignof(UBFGWidget_TutorialHandbookEntry) == 0x000008, "Wrong alignment on UBFGWidget_TutorialHandbookEntry");
static_assert(sizeof(UBFGWidget_TutorialHandbookEntry) == 0x000270, "Wrong size on UBFGWidget_TutorialHandbookEntry");
static_assert(offsetof(UBFGWidget_TutorialHandbookEntry, M_pDataEntry) == 0x000260, "Member 'UBFGWidget_TutorialHandbookEntry::M_pDataEntry' has a wrong offset!");
static_assert(offsetof(UBFGWidget_TutorialHandbookEntry, M_pDataChapter) == 0x000268, "Member 'UBFGWidget_TutorialHandbookEntry::M_pDataChapter' has a wrong offset!");

// Class BFGCore.BFGFoliageDitheredMeshTransition
// 0x0008 (0x0700 - 0x06F8)
class UBFGFoliageDitheredMeshTransition : public UStaticMeshComponent
{
public:
	uint8                                         Pad_6F8[0x8];                                      // 0x06F8(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"BFGFoliageDitheredMeshTransition">();
	}
	static class UBFGFoliageDitheredMeshTransition* GetDefaultObj()
	{
		return GetDefaultObjImpl<UBFGFoliageDitheredMeshTransition>();
	}
};
static_assert(alignof(UBFGFoliageDitheredMeshTransition) == 0x000008, "Wrong alignment on UBFGFoliageDitheredMeshTransition");
static_assert(sizeof(UBFGFoliageDitheredMeshTransition) == 0x000700, "Wrong size on UBFGFoliageDitheredMeshTransition");

// Class BFGCore.BFGFoliageUtils
// 0x0000 (0x0028 - 0x0028)
class UBFGFoliageUtils final : public UBlueprintFunctionLibrary
{
public:
	static bool FindFoliageInSphere(class UObject* WorldContextObject, TArray<struct FBFGFoliageComponentInstancePair>* _apResult, const struct FVector& _vOrigin, float _fRadius, class AActor* _pIgnoreActor, class UClass* _pOnlyFoliageComponentClass);
	static class FName MakeStableNameForFoliageInstance(const class UFoliageInstancedStaticMeshComponent* _pFoliageComponent, int32 _iInstanceIndex);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"BFGFoliageUtils">();
	}
	static class UBFGFoliageUtils* GetDefaultObj()
	{
		return GetDefaultObjImpl<UBFGFoliageUtils>();
	}
};
static_assert(alignof(UBFGFoliageUtils) == 0x000008, "Wrong alignment on UBFGFoliageUtils");
static_assert(sizeof(UBFGFoliageUtils) == 0x000028, "Wrong size on UBFGFoliageUtils");

// Class BFGCore.BFGFreeCamPawn
// 0x0000 (0x0460 - 0x0460)
class ABFGFreeCamPawn final : public ASpectatorPawn
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"BFGFreeCamPawn">();
	}
	static class ABFGFreeCamPawn* GetDefaultObj()
	{
		return GetDefaultObjImpl<ABFGFreeCamPawn>();
	}
};
static_assert(alignof(ABFGFreeCamPawn) == 0x000008, "Wrong alignment on ABFGFreeCamPawn");
static_assert(sizeof(ABFGFreeCamPawn) == 0x000460, "Wrong size on ABFGFreeCamPawn");

// Class BFGCore.BFGWidget_BumperVideo
// 0x0008 (0x0280 - 0x0278)
class UBFGWidget_BumperVideo final : public UBFGInputUserWidget
{
public:
	class UBFGGameFlowState_BumperVideos*         M_pState;                                          // 0x0278(0x0008)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)

public:
	void DoSkipSequence();
	void SetGameFlowState(class UBFGGameFlowState_BumperVideos* _pGameFlowState);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"BFGWidget_BumperVideo">();
	}
	static class UBFGWidget_BumperVideo* GetDefaultObj()
	{
		return GetDefaultObjImpl<UBFGWidget_BumperVideo>();
	}
};
static_assert(alignof(UBFGWidget_BumperVideo) == 0x000008, "Wrong alignment on UBFGWidget_BumperVideo");
static_assert(sizeof(UBFGWidget_BumperVideo) == 0x000280, "Wrong size on UBFGWidget_BumperVideo");
static_assert(offsetof(UBFGWidget_BumperVideo, M_pState) == 0x000278, "Member 'UBFGWidget_BumperVideo::M_pState' has a wrong offset!");

// Class BFGCore.BFGGameFlowState_ConfirmUpgrade
// 0x0038 (0x0140 - 0x0108)
class UBFGGameFlowState_ConfirmUpgrade final : public UBFGGameFlowState_GenericDialog_Customizable
{
public:
	UMulticastDelegateProperty_                   M_OnUpgradeConfirmed;                              // 0x0108(0x0018)(ZeroConstructor, InstancedReference, Protected, NativeAccessSpecifierProtected)
	class FText                                   M_strUpgradeName;                                  // 0x0120(0x0018)(Protected, NativeAccessSpecifierProtected)
	int32                                         M_iUpgradeCost;                                    // 0x0138(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_13C[0x4];                                      // 0x013C(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"BFGGameFlowState_ConfirmUpgrade">();
	}
	static class UBFGGameFlowState_ConfirmUpgrade* GetDefaultObj()
	{
		return GetDefaultObjImpl<UBFGGameFlowState_ConfirmUpgrade>();
	}
};
static_assert(alignof(UBFGGameFlowState_ConfirmUpgrade) == 0x000008, "Wrong alignment on UBFGGameFlowState_ConfirmUpgrade");
static_assert(sizeof(UBFGGameFlowState_ConfirmUpgrade) == 0x000140, "Wrong size on UBFGGameFlowState_ConfirmUpgrade");
static_assert(offsetof(UBFGGameFlowState_ConfirmUpgrade, M_OnUpgradeConfirmed) == 0x000108, "Member 'UBFGGameFlowState_ConfirmUpgrade::M_OnUpgradeConfirmed' has a wrong offset!");
static_assert(offsetof(UBFGGameFlowState_ConfirmUpgrade, M_strUpgradeName) == 0x000120, "Member 'UBFGGameFlowState_ConfirmUpgrade::M_strUpgradeName' has a wrong offset!");
static_assert(offsetof(UBFGGameFlowState_ConfirmUpgrade, M_iUpgradeCost) == 0x000138, "Member 'UBFGGameFlowState_ConfirmUpgrade::M_iUpgradeCost' has a wrong offset!");

// Class BFGCore.BFGWidget_Cutscene
// 0x0018 (0x0290 - 0x0278)
class UBFGWidget_Cutscene final : public UBFGInputUserWidget
{
public:
	uint8                                         Pad_278[0x8];                                      // 0x0278(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	class UBFGGameFlowState_Cutscene*             M_pState;                                          // 0x0280(0x0008)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_288[0x8];                                      // 0x0288(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void DoSkipSequence();
	void SetGameFlowState(class UBFGGameFlowState_Cutscene* _pGameFlowState);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"BFGWidget_Cutscene">();
	}
	static class UBFGWidget_Cutscene* GetDefaultObj()
	{
		return GetDefaultObjImpl<UBFGWidget_Cutscene>();
	}
};
static_assert(alignof(UBFGWidget_Cutscene) == 0x000008, "Wrong alignment on UBFGWidget_Cutscene");
static_assert(sizeof(UBFGWidget_Cutscene) == 0x000290, "Wrong size on UBFGWidget_Cutscene");
static_assert(offsetof(UBFGWidget_Cutscene, M_pState) == 0x000280, "Member 'UBFGWidget_Cutscene::M_pState' has a wrong offset!");

// Class BFGCore.BFGGameFlowState_DebugStartMenu_Entries
// 0x00D0 (0x01D8 - 0x0108)
class UBFGGameFlowState_DebugStartMenu_Entries final : public UBFGGameFlowState_GenericDialog_Customizable
{
public:
	EBFGDebugStartMenu_Mode                       M_mode;                                            // 0x0108(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_109[0x7];                                      // 0x0109(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	TSoftClassPtr<class UClass>                   M_pOptionClass;                                    // 0x0110(0x0028)(Edit, BlueprintVisible, BlueprintReadOnly, DisableEditOnInstance, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TSoftClassPtr<class UClass>                   M_pEntryHandlerClass;                              // 0x0138(0x0028)(Edit, BlueprintVisible, BlueprintReadOnly, DisableEditOnInstance, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TSoftClassPtr<class UClass>                   M_pSubMenuHandlerClass;                            // 0x0160(0x0028)(Edit, BlueprintVisible, BlueprintReadOnly, DisableEditOnInstance, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	struct FBFGDebugStartMenu_EntryData           M_Data;                                            // 0x0188(0x0050)(Transient, Protected, NativeAccessSpecifierProtected)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"BFGGameFlowState_DebugStartMenu_Entries">();
	}
	static class UBFGGameFlowState_DebugStartMenu_Entries* GetDefaultObj()
	{
		return GetDefaultObjImpl<UBFGGameFlowState_DebugStartMenu_Entries>();
	}
};
static_assert(alignof(UBFGGameFlowState_DebugStartMenu_Entries) == 0x000008, "Wrong alignment on UBFGGameFlowState_DebugStartMenu_Entries");
static_assert(sizeof(UBFGGameFlowState_DebugStartMenu_Entries) == 0x0001D8, "Wrong size on UBFGGameFlowState_DebugStartMenu_Entries");
static_assert(offsetof(UBFGGameFlowState_DebugStartMenu_Entries, M_mode) == 0x000108, "Member 'UBFGGameFlowState_DebugStartMenu_Entries::M_mode' has a wrong offset!");
static_assert(offsetof(UBFGGameFlowState_DebugStartMenu_Entries, M_pOptionClass) == 0x000110, "Member 'UBFGGameFlowState_DebugStartMenu_Entries::M_pOptionClass' has a wrong offset!");
static_assert(offsetof(UBFGGameFlowState_DebugStartMenu_Entries, M_pEntryHandlerClass) == 0x000138, "Member 'UBFGGameFlowState_DebugStartMenu_Entries::M_pEntryHandlerClass' has a wrong offset!");
static_assert(offsetof(UBFGGameFlowState_DebugStartMenu_Entries, M_pSubMenuHandlerClass) == 0x000160, "Member 'UBFGGameFlowState_DebugStartMenu_Entries::M_pSubMenuHandlerClass' has a wrong offset!");
static_assert(offsetof(UBFGGameFlowState_DebugStartMenu_Entries, M_Data) == 0x000188, "Member 'UBFGGameFlowState_DebugStartMenu_Entries::M_Data' has a wrong offset!");

// Class BFGCore.BFGGameFlowState_EndScreen
// 0x0068 (0x0170 - 0x0108)
class UBFGGameFlowState_EndScreen final : public UBFGGameFlowState_GenericDialog_Customizable
{
public:
	class FName                                   M_strHandlerName_MainMenu;                         // 0x0108(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	EBFGGameFlowState_EndScreen_Actions           M_action;                                          // 0x0110(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_111[0x7];                                      // 0x0111(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	struct FBFGDebugStartMenu_EntryData           M_dataStartAt;                                     // 0x0118(0x0050)(Transient, Protected, NativeAccessSpecifierProtected)
	float                                         M_fRemaininTime;                                   // 0x0168(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          M_bHasSwitchState;                                 // 0x016C(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_16D[0x3];                                      // 0x016D(0x0003)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"BFGGameFlowState_EndScreen">();
	}
	static class UBFGGameFlowState_EndScreen* GetDefaultObj()
	{
		return GetDefaultObjImpl<UBFGGameFlowState_EndScreen>();
	}
};
static_assert(alignof(UBFGGameFlowState_EndScreen) == 0x000008, "Wrong alignment on UBFGGameFlowState_EndScreen");
static_assert(sizeof(UBFGGameFlowState_EndScreen) == 0x000170, "Wrong size on UBFGGameFlowState_EndScreen");
static_assert(offsetof(UBFGGameFlowState_EndScreen, M_strHandlerName_MainMenu) == 0x000108, "Member 'UBFGGameFlowState_EndScreen::M_strHandlerName_MainMenu' has a wrong offset!");
static_assert(offsetof(UBFGGameFlowState_EndScreen, M_action) == 0x000110, "Member 'UBFGGameFlowState_EndScreen::M_action' has a wrong offset!");
static_assert(offsetof(UBFGGameFlowState_EndScreen, M_dataStartAt) == 0x000118, "Member 'UBFGGameFlowState_EndScreen::M_dataStartAt' has a wrong offset!");
static_assert(offsetof(UBFGGameFlowState_EndScreen, M_fRemaininTime) == 0x000168, "Member 'UBFGGameFlowState_EndScreen::M_fRemaininTime' has a wrong offset!");
static_assert(offsetof(UBFGGameFlowState_EndScreen, M_bHasSwitchState) == 0x00016C, "Member 'UBFGGameFlowState_EndScreen::M_bHasSwitchState' has a wrong offset!");

// Class BFGCore.BFGGameFlowState_IngameMainMenu
// 0x0050 (0x0158 - 0x0108)
class UBFGGameFlowState_IngameMainMenu : public UBFGGameFlowState_GenericDialog_Customizable
{
public:
	class FName                                   M_strHandlerName_Continue;                         // 0x0108(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class FName                                   M_strHandlerName_RestartMission;                   // 0x0110(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class FName                                   M_strHandlerName_RestartChallenge;                 // 0x0118(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class FName                                   M_strHandlerName_CancelChallenge;                  // 0x0120(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class FName                                   M_strHandlerName_FuronHandbook;                    // 0x0128(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class FName                                   M_strHandlerName_ShowOptions;                      // 0x0130(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class FName                                   M_strHandlerName_ReturnToMothership;               // 0x0138(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class FName                                   M_strHandlerName_ReturnToMainMenu;                 // 0x0140(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class FName                                   M_strHandlerName_ShowDebugMenu;                    // 0x0148(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	EBFGGameFlowState_IngameMainMenu_Actions      M_action;                                          // 0x0150(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_151[0x7];                                      // 0x0151(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"BFGGameFlowState_IngameMainMenu">();
	}
	static class UBFGGameFlowState_IngameMainMenu* GetDefaultObj()
	{
		return GetDefaultObjImpl<UBFGGameFlowState_IngameMainMenu>();
	}
};
static_assert(alignof(UBFGGameFlowState_IngameMainMenu) == 0x000008, "Wrong alignment on UBFGGameFlowState_IngameMainMenu");
static_assert(sizeof(UBFGGameFlowState_IngameMainMenu) == 0x000158, "Wrong size on UBFGGameFlowState_IngameMainMenu");
static_assert(offsetof(UBFGGameFlowState_IngameMainMenu, M_strHandlerName_Continue) == 0x000108, "Member 'UBFGGameFlowState_IngameMainMenu::M_strHandlerName_Continue' has a wrong offset!");
static_assert(offsetof(UBFGGameFlowState_IngameMainMenu, M_strHandlerName_RestartMission) == 0x000110, "Member 'UBFGGameFlowState_IngameMainMenu::M_strHandlerName_RestartMission' has a wrong offset!");
static_assert(offsetof(UBFGGameFlowState_IngameMainMenu, M_strHandlerName_RestartChallenge) == 0x000118, "Member 'UBFGGameFlowState_IngameMainMenu::M_strHandlerName_RestartChallenge' has a wrong offset!");
static_assert(offsetof(UBFGGameFlowState_IngameMainMenu, M_strHandlerName_CancelChallenge) == 0x000120, "Member 'UBFGGameFlowState_IngameMainMenu::M_strHandlerName_CancelChallenge' has a wrong offset!");
static_assert(offsetof(UBFGGameFlowState_IngameMainMenu, M_strHandlerName_FuronHandbook) == 0x000128, "Member 'UBFGGameFlowState_IngameMainMenu::M_strHandlerName_FuronHandbook' has a wrong offset!");
static_assert(offsetof(UBFGGameFlowState_IngameMainMenu, M_strHandlerName_ShowOptions) == 0x000130, "Member 'UBFGGameFlowState_IngameMainMenu::M_strHandlerName_ShowOptions' has a wrong offset!");
static_assert(offsetof(UBFGGameFlowState_IngameMainMenu, M_strHandlerName_ReturnToMothership) == 0x000138, "Member 'UBFGGameFlowState_IngameMainMenu::M_strHandlerName_ReturnToMothership' has a wrong offset!");
static_assert(offsetof(UBFGGameFlowState_IngameMainMenu, M_strHandlerName_ReturnToMainMenu) == 0x000140, "Member 'UBFGGameFlowState_IngameMainMenu::M_strHandlerName_ReturnToMainMenu' has a wrong offset!");
static_assert(offsetof(UBFGGameFlowState_IngameMainMenu, M_strHandlerName_ShowDebugMenu) == 0x000148, "Member 'UBFGGameFlowState_IngameMainMenu::M_strHandlerName_ShowDebugMenu' has a wrong offset!");
static_assert(offsetof(UBFGGameFlowState_IngameMainMenu, M_action) == 0x000150, "Member 'UBFGGameFlowState_IngameMainMenu::M_action' has a wrong offset!");

// Class BFGCore.BFGGameFlowState_LoadGame
// 0x0070 (0x0140 - 0x00D0)
class UBFGGameFlowState_LoadGame final : public UBFGGameFlowState_LoadingScreenBase
{
public:
	uint8                                         Pad_D0[0x8];                                       // 0x00D0(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	class UBFGSaveSystem*                         M_pSaveSystem;                                     // 0x00D8(0x0008)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	struct FBFGSavedMapDescription                M_targetMap;                                       // 0x00E0(0x0038)(Transient, Protected, NativeAccessSpecifierProtected)
	class UBFGSaveSystem_LoadGameAction*          M_pAction;                                         // 0x0118(0x0008)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_120[0x8];                                      // 0x0120(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	class UBFGSaveDataCache*                      M_pSaveCache;                                      // 0x0128(0x0008)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_130[0x8];                                      // 0x0130(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	class UBFGGameFlowState_RestartMissionForLoadGame* M_pGFSRestartMission;                              // 0x0138(0x0008)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)

public:
	static bool StartLoadGame(class UBFGGameInstance* _pGameInstance, int32 _iSlot);

	void OnSaveSystemActionComplete(class UBFGSaveSystem* _pSaveSystem, class UBFGSaveSystem_Action* _pAction, EBFGSaveSystem_ActionResult _result);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"BFGGameFlowState_LoadGame">();
	}
	static class UBFGGameFlowState_LoadGame* GetDefaultObj()
	{
		return GetDefaultObjImpl<UBFGGameFlowState_LoadGame>();
	}
};
static_assert(alignof(UBFGGameFlowState_LoadGame) == 0x000008, "Wrong alignment on UBFGGameFlowState_LoadGame");
static_assert(sizeof(UBFGGameFlowState_LoadGame) == 0x000140, "Wrong size on UBFGGameFlowState_LoadGame");
static_assert(offsetof(UBFGGameFlowState_LoadGame, M_pSaveSystem) == 0x0000D8, "Member 'UBFGGameFlowState_LoadGame::M_pSaveSystem' has a wrong offset!");
static_assert(offsetof(UBFGGameFlowState_LoadGame, M_targetMap) == 0x0000E0, "Member 'UBFGGameFlowState_LoadGame::M_targetMap' has a wrong offset!");
static_assert(offsetof(UBFGGameFlowState_LoadGame, M_pAction) == 0x000118, "Member 'UBFGGameFlowState_LoadGame::M_pAction' has a wrong offset!");
static_assert(offsetof(UBFGGameFlowState_LoadGame, M_pSaveCache) == 0x000128, "Member 'UBFGGameFlowState_LoadGame::M_pSaveCache' has a wrong offset!");
static_assert(offsetof(UBFGGameFlowState_LoadGame, M_pGFSRestartMission) == 0x000138, "Member 'UBFGGameFlowState_LoadGame::M_pGFSRestartMission' has a wrong offset!");

// Class BFGCore.BFGGameFlowState_MainMenu_PublicDemo
// 0x0018 (0x0120 - 0x0108)
class UBFGGameFlowState_MainMenu_PublicDemo final : public UBFGGameFlowState_GenericDialog_Customizable
{
public:
	class FName                                   M_strHandlerName_NewGame;                          // 0x0108(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class FName                                   M_strHandlerName_ToggleAxisInvert;                 // 0x0110(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class USoundBase*                             M_pMusicToPlay;                                    // 0x0118(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"BFGGameFlowState_MainMenu_PublicDemo">();
	}
	static class UBFGGameFlowState_MainMenu_PublicDemo* GetDefaultObj()
	{
		return GetDefaultObjImpl<UBFGGameFlowState_MainMenu_PublicDemo>();
	}
};
static_assert(alignof(UBFGGameFlowState_MainMenu_PublicDemo) == 0x000008, "Wrong alignment on UBFGGameFlowState_MainMenu_PublicDemo");
static_assert(sizeof(UBFGGameFlowState_MainMenu_PublicDemo) == 0x000120, "Wrong size on UBFGGameFlowState_MainMenu_PublicDemo");
static_assert(offsetof(UBFGGameFlowState_MainMenu_PublicDemo, M_strHandlerName_NewGame) == 0x000108, "Member 'UBFGGameFlowState_MainMenu_PublicDemo::M_strHandlerName_NewGame' has a wrong offset!");
static_assert(offsetof(UBFGGameFlowState_MainMenu_PublicDemo, M_strHandlerName_ToggleAxisInvert) == 0x000110, "Member 'UBFGGameFlowState_MainMenu_PublicDemo::M_strHandlerName_ToggleAxisInvert' has a wrong offset!");
static_assert(offsetof(UBFGGameFlowState_MainMenu_PublicDemo, M_pMusicToPlay) == 0x000118, "Member 'UBFGGameFlowState_MainMenu_PublicDemo::M_pMusicToPlay' has a wrong offset!");

// Class BFGCore.BFGGameFlowState_MainMenu_SaveSlots
// 0x00C0 (0x01C8 - 0x0108)
class UBFGGameFlowState_MainMenu_SaveSlots final : public UBFGGameFlowState_GenericDialog_Customizable
{
public:
	TSoftClassPtr<class UClass>                   M_pEntryWidgetClass;                               // 0x0108(0x0028)(Edit, BlueprintVisible, BlueprintReadOnly, DisableEditOnInstance, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TSoftClassPtr<class UClass>                   M_pSubMenuStateClass;                              // 0x0130(0x0028)(Edit, BlueprintVisible, BlueprintReadOnly, DisableEditOnInstance, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TSoftClassPtr<class UClass>                   M_pEntryHandlerClass;                              // 0x0158(0x0028)(Edit, BlueprintVisible, BlueprintReadOnly, DisableEditOnInstance, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TSoftClassPtr<class UClass>                   M_pSubMenuHandlerClass;                            // 0x0180(0x0028)(Edit, BlueprintVisible, BlueprintReadOnly, DisableEditOnInstance, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	EBFGGameFlowState_MainMenu_SaveSlotModes      M_mode;                                            // 0x01A8(0x0001)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_1A9[0x7];                                      // 0x01A9(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	class FText                                   M_strEmptySlot;                                    // 0x01B0(0x0018)(Edit, DisableEditOnInstance, Protected, NativeAccessSpecifierProtected)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"BFGGameFlowState_MainMenu_SaveSlots">();
	}
	static class UBFGGameFlowState_MainMenu_SaveSlots* GetDefaultObj()
	{
		return GetDefaultObjImpl<UBFGGameFlowState_MainMenu_SaveSlots>();
	}
};
static_assert(alignof(UBFGGameFlowState_MainMenu_SaveSlots) == 0x000008, "Wrong alignment on UBFGGameFlowState_MainMenu_SaveSlots");
static_assert(sizeof(UBFGGameFlowState_MainMenu_SaveSlots) == 0x0001C8, "Wrong size on UBFGGameFlowState_MainMenu_SaveSlots");
static_assert(offsetof(UBFGGameFlowState_MainMenu_SaveSlots, M_pEntryWidgetClass) == 0x000108, "Member 'UBFGGameFlowState_MainMenu_SaveSlots::M_pEntryWidgetClass' has a wrong offset!");
static_assert(offsetof(UBFGGameFlowState_MainMenu_SaveSlots, M_pSubMenuStateClass) == 0x000130, "Member 'UBFGGameFlowState_MainMenu_SaveSlots::M_pSubMenuStateClass' has a wrong offset!");
static_assert(offsetof(UBFGGameFlowState_MainMenu_SaveSlots, M_pEntryHandlerClass) == 0x000158, "Member 'UBFGGameFlowState_MainMenu_SaveSlots::M_pEntryHandlerClass' has a wrong offset!");
static_assert(offsetof(UBFGGameFlowState_MainMenu_SaveSlots, M_pSubMenuHandlerClass) == 0x000180, "Member 'UBFGGameFlowState_MainMenu_SaveSlots::M_pSubMenuHandlerClass' has a wrong offset!");
static_assert(offsetof(UBFGGameFlowState_MainMenu_SaveSlots, M_mode) == 0x0001A8, "Member 'UBFGGameFlowState_MainMenu_SaveSlots::M_mode' has a wrong offset!");
static_assert(offsetof(UBFGGameFlowState_MainMenu_SaveSlots, M_strEmptySlot) == 0x0001B0, "Member 'UBFGGameFlowState_MainMenu_SaveSlots::M_strEmptySlot' has a wrong offset!");

// Class BFGCore.BFGGameFlowState_MenuGameOptions
// 0x0340 (0x0448 - 0x0108)
class UBFGGameFlowState_MenuGameOptions final : public UBFGGameFlowState_GenericDialog_Customizable
{
public:
	class FText                                   M_resetOptionsConfirmationMessage;                 // 0x0108(0x0018)(Edit, DisableEditOnInstance, Protected, NativeAccessSpecifierProtected)
	TArray<struct FBFGMenuGameOptionEntryInfo>    M_aoMenuGameOptionEntryInfo;                       // 0x0120(0x0010)(Edit, ZeroConstructor, DisableEditOnInstance, Protected, NativeAccessSpecifierProtected)
	TArray<struct FBFGMenuGameOptionFloatProps>   M_aoMenuGameOptionFloatProps;                      // 0x0130(0x0010)(Edit, ZeroConstructor, DisableEditOnInstance, Protected, NativeAccessSpecifierProtected)
	TSoftClassPtr<class UClass>                   M_pGFSLeaveOptionsPromptClass;                     // 0x0140(0x0028)(Edit, BlueprintVisible, BlueprintReadOnly, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TSoftClassPtr<class UClass>                   M_pGFSKeyAssignmentWarningClass;                   // 0x0168(0x0028)(Edit, BlueprintVisible, BlueprintReadOnly, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TArray<struct FIntPoint>                      M_avFilteredResolutionAspectRatios;                // 0x0190(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Protected, NativeAccessSpecifierProtected)
	class FText                                   M_strResolutionPromptMessage;                      // 0x01A0(0x0018)(Edit, BlueprintVisible, BlueprintReadOnly, Protected, NativeAccessSpecifierProtected)
	float                                         M_fResolutionPromptTimerDuration;                  // 0x01B8(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_1BC[0x27C];                                    // 0x01BC(0x027C)(Fixing Size After Last Property [ Dumper-7 ])
	class UBFGGameFlowState_GenericDialog*        M_pGFSLeaveOptionsPrompt;                          // 0x0438(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UBFGGameFlowState_KeyAssignmentWarning* M_pGFSKeyAssignWindow;                             // 0x0440(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)

public:
	void OnChangesAccepted();
	void OnOptionFloatChanged(class FName _oOptionName, float _fValue);
	void OnOptionHandlerMessageLeavePrompt(EBFGDialogMessage _eMessage);
	void OnOptionIntChanged(class FName _oOptionName, int32 _iValue);
	void OnOptionKeyAssignmentChanged();
	void OnResetOptionsDialogResult(bool _bOkClicked);
	void OnResolutionPromptConfirmed(bool _bAccepted);
	void OnWindowModeChanged();
	void ResetOptionsToDefault();

	void GetCultureInfo(TArray<struct FBFGMenuGameOptionCultureInfo>& CultureInfo) const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"BFGGameFlowState_MenuGameOptions">();
	}
	static class UBFGGameFlowState_MenuGameOptions* GetDefaultObj()
	{
		return GetDefaultObjImpl<UBFGGameFlowState_MenuGameOptions>();
	}
};
static_assert(alignof(UBFGGameFlowState_MenuGameOptions) == 0x000008, "Wrong alignment on UBFGGameFlowState_MenuGameOptions");
static_assert(sizeof(UBFGGameFlowState_MenuGameOptions) == 0x000448, "Wrong size on UBFGGameFlowState_MenuGameOptions");
static_assert(offsetof(UBFGGameFlowState_MenuGameOptions, M_resetOptionsConfirmationMessage) == 0x000108, "Member 'UBFGGameFlowState_MenuGameOptions::M_resetOptionsConfirmationMessage' has a wrong offset!");
static_assert(offsetof(UBFGGameFlowState_MenuGameOptions, M_aoMenuGameOptionEntryInfo) == 0x000120, "Member 'UBFGGameFlowState_MenuGameOptions::M_aoMenuGameOptionEntryInfo' has a wrong offset!");
static_assert(offsetof(UBFGGameFlowState_MenuGameOptions, M_aoMenuGameOptionFloatProps) == 0x000130, "Member 'UBFGGameFlowState_MenuGameOptions::M_aoMenuGameOptionFloatProps' has a wrong offset!");
static_assert(offsetof(UBFGGameFlowState_MenuGameOptions, M_pGFSLeaveOptionsPromptClass) == 0x000140, "Member 'UBFGGameFlowState_MenuGameOptions::M_pGFSLeaveOptionsPromptClass' has a wrong offset!");
static_assert(offsetof(UBFGGameFlowState_MenuGameOptions, M_pGFSKeyAssignmentWarningClass) == 0x000168, "Member 'UBFGGameFlowState_MenuGameOptions::M_pGFSKeyAssignmentWarningClass' has a wrong offset!");
static_assert(offsetof(UBFGGameFlowState_MenuGameOptions, M_avFilteredResolutionAspectRatios) == 0x000190, "Member 'UBFGGameFlowState_MenuGameOptions::M_avFilteredResolutionAspectRatios' has a wrong offset!");
static_assert(offsetof(UBFGGameFlowState_MenuGameOptions, M_strResolutionPromptMessage) == 0x0001A0, "Member 'UBFGGameFlowState_MenuGameOptions::M_strResolutionPromptMessage' has a wrong offset!");
static_assert(offsetof(UBFGGameFlowState_MenuGameOptions, M_fResolutionPromptTimerDuration) == 0x0001B8, "Member 'UBFGGameFlowState_MenuGameOptions::M_fResolutionPromptTimerDuration' has a wrong offset!");
static_assert(offsetof(UBFGGameFlowState_MenuGameOptions, M_pGFSLeaveOptionsPrompt) == 0x000438, "Member 'UBFGGameFlowState_MenuGameOptions::M_pGFSLeaveOptionsPrompt' has a wrong offset!");
static_assert(offsetof(UBFGGameFlowState_MenuGameOptions, M_pGFSKeyAssignWindow) == 0x000440, "Member 'UBFGGameFlowState_MenuGameOptions::M_pGFSKeyAssignWindow' has a wrong offset!");

// Class BFGCore.BFGGameFlowState_MessageBox
// 0x0038 (0x0140 - 0x0108)
class UBFGGameFlowState_MessageBox final : public UBFGGameFlowState_GenericDialog_Customizable
{
public:
	struct FBFGMessageBoxParams                   M_params;                                          // 0x0108(0x0038)(Transient, ContainsInstancedReference, Protected, NativeAccessSpecifierProtected)

public:
	static void Show(class UBFGGameInstance* _pGameInstance, const struct FBFGMessageBoxParams& _params);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"BFGGameFlowState_MessageBox">();
	}
	static class UBFGGameFlowState_MessageBox* GetDefaultObj()
	{
		return GetDefaultObjImpl<UBFGGameFlowState_MessageBox>();
	}
};
static_assert(alignof(UBFGGameFlowState_MessageBox) == 0x000008, "Wrong alignment on UBFGGameFlowState_MessageBox");
static_assert(sizeof(UBFGGameFlowState_MessageBox) == 0x000140, "Wrong size on UBFGGameFlowState_MessageBox");
static_assert(offsetof(UBFGGameFlowState_MessageBox, M_params) == 0x000108, "Member 'UBFGGameFlowState_MessageBox::M_params' has a wrong offset!");

// Class BFGCore.BFGGameFlowState_MissionComplete
// 0x0010 (0x0118 - 0x0108)
class UBFGGameFlowState_MissionComplete final : public UBFGGameFlowState_GenericDialog_Customizable
{
public:
	class FName                                   M_strHandlerName_Mothership;                       // 0x0108(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          M_bGotoMothership;                                 // 0x0110(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_111[0x7];                                      // 0x0111(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"BFGGameFlowState_MissionComplete">();
	}
	static class UBFGGameFlowState_MissionComplete* GetDefaultObj()
	{
		return GetDefaultObjImpl<UBFGGameFlowState_MissionComplete>();
	}
};
static_assert(alignof(UBFGGameFlowState_MissionComplete) == 0x000008, "Wrong alignment on UBFGGameFlowState_MissionComplete");
static_assert(sizeof(UBFGGameFlowState_MissionComplete) == 0x000118, "Wrong size on UBFGGameFlowState_MissionComplete");
static_assert(offsetof(UBFGGameFlowState_MissionComplete, M_strHandlerName_Mothership) == 0x000108, "Member 'UBFGGameFlowState_MissionComplete::M_strHandlerName_Mothership' has a wrong offset!");
static_assert(offsetof(UBFGGameFlowState_MissionComplete, M_bGotoMothership) == 0x000110, "Member 'UBFGGameFlowState_MissionComplete::M_bGotoMothership' has a wrong offset!");

// Class BFGCore.BFGGameFlowState_MissionStreaming
// 0x0010 (0x0078 - 0x0068)
class UBFGGameFlowState_MissionStreaming final : public UBFGGameFlowState
{
public:
	class UBFGQuest*                              M_pContext;                                        // 0x0068(0x0008)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_70[0x8];                                       // 0x0070(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"BFGGameFlowState_MissionStreaming">();
	}
	static class UBFGGameFlowState_MissionStreaming* GetDefaultObj()
	{
		return GetDefaultObjImpl<UBFGGameFlowState_MissionStreaming>();
	}
};
static_assert(alignof(UBFGGameFlowState_MissionStreaming) == 0x000008, "Wrong alignment on UBFGGameFlowState_MissionStreaming");
static_assert(sizeof(UBFGGameFlowState_MissionStreaming) == 0x000078, "Wrong size on UBFGGameFlowState_MissionStreaming");
static_assert(offsetof(UBFGGameFlowState_MissionStreaming, M_pContext) == 0x000068, "Member 'UBFGGameFlowState_MissionStreaming::M_pContext' has a wrong offset!");

// Class BFGCore.BFGGameFlowState_Mothership_MainMenu
// 0x0018 (0x0120 - 0x0108)
class UBFGGameFlowState_Mothership_MainMenu final : public UBFGGameFlowState_GenericDialog_Customizable
{
public:
	class FName                                   M_strDebugStartMenuName;                           // 0x0108(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class FName                                   M_strHandlerName_DebugStartMenu;                   // 0x0110(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	EBFGGameFlowState_Mothership_MainMenu_Action  M_action;                                          // 0x0118(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_119[0x7];                                      // 0x0119(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"BFGGameFlowState_Mothership_MainMenu">();
	}
	static class UBFGGameFlowState_Mothership_MainMenu* GetDefaultObj()
	{
		return GetDefaultObjImpl<UBFGGameFlowState_Mothership_MainMenu>();
	}
};
static_assert(alignof(UBFGGameFlowState_Mothership_MainMenu) == 0x000008, "Wrong alignment on UBFGGameFlowState_Mothership_MainMenu");
static_assert(sizeof(UBFGGameFlowState_Mothership_MainMenu) == 0x000120, "Wrong size on UBFGGameFlowState_Mothership_MainMenu");
static_assert(offsetof(UBFGGameFlowState_Mothership_MainMenu, M_strDebugStartMenuName) == 0x000108, "Member 'UBFGGameFlowState_Mothership_MainMenu::M_strDebugStartMenuName' has a wrong offset!");
static_assert(offsetof(UBFGGameFlowState_Mothership_MainMenu, M_strHandlerName_DebugStartMenu) == 0x000110, "Member 'UBFGGameFlowState_Mothership_MainMenu::M_strHandlerName_DebugStartMenu' has a wrong offset!");
static_assert(offsetof(UBFGGameFlowState_Mothership_MainMenu, M_action) == 0x000118, "Member 'UBFGGameFlowState_Mothership_MainMenu::M_action' has a wrong offset!");

// Class BFGCore.BFGGameFlowState_Mothership_MissionSelection
// 0x0048 (0x0150 - 0x0108)
class UBFGGameFlowState_Mothership_MissionSelection final : public UBFGGameFlowState_GenericDialog_Customizable
{
public:
	TSoftClassPtr<class UClass>                   M_pWidget_MapEntry;                                // 0x0108(0x0028)(Edit, BlueprintVisible, BlueprintReadOnly, DisableEditOnInstance, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class ULevelSequence*                         M_pMissionStartSequence;                           // 0x0130(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	EBFGGameFlowState_Mothership_MissionSelection_Actions M_action;                                          // 0x0138(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_139[0x7];                                      // 0x0139(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	class FString                                 M_strTargetWorld;                                  // 0x0140(0x0010)(ZeroConstructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)

public:
	void TriggerLevelSwitch(class ALevelSequenceActor* _pActor, bool _bWasCutscene);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"BFGGameFlowState_Mothership_MissionSelection">();
	}
	static class UBFGGameFlowState_Mothership_MissionSelection* GetDefaultObj()
	{
		return GetDefaultObjImpl<UBFGGameFlowState_Mothership_MissionSelection>();
	}
};
static_assert(alignof(UBFGGameFlowState_Mothership_MissionSelection) == 0x000008, "Wrong alignment on UBFGGameFlowState_Mothership_MissionSelection");
static_assert(sizeof(UBFGGameFlowState_Mothership_MissionSelection) == 0x000150, "Wrong size on UBFGGameFlowState_Mothership_MissionSelection");
static_assert(offsetof(UBFGGameFlowState_Mothership_MissionSelection, M_pWidget_MapEntry) == 0x000108, "Member 'UBFGGameFlowState_Mothership_MissionSelection::M_pWidget_MapEntry' has a wrong offset!");
static_assert(offsetof(UBFGGameFlowState_Mothership_MissionSelection, M_pMissionStartSequence) == 0x000130, "Member 'UBFGGameFlowState_Mothership_MissionSelection::M_pMissionStartSequence' has a wrong offset!");
static_assert(offsetof(UBFGGameFlowState_Mothership_MissionSelection, M_action) == 0x000138, "Member 'UBFGGameFlowState_Mothership_MissionSelection::M_action' has a wrong offset!");
static_assert(offsetof(UBFGGameFlowState_Mothership_MissionSelection, M_strTargetWorld) == 0x000140, "Member 'UBFGGameFlowState_Mothership_MissionSelection::M_strTargetWorld' has a wrong offset!");

// Class BFGCore.BFGGameFlowState_NarrativeSequence
// 0x0028 (0x0130 - 0x0108)
class UBFGGameFlowState_NarrativeSequence final : public UBFGGameFlowState_GenericDialog_Customizable
{
public:
	class UBFGWidget_NarrativeSequence*           M_pWidget;                                         // 0x0108(0x0008)(ExportObject, ZeroConstructor, Transient, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UBFGSequencePlaybackManager*            M_pPlaybackManager;                                // 0x0110(0x0008)(ExportObject, ZeroConstructor, Transient, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UBFGNarrativeSequence*                  M_pNarrativeSequence;                              // 0x0118(0x0008)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_120[0x8];                                      // 0x0120(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	class ALevelSequenceActor*                    M_pLevelSequenceActor;                             // 0x0128(0x0008)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"BFGGameFlowState_NarrativeSequence">();
	}
	static class UBFGGameFlowState_NarrativeSequence* GetDefaultObj()
	{
		return GetDefaultObjImpl<UBFGGameFlowState_NarrativeSequence>();
	}
};
static_assert(alignof(UBFGGameFlowState_NarrativeSequence) == 0x000008, "Wrong alignment on UBFGGameFlowState_NarrativeSequence");
static_assert(sizeof(UBFGGameFlowState_NarrativeSequence) == 0x000130, "Wrong size on UBFGGameFlowState_NarrativeSequence");
static_assert(offsetof(UBFGGameFlowState_NarrativeSequence, M_pWidget) == 0x000108, "Member 'UBFGGameFlowState_NarrativeSequence::M_pWidget' has a wrong offset!");
static_assert(offsetof(UBFGGameFlowState_NarrativeSequence, M_pPlaybackManager) == 0x000110, "Member 'UBFGGameFlowState_NarrativeSequence::M_pPlaybackManager' has a wrong offset!");
static_assert(offsetof(UBFGGameFlowState_NarrativeSequence, M_pNarrativeSequence) == 0x000118, "Member 'UBFGGameFlowState_NarrativeSequence::M_pNarrativeSequence' has a wrong offset!");
static_assert(offsetof(UBFGGameFlowState_NarrativeSequence, M_pLevelSequenceActor) == 0x000128, "Member 'UBFGGameFlowState_NarrativeSequence::M_pLevelSequenceActor' has a wrong offset!");

// Class BFGCore.BFGGameFlowState_Newspaper
// 0x0008 (0x0110 - 0x0108)
class UBFGGameFlowState_Newspaper final : public UBFGGameFlowState_GenericDialog_Customizable
{
public:
	class UBFGDataAsset_NewspaperInfo*            M_pData;                                           // 0x0108(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"BFGGameFlowState_Newspaper">();
	}
	static class UBFGGameFlowState_Newspaper* GetDefaultObj()
	{
		return GetDefaultObjImpl<UBFGGameFlowState_Newspaper>();
	}
};
static_assert(alignof(UBFGGameFlowState_Newspaper) == 0x000008, "Wrong alignment on UBFGGameFlowState_Newspaper");
static_assert(sizeof(UBFGGameFlowState_Newspaper) == 0x000110, "Wrong size on UBFGGameFlowState_Newspaper");
static_assert(offsetof(UBFGGameFlowState_Newspaper, M_pData) == 0x000108, "Member 'UBFGGameFlowState_Newspaper::M_pData' has a wrong offset!");

// Class BFGCore.BFGGameFlowState_PauseMenu_PublicDemo
// 0x0008 (0x0110 - 0x0108)
class UBFGGameFlowState_PauseMenu_PublicDemo final : public UBFGGameFlowState_GenericDialog_Customizable
{
public:
	class FName                                   M_strHandlerName_ToggleAxisInvert;                 // 0x0108(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"BFGGameFlowState_PauseMenu_PublicDemo">();
	}
	static class UBFGGameFlowState_PauseMenu_PublicDemo* GetDefaultObj()
	{
		return GetDefaultObjImpl<UBFGGameFlowState_PauseMenu_PublicDemo>();
	}
};
static_assert(alignof(UBFGGameFlowState_PauseMenu_PublicDemo) == 0x000008, "Wrong alignment on UBFGGameFlowState_PauseMenu_PublicDemo");
static_assert(sizeof(UBFGGameFlowState_PauseMenu_PublicDemo) == 0x000110, "Wrong size on UBFGGameFlowState_PauseMenu_PublicDemo");
static_assert(offsetof(UBFGGameFlowState_PauseMenu_PublicDemo, M_strHandlerName_ToggleAxisInvert) == 0x000108, "Member 'UBFGGameFlowState_PauseMenu_PublicDemo::M_strHandlerName_ToggleAxisInvert' has a wrong offset!");

// Class BFGCore.BFGGameFlowState_QuestCheats
// 0x0010 (0x00E0 - 0x00D0)
class UBFGGameFlowState_QuestCheats final : public UBFGGameFlowState_LoadingScreenBase
{
public:
	class UBFGQuest_Manager*                      M_pQuestManager;                                   // 0x00D0(0x0008)(ExportObject, ZeroConstructor, Transient, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UBFGVariableMirror*                     M_pVarMirror;                                      // 0x00D8(0x0008)(ExportObject, ZeroConstructor, Transient, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"BFGGameFlowState_QuestCheats">();
	}
	static class UBFGGameFlowState_QuestCheats* GetDefaultObj()
	{
		return GetDefaultObjImpl<UBFGGameFlowState_QuestCheats>();
	}
};
static_assert(alignof(UBFGGameFlowState_QuestCheats) == 0x000008, "Wrong alignment on UBFGGameFlowState_QuestCheats");
static_assert(sizeof(UBFGGameFlowState_QuestCheats) == 0x0000E0, "Wrong size on UBFGGameFlowState_QuestCheats");
static_assert(offsetof(UBFGGameFlowState_QuestCheats, M_pQuestManager) == 0x0000D0, "Member 'UBFGGameFlowState_QuestCheats::M_pQuestManager' has a wrong offset!");
static_assert(offsetof(UBFGGameFlowState_QuestCheats, M_pVarMirror) == 0x0000D8, "Member 'UBFGGameFlowState_QuestCheats::M_pVarMirror' has a wrong offset!");

// Class BFGCore.BFGGameFlowState_RespawnAtCheckpoint
// 0x0048 (0x0118 - 0x00D0)
class UBFGGameFlowState_RespawnAtCheckpoint final : public UBFGGameFlowState_LoadingScreenBase
{
public:
	uint8                                         Pad_D0[0x10];                                      // 0x00D0(0x0010)(Fixing Size After Last Property [ Dumper-7 ])
	class ABFGUFOLandingSite*                     M_pLandingSite;                                    // 0x00E0(0x0008)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_E8[0x8];                                       // 0x00E8(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	class ABFGLevelCheckpoint*                    M_pRestartPlayerAtCheckpoint;                      // 0x00F0(0x0008)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class ABFGUFOLandingSite*                     M_pRestartPlayerAtLandingSite;                     // 0x00F8(0x0008)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_100[0x8];                                      // 0x0100(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	class UBFGSaveSystem_Action*                  M_pPostLoadSaveSystemAction;                       // 0x0108(0x0008)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_110[0x8];                                      // 0x0110(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static bool StartRespawn(class UBFGGameInstance* _pGameInstance, bool _bFailedMission);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"BFGGameFlowState_RespawnAtCheckpoint">();
	}
	static class UBFGGameFlowState_RespawnAtCheckpoint* GetDefaultObj()
	{
		return GetDefaultObjImpl<UBFGGameFlowState_RespawnAtCheckpoint>();
	}
};
static_assert(alignof(UBFGGameFlowState_RespawnAtCheckpoint) == 0x000008, "Wrong alignment on UBFGGameFlowState_RespawnAtCheckpoint");
static_assert(sizeof(UBFGGameFlowState_RespawnAtCheckpoint) == 0x000118, "Wrong size on UBFGGameFlowState_RespawnAtCheckpoint");
static_assert(offsetof(UBFGGameFlowState_RespawnAtCheckpoint, M_pLandingSite) == 0x0000E0, "Member 'UBFGGameFlowState_RespawnAtCheckpoint::M_pLandingSite' has a wrong offset!");
static_assert(offsetof(UBFGGameFlowState_RespawnAtCheckpoint, M_pRestartPlayerAtCheckpoint) == 0x0000F0, "Member 'UBFGGameFlowState_RespawnAtCheckpoint::M_pRestartPlayerAtCheckpoint' has a wrong offset!");
static_assert(offsetof(UBFGGameFlowState_RespawnAtCheckpoint, M_pRestartPlayerAtLandingSite) == 0x0000F8, "Member 'UBFGGameFlowState_RespawnAtCheckpoint::M_pRestartPlayerAtLandingSite' has a wrong offset!");
static_assert(offsetof(UBFGGameFlowState_RespawnAtCheckpoint, M_pPostLoadSaveSystemAction) == 0x000108, "Member 'UBFGGameFlowState_RespawnAtCheckpoint::M_pPostLoadSaveSystemAction' has a wrong offset!");

// Class BFGCore.BFGGameFlowState_SaveGame
// 0x0040 (0x0110 - 0x00D0)
class UBFGGameFlowState_SaveGame final : public UBFGGameFlowState_LoadingScreenBase
{
public:
	int32                                         M_iSlotIndex;                                      // 0x00D0(0x0004)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_D4[0x4];                                       // 0x00D4(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class UBFGSaveSystem*                         M_pSaveSystem;                                     // 0x00D8(0x0008)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          M_bSaveStarted;                                    // 0x00E0(0x0001)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_E1[0x7];                                       // 0x00E1(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	class UBFGSaveContext*                        M_pSaveContext;                                    // 0x00E8(0x0008)(ExportObject, ZeroConstructor, Transient, InstancedReference, IsPlainOldData, NoDestructor, Protected, PersistentInstance, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_F0[0x8];                                       // 0x00F0(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	class UBFGQuest*                              M_pQuestUseCase;                                   // 0x00F8(0x0008)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UBFGSaveSystem_SaveGameAction*          M_pSaveAction;                                     // 0x0100(0x0008)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_108[0x8];                                      // 0x0108(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static bool StartSaveGame(class UBFGGameInstance* _pGameInstance, class UBFGSaveContext* _pSaveContext, EBFGSaveSystem_SaveGameAction_UseCase _useCase, class UBFGQuest* _pQuestUseCase, int32 _iSlot, bool _bForceTeleport);

	void OnSaveSystemActionComplete(class UBFGSaveSystem* _pSaveSystem, class UBFGSaveSystem_Action* _pAction, EBFGSaveSystem_ActionResult _result);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"BFGGameFlowState_SaveGame">();
	}
	static class UBFGGameFlowState_SaveGame* GetDefaultObj()
	{
		return GetDefaultObjImpl<UBFGGameFlowState_SaveGame>();
	}
};
static_assert(alignof(UBFGGameFlowState_SaveGame) == 0x000008, "Wrong alignment on UBFGGameFlowState_SaveGame");
static_assert(sizeof(UBFGGameFlowState_SaveGame) == 0x000110, "Wrong size on UBFGGameFlowState_SaveGame");
static_assert(offsetof(UBFGGameFlowState_SaveGame, M_iSlotIndex) == 0x0000D0, "Member 'UBFGGameFlowState_SaveGame::M_iSlotIndex' has a wrong offset!");
static_assert(offsetof(UBFGGameFlowState_SaveGame, M_pSaveSystem) == 0x0000D8, "Member 'UBFGGameFlowState_SaveGame::M_pSaveSystem' has a wrong offset!");
static_assert(offsetof(UBFGGameFlowState_SaveGame, M_bSaveStarted) == 0x0000E0, "Member 'UBFGGameFlowState_SaveGame::M_bSaveStarted' has a wrong offset!");
static_assert(offsetof(UBFGGameFlowState_SaveGame, M_pSaveContext) == 0x0000E8, "Member 'UBFGGameFlowState_SaveGame::M_pSaveContext' has a wrong offset!");
static_assert(offsetof(UBFGGameFlowState_SaveGame, M_pQuestUseCase) == 0x0000F8, "Member 'UBFGGameFlowState_SaveGame::M_pQuestUseCase' has a wrong offset!");
static_assert(offsetof(UBFGGameFlowState_SaveGame, M_pSaveAction) == 0x000100, "Member 'UBFGGameFlowState_SaveGame::M_pSaveAction' has a wrong offset!");

// Class BFGCore.BFGGameFlowState_SelectPlayerOption
// 0x0060 (0x0168 - 0x0108)
class UBFGGameFlowState_SelectPlayerOption final : public UBFGGameFlowState_GenericDialog_Customizable
{
public:
	TSoftClassPtr<class UClass>                   M_spOptionWidgetClass;                             // 0x0108(0x0028)(Edit, DisableEditOnInstance, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_130[0x20];                                     // 0x0130(0x0020)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<class FText>                           M_aOptions;                                        // 0x0150(0x0010)(ZeroConstructor, Transient, NativeAccessSpecifierPrivate)
	uint8                                         Pad_160[0x8];                                      // 0x0160(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"BFGGameFlowState_SelectPlayerOption">();
	}
	static class UBFGGameFlowState_SelectPlayerOption* GetDefaultObj()
	{
		return GetDefaultObjImpl<UBFGGameFlowState_SelectPlayerOption>();
	}
};
static_assert(alignof(UBFGGameFlowState_SelectPlayerOption) == 0x000008, "Wrong alignment on UBFGGameFlowState_SelectPlayerOption");
static_assert(sizeof(UBFGGameFlowState_SelectPlayerOption) == 0x000168, "Wrong size on UBFGGameFlowState_SelectPlayerOption");
static_assert(offsetof(UBFGGameFlowState_SelectPlayerOption, M_spOptionWidgetClass) == 0x000108, "Member 'UBFGGameFlowState_SelectPlayerOption::M_spOptionWidgetClass' has a wrong offset!");
static_assert(offsetof(UBFGGameFlowState_SelectPlayerOption, M_aOptions) == 0x000150, "Member 'UBFGGameFlowState_SelectPlayerOption::M_aOptions' has a wrong offset!");

// Class BFGCore.BFGDialogOptionHandler_SelectPlayerOption
// 0x0010 (0x0060 - 0x0050)
class UBFGDialogOptionHandler_SelectPlayerOption final : public UBFGDialogOptionHandler_Base
{
public:
	uint8                                         Pad_50[0x10];                                      // 0x0050(0x0010)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"BFGDialogOptionHandler_SelectPlayerOption">();
	}
	static class UBFGDialogOptionHandler_SelectPlayerOption* GetDefaultObj()
	{
		return GetDefaultObjImpl<UBFGDialogOptionHandler_SelectPlayerOption>();
	}
};
static_assert(alignof(UBFGDialogOptionHandler_SelectPlayerOption) == 0x000008, "Wrong alignment on UBFGDialogOptionHandler_SelectPlayerOption");
static_assert(sizeof(UBFGDialogOptionHandler_SelectPlayerOption) == 0x000060, "Wrong size on UBFGDialogOptionHandler_SelectPlayerOption");

// Class BFGCore.BFGGameFlowState_TimedConfirm
// 0x0038 (0x0140 - 0x0108)
class UBFGGameFlowState_TimedConfirm final : public UBFGGameFlowState_GenericDialog_Customizable
{
public:
	UMulticastDelegateProperty_                   M_OnConfirmed;                                     // 0x0108(0x0018)(ZeroConstructor, InstancedReference, Protected, NativeAccessSpecifierProtected)
	class FText                                   M_strPromptMessage;                                // 0x0120(0x0018)(Protected, NativeAccessSpecifierProtected)
	float                                         M_fTimerDuration;                                  // 0x0138(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_13C[0x4];                                      // 0x013C(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"BFGGameFlowState_TimedConfirm">();
	}
	static class UBFGGameFlowState_TimedConfirm* GetDefaultObj()
	{
		return GetDefaultObjImpl<UBFGGameFlowState_TimedConfirm>();
	}
};
static_assert(alignof(UBFGGameFlowState_TimedConfirm) == 0x000008, "Wrong alignment on UBFGGameFlowState_TimedConfirm");
static_assert(sizeof(UBFGGameFlowState_TimedConfirm) == 0x000140, "Wrong size on UBFGGameFlowState_TimedConfirm");
static_assert(offsetof(UBFGGameFlowState_TimedConfirm, M_OnConfirmed) == 0x000108, "Member 'UBFGGameFlowState_TimedConfirm::M_OnConfirmed' has a wrong offset!");
static_assert(offsetof(UBFGGameFlowState_TimedConfirm, M_strPromptMessage) == 0x000120, "Member 'UBFGGameFlowState_TimedConfirm::M_strPromptMessage' has a wrong offset!");
static_assert(offsetof(UBFGGameFlowState_TimedConfirm, M_fTimerDuration) == 0x000138, "Member 'UBFGGameFlowState_TimedConfirm::M_fTimerDuration' has a wrong offset!");

// Class BFGCore.BFGFuronigamiSelectionInfo
// 0x0090 (0x00C0 - 0x0030)
class UBFGFuronigamiSelectionInfo : public UDataAsset
{
public:
	struct FSlateBrush                            M_oThumbnail;                                      // 0x0030(0x0088)(Edit, BlueprintVisible, BlueprintReadOnly, DisableEditOnInstance, NativeAccessSpecifierPublic)
	struct FGameplayTag                           M_oUnlockTag;                                      // 0x00B8(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, DisableEditOnInstance, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"BFGFuronigamiSelectionInfo">();
	}
	static class UBFGFuronigamiSelectionInfo* GetDefaultObj()
	{
		return GetDefaultObjImpl<UBFGFuronigamiSelectionInfo>();
	}
};
static_assert(alignof(UBFGFuronigamiSelectionInfo) == 0x000008, "Wrong alignment on UBFGFuronigamiSelectionInfo");
static_assert(sizeof(UBFGFuronigamiSelectionInfo) == 0x0000C0, "Wrong size on UBFGFuronigamiSelectionInfo");
static_assert(offsetof(UBFGFuronigamiSelectionInfo, M_oThumbnail) == 0x000030, "Member 'UBFGFuronigamiSelectionInfo::M_oThumbnail' has a wrong offset!");
static_assert(offsetof(UBFGFuronigamiSelectionInfo, M_oUnlockTag) == 0x0000B8, "Member 'UBFGFuronigamiSelectionInfo::M_oUnlockTag' has a wrong offset!");

// Class BFGCore.BFGGameFlowState_TutorialHandbook
// 0x0078 (0x0180 - 0x0108)
class UBFGGameFlowState_TutorialHandbook final : public UBFGGameFlowState_GenericDialog_Customizable
{
public:
	TSoftClassPtr<class UClass>                   M_pTutorialChapterWidgetClass;                     // 0x0108(0x0028)(Edit, BlueprintVisible, BlueprintReadOnly, DisableEditOnInstance, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TSoftClassPtr<class UClass>                   M_pTutorialEntryWidgetClass;                       // 0x0130(0x0028)(Edit, BlueprintVisible, BlueprintReadOnly, DisableEditOnInstance, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TSoftObjectPtr<class UDataTable>              M_pTutorialChapterDataTable;                       // 0x0158(0x0028)(Edit, BlueprintVisible, BlueprintReadOnly, DisableEditOnInstance, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"BFGGameFlowState_TutorialHandbook">();
	}
	static class UBFGGameFlowState_TutorialHandbook* GetDefaultObj()
	{
		return GetDefaultObjImpl<UBFGGameFlowState_TutorialHandbook>();
	}
};
static_assert(alignof(UBFGGameFlowState_TutorialHandbook) == 0x000008, "Wrong alignment on UBFGGameFlowState_TutorialHandbook");
static_assert(sizeof(UBFGGameFlowState_TutorialHandbook) == 0x000180, "Wrong size on UBFGGameFlowState_TutorialHandbook");
static_assert(offsetof(UBFGGameFlowState_TutorialHandbook, M_pTutorialChapterWidgetClass) == 0x000108, "Member 'UBFGGameFlowState_TutorialHandbook::M_pTutorialChapterWidgetClass' has a wrong offset!");
static_assert(offsetof(UBFGGameFlowState_TutorialHandbook, M_pTutorialEntryWidgetClass) == 0x000130, "Member 'UBFGGameFlowState_TutorialHandbook::M_pTutorialEntryWidgetClass' has a wrong offset!");
static_assert(offsetof(UBFGGameFlowState_TutorialHandbook, M_pTutorialChapterDataTable) == 0x000158, "Member 'UBFGGameFlowState_TutorialHandbook::M_pTutorialChapterDataTable' has a wrong offset!");

// Class BFGCore.BFGGameFlowState_UserSignedOut
// 0x0000 (0x0108 - 0x0108)
class UBFGGameFlowState_UserSignedOut final : public UBFGGameFlowState_GenericDialog_Customizable
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"BFGGameFlowState_UserSignedOut">();
	}
	static class UBFGGameFlowState_UserSignedOut* GetDefaultObj()
	{
		return GetDefaultObjImpl<UBFGGameFlowState_UserSignedOut>();
	}
};
static_assert(alignof(UBFGGameFlowState_UserSignedOut) == 0x000008, "Wrong alignment on UBFGGameFlowState_UserSignedOut");
static_assert(sizeof(UBFGGameFlowState_UserSignedOut) == 0x000108, "Wrong size on UBFGGameFlowState_UserSignedOut");

// Class BFGCore.BFGWorldLoadedCallbackHandler
// 0x0008 (0x0030 - 0x0028)
class UBFGWorldLoadedCallbackHandler final : public UObject
{
public:
	uint8                                         Pad_28[0x8];                                       // 0x0028(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void OnWorldLoaded(class UBFGGameInstance* _pGameInstance, class UWorld* _pWorld);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"BFGWorldLoadedCallbackHandler">();
	}
	static class UBFGWorldLoadedCallbackHandler* GetDefaultObj()
	{
		return GetDefaultObjImpl<UBFGWorldLoadedCallbackHandler>();
	}
};
static_assert(alignof(UBFGWorldLoadedCallbackHandler) == 0x000008, "Wrong alignment on UBFGWorldLoadedCallbackHandler");
static_assert(sizeof(UBFGWorldLoadedCallbackHandler) == 0x000030, "Wrong size on UBFGWorldLoadedCallbackHandler");

// Class BFGCore.BFGGameInstance
// 0x01E8 (0x0358 - 0x0170)
class UBFGGameInstance : public UGameInstance
{
public:
	uint8                                         Pad_170[0x8];                                      // 0x0170(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	UMulticastDelegateProperty_                   M_onWorldLoaded;                                   // 0x0178(0x0018)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	UMulticastDelegateProperty_                   M_onGameStart;                                     // 0x0190(0x0018)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	UMulticastDelegateProperty_                   M_onBeforeCloseLoadingScreen;                      // 0x01A8(0x0018)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	class UBFGDiscordWrapper*                     M_pDiscordRPObject;                                // 0x01C0(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         M_fUpdateTickTime;                                 // 0x01C8(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_1CC[0x4];                                      // 0x01CC(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	TSubclassOf<class UBFGMenuLifetimeManager>    M_pMenuLifetimeManagerClass;                       // 0x01D0(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TSubclassOf<class UBFGMenuFactory>            M_pMenuFactoryClass;                               // 0x01D8(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TSubclassOf<class UBFGUIInputDeviceTracker>   M_pInputDeviceTrackerClass;                        // 0x01E0(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TSoftObjectPtr<class UWorld>                  M_pMainMenuMap;                                    // 0x01E8(0x0028)(Edit, Config, DisableEditOnInstance, GlobalConfig, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TSoftClassPtr<class UClass>                   M_pInitialGameFlowState;                           // 0x0210(0x0028)(Edit, DisableEditOnInstance, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TSoftClassPtr<class UClass>                   M_pPlayGameFlowState;                              // 0x0238(0x0028)(Edit, DisableEditOnInstance, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TSubclassOf<class UBFGDiscordWrapper>         M_pDiscordRPClass;                                 // 0x0260(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_268[0x10];                                     // 0x0268(0x0010)(Fixing Size After Last Property [ Dumper-7 ])
	class UBFGGameSession*                        M_pGameSession;                                    // 0x0278(0x0008)(ExportObject, ZeroConstructor, Transient, InstancedReference, IsPlainOldData, NoDestructor, Protected, PersistentInstance, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UBFGGameFlowStateManager*               M_pGameFlowStateManager;                           // 0x0280(0x0008)(ExportObject, ZeroConstructor, Transient, InstancedReference, IsPlainOldData, NoDestructor, Protected, PersistentInstance, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UBFGMenuLifetimeManager*                M_pMenuLifetimeManager;                            // 0x0288(0x0008)(ExportObject, ZeroConstructor, Transient, InstancedReference, IsPlainOldData, NoDestructor, Protected, PersistentInstance, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UBFGMenuFactory*                        M_pMenuFactory;                                    // 0x0290(0x0008)(ExportObject, ZeroConstructor, Transient, InstancedReference, IsPlainOldData, NoDestructor, Protected, PersistentInstance, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UBFGUIInputDeviceTracker*               M_pInputDeviceTracker;                             // 0x0298(0x0008)(ExportObject, ZeroConstructor, Transient, InstancedReference, IsPlainOldData, NoDestructor, Protected, PersistentInstance, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UBFGSubtitleVisibilityManager*          M_pSubtitleVisibilityManager;                      // 0x02A0(0x0008)(ExportObject, ZeroConstructor, Transient, InstancedReference, IsPlainOldData, NoDestructor, Protected, PersistentInstance, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UBFGTransitionManager*                  M_pTransitionManager;                              // 0x02A8(0x0008)(ExportObject, ZeroConstructor, Transient, InstancedReference, IsPlainOldData, NoDestructor, Protected, PersistentInstance, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UBFGPauseManager*                       M_pPauseManager;                                   // 0x02B0(0x0008)(ExportObject, ZeroConstructor, Transient, InstancedReference, IsPlainOldData, NoDestructor, Protected, PersistentInstance, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UBFGInterLevelSoundManager*             M_pInterLevelSoundManager;                         // 0x02B8(0x0008)(ExportObject, ZeroConstructor, Transient, InstancedReference, IsPlainOldData, NoDestructor, Protected, PersistentInstance, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UBFGSaveSystem*                         M_pSaveSystem;                                     // 0x02C0(0x0008)(ExportObject, ZeroConstructor, Transient, InstancedReference, IsPlainOldData, NoDestructor, Protected, PersistentInstance, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UBFGBackgroundLoader*                   M_pBackgroundLoader;                               // 0x02C8(0x0008)(ExportObject, ZeroConstructor, Transient, InstancedReference, IsPlainOldData, NoDestructor, Protected, PersistentInstance, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UBFGUserSignInManager*                  M_pSignInManager;                                  // 0x02D0(0x0008)(ExportObject, ZeroConstructor, Transient, InstancedReference, IsPlainOldData, NoDestructor, Protected, PersistentInstance, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UBFGChunkManager*                       M_pChunkManager;                                   // 0x02D8(0x0008)(ExportObject, ZeroConstructor, Transient, InstancedReference, IsPlainOldData, NoDestructor, Protected, PersistentInstance, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UBFGGameplayEndSystem*                  M_pGameplayEndSystem;                              // 0x02E0(0x0008)(ExportObject, ZeroConstructor, Transient, InstancedReference, IsPlainOldData, NoDestructor, Protected, PersistentInstance, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UObjectLibrary*                         M_pPreloadLibrarySkin;                             // 0x02E8(0x0008)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	struct FDateTime                              M_lastTickTime;                                    // 0x02F0(0x0008)(ZeroConstructor, Transient, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_2F8[0x58];                                     // 0x02F8(0x0058)(Fixing Size After Last Property [ Dumper-7 ])
	class UObjectLibrary*                         M_pPreloadLibrary;                                 // 0x0350(0x0008)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)

public:
	void ClothTest();
	void DebugKinectReserve(bool _bTakeReseve);
	void GameFlowStateManager_LogStack();
	void GpuTestMode();
	void LDStats(int32 _iMode);
	void OnActiveUserChanged();
	void OnUpdate();
	void PerfCap(const class FString& _strMission);
	void SaveGame_LogActor(const class FString& _strPartialName, bool _bCaseSensitive);
	void SaveGame_LogActorPlayer();
	void SaveGame_LogContentsOfCache();
	void SaveGame_LogCurrentActorData();
	void SaveGame_LogProfileUnlockedTags();
	void Superman();
	void TransitionManager_LogStatus();
	void UpdateDLCList();

	class UBFGChunkManager* GetChunkManager() const;
	class UBFGGameFlowStateManager* GetGameFlowStateManager() const;
	class UBFGGameSession* GetGameSession() const;
	class UBFGUIInputDeviceTracker* GetInputDeviceTracker() const;
	class UBFGInterLevelSoundManager* GetInterLevelSoundManager() const;
	class UBFGMenuFactory* GetMenuFactory() const;
	class UBFGMenuLifetimeManager* GetMenuLifetimeManager() const;
	class UBFGPauseManager* GetPauseManager() const;
	class UBFGSaveSystem* GetSaveSystem() const;
	class UBFGSubtitleVisibilityManager* GetSubtitleVisibilityManager() const;
	class UBFGTransitionManager* GetTransitionManager() const;
	class UBFGUserSignInManager* GetUserSignInManager() const;
	bool HasDLC(EBFGDLCItem _eDLC) const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"BFGGameInstance">();
	}
	static class UBFGGameInstance* GetDefaultObj()
	{
		return GetDefaultObjImpl<UBFGGameInstance>();
	}
};
static_assert(alignof(UBFGGameInstance) == 0x000008, "Wrong alignment on UBFGGameInstance");
static_assert(sizeof(UBFGGameInstance) == 0x000358, "Wrong size on UBFGGameInstance");
static_assert(offsetof(UBFGGameInstance, M_onWorldLoaded) == 0x000178, "Member 'UBFGGameInstance::M_onWorldLoaded' has a wrong offset!");
static_assert(offsetof(UBFGGameInstance, M_onGameStart) == 0x000190, "Member 'UBFGGameInstance::M_onGameStart' has a wrong offset!");
static_assert(offsetof(UBFGGameInstance, M_onBeforeCloseLoadingScreen) == 0x0001A8, "Member 'UBFGGameInstance::M_onBeforeCloseLoadingScreen' has a wrong offset!");
static_assert(offsetof(UBFGGameInstance, M_pDiscordRPObject) == 0x0001C0, "Member 'UBFGGameInstance::M_pDiscordRPObject' has a wrong offset!");
static_assert(offsetof(UBFGGameInstance, M_fUpdateTickTime) == 0x0001C8, "Member 'UBFGGameInstance::M_fUpdateTickTime' has a wrong offset!");
static_assert(offsetof(UBFGGameInstance, M_pMenuLifetimeManagerClass) == 0x0001D0, "Member 'UBFGGameInstance::M_pMenuLifetimeManagerClass' has a wrong offset!");
static_assert(offsetof(UBFGGameInstance, M_pMenuFactoryClass) == 0x0001D8, "Member 'UBFGGameInstance::M_pMenuFactoryClass' has a wrong offset!");
static_assert(offsetof(UBFGGameInstance, M_pInputDeviceTrackerClass) == 0x0001E0, "Member 'UBFGGameInstance::M_pInputDeviceTrackerClass' has a wrong offset!");
static_assert(offsetof(UBFGGameInstance, M_pMainMenuMap) == 0x0001E8, "Member 'UBFGGameInstance::M_pMainMenuMap' has a wrong offset!");
static_assert(offsetof(UBFGGameInstance, M_pInitialGameFlowState) == 0x000210, "Member 'UBFGGameInstance::M_pInitialGameFlowState' has a wrong offset!");
static_assert(offsetof(UBFGGameInstance, M_pPlayGameFlowState) == 0x000238, "Member 'UBFGGameInstance::M_pPlayGameFlowState' has a wrong offset!");
static_assert(offsetof(UBFGGameInstance, M_pDiscordRPClass) == 0x000260, "Member 'UBFGGameInstance::M_pDiscordRPClass' has a wrong offset!");
static_assert(offsetof(UBFGGameInstance, M_pGameSession) == 0x000278, "Member 'UBFGGameInstance::M_pGameSession' has a wrong offset!");
static_assert(offsetof(UBFGGameInstance, M_pGameFlowStateManager) == 0x000280, "Member 'UBFGGameInstance::M_pGameFlowStateManager' has a wrong offset!");
static_assert(offsetof(UBFGGameInstance, M_pMenuLifetimeManager) == 0x000288, "Member 'UBFGGameInstance::M_pMenuLifetimeManager' has a wrong offset!");
static_assert(offsetof(UBFGGameInstance, M_pMenuFactory) == 0x000290, "Member 'UBFGGameInstance::M_pMenuFactory' has a wrong offset!");
static_assert(offsetof(UBFGGameInstance, M_pInputDeviceTracker) == 0x000298, "Member 'UBFGGameInstance::M_pInputDeviceTracker' has a wrong offset!");
static_assert(offsetof(UBFGGameInstance, M_pSubtitleVisibilityManager) == 0x0002A0, "Member 'UBFGGameInstance::M_pSubtitleVisibilityManager' has a wrong offset!");
static_assert(offsetof(UBFGGameInstance, M_pTransitionManager) == 0x0002A8, "Member 'UBFGGameInstance::M_pTransitionManager' has a wrong offset!");
static_assert(offsetof(UBFGGameInstance, M_pPauseManager) == 0x0002B0, "Member 'UBFGGameInstance::M_pPauseManager' has a wrong offset!");
static_assert(offsetof(UBFGGameInstance, M_pInterLevelSoundManager) == 0x0002B8, "Member 'UBFGGameInstance::M_pInterLevelSoundManager' has a wrong offset!");
static_assert(offsetof(UBFGGameInstance, M_pSaveSystem) == 0x0002C0, "Member 'UBFGGameInstance::M_pSaveSystem' has a wrong offset!");
static_assert(offsetof(UBFGGameInstance, M_pBackgroundLoader) == 0x0002C8, "Member 'UBFGGameInstance::M_pBackgroundLoader' has a wrong offset!");
static_assert(offsetof(UBFGGameInstance, M_pSignInManager) == 0x0002D0, "Member 'UBFGGameInstance::M_pSignInManager' has a wrong offset!");
static_assert(offsetof(UBFGGameInstance, M_pChunkManager) == 0x0002D8, "Member 'UBFGGameInstance::M_pChunkManager' has a wrong offset!");
static_assert(offsetof(UBFGGameInstance, M_pGameplayEndSystem) == 0x0002E0, "Member 'UBFGGameInstance::M_pGameplayEndSystem' has a wrong offset!");
static_assert(offsetof(UBFGGameInstance, M_pPreloadLibrarySkin) == 0x0002E8, "Member 'UBFGGameInstance::M_pPreloadLibrarySkin' has a wrong offset!");
static_assert(offsetof(UBFGGameInstance, M_lastTickTime) == 0x0002F0, "Member 'UBFGGameInstance::M_lastTickTime' has a wrong offset!");
static_assert(offsetof(UBFGGameInstance, M_pPreloadLibrary) == 0x000350, "Member 'UBFGGameInstance::M_pPreloadLibrary' has a wrong offset!");

// Class BFGCore.BFGWidget_Archive_InvasionReport
// 0x0058 (0x0548 - 0x04F0)
class UBFGWidget_Archive_InvasionReport final : public UBFGWidget_Archive_SubMenu
{
public:
	TMap<EBFGGameStatistic, struct FBFGGameStatisticData> M_aInvasionReportData;                             // 0x04F0(0x0050)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, Protected, NativeAccessSpecifierProtected)
	float                                         M_fMaxScrollSpeed;                                 // 0x0540(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_544[0x4];                                      // 0x0544(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	class UVerticalBox* GetVerticalBoxfromLayout();
	void Scroll(float _fAmount);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"BFGWidget_Archive_InvasionReport">();
	}
	static class UBFGWidget_Archive_InvasionReport* GetDefaultObj()
	{
		return GetDefaultObjImpl<UBFGWidget_Archive_InvasionReport>();
	}
};
static_assert(alignof(UBFGWidget_Archive_InvasionReport) == 0x000008, "Wrong alignment on UBFGWidget_Archive_InvasionReport");
static_assert(sizeof(UBFGWidget_Archive_InvasionReport) == 0x000548, "Wrong size on UBFGWidget_Archive_InvasionReport");
static_assert(offsetof(UBFGWidget_Archive_InvasionReport, M_aInvasionReportData) == 0x0004F0, "Member 'UBFGWidget_Archive_InvasionReport::M_aInvasionReportData' has a wrong offset!");
static_assert(offsetof(UBFGWidget_Archive_InvasionReport, M_fMaxScrollSpeed) == 0x000540, "Member 'UBFGWidget_Archive_InvasionReport::M_fMaxScrollSpeed' has a wrong offset!");

// Class BFGCore.BFGGameMode
// 0x00A0 (0x0518 - 0x0478)
class ABFGGameMode : public AGameModeBase
{
public:
	UMulticastDelegateProperty_                   M_OnRespawn;                                       // 0x0478(0x0018)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	TSoftClassPtr<class UClass>                   M_softCharacterClass;                              // 0x0490(0x0028)(Edit, DisableEditOnInstance, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TSoftClassPtr<class UClass>                   M_softUFOClass;                                    // 0x04B8(0x0028)(Edit, DisableEditOnInstance, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_4E0[0x8];                                      // 0x04E0(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	class ABFGLevelCheckpoint*                    M_pCheckpoint;                                     // 0x04E8(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class ABFGUFOLandingSite*                     M_pLandingSite;                                    // 0x04F0(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UClass*                                 M_pOverrideDefaultPawnClass;                       // 0x04F8(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_500[0x8];                                      // 0x0500(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<class AController*>                    M_apRespawnAtDefaultLandingSite;                   // 0x0508(0x0010)(ZeroConstructor, Transient, Protected, NativeAccessSpecifierProtected)

public:
	bool IsResetingActors() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"BFGGameMode">();
	}
	static class ABFGGameMode* GetDefaultObj()
	{
		return GetDefaultObjImpl<ABFGGameMode>();
	}
};
static_assert(alignof(ABFGGameMode) == 0x000008, "Wrong alignment on ABFGGameMode");
static_assert(sizeof(ABFGGameMode) == 0x000518, "Wrong size on ABFGGameMode");
static_assert(offsetof(ABFGGameMode, M_OnRespawn) == 0x000478, "Member 'ABFGGameMode::M_OnRespawn' has a wrong offset!");
static_assert(offsetof(ABFGGameMode, M_softCharacterClass) == 0x000490, "Member 'ABFGGameMode::M_softCharacterClass' has a wrong offset!");
static_assert(offsetof(ABFGGameMode, M_softUFOClass) == 0x0004B8, "Member 'ABFGGameMode::M_softUFOClass' has a wrong offset!");
static_assert(offsetof(ABFGGameMode, M_pCheckpoint) == 0x0004E8, "Member 'ABFGGameMode::M_pCheckpoint' has a wrong offset!");
static_assert(offsetof(ABFGGameMode, M_pLandingSite) == 0x0004F0, "Member 'ABFGGameMode::M_pLandingSite' has a wrong offset!");
static_assert(offsetof(ABFGGameMode, M_pOverrideDefaultPawnClass) == 0x0004F8, "Member 'ABFGGameMode::M_pOverrideDefaultPawnClass' has a wrong offset!");
static_assert(offsetof(ABFGGameMode, M_apRespawnAtDefaultLandingSite) == 0x000508, "Member 'ABFGGameMode::M_apRespawnAtDefaultLandingSite' has a wrong offset!");

// Class BFGCore.BFGWidget_ChunkInstall
// 0x0018 (0x0440 - 0x0428)
class UBFGWidget_ChunkInstall final : public UBFGWidget_GenericDialog
{
public:
	uint8                                         Pad_428[0x8];                                      // 0x0428(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         M_fPercentOfChunk;                                 // 0x0430(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_434[0x4];                                      // 0x0434(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	TSubclassOf<class UBFGInputAction_UI>         M_pCancel;                                         // 0x0438(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"BFGWidget_ChunkInstall">();
	}
	static class UBFGWidget_ChunkInstall* GetDefaultObj()
	{
		return GetDefaultObjImpl<UBFGWidget_ChunkInstall>();
	}
};
static_assert(alignof(UBFGWidget_ChunkInstall) == 0x000008, "Wrong alignment on UBFGWidget_ChunkInstall");
static_assert(sizeof(UBFGWidget_ChunkInstall) == 0x000440, "Wrong size on UBFGWidget_ChunkInstall");
static_assert(offsetof(UBFGWidget_ChunkInstall, M_fPercentOfChunk) == 0x000430, "Member 'UBFGWidget_ChunkInstall::M_fPercentOfChunk' has a wrong offset!");
static_assert(offsetof(UBFGWidget_ChunkInstall, M_pCancel) == 0x000438, "Member 'UBFGWidget_ChunkInstall::M_pCancel' has a wrong offset!");

// Class BFGCore.BFGGameplayEffectResponse_DisableSkate
// 0x0000 (0x0080 - 0x0080)
class UBFGGameplayEffectResponse_DisableSkate : public UBFGGameplayEffectResponse
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"BFGGameplayEffectResponse_DisableSkate">();
	}
	static class UBFGGameplayEffectResponse_DisableSkate* GetDefaultObj()
	{
		return GetDefaultObjImpl<UBFGGameplayEffectResponse_DisableSkate>();
	}
};
static_assert(alignof(UBFGGameplayEffectResponse_DisableSkate) == 0x000008, "Wrong alignment on UBFGGameplayEffectResponse_DisableSkate");
static_assert(sizeof(UBFGGameplayEffectResponse_DisableSkate) == 0x000080, "Wrong size on UBFGGameplayEffectResponse_DisableSkate");

// Class BFGCore.BFGGameplayEffectResponse_Disarm
// 0x0000 (0x0080 - 0x0080)
class UBFGGameplayEffectResponse_Disarm : public UBFGGameplayEffectResponse
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"BFGGameplayEffectResponse_Disarm">();
	}
	static class UBFGGameplayEffectResponse_Disarm* GetDefaultObj()
	{
		return GetDefaultObjImpl<UBFGGameplayEffectResponse_Disarm>();
	}
};
static_assert(alignof(UBFGGameplayEffectResponse_Disarm) == 0x000008, "Wrong alignment on UBFGGameplayEffectResponse_Disarm");
static_assert(sizeof(UBFGGameplayEffectResponse_Disarm) == 0x000080, "Wrong size on UBFGGameplayEffectResponse_Disarm");

// Class BFGCore.BFGGameplayEffectResponse_Electrocute
// 0x0000 (0x0080 - 0x0080)
class UBFGGameplayEffectResponse_Electrocute : public UBFGGameplayEffectResponse
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"BFGGameplayEffectResponse_Electrocute">();
	}
	static class UBFGGameplayEffectResponse_Electrocute* GetDefaultObj()
	{
		return GetDefaultObjImpl<UBFGGameplayEffectResponse_Electrocute>();
	}
};
static_assert(alignof(UBFGGameplayEffectResponse_Electrocute) == 0x000008, "Wrong alignment on UBFGGameplayEffectResponse_Electrocute");
static_assert(sizeof(UBFGGameplayEffectResponse_Electrocute) == 0x000080, "Wrong size on UBFGGameplayEffectResponse_Electrocute");

// Class BFGCore.BFGGameplayEffectResponse_MindBlock
// 0x0000 (0x0080 - 0x0080)
class UBFGGameplayEffectResponse_MindBlock : public UBFGGameplayEffectResponse
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"BFGGameplayEffectResponse_MindBlock">();
	}
	static class UBFGGameplayEffectResponse_MindBlock* GetDefaultObj()
	{
		return GetDefaultObjImpl<UBFGGameplayEffectResponse_MindBlock>();
	}
};
static_assert(alignof(UBFGGameplayEffectResponse_MindBlock) == 0x000008, "Wrong alignment on UBFGGameplayEffectResponse_MindBlock");
static_assert(sizeof(UBFGGameplayEffectResponse_MindBlock) == 0x000080, "Wrong size on UBFGGameplayEffectResponse_MindBlock");

// Class BFGCore.BFGGameplayEndEffects
// 0x0078 (0x00A0 - 0x0028)
class UBFGGameplayEndEffects final : public UObject
{
public:
	class UBFGGameInstance*                       M_pGameInstance;                                   // 0x0028(0x0008)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class ABFGGameState*                          M_pGameState;                                      // 0x0030(0x0008)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UBFGGameplayEndSession*                 M_pSession;                                        // 0x0038(0x0008)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_40[0x18];                                      // 0x0040(0x0018)(Fixing Size After Last Property [ Dumper-7 ])
	class ALevelSequenceActor*                    M_pActorSequenceEndFadeOut;                        // 0x0058(0x0008)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TScriptInterface<class IBFGVoiceoverQueueInterface> M_pVOQueue;                                        // 0x0060(0x0010)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, UObjectWrapper, NativeAccessSpecifierProtected)
	class UBFGWidget_GameplayEnd_BackgroundBlur*  M_pBlurWidget;                                     // 0x0070(0x0008)(ExportObject, ZeroConstructor, Transient, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UBFGActorComponent_HUDVisibilityStateManager* M_pHUDVisiblityMngr;                               // 0x0078(0x0008)(ExportObject, ZeroConstructor, Transient, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_80[0x20];                                      // 0x0080(0x0020)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void FinishedLevelSequence(class ALevelSequenceActor* _pActor, bool _bWasCutscene);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"BFGGameplayEndEffects">();
	}
	static class UBFGGameplayEndEffects* GetDefaultObj()
	{
		return GetDefaultObjImpl<UBFGGameplayEndEffects>();
	}
};
static_assert(alignof(UBFGGameplayEndEffects) == 0x000008, "Wrong alignment on UBFGGameplayEndEffects");
static_assert(sizeof(UBFGGameplayEndEffects) == 0x0000A0, "Wrong size on UBFGGameplayEndEffects");
static_assert(offsetof(UBFGGameplayEndEffects, M_pGameInstance) == 0x000028, "Member 'UBFGGameplayEndEffects::M_pGameInstance' has a wrong offset!");
static_assert(offsetof(UBFGGameplayEndEffects, M_pGameState) == 0x000030, "Member 'UBFGGameplayEndEffects::M_pGameState' has a wrong offset!");
static_assert(offsetof(UBFGGameplayEndEffects, M_pSession) == 0x000038, "Member 'UBFGGameplayEndEffects::M_pSession' has a wrong offset!");
static_assert(offsetof(UBFGGameplayEndEffects, M_pActorSequenceEndFadeOut) == 0x000058, "Member 'UBFGGameplayEndEffects::M_pActorSequenceEndFadeOut' has a wrong offset!");
static_assert(offsetof(UBFGGameplayEndEffects, M_pVOQueue) == 0x000060, "Member 'UBFGGameplayEndEffects::M_pVOQueue' has a wrong offset!");
static_assert(offsetof(UBFGGameplayEndEffects, M_pBlurWidget) == 0x000070, "Member 'UBFGGameplayEndEffects::M_pBlurWidget' has a wrong offset!");
static_assert(offsetof(UBFGGameplayEndEffects, M_pHUDVisiblityMngr) == 0x000078, "Member 'UBFGGameplayEndEffects::M_pHUDVisiblityMngr' has a wrong offset!");

// Class BFGCore.BFGDataSubscriber
// 0x0000 (0x0028 - 0x0028)
class IBFGDataSubscriber final : public IInterface
{
public:
	void OnDataChanged(class FName _tag, const TScriptInterface<class IBFGDataProvider>& PDataProvider);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"BFGDataSubscriber">();
	}
	static class IBFGDataSubscriber* GetDefaultObj()
	{
		return GetDefaultObjImpl<IBFGDataSubscriber>();
	}
};
static_assert(alignof(IBFGDataSubscriber) == 0x000008, "Wrong alignment on IBFGDataSubscriber");
static_assert(sizeof(IBFGDataSubscriber) == 0x000028, "Wrong size on IBFGDataSubscriber");

// Class BFGCore.BFGGameplayEndSession
// 0x00C8 (0x00F0 - 0x0028)
class UBFGGameplayEndSession final : public UObject
{
public:
	struct FBFGGameplayEndSettings                M_settings;                                        // 0x0028(0x0050)(Transient, NativeAccessSpecifierPublic)
	uint8                                         Pad_78[0x10];                                      // 0x0078(0x0010)(Fixing Size After Last Property [ Dumper-7 ])
	UMulticastDelegateProperty_                   M_onRemovedEffects;                                // 0x0088(0x0018)(ZeroConstructor, InstancedReference, NativeAccessSpecifierPublic)
	class UBFGGameInstance*                       M_pGameInstance;                                   // 0x00A0(0x0008)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UBFGGameFlowState_GameplayEndSequence*  M_pGFS;                                            // 0x00A8(0x0008)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UBFGTransitionManager*                  M_pTransitionManager;                              // 0x00B0(0x0008)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_B8[0x8];                                       // 0x00B8(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	class ULevelSequence*                         M_pLoadedLevelSequence;                            // 0x00C0(0x0008)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TSubclassOf<class UBFGWidget_GameplayEnd_BackgroundBlur> M_pLoadedBackgroundBlurWidgetClass;                // 0x00C8(0x0008)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TSubclassOf<class UBFGWidget_GameplayEnd_Background> M_pLoadedBackgroundWidgetClass;                    // 0x00D0(0x0008)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UBFGWidget_GameplayEnd_Background*      M_pBackgroundWidget;                               // 0x00D8(0x0008)(ExportObject, ZeroConstructor, Transient, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UBFGGameplayEndEffects*                 M_pEndEffects;                                     // 0x00E0(0x0008)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_E8[0x8];                                       // 0x00E8(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"BFGGameplayEndSession">();
	}
	static class UBFGGameplayEndSession* GetDefaultObj()
	{
		return GetDefaultObjImpl<UBFGGameplayEndSession>();
	}
};
static_assert(alignof(UBFGGameplayEndSession) == 0x000008, "Wrong alignment on UBFGGameplayEndSession");
static_assert(sizeof(UBFGGameplayEndSession) == 0x0000F0, "Wrong size on UBFGGameplayEndSession");
static_assert(offsetof(UBFGGameplayEndSession, M_settings) == 0x000028, "Member 'UBFGGameplayEndSession::M_settings' has a wrong offset!");
static_assert(offsetof(UBFGGameplayEndSession, M_onRemovedEffects) == 0x000088, "Member 'UBFGGameplayEndSession::M_onRemovedEffects' has a wrong offset!");
static_assert(offsetof(UBFGGameplayEndSession, M_pGameInstance) == 0x0000A0, "Member 'UBFGGameplayEndSession::M_pGameInstance' has a wrong offset!");
static_assert(offsetof(UBFGGameplayEndSession, M_pGFS) == 0x0000A8, "Member 'UBFGGameplayEndSession::M_pGFS' has a wrong offset!");
static_assert(offsetof(UBFGGameplayEndSession, M_pTransitionManager) == 0x0000B0, "Member 'UBFGGameplayEndSession::M_pTransitionManager' has a wrong offset!");
static_assert(offsetof(UBFGGameplayEndSession, M_pLoadedLevelSequence) == 0x0000C0, "Member 'UBFGGameplayEndSession::M_pLoadedLevelSequence' has a wrong offset!");
static_assert(offsetof(UBFGGameplayEndSession, M_pLoadedBackgroundBlurWidgetClass) == 0x0000C8, "Member 'UBFGGameplayEndSession::M_pLoadedBackgroundBlurWidgetClass' has a wrong offset!");
static_assert(offsetof(UBFGGameplayEndSession, M_pLoadedBackgroundWidgetClass) == 0x0000D0, "Member 'UBFGGameplayEndSession::M_pLoadedBackgroundWidgetClass' has a wrong offset!");
static_assert(offsetof(UBFGGameplayEndSession, M_pBackgroundWidget) == 0x0000D8, "Member 'UBFGGameplayEndSession::M_pBackgroundWidget' has a wrong offset!");
static_assert(offsetof(UBFGGameplayEndSession, M_pEndEffects) == 0x0000E0, "Member 'UBFGGameplayEndSession::M_pEndEffects' has a wrong offset!");

// Class BFGCore.BFGGameplayEndSystem
// 0x0010 (0x0038 - 0x0028)
class UBFGGameplayEndSystem final : public UObject
{
public:
	class UBFGGameInstance*                       M_pGameInstance;                                   // 0x0028(0x0008)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UBFGGameplayEndSession*                 M_pOpenSession;                                    // 0x0030(0x0008)(ExportObject, ZeroConstructor, Transient, InstancedReference, IsPlainOldData, NoDestructor, PersistentInstance, HasGetValueTypeHash, NativeAccessSpecifierPrivate)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"BFGGameplayEndSystem">();
	}
	static class UBFGGameplayEndSystem* GetDefaultObj()
	{
		return GetDefaultObjImpl<UBFGGameplayEndSystem>();
	}
};
static_assert(alignof(UBFGGameplayEndSystem) == 0x000008, "Wrong alignment on UBFGGameplayEndSystem");
static_assert(sizeof(UBFGGameplayEndSystem) == 0x000038, "Wrong size on UBFGGameplayEndSystem");
static_assert(offsetof(UBFGGameplayEndSystem, M_pGameInstance) == 0x000028, "Member 'UBFGGameplayEndSystem::M_pGameInstance' has a wrong offset!");
static_assert(offsetof(UBFGGameplayEndSystem, M_pOpenSession) == 0x000030, "Member 'UBFGGameplayEndSystem::M_pOpenSession' has a wrong offset!");

// Class BFGCore.BFGGameplayTagUtils
// 0x0000 (0x0028 - 0x0028)
class UBFGGameplayTagUtils final : public UBlueprintFunctionLibrary
{
public:
	static bool AddActorGameplayTags(class AActor* _pActor, bool _bPersist, bool _bSpawn, bool _bDestroy, bool _bMinimal);
	static void AppendGameplayEffectTagsTo(class AActor* _pObject, const struct FGameplayTagContainer& _tags);
	static void AppendGameplayTagsTo(class UObject* _pObject, const struct FGameplayTagContainer& _tags);
	static void AppendGameplayTagTo(class UObject* _pObject, const struct FGameplayTag& _tag);
	static struct FGameplayTagQuery CreateMatchAllTagsQuery(const struct FGameplayTagContainer& _tags);
	static bool DoesActorHaveMatchingTag(class AActor* _pActor, const struct FGameplayTag& _tag);
	static bool DoesActorMatchQuery(class AActor* _pActor, const struct FGameplayTagQuery& _query);
	static bool DoesObjectHaveMatchingTag(class UObject* _pObject, const struct FGameplayTag& _tag);
	static bool DoesObjectHaveMatchingTags(class UObject* _pObject, const struct FGameplayTagContainer& _tags);
	static bool DoesObjectMatchQuery(class UObject* _pObject, const struct FGameplayTagQuery& _query);
	static bool DoesTagsMatchQuery(const struct FGameplayTagContainer& _tags, const struct FGameplayTagQuery& _query);
	static struct FGameplayTagContainer GetGameplayEffectTagsFrom(const class UObject* _pObject);
	static struct FGameplayTagContainer GetGameplayTagsFrom(const class UObject* _pObject);
	static struct FGameplayTagQuery InverseGameplayTagQuery(const struct FGameplayTagQuery& _query);
	static bool IsGameplayTagQueryEmpty(const struct FGameplayTagQuery& _query);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"BFGGameplayTagUtils">();
	}
	static class UBFGGameplayTagUtils* GetDefaultObj()
	{
		return GetDefaultObjImpl<UBFGGameplayTagUtils>();
	}
};
static_assert(alignof(UBFGGameplayTagUtils) == 0x000008, "Wrong alignment on UBFGGameplayTagUtils");
static_assert(sizeof(UBFGGameplayTagUtils) == 0x000028, "Wrong size on UBFGGameplayTagUtils");

// Class BFGCore.BFGGameSession
// 0x00A0 (0x00C8 - 0x0028)
class UBFGGameSession final : public UObject
{
public:
	class UBFGGameInstance*                       M_pGameInstance;                                   // 0x0028(0x0008)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UBFGVariableMessageServer*              M_pVariableMessageServer;                          // 0x0030(0x0008)(ExportObject, ZeroConstructor, Transient, InstancedReference, IsPlainOldData, NoDestructor, Protected, PersistentInstance, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_38[0x60];                                      // 0x0038(0x0060)(Fixing Size After Last Property [ Dumper-7 ])
	struct FGameplayTagContainer                  M_aProfileGameplayTags;                            // 0x0098(0x0020)(Transient, Protected, NativeAccessSpecifierProtected)
	TArray<TScriptInterface<class IBFGAIAlertEventConstraint>> M_aAIAlertEventConstraintsActive;                  // 0x00B8(0x0010)(ZeroConstructor, Transient, Protected, UObjectWrapper, NativeAccessSpecifierProtected)

public:
	void OnWorldLoaded(class UBFGGameInstance* _pGameInstance, class UWorld* _pWorld);
	void SetShowMM01BackStoryInMothersthip(bool _bShouldShow);
	void SetShowOutroInMothersthip(bool _bShouldShow);
	void SetTransferToPoxLab(bool _bTransfer);

	bool ShouldShowMM01BackStoryInMothersthip() const;
	bool ShouldShowOutroInMothersthip() const;
	bool ShouldTransferToPoxLab() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"BFGGameSession">();
	}
	static class UBFGGameSession* GetDefaultObj()
	{
		return GetDefaultObjImpl<UBFGGameSession>();
	}
};
static_assert(alignof(UBFGGameSession) == 0x000008, "Wrong alignment on UBFGGameSession");
static_assert(sizeof(UBFGGameSession) == 0x0000C8, "Wrong size on UBFGGameSession");
static_assert(offsetof(UBFGGameSession, M_pGameInstance) == 0x000028, "Member 'UBFGGameSession::M_pGameInstance' has a wrong offset!");
static_assert(offsetof(UBFGGameSession, M_pVariableMessageServer) == 0x000030, "Member 'UBFGGameSession::M_pVariableMessageServer' has a wrong offset!");
static_assert(offsetof(UBFGGameSession, M_aProfileGameplayTags) == 0x000098, "Member 'UBFGGameSession::M_aProfileGameplayTags' has a wrong offset!");
static_assert(offsetof(UBFGGameSession, M_aAIAlertEventConstraintsActive) == 0x0000B8, "Member 'UBFGGameSession::M_aAIAlertEventConstraintsActive' has a wrong offset!");

// Class BFGCore.BFGGameSettings
// 0x0498 (0x04D0 - 0x0038)
class UBFGGameSettings final : public UDeveloperSettings
{
public:
	TSoftClassPtr<class UClass>                   M_pLoadingScreen;                                  // 0x0038(0x0028)(Edit, BlueprintVisible, BlueprintReadOnly, Config, DisableEditOnInstance, GlobalConfig, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TSoftClassPtr<class UClass>                   M_pSaveThrobberScreen;                             // 0x0060(0x0028)(Edit, BlueprintVisible, BlueprintReadOnly, Config, DisableEditOnInstance, GlobalConfig, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TSoftClassPtr<class UClass>                   M_pWidget_Cutscene;                                // 0x0088(0x0028)(Edit, BlueprintVisible, BlueprintReadOnly, Config, DisableEditOnInstance, GlobalConfig, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TSoftObjectPtr<class UDataTable>              M_pTableLocalizedGameOptionNames;                  // 0x00B0(0x0028)(Edit, BlueprintVisible, BlueprintReadOnly, Config, DisableEditOnInstance, GlobalConfig, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         M_iSaveGameVersion;                                // 0x00D8(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Config, DisableEditOnInstance, GlobalConfig, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FGameplayTag                           M_tagSaveSystemPersist;                            // 0x00DC(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, Config, DisableEditOnInstance, GlobalConfig, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FGameplayTag                           M_tagSaveSystemSpawn;                              // 0x00E4(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, Config, DisableEditOnInstance, GlobalConfig, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FGameplayTag                           M_tagSaveSystemDestroy;                            // 0x00EC(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, Config, DisableEditOnInstance, GlobalConfig, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FGameplayTag                           M_tagSaveSystemMinimal;                            // 0x00F4(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, Config, DisableEditOnInstance, GlobalConfig, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_FC[0x4];                                       // 0x00FC(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	struct FBFGGameFlowStateLayout                M_gameFlowStateLayout;                             // 0x0100(0x02D0)(Edit, BlueprintVisible, BlueprintReadOnly, Config, DisableEditOnInstance, GlobalConfig, NativeAccessSpecifierPublic)
	struct FBFGMissionLayout                      M_missionLayout;                                   // 0x03D0(0x0038)(Edit, BlueprintVisible, BlueprintReadOnly, Config, DisableEditOnInstance, GlobalConfig, NativeAccessSpecifierPublic)
	TSoftClassPtr<class UClass>                   M_softGameplayEndBackground;                       // 0x0408(0x0028)(Edit, BlueprintVisible, BlueprintReadOnly, Config, DisableEditOnInstance, GlobalConfig, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FBFGGameplayEndSettings                M_gameplayEndCompleted;                            // 0x0430(0x0050)(Edit, BlueprintVisible, BlueprintReadOnly, Config, DisableEditOnInstance, GlobalConfig, NativeAccessSpecifierPublic)
	struct FBFGGameplayEndSettings                M_gameplayEndFailure;                              // 0x0480(0x0050)(Edit, BlueprintVisible, BlueprintReadOnly, Config, DisableEditOnInstance, GlobalConfig, NativeAccessSpecifierPublic)

public:
	static class UBFGGameSettings* GetSettings();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"BFGGameSettings">();
	}
	static class UBFGGameSettings* GetDefaultObj()
	{
		return GetDefaultObjImpl<UBFGGameSettings>();
	}
};
static_assert(alignof(UBFGGameSettings) == 0x000008, "Wrong alignment on UBFGGameSettings");
static_assert(sizeof(UBFGGameSettings) == 0x0004D0, "Wrong size on UBFGGameSettings");
static_assert(offsetof(UBFGGameSettings, M_pLoadingScreen) == 0x000038, "Member 'UBFGGameSettings::M_pLoadingScreen' has a wrong offset!");
static_assert(offsetof(UBFGGameSettings, M_pSaveThrobberScreen) == 0x000060, "Member 'UBFGGameSettings::M_pSaveThrobberScreen' has a wrong offset!");
static_assert(offsetof(UBFGGameSettings, M_pWidget_Cutscene) == 0x000088, "Member 'UBFGGameSettings::M_pWidget_Cutscene' has a wrong offset!");
static_assert(offsetof(UBFGGameSettings, M_pTableLocalizedGameOptionNames) == 0x0000B0, "Member 'UBFGGameSettings::M_pTableLocalizedGameOptionNames' has a wrong offset!");
static_assert(offsetof(UBFGGameSettings, M_iSaveGameVersion) == 0x0000D8, "Member 'UBFGGameSettings::M_iSaveGameVersion' has a wrong offset!");
static_assert(offsetof(UBFGGameSettings, M_tagSaveSystemPersist) == 0x0000DC, "Member 'UBFGGameSettings::M_tagSaveSystemPersist' has a wrong offset!");
static_assert(offsetof(UBFGGameSettings, M_tagSaveSystemSpawn) == 0x0000E4, "Member 'UBFGGameSettings::M_tagSaveSystemSpawn' has a wrong offset!");
static_assert(offsetof(UBFGGameSettings, M_tagSaveSystemDestroy) == 0x0000EC, "Member 'UBFGGameSettings::M_tagSaveSystemDestroy' has a wrong offset!");
static_assert(offsetof(UBFGGameSettings, M_tagSaveSystemMinimal) == 0x0000F4, "Member 'UBFGGameSettings::M_tagSaveSystemMinimal' has a wrong offset!");
static_assert(offsetof(UBFGGameSettings, M_gameFlowStateLayout) == 0x000100, "Member 'UBFGGameSettings::M_gameFlowStateLayout' has a wrong offset!");
static_assert(offsetof(UBFGGameSettings, M_missionLayout) == 0x0003D0, "Member 'UBFGGameSettings::M_missionLayout' has a wrong offset!");
static_assert(offsetof(UBFGGameSettings, M_softGameplayEndBackground) == 0x000408, "Member 'UBFGGameSettings::M_softGameplayEndBackground' has a wrong offset!");
static_assert(offsetof(UBFGGameSettings, M_gameplayEndCompleted) == 0x000430, "Member 'UBFGGameSettings::M_gameplayEndCompleted' has a wrong offset!");
static_assert(offsetof(UBFGGameSettings, M_gameplayEndFailure) == 0x000480, "Member 'UBFGGameSettings::M_gameplayEndFailure' has a wrong offset!");

// Class BFGCore.BFGGeometryCacheAnimation
// 0x0020 (0x03F8 - 0x03D8)
class ABFGGeometryCacheAnimation final : public AActor
{
public:
	class UGeometryCacheComponent*                M_pGeometryCacheComp;                              // 0x03D8(0x0008)(Edit, BlueprintVisible, ExportObject, ZeroConstructor, DisableEditOnInstance, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         M_fWakeUpDistance;                                 // 0x03E0(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         M_fCheckFrequency;                                 // 0x03E4(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class APlayerController*                      M_pPlayerController;                               // 0x03E8(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_3F0[0x8];                                      // 0x03F0(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"BFGGeometryCacheAnimation">();
	}
	static class ABFGGeometryCacheAnimation* GetDefaultObj()
	{
		return GetDefaultObjImpl<ABFGGeometryCacheAnimation>();
	}
};
static_assert(alignof(ABFGGeometryCacheAnimation) == 0x000008, "Wrong alignment on ABFGGeometryCacheAnimation");
static_assert(sizeof(ABFGGeometryCacheAnimation) == 0x0003F8, "Wrong size on ABFGGeometryCacheAnimation");
static_assert(offsetof(ABFGGeometryCacheAnimation, M_pGeometryCacheComp) == 0x0003D8, "Member 'ABFGGeometryCacheAnimation::M_pGeometryCacheComp' has a wrong offset!");
static_assert(offsetof(ABFGGeometryCacheAnimation, M_fWakeUpDistance) == 0x0003E0, "Member 'ABFGGeometryCacheAnimation::M_fWakeUpDistance' has a wrong offset!");
static_assert(offsetof(ABFGGeometryCacheAnimation, M_fCheckFrequency) == 0x0003E4, "Member 'ABFGGeometryCacheAnimation::M_fCheckFrequency' has a wrong offset!");
static_assert(offsetof(ABFGGeometryCacheAnimation, M_pPlayerController) == 0x0003E8, "Member 'ABFGGeometryCacheAnimation::M_pPlayerController' has a wrong offset!");

// Class BFGCore.BFGGeometryUtils
// 0x0000 (0x0028 - 0x0028)
class UBFGGeometryUtils final : public UBlueprintFunctionLibrary
{
public:
	static float FindDistanceAlongSplineClosestToLocation(const class USplineComponent* Spline, const struct FVector& Location);
	static bool IsInsidePolygon(const TArray<struct FSplinePoint>& _aPolygonPoints, const struct FVector& _vPoint, float _fZMin, float _fZMax);
	static bool IsInsidePolygon2D(const TArray<struct FVector2D>& _aPolygonPoints, const struct FVector2D& _vPoint);
	static TArray<int32> Triangulate_SplinePoints(const TArray<struct FSplinePoint>& _aPolygonPoints);
	static TArray<int32> Triangulate_Vector2D(const TArray<struct FVector2D>& _aPolygonPoints);
	static TArray<int32> Triangulate_Vector3D(const TArray<struct FVector>& _aPolygonPoints);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"BFGGeometryUtils">();
	}
	static class UBFGGeometryUtils* GetDefaultObj()
	{
		return GetDefaultObjImpl<UBFGGeometryUtils>();
	}
};
static_assert(alignof(UBFGGeometryUtils) == 0x000008, "Wrong alignment on UBFGGeometryUtils");
static_assert(sizeof(UBFGGeometryUtils) == 0x000028, "Wrong size on UBFGGeometryUtils");

// Class BFGCore.BFGHighlightableSceneObjectManager
// 0x0108 (0x0138 - 0x0030)
class UBFGHighlightableSceneObjectManager final : public UBFGGameSystem
{
public:
	uint8                                         Pad_30[0x40];                                      // 0x0030(0x0040)(Fixing Size After Last Property [ Dumper-7 ])
	class UBFGActorComponent_OpportunityComponent* M_pFocusedOpportunityWidget_Mental;                // 0x0070(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UBFGActorComponent_OpportunityComponent* M_pFocusedOpportunityWidget_Weapon;                // 0x0078(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class ABFGGameState*                          M_pGameState;                                      // 0x0080(0x0008)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_88[0x8];                                       // 0x0088(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<struct FBFGHighlightableRuntimeInfo>   M_aHighlightableRuntimeInfo;                       // 0x0090(0x0010)(ZeroConstructor, ContainsInstancedReference, Protected, NativeAccessSpecifierProtected)
	class UBFGWidget_HUD_SceneObjectHighlighter*  M_pHighlighterHUD;                                 // 0x00A0(0x0008)(ExportObject, ZeroConstructor, Transient, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         M_fSmoothOffscreenMargin;                          // 0x00A8(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         M_fSmoothOffscreenInwardOffset;                    // 0x00AC(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         M_fSmoothOffscreenRatioRectangleEllipse;           // 0x00B0(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	struct FVector2D                              M_vSmoothOffscreenEllipseScale;                    // 0x00B4(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_BC[0x4];                                       // 0x00BC(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	struct FTickHighlightableSceneObjectFunction  M_TickFunction;                                    // 0x00C0(0x0078)(ContainsInstancedReference, Protected, NativeAccessSpecifierProtected)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"BFGHighlightableSceneObjectManager">();
	}
	static class UBFGHighlightableSceneObjectManager* GetDefaultObj()
	{
		return GetDefaultObjImpl<UBFGHighlightableSceneObjectManager>();
	}
};
static_assert(alignof(UBFGHighlightableSceneObjectManager) == 0x000008, "Wrong alignment on UBFGHighlightableSceneObjectManager");
static_assert(sizeof(UBFGHighlightableSceneObjectManager) == 0x000138, "Wrong size on UBFGHighlightableSceneObjectManager");
static_assert(offsetof(UBFGHighlightableSceneObjectManager, M_pFocusedOpportunityWidget_Mental) == 0x000070, "Member 'UBFGHighlightableSceneObjectManager::M_pFocusedOpportunityWidget_Mental' has a wrong offset!");
static_assert(offsetof(UBFGHighlightableSceneObjectManager, M_pFocusedOpportunityWidget_Weapon) == 0x000078, "Member 'UBFGHighlightableSceneObjectManager::M_pFocusedOpportunityWidget_Weapon' has a wrong offset!");
static_assert(offsetof(UBFGHighlightableSceneObjectManager, M_pGameState) == 0x000080, "Member 'UBFGHighlightableSceneObjectManager::M_pGameState' has a wrong offset!");
static_assert(offsetof(UBFGHighlightableSceneObjectManager, M_aHighlightableRuntimeInfo) == 0x000090, "Member 'UBFGHighlightableSceneObjectManager::M_aHighlightableRuntimeInfo' has a wrong offset!");
static_assert(offsetof(UBFGHighlightableSceneObjectManager, M_pHighlighterHUD) == 0x0000A0, "Member 'UBFGHighlightableSceneObjectManager::M_pHighlighterHUD' has a wrong offset!");
static_assert(offsetof(UBFGHighlightableSceneObjectManager, M_fSmoothOffscreenMargin) == 0x0000A8, "Member 'UBFGHighlightableSceneObjectManager::M_fSmoothOffscreenMargin' has a wrong offset!");
static_assert(offsetof(UBFGHighlightableSceneObjectManager, M_fSmoothOffscreenInwardOffset) == 0x0000AC, "Member 'UBFGHighlightableSceneObjectManager::M_fSmoothOffscreenInwardOffset' has a wrong offset!");
static_assert(offsetof(UBFGHighlightableSceneObjectManager, M_fSmoothOffscreenRatioRectangleEllipse) == 0x0000B0, "Member 'UBFGHighlightableSceneObjectManager::M_fSmoothOffscreenRatioRectangleEllipse' has a wrong offset!");
static_assert(offsetof(UBFGHighlightableSceneObjectManager, M_vSmoothOffscreenEllipseScale) == 0x0000B4, "Member 'UBFGHighlightableSceneObjectManager::M_vSmoothOffscreenEllipseScale' has a wrong offset!");
static_assert(offsetof(UBFGHighlightableSceneObjectManager, M_TickFunction) == 0x0000C0, "Member 'UBFGHighlightableSceneObjectManager::M_TickFunction' has a wrong offset!");

// Class BFGCore.BFGHUD
// 0x0050 (0x0518 - 0x04C8)
class ABFGHUD : public AHUD
{
public:
	TArray<TSubclassOf<class UUserWidget>>        M_aInterfaceAssets;                                // 0x04C8(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, UObjectWrapper, NativeAccessSpecifierPublic)
	TArray<class UUserWidget*>                    M_apHUDInstances;                                  // 0x04D8(0x0010)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, ContainsInstancedReference, NativeAccessSpecifierPublic)
	UMulticastDelegateProperty_                   M_onVisibilityChanged;                             // 0x04E8(0x0018)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	bool                                          M_bWidgetsHidden;                                  // 0x0500(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_501[0x1];                                      // 0x0501(0x0001)(Fixing Size After Last Property [ Dumper-7 ])
	bool                                          M_bAdvanceUI;                                      // 0x0502(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_503[0x15];                                     // 0x0503(0x0015)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"BFGHUD">();
	}
	static class ABFGHUD* GetDefaultObj()
	{
		return GetDefaultObjImpl<ABFGHUD>();
	}
};
static_assert(alignof(ABFGHUD) == 0x000008, "Wrong alignment on ABFGHUD");
static_assert(sizeof(ABFGHUD) == 0x000518, "Wrong size on ABFGHUD");
static_assert(offsetof(ABFGHUD, M_aInterfaceAssets) == 0x0004C8, "Member 'ABFGHUD::M_aInterfaceAssets' has a wrong offset!");
static_assert(offsetof(ABFGHUD, M_apHUDInstances) == 0x0004D8, "Member 'ABFGHUD::M_apHUDInstances' has a wrong offset!");
static_assert(offsetof(ABFGHUD, M_onVisibilityChanged) == 0x0004E8, "Member 'ABFGHUD::M_onVisibilityChanged' has a wrong offset!");
static_assert(offsetof(ABFGHUD, M_bWidgetsHidden) == 0x000500, "Member 'ABFGHUD::M_bWidgetsHidden' has a wrong offset!");
static_assert(offsetof(ABFGHUD, M_bAdvanceUI) == 0x000502, "Member 'ABFGHUD::M_bAdvanceUI' has a wrong offset!");

// Class BFGCore.BFGHUDConstants
// 0x0000 (0x0028 - 0x0028)
class UBFGHUDConstants final : public UObject
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"BFGHUDConstants">();
	}
	static class UBFGHUDConstants* GetDefaultObj()
	{
		return GetDefaultObjImpl<UBFGHUDConstants>();
	}
};
static_assert(alignof(UBFGHUDConstants) == 0x000008, "Wrong alignment on UBFGHUDConstants");
static_assert(sizeof(UBFGHUDConstants) == 0x000028, "Wrong size on UBFGHUDConstants");

// Class BFGCore.BFGInputAction_CameraHandleToggleModeOverride
// 0x0008 (0x0038 - 0x0030)
class UBFGInputAction_CameraHandleToggleModeOverride final : public UBFGInputAction
{
public:
	int32                                         M_iMode;                                           // 0x0030(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_34[0x4];                                       // 0x0034(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"BFGInputAction_CameraHandleToggleModeOverride">();
	}
	static class UBFGInputAction_CameraHandleToggleModeOverride* GetDefaultObj()
	{
		return GetDefaultObjImpl<UBFGInputAction_CameraHandleToggleModeOverride>();
	}
};
static_assert(alignof(UBFGInputAction_CameraHandleToggleModeOverride) == 0x000008, "Wrong alignment on UBFGInputAction_CameraHandleToggleModeOverride");
static_assert(sizeof(UBFGInputAction_CameraHandleToggleModeOverride) == 0x000038, "Wrong size on UBFGInputAction_CameraHandleToggleModeOverride");
static_assert(offsetof(UBFGInputAction_CameraHandleToggleModeOverride, M_iMode) == 0x000030, "Member 'UBFGInputAction_CameraHandleToggleModeOverride::M_iMode' has a wrong offset!");

// Class BFGCore.BFGInputAction_CancelMentalAbilities
// 0x0000 (0x0030 - 0x0030)
class UBFGInputAction_CancelMentalAbilities final : public UBFGInputAction
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"BFGInputAction_CancelMentalAbilities">();
	}
	static class UBFGInputAction_CancelMentalAbilities* GetDefaultObj()
	{
		return GetDefaultObjImpl<UBFGInputAction_CancelMentalAbilities>();
	}
};
static_assert(alignof(UBFGInputAction_CancelMentalAbilities) == 0x000008, "Wrong alignment on UBFGInputAction_CancelMentalAbilities");
static_assert(sizeof(UBFGInputAction_CancelMentalAbilities) == 0x000030, "Wrong size on UBFGInputAction_CancelMentalAbilities");

// Class BFGCore.BFGInputAction_CharacterJump
// 0x0000 (0x0030 - 0x0030)
class UBFGInputAction_CharacterJump final : public UBFGInputAction
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"BFGInputAction_CharacterJump">();
	}
	static class UBFGInputAction_CharacterJump* GetDefaultObj()
	{
		return GetDefaultObjImpl<UBFGInputAction_CharacterJump>();
	}
};
static_assert(alignof(UBFGInputAction_CharacterJump) == 0x000008, "Wrong alignment on UBFGInputAction_CharacterJump");
static_assert(sizeof(UBFGInputAction_CharacterJump) == 0x000030, "Wrong size on UBFGInputAction_CharacterJump");

// Class BFGCore.BFGInputAction_EquipmentSelectAbductoBeam
// 0x0000 (0x0038 - 0x0038)
class UBFGInputAction_EquipmentSelectAbductoBeam final : public UBFGInputAction_EquipmentSelect
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"BFGInputAction_EquipmentSelectAbductoBeam">();
	}
	static class UBFGInputAction_EquipmentSelectAbductoBeam* GetDefaultObj()
	{
		return GetDefaultObjImpl<UBFGInputAction_EquipmentSelectAbductoBeam>();
	}
};
static_assert(alignof(UBFGInputAction_EquipmentSelectAbductoBeam) == 0x000008, "Wrong alignment on UBFGInputAction_EquipmentSelectAbductoBeam");
static_assert(sizeof(UBFGInputAction_EquipmentSelectAbductoBeam) == 0x000038, "Wrong size on UBFGInputAction_EquipmentSelectAbductoBeam");

// Class BFGCore.BFGInputAction_EquipmentSelectAnalProbe
// 0x0000 (0x0038 - 0x0038)
class UBFGInputAction_EquipmentSelectAnalProbe final : public UBFGInputAction_EquipmentSelect
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"BFGInputAction_EquipmentSelectAnalProbe">();
	}
	static class UBFGInputAction_EquipmentSelectAnalProbe* GetDefaultObj()
	{
		return GetDefaultObjImpl<UBFGInputAction_EquipmentSelectAnalProbe>();
	}
};
static_assert(alignof(UBFGInputAction_EquipmentSelectAnalProbe) == 0x000008, "Wrong alignment on UBFGInputAction_EquipmentSelectAnalProbe");
static_assert(sizeof(UBFGInputAction_EquipmentSelectAnalProbe) == 0x000038, "Wrong size on UBFGInputAction_EquipmentSelectAnalProbe");

// Class BFGCore.BFGInputAction_EquipmentSelectDisintegratorRay
// 0x0000 (0x0038 - 0x0038)
class UBFGInputAction_EquipmentSelectDisintegratorRay final : public UBFGInputAction_EquipmentSelect
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"BFGInputAction_EquipmentSelectDisintegratorRay">();
	}
	static class UBFGInputAction_EquipmentSelectDisintegratorRay* GetDefaultObj()
	{
		return GetDefaultObjImpl<UBFGInputAction_EquipmentSelectDisintegratorRay>();
	}
};
static_assert(alignof(UBFGInputAction_EquipmentSelectDisintegratorRay) == 0x000008, "Wrong alignment on UBFGInputAction_EquipmentSelectDisintegratorRay");
static_assert(sizeof(UBFGInputAction_EquipmentSelectDisintegratorRay) == 0x000038, "Wrong size on UBFGInputAction_EquipmentSelectDisintegratorRay");

// Class BFGCore.BFGInputAction_EquipmentSelectIonDetonator
// 0x0000 (0x0038 - 0x0038)
class UBFGInputAction_EquipmentSelectIonDetonator final : public UBFGInputAction_EquipmentSelect
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"BFGInputAction_EquipmentSelectIonDetonator">();
	}
	static class UBFGInputAction_EquipmentSelectIonDetonator* GetDefaultObj()
	{
		return GetDefaultObjImpl<UBFGInputAction_EquipmentSelectIonDetonator>();
	}
};
static_assert(alignof(UBFGInputAction_EquipmentSelectIonDetonator) == 0x000008, "Wrong alignment on UBFGInputAction_EquipmentSelectIonDetonator");
static_assert(sizeof(UBFGInputAction_EquipmentSelectIonDetonator) == 0x000038, "Wrong size on UBFGInputAction_EquipmentSelectIonDetonator");

// Class BFGCore.BFGInputAction_EquipmentSelectQuantumDeconstructor
// 0x0000 (0x0038 - 0x0038)
class UBFGInputAction_EquipmentSelectQuantumDeconstructor final : public UBFGInputAction_EquipmentSelect
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"BFGInputAction_EquipmentSelectQuantumDeconstructor">();
	}
	static class UBFGInputAction_EquipmentSelectQuantumDeconstructor* GetDefaultObj()
	{
		return GetDefaultObjImpl<UBFGInputAction_EquipmentSelectQuantumDeconstructor>();
	}
};
static_assert(alignof(UBFGInputAction_EquipmentSelectQuantumDeconstructor) == 0x000008, "Wrong alignment on UBFGInputAction_EquipmentSelectQuantumDeconstructor");
static_assert(sizeof(UBFGInputAction_EquipmentSelectQuantumDeconstructor) == 0x000038, "Wrong size on UBFGInputAction_EquipmentSelectQuantumDeconstructor");

// Class BFGCore.BFGInputAction_EquipmentSelectZapOMatic
// 0x0000 (0x0038 - 0x0038)
class UBFGInputAction_EquipmentSelectZapOMatic final : public UBFGInputAction_EquipmentSelect
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"BFGInputAction_EquipmentSelectZapOMatic">();
	}
	static class UBFGInputAction_EquipmentSelectZapOMatic* GetDefaultObj()
	{
		return GetDefaultObjImpl<UBFGInputAction_EquipmentSelectZapOMatic>();
	}
};
static_assert(alignof(UBFGInputAction_EquipmentSelectZapOMatic) == 0x000008, "Wrong alignment on UBFGInputAction_EquipmentSelectZapOMatic");
static_assert(sizeof(UBFGInputAction_EquipmentSelectZapOMatic) == 0x000038, "Wrong size on UBFGInputAction_EquipmentSelectZapOMatic");

// Class BFGCore.BFGInputAction_FocusModeEnable
// 0x0000 (0x0030 - 0x0030)
class UBFGInputAction_FocusModeEnable final : public UBFGInputAction
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"BFGInputAction_FocusModeEnable">();
	}
	static class UBFGInputAction_FocusModeEnable* GetDefaultObj()
	{
		return GetDefaultObjImpl<UBFGInputAction_FocusModeEnable>();
	}
};
static_assert(alignof(UBFGInputAction_FocusModeEnable) == 0x000008, "Wrong alignment on UBFGInputAction_FocusModeEnable");
static_assert(sizeof(UBFGInputAction_FocusModeEnable) == 0x000030, "Wrong size on UBFGInputAction_FocusModeEnable");

// Class BFGCore.BFGInputAction_FocusModeToggleAutoLock
// 0x0000 (0x0030 - 0x0030)
class UBFGInputAction_FocusModeToggleAutoLock final : public UBFGInputAction
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"BFGInputAction_FocusModeToggleAutoLock">();
	}
	static class UBFGInputAction_FocusModeToggleAutoLock* GetDefaultObj()
	{
		return GetDefaultObjImpl<UBFGInputAction_FocusModeToggleAutoLock>();
	}
};
static_assert(alignof(UBFGInputAction_FocusModeToggleAutoLock) == 0x000008, "Wrong alignment on UBFGInputAction_FocusModeToggleAutoLock");
static_assert(sizeof(UBFGInputAction_FocusModeToggleAutoLock) == 0x000030, "Wrong size on UBFGInputAction_FocusModeToggleAutoLock");

// Class BFGCore.BFGWeaponHolderInterface
// 0x0000 (0x0028 - 0x0028)
class IBFGWeaponHolderInterface final : public IInterface
{
public:
	bool CanUseWeapon(class ABFGWeapon* _pWeapon);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"BFGWeaponHolderInterface">();
	}
	static class IBFGWeaponHolderInterface* GetDefaultObj()
	{
		return GetDefaultObjImpl<IBFGWeaponHolderInterface>();
	}
};
static_assert(alignof(IBFGWeaponHolderInterface) == 0x000008, "Wrong alignment on IBFGWeaponHolderInterface");
static_assert(sizeof(IBFGWeaponHolderInterface) == 0x000028, "Wrong size on IBFGWeaponHolderInterface");

// Class BFGCore.BFGInputAction_IonDetonate
// 0x0000 (0x0030 - 0x0030)
class UBFGInputAction_IonDetonate final : public UBFGInputAction
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"BFGInputAction_IonDetonate">();
	}
	static class UBFGInputAction_IonDetonate* GetDefaultObj()
	{
		return GetDefaultObjImpl<UBFGInputAction_IonDetonate>();
	}
};
static_assert(alignof(UBFGInputAction_IonDetonate) == 0x000008, "Wrong alignment on UBFGInputAction_IonDetonate");
static_assert(sizeof(UBFGInputAction_IonDetonate) == 0x000030, "Wrong size on UBFGInputAction_IonDetonate");

// Class BFGCore.BFGInputAction_JetpackPilotThrottle
// 0x0008 (0x0038 - 0x0030)
class UBFGInputAction_JetpackPilotThrottle : public UBFGInputAction
{
public:
	uint8                                         Pad_30[0x8];                                       // 0x0030(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"BFGInputAction_JetpackPilotThrottle">();
	}
	static class UBFGInputAction_JetpackPilotThrottle* GetDefaultObj()
	{
		return GetDefaultObjImpl<UBFGInputAction_JetpackPilotThrottle>();
	}
};
static_assert(alignof(UBFGInputAction_JetpackPilotThrottle) == 0x000008, "Wrong alignment on UBFGInputAction_JetpackPilotThrottle");
static_assert(sizeof(UBFGInputAction_JetpackPilotThrottle) == 0x000038, "Wrong size on UBFGInputAction_JetpackPilotThrottle");

// Class BFGCore.BFGInputAction_JetpackPilotThrottleInHolobob
// 0x0000 (0x0038 - 0x0038)
class UBFGInputAction_JetpackPilotThrottleInHolobob final : public UBFGInputAction_JetpackPilotThrottle
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"BFGInputAction_JetpackPilotThrottleInHolobob">();
	}
	static class UBFGInputAction_JetpackPilotThrottleInHolobob* GetDefaultObj()
	{
		return GetDefaultObjImpl<UBFGInputAction_JetpackPilotThrottleInHolobob>();
	}
};
static_assert(alignof(UBFGInputAction_JetpackPilotThrottleInHolobob) == 0x000008, "Wrong alignment on UBFGInputAction_JetpackPilotThrottleInHolobob");
static_assert(sizeof(UBFGInputAction_JetpackPilotThrottleInHolobob) == 0x000038, "Wrong size on UBFGInputAction_JetpackPilotThrottleInHolobob");

// Class BFGCore.BFGInputAction_JetpackPilotThrottleWhenOffGround
// 0x0000 (0x0038 - 0x0038)
class UBFGInputAction_JetpackPilotThrottleWhenOffGround final : public UBFGInputAction_JetpackPilotThrottle
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"BFGInputAction_JetpackPilotThrottleWhenOffGround">();
	}
	static class UBFGInputAction_JetpackPilotThrottleWhenOffGround* GetDefaultObj()
	{
		return GetDefaultObjImpl<UBFGInputAction_JetpackPilotThrottleWhenOffGround>();
	}
};
static_assert(alignof(UBFGInputAction_JetpackPilotThrottleWhenOffGround) == 0x000008, "Wrong alignment on UBFGInputAction_JetpackPilotThrottleWhenOffGround");
static_assert(sizeof(UBFGInputAction_JetpackPilotThrottleWhenOffGround) == 0x000038, "Wrong size on UBFGInputAction_JetpackPilotThrottleWhenOffGround");

// Class BFGCore.BFGInputAction_MentalAbilityCancelHolobob
// 0x0000 (0x0030 - 0x0030)
class UBFGInputAction_MentalAbilityCancelHolobob final : public UBFGInputAction
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"BFGInputAction_MentalAbilityCancelHolobob">();
	}
	static class UBFGInputAction_MentalAbilityCancelHolobob* GetDefaultObj()
	{
		return GetDefaultObjImpl<UBFGInputAction_MentalAbilityCancelHolobob>();
	}
};
static_assert(alignof(UBFGInputAction_MentalAbilityCancelHolobob) == 0x000008, "Wrong alignment on UBFGInputAction_MentalAbilityCancelHolobob");
static_assert(sizeof(UBFGInputAction_MentalAbilityCancelHolobob) == 0x000030, "Wrong size on UBFGInputAction_MentalAbilityCancelHolobob");

// Class BFGCore.BFGWidget_AR_ChallengePanel
// 0x0010 (0x0250 - 0x0240)
class UBFGWidget_AR_ChallengePanel : public UUserWidget
{
public:
	class UBFGDataAsset_ChallengeInfo*            M_pInfo;                                           // 0x0240(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	EBFGChallengeStartingPoint_Visibility         M_eCurrentVisibility;                              // 0x0248(0x0001)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_249[0x7];                                      // 0x0249(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void OnDataChanged();
	void OnPanelVisibilityChanged(EBFGChallengeStartingPoint_Visibility _eVisibility);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"BFGWidget_AR_ChallengePanel">();
	}
	static class UBFGWidget_AR_ChallengePanel* GetDefaultObj()
	{
		return GetDefaultObjImpl<UBFGWidget_AR_ChallengePanel>();
	}
};
static_assert(alignof(UBFGWidget_AR_ChallengePanel) == 0x000008, "Wrong alignment on UBFGWidget_AR_ChallengePanel");
static_assert(sizeof(UBFGWidget_AR_ChallengePanel) == 0x000250, "Wrong size on UBFGWidget_AR_ChallengePanel");
static_assert(offsetof(UBFGWidget_AR_ChallengePanel, M_pInfo) == 0x000240, "Member 'UBFGWidget_AR_ChallengePanel::M_pInfo' has a wrong offset!");
static_assert(offsetof(UBFGWidget_AR_ChallengePanel, M_eCurrentVisibility) == 0x000248, "Member 'UBFGWidget_AR_ChallengePanel::M_eCurrentVisibility' has a wrong offset!");

// Class BFGCore.BFGInputAction_MentalAbilityToggleBrainExtract
// 0x0000 (0x0030 - 0x0030)
class UBFGInputAction_MentalAbilityToggleBrainExtract final : public UBFGInputAction
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"BFGInputAction_MentalAbilityToggleBrainExtract">();
	}
	static class UBFGInputAction_MentalAbilityToggleBrainExtract* GetDefaultObj()
	{
		return GetDefaultObjImpl<UBFGInputAction_MentalAbilityToggleBrainExtract>();
	}
};
static_assert(alignof(UBFGInputAction_MentalAbilityToggleBrainExtract) == 0x000008, "Wrong alignment on UBFGInputAction_MentalAbilityToggleBrainExtract");
static_assert(sizeof(UBFGInputAction_MentalAbilityToggleBrainExtract) == 0x000030, "Wrong size on UBFGInputAction_MentalAbilityToggleBrainExtract");

// Class BFGCore.BFGInputAction_MentalAbilityToggleCortexScan
// 0x0000 (0x0030 - 0x0030)
class UBFGInputAction_MentalAbilityToggleCortexScan final : public UBFGInputAction
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"BFGInputAction_MentalAbilityToggleCortexScan">();
	}
	static class UBFGInputAction_MentalAbilityToggleCortexScan* GetDefaultObj()
	{
		return GetDefaultObjImpl<UBFGInputAction_MentalAbilityToggleCortexScan>();
	}
};
static_assert(alignof(UBFGInputAction_MentalAbilityToggleCortexScan) == 0x000008, "Wrong alignment on UBFGInputAction_MentalAbilityToggleCortexScan");
static_assert(sizeof(UBFGInputAction_MentalAbilityToggleCortexScan) == 0x000030, "Wrong size on UBFGInputAction_MentalAbilityToggleCortexScan");

// Class BFGCore.BFGInputAction_MentalAbilityTogglePK
// 0x0000 (0x0030 - 0x0030)
class UBFGInputAction_MentalAbilityTogglePK final : public UBFGInputAction
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"BFGInputAction_MentalAbilityTogglePK">();
	}
	static class UBFGInputAction_MentalAbilityTogglePK* GetDefaultObj()
	{
		return GetDefaultObjImpl<UBFGInputAction_MentalAbilityTogglePK>();
	}
};
static_assert(alignof(UBFGInputAction_MentalAbilityTogglePK) == 0x000008, "Wrong alignment on UBFGInputAction_MentalAbilityTogglePK");
static_assert(sizeof(UBFGInputAction_MentalAbilityTogglePK) == 0x000030, "Wrong size on UBFGInputAction_MentalAbilityTogglePK");

// Class BFGCore.BFGWidget_Archive
// 0x0000 (0x04C0 - 0x04C0)
class UBFGWidget_Archive final : public UBFGWidget_GenericMenuTree
{
public:
	void OnShowOverlay(bool _bDown);
	void OnUpdateItemDescription(const struct FBFGItemDescription& _aItemDescription);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"BFGWidget_Archive">();
	}
	static class UBFGWidget_Archive* GetDefaultObj()
	{
		return GetDefaultObjImpl<UBFGWidget_Archive>();
	}
};
static_assert(alignof(UBFGWidget_Archive) == 0x000008, "Wrong alignment on UBFGWidget_Archive");
static_assert(sizeof(UBFGWidget_Archive) == 0x0004C0, "Wrong size on UBFGWidget_Archive");

// Class BFGCore.BFGInputAction_MentalAbilityTrigger
// 0x0000 (0x0030 - 0x0030)
class UBFGInputAction_MentalAbilityTrigger final : public UBFGInputAction
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"BFGInputAction_MentalAbilityTrigger">();
	}
	static class UBFGInputAction_MentalAbilityTrigger* GetDefaultObj()
	{
		return GetDefaultObjImpl<UBFGInputAction_MentalAbilityTrigger>();
	}
};
static_assert(alignof(UBFGInputAction_MentalAbilityTrigger) == 0x000008, "Wrong alignment on UBFGInputAction_MentalAbilityTrigger");
static_assert(sizeof(UBFGInputAction_MentalAbilityTrigger) == 0x000030, "Wrong size on UBFGInputAction_MentalAbilityTrigger");

// Class BFGCore.BFGInputAction_PauseMenu
// 0x0000 (0x0030 - 0x0030)
class UBFGInputAction_PauseMenu final : public UBFGInputAction
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"BFGInputAction_PauseMenu">();
	}
	static class UBFGInputAction_PauseMenu* GetDefaultObj()
	{
		return GetDefaultObjImpl<UBFGInputAction_PauseMenu>();
	}
};
static_assert(alignof(UBFGInputAction_PauseMenu) == 0x000008, "Wrong alignment on UBFGInputAction_PauseMenu");
static_assert(sizeof(UBFGInputAction_PauseMenu) == 0x000030, "Wrong size on UBFGInputAction_PauseMenu");

// Class BFGCore.BFGInputAction_PlayerInteract
// 0x0000 (0x0030 - 0x0030)
class UBFGInputAction_PlayerInteract final : public UBFGInputAction
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"BFGInputAction_PlayerInteract">();
	}
	static class UBFGInputAction_PlayerInteract* GetDefaultObj()
	{
		return GetDefaultObjImpl<UBFGInputAction_PlayerInteract>();
	}
};
static_assert(alignof(UBFGInputAction_PlayerInteract) == 0x000008, "Wrong alignment on UBFGInputAction_PlayerInteract");
static_assert(sizeof(UBFGInputAction_PlayerInteract) == 0x000030, "Wrong size on UBFGInputAction_PlayerInteract");

// Class BFGCore.BFGWidget_KeyAssignmentWarning
// 0x0000 (0x0428 - 0x0428)
class UBFGWidget_KeyAssignmentWarning final : public UBFGWidget_GenericDialog
{
public:
	void AddInvalidActionText(const class FText& _strInvalidActionText);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"BFGWidget_KeyAssignmentWarning">();
	}
	static class UBFGWidget_KeyAssignmentWarning* GetDefaultObj()
	{
		return GetDefaultObjImpl<UBFGWidget_KeyAssignmentWarning>();
	}
};
static_assert(alignof(UBFGWidget_KeyAssignmentWarning) == 0x000008, "Wrong alignment on UBFGWidget_KeyAssignmentWarning");
static_assert(sizeof(UBFGWidget_KeyAssignmentWarning) == 0x000428, "Wrong size on UBFGWidget_KeyAssignmentWarning");

// Class BFGCore.BFGInputAction_PlayerMovementDash
// 0x0000 (0x0030 - 0x0030)
class UBFGInputAction_PlayerMovementDash : public UBFGInputAction
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"BFGInputAction_PlayerMovementDash">();
	}
	static class UBFGInputAction_PlayerMovementDash* GetDefaultObj()
	{
		return GetDefaultObjImpl<UBFGInputAction_PlayerMovementDash>();
	}
};
static_assert(alignof(UBFGInputAction_PlayerMovementDash) == 0x000008, "Wrong alignment on UBFGInputAction_PlayerMovementDash");
static_assert(sizeof(UBFGInputAction_PlayerMovementDash) == 0x000030, "Wrong size on UBFGInputAction_PlayerMovementDash");

// Class BFGCore.BFGInputAction_PlayerMovementDashInHolobob
// 0x0000 (0x0030 - 0x0030)
class UBFGInputAction_PlayerMovementDashInHolobob final : public UBFGInputAction_PlayerMovementDash
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"BFGInputAction_PlayerMovementDashInHolobob">();
	}
	static class UBFGInputAction_PlayerMovementDashInHolobob* GetDefaultObj()
	{
		return GetDefaultObjImpl<UBFGInputAction_PlayerMovementDashInHolobob>();
	}
};
static_assert(alignof(UBFGInputAction_PlayerMovementDashInHolobob) == 0x000008, "Wrong alignment on UBFGInputAction_PlayerMovementDashInHolobob");
static_assert(sizeof(UBFGInputAction_PlayerMovementDashInHolobob) == 0x000030, "Wrong size on UBFGInputAction_PlayerMovementDashInHolobob");

// Class BFGCore.BFGInputAction_PlayerSelectWeaponAndAbility
// 0x0000 (0x0030 - 0x0030)
class UBFGInputAction_PlayerSelectWeaponAndAbility final : public UBFGInputAction
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"BFGInputAction_PlayerSelectWeaponAndAbility">();
	}
	static class UBFGInputAction_PlayerSelectWeaponAndAbility* GetDefaultObj()
	{
		return GetDefaultObjImpl<UBFGInputAction_PlayerSelectWeaponAndAbility>();
	}
};
static_assert(alignof(UBFGInputAction_PlayerSelectWeaponAndAbility) == 0x000008, "Wrong alignment on UBFGInputAction_PlayerSelectWeaponAndAbility");
static_assert(sizeof(UBFGInputAction_PlayerSelectWeaponAndAbility) == 0x000030, "Wrong size on UBFGInputAction_PlayerSelectWeaponAndAbility");

// Class BFGCore.BFGWidget_MediaWidget
// 0x0028 (0x0450 - 0x0428)
class UBFGWidget_MediaWidget final : public UBFGWidget_GenericDialog
{
public:
	class UMaterial*                              M_pMaterialMediaPlayer;                            // 0x0428(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UMediaPlayer*                           M_pMediaPlayer;                                    // 0x0430(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UMediaPlaylist*                         M_pMediaPlaylist;                                  // 0x0438(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UTexture2D*                             M_pImage;                                          // 0x0440(0x0008)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UMediaSource*                           M_pVideo;                                          // 0x0448(0x0008)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)

public:
	void Action__DelegateSignature();
	void OnButtonBackClicked();
	void OnVideoFinishedPlaying();
	void ShowMediaInternal(const struct FSlateBrush& _oMedia);
	void StopMediaInternal();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"BFGWidget_MediaWidget">();
	}
	static class UBFGWidget_MediaWidget* GetDefaultObj()
	{
		return GetDefaultObjImpl<UBFGWidget_MediaWidget>();
	}
};
static_assert(alignof(UBFGWidget_MediaWidget) == 0x000008, "Wrong alignment on UBFGWidget_MediaWidget");
static_assert(sizeof(UBFGWidget_MediaWidget) == 0x000450, "Wrong size on UBFGWidget_MediaWidget");
static_assert(offsetof(UBFGWidget_MediaWidget, M_pMaterialMediaPlayer) == 0x000428, "Member 'UBFGWidget_MediaWidget::M_pMaterialMediaPlayer' has a wrong offset!");
static_assert(offsetof(UBFGWidget_MediaWidget, M_pMediaPlayer) == 0x000430, "Member 'UBFGWidget_MediaWidget::M_pMediaPlayer' has a wrong offset!");
static_assert(offsetof(UBFGWidget_MediaWidget, M_pMediaPlaylist) == 0x000438, "Member 'UBFGWidget_MediaWidget::M_pMediaPlaylist' has a wrong offset!");
static_assert(offsetof(UBFGWidget_MediaWidget, M_pImage) == 0x000440, "Member 'UBFGWidget_MediaWidget::M_pImage' has a wrong offset!");
static_assert(offsetof(UBFGWidget_MediaWidget, M_pVideo) == 0x000448, "Member 'UBFGWidget_MediaWidget::M_pVideo' has a wrong offset!");

// Class BFGCore.BFGInputAction_PlayerToggleForceADS
// 0x0008 (0x0038 - 0x0030)
class UBFGInputAction_PlayerToggleForceADS final : public UBFGInputAction
{
public:
	uint8                                         Pad_30[0x8];                                       // 0x0030(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"BFGInputAction_PlayerToggleForceADS">();
	}
	static class UBFGInputAction_PlayerToggleForceADS* GetDefaultObj()
	{
		return GetDefaultObjImpl<UBFGInputAction_PlayerToggleForceADS>();
	}
};
static_assert(alignof(UBFGInputAction_PlayerToggleForceADS) == 0x000008, "Wrong alignment on UBFGInputAction_PlayerToggleForceADS");
static_assert(sizeof(UBFGInputAction_PlayerToggleForceADS) == 0x000038, "Wrong size on UBFGInputAction_PlayerToggleForceADS");

// Class BFGCore.BFGInputAction_PlayerTutorialDismiss
// 0x0000 (0x0030 - 0x0030)
class UBFGInputAction_PlayerTutorialDismiss final : public UBFGInputAction
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"BFGInputAction_PlayerTutorialDismiss">();
	}
	static class UBFGInputAction_PlayerTutorialDismiss* GetDefaultObj()
	{
		return GetDefaultObjImpl<UBFGInputAction_PlayerTutorialDismiss>();
	}
};
static_assert(alignof(UBFGInputAction_PlayerTutorialDismiss) == 0x000008, "Wrong alignment on UBFGInputAction_PlayerTutorialDismiss");
static_assert(sizeof(UBFGInputAction_PlayerTutorialDismiss) == 0x000030, "Wrong size on UBFGInputAction_PlayerTutorialDismiss");

// Class BFGCore.BFGInputAction_PlayerTutorialMaximize
// 0x0000 (0x0030 - 0x0030)
class UBFGInputAction_PlayerTutorialMaximize final : public UBFGInputAction
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"BFGInputAction_PlayerTutorialMaximize">();
	}
	static class UBFGInputAction_PlayerTutorialMaximize* GetDefaultObj()
	{
		return GetDefaultObjImpl<UBFGInputAction_PlayerTutorialMaximize>();
	}
};
static_assert(alignof(UBFGInputAction_PlayerTutorialMaximize) == 0x000008, "Wrong alignment on UBFGInputAction_PlayerTutorialMaximize");
static_assert(sizeof(UBFGInputAction_PlayerTutorialMaximize) == 0x000030, "Wrong size on UBFGInputAction_PlayerTutorialMaximize");

// Class BFGCore.BFGWidget_Mothership_Archive
// 0x0000 (0x02C8 - 0x02C8)
class UBFGWidget_Mothership_Archive final : public UBFGWidget_Mothership_Submenu
{
public:
	class UBFGWidget_Archive* GetSubMenu();
	void OnAcceptButtonClicked();
	void OnTreeLayerChanged();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"BFGWidget_Mothership_Archive">();
	}
	static class UBFGWidget_Mothership_Archive* GetDefaultObj()
	{
		return GetDefaultObjImpl<UBFGWidget_Mothership_Archive>();
	}
};
static_assert(alignof(UBFGWidget_Mothership_Archive) == 0x000008, "Wrong alignment on UBFGWidget_Mothership_Archive");
static_assert(sizeof(UBFGWidget_Mothership_Archive) == 0x0002C8, "Wrong size on UBFGWidget_Mothership_Archive");

// Class BFGCore.BFGInputAction_PlayerUFODash
// 0x0000 (0x0030 - 0x0030)
class UBFGInputAction_PlayerUFODash final : public UBFGInputAction
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"BFGInputAction_PlayerUFODash">();
	}
	static class UBFGInputAction_PlayerUFODash* GetDefaultObj()
	{
		return GetDefaultObjImpl<UBFGInputAction_PlayerUFODash>();
	}
};
static_assert(alignof(UBFGInputAction_PlayerUFODash) == 0x000008, "Wrong alignment on UBFGInputAction_PlayerUFODash");
static_assert(sizeof(UBFGInputAction_PlayerUFODash) == 0x000030, "Wrong size on UBFGInputAction_PlayerUFODash");

// Class BFGCore.BFGInputAction_PlayerUFOEnableAbductMode
// 0x0000 (0x0030 - 0x0030)
class UBFGInputAction_PlayerUFOEnableAbductMode final : public UBFGInputAction
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"BFGInputAction_PlayerUFOEnableAbductMode">();
	}
	static class UBFGInputAction_PlayerUFOEnableAbductMode* GetDefaultObj()
	{
		return GetDefaultObjImpl<UBFGInputAction_PlayerUFOEnableAbductMode>();
	}
};
static_assert(alignof(UBFGInputAction_PlayerUFOEnableAbductMode) == 0x000008, "Wrong alignment on UBFGInputAction_PlayerUFOEnableAbductMode");
static_assert(sizeof(UBFGInputAction_PlayerUFOEnableAbductMode) == 0x000030, "Wrong size on UBFGInputAction_PlayerUFOEnableAbductMode");

// Class BFGCore.BFGInputAction_PlayerWeaponShoot
// 0x0000 (0x0030 - 0x0030)
class UBFGInputAction_PlayerWeaponShoot final : public UBFGInputAction
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"BFGInputAction_PlayerWeaponShoot">();
	}
	static class UBFGInputAction_PlayerWeaponShoot* GetDefaultObj()
	{
		return GetDefaultObjImpl<UBFGInputAction_PlayerWeaponShoot>();
	}
};
static_assert(alignof(UBFGInputAction_PlayerWeaponShoot) == 0x000008, "Wrong alignment on UBFGInputAction_PlayerWeaponShoot");
static_assert(sizeof(UBFGInputAction_PlayerWeaponShoot) == 0x000030, "Wrong size on UBFGInputAction_PlayerWeaponShoot");

// Class BFGCore.BFGWidgetPoxLabEntryPointOption
// 0x0058 (0x0298 - 0x0240)
class UBFGWidgetPoxLabEntryPointOption final : public UUserWidget
{
public:
	EBFGMotherShipPoxLabType                      M_eUpgradeOption;                                  // 0x0240(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_241[0x7];                                      // 0x0241(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	class UPaperSprite*                           M_pTexture;                                        // 0x0248(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FText                                   M_strTitle;                                        // 0x0250(0x0018)(Edit, BlueprintVisible, BlueprintReadOnly, NativeAccessSpecifierPublic)
	uint8                                         Pad_268[0x30];                                     // 0x0268(0x0030)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void ActionPoxUpgradeType__DelegateSignature(EBFGMotherShipPoxLabType _eType);
	void OnMouseHover();
	void OnMousePress();
	void OnUpgradeAvailable(bool _bValue);
	void UpdateSelectionState(bool _bSelected);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"BFGWidgetPoxLabEntryPointOption">();
	}
	static class UBFGWidgetPoxLabEntryPointOption* GetDefaultObj()
	{
		return GetDefaultObjImpl<UBFGWidgetPoxLabEntryPointOption>();
	}
};
static_assert(alignof(UBFGWidgetPoxLabEntryPointOption) == 0x000008, "Wrong alignment on UBFGWidgetPoxLabEntryPointOption");
static_assert(sizeof(UBFGWidgetPoxLabEntryPointOption) == 0x000298, "Wrong size on UBFGWidgetPoxLabEntryPointOption");
static_assert(offsetof(UBFGWidgetPoxLabEntryPointOption, M_eUpgradeOption) == 0x000240, "Member 'UBFGWidgetPoxLabEntryPointOption::M_eUpgradeOption' has a wrong offset!");
static_assert(offsetof(UBFGWidgetPoxLabEntryPointOption, M_pTexture) == 0x000248, "Member 'UBFGWidgetPoxLabEntryPointOption::M_pTexture' has a wrong offset!");
static_assert(offsetof(UBFGWidgetPoxLabEntryPointOption, M_strTitle) == 0x000250, "Member 'UBFGWidgetPoxLabEntryPointOption::M_strTitle' has a wrong offset!");

// Class BFGCore.BFGInputAction_UIAdvance
// 0x0000 (0x0030 - 0x0030)
class UBFGInputAction_UIAdvance final : public UBFGInputAction_UI
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"BFGInputAction_UIAdvance">();
	}
	static class UBFGInputAction_UIAdvance* GetDefaultObj()
	{
		return GetDefaultObjImpl<UBFGInputAction_UIAdvance>();
	}
};
static_assert(alignof(UBFGInputAction_UIAdvance) == 0x000008, "Wrong alignment on UBFGInputAction_UIAdvance");
static_assert(sizeof(UBFGInputAction_UIAdvance) == 0x000030, "Wrong size on UBFGInputAction_UIAdvance");

// Class BFGCore.BFGInputAction_UIBack
// 0x0000 (0x0030 - 0x0030)
class UBFGInputAction_UIBack final : public UBFGInputAction_UI
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"BFGInputAction_UIBack">();
	}
	static class UBFGInputAction_UIBack* GetDefaultObj()
	{
		return GetDefaultObjImpl<UBFGInputAction_UIBack>();
	}
};
static_assert(alignof(UBFGInputAction_UIBack) == 0x000008, "Wrong alignment on UBFGInputAction_UIBack");
static_assert(sizeof(UBFGInputAction_UIBack) == 0x000030, "Wrong size on UBFGInputAction_UIBack");

// Class BFGCore.BFGWidget_Credits
// 0x0160 (0x0588 - 0x0428)
class UBFGWidget_Credits final : public UBFGWidget_GenericDialog
{
public:
	UMulticastDelegateProperty_                   OnCreditsEnd;                                      // 0x0428(0x0018)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	float                                         M_fPreCreditsBufferTime;                           // 0x0440(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         M_fPostCreditsBufferTime;                          // 0x0444(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         M_fCreditInterval;                                 // 0x0448(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         M_fCreditScrollSpeedMofifier;                      // 0x044C(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	struct FSlateFontInfo                         M_oH1FontInfo;                                     // 0x0450(0x0050)(Edit, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         M_fH1IntervalAddition;                             // 0x04A0(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_4A4[0x4];                                      // 0x04A4(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	struct FSlateFontInfo                         M_oH2FontInfo;                                     // 0x04A8(0x0050)(Edit, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         M_fH2IntervalAddition;                             // 0x04F8(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_4FC[0x4];                                      // 0x04FC(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	struct FSlateFontInfo                         M_oH3FontInfo;                                     // 0x0500(0x0050)(Edit, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         M_fH3IntervalAddition;                             // 0x0550(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_554[0x34];                                     // 0x0554(0x0034)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void Action_OnCreditsEnd__DelegateSignature();
	class UBFGWidget_CreditsTextPanel* CreateTextPanel();
	void EndCredits();
	void HandleTextPanelDone(class UBFGWidget_CreditsTextPanel* _pPanel);
	void OnLastTextSpawned();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"BFGWidget_Credits">();
	}
	static class UBFGWidget_Credits* GetDefaultObj()
	{
		return GetDefaultObjImpl<UBFGWidget_Credits>();
	}
};
static_assert(alignof(UBFGWidget_Credits) == 0x000008, "Wrong alignment on UBFGWidget_Credits");
static_assert(sizeof(UBFGWidget_Credits) == 0x000588, "Wrong size on UBFGWidget_Credits");
static_assert(offsetof(UBFGWidget_Credits, OnCreditsEnd) == 0x000428, "Member 'UBFGWidget_Credits::OnCreditsEnd' has a wrong offset!");
static_assert(offsetof(UBFGWidget_Credits, M_fPreCreditsBufferTime) == 0x000440, "Member 'UBFGWidget_Credits::M_fPreCreditsBufferTime' has a wrong offset!");
static_assert(offsetof(UBFGWidget_Credits, M_fPostCreditsBufferTime) == 0x000444, "Member 'UBFGWidget_Credits::M_fPostCreditsBufferTime' has a wrong offset!");
static_assert(offsetof(UBFGWidget_Credits, M_fCreditInterval) == 0x000448, "Member 'UBFGWidget_Credits::M_fCreditInterval' has a wrong offset!");
static_assert(offsetof(UBFGWidget_Credits, M_fCreditScrollSpeedMofifier) == 0x00044C, "Member 'UBFGWidget_Credits::M_fCreditScrollSpeedMofifier' has a wrong offset!");
static_assert(offsetof(UBFGWidget_Credits, M_oH1FontInfo) == 0x000450, "Member 'UBFGWidget_Credits::M_oH1FontInfo' has a wrong offset!");
static_assert(offsetof(UBFGWidget_Credits, M_fH1IntervalAddition) == 0x0004A0, "Member 'UBFGWidget_Credits::M_fH1IntervalAddition' has a wrong offset!");
static_assert(offsetof(UBFGWidget_Credits, M_oH2FontInfo) == 0x0004A8, "Member 'UBFGWidget_Credits::M_oH2FontInfo' has a wrong offset!");
static_assert(offsetof(UBFGWidget_Credits, M_fH2IntervalAddition) == 0x0004F8, "Member 'UBFGWidget_Credits::M_fH2IntervalAddition' has a wrong offset!");
static_assert(offsetof(UBFGWidget_Credits, M_oH3FontInfo) == 0x000500, "Member 'UBFGWidget_Credits::M_oH3FontInfo' has a wrong offset!");
static_assert(offsetof(UBFGWidget_Credits, M_fH3IntervalAddition) == 0x000550, "Member 'UBFGWidget_Credits::M_fH3IntervalAddition' has a wrong offset!");

// Class BFGCore.BFGInputAction_UIChangeProfile
// 0x0000 (0x0030 - 0x0030)
class UBFGInputAction_UIChangeProfile final : public UBFGInputAction_UI
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"BFGInputAction_UIChangeProfile">();
	}
	static class UBFGInputAction_UIChangeProfile* GetDefaultObj()
	{
		return GetDefaultObjImpl<UBFGInputAction_UIChangeProfile>();
	}
};
static_assert(alignof(UBFGInputAction_UIChangeProfile) == 0x000008, "Wrong alignment on UBFGInputAction_UIChangeProfile");
static_assert(sizeof(UBFGInputAction_UIChangeProfile) == 0x000030, "Wrong size on UBFGInputAction_UIChangeProfile");

// Class BFGCore.BFGInputAction_UIModeBack
// 0x0000 (0x0030 - 0x0030)
class UBFGInputAction_UIModeBack final : public UBFGInputAction_UI
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"BFGInputAction_UIModeBack">();
	}
	static class UBFGInputAction_UIModeBack* GetDefaultObj()
	{
		return GetDefaultObjImpl<UBFGInputAction_UIModeBack>();
	}
};
static_assert(alignof(UBFGInputAction_UIModeBack) == 0x000008, "Wrong alignment on UBFGInputAction_UIModeBack");
static_assert(sizeof(UBFGInputAction_UIModeBack) == 0x000030, "Wrong size on UBFGInputAction_UIModeBack");

// Class BFGCore.BFGInputAction_UIModeForward
// 0x0000 (0x0030 - 0x0030)
class UBFGInputAction_UIModeForward final : public UBFGInputAction_UI
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"BFGInputAction_UIModeForward">();
	}
	static class UBFGInputAction_UIModeForward* GetDefaultObj()
	{
		return GetDefaultObjImpl<UBFGInputAction_UIModeForward>();
	}
};
static_assert(alignof(UBFGInputAction_UIModeForward) == 0x000008, "Wrong alignment on UBFGInputAction_UIModeForward");
static_assert(sizeof(UBFGInputAction_UIModeForward) == 0x000030, "Wrong size on UBFGInputAction_UIModeForward");

// Class BFGCore.BFGWidget_DialogOption_NavBarEntry
// 0x0008 (0x0280 - 0x0278)
class UBFGWidget_DialogOption_NavBarEntry final : public UBFGWidget_DialogOption_Customizable
{
public:
	uint8                                         Pad_278[0x8];                                      // 0x0278(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void OnCultureChanged();
	void SetEntryActive(bool _bActive);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"BFGWidget_DialogOption_NavBarEntry">();
	}
	static class UBFGWidget_DialogOption_NavBarEntry* GetDefaultObj()
	{
		return GetDefaultObjImpl<UBFGWidget_DialogOption_NavBarEntry>();
	}
};
static_assert(alignof(UBFGWidget_DialogOption_NavBarEntry) == 0x000008, "Wrong alignment on UBFGWidget_DialogOption_NavBarEntry");
static_assert(sizeof(UBFGWidget_DialogOption_NavBarEntry) == 0x000280, "Wrong size on UBFGWidget_DialogOption_NavBarEntry");

// Class BFGCore.BFGInputAction_UIOpenDebugMenu
// 0x0000 (0x0030 - 0x0030)
class UBFGInputAction_UIOpenDebugMenu final : public UBFGInputAction_UI
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"BFGInputAction_UIOpenDebugMenu">();
	}
	static class UBFGInputAction_UIOpenDebugMenu* GetDefaultObj()
	{
		return GetDefaultObjImpl<UBFGInputAction_UIOpenDebugMenu>();
	}
};
static_assert(alignof(UBFGInputAction_UIOpenDebugMenu) == 0x000008, "Wrong alignment on UBFGInputAction_UIOpenDebugMenu");
static_assert(sizeof(UBFGInputAction_UIOpenDebugMenu) == 0x000030, "Wrong size on UBFGInputAction_UIOpenDebugMenu");

// Class BFGCore.BFGInputAction_UIOption1
// 0x0000 (0x0030 - 0x0030)
class UBFGInputAction_UIOption1 final : public UBFGInputAction_UI
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"BFGInputAction_UIOption1">();
	}
	static class UBFGInputAction_UIOption1* GetDefaultObj()
	{
		return GetDefaultObjImpl<UBFGInputAction_UIOption1>();
	}
};
static_assert(alignof(UBFGInputAction_UIOption1) == 0x000008, "Wrong alignment on UBFGInputAction_UIOption1");
static_assert(sizeof(UBFGInputAction_UIOption1) == 0x000030, "Wrong size on UBFGInputAction_UIOption1");

// Class BFGCore.BFGInputAction_UIOption2
// 0x0000 (0x0030 - 0x0030)
class UBFGInputAction_UIOption2 final : public UBFGInputAction_UI
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"BFGInputAction_UIOption2">();
	}
	static class UBFGInputAction_UIOption2* GetDefaultObj()
	{
		return GetDefaultObjImpl<UBFGInputAction_UIOption2>();
	}
};
static_assert(alignof(UBFGInputAction_UIOption2) == 0x000008, "Wrong alignment on UBFGInputAction_UIOption2");
static_assert(sizeof(UBFGInputAction_UIOption2) == 0x000030, "Wrong size on UBFGInputAction_UIOption2");

// Class BFGCore.BFGWidget_FuronHandbook
// 0x0030 (0x0458 - 0x0428)
class UBFGWidget_FuronHandbook final : public UBFGWidget_GenericDialog
{
public:
	class UBFGWidget_Archive_FuronHandbook*       M_pFuronHandbook;                                  // 0x0428(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TSoftClassPtr<class UClass>                   M_pFuronHandbookClass;                             // 0x0430(0x0028)(Edit, DisableEditOnInstance, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)

public:
	void AddContentToLayout(class UBFGWidget_Archive_FuronHandbook* _pContent);
	void NextPage();
	void OnClickedBack();
	void OnTreeLayerChanged();
	void UpdatePath(const class FString& _strPath);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"BFGWidget_FuronHandbook">();
	}
	static class UBFGWidget_FuronHandbook* GetDefaultObj()
	{
		return GetDefaultObjImpl<UBFGWidget_FuronHandbook>();
	}
};
static_assert(alignof(UBFGWidget_FuronHandbook) == 0x000008, "Wrong alignment on UBFGWidget_FuronHandbook");
static_assert(sizeof(UBFGWidget_FuronHandbook) == 0x000458, "Wrong size on UBFGWidget_FuronHandbook");
static_assert(offsetof(UBFGWidget_FuronHandbook, M_pFuronHandbook) == 0x000428, "Member 'UBFGWidget_FuronHandbook::M_pFuronHandbook' has a wrong offset!");
static_assert(offsetof(UBFGWidget_FuronHandbook, M_pFuronHandbookClass) == 0x000430, "Member 'UBFGWidget_FuronHandbook::M_pFuronHandbookClass' has a wrong offset!");

// Class BFGCore.BFGInputAxis_PawnAddControllerPitchInput
// 0x0000 (0x0028 - 0x0028)
class UBFGInputAxis_PawnAddControllerPitchInput final : public UBFGInputAxis
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"BFGInputAxis_PawnAddControllerPitchInput">();
	}
	static class UBFGInputAxis_PawnAddControllerPitchInput* GetDefaultObj()
	{
		return GetDefaultObjImpl<UBFGInputAxis_PawnAddControllerPitchInput>();
	}
};
static_assert(alignof(UBFGInputAxis_PawnAddControllerPitchInput) == 0x000008, "Wrong alignment on UBFGInputAxis_PawnAddControllerPitchInput");
static_assert(sizeof(UBFGInputAxis_PawnAddControllerPitchInput) == 0x000028, "Wrong size on UBFGInputAxis_PawnAddControllerPitchInput");

// Class BFGCore.BFGInputAxis_PawnAddControllerYawInput
// 0x0000 (0x0028 - 0x0028)
class UBFGInputAxis_PawnAddControllerYawInput final : public UBFGInputAxis
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"BFGInputAxis_PawnAddControllerYawInput">();
	}
	static class UBFGInputAxis_PawnAddControllerYawInput* GetDefaultObj()
	{
		return GetDefaultObjImpl<UBFGInputAxis_PawnAddControllerYawInput>();
	}
};
static_assert(alignof(UBFGInputAxis_PawnAddControllerYawInput) == 0x000008, "Wrong alignment on UBFGInputAxis_PawnAddControllerYawInput");
static_assert(sizeof(UBFGInputAxis_PawnAddControllerYawInput) == 0x000028, "Wrong size on UBFGInputAxis_PawnAddControllerYawInput");

// Class BFGCore.BFGWidget_GamepadPanel
// 0x0000 (0x0240 - 0x0240)
class UBFGWidget_GamepadPanel final : public UUserWidget
{
public:
	void SwitchToPanel(int32 _iIndex);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"BFGWidget_GamepadPanel">();
	}
	static class UBFGWidget_GamepadPanel* GetDefaultObj()
	{
		return GetDefaultObjImpl<UBFGWidget_GamepadPanel>();
	}
};
static_assert(alignof(UBFGWidget_GamepadPanel) == 0x000008, "Wrong alignment on UBFGWidget_GamepadPanel");
static_assert(sizeof(UBFGWidget_GamepadPanel) == 0x000240, "Wrong size on UBFGWidget_GamepadPanel");

// Class BFGCore.BFGInputAxis_PawnMoveRight
// 0x0000 (0x0028 - 0x0028)
class UBFGInputAxis_PawnMoveRight final : public UBFGInputAxis
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"BFGInputAxis_PawnMoveRight">();
	}
	static class UBFGInputAxis_PawnMoveRight* GetDefaultObj()
	{
		return GetDefaultObjImpl<UBFGInputAxis_PawnMoveRight>();
	}
};
static_assert(alignof(UBFGInputAxis_PawnMoveRight) == 0x000008, "Wrong alignment on UBFGInputAxis_PawnMoveRight");
static_assert(sizeof(UBFGInputAxis_PawnMoveRight) == 0x000028, "Wrong size on UBFGInputAxis_PawnMoveRight");

// Class BFGCore.BFGInputAxis_PawnMoveUp
// 0x0000 (0x0028 - 0x0028)
class UBFGInputAxis_PawnMoveUp final : public UBFGInputAxis
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"BFGInputAxis_PawnMoveUp">();
	}
	static class UBFGInputAxis_PawnMoveUp* GetDefaultObj()
	{
		return GetDefaultObjImpl<UBFGInputAxis_PawnMoveUp>();
	}
};
static_assert(alignof(UBFGInputAxis_PawnMoveUp) == 0x000008, "Wrong alignment on UBFGInputAxis_PawnMoveUp");
static_assert(sizeof(UBFGInputAxis_PawnMoveUp) == 0x000028, "Wrong size on UBFGInputAxis_PawnMoveUp");

// Class BFGCore.BFGInputAxis_PawnTurnAtRate
// 0x0008 (0x0030 - 0x0028)
class UBFGInputAxis_PawnTurnAtRate final : public UBFGInputAxis
{
public:
	float                                         M_fTurnRate;                                       // 0x0028(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_2C[0x4];                                       // 0x002C(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"BFGInputAxis_PawnTurnAtRate">();
	}
	static class UBFGInputAxis_PawnTurnAtRate* GetDefaultObj()
	{
		return GetDefaultObjImpl<UBFGInputAxis_PawnTurnAtRate>();
	}
};
static_assert(alignof(UBFGInputAxis_PawnTurnAtRate) == 0x000008, "Wrong alignment on UBFGInputAxis_PawnTurnAtRate");
static_assert(sizeof(UBFGInputAxis_PawnTurnAtRate) == 0x000030, "Wrong size on UBFGInputAxis_PawnTurnAtRate");
static_assert(offsetof(UBFGInputAxis_PawnTurnAtRate, M_fTurnRate) == 0x000028, "Member 'UBFGInputAxis_PawnTurnAtRate::M_fTurnRate' has a wrong offset!");

// Class BFGCore.BFGInputAxis_PlayerControllerAimHorizontal
// 0x0000 (0x0028 - 0x0028)
class UBFGInputAxis_PlayerControllerAimHorizontal final : public UBFGInputAxis
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"BFGInputAxis_PlayerControllerAimHorizontal">();
	}
	static class UBFGInputAxis_PlayerControllerAimHorizontal* GetDefaultObj()
	{
		return GetDefaultObjImpl<UBFGInputAxis_PlayerControllerAimHorizontal>();
	}
};
static_assert(alignof(UBFGInputAxis_PlayerControllerAimHorizontal) == 0x000008, "Wrong alignment on UBFGInputAxis_PlayerControllerAimHorizontal");
static_assert(sizeof(UBFGInputAxis_PlayerControllerAimHorizontal) == 0x000028, "Wrong size on UBFGInputAxis_PlayerControllerAimHorizontal");

// Class BFGCore.BFGWeapon_EnemyHomingMissile
// 0x0000 (0x0850 - 0x0850)
class ABFGWeapon_EnemyHomingMissile final : public ABFGWeapon_Enemy
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"BFGWeapon_EnemyHomingMissile">();
	}
	static class ABFGWeapon_EnemyHomingMissile* GetDefaultObj()
	{
		return GetDefaultObjImpl<ABFGWeapon_EnemyHomingMissile>();
	}
};
static_assert(alignof(ABFGWeapon_EnemyHomingMissile) == 0x000008, "Wrong alignment on ABFGWeapon_EnemyHomingMissile");
static_assert(sizeof(ABFGWeapon_EnemyHomingMissile) == 0x000850, "Wrong size on ABFGWeapon_EnemyHomingMissile");

// Class BFGCore.BFGInputAxis_PlayerControllerAimVertical
// 0x0000 (0x0028 - 0x0028)
class UBFGInputAxis_PlayerControllerAimVertical final : public UBFGInputAxis
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"BFGInputAxis_PlayerControllerAimVertical">();
	}
	static class UBFGInputAxis_PlayerControllerAimVertical* GetDefaultObj()
	{
		return GetDefaultObjImpl<UBFGInputAxis_PlayerControllerAimVertical>();
	}
};
static_assert(alignof(UBFGInputAxis_PlayerControllerAimVertical) == 0x000008, "Wrong alignment on UBFGInputAxis_PlayerControllerAimVertical");
static_assert(sizeof(UBFGInputAxis_PlayerControllerAimVertical) == 0x000028, "Wrong size on UBFGInputAxis_PlayerControllerAimVertical");

// Class BFGCore.BFGInputAxis_PlayerWeaponCycle
// 0x0000 (0x0028 - 0x0028)
class UBFGInputAxis_PlayerWeaponCycle final : public UBFGInputAxis
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"BFGInputAxis_PlayerWeaponCycle">();
	}
	static class UBFGInputAxis_PlayerWeaponCycle* GetDefaultObj()
	{
		return GetDefaultObjImpl<UBFGInputAxis_PlayerWeaponCycle>();
	}
};
static_assert(alignof(UBFGInputAxis_PlayerWeaponCycle) == 0x000008, "Wrong alignment on UBFGInputAxis_PlayerWeaponCycle");
static_assert(sizeof(UBFGInputAxis_PlayerWeaponCycle) == 0x000028, "Wrong size on UBFGInputAxis_PlayerWeaponCycle");

// Class BFGCore.BFGInputAxis_UFOLookOrMoveUp
// 0x0008 (0x0030 - 0x0028)
class UBFGInputAxis_UFOLookOrMoveUp final : public UBFGInputAxis
{
public:
	float                                         M_fLookUpRate;                                     // 0x0028(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_2C[0x4];                                       // 0x002C(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"BFGInputAxis_UFOLookOrMoveUp">();
	}
	static class UBFGInputAxis_UFOLookOrMoveUp* GetDefaultObj()
	{
		return GetDefaultObjImpl<UBFGInputAxis_UFOLookOrMoveUp>();
	}
};
static_assert(alignof(UBFGInputAxis_UFOLookOrMoveUp) == 0x000008, "Wrong alignment on UBFGInputAxis_UFOLookOrMoveUp");
static_assert(sizeof(UBFGInputAxis_UFOLookOrMoveUp) == 0x000030, "Wrong size on UBFGInputAxis_UFOLookOrMoveUp");
static_assert(offsetof(UBFGInputAxis_UFOLookOrMoveUp, M_fLookUpRate) == 0x000028, "Member 'UBFGInputAxis_UFOLookOrMoveUp::M_fLookUpRate' has a wrong offset!");

// Class BFGCore.BFGWeapon_IonDetonator
// 0x00F8 (0x0848 - 0x0750)
class ABFGWeapon_IonDetonator : public ABFGWeapon_BaseProjectile
{
public:
	struct FGameplayTag                           M_tUpgradeTagTransmogrificationizer;               // 0x0750(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, DisableEditOnInstance, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FGameplayTag                           M_tUpgradeTagTransmogrificationizatomaticulatorizer; // 0x0758(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, DisableEditOnInstance, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FGameplayTag                           M_tUpgradeTagTemporalDistortionator;               // 0x0760(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, DisableEditOnInstance, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FGameplayTag                           M_tUpgradeTagIonStorageBeta;                       // 0x0768(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, DisableEditOnInstance, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FGameplayTag                           M_tUpgradeTagIonStorageZeta;                       // 0x0770(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, DisableEditOnInstance, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FGameplayTag                           M_tUpgradeTagIonVortexCoils;                       // 0x0778(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, DisableEditOnInstance, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         M_fMaxChargeTime;                                  // 0x0780(0x0004)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         M_fMinProjectileSpeed;                             // 0x0784(0x0004)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         M_fMaxProjectileSpeed;                             // 0x0788(0x0004)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         M_fProjectileAngle;                                // 0x078C(0x0004)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	struct FSoftClassPath                         M_oWeaponMarkerPath;                               // 0x0790(0x0018)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, Protected, NativeAccessSpecifierProtected)
	struct FColor                                 M_oWeaponMarketBounceColour;                       // 0x07A8(0x0004)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	struct FColor                                 M_oWeaponMarketNoBounceColour;                     // 0x07AC(0x0004)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class ABFGWeaponTargetMarker*                 M_pWeaponMarker;                                   // 0x07B0(0x0008)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_7B8[0x8];                                      // 0x07B8(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	class ABFGProjectile_IonDetonator*            M_pProjectile;                                     // 0x07C0(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_7C8[0x4];                                      // 0x07C8(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	int32                                         M_iIonStorageBeta_ExtraAmmoCount;                  // 0x07CC(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	int32                                         M_iIonStorageZeta_ExtraAmmoCount;                  // 0x07D0(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	struct FTimeDilationModifier                  M_oTemporalDistortionatorTimeModifier;             // 0x07D4(0x001C)(Edit, BlueprintVisible, DisableEditOnInstance, NoDestructor, Protected, NativeAccessSpecifierProtected)
	float                                         M_fTemporalDistortionatorSheildRegenerationRate;   // 0x07F0(0x0004)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_7F4[0x4];                                      // 0x07F4(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         M_oIonVortexCoilsRadius;                           // 0x07F8(0x0004)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	struct FVector                                M_vIonVortexCoilsRadius;                           // 0x07FC(0x000C)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TArray<struct FBFGIonVortexCoilsWeightClassData> M_aIonVortexCoilsMaxWeightClassData;               // 0x0808(0x0010)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, Protected, NativeAccessSpecifierProtected)
	float                                         M_fTransmogrificationizerProbability;              // 0x0818(0x0004)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         M_fTransmogrificationizatomaticulatorizerProbability; // 0x081C(0x0004)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	struct FSoftClassPath                         M_oTransmogrifierClass;                            // 0x0820(0x0018)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, Protected, NativeAccessSpecifierProtected)
	float                                         M_fTransmogrifierRadius;                           // 0x0838(0x0004)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_83C[0x4];                                      // 0x083C(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class UClass*                                 M_pCachedTransmogrifierClass;                      // 0x0840(0x0008)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)

public:
	void OnEquipementManagerWeaponRequestFireChanged(class ABFGWeapon* _pWeapon, bool _bValue);

	bool IsProjectileActive() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"BFGWeapon_IonDetonator">();
	}
	static class ABFGWeapon_IonDetonator* GetDefaultObj()
	{
		return GetDefaultObjImpl<ABFGWeapon_IonDetonator>();
	}
};
static_assert(alignof(ABFGWeapon_IonDetonator) == 0x000008, "Wrong alignment on ABFGWeapon_IonDetonator");
static_assert(sizeof(ABFGWeapon_IonDetonator) == 0x000848, "Wrong size on ABFGWeapon_IonDetonator");
static_assert(offsetof(ABFGWeapon_IonDetonator, M_tUpgradeTagTransmogrificationizer) == 0x000750, "Member 'ABFGWeapon_IonDetonator::M_tUpgradeTagTransmogrificationizer' has a wrong offset!");
static_assert(offsetof(ABFGWeapon_IonDetonator, M_tUpgradeTagTransmogrificationizatomaticulatorizer) == 0x000758, "Member 'ABFGWeapon_IonDetonator::M_tUpgradeTagTransmogrificationizatomaticulatorizer' has a wrong offset!");
static_assert(offsetof(ABFGWeapon_IonDetonator, M_tUpgradeTagTemporalDistortionator) == 0x000760, "Member 'ABFGWeapon_IonDetonator::M_tUpgradeTagTemporalDistortionator' has a wrong offset!");
static_assert(offsetof(ABFGWeapon_IonDetonator, M_tUpgradeTagIonStorageBeta) == 0x000768, "Member 'ABFGWeapon_IonDetonator::M_tUpgradeTagIonStorageBeta' has a wrong offset!");
static_assert(offsetof(ABFGWeapon_IonDetonator, M_tUpgradeTagIonStorageZeta) == 0x000770, "Member 'ABFGWeapon_IonDetonator::M_tUpgradeTagIonStorageZeta' has a wrong offset!");
static_assert(offsetof(ABFGWeapon_IonDetonator, M_tUpgradeTagIonVortexCoils) == 0x000778, "Member 'ABFGWeapon_IonDetonator::M_tUpgradeTagIonVortexCoils' has a wrong offset!");
static_assert(offsetof(ABFGWeapon_IonDetonator, M_fMaxChargeTime) == 0x000780, "Member 'ABFGWeapon_IonDetonator::M_fMaxChargeTime' has a wrong offset!");
static_assert(offsetof(ABFGWeapon_IonDetonator, M_fMinProjectileSpeed) == 0x000784, "Member 'ABFGWeapon_IonDetonator::M_fMinProjectileSpeed' has a wrong offset!");
static_assert(offsetof(ABFGWeapon_IonDetonator, M_fMaxProjectileSpeed) == 0x000788, "Member 'ABFGWeapon_IonDetonator::M_fMaxProjectileSpeed' has a wrong offset!");
static_assert(offsetof(ABFGWeapon_IonDetonator, M_fProjectileAngle) == 0x00078C, "Member 'ABFGWeapon_IonDetonator::M_fProjectileAngle' has a wrong offset!");
static_assert(offsetof(ABFGWeapon_IonDetonator, M_oWeaponMarkerPath) == 0x000790, "Member 'ABFGWeapon_IonDetonator::M_oWeaponMarkerPath' has a wrong offset!");
static_assert(offsetof(ABFGWeapon_IonDetonator, M_oWeaponMarketBounceColour) == 0x0007A8, "Member 'ABFGWeapon_IonDetonator::M_oWeaponMarketBounceColour' has a wrong offset!");
static_assert(offsetof(ABFGWeapon_IonDetonator, M_oWeaponMarketNoBounceColour) == 0x0007AC, "Member 'ABFGWeapon_IonDetonator::M_oWeaponMarketNoBounceColour' has a wrong offset!");
static_assert(offsetof(ABFGWeapon_IonDetonator, M_pWeaponMarker) == 0x0007B0, "Member 'ABFGWeapon_IonDetonator::M_pWeaponMarker' has a wrong offset!");
static_assert(offsetof(ABFGWeapon_IonDetonator, M_pProjectile) == 0x0007C0, "Member 'ABFGWeapon_IonDetonator::M_pProjectile' has a wrong offset!");
static_assert(offsetof(ABFGWeapon_IonDetonator, M_iIonStorageBeta_ExtraAmmoCount) == 0x0007CC, "Member 'ABFGWeapon_IonDetonator::M_iIonStorageBeta_ExtraAmmoCount' has a wrong offset!");
static_assert(offsetof(ABFGWeapon_IonDetonator, M_iIonStorageZeta_ExtraAmmoCount) == 0x0007D0, "Member 'ABFGWeapon_IonDetonator::M_iIonStorageZeta_ExtraAmmoCount' has a wrong offset!");
static_assert(offsetof(ABFGWeapon_IonDetonator, M_oTemporalDistortionatorTimeModifier) == 0x0007D4, "Member 'ABFGWeapon_IonDetonator::M_oTemporalDistortionatorTimeModifier' has a wrong offset!");
static_assert(offsetof(ABFGWeapon_IonDetonator, M_fTemporalDistortionatorSheildRegenerationRate) == 0x0007F0, "Member 'ABFGWeapon_IonDetonator::M_fTemporalDistortionatorSheildRegenerationRate' has a wrong offset!");
static_assert(offsetof(ABFGWeapon_IonDetonator, M_oIonVortexCoilsRadius) == 0x0007F8, "Member 'ABFGWeapon_IonDetonator::M_oIonVortexCoilsRadius' has a wrong offset!");
static_assert(offsetof(ABFGWeapon_IonDetonator, M_vIonVortexCoilsRadius) == 0x0007FC, "Member 'ABFGWeapon_IonDetonator::M_vIonVortexCoilsRadius' has a wrong offset!");
static_assert(offsetof(ABFGWeapon_IonDetonator, M_aIonVortexCoilsMaxWeightClassData) == 0x000808, "Member 'ABFGWeapon_IonDetonator::M_aIonVortexCoilsMaxWeightClassData' has a wrong offset!");
static_assert(offsetof(ABFGWeapon_IonDetonator, M_fTransmogrificationizerProbability) == 0x000818, "Member 'ABFGWeapon_IonDetonator::M_fTransmogrificationizerProbability' has a wrong offset!");
static_assert(offsetof(ABFGWeapon_IonDetonator, M_fTransmogrificationizatomaticulatorizerProbability) == 0x00081C, "Member 'ABFGWeapon_IonDetonator::M_fTransmogrificationizatomaticulatorizerProbability' has a wrong offset!");
static_assert(offsetof(ABFGWeapon_IonDetonator, M_oTransmogrifierClass) == 0x000820, "Member 'ABFGWeapon_IonDetonator::M_oTransmogrifierClass' has a wrong offset!");
static_assert(offsetof(ABFGWeapon_IonDetonator, M_fTransmogrifierRadius) == 0x000838, "Member 'ABFGWeapon_IonDetonator::M_fTransmogrifierRadius' has a wrong offset!");
static_assert(offsetof(ABFGWeapon_IonDetonator, M_pCachedTransmogrifierClass) == 0x000840, "Member 'ABFGWeapon_IonDetonator::M_pCachedTransmogrifierClass' has a wrong offset!");

// Class BFGCore.BFGInputAxis_UI
// 0x0000 (0x0028 - 0x0028)
class UBFGInputAxis_UI : public UBFGInputAxis
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"BFGInputAxis_UI">();
	}
	static class UBFGInputAxis_UI* GetDefaultObj()
	{
		return GetDefaultObjImpl<UBFGInputAxis_UI>();
	}
};
static_assert(alignof(UBFGInputAxis_UI) == 0x000008, "Wrong alignment on UBFGInputAxis_UI");
static_assert(sizeof(UBFGInputAxis_UI) == 0x000028, "Wrong size on UBFGInputAxis_UI");

// Class BFGCore.BFGInputAxis_UIAxis1
// 0x0000 (0x0028 - 0x0028)
class UBFGInputAxis_UIAxis1 final : public UBFGInputAxis_UI
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"BFGInputAxis_UIAxis1">();
	}
	static class UBFGInputAxis_UIAxis1* GetDefaultObj()
	{
		return GetDefaultObjImpl<UBFGInputAxis_UIAxis1>();
	}
};
static_assert(alignof(UBFGInputAxis_UIAxis1) == 0x000008, "Wrong alignment on UBFGInputAxis_UIAxis1");
static_assert(sizeof(UBFGInputAxis_UIAxis1) == 0x000028, "Wrong size on UBFGInputAxis_UIAxis1");

// Class BFGCore.BFGInputAxis_UIAxis2
// 0x0000 (0x0028 - 0x0028)
class UBFGInputAxis_UIAxis2 final : public UBFGInputAxis_UI
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"BFGInputAxis_UIAxis2">();
	}
	static class UBFGInputAxis_UIAxis2* GetDefaultObj()
	{
		return GetDefaultObjImpl<UBFGInputAxis_UIAxis2>();
	}
};
static_assert(alignof(UBFGInputAxis_UIAxis2) == 0x000008, "Wrong alignment on UBFGInputAxis_UIAxis2");
static_assert(sizeof(UBFGInputAxis_UIAxis2) == 0x000028, "Wrong size on UBFGInputAxis_UIAxis2");

// Class BFGCore.BFGInputAxis_UIAxis3
// 0x0000 (0x0028 - 0x0028)
class UBFGInputAxis_UIAxis3 final : public UBFGInputAxis_UI
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"BFGInputAxis_UIAxis3">();
	}
	static class UBFGInputAxis_UIAxis3* GetDefaultObj()
	{
		return GetDefaultObjImpl<UBFGInputAxis_UIAxis3>();
	}
};
static_assert(alignof(UBFGInputAxis_UIAxis3) == 0x000008, "Wrong alignment on UBFGInputAxis_UIAxis3");
static_assert(sizeof(UBFGInputAxis_UIAxis3) == 0x000028, "Wrong size on UBFGInputAxis_UIAxis3");

// Class BFGCore.BFGWeapon_RoboprezAOE
// 0x0008 (0x0930 - 0x0928)
class ABFGWeapon_RoboprezAOE : public ABFGWeapon_BossAOE
{
public:
	float                                         M_fVirtualAimHeight;                               // 0x0928(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_92C[0x4];                                      // 0x092C(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"BFGWeapon_RoboprezAOE">();
	}
	static class ABFGWeapon_RoboprezAOE* GetDefaultObj()
	{
		return GetDefaultObjImpl<ABFGWeapon_RoboprezAOE>();
	}
};
static_assert(alignof(ABFGWeapon_RoboprezAOE) == 0x000008, "Wrong alignment on ABFGWeapon_RoboprezAOE");
static_assert(sizeof(ABFGWeapon_RoboprezAOE) == 0x000930, "Wrong size on ABFGWeapon_RoboprezAOE");
static_assert(offsetof(ABFGWeapon_RoboprezAOE, M_fVirtualAimHeight) == 0x000928, "Member 'ABFGWeapon_RoboprezAOE::M_fVirtualAimHeight' has a wrong offset!");

// Class BFGCore.BFGInputAxis_UIAxis4
// 0x0000 (0x0028 - 0x0028)
class UBFGInputAxis_UIAxis4 final : public UBFGInputAxis_UI
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"BFGInputAxis_UIAxis4">();
	}
	static class UBFGInputAxis_UIAxis4* GetDefaultObj()
	{
		return GetDefaultObjImpl<UBFGInputAxis_UIAxis4>();
	}
};
static_assert(alignof(UBFGInputAxis_UIAxis4) == 0x000008, "Wrong alignment on UBFGInputAxis_UIAxis4");
static_assert(sizeof(UBFGInputAxis_UIAxis4) == 0x000028, "Wrong size on UBFGInputAxis_UIAxis4");

// Class BFGCore.BFGInputComponentUI
// 0x0010 (0x01C0 - 0x01B0)
class UBFGInputComponentUI final : public UBFGInputComponent
{
public:
	class UBFGActorComponent_InputActions*        M_pInputActions;                                   // 0x01B0(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UBFGInputUserWidget*                    M_pUserWidget;                                     // 0x01B8(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"BFGInputComponentUI">();
	}
	static class UBFGInputComponentUI* GetDefaultObj()
	{
		return GetDefaultObjImpl<UBFGInputComponentUI>();
	}
};
static_assert(alignof(UBFGInputComponentUI) == 0x000008, "Wrong alignment on UBFGInputComponentUI");
static_assert(sizeof(UBFGInputComponentUI) == 0x0001C0, "Wrong size on UBFGInputComponentUI");
static_assert(offsetof(UBFGInputComponentUI, M_pInputActions) == 0x0001B0, "Member 'UBFGInputComponentUI::M_pInputActions' has a wrong offset!");
static_assert(offsetof(UBFGInputComponentUI, M_pUserWidget) == 0x0001B8, "Member 'UBFGInputComponentUI::M_pUserWidget' has a wrong offset!");

// Class BFGCore.BFGWeapon_UFO_DeathRay
// 0x0048 (0x0788 - 0x0740)
class ABFGWeapon_UFO_DeathRay : public ABFGWeapon_BaseRay
{
public:
	struct FGameplayTag                           M_tUpgradeTagNuclearBlisterInducer;                // 0x0740(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, DisableEditOnInstance, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FGameplayTag                           M_tUpgradeTagNuclearUlcerator;                     // 0x0748(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, DisableEditOnInstance, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FGameplayTag                           M_tUpgradeTagFusionScorcher;                       // 0x0750(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, DisableEditOnInstance, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FGameplayTag                           M_tUpgradeTagLiquidN2Cooling;                      // 0x0758(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, DisableEditOnInstance, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FGameplayTag                           M_tUpgradeTagLiquidNaKCooling;                     // 0x0760(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, DisableEditOnInstance, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FGameplayTag                           M_tUpgradeTagSuperfluidHeatExhaust;                // 0x0768(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, DisableEditOnInstance, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         M_fNuclearBlisterInducer_Duration;                 // 0x0770(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         M_fNuclearUlcerator_Duration;                      // 0x0774(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         M_fFusionScorcher_DeadzoneTickDamage;              // 0x0778(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         M_fLiquidN2Cooling_MaxCharge;                      // 0x077C(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         M_fLiquidNaKCooling_MaxCharge;                     // 0x0780(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         M_fSuperfluidHeatExhaust_BonusRegenerationFactor;  // 0x0784(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"BFGWeapon_UFO_DeathRay">();
	}
	static class ABFGWeapon_UFO_DeathRay* GetDefaultObj()
	{
		return GetDefaultObjImpl<ABFGWeapon_UFO_DeathRay>();
	}
};
static_assert(alignof(ABFGWeapon_UFO_DeathRay) == 0x000008, "Wrong alignment on ABFGWeapon_UFO_DeathRay");
static_assert(sizeof(ABFGWeapon_UFO_DeathRay) == 0x000788, "Wrong size on ABFGWeapon_UFO_DeathRay");
static_assert(offsetof(ABFGWeapon_UFO_DeathRay, M_tUpgradeTagNuclearBlisterInducer) == 0x000740, "Member 'ABFGWeapon_UFO_DeathRay::M_tUpgradeTagNuclearBlisterInducer' has a wrong offset!");
static_assert(offsetof(ABFGWeapon_UFO_DeathRay, M_tUpgradeTagNuclearUlcerator) == 0x000748, "Member 'ABFGWeapon_UFO_DeathRay::M_tUpgradeTagNuclearUlcerator' has a wrong offset!");
static_assert(offsetof(ABFGWeapon_UFO_DeathRay, M_tUpgradeTagFusionScorcher) == 0x000750, "Member 'ABFGWeapon_UFO_DeathRay::M_tUpgradeTagFusionScorcher' has a wrong offset!");
static_assert(offsetof(ABFGWeapon_UFO_DeathRay, M_tUpgradeTagLiquidN2Cooling) == 0x000758, "Member 'ABFGWeapon_UFO_DeathRay::M_tUpgradeTagLiquidN2Cooling' has a wrong offset!");
static_assert(offsetof(ABFGWeapon_UFO_DeathRay, M_tUpgradeTagLiquidNaKCooling) == 0x000760, "Member 'ABFGWeapon_UFO_DeathRay::M_tUpgradeTagLiquidNaKCooling' has a wrong offset!");
static_assert(offsetof(ABFGWeapon_UFO_DeathRay, M_tUpgradeTagSuperfluidHeatExhaust) == 0x000768, "Member 'ABFGWeapon_UFO_DeathRay::M_tUpgradeTagSuperfluidHeatExhaust' has a wrong offset!");
static_assert(offsetof(ABFGWeapon_UFO_DeathRay, M_fNuclearBlisterInducer_Duration) == 0x000770, "Member 'ABFGWeapon_UFO_DeathRay::M_fNuclearBlisterInducer_Duration' has a wrong offset!");
static_assert(offsetof(ABFGWeapon_UFO_DeathRay, M_fNuclearUlcerator_Duration) == 0x000774, "Member 'ABFGWeapon_UFO_DeathRay::M_fNuclearUlcerator_Duration' has a wrong offset!");
static_assert(offsetof(ABFGWeapon_UFO_DeathRay, M_fFusionScorcher_DeadzoneTickDamage) == 0x000778, "Member 'ABFGWeapon_UFO_DeathRay::M_fFusionScorcher_DeadzoneTickDamage' has a wrong offset!");
static_assert(offsetof(ABFGWeapon_UFO_DeathRay, M_fLiquidN2Cooling_MaxCharge) == 0x00077C, "Member 'ABFGWeapon_UFO_DeathRay::M_fLiquidN2Cooling_MaxCharge' has a wrong offset!");
static_assert(offsetof(ABFGWeapon_UFO_DeathRay, M_fLiquidNaKCooling_MaxCharge) == 0x000780, "Member 'ABFGWeapon_UFO_DeathRay::M_fLiquidNaKCooling_MaxCharge' has a wrong offset!");
static_assert(offsetof(ABFGWeapon_UFO_DeathRay, M_fSuperfluidHeatExhaust_BonusRegenerationFactor) == 0x000784, "Member 'ABFGWeapon_UFO_DeathRay::M_fSuperfluidHeatExhaust_BonusRegenerationFactor' has a wrong offset!");

// Class BFGCore.BFGInputPack
// 0x0050 (0x0078 - 0x0028)
class UBFGInputPack final : public UObject
{
public:
	class FString                                 M_strName;                                         // 0x0028(0x0010)(Edit, ZeroConstructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	int32                                         M_iInputSchemeIndex;                               // 0x0038(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_3C[0x4];                                       // 0x003C(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class UBFGInputScheme*                        M_pCryptoInputScheme;                              // 0x0040(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UBFGInputScheme*                        M_pUFOInputScheme;                                 // 0x0048(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UBFGInputScheme*                        M_pHolobobInputScheme;                             // 0x0050(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UBFGInputScheme*                        M_pUIInputScheme;                                  // 0x0058(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          M_bUseAimAssit;                                    // 0x0060(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_61[0x3];                                       // 0x0061(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         M_fScreenAppoximationOffset;                       // 0x0064(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UCurveFloat*                            M_pDefaultCameraSpeedCoefCurve;                    // 0x0068(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          M_bUseExplorationCamera;                           // 0x0070(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_71[0x7];                                       // 0x0071(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	class UCurveFloat* GetDefaultCameraSpeedCoefCurve() const;
	class UBFGInputScheme* GetInputScheme(EInputSchemeIdentifier _eIdenfier) const;
	int32 GetInputSchemeIndex() const;
	class FString GetName() const;
	float GetScreenApproximationOffset() const;
	bool GetUseAimAssist() const;
	bool GetUseExplorationCamera() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"BFGInputPack">();
	}
	static class UBFGInputPack* GetDefaultObj()
	{
		return GetDefaultObjImpl<UBFGInputPack>();
	}
};
static_assert(alignof(UBFGInputPack) == 0x000008, "Wrong alignment on UBFGInputPack");
static_assert(sizeof(UBFGInputPack) == 0x000078, "Wrong size on UBFGInputPack");
static_assert(offsetof(UBFGInputPack, M_strName) == 0x000028, "Member 'UBFGInputPack::M_strName' has a wrong offset!");
static_assert(offsetof(UBFGInputPack, M_iInputSchemeIndex) == 0x000038, "Member 'UBFGInputPack::M_iInputSchemeIndex' has a wrong offset!");
static_assert(offsetof(UBFGInputPack, M_pCryptoInputScheme) == 0x000040, "Member 'UBFGInputPack::M_pCryptoInputScheme' has a wrong offset!");
static_assert(offsetof(UBFGInputPack, M_pUFOInputScheme) == 0x000048, "Member 'UBFGInputPack::M_pUFOInputScheme' has a wrong offset!");
static_assert(offsetof(UBFGInputPack, M_pHolobobInputScheme) == 0x000050, "Member 'UBFGInputPack::M_pHolobobInputScheme' has a wrong offset!");
static_assert(offsetof(UBFGInputPack, M_pUIInputScheme) == 0x000058, "Member 'UBFGInputPack::M_pUIInputScheme' has a wrong offset!");
static_assert(offsetof(UBFGInputPack, M_bUseAimAssit) == 0x000060, "Member 'UBFGInputPack::M_bUseAimAssit' has a wrong offset!");
static_assert(offsetof(UBFGInputPack, M_fScreenAppoximationOffset) == 0x000064, "Member 'UBFGInputPack::M_fScreenAppoximationOffset' has a wrong offset!");
static_assert(offsetof(UBFGInputPack, M_pDefaultCameraSpeedCoefCurve) == 0x000068, "Member 'UBFGInputPack::M_pDefaultCameraSpeedCoefCurve' has a wrong offset!");
static_assert(offsetof(UBFGInputPack, M_bUseExplorationCamera) == 0x000070, "Member 'UBFGInputPack::M_bUseExplorationCamera' has a wrong offset!");

// Class BFGCore.BFGInputRebindingSystem
// 0x0030 (0x0060 - 0x0030)
class UBFGInputRebindingSystem : public UBFGGameSystem
{
public:
	class ABFGGameState*                          M_pGameState;                                      // 0x0030(0x0008)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	int32                                         M_iDefaultRebindingsVersion;                       // 0x0038(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_3C[0x4];                                       // 0x003C(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<struct FBFGInputRebinding>             M_apDefaultRebindings;                             // 0x0040(0x0010)(Edit, ZeroConstructor, Protected, NativeAccessSpecifierProtected)
	TArray<struct FKey>                           M_aForbiddenKeys;                                  // 0x0050(0x0010)(Edit, ZeroConstructor, Protected, NativeAccessSpecifierProtected)

public:
	void OnSaveActionDone(class UBFGSaveSystem* _pSaveSystem, class UBFGSaveSystem_Action* _pAction, EBFGSaveSystem_ActionResult _result);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"BFGInputRebindingSystem">();
	}
	static class UBFGInputRebindingSystem* GetDefaultObj()
	{
		return GetDefaultObjImpl<UBFGInputRebindingSystem>();
	}
};
static_assert(alignof(UBFGInputRebindingSystem) == 0x000008, "Wrong alignment on UBFGInputRebindingSystem");
static_assert(sizeof(UBFGInputRebindingSystem) == 0x000060, "Wrong size on UBFGInputRebindingSystem");
static_assert(offsetof(UBFGInputRebindingSystem, M_pGameState) == 0x000030, "Member 'UBFGInputRebindingSystem::M_pGameState' has a wrong offset!");
static_assert(offsetof(UBFGInputRebindingSystem, M_iDefaultRebindingsVersion) == 0x000038, "Member 'UBFGInputRebindingSystem::M_iDefaultRebindingsVersion' has a wrong offset!");
static_assert(offsetof(UBFGInputRebindingSystem, M_apDefaultRebindings) == 0x000040, "Member 'UBFGInputRebindingSystem::M_apDefaultRebindings' has a wrong offset!");
static_assert(offsetof(UBFGInputRebindingSystem, M_aForbiddenKeys) == 0x000050, "Member 'UBFGInputRebindingSystem::M_aForbiddenKeys' has a wrong offset!");

// Class BFGCore.BFGInputSettings
// 0x0140 (0x0178 - 0x0038)
class UBFGInputSettings final : public UDeveloperSettings
{
public:
	float                                         M_fBFGInput_Sensitivity_CryptoMouse_Min;           // 0x0038(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Config, DisableEditOnInstance, GlobalConfig, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         M_fBFGInput_Sensitivity_CryptoMouse_Mid;           // 0x003C(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Config, DisableEditOnInstance, GlobalConfig, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         M_fBFGInput_Sensitivity_CryptoMouse_Max;           // 0x0040(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Config, DisableEditOnInstance, GlobalConfig, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         M_fBFGInput_Sensitivity_UFOMouse_Min;              // 0x0044(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Config, DisableEditOnInstance, GlobalConfig, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         M_fBFGInput_Sensitivity_UFOMouse_Mid;              // 0x0048(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Config, DisableEditOnInstance, GlobalConfig, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         M_fBFGInput_Sensitivity_UFOMouse_Max;              // 0x004C(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Config, DisableEditOnInstance, GlobalConfig, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         M_fBFGInput_Sensitivity_CryptoGamepad_Min;         // 0x0050(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Config, DisableEditOnInstance, GlobalConfig, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         M_fBFGInput_Sensitivity_CryptoGamepad_Mid;         // 0x0054(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Config, DisableEditOnInstance, GlobalConfig, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         M_fBFGInput_Sensitivity_CryptoGamepad_Max;         // 0x0058(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Config, DisableEditOnInstance, GlobalConfig, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         M_fBFGInput_Sensitivity_UFOGamepad_Min;            // 0x005C(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Config, DisableEditOnInstance, GlobalConfig, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         M_fBFGInput_Sensitivity_UFOGamepad_Mid;            // 0x0060(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Config, DisableEditOnInstance, GlobalConfig, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         M_fBFGInput_Sensitivity_UFOGamepad_Max;            // 0x0064(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Config, DisableEditOnInstance, GlobalConfig, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TSoftObjectPtr<class UBFGInputScheme>         M_pDefaultUIScheme;                                // 0x0068(0x0028)(Edit, Config, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TArray<TSoftObjectPtr<class UBFGInputPack>>   M_aInputPacks;                                     // 0x0090(0x0010)(Edit, ZeroConstructor, Config, Protected, UObjectWrapper, NativeAccessSpecifierProtected)
	TArray<class UObject*>                        M_apCachedData;                                    // 0x00A0(0x0010)(ZeroConstructor, Transient, Protected, NativeAccessSpecifierProtected)
	TSoftObjectPtr<class UDataTable>              M_pTableButtonSpritesOrbis;                        // 0x00B0(0x0028)(Edit, Config, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TSoftObjectPtr<class UDataTable>              M_pTableButtonSpritesDurango;                      // 0x00D8(0x0028)(Edit, Config, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TSoftObjectPtr<class UDataTable>              M_pTableLocalizedKeyNamesOrbis;                    // 0x0100(0x0028)(Edit, Config, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TSoftObjectPtr<class UDataTable>              M_pTableLocalizedKeyNamesDurango;                  // 0x0128(0x0028)(Edit, Config, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TSoftObjectPtr<class UDataTable>              M_pTableLocalizedActionNames;                      // 0x0150(0x0028)(Edit, Config, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)

public:
	static class UBFGInputSettings* GetSettings();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"BFGInputSettings">();
	}
	static class UBFGInputSettings* GetDefaultObj()
	{
		return GetDefaultObjImpl<UBFGInputSettings>();
	}
};
static_assert(alignof(UBFGInputSettings) == 0x000008, "Wrong alignment on UBFGInputSettings");
static_assert(sizeof(UBFGInputSettings) == 0x000178, "Wrong size on UBFGInputSettings");
static_assert(offsetof(UBFGInputSettings, M_fBFGInput_Sensitivity_CryptoMouse_Min) == 0x000038, "Member 'UBFGInputSettings::M_fBFGInput_Sensitivity_CryptoMouse_Min' has a wrong offset!");
static_assert(offsetof(UBFGInputSettings, M_fBFGInput_Sensitivity_CryptoMouse_Mid) == 0x00003C, "Member 'UBFGInputSettings::M_fBFGInput_Sensitivity_CryptoMouse_Mid' has a wrong offset!");
static_assert(offsetof(UBFGInputSettings, M_fBFGInput_Sensitivity_CryptoMouse_Max) == 0x000040, "Member 'UBFGInputSettings::M_fBFGInput_Sensitivity_CryptoMouse_Max' has a wrong offset!");
static_assert(offsetof(UBFGInputSettings, M_fBFGInput_Sensitivity_UFOMouse_Min) == 0x000044, "Member 'UBFGInputSettings::M_fBFGInput_Sensitivity_UFOMouse_Min' has a wrong offset!");
static_assert(offsetof(UBFGInputSettings, M_fBFGInput_Sensitivity_UFOMouse_Mid) == 0x000048, "Member 'UBFGInputSettings::M_fBFGInput_Sensitivity_UFOMouse_Mid' has a wrong offset!");
static_assert(offsetof(UBFGInputSettings, M_fBFGInput_Sensitivity_UFOMouse_Max) == 0x00004C, "Member 'UBFGInputSettings::M_fBFGInput_Sensitivity_UFOMouse_Max' has a wrong offset!");
static_assert(offsetof(UBFGInputSettings, M_fBFGInput_Sensitivity_CryptoGamepad_Min) == 0x000050, "Member 'UBFGInputSettings::M_fBFGInput_Sensitivity_CryptoGamepad_Min' has a wrong offset!");
static_assert(offsetof(UBFGInputSettings, M_fBFGInput_Sensitivity_CryptoGamepad_Mid) == 0x000054, "Member 'UBFGInputSettings::M_fBFGInput_Sensitivity_CryptoGamepad_Mid' has a wrong offset!");
static_assert(offsetof(UBFGInputSettings, M_fBFGInput_Sensitivity_CryptoGamepad_Max) == 0x000058, "Member 'UBFGInputSettings::M_fBFGInput_Sensitivity_CryptoGamepad_Max' has a wrong offset!");
static_assert(offsetof(UBFGInputSettings, M_fBFGInput_Sensitivity_UFOGamepad_Min) == 0x00005C, "Member 'UBFGInputSettings::M_fBFGInput_Sensitivity_UFOGamepad_Min' has a wrong offset!");
static_assert(offsetof(UBFGInputSettings, M_fBFGInput_Sensitivity_UFOGamepad_Mid) == 0x000060, "Member 'UBFGInputSettings::M_fBFGInput_Sensitivity_UFOGamepad_Mid' has a wrong offset!");
static_assert(offsetof(UBFGInputSettings, M_fBFGInput_Sensitivity_UFOGamepad_Max) == 0x000064, "Member 'UBFGInputSettings::M_fBFGInput_Sensitivity_UFOGamepad_Max' has a wrong offset!");
static_assert(offsetof(UBFGInputSettings, M_pDefaultUIScheme) == 0x000068, "Member 'UBFGInputSettings::M_pDefaultUIScheme' has a wrong offset!");
static_assert(offsetof(UBFGInputSettings, M_aInputPacks) == 0x000090, "Member 'UBFGInputSettings::M_aInputPacks' has a wrong offset!");
static_assert(offsetof(UBFGInputSettings, M_apCachedData) == 0x0000A0, "Member 'UBFGInputSettings::M_apCachedData' has a wrong offset!");
static_assert(offsetof(UBFGInputSettings, M_pTableButtonSpritesOrbis) == 0x0000B0, "Member 'UBFGInputSettings::M_pTableButtonSpritesOrbis' has a wrong offset!");
static_assert(offsetof(UBFGInputSettings, M_pTableButtonSpritesDurango) == 0x0000D8, "Member 'UBFGInputSettings::M_pTableButtonSpritesDurango' has a wrong offset!");
static_assert(offsetof(UBFGInputSettings, M_pTableLocalizedKeyNamesOrbis) == 0x000100, "Member 'UBFGInputSettings::M_pTableLocalizedKeyNamesOrbis' has a wrong offset!");
static_assert(offsetof(UBFGInputSettings, M_pTableLocalizedKeyNamesDurango) == 0x000128, "Member 'UBFGInputSettings::M_pTableLocalizedKeyNamesDurango' has a wrong offset!");
static_assert(offsetof(UBFGInputSettings, M_pTableLocalizedActionNames) == 0x000150, "Member 'UBFGInputSettings::M_pTableLocalizedActionNames' has a wrong offset!");

// Class BFGCore.BFGInteractableNoState
// 0x0000 (0x0428 - 0x0428)
class ABFGInteractableNoState : public ABFGInteractable
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"BFGInteractableNoState">();
	}
	static class ABFGInteractableNoState* GetDefaultObj()
	{
		return GetDefaultObjImpl<ABFGInteractableNoState>();
	}
};
static_assert(alignof(ABFGInteractableNoState) == 0x000008, "Wrong alignment on ABFGInteractableNoState");
static_assert(sizeof(ABFGInteractableNoState) == 0x000428, "Wrong size on ABFGInteractableNoState");

// Class BFGCore.BFGInteractAnimationObjectItemCollectionBase
// 0x0028 (0x00D0 - 0x00A8)
class UBFGInteractAnimationObjectItemCollectionBase : public UBFGInteractAnimationObject
{
public:
	TArray<struct FBFGInteractAnimationData>      M_aAnimations;                                     // 0x00A8(0x0010)(ZeroConstructor, Transient, Protected, NativeAccessSpecifierProtected)
	int32                                         M_iNextAnimation;                                  // 0x00B8(0x0004)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_BC[0x4];                                       // 0x00BC(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<struct FBFGInteractAnimationAssetData> M_aAnimationsAssetData;                            // 0x00C0(0x0010)(ZeroConstructor, Transient, Protected, NativeAccessSpecifierProtected)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"BFGInteractAnimationObjectItemCollectionBase">();
	}
	static class UBFGInteractAnimationObjectItemCollectionBase* GetDefaultObj()
	{
		return GetDefaultObjImpl<UBFGInteractAnimationObjectItemCollectionBase>();
	}
};
static_assert(alignof(UBFGInteractAnimationObjectItemCollectionBase) == 0x000008, "Wrong alignment on UBFGInteractAnimationObjectItemCollectionBase");
static_assert(sizeof(UBFGInteractAnimationObjectItemCollectionBase) == 0x0000D0, "Wrong size on UBFGInteractAnimationObjectItemCollectionBase");
static_assert(offsetof(UBFGInteractAnimationObjectItemCollectionBase, M_aAnimations) == 0x0000A8, "Member 'UBFGInteractAnimationObjectItemCollectionBase::M_aAnimations' has a wrong offset!");
static_assert(offsetof(UBFGInteractAnimationObjectItemCollectionBase, M_iNextAnimation) == 0x0000B8, "Member 'UBFGInteractAnimationObjectItemCollectionBase::M_iNextAnimation' has a wrong offset!");
static_assert(offsetof(UBFGInteractAnimationObjectItemCollectionBase, M_aAnimationsAssetData) == 0x0000C0, "Member 'UBFGInteractAnimationObjectItemCollectionBase::M_aAnimationsAssetData' has a wrong offset!");

// Class BFGCore.BFGInteractAnimationObjectItemRandomization
// 0x0010 (0x00E0 - 0x00D0)
class UBFGInteractAnimationObjectItemRandomization final : public UBFGInteractAnimationObjectItemCollectionBase
{
public:
	bool                                          M_bPlayingVariation;                               // 0x00D0(0x0001)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_D1[0x3];                                       // 0x00D1(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	int32                                         M_iSelectedVariation;                              // 0x00D4(0x0004)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	int32                                         M_iLastPlayedAnimationIndex;                       // 0x00D8(0x0004)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          M_bIsDialog;                                       // 0x00DC(0x0001)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_DD[0x3];                                       // 0x00DD(0x0003)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"BFGInteractAnimationObjectItemRandomization">();
	}
	static class UBFGInteractAnimationObjectItemRandomization* GetDefaultObj()
	{
		return GetDefaultObjImpl<UBFGInteractAnimationObjectItemRandomization>();
	}
};
static_assert(alignof(UBFGInteractAnimationObjectItemRandomization) == 0x000008, "Wrong alignment on UBFGInteractAnimationObjectItemRandomization");
static_assert(sizeof(UBFGInteractAnimationObjectItemRandomization) == 0x0000E0, "Wrong size on UBFGInteractAnimationObjectItemRandomization");
static_assert(offsetof(UBFGInteractAnimationObjectItemRandomization, M_bPlayingVariation) == 0x0000D0, "Member 'UBFGInteractAnimationObjectItemRandomization::M_bPlayingVariation' has a wrong offset!");
static_assert(offsetof(UBFGInteractAnimationObjectItemRandomization, M_iSelectedVariation) == 0x0000D4, "Member 'UBFGInteractAnimationObjectItemRandomization::M_iSelectedVariation' has a wrong offset!");
static_assert(offsetof(UBFGInteractAnimationObjectItemRandomization, M_iLastPlayedAnimationIndex) == 0x0000D8, "Member 'UBFGInteractAnimationObjectItemRandomization::M_iLastPlayedAnimationIndex' has a wrong offset!");
static_assert(offsetof(UBFGInteractAnimationObjectItemRandomization, M_bIsDialog) == 0x0000DC, "Member 'UBFGInteractAnimationObjectItemRandomization::M_bIsDialog' has a wrong offset!");

// Class BFGCore.BFGInteractAnimationObjectItemSequence
// 0x0008 (0x00D8 - 0x00D0)
class UBFGInteractAnimationObjectItemSequence final : public UBFGInteractAnimationObjectItemCollectionBase
{
public:
	int32                                         M_iCurrentlyPlayingItem;                           // 0x00D0(0x0004)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_D4[0x4];                                       // 0x00D4(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"BFGInteractAnimationObjectItemSequence">();
	}
	static class UBFGInteractAnimationObjectItemSequence* GetDefaultObj()
	{
		return GetDefaultObjImpl<UBFGInteractAnimationObjectItemSequence>();
	}
};
static_assert(alignof(UBFGInteractAnimationObjectItemSequence) == 0x000008, "Wrong alignment on UBFGInteractAnimationObjectItemSequence");
static_assert(sizeof(UBFGInteractAnimationObjectItemSequence) == 0x0000D8, "Wrong size on UBFGInteractAnimationObjectItemSequence");
static_assert(offsetof(UBFGInteractAnimationObjectItemSequence, M_iCurrentlyPlayingItem) == 0x0000D0, "Member 'UBFGInteractAnimationObjectItemSequence::M_iCurrentlyPlayingItem' has a wrong offset!");

// Class BFGCore.BFGItemAnalProbeAmmo
// 0x0040 (0x0508 - 0x04C8)
class ABFGItemAnalProbeAmmo : public ABFGItemValuePack
{
public:
	float                                         M_fBrainPickupRadius;                              // 0x04C8(0x0004)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         M_fHomingAcceleration;                             // 0x04CC(0x0004)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         M_fHomingStartSpeed;                               // 0x04D0(0x0004)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         M_fHomingMaxSpeed;                                 // 0x04D4(0x0004)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         M_fStartMovingToTargetDelay;                       // 0x04D8(0x0004)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         M_fReturnTimeout;                                  // 0x04DC(0x0004)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	struct FVector                                M_vStartWaitMovement;                              // 0x04E0(0x000C)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_4EC[0xC];                                      // 0x04EC(0x000C)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<class AActor*>                         M_aPickedUpBrains;                                 // 0x04F8(0x0010)(ZeroConstructor, Protected, NativeAccessSpecifierProtected)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"BFGItemAnalProbeAmmo">();
	}
	static class ABFGItemAnalProbeAmmo* GetDefaultObj()
	{
		return GetDefaultObjImpl<ABFGItemAnalProbeAmmo>();
	}
};
static_assert(alignof(ABFGItemAnalProbeAmmo) == 0x000008, "Wrong alignment on ABFGItemAnalProbeAmmo");
static_assert(sizeof(ABFGItemAnalProbeAmmo) == 0x000508, "Wrong size on ABFGItemAnalProbeAmmo");
static_assert(offsetof(ABFGItemAnalProbeAmmo, M_fBrainPickupRadius) == 0x0004C8, "Member 'ABFGItemAnalProbeAmmo::M_fBrainPickupRadius' has a wrong offset!");
static_assert(offsetof(ABFGItemAnalProbeAmmo, M_fHomingAcceleration) == 0x0004CC, "Member 'ABFGItemAnalProbeAmmo::M_fHomingAcceleration' has a wrong offset!");
static_assert(offsetof(ABFGItemAnalProbeAmmo, M_fHomingStartSpeed) == 0x0004D0, "Member 'ABFGItemAnalProbeAmmo::M_fHomingStartSpeed' has a wrong offset!");
static_assert(offsetof(ABFGItemAnalProbeAmmo, M_fHomingMaxSpeed) == 0x0004D4, "Member 'ABFGItemAnalProbeAmmo::M_fHomingMaxSpeed' has a wrong offset!");
static_assert(offsetof(ABFGItemAnalProbeAmmo, M_fStartMovingToTargetDelay) == 0x0004D8, "Member 'ABFGItemAnalProbeAmmo::M_fStartMovingToTargetDelay' has a wrong offset!");
static_assert(offsetof(ABFGItemAnalProbeAmmo, M_fReturnTimeout) == 0x0004DC, "Member 'ABFGItemAnalProbeAmmo::M_fReturnTimeout' has a wrong offset!");
static_assert(offsetof(ABFGItemAnalProbeAmmo, M_vStartWaitMovement) == 0x0004E0, "Member 'ABFGItemAnalProbeAmmo::M_vStartWaitMovement' has a wrong offset!");
static_assert(offsetof(ABFGItemAnalProbeAmmo, M_aPickedUpBrains) == 0x0004F8, "Member 'ABFGItemAnalProbeAmmo::M_aPickedUpBrains' has a wrong offset!");

// Class BFGCore.BFGItemUnlock
// 0x0010 (0x04C8 - 0x04B8)
class ABFGItemUnlock final : public ABFGAutoPickupItem
{
public:
	struct FGameplayTag                           M_gameplayTagUnlock;                               // 0x04B8(0x0008)(Edit, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          M_bIsPermanentUnlock;                              // 0x04C0(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_4C1[0x7];                                      // 0x04C1(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"BFGItemUnlock">();
	}
	static class ABFGItemUnlock* GetDefaultObj()
	{
		return GetDefaultObjImpl<ABFGItemUnlock>();
	}
};
static_assert(alignof(ABFGItemUnlock) == 0x000008, "Wrong alignment on ABFGItemUnlock");
static_assert(sizeof(ABFGItemUnlock) == 0x0004C8, "Wrong size on ABFGItemUnlock");
static_assert(offsetof(ABFGItemUnlock, M_gameplayTagUnlock) == 0x0004B8, "Member 'ABFGItemUnlock::M_gameplayTagUnlock' has a wrong offset!");
static_assert(offsetof(ABFGItemUnlock, M_bIsPermanentUnlock) == 0x0004C0, "Member 'ABFGItemUnlock::M_bIsPermanentUnlock' has a wrong offset!");

// Class BFGCore.BFGWidget_HUD_WeaponStats
// 0x0120 (0x0418 - 0x02F8)
class UBFGWidget_HUD_WeaponStats : public UBFGWidget_HUD
{
public:
	uint8                                         Pad_2F8[0x8];                                      // 0x02F8(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	TSoftClassPtr<class UClass>                   M_pWeaponSlotClass;                                // 0x0300(0x0028)(Edit, BlueprintVisible, BlueprintReadOnly, DisableEditOnInstance, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         M_iAmmoCurrent;                                    // 0x0328(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         M_iAmmoMax;                                        // 0x032C(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   M_sWeaponName;                                     // 0x0330(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UBFGActorComponent_EquipmentManager*    M_pPlayerEquipmentManager;                         // 0x0338(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TArray<class UBFGUIQuickSlotItem*>            M_aQuickSlotInfo_Player;                           // 0x0340(0x0010)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, NativeAccessSpecifierPublic)
	TArray<class UBFGUIQuickSlotItem*>            M_aQuickSlotInfo_UFO;                              // 0x0350(0x0010)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, NativeAccessSpecifierPublic)
	class UBFGWeaponSlot*                         M_pActiveSlot;                                     // 0x0360(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TArray<class UBFGWeaponSlot*>                 M_apQuickSlots;                                    // 0x0368(0x0010)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, ContainsInstancedReference, NativeAccessSpecifierPublic)
	class UWidget*                                M_pContainerMain;                                  // 0x0378(0x0008)(Edit, BlueprintVisible, ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UWidget*                                M_pContainerActiveSlot;                            // 0x0380(0x0008)(Edit, BlueprintVisible, ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UWidget*                                M_pContainerQuickslots;                            // 0x0388(0x0008)(Edit, BlueprintVisible, ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UWidget*                                M_pContainerGamepadVersion;                        // 0x0390(0x0008)(Edit, BlueprintVisible, ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UWidget*                                M_pContainerKeyboardVersion;                       // 0x0398(0x0008)(Edit, BlueprintVisible, ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UWidget*                                M_pContainerAmmoInfinite;                          // 0x03A0(0x0008)(Edit, BlueprintVisible, ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UImage*                                 M_pImageJammedEffect;                              // 0x03A8(0x0008)(Edit, BlueprintVisible, ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UImage*                                 M_pImageScanlinesAmmo;                             // 0x03B0(0x0008)(Edit, BlueprintVisible, ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UImage*                                 M_pImageScanlinesWeapon;                           // 0x03B8(0x0008)(Edit, BlueprintVisible, ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UTextBlock*                             M_pTextPercent;                                    // 0x03C0(0x0008)(Edit, BlueprintVisible, ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UTextBlock*                             M_pTextAmmo;                                       // 0x03C8(0x0008)(Edit, BlueprintVisible, ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	struct FLinearColor                           M_oColorNormal;                                    // 0x03D0(0x0010)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	struct FLinearColor                           M_oColorJammed;                                    // 0x03E0(0x0010)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	struct FLinearColor                           M_oColorOverheated;                                // 0x03F0(0x0010)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_400[0x18];                                     // 0x0400(0x0018)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void AddQuickSlotToLayout(class UBFGWeaponSlot* _pSlot);
	TSubclassOf<class ABFGWeapon> GetActiveWeaponClass();
	void OnAllWeaponsEnabled(class UBFGActorComponent_EquipmentManager* _pEquipmentManager, bool _bEnabled);
	void OnInputDeviceSwitched(bool _bIsGamepad);
	void OnSwitchedToGroundMode(class APawn* _pPawn);
	void OnSwitchedToUFOMode(class APawn* _pPawn);
	void OnWeaponAmmoChanged(class ABFGWeapon* _pWeapon);
	void SetActiveSlot(class UBFGWeaponSlot* _pSlot);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"BFGWidget_HUD_WeaponStats">();
	}
	static class UBFGWidget_HUD_WeaponStats* GetDefaultObj()
	{
		return GetDefaultObjImpl<UBFGWidget_HUD_WeaponStats>();
	}
};
static_assert(alignof(UBFGWidget_HUD_WeaponStats) == 0x000008, "Wrong alignment on UBFGWidget_HUD_WeaponStats");
static_assert(sizeof(UBFGWidget_HUD_WeaponStats) == 0x000418, "Wrong size on UBFGWidget_HUD_WeaponStats");
static_assert(offsetof(UBFGWidget_HUD_WeaponStats, M_pWeaponSlotClass) == 0x000300, "Member 'UBFGWidget_HUD_WeaponStats::M_pWeaponSlotClass' has a wrong offset!");
static_assert(offsetof(UBFGWidget_HUD_WeaponStats, M_iAmmoCurrent) == 0x000328, "Member 'UBFGWidget_HUD_WeaponStats::M_iAmmoCurrent' has a wrong offset!");
static_assert(offsetof(UBFGWidget_HUD_WeaponStats, M_iAmmoMax) == 0x00032C, "Member 'UBFGWidget_HUD_WeaponStats::M_iAmmoMax' has a wrong offset!");
static_assert(offsetof(UBFGWidget_HUD_WeaponStats, M_sWeaponName) == 0x000330, "Member 'UBFGWidget_HUD_WeaponStats::M_sWeaponName' has a wrong offset!");
static_assert(offsetof(UBFGWidget_HUD_WeaponStats, M_pPlayerEquipmentManager) == 0x000338, "Member 'UBFGWidget_HUD_WeaponStats::M_pPlayerEquipmentManager' has a wrong offset!");
static_assert(offsetof(UBFGWidget_HUD_WeaponStats, M_aQuickSlotInfo_Player) == 0x000340, "Member 'UBFGWidget_HUD_WeaponStats::M_aQuickSlotInfo_Player' has a wrong offset!");
static_assert(offsetof(UBFGWidget_HUD_WeaponStats, M_aQuickSlotInfo_UFO) == 0x000350, "Member 'UBFGWidget_HUD_WeaponStats::M_aQuickSlotInfo_UFO' has a wrong offset!");
static_assert(offsetof(UBFGWidget_HUD_WeaponStats, M_pActiveSlot) == 0x000360, "Member 'UBFGWidget_HUD_WeaponStats::M_pActiveSlot' has a wrong offset!");
static_assert(offsetof(UBFGWidget_HUD_WeaponStats, M_apQuickSlots) == 0x000368, "Member 'UBFGWidget_HUD_WeaponStats::M_apQuickSlots' has a wrong offset!");
static_assert(offsetof(UBFGWidget_HUD_WeaponStats, M_pContainerMain) == 0x000378, "Member 'UBFGWidget_HUD_WeaponStats::M_pContainerMain' has a wrong offset!");
static_assert(offsetof(UBFGWidget_HUD_WeaponStats, M_pContainerActiveSlot) == 0x000380, "Member 'UBFGWidget_HUD_WeaponStats::M_pContainerActiveSlot' has a wrong offset!");
static_assert(offsetof(UBFGWidget_HUD_WeaponStats, M_pContainerQuickslots) == 0x000388, "Member 'UBFGWidget_HUD_WeaponStats::M_pContainerQuickslots' has a wrong offset!");
static_assert(offsetof(UBFGWidget_HUD_WeaponStats, M_pContainerGamepadVersion) == 0x000390, "Member 'UBFGWidget_HUD_WeaponStats::M_pContainerGamepadVersion' has a wrong offset!");
static_assert(offsetof(UBFGWidget_HUD_WeaponStats, M_pContainerKeyboardVersion) == 0x000398, "Member 'UBFGWidget_HUD_WeaponStats::M_pContainerKeyboardVersion' has a wrong offset!");
static_assert(offsetof(UBFGWidget_HUD_WeaponStats, M_pContainerAmmoInfinite) == 0x0003A0, "Member 'UBFGWidget_HUD_WeaponStats::M_pContainerAmmoInfinite' has a wrong offset!");
static_assert(offsetof(UBFGWidget_HUD_WeaponStats, M_pImageJammedEffect) == 0x0003A8, "Member 'UBFGWidget_HUD_WeaponStats::M_pImageJammedEffect' has a wrong offset!");
static_assert(offsetof(UBFGWidget_HUD_WeaponStats, M_pImageScanlinesAmmo) == 0x0003B0, "Member 'UBFGWidget_HUD_WeaponStats::M_pImageScanlinesAmmo' has a wrong offset!");
static_assert(offsetof(UBFGWidget_HUD_WeaponStats, M_pImageScanlinesWeapon) == 0x0003B8, "Member 'UBFGWidget_HUD_WeaponStats::M_pImageScanlinesWeapon' has a wrong offset!");
static_assert(offsetof(UBFGWidget_HUD_WeaponStats, M_pTextPercent) == 0x0003C0, "Member 'UBFGWidget_HUD_WeaponStats::M_pTextPercent' has a wrong offset!");
static_assert(offsetof(UBFGWidget_HUD_WeaponStats, M_pTextAmmo) == 0x0003C8, "Member 'UBFGWidget_HUD_WeaponStats::M_pTextAmmo' has a wrong offset!");
static_assert(offsetof(UBFGWidget_HUD_WeaponStats, M_oColorNormal) == 0x0003D0, "Member 'UBFGWidget_HUD_WeaponStats::M_oColorNormal' has a wrong offset!");
static_assert(offsetof(UBFGWidget_HUD_WeaponStats, M_oColorJammed) == 0x0003E0, "Member 'UBFGWidget_HUD_WeaponStats::M_oColorJammed' has a wrong offset!");
static_assert(offsetof(UBFGWidget_HUD_WeaponStats, M_oColorOverheated) == 0x0003F0, "Member 'UBFGWidget_HUD_WeaponStats::M_oColorOverheated' has a wrong offset!");

// Class BFGCore.BFGLabeledImage
// 0x0000 (0x0240 - 0x0240)
class UBFGLabeledImage : public UUserWidget
{
public:
	void SetBrush(const struct FSlateBrush& _pBrush);
	void SetBrushSize(float _fWidth, float _fHeight);
	void SetText(const class FText& _pText);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"BFGLabeledImage">();
	}
	static class UBFGLabeledImage* GetDefaultObj()
	{
		return GetDefaultObjImpl<UBFGLabeledImage>();
	}
};
static_assert(alignof(UBFGLabeledImage) == 0x000008, "Wrong alignment on UBFGLabeledImage");
static_assert(sizeof(UBFGLabeledImage) == 0x000240, "Wrong size on UBFGLabeledImage");

// Class BFGCore.BFGLevelCheckpoint
// 0x0008 (0x03E0 - 0x03D8)
class ABFGLevelCheckpoint final : public AActor
{
public:
	bool                                          M_bRespawnAsCharacter;                             // 0x03D8(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          M_bRespawnAsUFO;                                   // 0x03D9(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_3DA[0x6];                                      // 0x03DA(0x0006)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void GetCharacterSpawn(struct FVector* _vLocationOut, struct FRotator* _rotationOut);
	void GetUFOSpawn(struct FVector* _vLocationOut, struct FRotator* _rotationOut);

	bool IsRespawnAsCharacter() const;
	bool IsRespawnAsUFO() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"BFGLevelCheckpoint">();
	}
	static class ABFGLevelCheckpoint* GetDefaultObj()
	{
		return GetDefaultObjImpl<ABFGLevelCheckpoint>();
	}
};
static_assert(alignof(ABFGLevelCheckpoint) == 0x000008, "Wrong alignment on ABFGLevelCheckpoint");
static_assert(sizeof(ABFGLevelCheckpoint) == 0x0003E0, "Wrong size on ABFGLevelCheckpoint");
static_assert(offsetof(ABFGLevelCheckpoint, M_bRespawnAsCharacter) == 0x0003D8, "Member 'ABFGLevelCheckpoint::M_bRespawnAsCharacter' has a wrong offset!");
static_assert(offsetof(ABFGLevelCheckpoint, M_bRespawnAsUFO) == 0x0003D9, "Member 'ABFGLevelCheckpoint::M_bRespawnAsUFO' has a wrong offset!");

// Class BFGCore.BFGManualPickupItem
// 0x0010 (0x0438 - 0x0428)
class ABFGManualPickupItem final : public ABFGInteractableNoState
{
public:
	struct FVector                                M_vScale;                                          // 0x0428(0x000C)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_434[0x4];                                      // 0x0434(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"BFGManualPickupItem">();
	}
	static class ABFGManualPickupItem* GetDefaultObj()
	{
		return GetDefaultObjImpl<ABFGManualPickupItem>();
	}
};
static_assert(alignof(ABFGManualPickupItem) == 0x000008, "Wrong alignment on ABFGManualPickupItem");
static_assert(sizeof(ABFGManualPickupItem) == 0x000438, "Wrong size on ABFGManualPickupItem");
static_assert(offsetof(ABFGManualPickupItem, M_vScale) == 0x000428, "Member 'ABFGManualPickupItem::M_vScale' has a wrong offset!");

// Class BFGCore.BFGMathUtils
// 0x0000 (0x0028 - 0x0028)
class UBFGMathUtils final : public UBlueprintFunctionLibrary
{
public:
	static float ArcTanDegreesFast(float _fValue);
	static float ArcTanRadiansFast(float _fValue);
	static bool AreBoxesOverlapping(const struct FVector& _vBoxA_Origin, const struct FVector& _vBoxA_Extent, const struct FVector& _vBoxB_Origin, const struct FVector& _vBoxB_Extent);
	static struct FVector GetRandomVectorInRange(const struct FVector& _vRangeMin, const struct FVector& _vRangeMax);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"BFGMathUtils">();
	}
	static class UBFGMathUtils* GetDefaultObj()
	{
		return GetDefaultObjImpl<UBFGMathUtils>();
	}
};
static_assert(alignof(UBFGMathUtils) == 0x000008, "Wrong alignment on UBFGMathUtils");
static_assert(sizeof(UBFGMathUtils) == 0x000028, "Wrong size on UBFGMathUtils");

// Class BFGCore.BFGMatrixMath
// 0x0000 (0x0028 - 0x0028)
class UBFGMatrixMath final : public UBlueprintFunctionLibrary
{
public:
	static void BuildProjectionMatrix(const struct FIntPoint& RenderTargetSize, ECameraProjectionMode ProjectionType, float FOV, float InOrthoWidth, struct FMatrix* ProjectionMatrix);
	static struct FMatrix GetInverseViewProjMatrix(const struct FMatrix& _matView, const struct FMatrix& _matProj);
	static void GetMatrixAsLinearColor(struct FLinearColor* _row1, struct FLinearColor* _row2, struct FLinearColor* _row3, struct FLinearColor* _row4, const struct FMatrix& _m, bool _bTransposeOutput);
	static struct FMatrix GetMatrixFromColor(const struct FLinearColor& _row1, const struct FLinearColor& _row2, const struct FLinearColor& _row3, const struct FLinearColor& _row4, bool _bTransposeInput);
	static struct FMatrix GetMatrixFromTransform(const struct FTransform& _Transform, bool _bWithScale);
	static struct FMatrix GetProjectionMatrix(class USceneCaptureComponent2D* _pComponent);
	static struct FMatrix GetViewMatrix(class USceneCaptureComponent2D* _pComponent);
	static struct FMatrix GetViewProjectionMatrix(class USceneCaptureComponent2D* _pComponent);
	static struct FMatrix InvertMatrix(const struct FMatrix& _a);
	static struct FMatrix InvertMatrixFromColor(const struct FLinearColor& _row1, const struct FLinearColor& _row2, const struct FLinearColor& _row3, const struct FLinearColor& _row4, bool _bTransposeInput);
	static struct FMatrix MultiplyMatrices(const struct FMatrix& _a, const struct FMatrix& _b);
	static struct FVector4 TransformVector(const struct FMatrix& _a, const struct FVector4& _b);
	static struct FMatrix TransposeMatrix(const struct FMatrix& _a);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"BFGMatrixMath">();
	}
	static class UBFGMatrixMath* GetDefaultObj()
	{
		return GetDefaultObjImpl<UBFGMatrixMath>();
	}
};
static_assert(alignof(UBFGMatrixMath) == 0x000008, "Wrong alignment on UBFGMatrixMath");
static_assert(sizeof(UBFGMatrixMath) == 0x000028, "Wrong size on UBFGMatrixMath");

// Class BFGCore.BFGHypnotizeTargetData_Distract
// 0x0000 (0x0038 - 0x0038)
class UBFGHypnotizeTargetData_Distract final : public UBFGHypnotizeTargetData
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"BFGHypnotizeTargetData_Distract">();
	}
	static class UBFGHypnotizeTargetData_Distract* GetDefaultObj()
	{
		return GetDefaultObjImpl<UBFGHypnotizeTargetData_Distract>();
	}
};
static_assert(alignof(UBFGHypnotizeTargetData_Distract) == 0x000008, "Wrong alignment on UBFGHypnotizeTargetData_Distract");
static_assert(sizeof(UBFGHypnotizeTargetData_Distract) == 0x000038, "Wrong size on UBFGHypnotizeTargetData_Distract");

// Class BFGCore.BFGMentalAbility_Hypnotize_Distract
// 0x0008 (0x0208 - 0x0200)
class UBFGMentalAbility_Hypnotize_Distract : public UBFGMentalAbility_Hypnotize
{
public:
	float                                         M_fNoiseLoudness;                                  // 0x0200(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_204[0x4];                                      // 0x0204(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"BFGMentalAbility_Hypnotize_Distract">();
	}
	static class UBFGMentalAbility_Hypnotize_Distract* GetDefaultObj()
	{
		return GetDefaultObjImpl<UBFGMentalAbility_Hypnotize_Distract>();
	}
};
static_assert(alignof(UBFGMentalAbility_Hypnotize_Distract) == 0x000008, "Wrong alignment on UBFGMentalAbility_Hypnotize_Distract");
static_assert(sizeof(UBFGMentalAbility_Hypnotize_Distract) == 0x000208, "Wrong size on UBFGMentalAbility_Hypnotize_Distract");
static_assert(offsetof(UBFGMentalAbility_Hypnotize_Distract, M_fNoiseLoudness) == 0x000200, "Member 'UBFGMentalAbility_Hypnotize_Distract::M_fNoiseLoudness' has a wrong offset!");

// Class BFGCore.BFGHypnotizeTargetData_Follow
// 0x0008 (0x0040 - 0x0038)
class UBFGHypnotizeTargetData_Follow final : public UBFGHypnotizeTargetData
{
public:
	uint8                                         Pad_38[0x8];                                       // 0x0038(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"BFGHypnotizeTargetData_Follow">();
	}
	static class UBFGHypnotizeTargetData_Follow* GetDefaultObj()
	{
		return GetDefaultObjImpl<UBFGHypnotizeTargetData_Follow>();
	}
};
static_assert(alignof(UBFGHypnotizeTargetData_Follow) == 0x000008, "Wrong alignment on UBFGHypnotizeTargetData_Follow");
static_assert(sizeof(UBFGHypnotizeTargetData_Follow) == 0x000040, "Wrong size on UBFGHypnotizeTargetData_Follow");

// Class BFGCore.BFGWidget_NarrativeSequence_Strike
// 0x0000 (0x0240 - 0x0240)
class UBFGWidget_NarrativeSequence_Strike final : public UUserWidget
{
public:
	void SetFailed(bool _bFailed);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"BFGWidget_NarrativeSequence_Strike">();
	}
	static class UBFGWidget_NarrativeSequence_Strike* GetDefaultObj()
	{
		return GetDefaultObjImpl<UBFGWidget_NarrativeSequence_Strike>();
	}
};
static_assert(alignof(UBFGWidget_NarrativeSequence_Strike) == 0x000008, "Wrong alignment on UBFGWidget_NarrativeSequence_Strike");
static_assert(sizeof(UBFGWidget_NarrativeSequence_Strike) == 0x000240, "Wrong size on UBFGWidget_NarrativeSequence_Strike");

// Class BFGCore.BFGMentalAbility_Hypnotize_Forget
// 0x0000 (0x0200 - 0x0200)
class UBFGMentalAbility_Hypnotize_Forget : public UBFGMentalAbility_Hypnotize
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"BFGMentalAbility_Hypnotize_Forget">();
	}
	static class UBFGMentalAbility_Hypnotize_Forget* GetDefaultObj()
	{
		return GetDefaultObjImpl<UBFGMentalAbility_Hypnotize_Forget>();
	}
};
static_assert(alignof(UBFGMentalAbility_Hypnotize_Forget) == 0x000008, "Wrong alignment on UBFGMentalAbility_Hypnotize_Forget");
static_assert(sizeof(UBFGMentalAbility_Hypnotize_Forget) == 0x000200, "Wrong size on UBFGMentalAbility_Hypnotize_Forget");

// Class BFGCore.BFGMentalAbility_MentalInteraction
// 0x0058 (0x0220 - 0x01C8)
class UBFGMentalAbility_MentalInteraction : public UBFGMentalAbilityBase
{
public:
	TMap<EBFGAnimation_MentalAbilityPosture, class UBFGEffectBank*> M_aEffectBanks;                                    // 0x01C8(0x0050)(Edit, ZeroConstructor, Protected, NativeAccessSpecifierProtected)
	class UBFGActorComponent_MentallyInteractable* M_pCurrentInteraction;                             // 0x0218(0x0008)(ExportObject, ZeroConstructor, Transient, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"BFGMentalAbility_MentalInteraction">();
	}
	static class UBFGMentalAbility_MentalInteraction* GetDefaultObj()
	{
		return GetDefaultObjImpl<UBFGMentalAbility_MentalInteraction>();
	}
};
static_assert(alignof(UBFGMentalAbility_MentalInteraction) == 0x000008, "Wrong alignment on UBFGMentalAbility_MentalInteraction");
static_assert(sizeof(UBFGMentalAbility_MentalInteraction) == 0x000220, "Wrong size on UBFGMentalAbility_MentalInteraction");
static_assert(offsetof(UBFGMentalAbility_MentalInteraction, M_aEffectBanks) == 0x0001C8, "Member 'UBFGMentalAbility_MentalInteraction::M_aEffectBanks' has a wrong offset!");
static_assert(offsetof(UBFGMentalAbility_MentalInteraction, M_pCurrentInteraction) == 0x000218, "Member 'UBFGMentalAbility_MentalInteraction::M_pCurrentInteraction' has a wrong offset!");

// Class BFGCore.BFGWidget_Newspaper
// 0x0010 (0x0438 - 0x0428)
class UBFGWidget_Newspaper final : public UBFGWidget_GenericDialog
{
public:
	class UBFGWidget_Newspaper_Content*           M_pContent;                                        // 0x0428(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UBFGDataAsset_NewspaperInfo*            M_pContentInfo;                                    // 0x0430(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)

public:
	void AddContentToLayout(const class UBFGWidget_Newspaper_Content* _pContent);
	void InitContent(class UBFGDataAsset_NewspaperInfo* _pContentInfo);
	void SetSubtitleSubtitles(const class FText& Text);
	void SetTitleSubtitles(const class FText& Text);

	struct FLinearColor DetermineBackgroundColor() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"BFGWidget_Newspaper">();
	}
	static class UBFGWidget_Newspaper* GetDefaultObj()
	{
		return GetDefaultObjImpl<UBFGWidget_Newspaper>();
	}
};
static_assert(alignof(UBFGWidget_Newspaper) == 0x000008, "Wrong alignment on UBFGWidget_Newspaper");
static_assert(sizeof(UBFGWidget_Newspaper) == 0x000438, "Wrong size on UBFGWidget_Newspaper");
static_assert(offsetof(UBFGWidget_Newspaper, M_pContent) == 0x000428, "Member 'UBFGWidget_Newspaper::M_pContent' has a wrong offset!");
static_assert(offsetof(UBFGWidget_Newspaper, M_pContentInfo) == 0x000430, "Member 'UBFGWidget_Newspaper::M_pContentInfo' has a wrong offset!");

// Class BFGCore.BFGMentallyInteractableCheck_Distance
// 0x0008 (0x0058 - 0x0050)
class UBFGMentallyInteractableCheck_Distance final : public UBFGMentallyInteractableCheck
{
public:
	float                                         M_fMaxDist;                                        // 0x0050(0x0004)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnTemplate, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_54[0x4];                                       // 0x0054(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"BFGMentallyInteractableCheck_Distance">();
	}
	static class UBFGMentallyInteractableCheck_Distance* GetDefaultObj()
	{
		return GetDefaultObjImpl<UBFGMentallyInteractableCheck_Distance>();
	}
};
static_assert(alignof(UBFGMentallyInteractableCheck_Distance) == 0x000008, "Wrong alignment on UBFGMentallyInteractableCheck_Distance");
static_assert(sizeof(UBFGMentallyInteractableCheck_Distance) == 0x000058, "Wrong size on UBFGMentallyInteractableCheck_Distance");
static_assert(offsetof(UBFGMentallyInteractableCheck_Distance, M_fMaxDist) == 0x000050, "Member 'UBFGMentallyInteractableCheck_Distance::M_fMaxDist' has a wrong offset!");

// Class BFGCore.BFGMentallyInteractableCheck_Location
// 0x0090 (0x00E0 - 0x0050)
class UBFGMentallyInteractableCheck_Location final : public UBFGMentallyInteractableCheck
{
public:
	struct FBFGActorBinding                       M_triggerBinding;                                  // 0x0050(0x0090)(Edit, BlueprintVisible, DisableEditOnTemplate, Protected, NativeAccessSpecifierProtected)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"BFGMentallyInteractableCheck_Location">();
	}
	static class UBFGMentallyInteractableCheck_Location* GetDefaultObj()
	{
		return GetDefaultObjImpl<UBFGMentallyInteractableCheck_Location>();
	}
};
static_assert(alignof(UBFGMentallyInteractableCheck_Location) == 0x000008, "Wrong alignment on UBFGMentallyInteractableCheck_Location");
static_assert(sizeof(UBFGMentallyInteractableCheck_Location) == 0x0000E0, "Wrong size on UBFGMentallyInteractableCheck_Location");
static_assert(offsetof(UBFGMentallyInteractableCheck_Location, M_triggerBinding) == 0x000050, "Member 'UBFGMentallyInteractableCheck_Location::M_triggerBinding' has a wrong offset!");

// Class BFGCore.BFGWidget_LinearGraphNode
// 0x0010 (0x0250 - 0x0240)
class UBFGWidget_LinearGraphNode : public UUserWidget
{
public:
	TWeakObjectPtr<class UBFGWidget_LinearGraph>  M_pParent;                                         // 0x0240(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_248[0x8];                                      // 0x0248(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void SetNodeAsMarked();
	void SetNodeAsObliterated();
	void SetSelected(bool _bSelected);

	bool IsSelected() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"BFGWidget_LinearGraphNode">();
	}
	static class UBFGWidget_LinearGraphNode* GetDefaultObj()
	{
		return GetDefaultObjImpl<UBFGWidget_LinearGraphNode>();
	}
};
static_assert(alignof(UBFGWidget_LinearGraphNode) == 0x000008, "Wrong alignment on UBFGWidget_LinearGraphNode");
static_assert(sizeof(UBFGWidget_LinearGraphNode) == 0x000250, "Wrong size on UBFGWidget_LinearGraphNode");
static_assert(offsetof(UBFGWidget_LinearGraphNode, M_pParent) == 0x000240, "Member 'UBFGWidget_LinearGraphNode::M_pParent' has a wrong offset!");

// Class BFGCore.BFGWidget_PoxLab_UpgradeGraphNode
// 0x0018 (0x0268 - 0x0250)
class UBFGWidget_PoxLab_UpgradeGraphNode final : public UBFGWidget_LinearGraphNode
{
public:
	class UBFGDataAssetPoxLabUpgrade*             M_pDataAsset;                                      // 0x0250(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          M_bIsPurchaseable;                                 // 0x0258(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_259[0x3];                                      // 0x0259(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	struct FGameplayTag                           M_oUnlockTag;                                      // 0x025C(0x0008)(NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_264[0x2];                                      // 0x0264(0x0002)(Fixing Size After Last Property [ Dumper-7 ])
	EPoxLabUpgradeGraphNodeState                  M_eCurrentState;                                   // 0x0266(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_267[0x1];                                      // 0x0267(0x0001)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void AnimateActivation(EPoxLabUpgradeGraphNodeState _eState);
	void OnStateChanged(EPoxLabUpgradeGraphNodeState _eNewState);
	void OnUpgradePressed();
	void SetGraphState(bool _bUpgradeable, bool _bUpgraded, bool _bPurchaseable);
	void SetGraphText(const class FText& _strText);
	void UpdateState();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"BFGWidget_PoxLab_UpgradeGraphNode">();
	}
	static class UBFGWidget_PoxLab_UpgradeGraphNode* GetDefaultObj()
	{
		return GetDefaultObjImpl<UBFGWidget_PoxLab_UpgradeGraphNode>();
	}
};
static_assert(alignof(UBFGWidget_PoxLab_UpgradeGraphNode) == 0x000008, "Wrong alignment on UBFGWidget_PoxLab_UpgradeGraphNode");
static_assert(sizeof(UBFGWidget_PoxLab_UpgradeGraphNode) == 0x000268, "Wrong size on UBFGWidget_PoxLab_UpgradeGraphNode");
static_assert(offsetof(UBFGWidget_PoxLab_UpgradeGraphNode, M_pDataAsset) == 0x000250, "Member 'UBFGWidget_PoxLab_UpgradeGraphNode::M_pDataAsset' has a wrong offset!");
static_assert(offsetof(UBFGWidget_PoxLab_UpgradeGraphNode, M_bIsPurchaseable) == 0x000258, "Member 'UBFGWidget_PoxLab_UpgradeGraphNode::M_bIsPurchaseable' has a wrong offset!");
static_assert(offsetof(UBFGWidget_PoxLab_UpgradeGraphNode, M_oUnlockTag) == 0x00025C, "Member 'UBFGWidget_PoxLab_UpgradeGraphNode::M_oUnlockTag' has a wrong offset!");
static_assert(offsetof(UBFGWidget_PoxLab_UpgradeGraphNode, M_eCurrentState) == 0x000266, "Member 'UBFGWidget_PoxLab_UpgradeGraphNode::M_eCurrentState' has a wrong offset!");

// Class BFGCore.BFGMentallyInteractableCheck_AIState
// 0x0008 (0x0058 - 0x0050)
class UBFGMentallyInteractableCheck_AIState final : public UBFGMentallyInteractableCheck
{
public:
	int32                                         M_iBehaviourStates;                                // 0x0050(0x0004)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnTemplate, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_54[0x4];                                       // 0x0054(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"BFGMentallyInteractableCheck_AIState">();
	}
	static class UBFGMentallyInteractableCheck_AIState* GetDefaultObj()
	{
		return GetDefaultObjImpl<UBFGMentallyInteractableCheck_AIState>();
	}
};
static_assert(alignof(UBFGMentallyInteractableCheck_AIState) == 0x000008, "Wrong alignment on UBFGMentallyInteractableCheck_AIState");
static_assert(sizeof(UBFGMentallyInteractableCheck_AIState) == 0x000058, "Wrong size on UBFGMentallyInteractableCheck_AIState");
static_assert(offsetof(UBFGMentallyInteractableCheck_AIState, M_iBehaviourStates) == 0x000050, "Member 'UBFGMentallyInteractableCheck_AIState::M_iBehaviourStates' has a wrong offset!");

// Class BFGCore.BFGMentallyInteractableCheck_AlertLevel
// 0x0008 (0x0058 - 0x0050)
class UBFGMentallyInteractableCheck_AlertLevel final : public UBFGMentallyInteractableCheck
{
public:
	int32                                         M_iAlertLevels;                                    // 0x0050(0x0004)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnTemplate, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_54[0x4];                                       // 0x0054(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"BFGMentallyInteractableCheck_AlertLevel">();
	}
	static class UBFGMentallyInteractableCheck_AlertLevel* GetDefaultObj()
	{
		return GetDefaultObjImpl<UBFGMentallyInteractableCheck_AlertLevel>();
	}
};
static_assert(alignof(UBFGMentallyInteractableCheck_AlertLevel) == 0x000008, "Wrong alignment on UBFGMentallyInteractableCheck_AlertLevel");
static_assert(sizeof(UBFGMentallyInteractableCheck_AlertLevel) == 0x000058, "Wrong size on UBFGMentallyInteractableCheck_AlertLevel");
static_assert(offsetof(UBFGMentallyInteractableCheck_AlertLevel, M_iAlertLevels) == 0x000050, "Member 'UBFGMentallyInteractableCheck_AlertLevel::M_iAlertLevels' has a wrong offset!");

// Class BFGCore.BFGMenuFactory
// 0x0068 (0x0090 - 0x0028)
class UBFGMenuFactory : public UObject
{
public:
	TArray<class UBFGData_MenuFactoryEntry*>      M_apDefaultMenuStates;                             // 0x0028(0x0010)(Edit, ZeroConstructor, DisableEditOnInstance, NativeAccessSpecifierPublic)
	TMap<class FName, TSoftClassPtr<class UClass>> M_apDefaultMenuStatesRuntime;                      // 0x0038(0x0050)(ZeroConstructor, UObjectWrapper, NativeAccessSpecifierPrivate)
	TWeakObjectPtr<class UBFGGameInstance>        M_pGameInstance;                                   // 0x0088(0x0008)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)

public:
	class UBFGGameFlowState_GenericDialog* CreateGenericDialogState(class FName _menuName);
	class UBFGGameFlowState_MenuBase* CreateMenuState(class FName _menuName, bool _bKeepCurrentGameFlowState, class UObject* _pMenuContext);
	class UClass* GetMenuStateClass(class FName _menuName);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"BFGMenuFactory">();
	}
	static class UBFGMenuFactory* GetDefaultObj()
	{
		return GetDefaultObjImpl<UBFGMenuFactory>();
	}
};
static_assert(alignof(UBFGMenuFactory) == 0x000008, "Wrong alignment on UBFGMenuFactory");
static_assert(sizeof(UBFGMenuFactory) == 0x000090, "Wrong size on UBFGMenuFactory");
static_assert(offsetof(UBFGMenuFactory, M_apDefaultMenuStates) == 0x000028, "Member 'UBFGMenuFactory::M_apDefaultMenuStates' has a wrong offset!");
static_assert(offsetof(UBFGMenuFactory, M_apDefaultMenuStatesRuntime) == 0x000038, "Member 'UBFGMenuFactory::M_apDefaultMenuStatesRuntime' has a wrong offset!");
static_assert(offsetof(UBFGMenuFactory, M_pGameInstance) == 0x000088, "Member 'UBFGMenuFactory::M_pGameInstance' has a wrong offset!");

// Class BFGCore.BFGWidget_TimedConfirm
// 0x0008 (0x0430 - 0x0428)
class UBFGWidget_TimedConfirm final : public UBFGWidget_GenericDialog
{
public:
	uint8                                         Pad_428[0x8];                                      // 0x0428(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void OnUpdateTimer(float _fTimer);
	void SetPromptMessage(const class FText& _strPromptMessage);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"BFGWidget_TimedConfirm">();
	}
	static class UBFGWidget_TimedConfirm* GetDefaultObj()
	{
		return GetDefaultObjImpl<UBFGWidget_TimedConfirm>();
	}
};
static_assert(alignof(UBFGWidget_TimedConfirm) == 0x000008, "Wrong alignment on UBFGWidget_TimedConfirm");
static_assert(sizeof(UBFGWidget_TimedConfirm) == 0x000430, "Wrong size on UBFGWidget_TimedConfirm");

// Class BFGCore.BFGMenuLifetimeManager
// 0x0018 (0x0040 - 0x0028)
class UBFGMenuLifetimeManager final : public UObject
{
public:
	TArray<class UBFGWidget_MenuBase*>            M_apCurrentMenus;                                  // 0x0028(0x0010)(ExportObject, ZeroConstructor, ContainsInstancedReference, NativeAccessSpecifierPrivate)
	TWeakObjectPtr<class UBFGGameInstance>        M_pGameInstance;                                   // 0x0038(0x0008)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)

public:
	void OnMenuFinalized(class UBFGWidget_MenuBase* _pMenuBase);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"BFGMenuLifetimeManager">();
	}
	static class UBFGMenuLifetimeManager* GetDefaultObj()
	{
		return GetDefaultObjImpl<UBFGMenuLifetimeManager>();
	}
};
static_assert(alignof(UBFGMenuLifetimeManager) == 0x000008, "Wrong alignment on UBFGMenuLifetimeManager");
static_assert(sizeof(UBFGMenuLifetimeManager) == 0x000040, "Wrong size on UBFGMenuLifetimeManager");
static_assert(offsetof(UBFGMenuLifetimeManager, M_apCurrentMenus) == 0x000028, "Member 'UBFGMenuLifetimeManager::M_apCurrentMenus' has a wrong offset!");
static_assert(offsetof(UBFGMenuLifetimeManager, M_pGameInstance) == 0x000038, "Member 'UBFGMenuLifetimeManager::M_pGameInstance' has a wrong offset!");

// Class BFGCore.BFGMIButton
// 0x0010 (0x03E8 - 0x03D8)
class ABFGMIButton final : public AActor
{
public:
	class UBFGActorComponent_MentallyInteractable* M_pMentallyInteractableComponent;                  // 0x03D8(0x0008)(Edit, ExportObject, ZeroConstructor, EditConst, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          M_bActivated;                                      // 0x03E0(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_3E1[0x7];                                      // 0x03E1(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void HandleMentallyInteractabledUse(class UBFGActorComponent_MentallyInteractable* _pMentallyInteractable, class AController* _pController);
	void OnToggleActivate();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"BFGMIButton">();
	}
	static class ABFGMIButton* GetDefaultObj()
	{
		return GetDefaultObjImpl<ABFGMIButton>();
	}
};
static_assert(alignof(ABFGMIButton) == 0x000008, "Wrong alignment on ABFGMIButton");
static_assert(sizeof(ABFGMIButton) == 0x0003E8, "Wrong size on ABFGMIButton");
static_assert(offsetof(ABFGMIButton, M_pMentallyInteractableComponent) == 0x0003D8, "Member 'ABFGMIButton::M_pMentallyInteractableComponent' has a wrong offset!");
static_assert(offsetof(ABFGMIButton, M_bActivated) == 0x0003E0, "Member 'ABFGMIButton::M_bActivated' has a wrong offset!");

// Class BFGCore.BFGMissionCustomTriggerZone
// 0x0120 (0x0598 - 0x0478)
class ABFGMissionCustomTriggerZone : public ABFGMissionTriggerZone
{
public:
	uint8                                         Pad_478[0x8];                                      // 0x0478(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	UMulticastDelegateProperty_                   M_onShapeGenerated;                                // 0x0480(0x0018)(ZeroConstructor, InstancedReference, NativeAccessSpecifierPublic)
	TArray<struct FSplinePoint>                   M_aPointsInnerBoundsBottom;                        // 0x0498(0x0010)(BlueprintVisible, ZeroConstructor, NativeAccessSpecifierPublic)
	TArray<struct FSplinePoint>                   M_aPointsInnerBoundsTop;                           // 0x04A8(0x0010)(BlueprintVisible, ZeroConstructor, NativeAccessSpecifierPublic)
	TArray<struct FSplinePoint>                   M_aPointsOuterBoundsBottom;                        // 0x04B8(0x0010)(BlueprintVisible, ZeroConstructor, NativeAccessSpecifierPublic)
	TArray<struct FSplinePoint>                   M_aPointsOuterBoundsTop;                           // 0x04C8(0x0010)(BlueprintVisible, ZeroConstructor, NativeAccessSpecifierPublic)
	class ABFGGameState*                          M_pGameState;                                      // 0x04D8(0x0008)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                M_vUpperCentroid;                                  // 0x04E0(0x000C)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                M_vLowerCentroid;                                  // 0x04EC(0x000C)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         M_fTriggerHeight;                                  // 0x04F8(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_4FC[0x4];                                      // 0x04FC(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class UMaterialInterface*                     M_pMaterialInterface;                              // 0x0500(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          M_bCloseVolume;                                    // 0x0508(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          M_bIsOOBTrigger;                                   // 0x0509(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          M_bIsOceanTrigger;                                 // 0x050A(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, ExposeOnSpawn, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          M_bIsNonNavigable;                                 // 0x050B(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          M_bShouldUseAlgorithm;                             // 0x050C(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_50D[0x3];                                      // 0x050D(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         M_fOuterBoundsOffset;                              // 0x0510(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         M_fDebugLineDuration;                              // 0x0514(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         M_fDebugLineThickness;                             // 0x0518(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_51C[0x4];                                      // 0x051C(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<struct FSplinePoint>                   M_aInnerPoints;                                    // 0x0520(0x0010)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, NativeAccessSpecifierPublic)
	TArray<struct FSplinePoint>                   M_aOuterPoints;                                    // 0x0530(0x0010)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, NativeAccessSpecifierPublic)
	TSubclassOf<class UNavAreaBase>               M_NavAreaClass_InnerPoints;                        // 0x0540(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         M_fNavAreaThickness_InnerPoints;                   // 0x0548(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_54C[0x4];                                      // 0x054C(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	TSubclassOf<class UNavAreaBase>               M_NavAreaClass_OuterPoints;                        // 0x0550(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         M_fNavAreaThickness_OuterPoints;                   // 0x0558(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_55C[0x4];                                      // 0x055C(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class UBFGTriggerManager*                     M_pTriggerManager;                                 // 0x0560(0x0008)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UBFGBroadphaseManager*                  M_pBroadphase;                                     // 0x0568(0x0008)(ExportObject, ZeroConstructor, Transient, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_570[0x20];                                     // 0x0570(0x0020)(Fixing Size After Last Property [ Dumper-7 ])
	class ABFGActorOcean*                         M_pOcean;                                          // 0x0590(0x0008)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)

public:
	void OnStateChange(class AActor* _pActor, ETriggerState _eLastState, ETriggerState _eCurrentState);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"BFGMissionCustomTriggerZone">();
	}
	static class ABFGMissionCustomTriggerZone* GetDefaultObj()
	{
		return GetDefaultObjImpl<ABFGMissionCustomTriggerZone>();
	}
};
static_assert(alignof(ABFGMissionCustomTriggerZone) == 0x000008, "Wrong alignment on ABFGMissionCustomTriggerZone");
static_assert(sizeof(ABFGMissionCustomTriggerZone) == 0x000598, "Wrong size on ABFGMissionCustomTriggerZone");
static_assert(offsetof(ABFGMissionCustomTriggerZone, M_onShapeGenerated) == 0x000480, "Member 'ABFGMissionCustomTriggerZone::M_onShapeGenerated' has a wrong offset!");
static_assert(offsetof(ABFGMissionCustomTriggerZone, M_aPointsInnerBoundsBottom) == 0x000498, "Member 'ABFGMissionCustomTriggerZone::M_aPointsInnerBoundsBottom' has a wrong offset!");
static_assert(offsetof(ABFGMissionCustomTriggerZone, M_aPointsInnerBoundsTop) == 0x0004A8, "Member 'ABFGMissionCustomTriggerZone::M_aPointsInnerBoundsTop' has a wrong offset!");
static_assert(offsetof(ABFGMissionCustomTriggerZone, M_aPointsOuterBoundsBottom) == 0x0004B8, "Member 'ABFGMissionCustomTriggerZone::M_aPointsOuterBoundsBottom' has a wrong offset!");
static_assert(offsetof(ABFGMissionCustomTriggerZone, M_aPointsOuterBoundsTop) == 0x0004C8, "Member 'ABFGMissionCustomTriggerZone::M_aPointsOuterBoundsTop' has a wrong offset!");
static_assert(offsetof(ABFGMissionCustomTriggerZone, M_pGameState) == 0x0004D8, "Member 'ABFGMissionCustomTriggerZone::M_pGameState' has a wrong offset!");
static_assert(offsetof(ABFGMissionCustomTriggerZone, M_vUpperCentroid) == 0x0004E0, "Member 'ABFGMissionCustomTriggerZone::M_vUpperCentroid' has a wrong offset!");
static_assert(offsetof(ABFGMissionCustomTriggerZone, M_vLowerCentroid) == 0x0004EC, "Member 'ABFGMissionCustomTriggerZone::M_vLowerCentroid' has a wrong offset!");
static_assert(offsetof(ABFGMissionCustomTriggerZone, M_fTriggerHeight) == 0x0004F8, "Member 'ABFGMissionCustomTriggerZone::M_fTriggerHeight' has a wrong offset!");
static_assert(offsetof(ABFGMissionCustomTriggerZone, M_pMaterialInterface) == 0x000500, "Member 'ABFGMissionCustomTriggerZone::M_pMaterialInterface' has a wrong offset!");
static_assert(offsetof(ABFGMissionCustomTriggerZone, M_bCloseVolume) == 0x000508, "Member 'ABFGMissionCustomTriggerZone::M_bCloseVolume' has a wrong offset!");
static_assert(offsetof(ABFGMissionCustomTriggerZone, M_bIsOOBTrigger) == 0x000509, "Member 'ABFGMissionCustomTriggerZone::M_bIsOOBTrigger' has a wrong offset!");
static_assert(offsetof(ABFGMissionCustomTriggerZone, M_bIsOceanTrigger) == 0x00050A, "Member 'ABFGMissionCustomTriggerZone::M_bIsOceanTrigger' has a wrong offset!");
static_assert(offsetof(ABFGMissionCustomTriggerZone, M_bIsNonNavigable) == 0x00050B, "Member 'ABFGMissionCustomTriggerZone::M_bIsNonNavigable' has a wrong offset!");
static_assert(offsetof(ABFGMissionCustomTriggerZone, M_bShouldUseAlgorithm) == 0x00050C, "Member 'ABFGMissionCustomTriggerZone::M_bShouldUseAlgorithm' has a wrong offset!");
static_assert(offsetof(ABFGMissionCustomTriggerZone, M_fOuterBoundsOffset) == 0x000510, "Member 'ABFGMissionCustomTriggerZone::M_fOuterBoundsOffset' has a wrong offset!");
static_assert(offsetof(ABFGMissionCustomTriggerZone, M_fDebugLineDuration) == 0x000514, "Member 'ABFGMissionCustomTriggerZone::M_fDebugLineDuration' has a wrong offset!");
static_assert(offsetof(ABFGMissionCustomTriggerZone, M_fDebugLineThickness) == 0x000518, "Member 'ABFGMissionCustomTriggerZone::M_fDebugLineThickness' has a wrong offset!");
static_assert(offsetof(ABFGMissionCustomTriggerZone, M_aInnerPoints) == 0x000520, "Member 'ABFGMissionCustomTriggerZone::M_aInnerPoints' has a wrong offset!");
static_assert(offsetof(ABFGMissionCustomTriggerZone, M_aOuterPoints) == 0x000530, "Member 'ABFGMissionCustomTriggerZone::M_aOuterPoints' has a wrong offset!");
static_assert(offsetof(ABFGMissionCustomTriggerZone, M_NavAreaClass_InnerPoints) == 0x000540, "Member 'ABFGMissionCustomTriggerZone::M_NavAreaClass_InnerPoints' has a wrong offset!");
static_assert(offsetof(ABFGMissionCustomTriggerZone, M_fNavAreaThickness_InnerPoints) == 0x000548, "Member 'ABFGMissionCustomTriggerZone::M_fNavAreaThickness_InnerPoints' has a wrong offset!");
static_assert(offsetof(ABFGMissionCustomTriggerZone, M_NavAreaClass_OuterPoints) == 0x000550, "Member 'ABFGMissionCustomTriggerZone::M_NavAreaClass_OuterPoints' has a wrong offset!");
static_assert(offsetof(ABFGMissionCustomTriggerZone, M_fNavAreaThickness_OuterPoints) == 0x000558, "Member 'ABFGMissionCustomTriggerZone::M_fNavAreaThickness_OuterPoints' has a wrong offset!");
static_assert(offsetof(ABFGMissionCustomTriggerZone, M_pTriggerManager) == 0x000560, "Member 'ABFGMissionCustomTriggerZone::M_pTriggerManager' has a wrong offset!");
static_assert(offsetof(ABFGMissionCustomTriggerZone, M_pBroadphase) == 0x000568, "Member 'ABFGMissionCustomTriggerZone::M_pBroadphase' has a wrong offset!");
static_assert(offsetof(ABFGMissionCustomTriggerZone, M_pOcean) == 0x000590, "Member 'ABFGMissionCustomTriggerZone::M_pOcean' has a wrong offset!");

// Class BFGCore.BFGWidget_GameplayTagOption
// 0x0010 (0x0250 - 0x0240)
class UBFGWidget_GameplayTagOption final : public UUserWidget
{
public:
	struct FGameplayTag                           M_gameplayTag;                                     // 0x0240(0x0008)(Edit, BlueprintVisible, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TWeakObjectPtr<class UBFGWidget_GameplayTags> M_pParent;                                         // 0x0248(0x0008)(ExportObject, ZeroConstructor, Transient, InstancedReference, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)

public:
	void SetParentWidget(class UBFGWidget_GameplayTags* _pParent);

	class UBFGWidget_GameplayTags* GetParentWidget() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"BFGWidget_GameplayTagOption">();
	}
	static class UBFGWidget_GameplayTagOption* GetDefaultObj()
	{
		return GetDefaultObjImpl<UBFGWidget_GameplayTagOption>();
	}
};
static_assert(alignof(UBFGWidget_GameplayTagOption) == 0x000008, "Wrong alignment on UBFGWidget_GameplayTagOption");
static_assert(sizeof(UBFGWidget_GameplayTagOption) == 0x000250, "Wrong size on UBFGWidget_GameplayTagOption");
static_assert(offsetof(UBFGWidget_GameplayTagOption, M_gameplayTag) == 0x000240, "Member 'UBFGWidget_GameplayTagOption::M_gameplayTag' has a wrong offset!");
static_assert(offsetof(UBFGWidget_GameplayTagOption, M_pParent) == 0x000248, "Member 'UBFGWidget_GameplayTagOption::M_pParent' has a wrong offset!");

// Class BFGCore.BFGMissionBoundaries
// 0x0008 (0x05A0 - 0x0598)
class ABFGMissionBoundaries : public ABFGMissionCustomTriggerZone
{
public:
	bool                                          M_bPlayVoiceovers;                                 // 0x0598(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_599[0x7];                                      // 0x0599(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"BFGMissionBoundaries">();
	}
	static class ABFGMissionBoundaries* GetDefaultObj()
	{
		return GetDefaultObjImpl<ABFGMissionBoundaries>();
	}
};
static_assert(alignof(ABFGMissionBoundaries) == 0x000008, "Wrong alignment on ABFGMissionBoundaries");
static_assert(sizeof(ABFGMissionBoundaries) == 0x0005A0, "Wrong size on ABFGMissionBoundaries");
static_assert(offsetof(ABFGMissionBoundaries, M_bPlayVoiceovers) == 0x000598, "Member 'ABFGMissionBoundaries::M_bPlayVoiceovers' has a wrong offset!");

// Class BFGCore.BFGMissionCinematicVolume
// 0x0068 (0x0440 - 0x03D8)
class ABFGMissionCinematicVolume final : public AActor
{
public:
	uint8                                         Pad_3D8[0x8];                                      // 0x03D8(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	class FName                                   M_fTagForHidingActors;                             // 0x03E0(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          M_bRemovePKActors;                                 // 0x03E8(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          M_bKillProjectiles;                                // 0x03E9(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          M_bDisableCollisionForActors;                      // 0x03EA(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          M_bHideActors;                                     // 0x03EB(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          M_bBlockNetworkPaths;                              // 0x03EC(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          M_bHideCrowdlifeStationActors;                     // 0x03ED(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          M_bCinematicVolumeEnabled;                         // 0x03EE(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_3EF[0x1];                                      // 0x03EF(0x0001)(Fixing Size After Last Property [ Dumper-7 ])
	struct FGameplayTagContainer                  M_gameplayTags;                                    // 0x03F0(0x0020)(Edit, BlueprintVisible, BlueprintReadOnly, Protected, NativeAccessSpecifierProtected)
	TArray<struct FBFGMissionCinematicActorSettings> M_aActorData;                                      // 0x0410(0x0010)(ZeroConstructor, ContainsInstancedReference, NativeAccessSpecifierPrivate)
	TArray<class UBFGNetworkPath*>                M_apBlockedNetworkPaths;                           // 0x0420(0x0010)(ZeroConstructor, NativeAccessSpecifierPrivate)
	TArray<class UBFGCrowdLifeStationComponent*>  M_apDisabledCrowdlifeStations;                     // 0x0430(0x0010)(ExportObject, ZeroConstructor, ContainsInstancedReference, NativeAccessSpecifierPrivate)

public:
	void BlockNetworkPaths();
	void CleanupVolume();
	void DisableCrowdlifeStationsAndHideActors();
	void DoHideActors(TArray<class AActor*>* ApActors);
	void EnableCrowdlifeStations();
	void HideActors();
	void RemoveObjects();
	void ShowActors();
	void UnBlockNetworkPaths();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"BFGMissionCinematicVolume">();
	}
	static class ABFGMissionCinematicVolume* GetDefaultObj()
	{
		return GetDefaultObjImpl<ABFGMissionCinematicVolume>();
	}
};
static_assert(alignof(ABFGMissionCinematicVolume) == 0x000008, "Wrong alignment on ABFGMissionCinematicVolume");
static_assert(sizeof(ABFGMissionCinematicVolume) == 0x000440, "Wrong size on ABFGMissionCinematicVolume");
static_assert(offsetof(ABFGMissionCinematicVolume, M_fTagForHidingActors) == 0x0003E0, "Member 'ABFGMissionCinematicVolume::M_fTagForHidingActors' has a wrong offset!");
static_assert(offsetof(ABFGMissionCinematicVolume, M_bRemovePKActors) == 0x0003E8, "Member 'ABFGMissionCinematicVolume::M_bRemovePKActors' has a wrong offset!");
static_assert(offsetof(ABFGMissionCinematicVolume, M_bKillProjectiles) == 0x0003E9, "Member 'ABFGMissionCinematicVolume::M_bKillProjectiles' has a wrong offset!");
static_assert(offsetof(ABFGMissionCinematicVolume, M_bDisableCollisionForActors) == 0x0003EA, "Member 'ABFGMissionCinematicVolume::M_bDisableCollisionForActors' has a wrong offset!");
static_assert(offsetof(ABFGMissionCinematicVolume, M_bHideActors) == 0x0003EB, "Member 'ABFGMissionCinematicVolume::M_bHideActors' has a wrong offset!");
static_assert(offsetof(ABFGMissionCinematicVolume, M_bBlockNetworkPaths) == 0x0003EC, "Member 'ABFGMissionCinematicVolume::M_bBlockNetworkPaths' has a wrong offset!");
static_assert(offsetof(ABFGMissionCinematicVolume, M_bHideCrowdlifeStationActors) == 0x0003ED, "Member 'ABFGMissionCinematicVolume::M_bHideCrowdlifeStationActors' has a wrong offset!");
static_assert(offsetof(ABFGMissionCinematicVolume, M_bCinematicVolumeEnabled) == 0x0003EE, "Member 'ABFGMissionCinematicVolume::M_bCinematicVolumeEnabled' has a wrong offset!");
static_assert(offsetof(ABFGMissionCinematicVolume, M_gameplayTags) == 0x0003F0, "Member 'ABFGMissionCinematicVolume::M_gameplayTags' has a wrong offset!");
static_assert(offsetof(ABFGMissionCinematicVolume, M_aActorData) == 0x000410, "Member 'ABFGMissionCinematicVolume::M_aActorData' has a wrong offset!");
static_assert(offsetof(ABFGMissionCinematicVolume, M_apBlockedNetworkPaths) == 0x000420, "Member 'ABFGMissionCinematicVolume::M_apBlockedNetworkPaths' has a wrong offset!");
static_assert(offsetof(ABFGMissionCinematicVolume, M_apDisabledCrowdlifeStations) == 0x000430, "Member 'ABFGMissionCinematicVolume::M_apDisabledCrowdlifeStations' has a wrong offset!");

// Class BFGCore.BFGMissionConsequence_Alert
// 0x0018 (0x0080 - 0x0068)
class UBFGMissionConsequence_Alert final : public UBFGMissionConsequence
{
public:
	EBFGMissionConsequence_AlertOperation         M_operation;                                       // 0x0068(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_69[0x3];                                       // 0x0069(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	int32                                         M_iResponseIndex;                                  // 0x006C(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          M_bIncrementResponseLevel;                         // 0x0070(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_71[0x7];                                       // 0x0071(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	class UBFGAlertSystemManager*                 M_pAlertSystem;                                    // 0x0078(0x0008)(ExportObject, ZeroConstructor, Transient, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"BFGMissionConsequence_Alert">();
	}
	static class UBFGMissionConsequence_Alert* GetDefaultObj()
	{
		return GetDefaultObjImpl<UBFGMissionConsequence_Alert>();
	}
};
static_assert(alignof(UBFGMissionConsequence_Alert) == 0x000008, "Wrong alignment on UBFGMissionConsequence_Alert");
static_assert(sizeof(UBFGMissionConsequence_Alert) == 0x000080, "Wrong size on UBFGMissionConsequence_Alert");
static_assert(offsetof(UBFGMissionConsequence_Alert, M_operation) == 0x000068, "Member 'UBFGMissionConsequence_Alert::M_operation' has a wrong offset!");
static_assert(offsetof(UBFGMissionConsequence_Alert, M_iResponseIndex) == 0x00006C, "Member 'UBFGMissionConsequence_Alert::M_iResponseIndex' has a wrong offset!");
static_assert(offsetof(UBFGMissionConsequence_Alert, M_bIncrementResponseLevel) == 0x000070, "Member 'UBFGMissionConsequence_Alert::M_bIncrementResponseLevel' has a wrong offset!");
static_assert(offsetof(UBFGMissionConsequence_Alert, M_pAlertSystem) == 0x000078, "Member 'UBFGMissionConsequence_Alert::M_pAlertSystem' has a wrong offset!");

// Class BFGCore.BFGWidget_HUD_AlertLevel
// 0x0070 (0x0368 - 0x02F8)
class UBFGWidget_HUD_AlertLevel : public UBFGWidget_HUD
{
public:
	uint8                                         Pad_2F8[0x8];                                      // 0x02F8(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	TMap<EBFGAlertLevelIconType, struct FBFGAlertLevelIconPack> M_aoAlertLevelIconPacks;                           // 0x0300(0x0050)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, NativeAccessSpecifierPublic)
	uint8                                         Pad_350[0x8];                                      // 0x0350(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<EBFGAlertLevelIconType>                M_aeAlertLevelIconTypes;                           // 0x0358(0x0010)(ZeroConstructor, NativeAccessSpecifierPublic)

public:
	void EnableStealthWarning(bool _bEnable);
	void SetAlertBarPercent(float _fValue);
	void SetAlertDevelopmentState(int32 _iIndex, int32 _iState);
	void SetIconPack(int32 _iIndex, const struct FBFGAlertLevelIconPack& _oIcon);
	void SetInvestigativeBarPercent(float _fValue);
	void SetSeenLevel(EBFGAlertSystemSeenState _eState);
	void SetStealthWarningLevel(EBFGAlertSystemState _eState);
	void TriggerAnimationNewLevelReached(int32 _iIndex);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"BFGWidget_HUD_AlertLevel">();
	}
	static class UBFGWidget_HUD_AlertLevel* GetDefaultObj()
	{
		return GetDefaultObjImpl<UBFGWidget_HUD_AlertLevel>();
	}
};
static_assert(alignof(UBFGWidget_HUD_AlertLevel) == 0x000008, "Wrong alignment on UBFGWidget_HUD_AlertLevel");
static_assert(sizeof(UBFGWidget_HUD_AlertLevel) == 0x000368, "Wrong size on UBFGWidget_HUD_AlertLevel");
static_assert(offsetof(UBFGWidget_HUD_AlertLevel, M_aoAlertLevelIconPacks) == 0x000300, "Member 'UBFGWidget_HUD_AlertLevel::M_aoAlertLevelIconPacks' has a wrong offset!");
static_assert(offsetof(UBFGWidget_HUD_AlertLevel, M_aeAlertLevelIconTypes) == 0x000358, "Member 'UBFGWidget_HUD_AlertLevel::M_aeAlertLevelIconTypes' has a wrong offset!");

// Class BFGCore.BFGMissionConsequence_Blueprint
// 0x0000 (0x0068 - 0x0068)
class UBFGMissionConsequence_Blueprint final : public UBFGMissionConsequence
{
public:
	void ReceiveEndPlay();
	void ReceiveStartPlay();
	void ReceiveUpdate(float _fDelta);

	class AActor* GetSourceActor() const;
	class AActor* GetSourceActorAs(TSubclassOf<class AActor> _pClass) const;
	class UActorComponent* GetSourceComponent(TSubclassOf<class UActorComponent> _pClass) const;
	class AActor* GetTargetActor() const;
	class AActor* GetTargetActorAs(TSubclassOf<class AActor> _pClass) const;
	class UActorComponent* GetTargetComponent(TSubclassOf<class UActorComponent> _pClass) const;
	bool ReceiveIsComplete() const;
	bool ReceiveIsValid() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"BFGMissionConsequence_Blueprint">();
	}
	static class UBFGMissionConsequence_Blueprint* GetDefaultObj()
	{
		return GetDefaultObjImpl<UBFGMissionConsequence_Blueprint>();
	}
};
static_assert(alignof(UBFGMissionConsequence_Blueprint) == 0x000008, "Wrong alignment on UBFGMissionConsequence_Blueprint");
static_assert(sizeof(UBFGMissionConsequence_Blueprint) == 0x000068, "Wrong size on UBFGMissionConsequence_Blueprint");

// Class BFGCore.BFGMissionConsequence_Noise
// 0x0008 (0x0070 - 0x0068)
class UBFGMissionConsequence_Noise final : public UBFGMissionConsequence
{
public:
	float                                         M_fLoudness;                                       // 0x0068(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         M_fMaxRange;                                       // 0x006C(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"BFGMissionConsequence_Noise">();
	}
	static class UBFGMissionConsequence_Noise* GetDefaultObj()
	{
		return GetDefaultObjImpl<UBFGMissionConsequence_Noise>();
	}
};
static_assert(alignof(UBFGMissionConsequence_Noise) == 0x000008, "Wrong alignment on UBFGMissionConsequence_Noise");
static_assert(sizeof(UBFGMissionConsequence_Noise) == 0x000070, "Wrong size on UBFGMissionConsequence_Noise");
static_assert(offsetof(UBFGMissionConsequence_Noise, M_fLoudness) == 0x000068, "Member 'UBFGMissionConsequence_Noise::M_fLoudness' has a wrong offset!");
static_assert(offsetof(UBFGMissionConsequence_Noise, M_fMaxRange) == 0x00006C, "Member 'UBFGMissionConsequence_Noise::M_fMaxRange' has a wrong offset!");

// Class BFGCore.BFGMissionConsequenceRequest
// 0x0020 (0x0048 - 0x0028)
class UBFGMissionConsequenceRequest final : public UObject
{
public:
	uint8                                         Pad_28[0x8];                                       // 0x0028(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	struct FBFGMissionConsequence_Context         M_context;                                         // 0x0030(0x0010)(Transient, NoDestructor, NativeAccessSpecifierPrivate)
	uint8                                         Pad_40[0x8];                                       // 0x0040(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"BFGMissionConsequenceRequest">();
	}
	static class UBFGMissionConsequenceRequest* GetDefaultObj()
	{
		return GetDefaultObjImpl<UBFGMissionConsequenceRequest>();
	}
};
static_assert(alignof(UBFGMissionConsequenceRequest) == 0x000008, "Wrong alignment on UBFGMissionConsequenceRequest");
static_assert(sizeof(UBFGMissionConsequenceRequest) == 0x000048, "Wrong size on UBFGMissionConsequenceRequest");
static_assert(offsetof(UBFGMissionConsequenceRequest, M_context) == 0x000030, "Member 'UBFGMissionConsequenceRequest::M_context' has a wrong offset!");

// Class BFGCore.BFGWidget_HUD_MentalAbilitiesStats
// 0x0028 (0x0320 - 0x02F8)
class UBFGWidget_HUD_MentalAbilitiesStats final : public UBFGWidget_HUD
{
public:
	uint8                                         Pad_2F8[0x8];                                      // 0x02F8(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	int32                                         M_iAmmoCurrent;                                    // 0x0300(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_304[0x4];                                      // 0x0304(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class UUserWidget*                            M_pMentalAbilitiesIcon;                            // 0x0308(0x0008)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         M_iAmmoMax;                                        // 0x0310(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   M_sMentalAbilityName;                              // 0x0314(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_31C[0x4];                                      // 0x031C(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"BFGWidget_HUD_MentalAbilitiesStats">();
	}
	static class UBFGWidget_HUD_MentalAbilitiesStats* GetDefaultObj()
	{
		return GetDefaultObjImpl<UBFGWidget_HUD_MentalAbilitiesStats>();
	}
};
static_assert(alignof(UBFGWidget_HUD_MentalAbilitiesStats) == 0x000008, "Wrong alignment on UBFGWidget_HUD_MentalAbilitiesStats");
static_assert(sizeof(UBFGWidget_HUD_MentalAbilitiesStats) == 0x000320, "Wrong size on UBFGWidget_HUD_MentalAbilitiesStats");
static_assert(offsetof(UBFGWidget_HUD_MentalAbilitiesStats, M_iAmmoCurrent) == 0x000300, "Member 'UBFGWidget_HUD_MentalAbilitiesStats::M_iAmmoCurrent' has a wrong offset!");
static_assert(offsetof(UBFGWidget_HUD_MentalAbilitiesStats, M_pMentalAbilitiesIcon) == 0x000308, "Member 'UBFGWidget_HUD_MentalAbilitiesStats::M_pMentalAbilitiesIcon' has a wrong offset!");
static_assert(offsetof(UBFGWidget_HUD_MentalAbilitiesStats, M_iAmmoMax) == 0x000310, "Member 'UBFGWidget_HUD_MentalAbilitiesStats::M_iAmmoMax' has a wrong offset!");
static_assert(offsetof(UBFGWidget_HUD_MentalAbilitiesStats, M_sMentalAbilityName) == 0x000314, "Member 'UBFGWidget_HUD_MentalAbilitiesStats::M_sMentalAbilityName' has a wrong offset!");

// Class BFGCore.BFGMissionGroup
// 0x00E0 (0x0110 - 0x0030)
class UBFGMissionGroup final : public UDataAsset
{
public:
	uint8                                         Pad_30[0x8];                                       // 0x0030(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	TSoftObjectPtr<class UBFGLoadingScreenInfo>   M_spLoadingscreenInfo;                             // 0x0038(0x0028)(Edit, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FGuid                                  M_guid;                                            // 0x0060(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class FName                                   M_strMissionGroupName;                             // 0x0070(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	struct FBFGMissionCondition                   M_unlockCondition;                                 // 0x0078(0x0020)(Edit, BlueprintVisible, BlueprintReadOnly, DisableEditOnInstance, Protected, NativeAccessSpecifierProtected)
	TArray<TSubclassOf<class UBFGQuest>>          M_aQuestClasses;                                   // 0x0098(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, Protected, UObjectWrapper, NativeAccessSpecifierProtected)
	EBFGMissionGroupType                          M_type;                                            // 0x00A8(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_A9[0x7];                                       // 0x00A9(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	class ABFGGameState*                          M_pGameState;                                      // 0x00B0(0x0008)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UBFGMissionGroup*                       M_pGlobalInstance;                                 // 0x00B8(0x0008)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UBFGVariable*                           M_pVariable;                                       // 0x00C0(0x0008)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UBFGVariable*                           M_pVariableFinished;                               // 0x00C8(0x0008)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_D0[0x8];                                       // 0x00D0(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<class UBFGEvent*>                      M_aEvent;                                          // 0x00D8(0x0010)(ZeroConstructor, Transient, Protected, NativeAccessSpecifierProtected)
	TArray<class UBFGQuest*>                      M_aQuestInstances;                                 // 0x00E8(0x0010)(ZeroConstructor, Transient, Protected, NativeAccessSpecifierProtected)
	uint8                                         Pad_F8[0x8];                                       // 0x00F8(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<class UBFGVariable*>                   M_apQuestVariables;                                // 0x0100(0x0010)(ZeroConstructor, Transient, Protected, NativeAccessSpecifierProtected)

public:
	void OnVarChanged(class UBFGVariableMirror* _pVarMirror, const class UBFGVariable* _pVariable, int32 _iOldValue, int32 _iNewValue);

	class UBFGVariable* GetVariable() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"BFGMissionGroup">();
	}
	static class UBFGMissionGroup* GetDefaultObj()
	{
		return GetDefaultObjImpl<UBFGMissionGroup>();
	}
};
static_assert(alignof(UBFGMissionGroup) == 0x000008, "Wrong alignment on UBFGMissionGroup");
static_assert(sizeof(UBFGMissionGroup) == 0x000110, "Wrong size on UBFGMissionGroup");
static_assert(offsetof(UBFGMissionGroup, M_spLoadingscreenInfo) == 0x000038, "Member 'UBFGMissionGroup::M_spLoadingscreenInfo' has a wrong offset!");
static_assert(offsetof(UBFGMissionGroup, M_guid) == 0x000060, "Member 'UBFGMissionGroup::M_guid' has a wrong offset!");
static_assert(offsetof(UBFGMissionGroup, M_strMissionGroupName) == 0x000070, "Member 'UBFGMissionGroup::M_strMissionGroupName' has a wrong offset!");
static_assert(offsetof(UBFGMissionGroup, M_unlockCondition) == 0x000078, "Member 'UBFGMissionGroup::M_unlockCondition' has a wrong offset!");
static_assert(offsetof(UBFGMissionGroup, M_aQuestClasses) == 0x000098, "Member 'UBFGMissionGroup::M_aQuestClasses' has a wrong offset!");
static_assert(offsetof(UBFGMissionGroup, M_type) == 0x0000A8, "Member 'UBFGMissionGroup::M_type' has a wrong offset!");
static_assert(offsetof(UBFGMissionGroup, M_pGameState) == 0x0000B0, "Member 'UBFGMissionGroup::M_pGameState' has a wrong offset!");
static_assert(offsetof(UBFGMissionGroup, M_pGlobalInstance) == 0x0000B8, "Member 'UBFGMissionGroup::M_pGlobalInstance' has a wrong offset!");
static_assert(offsetof(UBFGMissionGroup, M_pVariable) == 0x0000C0, "Member 'UBFGMissionGroup::M_pVariable' has a wrong offset!");
static_assert(offsetof(UBFGMissionGroup, M_pVariableFinished) == 0x0000C8, "Member 'UBFGMissionGroup::M_pVariableFinished' has a wrong offset!");
static_assert(offsetof(UBFGMissionGroup, M_aEvent) == 0x0000D8, "Member 'UBFGMissionGroup::M_aEvent' has a wrong offset!");
static_assert(offsetof(UBFGMissionGroup, M_aQuestInstances) == 0x0000E8, "Member 'UBFGMissionGroup::M_aQuestInstances' has a wrong offset!");
static_assert(offsetof(UBFGMissionGroup, M_apQuestVariables) == 0x000100, "Member 'UBFGMissionGroup::M_apQuestVariables' has a wrong offset!");

// Class BFGCore.BFGMissionInterface
// 0x0000 (0x0028 - 0x0028)
class IBFGMissionInterface final : public IInterface
{
public:
	struct FGuid GetGuid() const;
	TArray<class UObject*> GetUsedMissionObjects(class ABFGGameState* _pGameState) const;
	bool HasRegistredVariable(class UBFGVariableMirror* _pVarMirror) const;
	TArray<class UBFGVariable*> RegisterVariables(class UObject* _pVariableOwner, class UBFGVariableMirror* _pVarMirror) const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"BFGMissionInterface">();
	}
	static class IBFGMissionInterface* GetDefaultObj()
	{
		return GetDefaultObjImpl<IBFGMissionInterface>();
	}
};
static_assert(alignof(IBFGMissionInterface) == 0x000008, "Wrong alignment on IBFGMissionInterface");
static_assert(sizeof(IBFGMissionInterface) == 0x000028, "Wrong size on IBFGMissionInterface");

// Class BFGCore.BFGMissionOrbitalTransporter
// 0x00E0 (0x04B8 - 0x03D8)
class ABFGMissionOrbitalTransporter final : public AActor
{
public:
	uint8                                         Pad_3D8[0x8];                                      // 0x03D8(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         M_fRadius;                                         // 0x03E0(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_3E4[0x4];                                      // 0x03E4(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	struct FGameplayTagContainer                  M_oGameplayTags;                                   // 0x03E8(0x0020)(Edit, BlueprintVisible, BlueprintReadOnly, Protected, NativeAccessSpecifierProtected)
	TArray<struct FBFGActorBinding>               M_aActivateWith;                                   // 0x0408(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Protected, NativeAccessSpecifierProtected)
	struct FGameplayTagContainer                  M_oGrantedTags;                                    // 0x0418(0x0020)(Edit, BlueprintVisible, BlueprintReadOnly, DisableEditOnInstance, Protected, NativeAccessSpecifierProtected)
	bool                                          M_bInformQuestOnEnter;                             // 0x0438(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_439[0x7];                                      // 0x0439(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<class AActor*>                         M_apTestedActors;                                  // 0x0440(0x0010)(ZeroConstructor, Transient, Protected, NativeAccessSpecifierProtected)
	TArray<struct FBFGMissionOrbitalTransporterTarget> M_aDeliveredActors;                                // 0x0450(0x0010)(ZeroConstructor, Transient, Protected, NativeAccessSpecifierProtected)
	class UBFGActorComponent_RadarObject*         M_pRadarComponent;                                 // 0x0460(0x0008)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, EditConst, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         M_fInitialSlowDownTime;                            // 0x0468(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         M_fInitialLinearDamping;                           // 0x046C(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         M_fInitialAngularDamping;                          // 0x0470(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         M_fHangTime;                                       // 0x0474(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         M_fHangFrequency;                                  // 0x0478(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         M_fHangForce;                                      // 0x047C(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         M_fHangTorque;                                     // 0x0480(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         M_fHangLinearDamping;                              // 0x0484(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         M_fHangAngularDamping;                             // 0x0488(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         M_fHangRandMin;                                    // 0x048C(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         M_fHangCentralForceRadiusOffset;                   // 0x0490(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         M_fHangCentralForce;                               // 0x0494(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         M_fAbductForce;                                    // 0x0498(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         M_fAbductCenterAttractionForce;                    // 0x049C(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         M_fAbductCutoffTime;                               // 0x04A0(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_4A4[0x4];                                      // 0x04A4(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class ABFGMissionPath*                        M_pPath;                                           // 0x04A8(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnTemplate, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         M_fPathZOffset;                                    // 0x04B0(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnTemplate, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_4B4[0x4];                                      // 0x04B4(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void OnSaveSystemLoad(class UBFGSaveSystem* _pSaveSystem, class UBFGSaveSystem_Action* _pAction);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"BFGMissionOrbitalTransporter">();
	}
	static class ABFGMissionOrbitalTransporter* GetDefaultObj()
	{
		return GetDefaultObjImpl<ABFGMissionOrbitalTransporter>();
	}
};
static_assert(alignof(ABFGMissionOrbitalTransporter) == 0x000008, "Wrong alignment on ABFGMissionOrbitalTransporter");
static_assert(sizeof(ABFGMissionOrbitalTransporter) == 0x0004B8, "Wrong size on ABFGMissionOrbitalTransporter");
static_assert(offsetof(ABFGMissionOrbitalTransporter, M_fRadius) == 0x0003E0, "Member 'ABFGMissionOrbitalTransporter::M_fRadius' has a wrong offset!");
static_assert(offsetof(ABFGMissionOrbitalTransporter, M_oGameplayTags) == 0x0003E8, "Member 'ABFGMissionOrbitalTransporter::M_oGameplayTags' has a wrong offset!");
static_assert(offsetof(ABFGMissionOrbitalTransporter, M_aActivateWith) == 0x000408, "Member 'ABFGMissionOrbitalTransporter::M_aActivateWith' has a wrong offset!");
static_assert(offsetof(ABFGMissionOrbitalTransporter, M_oGrantedTags) == 0x000418, "Member 'ABFGMissionOrbitalTransporter::M_oGrantedTags' has a wrong offset!");
static_assert(offsetof(ABFGMissionOrbitalTransporter, M_bInformQuestOnEnter) == 0x000438, "Member 'ABFGMissionOrbitalTransporter::M_bInformQuestOnEnter' has a wrong offset!");
static_assert(offsetof(ABFGMissionOrbitalTransporter, M_apTestedActors) == 0x000440, "Member 'ABFGMissionOrbitalTransporter::M_apTestedActors' has a wrong offset!");
static_assert(offsetof(ABFGMissionOrbitalTransporter, M_aDeliveredActors) == 0x000450, "Member 'ABFGMissionOrbitalTransporter::M_aDeliveredActors' has a wrong offset!");
static_assert(offsetof(ABFGMissionOrbitalTransporter, M_pRadarComponent) == 0x000460, "Member 'ABFGMissionOrbitalTransporter::M_pRadarComponent' has a wrong offset!");
static_assert(offsetof(ABFGMissionOrbitalTransporter, M_fInitialSlowDownTime) == 0x000468, "Member 'ABFGMissionOrbitalTransporter::M_fInitialSlowDownTime' has a wrong offset!");
static_assert(offsetof(ABFGMissionOrbitalTransporter, M_fInitialLinearDamping) == 0x00046C, "Member 'ABFGMissionOrbitalTransporter::M_fInitialLinearDamping' has a wrong offset!");
static_assert(offsetof(ABFGMissionOrbitalTransporter, M_fInitialAngularDamping) == 0x000470, "Member 'ABFGMissionOrbitalTransporter::M_fInitialAngularDamping' has a wrong offset!");
static_assert(offsetof(ABFGMissionOrbitalTransporter, M_fHangTime) == 0x000474, "Member 'ABFGMissionOrbitalTransporter::M_fHangTime' has a wrong offset!");
static_assert(offsetof(ABFGMissionOrbitalTransporter, M_fHangFrequency) == 0x000478, "Member 'ABFGMissionOrbitalTransporter::M_fHangFrequency' has a wrong offset!");
static_assert(offsetof(ABFGMissionOrbitalTransporter, M_fHangForce) == 0x00047C, "Member 'ABFGMissionOrbitalTransporter::M_fHangForce' has a wrong offset!");
static_assert(offsetof(ABFGMissionOrbitalTransporter, M_fHangTorque) == 0x000480, "Member 'ABFGMissionOrbitalTransporter::M_fHangTorque' has a wrong offset!");
static_assert(offsetof(ABFGMissionOrbitalTransporter, M_fHangLinearDamping) == 0x000484, "Member 'ABFGMissionOrbitalTransporter::M_fHangLinearDamping' has a wrong offset!");
static_assert(offsetof(ABFGMissionOrbitalTransporter, M_fHangAngularDamping) == 0x000488, "Member 'ABFGMissionOrbitalTransporter::M_fHangAngularDamping' has a wrong offset!");
static_assert(offsetof(ABFGMissionOrbitalTransporter, M_fHangRandMin) == 0x00048C, "Member 'ABFGMissionOrbitalTransporter::M_fHangRandMin' has a wrong offset!");
static_assert(offsetof(ABFGMissionOrbitalTransporter, M_fHangCentralForceRadiusOffset) == 0x000490, "Member 'ABFGMissionOrbitalTransporter::M_fHangCentralForceRadiusOffset' has a wrong offset!");
static_assert(offsetof(ABFGMissionOrbitalTransporter, M_fHangCentralForce) == 0x000494, "Member 'ABFGMissionOrbitalTransporter::M_fHangCentralForce' has a wrong offset!");
static_assert(offsetof(ABFGMissionOrbitalTransporter, M_fAbductForce) == 0x000498, "Member 'ABFGMissionOrbitalTransporter::M_fAbductForce' has a wrong offset!");
static_assert(offsetof(ABFGMissionOrbitalTransporter, M_fAbductCenterAttractionForce) == 0x00049C, "Member 'ABFGMissionOrbitalTransporter::M_fAbductCenterAttractionForce' has a wrong offset!");
static_assert(offsetof(ABFGMissionOrbitalTransporter, M_fAbductCutoffTime) == 0x0004A0, "Member 'ABFGMissionOrbitalTransporter::M_fAbductCutoffTime' has a wrong offset!");
static_assert(offsetof(ABFGMissionOrbitalTransporter, M_pPath) == 0x0004A8, "Member 'ABFGMissionOrbitalTransporter::M_pPath' has a wrong offset!");
static_assert(offsetof(ABFGMissionOrbitalTransporter, M_fPathZOffset) == 0x0004B0, "Member 'ABFGMissionOrbitalTransporter::M_fPathZOffset' has a wrong offset!");

// Class BFGCore.BFGWidget_HUD_ProximityMonitor
// 0x0000 (0x0240 - 0x0240)
class UBFGWidget_HUD_ProximityMonitor : public UUserWidget
{
public:
	void OnDistanceTextChanged(const class FText& StrDistance);
	void OnSubgoalReached();
	void OnWarningAreaChanged(bool Entered);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"BFGWidget_HUD_ProximityMonitor">();
	}
	static class UBFGWidget_HUD_ProximityMonitor* GetDefaultObj()
	{
		return GetDefaultObjImpl<UBFGWidget_HUD_ProximityMonitor>();
	}
};
static_assert(alignof(UBFGWidget_HUD_ProximityMonitor) == 0x000008, "Wrong alignment on UBFGWidget_HUD_ProximityMonitor");
static_assert(sizeof(UBFGWidget_HUD_ProximityMonitor) == 0x000240, "Wrong size on UBFGWidget_HUD_ProximityMonitor");

// Class BFGCore.BFGMissionPath
// 0x0020 (0x03F8 - 0x03D8)
class ABFGMissionPath final : public AActor
{
public:
	class USplineComponent*                       M_pPathComponent;                                  // 0x03D8(0x0008)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, EditConst, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         M_fStepSize;                                       // 0x03E0(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         M_fProgress;                                       // 0x03E4(0x0004)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class AActor*                                 M_pGoal;                                           // 0x03E8(0x0008)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UBFGNetworkPath*                        M_pNetworkPath;                                    // 0x03F0(0x0008)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"BFGMissionPath">();
	}
	static class ABFGMissionPath* GetDefaultObj()
	{
		return GetDefaultObjImpl<ABFGMissionPath>();
	}
};
static_assert(alignof(ABFGMissionPath) == 0x000008, "Wrong alignment on ABFGMissionPath");
static_assert(sizeof(ABFGMissionPath) == 0x0003F8, "Wrong size on ABFGMissionPath");
static_assert(offsetof(ABFGMissionPath, M_pPathComponent) == 0x0003D8, "Member 'ABFGMissionPath::M_pPathComponent' has a wrong offset!");
static_assert(offsetof(ABFGMissionPath, M_fStepSize) == 0x0003E0, "Member 'ABFGMissionPath::M_fStepSize' has a wrong offset!");
static_assert(offsetof(ABFGMissionPath, M_fProgress) == 0x0003E4, "Member 'ABFGMissionPath::M_fProgress' has a wrong offset!");
static_assert(offsetof(ABFGMissionPath, M_pGoal) == 0x0003E8, "Member 'ABFGMissionPath::M_pGoal' has a wrong offset!");
static_assert(offsetof(ABFGMissionPath, M_pNetworkPath) == 0x0003F0, "Member 'ABFGMissionPath::M_pNetworkPath' has a wrong offset!");

// Class BFGCore.BFGMissionPathSplineComponent
// 0x0020 (0x0770 - 0x0750)
class UBFGMissionPathSplineComponent final : public USplineComponent
{
public:
	struct FBFGPatrolPathInfo                     M_patrolPathInfo;                                  // 0x0750(0x0018)(Edit, BlueprintVisible, BlueprintReadOnly, Protected, NativeAccessSpecifierProtected)
	uint8                                         Pad_768[0x8];                                      // 0x0768(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"BFGMissionPathSplineComponent">();
	}
	static class UBFGMissionPathSplineComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UBFGMissionPathSplineComponent>();
	}
};
static_assert(alignof(UBFGMissionPathSplineComponent) == 0x000008, "Wrong alignment on UBFGMissionPathSplineComponent");
static_assert(sizeof(UBFGMissionPathSplineComponent) == 0x000770, "Wrong size on UBFGMissionPathSplineComponent");
static_assert(offsetof(UBFGMissionPathSplineComponent, M_patrolPathInfo) == 0x000750, "Member 'UBFGMissionPathSplineComponent::M_patrolPathInfo' has a wrong offset!");

// Class BFGCore.BFGMissionSpawnerGroup
// 0x0198 (0x0570 - 0x03D8)
class ABFGMissionSpawnerGroup final : public AActor
{
public:
	uint8                                         Pad_3D8[0x10];                                     // 0x03D8(0x0010)(Fixing Size After Last Property [ Dumper-7 ])
	class UBFGActorComponent_Objective*           M_pObjectiveComponent;                             // 0x03E8(0x0008)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, EditConst, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	struct FGameplayTagContainer                  M_gameplayTags;                                    // 0x03F0(0x0020)(Edit, BlueprintVisible, BlueprintReadOnly, DisableEditOnTemplate, Protected, NativeAccessSpecifierProtected)
	uint8                                         Pad_410[0x8];                                      // 0x0410(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<class ABFGMissionSpawner*>             M_aSpawners;                                       // 0x0418(0x0010)(ZeroConstructor, Transient, Protected, NativeAccessSpecifierProtected)
	struct FBFGMissionSpawnRequest                M_spawnRequest;                                    // 0x0428(0x0148)(Transient, ContainsInstancedReference, Protected, NativeAccessSpecifierProtected)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"BFGMissionSpawnerGroup">();
	}
	static class ABFGMissionSpawnerGroup* GetDefaultObj()
	{
		return GetDefaultObjImpl<ABFGMissionSpawnerGroup>();
	}
};
static_assert(alignof(ABFGMissionSpawnerGroup) == 0x000008, "Wrong alignment on ABFGMissionSpawnerGroup");
static_assert(sizeof(ABFGMissionSpawnerGroup) == 0x000570, "Wrong size on ABFGMissionSpawnerGroup");
static_assert(offsetof(ABFGMissionSpawnerGroup, M_pObjectiveComponent) == 0x0003E8, "Member 'ABFGMissionSpawnerGroup::M_pObjectiveComponent' has a wrong offset!");
static_assert(offsetof(ABFGMissionSpawnerGroup, M_gameplayTags) == 0x0003F0, "Member 'ABFGMissionSpawnerGroup::M_gameplayTags' has a wrong offset!");
static_assert(offsetof(ABFGMissionSpawnerGroup, M_aSpawners) == 0x000418, "Member 'ABFGMissionSpawnerGroup::M_aSpawners' has a wrong offset!");
static_assert(offsetof(ABFGMissionSpawnerGroup, M_spawnRequest) == 0x000428, "Member 'ABFGMissionSpawnerGroup::M_spawnRequest' has a wrong offset!");

// Class BFGCore.BFGMissionSpawnManager
// 0x0150 (0x0528 - 0x03D8)
class ABFGMissionSpawnManager final : public AActor
{
public:
	uint8                                         Pad_3D8[0x8];                                      // 0x03D8(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	UMulticastDelegateProperty_                   M_OnSpawnedActor;                                  // 0x03E0(0x0018)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	TArray<struct FBFGMissionSpawnManager_Wave>   M_aWaves;                                          // 0x03F8(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnTemplate, ContainsInstancedReference, Protected, NativeAccessSpecifierProtected)
	bool                                          M_bLoopWaves;                                      // 0x0408(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnTemplate, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_409[0x3];                                      // 0x0409(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	struct FGameplayTag                           M_SpawnersTag;                                     // 0x040C(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, DisableEditOnTemplate, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_414[0x4];                                      // 0x0414(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	struct FBFGObjectiveMarkerInfo                M_SpawnersMarkerInfo;                              // 0x0418(0x0028)(Edit, BlueprintVisible, BlueprintReadOnly, ContainsInstancedReference, Protected, NativeAccessSpecifierProtected)
	struct FGameplayTag                           M_AttackersTag;                                    // 0x0440(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, DisableEditOnTemplate, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	struct FGameplayTagContainer                  M_AttackersAdditionalTags;                         // 0x0448(0x0020)(Edit, BlueprintVisible, BlueprintReadOnly, DisableEditOnTemplate, Protected, NativeAccessSpecifierProtected)
	struct FBFGObjectiveMarkerInfo                M_AttackersMarkerInfo;                             // 0x0468(0x0028)(Edit, BlueprintVisible, BlueprintReadOnly, ContainsInstancedReference, Protected, NativeAccessSpecifierProtected)
	TArray<TSubclassOf<class AActor>>             M_aNpcClassesToTag;                                // 0x0490(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnTemplate, Protected, UObjectWrapper, NativeAccessSpecifierProtected)
	bool                                          M_bRequestInitialSpawnFinished;                    // 0x04A0(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnTemplate, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_4A1[0x7];                                      // 0x04A1(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	struct FGameplayTagContainer                  M_gameplayTags;                                    // 0x04A8(0x0020)(Edit, BlueprintVisible, BlueprintReadOnly, DisableEditOnTemplate, Protected, NativeAccessSpecifierProtected)
	uint8                                         Pad_4C8[0x18];                                     // 0x04C8(0x0018)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<class ABFGMissionSpawnerGroup*>        M_aSpawnerGroups;                                  // 0x04E0(0x0010)(ZeroConstructor, Transient, Protected, NativeAccessSpecifierProtected)
	uint8                                         Pad_4F0[0x10];                                     // 0x04F0(0x0010)(Fixing Size After Last Property [ Dumper-7 ])
	class UBFGObjectiveMarkerGroup*               M_SpawnersMarkerGroup;                             // 0x0500(0x0008)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UBFGObjectiveMarkerGroup*               M_AttackersMarkerGroup;                            // 0x0508(0x0008)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UBFGActorComponent_SpawnManagerStats*   M_pStatsComponent;                                 // 0x0510(0x0008)(ExportObject, ZeroConstructor, Transient, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_518[0x10];                                     // 0x0518(0x0010)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	class UBFGScriptedSequence* CreateNewScriptSequence(class AActor* _pActor, bool _bAutoStart, bool _bRemoveWhenDone);
	void OnActorDestroyed(class AActor* _pActor);
	void OnDeadStatusChanged(class AActor* _pActor, class UBFGActorStat_Bool* _pStat);
	void OnSpawned(class AActor* _pActor, const struct FBFGMissionSpawner_SpawnedParameters& _params);
	void SetActive(bool _bActive, bool _bForce);

	bool IsActive() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"BFGMissionSpawnManager">();
	}
	static class ABFGMissionSpawnManager* GetDefaultObj()
	{
		return GetDefaultObjImpl<ABFGMissionSpawnManager>();
	}
};
static_assert(alignof(ABFGMissionSpawnManager) == 0x000008, "Wrong alignment on ABFGMissionSpawnManager");
static_assert(sizeof(ABFGMissionSpawnManager) == 0x000528, "Wrong size on ABFGMissionSpawnManager");
static_assert(offsetof(ABFGMissionSpawnManager, M_OnSpawnedActor) == 0x0003E0, "Member 'ABFGMissionSpawnManager::M_OnSpawnedActor' has a wrong offset!");
static_assert(offsetof(ABFGMissionSpawnManager, M_aWaves) == 0x0003F8, "Member 'ABFGMissionSpawnManager::M_aWaves' has a wrong offset!");
static_assert(offsetof(ABFGMissionSpawnManager, M_bLoopWaves) == 0x000408, "Member 'ABFGMissionSpawnManager::M_bLoopWaves' has a wrong offset!");
static_assert(offsetof(ABFGMissionSpawnManager, M_SpawnersTag) == 0x00040C, "Member 'ABFGMissionSpawnManager::M_SpawnersTag' has a wrong offset!");
static_assert(offsetof(ABFGMissionSpawnManager, M_SpawnersMarkerInfo) == 0x000418, "Member 'ABFGMissionSpawnManager::M_SpawnersMarkerInfo' has a wrong offset!");
static_assert(offsetof(ABFGMissionSpawnManager, M_AttackersTag) == 0x000440, "Member 'ABFGMissionSpawnManager::M_AttackersTag' has a wrong offset!");
static_assert(offsetof(ABFGMissionSpawnManager, M_AttackersAdditionalTags) == 0x000448, "Member 'ABFGMissionSpawnManager::M_AttackersAdditionalTags' has a wrong offset!");
static_assert(offsetof(ABFGMissionSpawnManager, M_AttackersMarkerInfo) == 0x000468, "Member 'ABFGMissionSpawnManager::M_AttackersMarkerInfo' has a wrong offset!");
static_assert(offsetof(ABFGMissionSpawnManager, M_aNpcClassesToTag) == 0x000490, "Member 'ABFGMissionSpawnManager::M_aNpcClassesToTag' has a wrong offset!");
static_assert(offsetof(ABFGMissionSpawnManager, M_bRequestInitialSpawnFinished) == 0x0004A0, "Member 'ABFGMissionSpawnManager::M_bRequestInitialSpawnFinished' has a wrong offset!");
static_assert(offsetof(ABFGMissionSpawnManager, M_gameplayTags) == 0x0004A8, "Member 'ABFGMissionSpawnManager::M_gameplayTags' has a wrong offset!");
static_assert(offsetof(ABFGMissionSpawnManager, M_aSpawnerGroups) == 0x0004E0, "Member 'ABFGMissionSpawnManager::M_aSpawnerGroups' has a wrong offset!");
static_assert(offsetof(ABFGMissionSpawnManager, M_SpawnersMarkerGroup) == 0x000500, "Member 'ABFGMissionSpawnManager::M_SpawnersMarkerGroup' has a wrong offset!");
static_assert(offsetof(ABFGMissionSpawnManager, M_AttackersMarkerGroup) == 0x000508, "Member 'ABFGMissionSpawnManager::M_AttackersMarkerGroup' has a wrong offset!");
static_assert(offsetof(ABFGMissionSpawnManager, M_pStatsComponent) == 0x000510, "Member 'ABFGMissionSpawnManager::M_pStatsComponent' has a wrong offset!");

// Class BFGCore.BFGVariableAction_MissionGroup_InProgress
// 0x0000 (0x00F0 - 0x00F0)
class UBFGVariableAction_MissionGroup_InProgress final : public UBFGVariableAction
{
public:
	static const class FName GetActionName_MissionGroupInProgress();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"BFGVariableAction_MissionGroup_InProgress">();
	}
	static class UBFGVariableAction_MissionGroup_InProgress* GetDefaultObj()
	{
		return GetDefaultObjImpl<UBFGVariableAction_MissionGroup_InProgress>();
	}
};
static_assert(alignof(UBFGVariableAction_MissionGroup_InProgress) == 0x000008, "Wrong alignment on UBFGVariableAction_MissionGroup_InProgress");
static_assert(sizeof(UBFGVariableAction_MissionGroup_InProgress) == 0x0000F0, "Wrong size on UBFGVariableAction_MissionGroup_InProgress");

// Class BFGCore.BFGMissionSpawnRequestAsset
// 0x00F8 (0x0128 - 0x0030)
class UBFGMissionSpawnRequestAsset final : public UDataAsset
{
public:
	TSubclassOf<class AActor>                     M_pClass;                                          // 0x0030(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          M_bIsEnemyVehicle;                                 // 0x0038(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_39[0x7];                                       // 0x0039(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	struct FBFGPassengersData                     M_passengerData;                                   // 0x0040(0x0038)(Edit, BlueprintVisible, BlueprintReadOnly, DisableEditOnInstance, NativeAccessSpecifierPublic)
	struct FBFGAgentAIData                        M_agentAIData;                                     // 0x0078(0x00B0)(Edit, DisableEditOnInstance, ContainsInstancedReference, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"BFGMissionSpawnRequestAsset">();
	}
	static class UBFGMissionSpawnRequestAsset* GetDefaultObj()
	{
		return GetDefaultObjImpl<UBFGMissionSpawnRequestAsset>();
	}
};
static_assert(alignof(UBFGMissionSpawnRequestAsset) == 0x000008, "Wrong alignment on UBFGMissionSpawnRequestAsset");
static_assert(sizeof(UBFGMissionSpawnRequestAsset) == 0x000128, "Wrong size on UBFGMissionSpawnRequestAsset");
static_assert(offsetof(UBFGMissionSpawnRequestAsset, M_pClass) == 0x000030, "Member 'UBFGMissionSpawnRequestAsset::M_pClass' has a wrong offset!");
static_assert(offsetof(UBFGMissionSpawnRequestAsset, M_bIsEnemyVehicle) == 0x000038, "Member 'UBFGMissionSpawnRequestAsset::M_bIsEnemyVehicle' has a wrong offset!");
static_assert(offsetof(UBFGMissionSpawnRequestAsset, M_passengerData) == 0x000040, "Member 'UBFGMissionSpawnRequestAsset::M_passengerData' has a wrong offset!");
static_assert(offsetof(UBFGMissionSpawnRequestAsset, M_agentAIData) == 0x000078, "Member 'UBFGMissionSpawnRequestAsset::M_agentAIData' has a wrong offset!");

// Class BFGCore.BFGMissionSystem
// 0x0118 (0x0148 - 0x0030)
class UBFGMissionSystem final : public UBFGGameSystem
{
public:
	uint8                                         Pad_30[0x10];                                      // 0x0030(0x0010)(Fixing Size After Last Property [ Dumper-7 ])
	class ABFGGameState*                          M_pGameState;                                      // 0x0040(0x0008)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TMap<struct FGuid, class UBFGMissionGroup*>   M_apMissionGroups;                                 // 0x0048(0x0050)(ZeroConstructor, Transient, Protected, NativeAccessSpecifierProtected)
	TMap<class FString, class UBFGMissionWorldState*> M_apWorldState;                                    // 0x0098(0x0050)(ZeroConstructor, Transient, Protected, NativeAccessSpecifierProtected)
	struct FBFGDebugStartMenu_EntryData           M_mapEntryData;                                    // 0x00E8(0x0050)(Transient, Protected, NativeAccessSpecifierProtected)
	TArray<class UBFGVariable*>                   M_aExtraVariables;                                 // 0x0138(0x0010)(ZeroConstructor, Transient, Protected, NativeAccessSpecifierProtected)

public:
	void OnWorldLoaded(class UBFGGameInstance* _pGameInstance, class UWorld* _pWorld);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"BFGMissionSystem">();
	}
	static class UBFGMissionSystem* GetDefaultObj()
	{
		return GetDefaultObjImpl<UBFGMissionSystem>();
	}
};
static_assert(alignof(UBFGMissionSystem) == 0x000008, "Wrong alignment on UBFGMissionSystem");
static_assert(sizeof(UBFGMissionSystem) == 0x000148, "Wrong size on UBFGMissionSystem");
static_assert(offsetof(UBFGMissionSystem, M_pGameState) == 0x000040, "Member 'UBFGMissionSystem::M_pGameState' has a wrong offset!");
static_assert(offsetof(UBFGMissionSystem, M_apMissionGroups) == 0x000048, "Member 'UBFGMissionSystem::M_apMissionGroups' has a wrong offset!");
static_assert(offsetof(UBFGMissionSystem, M_apWorldState) == 0x000098, "Member 'UBFGMissionSystem::M_apWorldState' has a wrong offset!");
static_assert(offsetof(UBFGMissionSystem, M_mapEntryData) == 0x0000E8, "Member 'UBFGMissionSystem::M_mapEntryData' has a wrong offset!");
static_assert(offsetof(UBFGMissionSystem, M_aExtraVariables) == 0x000138, "Member 'UBFGMissionSystem::M_aExtraVariables' has a wrong offset!");

// Class BFGCore.BFGMothershipSubstate_Archives
// 0x0000 (0x00D0 - 0x00D0)
class UBFGMothershipSubstate_Archives final : public UBFGMothershipSubstate
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"BFGMothershipSubstate_Archives">();
	}
	static class UBFGMothershipSubstate_Archives* GetDefaultObj()
	{
		return GetDefaultObjImpl<UBFGMothershipSubstate_Archives>();
	}
};
static_assert(alignof(UBFGMothershipSubstate_Archives) == 0x000008, "Wrong alignment on UBFGMothershipSubstate_Archives");
static_assert(sizeof(UBFGMothershipSubstate_Archives) == 0x0000D0, "Wrong size on UBFGMothershipSubstate_Archives");

// Class BFGCore.BFGVariableAction_Quest_MakeUnavailable
// 0x0000 (0x00F0 - 0x00F0)
class UBFGVariableAction_Quest_MakeUnavailable final : public UBFGVariableAction
{
public:
	static const class FName GetActionName_QuestMakeUnavailable();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"BFGVariableAction_Quest_MakeUnavailable">();
	}
	static class UBFGVariableAction_Quest_MakeUnavailable* GetDefaultObj()
	{
		return GetDefaultObjImpl<UBFGVariableAction_Quest_MakeUnavailable>();
	}
};
static_assert(alignof(UBFGVariableAction_Quest_MakeUnavailable) == 0x000008, "Wrong alignment on UBFGVariableAction_Quest_MakeUnavailable");
static_assert(sizeof(UBFGVariableAction_Quest_MakeUnavailable) == 0x0000F0, "Wrong size on UBFGVariableAction_Quest_MakeUnavailable");

// Class BFGCore.BFGMothershipSubstate_Deck
// 0x0000 (0x00D0 - 0x00D0)
class UBFGMothershipSubstate_Deck final : public UBFGMothershipSubstate
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"BFGMothershipSubstate_Deck">();
	}
	static class UBFGMothershipSubstate_Deck* GetDefaultObj()
	{
		return GetDefaultObjImpl<UBFGMothershipSubstate_Deck>();
	}
};
static_assert(alignof(UBFGMothershipSubstate_Deck) == 0x000008, "Wrong alignment on UBFGMothershipSubstate_Deck");
static_assert(sizeof(UBFGMothershipSubstate_Deck) == 0x0000D0, "Wrong size on UBFGMothershipSubstate_Deck");

// Class BFGCore.BFGMothershipSubstate_InvasionReport
// 0x0000 (0x00D0 - 0x00D0)
class UBFGMothershipSubstate_InvasionReport final : public UBFGMothershipSubstate
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"BFGMothershipSubstate_InvasionReport">();
	}
	static class UBFGMothershipSubstate_InvasionReport* GetDefaultObj()
	{
		return GetDefaultObjImpl<UBFGMothershipSubstate_InvasionReport>();
	}
};
static_assert(alignof(UBFGMothershipSubstate_InvasionReport) == 0x000008, "Wrong alignment on UBFGMothershipSubstate_InvasionReport");
static_assert(sizeof(UBFGMothershipSubstate_InvasionReport) == 0x0000D0, "Wrong size on UBFGMothershipSubstate_InvasionReport");

// Class BFGCore.BFGMothershipSubstate_PoxLab
// 0x0018 (0x00E8 - 0x00D0)
class UBFGMothershipSubstate_PoxLab final : public UBFGMothershipSubstate
{
public:
	TArray<class UBFGDataAssetPoxLabUpgrade*>     M_apUpgrads;                                       // 0x00D0(0x0010)(Edit, ZeroConstructor, DisableEditOnInstance, NativeAccessSpecifierPublic)
	bool                                          M_bIsInitialized;                                  // 0x00E0(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_E1[0x7];                                       // 0x00E1(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void ApplyUpgrade(class UBFGDataAssetPoxLabUpgrade* _pUpgrade);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"BFGMothershipSubstate_PoxLab">();
	}
	static class UBFGMothershipSubstate_PoxLab* GetDefaultObj()
	{
		return GetDefaultObjImpl<UBFGMothershipSubstate_PoxLab>();
	}
};
static_assert(alignof(UBFGMothershipSubstate_PoxLab) == 0x000008, "Wrong alignment on UBFGMothershipSubstate_PoxLab");
static_assert(sizeof(UBFGMothershipSubstate_PoxLab) == 0x0000E8, "Wrong size on UBFGMothershipSubstate_PoxLab");
static_assert(offsetof(UBFGMothershipSubstate_PoxLab, M_apUpgrads) == 0x0000D0, "Member 'UBFGMothershipSubstate_PoxLab::M_apUpgrads' has a wrong offset!");
static_assert(offsetof(UBFGMothershipSubstate_PoxLab, M_bIsInitialized) == 0x0000E0, "Member 'UBFGMothershipSubstate_PoxLab::M_bIsInitialized' has a wrong offset!");

// Class BFGCore.BFGVariableAction_Quest_Finish
// 0x0000 (0x00F0 - 0x00F0)
class UBFGVariableAction_Quest_Finish final : public UBFGVariableAction
{
public:
	static const class FName GetActionName_QuestFinish();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"BFGVariableAction_Quest_Finish">();
	}
	static class UBFGVariableAction_Quest_Finish* GetDefaultObj()
	{
		return GetDefaultObjImpl<UBFGVariableAction_Quest_Finish>();
	}
};
static_assert(alignof(UBFGVariableAction_Quest_Finish) == 0x000008, "Wrong alignment on UBFGVariableAction_Quest_Finish");
static_assert(sizeof(UBFGVariableAction_Quest_Finish) == 0x0000F0, "Wrong size on UBFGVariableAction_Quest_Finish");

// Class BFGCore.BFGNarrativeSequence
// 0x0188 (0x01B8 - 0x0030)
class UBFGNarrativeSequence final : public UBFGGenericGraphOwner
{
public:
	uint8                                         Pad_30[0x10];                                      // 0x0030(0x0010)(Fixing Size After Last Property [ Dumper-7 ])
	UMulticastDelegateProperty_                   M_onStarted;                                       // 0x0040(0x0018)(ZeroConstructor, InstancedReference, NativeAccessSpecifierPublic)
	UMulticastDelegateProperty_                   M_onFailed;                                        // 0x0058(0x0018)(ZeroConstructor, InstancedReference, NativeAccessSpecifierPublic)
	UMulticastDelegateProperty_                   M_onFinished;                                      // 0x0070(0x0018)(ZeroConstructor, InstancedReference, NativeAccessSpecifierPublic)
	UMulticastDelegateProperty_                   M_onAborted;                                       // 0x0088(0x0018)(ZeroConstructor, InstancedReference, NativeAccessSpecifierPublic)
	TSoftClassPtr<class UClass>                   M_pGameFlowStateClass;                             // 0x00A0(0x0028)(Edit, DisableEditOnInstance, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	int32                                         M_iMaxStrikes;                                     // 0x00C8(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_CC[0x4];                                       // 0x00CC(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	TSoftObjectPtr<class ULevelSequence>          M_spLevelSequence;                                 // 0x00D0(0x0028)(Edit, DisableEditOnInstance, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          M_bFadeIn;                                         // 0x00F8(0x0001)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_F9[0x3];                                       // 0x00F9(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	struct FBFGFadeEditorInfo                     M_FadeInInfo;                                      // 0x00FC(0x000C)(Edit, DisableEditOnInstance, NoDestructor, Protected, NativeAccessSpecifierProtected)
	bool                                          M_bFadeOut;                                        // 0x0108(0x0001)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_109[0x3];                                      // 0x0109(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	struct FBFGFadeEditorInfo                     M_FadeOutInfo;                                     // 0x010C(0x000C)(Edit, DisableEditOnInstance, NoDestructor, Protected, NativeAccessSpecifierProtected)
	bool                                          M_bOmitFadeOutOnFail;                              // 0x0118(0x0001)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_119[0x7];                                      // 0x0119(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	class ABFGGameState*                          M_pGameState;                                      // 0x0120(0x0008)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UBFGNarrativeSequenceNode*              M_pCurrentNode;                                    // 0x0128(0x0008)(ExportObject, ZeroConstructor, Transient, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_130[0x8];                                      // 0x0130(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	class UBFGNarrativeSequenceNode*              M_pNextNode;                                       // 0x0138(0x0008)(ExportObject, ZeroConstructor, Transient, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_140[0x10];                                     // 0x0140(0x0010)(Fixing Size After Last Property [ Dumper-7 ])
	TMap<class FName, EUBFGNarrativeSequence_Assessment> M_aAnswerAssessments;                              // 0x0150(0x0050)(ZeroConstructor, Transient, Protected, NativeAccessSpecifierProtected)
	class UBFGNarrativeSequenceNode*              M_pFailNode;                                       // 0x01A0(0x0008)(ExportObject, ZeroConstructor, Transient, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UBFGGameFlowState_NarrativeSequence*    M_pGameFlowState;                                  // 0x01A8(0x0008)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UBFGGameplayEndSession*                 M_pEndSession;                                     // 0x01B0(0x0008)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)

public:
	void OnStarted(class UBFGNarrativeSequenceNode* _pNode);
	void OnStopped(class UBFGNarrativeSequenceNode* _pNode);
	bool RequestStart();
	void RequestStop(bool _bRemoveSequence, bool _bIsAbort);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"BFGNarrativeSequence">();
	}
	static class UBFGNarrativeSequence* GetDefaultObj()
	{
		return GetDefaultObjImpl<UBFGNarrativeSequence>();
	}
};
static_assert(alignof(UBFGNarrativeSequence) == 0x000008, "Wrong alignment on UBFGNarrativeSequence");
static_assert(sizeof(UBFGNarrativeSequence) == 0x0001B8, "Wrong size on UBFGNarrativeSequence");
static_assert(offsetof(UBFGNarrativeSequence, M_onStarted) == 0x000040, "Member 'UBFGNarrativeSequence::M_onStarted' has a wrong offset!");
static_assert(offsetof(UBFGNarrativeSequence, M_onFailed) == 0x000058, "Member 'UBFGNarrativeSequence::M_onFailed' has a wrong offset!");
static_assert(offsetof(UBFGNarrativeSequence, M_onFinished) == 0x000070, "Member 'UBFGNarrativeSequence::M_onFinished' has a wrong offset!");
static_assert(offsetof(UBFGNarrativeSequence, M_onAborted) == 0x000088, "Member 'UBFGNarrativeSequence::M_onAborted' has a wrong offset!");
static_assert(offsetof(UBFGNarrativeSequence, M_pGameFlowStateClass) == 0x0000A0, "Member 'UBFGNarrativeSequence::M_pGameFlowStateClass' has a wrong offset!");
static_assert(offsetof(UBFGNarrativeSequence, M_iMaxStrikes) == 0x0000C8, "Member 'UBFGNarrativeSequence::M_iMaxStrikes' has a wrong offset!");
static_assert(offsetof(UBFGNarrativeSequence, M_spLevelSequence) == 0x0000D0, "Member 'UBFGNarrativeSequence::M_spLevelSequence' has a wrong offset!");
static_assert(offsetof(UBFGNarrativeSequence, M_bFadeIn) == 0x0000F8, "Member 'UBFGNarrativeSequence::M_bFadeIn' has a wrong offset!");
static_assert(offsetof(UBFGNarrativeSequence, M_FadeInInfo) == 0x0000FC, "Member 'UBFGNarrativeSequence::M_FadeInInfo' has a wrong offset!");
static_assert(offsetof(UBFGNarrativeSequence, M_bFadeOut) == 0x000108, "Member 'UBFGNarrativeSequence::M_bFadeOut' has a wrong offset!");
static_assert(offsetof(UBFGNarrativeSequence, M_FadeOutInfo) == 0x00010C, "Member 'UBFGNarrativeSequence::M_FadeOutInfo' has a wrong offset!");
static_assert(offsetof(UBFGNarrativeSequence, M_bOmitFadeOutOnFail) == 0x000118, "Member 'UBFGNarrativeSequence::M_bOmitFadeOutOnFail' has a wrong offset!");
static_assert(offsetof(UBFGNarrativeSequence, M_pGameState) == 0x000120, "Member 'UBFGNarrativeSequence::M_pGameState' has a wrong offset!");
static_assert(offsetof(UBFGNarrativeSequence, M_pCurrentNode) == 0x000128, "Member 'UBFGNarrativeSequence::M_pCurrentNode' has a wrong offset!");
static_assert(offsetof(UBFGNarrativeSequence, M_pNextNode) == 0x000138, "Member 'UBFGNarrativeSequence::M_pNextNode' has a wrong offset!");
static_assert(offsetof(UBFGNarrativeSequence, M_aAnswerAssessments) == 0x000150, "Member 'UBFGNarrativeSequence::M_aAnswerAssessments' has a wrong offset!");
static_assert(offsetof(UBFGNarrativeSequence, M_pFailNode) == 0x0001A0, "Member 'UBFGNarrativeSequence::M_pFailNode' has a wrong offset!");
static_assert(offsetof(UBFGNarrativeSequence, M_pGameFlowState) == 0x0001A8, "Member 'UBFGNarrativeSequence::M_pGameFlowState' has a wrong offset!");
static_assert(offsetof(UBFGNarrativeSequence, M_pEndSession) == 0x0001B0, "Member 'UBFGNarrativeSequence::M_pEndSession' has a wrong offset!");

// Class BFGCore.BFGVariableAction_QuestCounter_Decrease
// 0x0000 (0x00F0 - 0x00F0)
class UBFGVariableAction_QuestCounter_Decrease final : public UBFGVariableAction
{
public:
	static const class FName GetActionName_QuestCounterDecrease();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"BFGVariableAction_QuestCounter_Decrease">();
	}
	static class UBFGVariableAction_QuestCounter_Decrease* GetDefaultObj()
	{
		return GetDefaultObjImpl<UBFGVariableAction_QuestCounter_Decrease>();
	}
};
static_assert(alignof(UBFGVariableAction_QuestCounter_Decrease) == 0x000008, "Wrong alignment on UBFGVariableAction_QuestCounter_Decrease");
static_assert(sizeof(UBFGVariableAction_QuestCounter_Decrease) == 0x0000F0, "Wrong size on UBFGVariableAction_QuestCounter_Decrease");

// Class BFGCore.BFGNarrativeSequenceNode_Fade
// 0x0068 (0x0148 - 0x00E0)
class UBFGNarrativeSequenceNode_Fade final : public UBFGNarrativeSequenceNode_PlayerOption
{
public:
	struct FBFGFadeEditorInfo                     M_info;                                            // 0x00E0(0x000C)(Edit, DisableEditOnInstance, NoDestructor, Protected, NativeAccessSpecifierProtected)
	EBFGElementFadeType                           M_fadeType;                                        // 0x00EC(0x0001)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_ED[0x3];                                       // 0x00ED(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<TSoftObjectPtr<class UWorld>>          M_aLoadLevels;                                     // 0x00F0(0x0010)(Edit, ZeroConstructor, DisableEditOnInstance, Protected, UObjectWrapper, NativeAccessSpecifierProtected)
	TArray<TSoftObjectPtr<class UWorld>>          M_aUnloadLevels;                                   // 0x0100(0x0010)(Edit, ZeroConstructor, DisableEditOnInstance, Protected, UObjectWrapper, NativeAccessSpecifierProtected)
	bool                                          M_bUseGameplayEndingEffects;                       // 0x0110(0x0001)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_111[0x7];                                      // 0x0111(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	class ABFGGameState*                          M_pGameState;                                      // 0x0118(0x0008)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_120[0x8];                                      // 0x0120(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<class UBFGStreamingLevelHandle*>       M_apLoadStreamingLevels;                           // 0x0128(0x0010)(ZeroConstructor, Transient, Protected, NativeAccessSpecifierProtected)
	TArray<class UBFGStreamingLevelHandle*>       M_apUnloadStreamingLevels;                         // 0x0138(0x0010)(ZeroConstructor, Transient, Protected, NativeAccessSpecifierProtected)

public:
	void OnFadeFinishedCallback(class FName _strFadeIdentifier, bool _bFadeOut);
	void OnStreamingStateChanged(class UBFGStreamingLevelHandle* _pHandle, bool _bIsLoaded);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"BFGNarrativeSequenceNode_Fade">();
	}
	static class UBFGNarrativeSequenceNode_Fade* GetDefaultObj()
	{
		return GetDefaultObjImpl<UBFGNarrativeSequenceNode_Fade>();
	}
};
static_assert(alignof(UBFGNarrativeSequenceNode_Fade) == 0x000008, "Wrong alignment on UBFGNarrativeSequenceNode_Fade");
static_assert(sizeof(UBFGNarrativeSequenceNode_Fade) == 0x000148, "Wrong size on UBFGNarrativeSequenceNode_Fade");
static_assert(offsetof(UBFGNarrativeSequenceNode_Fade, M_info) == 0x0000E0, "Member 'UBFGNarrativeSequenceNode_Fade::M_info' has a wrong offset!");
static_assert(offsetof(UBFGNarrativeSequenceNode_Fade, M_fadeType) == 0x0000EC, "Member 'UBFGNarrativeSequenceNode_Fade::M_fadeType' has a wrong offset!");
static_assert(offsetof(UBFGNarrativeSequenceNode_Fade, M_aLoadLevels) == 0x0000F0, "Member 'UBFGNarrativeSequenceNode_Fade::M_aLoadLevels' has a wrong offset!");
static_assert(offsetof(UBFGNarrativeSequenceNode_Fade, M_aUnloadLevels) == 0x000100, "Member 'UBFGNarrativeSequenceNode_Fade::M_aUnloadLevels' has a wrong offset!");
static_assert(offsetof(UBFGNarrativeSequenceNode_Fade, M_bUseGameplayEndingEffects) == 0x000110, "Member 'UBFGNarrativeSequenceNode_Fade::M_bUseGameplayEndingEffects' has a wrong offset!");
static_assert(offsetof(UBFGNarrativeSequenceNode_Fade, M_pGameState) == 0x000118, "Member 'UBFGNarrativeSequenceNode_Fade::M_pGameState' has a wrong offset!");
static_assert(offsetof(UBFGNarrativeSequenceNode_Fade, M_apLoadStreamingLevels) == 0x000128, "Member 'UBFGNarrativeSequenceNode_Fade::M_apLoadStreamingLevels' has a wrong offset!");
static_assert(offsetof(UBFGNarrativeSequenceNode_Fade, M_apUnloadStreamingLevels) == 0x000138, "Member 'UBFGNarrativeSequenceNode_Fade::M_apUnloadStreamingLevels' has a wrong offset!");

// Class BFGCore.BFGNarrativeSequenceNode_PlayCutscene
// 0x00D0 (0x01B0 - 0x00E0)
class UBFGNarrativeSequenceNode_PlayCutscene final : public UBFGNarrativeSequenceNode_PlayerOption
{
public:
	TSoftObjectPtr<class ULevelSequence>          M_softLevelSequence;                               // 0x00E0(0x0028)(Edit, DisableEditOnInstance, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	struct FBFGSequencePlayer_Parameters          M_cutsceneParams;                                  // 0x0108(0x0070)(Edit, DisableEditOnInstance, Protected, NativeAccessSpecifierProtected)
	struct FMovieSceneSequencePlaybackSettings    M_playbackSettings;                                // 0x0178(0x0014)(Edit, DisableEditOnInstance, NoDestructor, Protected, NativeAccessSpecifierProtected)
	uint8                                         Pad_18C[0x4];                                      // 0x018C(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class ULevelSequence*                         M_pLevelSequence;                                  // 0x0190(0x0008)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UBFGSequencePlaybackManager*            M_pSequencePlaybackManager;                        // 0x0198(0x0008)(ExportObject, ZeroConstructor, Transient, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class ALevelSequenceActor*                    M_pCutsceneActor;                                  // 0x01A0(0x0008)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_1A8[0x8];                                      // 0x01A8(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void FinishedSequence(class ALevelSequenceActor* _pActor, bool _bWasCutscene);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"BFGNarrativeSequenceNode_PlayCutscene">();
	}
	static class UBFGNarrativeSequenceNode_PlayCutscene* GetDefaultObj()
	{
		return GetDefaultObjImpl<UBFGNarrativeSequenceNode_PlayCutscene>();
	}
};
static_assert(alignof(UBFGNarrativeSequenceNode_PlayCutscene) == 0x000008, "Wrong alignment on UBFGNarrativeSequenceNode_PlayCutscene");
static_assert(sizeof(UBFGNarrativeSequenceNode_PlayCutscene) == 0x0001B0, "Wrong size on UBFGNarrativeSequenceNode_PlayCutscene");
static_assert(offsetof(UBFGNarrativeSequenceNode_PlayCutscene, M_softLevelSequence) == 0x0000E0, "Member 'UBFGNarrativeSequenceNode_PlayCutscene::M_softLevelSequence' has a wrong offset!");
static_assert(offsetof(UBFGNarrativeSequenceNode_PlayCutscene, M_cutsceneParams) == 0x000108, "Member 'UBFGNarrativeSequenceNode_PlayCutscene::M_cutsceneParams' has a wrong offset!");
static_assert(offsetof(UBFGNarrativeSequenceNode_PlayCutscene, M_playbackSettings) == 0x000178, "Member 'UBFGNarrativeSequenceNode_PlayCutscene::M_playbackSettings' has a wrong offset!");
static_assert(offsetof(UBFGNarrativeSequenceNode_PlayCutscene, M_pLevelSequence) == 0x000190, "Member 'UBFGNarrativeSequenceNode_PlayCutscene::M_pLevelSequence' has a wrong offset!");
static_assert(offsetof(UBFGNarrativeSequenceNode_PlayCutscene, M_pSequencePlaybackManager) == 0x000198, "Member 'UBFGNarrativeSequenceNode_PlayCutscene::M_pSequencePlaybackManager' has a wrong offset!");
static_assert(offsetof(UBFGNarrativeSequenceNode_PlayCutscene, M_pCutsceneActor) == 0x0001A0, "Member 'UBFGNarrativeSequenceNode_PlayCutscene::M_pCutsceneActor' has a wrong offset!");

// Class BFGCore.BFGNarrativeSequenceNode_PlayNewspaper
// 0x0058 (0x0118 - 0x00C0)
class UBFGNarrativeSequenceNode_PlayNewspaper final : public UBFGNarrativeSequenceNode
{
public:
	bool                                          M_bIsTemplate;                                     // 0x00C0(0x0001)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_C1[0x7];                                       // 0x00C1(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	TSoftObjectPtr<class UBFGDataAsset_NewspaperInfo> M_softNewspaper;                                   // 0x00C8(0x0028)(Edit, DisableEditOnInstance, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UBFGDataAsset_NewspaperInfo*            M_pNewspaper;                                      // 0x00F0(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class ABFGGameState*                          M_pGameState;                                      // 0x00F8(0x0008)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_100[0x8];                                      // 0x0100(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	class UObject*                                M_pLastLoaded;                                     // 0x0108(0x0008)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UBFGGameFlowState_Newspaper*            M_pNewspaperState;                                 // 0x0110(0x0008)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)

public:
	void OnNewspaperLeaves(class UBFGGameFlowState* _pState);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"BFGNarrativeSequenceNode_PlayNewspaper">();
	}
	static class UBFGNarrativeSequenceNode_PlayNewspaper* GetDefaultObj()
	{
		return GetDefaultObjImpl<UBFGNarrativeSequenceNode_PlayNewspaper>();
	}
};
static_assert(alignof(UBFGNarrativeSequenceNode_PlayNewspaper) == 0x000008, "Wrong alignment on UBFGNarrativeSequenceNode_PlayNewspaper");
static_assert(sizeof(UBFGNarrativeSequenceNode_PlayNewspaper) == 0x000118, "Wrong size on UBFGNarrativeSequenceNode_PlayNewspaper");
static_assert(offsetof(UBFGNarrativeSequenceNode_PlayNewspaper, M_bIsTemplate) == 0x0000C0, "Member 'UBFGNarrativeSequenceNode_PlayNewspaper::M_bIsTemplate' has a wrong offset!");
static_assert(offsetof(UBFGNarrativeSequenceNode_PlayNewspaper, M_softNewspaper) == 0x0000C8, "Member 'UBFGNarrativeSequenceNode_PlayNewspaper::M_softNewspaper' has a wrong offset!");
static_assert(offsetof(UBFGNarrativeSequenceNode_PlayNewspaper, M_pNewspaper) == 0x0000F0, "Member 'UBFGNarrativeSequenceNode_PlayNewspaper::M_pNewspaper' has a wrong offset!");
static_assert(offsetof(UBFGNarrativeSequenceNode_PlayNewspaper, M_pGameState) == 0x0000F8, "Member 'UBFGNarrativeSequenceNode_PlayNewspaper::M_pGameState' has a wrong offset!");
static_assert(offsetof(UBFGNarrativeSequenceNode_PlayNewspaper, M_pLastLoaded) == 0x000108, "Member 'UBFGNarrativeSequenceNode_PlayNewspaper::M_pLastLoaded' has a wrong offset!");
static_assert(offsetof(UBFGNarrativeSequenceNode_PlayNewspaper, M_pNewspaperState) == 0x000110, "Member 'UBFGNarrativeSequenceNode_PlayNewspaper::M_pNewspaperState' has a wrong offset!");

// Class BFGCore.BFGTaskNode_VehiclePark
// 0x0000 (0x0138 - 0x0138)
class UBFGTaskNode_VehiclePark final : public UBFGTaskNode_VehicleBase
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"BFGTaskNode_VehiclePark">();
	}
	static class UBFGTaskNode_VehiclePark* GetDefaultObj()
	{
		return GetDefaultObjImpl<UBFGTaskNode_VehiclePark>();
	}
};
static_assert(alignof(UBFGTaskNode_VehiclePark) == 0x000008, "Wrong alignment on UBFGTaskNode_VehiclePark");
static_assert(sizeof(UBFGTaskNode_VehiclePark) == 0x000138, "Wrong size on UBFGTaskNode_VehiclePark");

// Class BFGCore.BFGNarrativeSequenceNode_PlayVO
// 0x00D0 (0x01B0 - 0x00E0)
class UBFGNarrativeSequenceNode_PlayVO final : public UBFGNarrativeSequenceNode_PlayerOption
{
public:
	class FText                                   M_strVOTextEntry;                                  // 0x00E0(0x0018)(Edit, NativeAccessSpecifierPublic)
	TScriptInterface<class IBFGVoiceoverQueueInterface> M_pVOQueue;                                        // 0x00F8(0x0010)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, UObjectWrapper, NativeAccessSpecifierProtected)
	struct FBFGVoiceoverItem                      M_item;                                            // 0x0108(0x00A8)(Transient, Protected, NativeAccessSpecifierProtected)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"BFGNarrativeSequenceNode_PlayVO">();
	}
	static class UBFGNarrativeSequenceNode_PlayVO* GetDefaultObj()
	{
		return GetDefaultObjImpl<UBFGNarrativeSequenceNode_PlayVO>();
	}
};
static_assert(alignof(UBFGNarrativeSequenceNode_PlayVO) == 0x000008, "Wrong alignment on UBFGNarrativeSequenceNode_PlayVO");
static_assert(sizeof(UBFGNarrativeSequenceNode_PlayVO) == 0x0001B0, "Wrong size on UBFGNarrativeSequenceNode_PlayVO");
static_assert(offsetof(UBFGNarrativeSequenceNode_PlayVO, M_strVOTextEntry) == 0x0000E0, "Member 'UBFGNarrativeSequenceNode_PlayVO::M_strVOTextEntry' has a wrong offset!");
static_assert(offsetof(UBFGNarrativeSequenceNode_PlayVO, M_pVOQueue) == 0x0000F8, "Member 'UBFGNarrativeSequenceNode_PlayVO::M_pVOQueue' has a wrong offset!");
static_assert(offsetof(UBFGNarrativeSequenceNode_PlayVO, M_item) == 0x000108, "Member 'UBFGNarrativeSequenceNode_PlayVO::M_item' has a wrong offset!");

// Class BFGCore.BFGNarrativeSequenceNode_SelectPlayerOption
// 0x0080 (0x0140 - 0x00C0)
class UBFGNarrativeSequenceNode_SelectPlayerOption final : public UBFGNarrativeSequenceNode
{
public:
	TSoftObjectPtr<class ULevelSequence>          M_spLevelSequence;                                 // 0x00C0(0x0028)(Edit, DisableEditOnInstance, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class FText                                   M_strQuestion;                                     // 0x00E8(0x0018)(Edit, DisableEditOnInstance, Protected, NativeAccessSpecifierProtected)
	bool                                          M_bShowMoodBar;                                    // 0x0100(0x0001)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_101[0x7];                                      // 0x0101(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	TSoftClassPtr<class UClass>                   M_pGameFlowStateClass;                             // 0x0108(0x0028)(Edit, DisableEditOnInstance, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class FName                                   M_strIdentifier;                                   // 0x0130(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_138[0x8];                                      // 0x0138(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"BFGNarrativeSequenceNode_SelectPlayerOption">();
	}
	static class UBFGNarrativeSequenceNode_SelectPlayerOption* GetDefaultObj()
	{
		return GetDefaultObjImpl<UBFGNarrativeSequenceNode_SelectPlayerOption>();
	}
};
static_assert(alignof(UBFGNarrativeSequenceNode_SelectPlayerOption) == 0x000008, "Wrong alignment on UBFGNarrativeSequenceNode_SelectPlayerOption");
static_assert(sizeof(UBFGNarrativeSequenceNode_SelectPlayerOption) == 0x000140, "Wrong size on UBFGNarrativeSequenceNode_SelectPlayerOption");
static_assert(offsetof(UBFGNarrativeSequenceNode_SelectPlayerOption, M_spLevelSequence) == 0x0000C0, "Member 'UBFGNarrativeSequenceNode_SelectPlayerOption::M_spLevelSequence' has a wrong offset!");
static_assert(offsetof(UBFGNarrativeSequenceNode_SelectPlayerOption, M_strQuestion) == 0x0000E8, "Member 'UBFGNarrativeSequenceNode_SelectPlayerOption::M_strQuestion' has a wrong offset!");
static_assert(offsetof(UBFGNarrativeSequenceNode_SelectPlayerOption, M_bShowMoodBar) == 0x000100, "Member 'UBFGNarrativeSequenceNode_SelectPlayerOption::M_bShowMoodBar' has a wrong offset!");
static_assert(offsetof(UBFGNarrativeSequenceNode_SelectPlayerOption, M_pGameFlowStateClass) == 0x000108, "Member 'UBFGNarrativeSequenceNode_SelectPlayerOption::M_pGameFlowStateClass' has a wrong offset!");
static_assert(offsetof(UBFGNarrativeSequenceNode_SelectPlayerOption, M_strIdentifier) == 0x000130, "Member 'UBFGNarrativeSequenceNode_SelectPlayerOption::M_strIdentifier' has a wrong offset!");

// Class BFGCore.BFGNarrativeSequenceNodeEdge
// 0x0000 (0x0040 - 0x0040)
class UBFGNarrativeSequenceNodeEdge final : public UGenericGraphEdge
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"BFGNarrativeSequenceNodeEdge">();
	}
	static class UBFGNarrativeSequenceNodeEdge* GetDefaultObj()
	{
		return GetDefaultObjImpl<UBFGNarrativeSequenceNodeEdge>();
	}
};
static_assert(alignof(UBFGNarrativeSequenceNodeEdge) == 0x000008, "Wrong alignment on UBFGNarrativeSequenceNodeEdge");
static_assert(sizeof(UBFGNarrativeSequenceNodeEdge) == 0x000040, "Wrong size on UBFGNarrativeSequenceNodeEdge");

// Class BFGCore.BFGTaskNode_VehicleSuspicious
// 0x0000 (0x0138 - 0x0138)
class UBFGTaskNode_VehicleSuspicious final : public UBFGTaskNode_VehicleBase
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"BFGTaskNode_VehicleSuspicious">();
	}
	static class UBFGTaskNode_VehicleSuspicious* GetDefaultObj()
	{
		return GetDefaultObjImpl<UBFGTaskNode_VehicleSuspicious>();
	}
};
static_assert(alignof(UBFGTaskNode_VehicleSuspicious) == 0x000008, "Wrong alignment on UBFGTaskNode_VehicleSuspicious");
static_assert(sizeof(UBFGTaskNode_VehicleSuspicious) == 0x000138, "Wrong size on UBFGTaskNode_VehicleSuspicious");

// Class BFGCore.BFGNarrativeSequenceNodeGraph
// 0x0000 (0x0098 - 0x0098)
class UBFGNarrativeSequenceNodeGraph final : public UGenericGraph
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"BFGNarrativeSequenceNodeGraph">();
	}
	static class UBFGNarrativeSequenceNodeGraph* GetDefaultObj()
	{
		return GetDefaultObjImpl<UBFGNarrativeSequenceNodeGraph>();
	}
};
static_assert(alignof(UBFGNarrativeSequenceNodeGraph) == 0x000008, "Wrong alignment on UBFGNarrativeSequenceNodeGraph");
static_assert(sizeof(UBFGNarrativeSequenceNodeGraph) == 0x000098, "Wrong size on UBFGNarrativeSequenceNodeGraph");

// Class BFGCore.BFGNarrativeSequenceSettings
// 0x0078 (0x00B0 - 0x0038)
class UBFGNarrativeSequenceSettings final : public UDeveloperSettings
{
public:
	TSoftClassPtr<class UClass>                   M_softNarrativeSequence_Newspapers;                // 0x0038(0x0028)(Edit, Config, DisableEditOnInstance, GlobalConfig, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TSoftClassPtr<class UClass>                   M_spSequence_GameFlowStateClass;                   // 0x0060(0x0028)(Edit, Config, DisableEditOnInstance, GlobalConfig, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TSoftClassPtr<class UClass>                   M_spSelectPlayerOption_GameFlowStateClass;         // 0x0088(0x0028)(Edit, Config, DisableEditOnInstance, GlobalConfig, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"BFGNarrativeSequenceSettings">();
	}
	static class UBFGNarrativeSequenceSettings* GetDefaultObj()
	{
		return GetDefaultObjImpl<UBFGNarrativeSequenceSettings>();
	}
};
static_assert(alignof(UBFGNarrativeSequenceSettings) == 0x000008, "Wrong alignment on UBFGNarrativeSequenceSettings");
static_assert(sizeof(UBFGNarrativeSequenceSettings) == 0x0000B0, "Wrong size on UBFGNarrativeSequenceSettings");
static_assert(offsetof(UBFGNarrativeSequenceSettings, M_softNarrativeSequence_Newspapers) == 0x000038, "Member 'UBFGNarrativeSequenceSettings::M_softNarrativeSequence_Newspapers' has a wrong offset!");
static_assert(offsetof(UBFGNarrativeSequenceSettings, M_spSequence_GameFlowStateClass) == 0x000060, "Member 'UBFGNarrativeSequenceSettings::M_spSequence_GameFlowStateClass' has a wrong offset!");
static_assert(offsetof(UBFGNarrativeSequenceSettings, M_spSelectPlayerOption_GameFlowStateClass) == 0x000088, "Member 'UBFGNarrativeSequenceSettings::M_spSelectPlayerOption_GameFlowStateClass' has a wrong offset!");

// Class BFGCore.BFGNarrativeSequenceSystem
// 0x0020 (0x0050 - 0x0030)
class UBFGNarrativeSequenceSystem final : public UBFGGameSystem
{
public:
	uint8                                         Pad_30[0x8];                                       // 0x0030(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	class ABFGGameState*                          M_pGameState;                                      // 0x0038(0x0008)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TArray<class UBFGNarrativeSequence*>          M_apSequences;                                     // 0x0040(0x0010)(ZeroConstructor, Transient, Protected, NativeAccessSpecifierProtected)

public:
	static bool FindFirstNarrativeSequenceAssessment(TMap<class FName, EUBFGNarrativeSequence_Assessment>* _aAssessmentOut, const class UObject* _pWorldContextObject, TSoftClassPtr<class UClass> _softSequenceType);

	class UBFGNarrativeSequence* NewSequence(TSoftClassPtr<class UClass> _softSequence, bool _bAutoStart, bool _bRemoveAfterPlayback);
	bool PlaySequence_FireAndForget(TSoftClassPtr<class UClass> _softSequence);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"BFGNarrativeSequenceSystem">();
	}
	static class UBFGNarrativeSequenceSystem* GetDefaultObj()
	{
		return GetDefaultObjImpl<UBFGNarrativeSequenceSystem>();
	}
};
static_assert(alignof(UBFGNarrativeSequenceSystem) == 0x000008, "Wrong alignment on UBFGNarrativeSequenceSystem");
static_assert(sizeof(UBFGNarrativeSequenceSystem) == 0x000050, "Wrong size on UBFGNarrativeSequenceSystem");
static_assert(offsetof(UBFGNarrativeSequenceSystem, M_pGameState) == 0x000038, "Member 'UBFGNarrativeSequenceSystem::M_pGameState' has a wrong offset!");
static_assert(offsetof(UBFGNarrativeSequenceSystem, M_apSequences) == 0x000040, "Member 'UBFGNarrativeSequenceSystem::M_apSequences' has a wrong offset!");

// Class BFGCore.BFGNavArea_Hazard
// 0x0000 (0x0048 - 0x0048)
class UBFGNavArea_Hazard final : public UNavArea
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"BFGNavArea_Hazard">();
	}
	static class UBFGNavArea_Hazard* GetDefaultObj()
	{
		return GetDefaultObjImpl<UBFGNavArea_Hazard>();
	}
};
static_assert(alignof(UBFGNavArea_Hazard) == 0x000008, "Wrong alignment on UBFGNavArea_Hazard");
static_assert(sizeof(UBFGNavArea_Hazard) == 0x000048, "Wrong size on UBFGNavArea_Hazard");

// Class BFGCore.BFGTrafficCrowdManagerSettingsActor
// 0x0050 (0x0428 - 0x03D8)
class ABFGTrafficCrowdManagerSettingsActor final : public AActor
{
public:
	TSoftObjectPtr<class UBFGSpawningComposition> M_pDefaultCivilianNPCSpawningComposition;          // 0x03D8(0x0028)(Edit, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TSoftObjectPtr<class UBFGSpawningComposition> M_pDefaultEnemyNPCSpawningComposition;             // 0x0400(0x0028)(Edit, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"BFGTrafficCrowdManagerSettingsActor">();
	}
	static class ABFGTrafficCrowdManagerSettingsActor* GetDefaultObj()
	{
		return GetDefaultObjImpl<ABFGTrafficCrowdManagerSettingsActor>();
	}
};
static_assert(alignof(ABFGTrafficCrowdManagerSettingsActor) == 0x000008, "Wrong alignment on ABFGTrafficCrowdManagerSettingsActor");
static_assert(sizeof(ABFGTrafficCrowdManagerSettingsActor) == 0x000428, "Wrong size on ABFGTrafficCrowdManagerSettingsActor");
static_assert(offsetof(ABFGTrafficCrowdManagerSettingsActor, M_pDefaultCivilianNPCSpawningComposition) == 0x0003D8, "Member 'ABFGTrafficCrowdManagerSettingsActor::M_pDefaultCivilianNPCSpawningComposition' has a wrong offset!");
static_assert(offsetof(ABFGTrafficCrowdManagerSettingsActor, M_pDefaultEnemyNPCSpawningComposition) == 0x000400, "Member 'ABFGTrafficCrowdManagerSettingsActor::M_pDefaultEnemyNPCSpawningComposition' has a wrong offset!");

// Class BFGCore.BFGNavigationSettings
// 0x0010 (0x0048 - 0x0038)
class UBFGNavigationSettings final : public UDeveloperSettings
{
public:
	TArray<class FString>                         M_aNavAgentGroupNames;                             // 0x0038(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Config, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"BFGNavigationSettings">();
	}
	static class UBFGNavigationSettings* GetDefaultObj()
	{
		return GetDefaultObjImpl<UBFGNavigationSettings>();
	}
};
static_assert(alignof(UBFGNavigationSettings) == 0x000008, "Wrong alignment on UBFGNavigationSettings");
static_assert(sizeof(UBFGNavigationSettings) == 0x000048, "Wrong size on UBFGNavigationSettings");
static_assert(offsetof(UBFGNavigationSettings, M_aNavAgentGroupNames) == 0x000038, "Member 'UBFGNavigationSettings::M_aNavAgentGroupNames' has a wrong offset!");

// Class BFGCore.BFGNetworkPath
// 0x0328 (0x0350 - 0x0028)
class UBFGNetworkPath final : public UObject
{
public:
	struct FGameplayTagContainer                  M_gameplayTags;                                    // 0x0028(0x0020)(Transient, Protected, NativeAccessSpecifierProtected)
	TWeakObjectPtr<class UBFGNetworkPathComponent> M_pComponent;                                      // 0x0048(0x0008)(ExportObject, ZeroConstructor, Transient, InstancedReference, IsPlainOldData, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UGameInstance*                          M_pGameInstance;                                   // 0x0050(0x0008)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UBFGNetworkPathSpawner*                 M_pAgentSpawner;                                   // 0x0058(0x0008)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TArray<class UBFGNetworkPathAgent*>           M_apSpawnedAgents;                                 // 0x0060(0x0010)(ZeroConstructor, Transient, Protected, NativeAccessSpecifierProtected)
	float                                         M_fMaxAgents;                                      // 0x0070(0x0004)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_74[0x4];                                       // 0x0074(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class UBFGTrafficCrowdManager*                M_pManager;                                        // 0x0078(0x0008)(ExportObject, ZeroConstructor, Transient, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	struct FBFGNetworkPathInfo                    M_networkPathInfo;                                 // 0x0080(0x0120)(Edit, BlueprintVisible, BlueprintReadOnly, EditConst, Protected, NativeAccessSpecifierProtected)
	struct FBFGPatrolPathInfo                     M_patrolPathInfo;                                  // 0x01A0(0x0018)(Edit, BlueprintVisible, BlueprintReadOnly, EditConst, Protected, NativeAccessSpecifierProtected)
	uint8                                         Pad_1B8[0x10];                                     // 0x01B8(0x0010)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<class UBFGNetworkPathAgent*>           M_apRegisteredAgents;                              // 0x01C8(0x0010)(ZeroConstructor, Transient, Protected, NativeAccessSpecifierProtected)
	TArray<class UBFGNetworkPathAgent*>           M_apAgentsInStandy;                                // 0x01D8(0x0010)(ZeroConstructor, Transient, Protected, NativeAccessSpecifierProtected)
	TArray<class UBFGNetworkPathAgent*>           M_apAllAgents;                                     // 0x01E8(0x0010)(ZeroConstructor, Transient, Protected, NativeAccessSpecifierProtected)
	TArray<class UBFGNetworkPathAgent*>           M_apCrossingPendingRequests;                       // 0x01F8(0x0010)(ZeroConstructor, Transient, Protected, NativeAccessSpecifierProtected)
	TArray<struct FBFGNetworkPathEventReport>     M_aReportedEvents;                                 // 0x0208(0x0010)(ZeroConstructor, Transient, Protected, NativeAccessSpecifierProtected)
	float                                         M_fInitialTimer;                                   // 0x0218(0x0004)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         M_fExpensiveUpdateTimer;                           // 0x021C(0x0004)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UBFGNetworkPathIntersection*            M_pIntersectionAtHead;                             // 0x0220(0x0008)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UBFGNetworkPathIntersection*            M_pIntersectionAtTail;                             // 0x0228(0x0008)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UBFGNetworkPath*                        M_pCrossWalkAtHead;                                // 0x0230(0x0008)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UBFGNetworkPath*                        M_pCrossWalkAtTail;                                // 0x0238(0x0008)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         M_fCrossWalkAtHeadDistanceOnSpline;                // 0x0240(0x0004)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         M_fCrossWalkAtTailDistanceOnSpline;                // 0x0244(0x0004)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          M_bCrossingOpened;                                 // 0x0248(0x0001)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_249[0x7];                                      // 0x0249(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<class UBFGNetworkPathAgent*>           M_apAgentsToEasePath;                              // 0x0250(0x0010)(ZeroConstructor, Transient, Protected, NativeAccessSpecifierProtected)
	TArray<bool>                                  M_aNonPrioritarAgentsShouldAvoidPath;              // 0x0260(0x0010)(ZeroConstructor, Transient, Protected, NativeAccessSpecifierProtected)
	bool                                          M_bAgentsShouldTightTheirRight;                    // 0x0270(0x0001)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_271[0xF];                                      // 0x0271(0x000F)(Fixing Size After Last Property [ Dumper-7 ])
	struct FTransform                             M_Transform;                                       // 0x0280(0x0030)(Transient, IsPlainOldData, NoDestructor, Protected, NativeAccessSpecifierProtected)
	struct FSplineCurves                          M_splineCurve;                                     // 0x02B0(0x0060)(Transient, Protected, NativeAccessSpecifierProtected)
	struct FBFGHeightAlongPathData                M_heightData;                                      // 0x0310(0x0020)(Transient, Protected, NativeAccessSpecifierProtected)
	uint8                                         Pad_330[0x20];                                     // 0x0330(0x0020)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void OnAgentSpawnedBySpawner(class UBFGNetworkPathAgent* _pAgent, bool _bOwnedByPath);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"BFGNetworkPath">();
	}
	static class UBFGNetworkPath* GetDefaultObj()
	{
		return GetDefaultObjImpl<UBFGNetworkPath>();
	}
};
static_assert(alignof(UBFGNetworkPath) == 0x000010, "Wrong alignment on UBFGNetworkPath");
static_assert(sizeof(UBFGNetworkPath) == 0x000350, "Wrong size on UBFGNetworkPath");
static_assert(offsetof(UBFGNetworkPath, M_gameplayTags) == 0x000028, "Member 'UBFGNetworkPath::M_gameplayTags' has a wrong offset!");
static_assert(offsetof(UBFGNetworkPath, M_pComponent) == 0x000048, "Member 'UBFGNetworkPath::M_pComponent' has a wrong offset!");
static_assert(offsetof(UBFGNetworkPath, M_pGameInstance) == 0x000050, "Member 'UBFGNetworkPath::M_pGameInstance' has a wrong offset!");
static_assert(offsetof(UBFGNetworkPath, M_pAgentSpawner) == 0x000058, "Member 'UBFGNetworkPath::M_pAgentSpawner' has a wrong offset!");
static_assert(offsetof(UBFGNetworkPath, M_apSpawnedAgents) == 0x000060, "Member 'UBFGNetworkPath::M_apSpawnedAgents' has a wrong offset!");
static_assert(offsetof(UBFGNetworkPath, M_fMaxAgents) == 0x000070, "Member 'UBFGNetworkPath::M_fMaxAgents' has a wrong offset!");
static_assert(offsetof(UBFGNetworkPath, M_pManager) == 0x000078, "Member 'UBFGNetworkPath::M_pManager' has a wrong offset!");
static_assert(offsetof(UBFGNetworkPath, M_networkPathInfo) == 0x000080, "Member 'UBFGNetworkPath::M_networkPathInfo' has a wrong offset!");
static_assert(offsetof(UBFGNetworkPath, M_patrolPathInfo) == 0x0001A0, "Member 'UBFGNetworkPath::M_patrolPathInfo' has a wrong offset!");
static_assert(offsetof(UBFGNetworkPath, M_apRegisteredAgents) == 0x0001C8, "Member 'UBFGNetworkPath::M_apRegisteredAgents' has a wrong offset!");
static_assert(offsetof(UBFGNetworkPath, M_apAgentsInStandy) == 0x0001D8, "Member 'UBFGNetworkPath::M_apAgentsInStandy' has a wrong offset!");
static_assert(offsetof(UBFGNetworkPath, M_apAllAgents) == 0x0001E8, "Member 'UBFGNetworkPath::M_apAllAgents' has a wrong offset!");
static_assert(offsetof(UBFGNetworkPath, M_apCrossingPendingRequests) == 0x0001F8, "Member 'UBFGNetworkPath::M_apCrossingPendingRequests' has a wrong offset!");
static_assert(offsetof(UBFGNetworkPath, M_aReportedEvents) == 0x000208, "Member 'UBFGNetworkPath::M_aReportedEvents' has a wrong offset!");
static_assert(offsetof(UBFGNetworkPath, M_fInitialTimer) == 0x000218, "Member 'UBFGNetworkPath::M_fInitialTimer' has a wrong offset!");
static_assert(offsetof(UBFGNetworkPath, M_fExpensiveUpdateTimer) == 0x00021C, "Member 'UBFGNetworkPath::M_fExpensiveUpdateTimer' has a wrong offset!");
static_assert(offsetof(UBFGNetworkPath, M_pIntersectionAtHead) == 0x000220, "Member 'UBFGNetworkPath::M_pIntersectionAtHead' has a wrong offset!");
static_assert(offsetof(UBFGNetworkPath, M_pIntersectionAtTail) == 0x000228, "Member 'UBFGNetworkPath::M_pIntersectionAtTail' has a wrong offset!");
static_assert(offsetof(UBFGNetworkPath, M_pCrossWalkAtHead) == 0x000230, "Member 'UBFGNetworkPath::M_pCrossWalkAtHead' has a wrong offset!");
static_assert(offsetof(UBFGNetworkPath, M_pCrossWalkAtTail) == 0x000238, "Member 'UBFGNetworkPath::M_pCrossWalkAtTail' has a wrong offset!");
static_assert(offsetof(UBFGNetworkPath, M_fCrossWalkAtHeadDistanceOnSpline) == 0x000240, "Member 'UBFGNetworkPath::M_fCrossWalkAtHeadDistanceOnSpline' has a wrong offset!");
static_assert(offsetof(UBFGNetworkPath, M_fCrossWalkAtTailDistanceOnSpline) == 0x000244, "Member 'UBFGNetworkPath::M_fCrossWalkAtTailDistanceOnSpline' has a wrong offset!");
static_assert(offsetof(UBFGNetworkPath, M_bCrossingOpened) == 0x000248, "Member 'UBFGNetworkPath::M_bCrossingOpened' has a wrong offset!");
static_assert(offsetof(UBFGNetworkPath, M_apAgentsToEasePath) == 0x000250, "Member 'UBFGNetworkPath::M_apAgentsToEasePath' has a wrong offset!");
static_assert(offsetof(UBFGNetworkPath, M_aNonPrioritarAgentsShouldAvoidPath) == 0x000260, "Member 'UBFGNetworkPath::M_aNonPrioritarAgentsShouldAvoidPath' has a wrong offset!");
static_assert(offsetof(UBFGNetworkPath, M_bAgentsShouldTightTheirRight) == 0x000270, "Member 'UBFGNetworkPath::M_bAgentsShouldTightTheirRight' has a wrong offset!");
static_assert(offsetof(UBFGNetworkPath, M_Transform) == 0x000280, "Member 'UBFGNetworkPath::M_Transform' has a wrong offset!");
static_assert(offsetof(UBFGNetworkPath, M_splineCurve) == 0x0002B0, "Member 'UBFGNetworkPath::M_splineCurve' has a wrong offset!");
static_assert(offsetof(UBFGNetworkPath, M_heightData) == 0x000310, "Member 'UBFGNetworkPath::M_heightData' has a wrong offset!");

// Class BFGCore.BFGTaskNode_BossCharge
// 0x0038 (0x00D8 - 0x00A0)
class UBFGTaskNode_BossCharge final : public UBFGTaskNode_BossBase
{
public:
	float                                         M_fMinDistanceImpulse;                             // 0x00A0(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         M_fImpulseStrength;                                // 0x00A4(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class ABFGNPCCharacterBoss_Armquist*          M_pOwnerCharacterBoss_Armquist;                    // 0x00A8(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_B0[0x28];                                      // 0x00B0(0x0028)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"BFGTaskNode_BossCharge">();
	}
	static class UBFGTaskNode_BossCharge* GetDefaultObj()
	{
		return GetDefaultObjImpl<UBFGTaskNode_BossCharge>();
	}
};
static_assert(alignof(UBFGTaskNode_BossCharge) == 0x000008, "Wrong alignment on UBFGTaskNode_BossCharge");
static_assert(sizeof(UBFGTaskNode_BossCharge) == 0x0000D8, "Wrong size on UBFGTaskNode_BossCharge");
static_assert(offsetof(UBFGTaskNode_BossCharge, M_fMinDistanceImpulse) == 0x0000A0, "Member 'UBFGTaskNode_BossCharge::M_fMinDistanceImpulse' has a wrong offset!");
static_assert(offsetof(UBFGTaskNode_BossCharge, M_fImpulseStrength) == 0x0000A4, "Member 'UBFGTaskNode_BossCharge::M_fImpulseStrength' has a wrong offset!");
static_assert(offsetof(UBFGTaskNode_BossCharge, M_pOwnerCharacterBoss_Armquist) == 0x0000A8, "Member 'UBFGTaskNode_BossCharge::M_pOwnerCharacterBoss_Armquist' has a wrong offset!");

// Class BFGCore.BFGNetworkPath_RelativeDistanceCalculator_EndSegment
// 0x0000 (0x0070 - 0x0070)
class UBFGNetworkPath_RelativeDistanceCalculator_EndSegment final : public UBFGNetworkPath_RelativeDistanceCalculator_Segment
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"BFGNetworkPath_RelativeDistanceCalculator_EndSegment">();
	}
	static class UBFGNetworkPath_RelativeDistanceCalculator_EndSegment* GetDefaultObj()
	{
		return GetDefaultObjImpl<UBFGNetworkPath_RelativeDistanceCalculator_EndSegment>();
	}
};
static_assert(alignof(UBFGNetworkPath_RelativeDistanceCalculator_EndSegment) == 0x000008, "Wrong alignment on UBFGNetworkPath_RelativeDistanceCalculator_EndSegment");
static_assert(sizeof(UBFGNetworkPath_RelativeDistanceCalculator_EndSegment) == 0x000070, "Wrong size on UBFGNetworkPath_RelativeDistanceCalculator_EndSegment");

// Class BFGCore.BFGNetworkPath_RelativeDistanceCalculator_Transition
// 0x0020 (0x0070 - 0x0050)
class UBFGNetworkPath_RelativeDistanceCalculator_Transition final : public UBFGNetworkPath_RelativeDistanceCalculator_Base
{
public:
	class UBFGNetworkPath*                        M_pStartPath;                                      // 0x0050(0x0008)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	EBFGNetworkPathExtremity                      M_eStartExtremity;                                 // 0x0058(0x0001)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_59[0x7];                                       // 0x0059(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	class UBFGNetworkPath*                        M_pEndPath;                                        // 0x0060(0x0008)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	EBFGNetworkPathExtremity                      M_eEndExtremity;                                   // 0x0068(0x0001)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_69[0x7];                                       // 0x0069(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"BFGNetworkPath_RelativeDistanceCalculator_Transition">();
	}
	static class UBFGNetworkPath_RelativeDistanceCalculator_Transition* GetDefaultObj()
	{
		return GetDefaultObjImpl<UBFGNetworkPath_RelativeDistanceCalculator_Transition>();
	}
};
static_assert(alignof(UBFGNetworkPath_RelativeDistanceCalculator_Transition) == 0x000008, "Wrong alignment on UBFGNetworkPath_RelativeDistanceCalculator_Transition");
static_assert(sizeof(UBFGNetworkPath_RelativeDistanceCalculator_Transition) == 0x000070, "Wrong size on UBFGNetworkPath_RelativeDistanceCalculator_Transition");
static_assert(offsetof(UBFGNetworkPath_RelativeDistanceCalculator_Transition, M_pStartPath) == 0x000050, "Member 'UBFGNetworkPath_RelativeDistanceCalculator_Transition::M_pStartPath' has a wrong offset!");
static_assert(offsetof(UBFGNetworkPath_RelativeDistanceCalculator_Transition, M_eStartExtremity) == 0x000058, "Member 'UBFGNetworkPath_RelativeDistanceCalculator_Transition::M_eStartExtremity' has a wrong offset!");
static_assert(offsetof(UBFGNetworkPath_RelativeDistanceCalculator_Transition, M_pEndPath) == 0x000060, "Member 'UBFGNetworkPath_RelativeDistanceCalculator_Transition::M_pEndPath' has a wrong offset!");
static_assert(offsetof(UBFGNetworkPath_RelativeDistanceCalculator_Transition, M_eEndExtremity) == 0x000068, "Member 'UBFGNetworkPath_RelativeDistanceCalculator_Transition::M_eEndExtremity' has a wrong offset!");

// Class BFGCore.BFGTaskNode_CivilianIdle
// 0x0000 (0x0070 - 0x0070)
class UBFGTaskNode_CivilianIdle final : public UBTTaskNode
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"BFGTaskNode_CivilianIdle">();
	}
	static class UBFGTaskNode_CivilianIdle* GetDefaultObj()
	{
		return GetDefaultObjImpl<UBFGTaskNode_CivilianIdle>();
	}
};
static_assert(alignof(UBFGTaskNode_CivilianIdle) == 0x000008, "Wrong alignment on UBFGTaskNode_CivilianIdle");
static_assert(sizeof(UBFGTaskNode_CivilianIdle) == 0x000070, "Wrong size on UBFGTaskNode_CivilianIdle");

// Class BFGCore.BFGNetworkPathAgent_AINPC
// 0x0000 (0x0188 - 0x0188)
class UBFGNetworkPathAgent_AINPC final : public UBFGNetworkPathAgent_AI
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"BFGNetworkPathAgent_AINPC">();
	}
	static class UBFGNetworkPathAgent_AINPC* GetDefaultObj()
	{
		return GetDefaultObjImpl<UBFGNetworkPathAgent_AINPC>();
	}
};
static_assert(alignof(UBFGNetworkPathAgent_AINPC) == 0x000008, "Wrong alignment on UBFGNetworkPathAgent_AINPC");
static_assert(sizeof(UBFGNetworkPathAgent_AINPC) == 0x000188, "Wrong size on UBFGNetworkPathAgent_AINPC");

// Class BFGCore.BFGNetworkPathAgent_AIStateDefault
// 0x0000 (0x0058 - 0x0058)
class UBFGNetworkPathAgent_AIStateDefault final : public UBFGNetworkPathAgent_AIStateBase
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"BFGNetworkPathAgent_AIStateDefault">();
	}
	static class UBFGNetworkPathAgent_AIStateDefault* GetDefaultObj()
	{
		return GetDefaultObjImpl<UBFGNetworkPathAgent_AIStateDefault>();
	}
};
static_assert(alignof(UBFGNetworkPathAgent_AIStateDefault) == 0x000008, "Wrong alignment on UBFGNetworkPathAgent_AIStateDefault");
static_assert(sizeof(UBFGNetworkPathAgent_AIStateDefault) == 0x000058, "Wrong size on UBFGNetworkPathAgent_AIStateDefault");

// Class BFGCore.BFGNetworkPathAgent_AIStateNPCExitVehicle
// 0x0228 (0x0280 - 0x0058)
class UBFGNetworkPathAgent_AIStateNPCExitVehicle final : public UBFGNetworkPathAgent_AIStateBase
{
public:
	EBFGAnimation_Interact                        M_eExitAnimationId;                                // 0x0058(0x0001)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	EBFGAgentAIPassengerExitPhase                 M_ePhase;                                          // 0x0059(0x0001)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_5A[0x2];                                       // 0x005A(0x0002)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         M_fExitTimer;                                      // 0x005C(0x0004)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         M_fPostponeExitTimer;                              // 0x0060(0x0004)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_64[0xC];                                       // 0x0064(0x000C)(Fixing Size After Last Property [ Dumper-7 ])
	struct FTransform                             M_spotTransform;                                   // 0x0070(0x0030)(Transient, IsPlainOldData, NoDestructor, Protected, NativeAccessSpecifierProtected)
	struct FVector                                M_vExitVector;                                     // 0x00A0(0x000C)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_AC[0x4];                                       // 0x00AC(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class UBFGNetworkPathAgent_Vehicle*           M_pAttachedVehicle;                                // 0x00B0(0x0008)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class FName                                   M_DoorBoneName;                                    // 0x00B8(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UCurveFloat*                            M_pDoorAnimCurve;                                  // 0x00C0(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_C8[0x8];                                       // 0x00C8(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	struct FBFGVehiclePassengerSpot               M_spot;                                            // 0x00D0(0x0190)(Edit, BlueprintVisible, Protected, NativeAccessSpecifierProtected)
	bool                                          M_bAttachedToVehicle;                              // 0x0260(0x0001)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_261[0x3];                                      // 0x0261(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         M_fNonAttachedTime;                                // 0x0264(0x0004)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         M_fExitAnimationLength;                            // 0x0268(0x0004)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         M_fRandomBackTrucExitOffset;                       // 0x026C(0x0004)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          M_bDoorOpened;                                     // 0x0270(0x0001)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_271[0xF];                                      // 0x0271(0x000F)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"BFGNetworkPathAgent_AIStateNPCExitVehicle">();
	}
	static class UBFGNetworkPathAgent_AIStateNPCExitVehicle* GetDefaultObj()
	{
		return GetDefaultObjImpl<UBFGNetworkPathAgent_AIStateNPCExitVehicle>();
	}
};
static_assert(alignof(UBFGNetworkPathAgent_AIStateNPCExitVehicle) == 0x000010, "Wrong alignment on UBFGNetworkPathAgent_AIStateNPCExitVehicle");
static_assert(sizeof(UBFGNetworkPathAgent_AIStateNPCExitVehicle) == 0x000280, "Wrong size on UBFGNetworkPathAgent_AIStateNPCExitVehicle");
static_assert(offsetof(UBFGNetworkPathAgent_AIStateNPCExitVehicle, M_eExitAnimationId) == 0x000058, "Member 'UBFGNetworkPathAgent_AIStateNPCExitVehicle::M_eExitAnimationId' has a wrong offset!");
static_assert(offsetof(UBFGNetworkPathAgent_AIStateNPCExitVehicle, M_ePhase) == 0x000059, "Member 'UBFGNetworkPathAgent_AIStateNPCExitVehicle::M_ePhase' has a wrong offset!");
static_assert(offsetof(UBFGNetworkPathAgent_AIStateNPCExitVehicle, M_fExitTimer) == 0x00005C, "Member 'UBFGNetworkPathAgent_AIStateNPCExitVehicle::M_fExitTimer' has a wrong offset!");
static_assert(offsetof(UBFGNetworkPathAgent_AIStateNPCExitVehicle, M_fPostponeExitTimer) == 0x000060, "Member 'UBFGNetworkPathAgent_AIStateNPCExitVehicle::M_fPostponeExitTimer' has a wrong offset!");
static_assert(offsetof(UBFGNetworkPathAgent_AIStateNPCExitVehicle, M_spotTransform) == 0x000070, "Member 'UBFGNetworkPathAgent_AIStateNPCExitVehicle::M_spotTransform' has a wrong offset!");
static_assert(offsetof(UBFGNetworkPathAgent_AIStateNPCExitVehicle, M_vExitVector) == 0x0000A0, "Member 'UBFGNetworkPathAgent_AIStateNPCExitVehicle::M_vExitVector' has a wrong offset!");
static_assert(offsetof(UBFGNetworkPathAgent_AIStateNPCExitVehicle, M_pAttachedVehicle) == 0x0000B0, "Member 'UBFGNetworkPathAgent_AIStateNPCExitVehicle::M_pAttachedVehicle' has a wrong offset!");
static_assert(offsetof(UBFGNetworkPathAgent_AIStateNPCExitVehicle, M_DoorBoneName) == 0x0000B8, "Member 'UBFGNetworkPathAgent_AIStateNPCExitVehicle::M_DoorBoneName' has a wrong offset!");
static_assert(offsetof(UBFGNetworkPathAgent_AIStateNPCExitVehicle, M_pDoorAnimCurve) == 0x0000C0, "Member 'UBFGNetworkPathAgent_AIStateNPCExitVehicle::M_pDoorAnimCurve' has a wrong offset!");
static_assert(offsetof(UBFGNetworkPathAgent_AIStateNPCExitVehicle, M_spot) == 0x0000D0, "Member 'UBFGNetworkPathAgent_AIStateNPCExitVehicle::M_spot' has a wrong offset!");
static_assert(offsetof(UBFGNetworkPathAgent_AIStateNPCExitVehicle, M_bAttachedToVehicle) == 0x000260, "Member 'UBFGNetworkPathAgent_AIStateNPCExitVehicle::M_bAttachedToVehicle' has a wrong offset!");
static_assert(offsetof(UBFGNetworkPathAgent_AIStateNPCExitVehicle, M_fNonAttachedTime) == 0x000264, "Member 'UBFGNetworkPathAgent_AIStateNPCExitVehicle::M_fNonAttachedTime' has a wrong offset!");
static_assert(offsetof(UBFGNetworkPathAgent_AIStateNPCExitVehicle, M_fExitAnimationLength) == 0x000268, "Member 'UBFGNetworkPathAgent_AIStateNPCExitVehicle::M_fExitAnimationLength' has a wrong offset!");
static_assert(offsetof(UBFGNetworkPathAgent_AIStateNPCExitVehicle, M_fRandomBackTrucExitOffset) == 0x00026C, "Member 'UBFGNetworkPathAgent_AIStateNPCExitVehicle::M_fRandomBackTrucExitOffset' has a wrong offset!");
static_assert(offsetof(UBFGNetworkPathAgent_AIStateNPCExitVehicle, M_bDoorOpened) == 0x000270, "Member 'UBFGNetworkPathAgent_AIStateNPCExitVehicle::M_bDoorOpened' has a wrong offset!");

// Class BFGCore.BFGUFOAbility_ExtractBrain
// 0x0000 (0x02A0 - 0x02A0)
class UBFGUFOAbility_ExtractBrain : public UBFGMentalAbility_ExtractBrain
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"BFGUFOAbility_ExtractBrain">();
	}
	static class UBFGUFOAbility_ExtractBrain* GetDefaultObj()
	{
		return GetDefaultObjImpl<UBFGUFOAbility_ExtractBrain>();
	}
};
static_assert(alignof(UBFGUFOAbility_ExtractBrain) == 0x000008, "Wrong alignment on UBFGUFOAbility_ExtractBrain");
static_assert(sizeof(UBFGUFOAbility_ExtractBrain) == 0x0002A0, "Wrong size on UBFGUFOAbility_ExtractBrain");

// Class BFGCore.BFGNetworkPathAgent_AIStateOff
// 0x0000 (0x0058 - 0x0058)
class UBFGNetworkPathAgent_AIStateOff : public UBFGNetworkPathAgent_AIStateBase
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"BFGNetworkPathAgent_AIStateOff">();
	}
	static class UBFGNetworkPathAgent_AIStateOff* GetDefaultObj()
	{
		return GetDefaultObjImpl<UBFGNetworkPathAgent_AIStateOff>();
	}
};
static_assert(alignof(UBFGNetworkPathAgent_AIStateOff) == 0x000008, "Wrong alignment on UBFGNetworkPathAgent_AIStateOff");
static_assert(sizeof(UBFGNetworkPathAgent_AIStateOff) == 0x000058, "Wrong size on UBFGNetworkPathAgent_AIStateOff");

// Class BFGCore.BFGNetworkPathAgent_AIStateOffVehicle
// 0x0000 (0x0058 - 0x0058)
class UBFGNetworkPathAgent_AIStateOffVehicle final : public UBFGNetworkPathAgent_AIStateOff
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"BFGNetworkPathAgent_AIStateOffVehicle">();
	}
	static class UBFGNetworkPathAgent_AIStateOffVehicle* GetDefaultObj()
	{
		return GetDefaultObjImpl<UBFGNetworkPathAgent_AIStateOffVehicle>();
	}
};
static_assert(alignof(UBFGNetworkPathAgent_AIStateOffVehicle) == 0x000008, "Wrong alignment on UBFGNetworkPathAgent_AIStateOffVehicle");
static_assert(sizeof(UBFGNetworkPathAgent_AIStateOffVehicle) == 0x000058, "Wrong size on UBFGNetworkPathAgent_AIStateOffVehicle");

// Class BFGCore.BFGNetworkPathAgent_AIStatePlayInteractAtLocation
// 0x00D8 (0x0130 - 0x0058)
class UBFGNetworkPathAgent_AIStatePlayInteractAtLocation final : public UBFGNetworkPathAgent_AIStateBase
{
public:
	UMulticastDelegateProperty_                   M_onInteractAnimChanged;                           // 0x0058(0x0018)(ZeroConstructor, InstancedReference, NativeAccessSpecifierPublic)
	EBFGAIPlayInteractAtLocationState             M_eState;                                          // 0x0070(0x0001)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_71[0x1F];                                      // 0x0071(0x001F)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<EBFGAnimation_Interact>                M_aAnimations;                                     // 0x0090(0x0010)(ZeroConstructor, Transient, Protected, NativeAccessSpecifierProtected)
	struct FBFGInteractAnimationSequence          M_animationSequence;                               // 0x00A0(0x0018)(Transient, Protected, NativeAccessSpecifierProtected)
	uint8                                         Pad_B8[0x78];                                      // 0x00B8(0x0078)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void OnAttachedActorChange(class UBFGNetworkPathAgent* _pAgent, class AActor* _pActor, bool _bIsAttached);
	void OnInteractAnimationPop(TScriptInterface<class IBFGInteractAnimationPlayerInterface> _pInteractAnimationPlayer, const struct FBFGInteractAnimationData& _data, const struct FBFGInteractAnimationData& _oldData);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"BFGNetworkPathAgent_AIStatePlayInteractAtLocation">();
	}
	static class UBFGNetworkPathAgent_AIStatePlayInteractAtLocation* GetDefaultObj()
	{
		return GetDefaultObjImpl<UBFGNetworkPathAgent_AIStatePlayInteractAtLocation>();
	}
};
static_assert(alignof(UBFGNetworkPathAgent_AIStatePlayInteractAtLocation) == 0x000008, "Wrong alignment on UBFGNetworkPathAgent_AIStatePlayInteractAtLocation");
static_assert(sizeof(UBFGNetworkPathAgent_AIStatePlayInteractAtLocation) == 0x000130, "Wrong size on UBFGNetworkPathAgent_AIStatePlayInteractAtLocation");
static_assert(offsetof(UBFGNetworkPathAgent_AIStatePlayInteractAtLocation, M_onInteractAnimChanged) == 0x000058, "Member 'UBFGNetworkPathAgent_AIStatePlayInteractAtLocation::M_onInteractAnimChanged' has a wrong offset!");
static_assert(offsetof(UBFGNetworkPathAgent_AIStatePlayInteractAtLocation, M_eState) == 0x000070, "Member 'UBFGNetworkPathAgent_AIStatePlayInteractAtLocation::M_eState' has a wrong offset!");
static_assert(offsetof(UBFGNetworkPathAgent_AIStatePlayInteractAtLocation, M_aAnimations) == 0x000090, "Member 'UBFGNetworkPathAgent_AIStatePlayInteractAtLocation::M_aAnimations' has a wrong offset!");
static_assert(offsetof(UBFGNetworkPathAgent_AIStatePlayInteractAtLocation, M_animationSequence) == 0x0000A0, "Member 'UBFGNetworkPathAgent_AIStatePlayInteractAtLocation::M_animationSequence' has a wrong offset!");

// Class BFGCore.BFGNetworkPathAgent_AIStateStandByNpc
// 0x0000 (0x0070 - 0x0070)
class UBFGNetworkPathAgent_AIStateStandByNpc final : public UBFGNetworkPathAgent_AIStateStandBy
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"BFGNetworkPathAgent_AIStateStandByNpc">();
	}
	static class UBFGNetworkPathAgent_AIStateStandByNpc* GetDefaultObj()
	{
		return GetDefaultObjImpl<UBFGNetworkPathAgent_AIStateStandByNpc>();
	}
};
static_assert(alignof(UBFGNetworkPathAgent_AIStateStandByNpc) == 0x000008, "Wrong alignment on UBFGNetworkPathAgent_AIStateStandByNpc");
static_assert(sizeof(UBFGNetworkPathAgent_AIStateStandByNpc) == 0x000070, "Wrong size on UBFGNetworkPathAgent_AIStateStandByNpc");

// Class BFGCore.BFGNetworkPathAgent_AIStateStandByVehicle
// 0x0000 (0x0070 - 0x0070)
class UBFGNetworkPathAgent_AIStateStandByVehicle final : public UBFGNetworkPathAgent_AIStateStandBy
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"BFGNetworkPathAgent_AIStateStandByVehicle">();
	}
	static class UBFGNetworkPathAgent_AIStateStandByVehicle* GetDefaultObj()
	{
		return GetDefaultObjImpl<UBFGNetworkPathAgent_AIStateStandByVehicle>();
	}
};
static_assert(alignof(UBFGNetworkPathAgent_AIStateStandByVehicle) == 0x000008, "Wrong alignment on UBFGNetworkPathAgent_AIStateStandByVehicle");
static_assert(sizeof(UBFGNetworkPathAgent_AIStateStandByVehicle) == 0x000070, "Wrong size on UBFGNetworkPathAgent_AIStateStandByVehicle");

// Class BFGCore.BFGNetworkPathAgent_AIStateTakePassengers
// 0x0008 (0x0060 - 0x0058)
class UBFGNetworkPathAgent_AIStateTakePassengers final : public UBFGNetworkPathAgent_AIStateBase
{
public:
	bool                                          M_bPanicMode;                                      // 0x0058(0x0001)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	EBFGAIVehicleTakePassengersPhase              M_ePhase;                                          // 0x0059(0x0001)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_5A[0x6];                                       // 0x005A(0x0006)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"BFGNetworkPathAgent_AIStateTakePassengers">();
	}
	static class UBFGNetworkPathAgent_AIStateTakePassengers* GetDefaultObj()
	{
		return GetDefaultObjImpl<UBFGNetworkPathAgent_AIStateTakePassengers>();
	}
};
static_assert(alignof(UBFGNetworkPathAgent_AIStateTakePassengers) == 0x000008, "Wrong alignment on UBFGNetworkPathAgent_AIStateTakePassengers");
static_assert(sizeof(UBFGNetworkPathAgent_AIStateTakePassengers) == 0x000060, "Wrong size on UBFGNetworkPathAgent_AIStateTakePassengers");
static_assert(offsetof(UBFGNetworkPathAgent_AIStateTakePassengers, M_bPanicMode) == 0x000058, "Member 'UBFGNetworkPathAgent_AIStateTakePassengers::M_bPanicMode' has a wrong offset!");
static_assert(offsetof(UBFGNetworkPathAgent_AIStateTakePassengers, M_ePhase) == 0x000059, "Member 'UBFGNetworkPathAgent_AIStateTakePassengers::M_ePhase' has a wrong offset!");

// Class BFGCore.BFGNetworkPathAgent_AIStateTestStop
// 0x0008 (0x0060 - 0x0058)
class UBFGNetworkPathAgent_AIStateTestStop final : public UBFGNetworkPathAgent_AIStateBase
{
public:
	float                                         M_fTimer;                                          // 0x0058(0x0004)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          M_bIsStopping;                                     // 0x005C(0x0001)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_5D[0x3];                                       // 0x005D(0x0003)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"BFGNetworkPathAgent_AIStateTestStop">();
	}
	static class UBFGNetworkPathAgent_AIStateTestStop* GetDefaultObj()
	{
		return GetDefaultObjImpl<UBFGNetworkPathAgent_AIStateTestStop>();
	}
};
static_assert(alignof(UBFGNetworkPathAgent_AIStateTestStop) == 0x000008, "Wrong alignment on UBFGNetworkPathAgent_AIStateTestStop");
static_assert(sizeof(UBFGNetworkPathAgent_AIStateTestStop) == 0x000060, "Wrong size on UBFGNetworkPathAgent_AIStateTestStop");
static_assert(offsetof(UBFGNetworkPathAgent_AIStateTestStop, M_fTimer) == 0x000058, "Member 'UBFGNetworkPathAgent_AIStateTestStop::M_fTimer' has a wrong offset!");
static_assert(offsetof(UBFGNetworkPathAgent_AIStateTestStop, M_bIsStopping) == 0x00005C, "Member 'UBFGNetworkPathAgent_AIStateTestStop::M_bIsStopping' has a wrong offset!");

// Class BFGCore.BFGNetworkPathAgent_AIStateVehicleFlee
// 0x0028 (0x0080 - 0x0058)
class UBFGNetworkPathAgent_AIStateVehicleFlee final : public UBFGNetworkPathAgent_AIStateBase
{
public:
	class UObject*                                M_pTargetToEscapeFrom;                             // 0x0058(0x0008)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          M_bTargetChanged;                                  // 0x0060(0x0001)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_61[0x3];                                       // 0x0061(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         M_fRecomputeTimer;                                 // 0x0064(0x0004)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	EBFGAIVehicleVehicleFleePhase                 M_ePhase;                                          // 0x0068(0x0001)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_69[0x3];                                       // 0x0069(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	struct FVector                                M_vLastKnownLocation;                              // 0x006C(0x000C)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         M_fCoolDownTimer;                                  // 0x0078(0x0004)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_7C[0x4];                                       // 0x007C(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"BFGNetworkPathAgent_AIStateVehicleFlee">();
	}
	static class UBFGNetworkPathAgent_AIStateVehicleFlee* GetDefaultObj()
	{
		return GetDefaultObjImpl<UBFGNetworkPathAgent_AIStateVehicleFlee>();
	}
};
static_assert(alignof(UBFGNetworkPathAgent_AIStateVehicleFlee) == 0x000008, "Wrong alignment on UBFGNetworkPathAgent_AIStateVehicleFlee");
static_assert(sizeof(UBFGNetworkPathAgent_AIStateVehicleFlee) == 0x000080, "Wrong size on UBFGNetworkPathAgent_AIStateVehicleFlee");
static_assert(offsetof(UBFGNetworkPathAgent_AIStateVehicleFlee, M_pTargetToEscapeFrom) == 0x000058, "Member 'UBFGNetworkPathAgent_AIStateVehicleFlee::M_pTargetToEscapeFrom' has a wrong offset!");
static_assert(offsetof(UBFGNetworkPathAgent_AIStateVehicleFlee, M_bTargetChanged) == 0x000060, "Member 'UBFGNetworkPathAgent_AIStateVehicleFlee::M_bTargetChanged' has a wrong offset!");
static_assert(offsetof(UBFGNetworkPathAgent_AIStateVehicleFlee, M_fRecomputeTimer) == 0x000064, "Member 'UBFGNetworkPathAgent_AIStateVehicleFlee::M_fRecomputeTimer' has a wrong offset!");
static_assert(offsetof(UBFGNetworkPathAgent_AIStateVehicleFlee, M_ePhase) == 0x000068, "Member 'UBFGNetworkPathAgent_AIStateVehicleFlee::M_ePhase' has a wrong offset!");
static_assert(offsetof(UBFGNetworkPathAgent_AIStateVehicleFlee, M_vLastKnownLocation) == 0x00006C, "Member 'UBFGNetworkPathAgent_AIStateVehicleFlee::M_vLastKnownLocation' has a wrong offset!");
static_assert(offsetof(UBFGNetworkPathAgent_AIStateVehicleFlee, M_fCoolDownTimer) == 0x000078, "Member 'UBFGNetworkPathAgent_AIStateVehicleFlee::M_fCoolDownTimer' has a wrong offset!");

// Class BFGCore.BFGNetworkPathAgent_NavMeshPathUser
// 0x0000 (0x05A0 - 0x05A0)
class UBFGNetworkPathAgent_NavMeshPathUser : public UBFGNetworkPathAgent
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"BFGNetworkPathAgent_NavMeshPathUser">();
	}
	static class UBFGNetworkPathAgent_NavMeshPathUser* GetDefaultObj()
	{
		return GetDefaultObjImpl<UBFGNetworkPathAgent_NavMeshPathUser>();
	}
};
static_assert(alignof(UBFGNetworkPathAgent_NavMeshPathUser) == 0x000008, "Wrong alignment on UBFGNetworkPathAgent_NavMeshPathUser");
static_assert(sizeof(UBFGNetworkPathAgent_NavMeshPathUser) == 0x0005A0, "Wrong size on UBFGNetworkPathAgent_NavMeshPathUser");

// Class BFGCore.BFGVoiceoverStatistics
// 0x0058 (0x0080 - 0x0028)
class UBFGVoiceoverStatistics final : public UObject
{
public:
	TMap<class FName, float>                      M_aLastSpokenTimes;                                // 0x0028(0x0050)(ZeroConstructor, NativeAccessSpecifierPrivate)
	class ABFGGameState*                          M_pGameState;                                      // 0x0078(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)

public:
	float GetLastSpokenTime(class FName _voice) const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"BFGVoiceoverStatistics">();
	}
	static class UBFGVoiceoverStatistics* GetDefaultObj()
	{
		return GetDefaultObjImpl<UBFGVoiceoverStatistics>();
	}
};
static_assert(alignof(UBFGVoiceoverStatistics) == 0x000008, "Wrong alignment on UBFGVoiceoverStatistics");
static_assert(sizeof(UBFGVoiceoverStatistics) == 0x000080, "Wrong size on UBFGVoiceoverStatistics");
static_assert(offsetof(UBFGVoiceoverStatistics, M_aLastSpokenTimes) == 0x000028, "Member 'UBFGVoiceoverStatistics::M_aLastSpokenTimes' has a wrong offset!");
static_assert(offsetof(UBFGVoiceoverStatistics, M_pGameState) == 0x000078, "Member 'UBFGVoiceoverStatistics::M_pGameState' has a wrong offset!");

// Class BFGCore.BFGNetworkPathAgent_Animal
// 0x0000 (0x05A0 - 0x05A0)
class UBFGNetworkPathAgent_Animal final : public UBFGNetworkPathAgent_NavMeshPathUser
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"BFGNetworkPathAgent_Animal">();
	}
	static class UBFGNetworkPathAgent_Animal* GetDefaultObj()
	{
		return GetDefaultObjImpl<UBFGNetworkPathAgent_Animal>();
	}
};
static_assert(alignof(UBFGNetworkPathAgent_Animal) == 0x000008, "Wrong alignment on UBFGNetworkPathAgent_Animal");
static_assert(sizeof(UBFGNetworkPathAgent_Animal) == 0x0005A0, "Wrong size on UBFGNetworkPathAgent_Animal");

// Class BFGCore.BFGNetworkPathAgent_AttachedEntityVehicle
// 0x0410 (0x0840 - 0x0430)
#pragma pack(push, 0x1)
class alignas(0x10) UBFGNetworkPathAgent_AttachedEntityVehicle : public UBFGNetworkPathAgent_AttachedEntity
{
public:
	UMulticastDelegateProperty_                   M_onPassengersOut;                                 // 0x0428(0x0018)(ZeroConstructor, InstancedReference, NativeAccessSpecifierPublic)
	struct FBFGWheeledVehicleConfig               M_config;                                          // 0x0440(0x03B8)(Transient, Protected, NativeAccessSpecifierProtected)
	class UBFGVehiclePassengerContainer*          M_pDriverSpotEntry;                                // 0x07F8(0x0008)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	struct FBFGVehicleState                       M_vehicleState;                                    // 0x0800(0x0018)(Transient, Protected, NativeAccessSpecifierProtected)
	uint8                                         Pad_818[0x20];                                     // 0x0818(0x0020)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"BFGNetworkPathAgent_AttachedEntityVehicle">();
	}
	static class UBFGNetworkPathAgent_AttachedEntityVehicle* GetDefaultObj()
	{
		return GetDefaultObjImpl<UBFGNetworkPathAgent_AttachedEntityVehicle>();
	}
};
#pragma pack(pop)
static_assert(alignof(UBFGNetworkPathAgent_AttachedEntityVehicle) == 0x000010, "Wrong alignment on UBFGNetworkPathAgent_AttachedEntityVehicle");
static_assert(sizeof(UBFGNetworkPathAgent_AttachedEntityVehicle) == 0x000840, "Wrong size on UBFGNetworkPathAgent_AttachedEntityVehicle");
static_assert(offsetof(UBFGNetworkPathAgent_AttachedEntityVehicle, M_onPassengersOut) == 0x000428, "Member 'UBFGNetworkPathAgent_AttachedEntityVehicle::M_onPassengersOut' has a wrong offset!");
static_assert(offsetof(UBFGNetworkPathAgent_AttachedEntityVehicle, M_config) == 0x000440, "Member 'UBFGNetworkPathAgent_AttachedEntityVehicle::M_config' has a wrong offset!");
static_assert(offsetof(UBFGNetworkPathAgent_AttachedEntityVehicle, M_pDriverSpotEntry) == 0x0007F8, "Member 'UBFGNetworkPathAgent_AttachedEntityVehicle::M_pDriverSpotEntry' has a wrong offset!");
static_assert(offsetof(UBFGNetworkPathAgent_AttachedEntityVehicle, M_vehicleState) == 0x000800, "Member 'UBFGNetworkPathAgent_AttachedEntityVehicle::M_vehicleState' has a wrong offset!");

// Class BFGCore.BFGNetworkPathAgent_AttachedEntityTank
// 0x0040 (0x0880 - 0x0840)
class UBFGNetworkPathAgent_AttachedEntityTank final : public UBFGNetworkPathAgent_AttachedEntityVehicle
{
public:
	struct FBFGTankInfo                           M_tankInfo;                                        // 0x0838(0x0040)(Transient, NoDestructor, Protected, NativeAccessSpecifierProtected)
	uint8                                         Pad_878[0x8];                                      // 0x0878(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"BFGNetworkPathAgent_AttachedEntityTank">();
	}
	static class UBFGNetworkPathAgent_AttachedEntityTank* GetDefaultObj()
	{
		return GetDefaultObjImpl<UBFGNetworkPathAgent_AttachedEntityTank>();
	}
};
static_assert(alignof(UBFGNetworkPathAgent_AttachedEntityTank) == 0x000010, "Wrong alignment on UBFGNetworkPathAgent_AttachedEntityTank");
static_assert(sizeof(UBFGNetworkPathAgent_AttachedEntityTank) == 0x000880, "Wrong size on UBFGNetworkPathAgent_AttachedEntityTank");
static_assert(offsetof(UBFGNetworkPathAgent_AttachedEntityTank, M_tankInfo) == 0x000838, "Member 'UBFGNetworkPathAgent_AttachedEntityTank::M_tankInfo' has a wrong offset!");

// Class BFGCore.BFGNetworkPathAgent_Human
// 0x0080 (0x0620 - 0x05A0)
class UBFGNetworkPathAgent_Human final : public UBFGNetworkPathAgent_NavMeshPathUser
{
public:
	class UBFGNetworkPathAgent_Vehicle*           M_pAttachedVehicle;                                // 0x05A0(0x0008)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	EBFGNetworkPathAgent_HumanMode                M_eMode;                                           // 0x05A8(0x0001)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	EBFGNetworkPathAgent_AIControllerState        M_eAIControllerState;                              // 0x05A9(0x0001)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_5AA[0x6];                                      // 0x05AA(0x0006)(Fixing Size After Last Property [ Dumper-7 ])
	struct FTransform                             M_vehicleSpotTransform;                            // 0x05B0(0x0030)(Transient, IsPlainOldData, NoDestructor, Protected, NativeAccessSpecifierProtected)
	struct FTransform                             M_vehicleRelativeSpotTransform;                    // 0x05E0(0x0030)(Transient, IsPlainOldData, NoDestructor, Protected, NativeAccessSpecifierProtected)
	struct FVector                                M_vVehicleSpotNonStandardRelativeOffset;           // 0x0610(0x000C)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          M_bIsAttachedToVehicle;                            // 0x061C(0x0001)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_61D[0x3];                                      // 0x061D(0x0003)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"BFGNetworkPathAgent_Human">();
	}
	static class UBFGNetworkPathAgent_Human* GetDefaultObj()
	{
		return GetDefaultObjImpl<UBFGNetworkPathAgent_Human>();
	}
};
static_assert(alignof(UBFGNetworkPathAgent_Human) == 0x000010, "Wrong alignment on UBFGNetworkPathAgent_Human");
static_assert(sizeof(UBFGNetworkPathAgent_Human) == 0x000620, "Wrong size on UBFGNetworkPathAgent_Human");
static_assert(offsetof(UBFGNetworkPathAgent_Human, M_pAttachedVehicle) == 0x0005A0, "Member 'UBFGNetworkPathAgent_Human::M_pAttachedVehicle' has a wrong offset!");
static_assert(offsetof(UBFGNetworkPathAgent_Human, M_eMode) == 0x0005A8, "Member 'UBFGNetworkPathAgent_Human::M_eMode' has a wrong offset!");
static_assert(offsetof(UBFGNetworkPathAgent_Human, M_eAIControllerState) == 0x0005A9, "Member 'UBFGNetworkPathAgent_Human::M_eAIControllerState' has a wrong offset!");
static_assert(offsetof(UBFGNetworkPathAgent_Human, M_vehicleSpotTransform) == 0x0005B0, "Member 'UBFGNetworkPathAgent_Human::M_vehicleSpotTransform' has a wrong offset!");
static_assert(offsetof(UBFGNetworkPathAgent_Human, M_vehicleRelativeSpotTransform) == 0x0005E0, "Member 'UBFGNetworkPathAgent_Human::M_vehicleRelativeSpotTransform' has a wrong offset!");
static_assert(offsetof(UBFGNetworkPathAgent_Human, M_vVehicleSpotNonStandardRelativeOffset) == 0x000610, "Member 'UBFGNetworkPathAgent_Human::M_vVehicleSpotNonStandardRelativeOffset' has a wrong offset!");
static_assert(offsetof(UBFGNetworkPathAgent_Human, M_bIsAttachedToVehicle) == 0x00061C, "Member 'UBFGNetworkPathAgent_Human::M_bIsAttachedToVehicle' has a wrong offset!");

// Class BFGCore.BFGNetworkPathAgent_MoveNavMesh
// 0x0080 (0x06C0 - 0x0640)
class UBFGNetworkPathAgent_MoveNavMesh final : public UBFGNetworkPathAgent_Move
{
public:
	uint8                                         Pad_638[0x8];                                      // 0x0638(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         M_fTargetOffsetFromCenter;                         // 0x0640(0x0004)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         M_fCurrentOffsetFromCenter;                        // 0x0644(0x0004)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         M_fMaxOffSetFromCenterRatio;                       // 0x0648(0x0004)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         M_fOffsetModifyTimer;                              // 0x064C(0x0004)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	struct FVector                                M_vGoalActorTargetLocation;                        // 0x0650(0x000C)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	struct FVector                                M_vNPCTargetLocation;                              // 0x065C(0x000C)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	struct FVector                                M_vLastTargetLocation;                             // 0x0668(0x000C)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_674[0x4];                                      // 0x0674(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         M_fWalkSpeed;                                      // 0x0678(0x0004)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         M_fWalkSpeedModifier;                              // 0x067C(0x0004)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         M_fInitialWalkSpeed;                               // 0x0680(0x0004)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         M_fOverrideSpeed;                                  // 0x0684(0x0004)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	EBFGNPCCharacter_MoveSpeed                    M_overrideMoveSpeed;                               // 0x0688(0x0001)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_689[0x37];                                     // 0x0689(0x0037)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"BFGNetworkPathAgent_MoveNavMesh">();
	}
	static class UBFGNetworkPathAgent_MoveNavMesh* GetDefaultObj()
	{
		return GetDefaultObjImpl<UBFGNetworkPathAgent_MoveNavMesh>();
	}
};
static_assert(alignof(UBFGNetworkPathAgent_MoveNavMesh) == 0x000010, "Wrong alignment on UBFGNetworkPathAgent_MoveNavMesh");
static_assert(sizeof(UBFGNetworkPathAgent_MoveNavMesh) == 0x0006C0, "Wrong size on UBFGNetworkPathAgent_MoveNavMesh");
static_assert(offsetof(UBFGNetworkPathAgent_MoveNavMesh, M_fTargetOffsetFromCenter) == 0x000640, "Member 'UBFGNetworkPathAgent_MoveNavMesh::M_fTargetOffsetFromCenter' has a wrong offset!");
static_assert(offsetof(UBFGNetworkPathAgent_MoveNavMesh, M_fCurrentOffsetFromCenter) == 0x000644, "Member 'UBFGNetworkPathAgent_MoveNavMesh::M_fCurrentOffsetFromCenter' has a wrong offset!");
static_assert(offsetof(UBFGNetworkPathAgent_MoveNavMesh, M_fMaxOffSetFromCenterRatio) == 0x000648, "Member 'UBFGNetworkPathAgent_MoveNavMesh::M_fMaxOffSetFromCenterRatio' has a wrong offset!");
static_assert(offsetof(UBFGNetworkPathAgent_MoveNavMesh, M_fOffsetModifyTimer) == 0x00064C, "Member 'UBFGNetworkPathAgent_MoveNavMesh::M_fOffsetModifyTimer' has a wrong offset!");
static_assert(offsetof(UBFGNetworkPathAgent_MoveNavMesh, M_vGoalActorTargetLocation) == 0x000650, "Member 'UBFGNetworkPathAgent_MoveNavMesh::M_vGoalActorTargetLocation' has a wrong offset!");
static_assert(offsetof(UBFGNetworkPathAgent_MoveNavMesh, M_vNPCTargetLocation) == 0x00065C, "Member 'UBFGNetworkPathAgent_MoveNavMesh::M_vNPCTargetLocation' has a wrong offset!");
static_assert(offsetof(UBFGNetworkPathAgent_MoveNavMesh, M_vLastTargetLocation) == 0x000668, "Member 'UBFGNetworkPathAgent_MoveNavMesh::M_vLastTargetLocation' has a wrong offset!");
static_assert(offsetof(UBFGNetworkPathAgent_MoveNavMesh, M_fWalkSpeed) == 0x000678, "Member 'UBFGNetworkPathAgent_MoveNavMesh::M_fWalkSpeed' has a wrong offset!");
static_assert(offsetof(UBFGNetworkPathAgent_MoveNavMesh, M_fWalkSpeedModifier) == 0x00067C, "Member 'UBFGNetworkPathAgent_MoveNavMesh::M_fWalkSpeedModifier' has a wrong offset!");
static_assert(offsetof(UBFGNetworkPathAgent_MoveNavMesh, M_fInitialWalkSpeed) == 0x000680, "Member 'UBFGNetworkPathAgent_MoveNavMesh::M_fInitialWalkSpeed' has a wrong offset!");
static_assert(offsetof(UBFGNetworkPathAgent_MoveNavMesh, M_fOverrideSpeed) == 0x000684, "Member 'UBFGNetworkPathAgent_MoveNavMesh::M_fOverrideSpeed' has a wrong offset!");
static_assert(offsetof(UBFGNetworkPathAgent_MoveNavMesh, M_overrideMoveSpeed) == 0x000688, "Member 'UBFGNetworkPathAgent_MoveNavMesh::M_overrideMoveSpeed' has a wrong offset!");

// Class BFGCore.BFGNetworkPathAgent_MoveVehicle
// 0x02A0 (0x08E0 - 0x0640)
class UBFGNetworkPathAgent_MoveVehicle final : public UBFGNetworkPathAgent_Move
{
public:
	struct FBFGVehicleAgentDriveInfo              M_driveInfo;                                       // 0x0638(0x005C)(Transient, NoDestructor, Protected, NativeAccessSpecifierProtected)
	uint8                                         Pad_694[0x4];                                      // 0x0694(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	struct FBFGVehicleDrivingState                M_drivingState;                                    // 0x0698(0x0018)(Transient, NoDestructor, Protected, NativeAccessSpecifierProtected)
	float                                         M_fVehicleMaxSpeed;                                // 0x06B0(0x0004)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         M_fVehicleMaxAlertSpeed;                           // 0x06B4(0x0004)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         M_fVehicleMaxSpeedOverride;                        // 0x06B8(0x0004)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          M_bSlowAndLetOvertakingAgentPass;                  // 0x06BC(0x0001)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_6BD[0x3];                                      // 0x06BD(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         M_fRequestedOffsetFromCenter;                      // 0x06C0(0x0004)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_6C4[0x4];                                      // 0x06C4(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	struct FBFGInFrontObstacleInfo                M_infrontObstacleInfo;                             // 0x06C8(0x0028)(Transient, NoDestructor, Protected, NativeAccessSpecifierProtected)
	struct FBFGInFrontIntersectionInfo            M_inFrontIntersectionInfo;                         // 0x06F0(0x0048)(Transient, NoDestructor, Protected, NativeAccessSpecifierProtected)
	struct FBFGInFrontVehicleInfo                 M_inFrontVehicleInfo;                              // 0x0738(0x0030)(Transient, NoDestructor, Protected, NativeAccessSpecifierProtected)
	uint8                                         Pad_768[0x88];                                     // 0x0768(0x0088)(Fixing Size After Last Property [ Dumper-7 ])
	struct FBFGVehicleStop_Param                  M_stopMode;                                        // 0x07F0(0x000C)(Transient, NoDestructor, Protected, NativeAccessSpecifierProtected)
	uint8                                         Pad_7FC[0x4];                                      // 0x07FC(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	struct FBFGVirtualVehicle                     M_virtualVehicle;                                  // 0x0800(0x00D0)(Transient, NoDestructor, Protected, NativeAccessSpecifierProtected)
	float                                         M_fAdditionalOffset;                               // 0x08D0(0x0004)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_8D4[0xC];                                      // 0x08D4(0x000C)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"BFGNetworkPathAgent_MoveVehicle">();
	}
	static class UBFGNetworkPathAgent_MoveVehicle* GetDefaultObj()
	{
		return GetDefaultObjImpl<UBFGNetworkPathAgent_MoveVehicle>();
	}
};
static_assert(alignof(UBFGNetworkPathAgent_MoveVehicle) == 0x000010, "Wrong alignment on UBFGNetworkPathAgent_MoveVehicle");
static_assert(sizeof(UBFGNetworkPathAgent_MoveVehicle) == 0x0008E0, "Wrong size on UBFGNetworkPathAgent_MoveVehicle");
static_assert(offsetof(UBFGNetworkPathAgent_MoveVehicle, M_driveInfo) == 0x000638, "Member 'UBFGNetworkPathAgent_MoveVehicle::M_driveInfo' has a wrong offset!");
static_assert(offsetof(UBFGNetworkPathAgent_MoveVehicle, M_drivingState) == 0x000698, "Member 'UBFGNetworkPathAgent_MoveVehicle::M_drivingState' has a wrong offset!");
static_assert(offsetof(UBFGNetworkPathAgent_MoveVehicle, M_fVehicleMaxSpeed) == 0x0006B0, "Member 'UBFGNetworkPathAgent_MoveVehicle::M_fVehicleMaxSpeed' has a wrong offset!");
static_assert(offsetof(UBFGNetworkPathAgent_MoveVehicle, M_fVehicleMaxAlertSpeed) == 0x0006B4, "Member 'UBFGNetworkPathAgent_MoveVehicle::M_fVehicleMaxAlertSpeed' has a wrong offset!");
static_assert(offsetof(UBFGNetworkPathAgent_MoveVehicle, M_fVehicleMaxSpeedOverride) == 0x0006B8, "Member 'UBFGNetworkPathAgent_MoveVehicle::M_fVehicleMaxSpeedOverride' has a wrong offset!");
static_assert(offsetof(UBFGNetworkPathAgent_MoveVehicle, M_bSlowAndLetOvertakingAgentPass) == 0x0006BC, "Member 'UBFGNetworkPathAgent_MoveVehicle::M_bSlowAndLetOvertakingAgentPass' has a wrong offset!");
static_assert(offsetof(UBFGNetworkPathAgent_MoveVehicle, M_fRequestedOffsetFromCenter) == 0x0006C0, "Member 'UBFGNetworkPathAgent_MoveVehicle::M_fRequestedOffsetFromCenter' has a wrong offset!");
static_assert(offsetof(UBFGNetworkPathAgent_MoveVehicle, M_infrontObstacleInfo) == 0x0006C8, "Member 'UBFGNetworkPathAgent_MoveVehicle::M_infrontObstacleInfo' has a wrong offset!");
static_assert(offsetof(UBFGNetworkPathAgent_MoveVehicle, M_inFrontIntersectionInfo) == 0x0006F0, "Member 'UBFGNetworkPathAgent_MoveVehicle::M_inFrontIntersectionInfo' has a wrong offset!");
static_assert(offsetof(UBFGNetworkPathAgent_MoveVehicle, M_inFrontVehicleInfo) == 0x000738, "Member 'UBFGNetworkPathAgent_MoveVehicle::M_inFrontVehicleInfo' has a wrong offset!");
static_assert(offsetof(UBFGNetworkPathAgent_MoveVehicle, M_stopMode) == 0x0007F0, "Member 'UBFGNetworkPathAgent_MoveVehicle::M_stopMode' has a wrong offset!");
static_assert(offsetof(UBFGNetworkPathAgent_MoveVehicle, M_virtualVehicle) == 0x000800, "Member 'UBFGNetworkPathAgent_MoveVehicle::M_virtualVehicle' has a wrong offset!");
static_assert(offsetof(UBFGNetworkPathAgent_MoveVehicle, M_fAdditionalOffset) == 0x0008D0, "Member 'UBFGNetworkPathAgent_MoveVehicle::M_fAdditionalOffset' has a wrong offset!");

// Class BFGCore.BFGNetworkPathAgent_NavigationVehicle
// 0x0020 (0x0420 - 0x0400)
class UBFGNetworkPathAgent_NavigationVehicle final : public UBFGNetworkPathAgent_Navigation
{
public:
	struct FBFGVehicleHeightData                  M_vehicleHeightData;                               // 0x03F8(0x0020)(Transient, NoDestructor, Protected, NativeAccessSpecifierProtected)
	uint8                                         Pad_418[0x8];                                      // 0x0418(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"BFGNetworkPathAgent_NavigationVehicle">();
	}
	static class UBFGNetworkPathAgent_NavigationVehicle* GetDefaultObj()
	{
		return GetDefaultObjImpl<UBFGNetworkPathAgent_NavigationVehicle>();
	}
};
static_assert(alignof(UBFGNetworkPathAgent_NavigationVehicle) == 0x000010, "Wrong alignment on UBFGNetworkPathAgent_NavigationVehicle");
static_assert(sizeof(UBFGNetworkPathAgent_NavigationVehicle) == 0x000420, "Wrong size on UBFGNetworkPathAgent_NavigationVehicle");
static_assert(offsetof(UBFGNetworkPathAgent_NavigationVehicle, M_vehicleHeightData) == 0x0003F8, "Member 'UBFGNetworkPathAgent_NavigationVehicle::M_vehicleHeightData' has a wrong offset!");

// Class BFGCore.BFGWeapon_BossProjectile
// 0x0028 (0x08C8 - 0x08A0)
class ABFGWeapon_BossProjectile final : public ABFGWeapon_BossBase
{
public:
	TArray<TSubclassOf<class ABFGPattern_Projectile>> M_aProjectilePatternClasses;                       // 0x08A0(0x0010)(Edit, ZeroConstructor, DisableEditOnInstance, UObjectWrapper, NativeAccessSpecifierPublic)
	bool                                          M_bUseSubFrameBulletTiming;                        // 0x08B0(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_8B1[0x3];                                      // 0x08B1(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	class FName                                   M_strHandSocket;                                   // 0x08B4(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   M_strShoulderSocket;                               // 0x08BC(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          M_bShowAimingLines;                                // 0x08C4(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_8C5[0x3];                                      // 0x08C5(0x0003)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"BFGWeapon_BossProjectile">();
	}
	static class ABFGWeapon_BossProjectile* GetDefaultObj()
	{
		return GetDefaultObjImpl<ABFGWeapon_BossProjectile>();
	}
};
static_assert(alignof(ABFGWeapon_BossProjectile) == 0x000008, "Wrong alignment on ABFGWeapon_BossProjectile");
static_assert(sizeof(ABFGWeapon_BossProjectile) == 0x0008C8, "Wrong size on ABFGWeapon_BossProjectile");
static_assert(offsetof(ABFGWeapon_BossProjectile, M_aProjectilePatternClasses) == 0x0008A0, "Member 'ABFGWeapon_BossProjectile::M_aProjectilePatternClasses' has a wrong offset!");
static_assert(offsetof(ABFGWeapon_BossProjectile, M_bUseSubFrameBulletTiming) == 0x0008B0, "Member 'ABFGWeapon_BossProjectile::M_bUseSubFrameBulletTiming' has a wrong offset!");
static_assert(offsetof(ABFGWeapon_BossProjectile, M_strHandSocket) == 0x0008B4, "Member 'ABFGWeapon_BossProjectile::M_strHandSocket' has a wrong offset!");
static_assert(offsetof(ABFGWeapon_BossProjectile, M_strShoulderSocket) == 0x0008BC, "Member 'ABFGWeapon_BossProjectile::M_strShoulderSocket' has a wrong offset!");
static_assert(offsetof(ABFGWeapon_BossProjectile, M_bShowAimingLines) == 0x0008C4, "Member 'ABFGWeapon_BossProjectile::M_bShowAimingLines' has a wrong offset!");

// Class BFGCore.BFGNetworkPathAgent_NavModeNetworkPath
// 0x0370 (0x03B0 - 0x0040)
class UBFGNetworkPathAgent_NavModeNetworkPath : public UBFGNetworkPathAgent_NavModeBase
{
public:
	struct FBFGNetworkPathNavigationData          M_navigationData;                                  // 0x0040(0x0370)(Transient, Protected, NativeAccessSpecifierProtected)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"BFGNetworkPathAgent_NavModeNetworkPath">();
	}
	static class UBFGNetworkPathAgent_NavModeNetworkPath* GetDefaultObj()
	{
		return GetDefaultObjImpl<UBFGNetworkPathAgent_NavModeNetworkPath>();
	}
};
static_assert(alignof(UBFGNetworkPathAgent_NavModeNetworkPath) == 0x000010, "Wrong alignment on UBFGNetworkPathAgent_NavModeNetworkPath");
static_assert(sizeof(UBFGNetworkPathAgent_NavModeNetworkPath) == 0x0003B0, "Wrong size on UBFGNetworkPathAgent_NavModeNetworkPath");
static_assert(offsetof(UBFGNetworkPathAgent_NavModeNetworkPath, M_navigationData) == 0x000040, "Member 'UBFGNetworkPathAgent_NavModeNetworkPath::M_navigationData' has a wrong offset!");

// Class BFGCore.BFGNetworkPathAgent_NavModeNetworkPathRandom
// 0x0000 (0x03B0 - 0x03B0)
class UBFGNetworkPathAgent_NavModeNetworkPathRandom final : public UBFGNetworkPathAgent_NavModeNetworkPath
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"BFGNetworkPathAgent_NavModeNetworkPathRandom">();
	}
	static class UBFGNetworkPathAgent_NavModeNetworkPathRandom* GetDefaultObj()
	{
		return GetDefaultObjImpl<UBFGNetworkPathAgent_NavModeNetworkPathRandom>();
	}
};
static_assert(alignof(UBFGNetworkPathAgent_NavModeNetworkPathRandom) == 0x000010, "Wrong alignment on UBFGNetworkPathAgent_NavModeNetworkPathRandom");
static_assert(sizeof(UBFGNetworkPathAgent_NavModeNetworkPathRandom) == 0x0003B0, "Wrong size on UBFGNetworkPathAgent_NavModeNetworkPathRandom");

// Class BFGCore.BFGNetworkPathAgent_NavModeNetworkPathScriptedPath
// 0x0030 (0x03E0 - 0x03B0)
class UBFGNetworkPathAgent_NavModeNetworkPathScriptedPath final : public UBFGNetworkPathAgent_NavModeNetworkPath
{
public:
	class ABFGMissionPath*                        M_pMissionPath;                                    // 0x03B0(0x0008)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UBFGNetworkPath_ScriptedPath*           M_pScriptedPath;                                   // 0x03B8(0x0008)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UBFGNetworkPath_ScriptedPath*           M_pTestScriptedPath;                               // 0x03C0(0x0008)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          M_bStopStarted;                                    // 0x03C8(0x0001)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_3C9[0x3];                                      // 0x03C9(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         M_fCheckWaypointTimer;                             // 0x03CC(0x0004)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	int32                                         M_iLastKnownWaypoint;                              // 0x03D0(0x0004)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          M_bSwitchToFreeNavAtEnd;                           // 0x03D4(0x0001)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_3D5[0xB];                                      // 0x03D5(0x000B)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"BFGNetworkPathAgent_NavModeNetworkPathScriptedPath">();
	}
	static class UBFGNetworkPathAgent_NavModeNetworkPathScriptedPath* GetDefaultObj()
	{
		return GetDefaultObjImpl<UBFGNetworkPathAgent_NavModeNetworkPathScriptedPath>();
	}
};
static_assert(alignof(UBFGNetworkPathAgent_NavModeNetworkPathScriptedPath) == 0x000010, "Wrong alignment on UBFGNetworkPathAgent_NavModeNetworkPathScriptedPath");
static_assert(sizeof(UBFGNetworkPathAgent_NavModeNetworkPathScriptedPath) == 0x0003E0, "Wrong size on UBFGNetworkPathAgent_NavModeNetworkPathScriptedPath");
static_assert(offsetof(UBFGNetworkPathAgent_NavModeNetworkPathScriptedPath, M_pMissionPath) == 0x0003B0, "Member 'UBFGNetworkPathAgent_NavModeNetworkPathScriptedPath::M_pMissionPath' has a wrong offset!");
static_assert(offsetof(UBFGNetworkPathAgent_NavModeNetworkPathScriptedPath, M_pScriptedPath) == 0x0003B8, "Member 'UBFGNetworkPathAgent_NavModeNetworkPathScriptedPath::M_pScriptedPath' has a wrong offset!");
static_assert(offsetof(UBFGNetworkPathAgent_NavModeNetworkPathScriptedPath, M_pTestScriptedPath) == 0x0003C0, "Member 'UBFGNetworkPathAgent_NavModeNetworkPathScriptedPath::M_pTestScriptedPath' has a wrong offset!");
static_assert(offsetof(UBFGNetworkPathAgent_NavModeNetworkPathScriptedPath, M_bStopStarted) == 0x0003C8, "Member 'UBFGNetworkPathAgent_NavModeNetworkPathScriptedPath::M_bStopStarted' has a wrong offset!");
static_assert(offsetof(UBFGNetworkPathAgent_NavModeNetworkPathScriptedPath, M_fCheckWaypointTimer) == 0x0003CC, "Member 'UBFGNetworkPathAgent_NavModeNetworkPathScriptedPath::M_fCheckWaypointTimer' has a wrong offset!");
static_assert(offsetof(UBFGNetworkPathAgent_NavModeNetworkPathScriptedPath, M_iLastKnownWaypoint) == 0x0003D0, "Member 'UBFGNetworkPathAgent_NavModeNetworkPathScriptedPath::M_iLastKnownWaypoint' has a wrong offset!");
static_assert(offsetof(UBFGNetworkPathAgent_NavModeNetworkPathScriptedPath, M_bSwitchToFreeNavAtEnd) == 0x0003D4, "Member 'UBFGNetworkPathAgent_NavModeNetworkPathScriptedPath::M_bSwitchToFreeNavAtEnd' has a wrong offset!");

// Class BFGCore.BFGSensor_VehicleDriverCheck
// 0x0000 (0x0040 - 0x0040)
class UBFGSensor_VehicleDriverCheck final : public UBFGSensor
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"BFGSensor_VehicleDriverCheck">();
	}
	static class UBFGSensor_VehicleDriverCheck* GetDefaultObj()
	{
		return GetDefaultObjImpl<UBFGSensor_VehicleDriverCheck>();
	}
};
static_assert(alignof(UBFGSensor_VehicleDriverCheck) == 0x000008, "Wrong alignment on UBFGSensor_VehicleDriverCheck");
static_assert(sizeof(UBFGSensor_VehicleDriverCheck) == 0x000040, "Wrong size on UBFGSensor_VehicleDriverCheck");

// Class BFGCore.BFGVariableAction_ScriptedSequence_Running
// 0x0000 (0x00F0 - 0x00F0)
class UBFGVariableAction_ScriptedSequence_Running final : public UBFGVariableAction
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"BFGVariableAction_ScriptedSequence_Running">();
	}
	static class UBFGVariableAction_ScriptedSequence_Running* GetDefaultObj()
	{
		return GetDefaultObjImpl<UBFGVariableAction_ScriptedSequence_Running>();
	}
};
static_assert(alignof(UBFGVariableAction_ScriptedSequence_Running) == 0x000008, "Wrong alignment on UBFGVariableAction_ScriptedSequence_Running");
static_assert(sizeof(UBFGVariableAction_ScriptedSequence_Running) == 0x0000F0, "Wrong size on UBFGVariableAction_ScriptedSequence_Running");

// Class BFGCore.BFGNetworkPathAgent_NavModeStationary
// 0x0038 (0x0078 - 0x0040)
class UBFGNetworkPathAgent_NavModeStationary final : public UBFGNetworkPathAgent_NavModeBase
{
public:
	struct FVector                                M_vNavTargetLocation;                              // 0x0040(0x000C)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_4C[0x4];                                       // 0x004C(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class UBFGNetworkPath*                        M_pStandByPath;                                    // 0x0050(0x0008)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UBFGNetworkPathIntersection*            M_pStandByIntersection;                            // 0x0058(0x0008)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          M_bRegisterAsStandBy;                              // 0x0060(0x0001)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_61[0x3];                                       // 0x0061(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         M_fUpdateCooldDownTimer;                           // 0x0064(0x0004)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	struct FVector                                M_vLastStandByLocation;                            // 0x0068(0x000C)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_74[0x4];                                       // 0x0074(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"BFGNetworkPathAgent_NavModeStationary">();
	}
	static class UBFGNetworkPathAgent_NavModeStationary* GetDefaultObj()
	{
		return GetDefaultObjImpl<UBFGNetworkPathAgent_NavModeStationary>();
	}
};
static_assert(alignof(UBFGNetworkPathAgent_NavModeStationary) == 0x000008, "Wrong alignment on UBFGNetworkPathAgent_NavModeStationary");
static_assert(sizeof(UBFGNetworkPathAgent_NavModeStationary) == 0x000078, "Wrong size on UBFGNetworkPathAgent_NavModeStationary");
static_assert(offsetof(UBFGNetworkPathAgent_NavModeStationary, M_vNavTargetLocation) == 0x000040, "Member 'UBFGNetworkPathAgent_NavModeStationary::M_vNavTargetLocation' has a wrong offset!");
static_assert(offsetof(UBFGNetworkPathAgent_NavModeStationary, M_pStandByPath) == 0x000050, "Member 'UBFGNetworkPathAgent_NavModeStationary::M_pStandByPath' has a wrong offset!");
static_assert(offsetof(UBFGNetworkPathAgent_NavModeStationary, M_pStandByIntersection) == 0x000058, "Member 'UBFGNetworkPathAgent_NavModeStationary::M_pStandByIntersection' has a wrong offset!");
static_assert(offsetof(UBFGNetworkPathAgent_NavModeStationary, M_bRegisterAsStandBy) == 0x000060, "Member 'UBFGNetworkPathAgent_NavModeStationary::M_bRegisterAsStandBy' has a wrong offset!");
static_assert(offsetof(UBFGNetworkPathAgent_NavModeStationary, M_fUpdateCooldDownTimer) == 0x000064, "Member 'UBFGNetworkPathAgent_NavModeStationary::M_fUpdateCooldDownTimer' has a wrong offset!");
static_assert(offsetof(UBFGNetworkPathAgent_NavModeStationary, M_vLastStandByLocation) == 0x000068, "Member 'UBFGNetworkPathAgent_NavModeStationary::M_vLastStandByLocation' has a wrong offset!");

// Class BFGCore.BFGNetworkPathAgent_VehicleTank
// 0x0000 (0x05A8 - 0x05A8)
class UBFGNetworkPathAgent_VehicleTank final : public UBFGNetworkPathAgent_Vehicle
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"BFGNetworkPathAgent_VehicleTank">();
	}
	static class UBFGNetworkPathAgent_VehicleTank* GetDefaultObj()
	{
		return GetDefaultObjImpl<UBFGNetworkPathAgent_VehicleTank>();
	}
};
static_assert(alignof(UBFGNetworkPathAgent_VehicleTank) == 0x000008, "Wrong alignment on UBFGNetworkPathAgent_VehicleTank");
static_assert(sizeof(UBFGNetworkPathAgent_VehicleTank) == 0x0005A8, "Wrong size on UBFGNetworkPathAgent_VehicleTank");

// Class BFGCore.BFGSequencePlayer
// 0x00A8 (0x00D0 - 0x0028)
class UBFGSequencePlayer final : public UObject
{
public:
	UMulticastDelegateProperty_                   M_onReset;                                         // 0x0028(0x0018)(ZeroConstructor, InstancedReference, NativeAccessSpecifierPublic)
	class UBFGSequencePlaybackManager*            M_pManager;                                        // 0x0040(0x0008)(ExportObject, ZeroConstructor, Transient, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class ALevelSequenceActor*                    M_pSequence;                                       // 0x0048(0x0008)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_50[0x78];                                      // 0x0050(0x0078)(Fixing Size After Last Property [ Dumper-7 ])
	class UBFGGameFlowState_Cutscene*             M_pCutsceneState;                                  // 0x00C8(0x0008)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)

public:
	void Sequence_PlaybackPaused();
	void Sequence_PlaybackStopped();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"BFGSequencePlayer">();
	}
	static class UBFGSequencePlayer* GetDefaultObj()
	{
		return GetDefaultObjImpl<UBFGSequencePlayer>();
	}
};
static_assert(alignof(UBFGSequencePlayer) == 0x000008, "Wrong alignment on UBFGSequencePlayer");
static_assert(sizeof(UBFGSequencePlayer) == 0x0000D0, "Wrong size on UBFGSequencePlayer");
static_assert(offsetof(UBFGSequencePlayer, M_onReset) == 0x000028, "Member 'UBFGSequencePlayer::M_onReset' has a wrong offset!");
static_assert(offsetof(UBFGSequencePlayer, M_pManager) == 0x000040, "Member 'UBFGSequencePlayer::M_pManager' has a wrong offset!");
static_assert(offsetof(UBFGSequencePlayer, M_pSequence) == 0x000048, "Member 'UBFGSequencePlayer::M_pSequence' has a wrong offset!");
static_assert(offsetof(UBFGSequencePlayer, M_pCutsceneState) == 0x0000C8, "Member 'UBFGSequencePlayer::M_pCutsceneState' has a wrong offset!");

// Class BFGCore.BFGVariableAction_ScriptedSequence_NotYetStarted
// 0x0000 (0x00F0 - 0x00F0)
class UBFGVariableAction_ScriptedSequence_NotYetStarted final : public UBFGVariableAction
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"BFGVariableAction_ScriptedSequence_NotYetStarted">();
	}
	static class UBFGVariableAction_ScriptedSequence_NotYetStarted* GetDefaultObj()
	{
		return GetDefaultObjImpl<UBFGVariableAction_ScriptedSequence_NotYetStarted>();
	}
};
static_assert(alignof(UBFGVariableAction_ScriptedSequence_NotYetStarted) == 0x000008, "Wrong alignment on UBFGVariableAction_ScriptedSequence_NotYetStarted");
static_assert(sizeof(UBFGVariableAction_ScriptedSequence_NotYetStarted) == 0x0000F0, "Wrong size on UBFGVariableAction_ScriptedSequence_NotYetStarted");

// Class BFGCore.BFGNetworkPathAgentComponent
// 0x00F8 (0x0220 - 0x0128)
class UBFGNetworkPathAgentComponent final : public UActorComponent
{
public:
	UMulticastDelegateProperty_                   M_onAgentChanged;                                  // 0x0128(0x0018)(ZeroConstructor, InstancedReference, NativeAccessSpecifierPublic)
	TSubclassOf<class UBFGNetworkPathAgent>       AgentType;                                         // 0x0140(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	struct FBFGNetworkPathAgentLODInfo            M_lodInfo;                                         // 0x0148(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, DisableEditOnInstance, Protected, NativeAccessSpecifierProtected)
	struct FBFGAgentAIData                        M_initialAIData;                                   // 0x0158(0x00B0)(Edit, BlueprintVisible, ContainsInstancedReference, Protected, NativeAccessSpecifierProtected)
	bool                                          M_bLODEnabled;                                     // 0x0208(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          M_bResetLODEnabledContextWhenDead;                 // 0x0209(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          M_bDespawnOnDeath;                                 // 0x020A(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          M_bStayAttachedToLevel;                            // 0x020B(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          M_bIsDynamicObstacle;                              // 0x020C(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          M_bEnableVirtualCrowdAnimations;                   // 0x020D(0x0001)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_20E[0x2];                                      // 0x020E(0x0002)(Fixing Size After Last Property [ Dumper-7 ])
	class UBFGNetworkPathAgent*                   M_pAgent;                                          // 0x0210(0x0008)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	int32                                         M_iDebugComponentID;                               // 0x0218(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, NonPIEDuplicateTransient, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_21C[0x4];                                      // 0x021C(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void SetLODEnabled(bool _bEnabled);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"BFGNetworkPathAgentComponent">();
	}
	static class UBFGNetworkPathAgentComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UBFGNetworkPathAgentComponent>();
	}
};
static_assert(alignof(UBFGNetworkPathAgentComponent) == 0x000008, "Wrong alignment on UBFGNetworkPathAgentComponent");
static_assert(sizeof(UBFGNetworkPathAgentComponent) == 0x000220, "Wrong size on UBFGNetworkPathAgentComponent");
static_assert(offsetof(UBFGNetworkPathAgentComponent, M_onAgentChanged) == 0x000128, "Member 'UBFGNetworkPathAgentComponent::M_onAgentChanged' has a wrong offset!");
static_assert(offsetof(UBFGNetworkPathAgentComponent, AgentType) == 0x000140, "Member 'UBFGNetworkPathAgentComponent::AgentType' has a wrong offset!");
static_assert(offsetof(UBFGNetworkPathAgentComponent, M_lodInfo) == 0x000148, "Member 'UBFGNetworkPathAgentComponent::M_lodInfo' has a wrong offset!");
static_assert(offsetof(UBFGNetworkPathAgentComponent, M_initialAIData) == 0x000158, "Member 'UBFGNetworkPathAgentComponent::M_initialAIData' has a wrong offset!");
static_assert(offsetof(UBFGNetworkPathAgentComponent, M_bLODEnabled) == 0x000208, "Member 'UBFGNetworkPathAgentComponent::M_bLODEnabled' has a wrong offset!");
static_assert(offsetof(UBFGNetworkPathAgentComponent, M_bResetLODEnabledContextWhenDead) == 0x000209, "Member 'UBFGNetworkPathAgentComponent::M_bResetLODEnabledContextWhenDead' has a wrong offset!");
static_assert(offsetof(UBFGNetworkPathAgentComponent, M_bDespawnOnDeath) == 0x00020A, "Member 'UBFGNetworkPathAgentComponent::M_bDespawnOnDeath' has a wrong offset!");
static_assert(offsetof(UBFGNetworkPathAgentComponent, M_bStayAttachedToLevel) == 0x00020B, "Member 'UBFGNetworkPathAgentComponent::M_bStayAttachedToLevel' has a wrong offset!");
static_assert(offsetof(UBFGNetworkPathAgentComponent, M_bIsDynamicObstacle) == 0x00020C, "Member 'UBFGNetworkPathAgentComponent::M_bIsDynamicObstacle' has a wrong offset!");
static_assert(offsetof(UBFGNetworkPathAgentComponent, M_bEnableVirtualCrowdAnimations) == 0x00020D, "Member 'UBFGNetworkPathAgentComponent::M_bEnableVirtualCrowdAnimations' has a wrong offset!");
static_assert(offsetof(UBFGNetworkPathAgentComponent, M_pAgent) == 0x000210, "Member 'UBFGNetworkPathAgentComponent::M_pAgent' has a wrong offset!");
static_assert(offsetof(UBFGNetworkPathAgentComponent, M_iDebugComponentID) == 0x000218, "Member 'UBFGNetworkPathAgentComponent::M_iDebugComponentID' has a wrong offset!");

// Class BFGCore.BFGNetworkPathAgentRadarInfo
// 0x0020 (0x0048 - 0x0028)
class UBFGNetworkPathAgentRadarInfo final : public UObject
{
public:
	uint8                                         Pad_28[0x8];                                       // 0x0028(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	class UBFGNetworkPathAgent*                   M_pAgent;                                          // 0x0030(0x0008)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UBFGNetworkPathAgent_AttachedEntity*    M_pAttachedEntity;                                 // 0x0038(0x0008)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UBFGRadarManager*                       M_pRadarManager;                                   // 0x0040(0x0008)(ExportObject, ZeroConstructor, Transient, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)

public:
	void OnAttachedEntityDied(class UBFGNetworkPathAgent* _pAgent, class AActor* _pActor, bool _bIsAttached);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"BFGNetworkPathAgentRadarInfo">();
	}
	static class UBFGNetworkPathAgentRadarInfo* GetDefaultObj()
	{
		return GetDefaultObjImpl<UBFGNetworkPathAgentRadarInfo>();
	}
};
static_assert(alignof(UBFGNetworkPathAgentRadarInfo) == 0x000008, "Wrong alignment on UBFGNetworkPathAgentRadarInfo");
static_assert(sizeof(UBFGNetworkPathAgentRadarInfo) == 0x000048, "Wrong size on UBFGNetworkPathAgentRadarInfo");
static_assert(offsetof(UBFGNetworkPathAgentRadarInfo, M_pAgent) == 0x000030, "Member 'UBFGNetworkPathAgentRadarInfo::M_pAgent' has a wrong offset!");
static_assert(offsetof(UBFGNetworkPathAgentRadarInfo, M_pAttachedEntity) == 0x000038, "Member 'UBFGNetworkPathAgentRadarInfo::M_pAttachedEntity' has a wrong offset!");
static_assert(offsetof(UBFGNetworkPathAgentRadarInfo, M_pRadarManager) == 0x000040, "Member 'UBFGNetworkPathAgentRadarInfo::M_pRadarManager' has a wrong offset!");

// Class BFGCore.BFGNetworkPathAsset
// 0x0038 (0x0068 - 0x0030)
class UBFGNetworkPathAsset final : public UDataAsset
{
public:
	TArray<TSubclassOf<class AActor>>             ActorsToSpawn;                                     // 0x0030(0x0010)(Edit, BlueprintVisible, ZeroConstructor, UObjectWrapper, NativeAccessSpecifierPublic)
	TSoftObjectPtr<class UBFGSpawningComposition> SpawningComposition;                               // 0x0040(0x0028)(Edit, BlueprintVisible, BlueprintReadOnly, DisableEditOnInstance, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"BFGNetworkPathAsset">();
	}
	static class UBFGNetworkPathAsset* GetDefaultObj()
	{
		return GetDefaultObjImpl<UBFGNetworkPathAsset>();
	}
};
static_assert(alignof(UBFGNetworkPathAsset) == 0x000008, "Wrong alignment on UBFGNetworkPathAsset");
static_assert(sizeof(UBFGNetworkPathAsset) == 0x000068, "Wrong size on UBFGNetworkPathAsset");
static_assert(offsetof(UBFGNetworkPathAsset, ActorsToSpawn) == 0x000030, "Member 'UBFGNetworkPathAsset::ActorsToSpawn' has a wrong offset!");
static_assert(offsetof(UBFGNetworkPathAsset, SpawningComposition) == 0x000040, "Member 'UBFGNetworkPathAsset::SpawningComposition' has a wrong offset!");

// Class BFGCore.BFGNetworkPathComponent
// 0x0160 (0x08B0 - 0x0750)
class UBFGNetworkPathComponent final : public USplineComponent
{
public:
	TWeakObjectPtr<class UBFGNetworkPath>         M_pNetworkPathObject;                              // 0x0750(0x0008)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	struct FBFGNetworkPathInfo                    M_networkPathInfo;                                 // 0x0758(0x0120)(Edit, BlueprintVisible, Protected, NativeAccessSpecifierProtected)
	struct FBFGPatrolPathInfo                     M_patrolPathInfo;                                  // 0x0878(0x0018)(Edit, BlueprintVisible, Protected, NativeAccessSpecifierProtected)
	struct FBFGHeightAlongPathData                M_heightData;                                      // 0x0890(0x0020)(Edit, BlueprintVisible, BlueprintReadOnly, EditConst, Protected, NativeAccessSpecifierProtected)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"BFGNetworkPathComponent">();
	}
	static class UBFGNetworkPathComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UBFGNetworkPathComponent>();
	}
};
static_assert(alignof(UBFGNetworkPathComponent) == 0x000008, "Wrong alignment on UBFGNetworkPathComponent");
static_assert(sizeof(UBFGNetworkPathComponent) == 0x0008B0, "Wrong size on UBFGNetworkPathComponent");
static_assert(offsetof(UBFGNetworkPathComponent, M_pNetworkPathObject) == 0x000750, "Member 'UBFGNetworkPathComponent::M_pNetworkPathObject' has a wrong offset!");
static_assert(offsetof(UBFGNetworkPathComponent, M_networkPathInfo) == 0x000758, "Member 'UBFGNetworkPathComponent::M_networkPathInfo' has a wrong offset!");
static_assert(offsetof(UBFGNetworkPathComponent, M_patrolPathInfo) == 0x000878, "Member 'UBFGNetworkPathComponent::M_patrolPathInfo' has a wrong offset!");
static_assert(offsetof(UBFGNetworkPathComponent, M_heightData) == 0x000890, "Member 'UBFGNetworkPathComponent::M_heightData' has a wrong offset!");

// Class BFGCore.BFGSkeletalMeshComponentBudgeted
// 0x0018 (0x0D60 - 0x0D48)
class UBFGSkeletalMeshComponentBudgeted final : public USkeletalMeshComponentBudgeted
{
public:
	TArray<class FName>                           M_aTranslationHackBoneNames;                       // 0x0D48(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, NativeAccessSpecifierPublic)
	uint8                                         Pad_D58[0x8];                                      // 0x0D58(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"BFGSkeletalMeshComponentBudgeted">();
	}
	static class UBFGSkeletalMeshComponentBudgeted* GetDefaultObj()
	{
		return GetDefaultObjImpl<UBFGSkeletalMeshComponentBudgeted>();
	}
};
static_assert(alignof(UBFGSkeletalMeshComponentBudgeted) == 0x000008, "Wrong alignment on UBFGSkeletalMeshComponentBudgeted");
static_assert(sizeof(UBFGSkeletalMeshComponentBudgeted) == 0x000D60, "Wrong size on UBFGSkeletalMeshComponentBudgeted");
static_assert(offsetof(UBFGSkeletalMeshComponentBudgeted, M_aTranslationHackBoneNames) == 0x000D48, "Member 'UBFGSkeletalMeshComponentBudgeted::M_aTranslationHackBoneNames' has a wrong offset!");

// Class BFGCore.BFGVariableAction_Timer_Stopped
// 0x0000 (0x00F0 - 0x00F0)
class UBFGVariableAction_Timer_Stopped final : public UBFGVariableAction
{
public:
	static const class FName GetActionName_TimerStop();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"BFGVariableAction_Timer_Stopped">();
	}
	static class UBFGVariableAction_Timer_Stopped* GetDefaultObj()
	{
		return GetDefaultObjImpl<UBFGVariableAction_Timer_Stopped>();
	}
};
static_assert(alignof(UBFGVariableAction_Timer_Stopped) == 0x000008, "Wrong alignment on UBFGVariableAction_Timer_Stopped");
static_assert(sizeof(UBFGVariableAction_Timer_Stopped) == 0x0000F0, "Wrong size on UBFGVariableAction_Timer_Stopped");

// Class BFGCore.BFGNetworkPathIntersection
// 0x00F0 (0x0118 - 0x0028)
class UBFGNetworkPathIntersection final : public UObject
{
public:
	int32                                         M_iNextTicket;                                     // 0x0028(0x0004)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_2C[0x4];                                       // 0x002C(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class UBFGTrafficCrowdManager*                M_pManager;                                        // 0x0030(0x0008)(ExportObject, ZeroConstructor, Transient, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TArray<class UBFGNetworkPathAgent*>           M_apStandbyAgents;                                 // 0x0038(0x0010)(ZeroConstructor, Transient, Protected, NativeAccessSpecifierProtected)
	TArray<struct FBFGIntersectionPathExtremity>  M_apPaths;                                         // 0x0048(0x0010)(ZeroConstructor, Transient, Protected, NativeAccessSpecifierProtected)
	TMap<int32, int32>                            M_aOrdinalIndexToPathExtremityIndex;               // 0x0058(0x0050)(ZeroConstructor, Transient, Protected, NativeAccessSpecifierProtected)
	TMap<int32, int32>                            M_aTicketToPathExtremity;                          // 0x00A8(0x0050)(ZeroConstructor, Transient, Protected, NativeAccessSpecifierProtected)
	float                                         M_fUpdateTimer;                                    // 0x00F8(0x0004)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         M_fUpdateTimerMax;                                 // 0x00FC(0x0004)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	int32                                         M_iPriorityPath;                                   // 0x0100(0x0004)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          M_bPriorityPathHasPriorityVehicle;                 // 0x0104(0x0001)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          M_bClosed;                                         // 0x0105(0x0001)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_106[0x2];                                      // 0x0106(0x0002)(Fixing Size After Last Property [ Dumper-7 ])
	struct FVector                                M_vGravityCenter;                                  // 0x0108(0x000C)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_114[0x4];                                      // 0x0114(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"BFGNetworkPathIntersection">();
	}
	static class UBFGNetworkPathIntersection* GetDefaultObj()
	{
		return GetDefaultObjImpl<UBFGNetworkPathIntersection>();
	}
};
static_assert(alignof(UBFGNetworkPathIntersection) == 0x000008, "Wrong alignment on UBFGNetworkPathIntersection");
static_assert(sizeof(UBFGNetworkPathIntersection) == 0x000118, "Wrong size on UBFGNetworkPathIntersection");
static_assert(offsetof(UBFGNetworkPathIntersection, M_iNextTicket) == 0x000028, "Member 'UBFGNetworkPathIntersection::M_iNextTicket' has a wrong offset!");
static_assert(offsetof(UBFGNetworkPathIntersection, M_pManager) == 0x000030, "Member 'UBFGNetworkPathIntersection::M_pManager' has a wrong offset!");
static_assert(offsetof(UBFGNetworkPathIntersection, M_apStandbyAgents) == 0x000038, "Member 'UBFGNetworkPathIntersection::M_apStandbyAgents' has a wrong offset!");
static_assert(offsetof(UBFGNetworkPathIntersection, M_apPaths) == 0x000048, "Member 'UBFGNetworkPathIntersection::M_apPaths' has a wrong offset!");
static_assert(offsetof(UBFGNetworkPathIntersection, M_aOrdinalIndexToPathExtremityIndex) == 0x000058, "Member 'UBFGNetworkPathIntersection::M_aOrdinalIndexToPathExtremityIndex' has a wrong offset!");
static_assert(offsetof(UBFGNetworkPathIntersection, M_aTicketToPathExtremity) == 0x0000A8, "Member 'UBFGNetworkPathIntersection::M_aTicketToPathExtremity' has a wrong offset!");
static_assert(offsetof(UBFGNetworkPathIntersection, M_fUpdateTimer) == 0x0000F8, "Member 'UBFGNetworkPathIntersection::M_fUpdateTimer' has a wrong offset!");
static_assert(offsetof(UBFGNetworkPathIntersection, M_fUpdateTimerMax) == 0x0000FC, "Member 'UBFGNetworkPathIntersection::M_fUpdateTimerMax' has a wrong offset!");
static_assert(offsetof(UBFGNetworkPathIntersection, M_iPriorityPath) == 0x000100, "Member 'UBFGNetworkPathIntersection::M_iPriorityPath' has a wrong offset!");
static_assert(offsetof(UBFGNetworkPathIntersection, M_bPriorityPathHasPriorityVehicle) == 0x000104, "Member 'UBFGNetworkPathIntersection::M_bPriorityPathHasPriorityVehicle' has a wrong offset!");
static_assert(offsetof(UBFGNetworkPathIntersection, M_bClosed) == 0x000105, "Member 'UBFGNetworkPathIntersection::M_bClosed' has a wrong offset!");
static_assert(offsetof(UBFGNetworkPathIntersection, M_vGravityCenter) == 0x000108, "Member 'UBFGNetworkPathIntersection::M_vGravityCenter' has a wrong offset!");

// Class BFGCore.BFGNPCCharacter_Interactable
// 0x0000 (0x0B90 - 0x0B90)
class ABFGNPCCharacter_Interactable final : public ABFGNPCCharacterGameplay
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"BFGNPCCharacter_Interactable">();
	}
	static class ABFGNPCCharacter_Interactable* GetDefaultObj()
	{
		return GetDefaultObjImpl<ABFGNPCCharacter_Interactable>();
	}
};
static_assert(alignof(ABFGNPCCharacter_Interactable) == 0x000010, "Wrong alignment on ABFGNPCCharacter_Interactable");
static_assert(sizeof(ABFGNPCCharacter_Interactable) == 0x000B90, "Wrong size on ABFGNPCCharacter_Interactable");

// Class BFGCore.BFGSpawnPool
// 0x0158 (0x0530 - 0x03D8)
class ABFGSpawnPool : public AActor
{
public:
	bool                                          M_bDisableSpawnPool;                               // 0x03D8(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          M_bShowPoolContents;                               // 0x03D9(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_3DA[0x6];                                      // 0x03DA(0x0006)(Fixing Size After Last Property [ Dumper-7 ])
	TMap<TSubclassOf<class AActor>, int32>        M_mInitialSpawnMap;                                // 0x03E0(0x0050)(Edit, ZeroConstructor, NativeAccessSpecifierPrivate)
	TMap<TSubclassOf<class AActor>, struct FVector> M_aScaleTable;                                     // 0x0430(0x0050)(ZeroConstructor, Transient, NativeAccessSpecifierPrivate)
	TMap<class UClass*, struct FBFGActorArray>    M_mActorArrayMap;                                  // 0x0480(0x0050)(ZeroConstructor, NativeAccessSpecifierPrivate)
	TSet<class UClass*>                           M_BlackList;                                       // 0x04D0(0x0050)(Edit, ZeroConstructor, NativeAccessSpecifierPrivate)
	uint8                                         Pad_520[0x10];                                     // 0x0520(0x0010)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"BFGSpawnPool">();
	}
	static class ABFGSpawnPool* GetDefaultObj()
	{
		return GetDefaultObjImpl<ABFGSpawnPool>();
	}
};
static_assert(alignof(ABFGSpawnPool) == 0x000008, "Wrong alignment on ABFGSpawnPool");
static_assert(sizeof(ABFGSpawnPool) == 0x000530, "Wrong size on ABFGSpawnPool");
static_assert(offsetof(ABFGSpawnPool, M_bDisableSpawnPool) == 0x0003D8, "Member 'ABFGSpawnPool::M_bDisableSpawnPool' has a wrong offset!");
static_assert(offsetof(ABFGSpawnPool, M_bShowPoolContents) == 0x0003D9, "Member 'ABFGSpawnPool::M_bShowPoolContents' has a wrong offset!");
static_assert(offsetof(ABFGSpawnPool, M_mInitialSpawnMap) == 0x0003E0, "Member 'ABFGSpawnPool::M_mInitialSpawnMap' has a wrong offset!");
static_assert(offsetof(ABFGSpawnPool, M_aScaleTable) == 0x000430, "Member 'ABFGSpawnPool::M_aScaleTable' has a wrong offset!");
static_assert(offsetof(ABFGSpawnPool, M_mActorArrayMap) == 0x000480, "Member 'ABFGSpawnPool::M_mActorArrayMap' has a wrong offset!");
static_assert(offsetof(ABFGSpawnPool, M_BlackList) == 0x0004D0, "Member 'ABFGSpawnPool::M_BlackList' has a wrong offset!");

// Class BFGCore.BFGNPCCharacterAnimal
// 0x0000 (0x0B90 - 0x0B90)
class ABFGNPCCharacterAnimal : public ABFGNPCCharacterGameplay
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"BFGNPCCharacterAnimal">();
	}
	static class ABFGNPCCharacterAnimal* GetDefaultObj()
	{
		return GetDefaultObjImpl<ABFGNPCCharacterAnimal>();
	}
};
static_assert(alignof(ABFGNPCCharacterAnimal) == 0x000010, "Wrong alignment on ABFGNPCCharacterAnimal");
static_assert(sizeof(ABFGNPCCharacterAnimal) == 0x000B90, "Wrong size on ABFGNPCCharacterAnimal");

// Class BFGCore.BFGNPCCharacterBoss
// 0x0240 (0x0DD0 - 0x0B90)
class ABFGNPCCharacterBoss : public ABFGNPCCharacterGameplay
{
public:
	int32                                         M_iCurrentPhase;                                   // 0x0B88(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_B8C[0x4];                                      // 0x0B8C(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	TSubclassOf<class ABFGEffectActor>            M_pEffectActorClass;                               // 0x0B90(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TSubclassOf<class ABFGEffectActor>            M_pPhaseChangeEffect;                              // 0x0B98(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          M_bDisableStomp;                                   // 0x0BA0(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_BA1[0x7];                                      // 0x0BA1(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	UMulticastDelegateProperty_                   M_dOnPhaseChangeTriggeredEvent;                    // 0x0BA8(0x0018)(ZeroConstructor, InstancedReference, NativeAccessSpecifierPublic)
	UMulticastDelegateProperty_                   M_onPhaseChangedEvent;                             // 0x0BC0(0x0018)(ZeroConstructor, InstancedReference, NativeAccessSpecifierPublic)
	bool                                          M_bDebugPatternTestMode;                           // 0x0BD8(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_BD9[0x7];                                      // 0x0BD9(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	class UBehaviorTree*                          M_pPatternTestTree;                                // 0x0BE0(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TArray<class UDataTable*>                     M_aPatternTestBank;                                // 0x0BE8(0x0010)(Edit, BlueprintVisible, ZeroConstructor, NativeAccessSpecifierPublic)
	uint8                                         Pad_BF8[0x4];                                      // 0x0BF8(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	bool                                          M_bDebugDrawQuadrants;                             // 0x0BFC(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_BFD[0x3];                                      // 0x0BFD(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         M_fDebugQuadrantHeight;                            // 0x0C00(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         M_fDebugQuadrantRadius;                            // 0x0C04(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         M_fDebugQuadrantThickness;                         // 0x0C08(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_C0C[0x4];                                      // 0x0C0C(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	UMulticastDelegateProperty_                   OnMetaPatternStartedDelegate;                      // 0x0C10(0x0018)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	UMulticastDelegateProperty_                   OnActionCompleteDelegate;                          // 0x0C28(0x0018)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	UMulticastDelegateProperty_                   OnActionInterrupted;                               // 0x0C40(0x0018)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	uint8                                         Pad_C58[0x18];                                     // 0x0C58(0x0018)(Fixing Size After Last Property [ Dumper-7 ])
	class UBFGActorComponent_ReinforcementManager* M_pReinforcementManagerComponent;                  // 0x0C70(0x0008)(Edit, ExportObject, ZeroConstructor, EditConst, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          M_bEnableRelocationIfTooFar;                       // 0x0C78(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_C79[0x7];                                      // 0x0C79(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	class UBFGDataAsset_BossData*                 M_pBossDataAsset;                                  // 0x0C80(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UDataTable*                             M_pBossAnimDataTable;                              // 0x0C88(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	struct FVector                                M_vResetLocation;                                  // 0x0C90(0x000C)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_C9C[0x4];                                      // 0x0C9C(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	struct FBossData_AnimData                     M_oBossAnimData;                                   // 0x0CA0(0x00D8)(Protected, NativeAccessSpecifierProtected)
	struct FMetaPattern                           M_oCurrentMetaPattern;                             // 0x0D78(0x0028)(Transient, Protected, NativeAccessSpecifierProtected)
	int32                                         M_iStepIndex;                                      // 0x0DA0(0x0004)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          M_bHasStepListRepeated;                            // 0x0DA4(0x0001)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          M_bDebugSteps;                                     // 0x0DA5(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_DA6[0x22];                                     // 0x0DA6(0x0022)(Fixing Size After Last Property [ Dumper-7 ])
	class UBlackboardComponent*                   M_BlackBoardComponent;                             // 0x0DC8(0x0008)(ExportObject, ZeroConstructor, Transient, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)

public:
	void ActivatePickUpSpawner(int32 _iCurrentPhase);
	void BeginBossAction_CallReinforcements();
	void BeginStandingUp();
	void FinishedStandingUp();
	float GetCurrentStepDuration();
	class UBehaviorTree* GetCurrentSubtree();
	void GetKnockdownDirection(const struct FVector& _vImpactDirection);
	void OnCallReinforcements();
	void OnEnterWeakState();
	void OnExitWeakState();
	void OnHealthChanged(class AActor* _pOwner, class UBFGActorStat_Float* _pStat);
	void OnPatternComplete(class ABFGWeapon* _pWeapon);
	void OnPhaseChanged(int32 _iPhaseNumber);
	void OnRocketLaunched(EBFGRocketSocket _eRocketSocket);
	void OnStepAborted();
	void OnStepStarted();
	void OnSubtreeComplete();
	void PhaseTransitionTriggered(int32 _iCurrentPhaseNumber);
	void RetriggerChangePhase(int32 _Phase);
	void SetWeaponPattern(int32 WeaponIndex, int32 WeaponPatternIndex);
	void SpawnReinforcements();
	void StartMetaPattern();

	class UBFGDataAsset_BossPhase* GetBossPhaseAtIndex(int32 _iPhaseIndex) const;
	const TArray<class ABFGWeapon*> GetWeaponList() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"BFGNPCCharacterBoss">();
	}
	static class ABFGNPCCharacterBoss* GetDefaultObj()
	{
		return GetDefaultObjImpl<ABFGNPCCharacterBoss>();
	}
};
static_assert(alignof(ABFGNPCCharacterBoss) == 0x000010, "Wrong alignment on ABFGNPCCharacterBoss");
static_assert(sizeof(ABFGNPCCharacterBoss) == 0x000DD0, "Wrong size on ABFGNPCCharacterBoss");
static_assert(offsetof(ABFGNPCCharacterBoss, M_iCurrentPhase) == 0x000B88, "Member 'ABFGNPCCharacterBoss::M_iCurrentPhase' has a wrong offset!");
static_assert(offsetof(ABFGNPCCharacterBoss, M_pEffectActorClass) == 0x000B90, "Member 'ABFGNPCCharacterBoss::M_pEffectActorClass' has a wrong offset!");
static_assert(offsetof(ABFGNPCCharacterBoss, M_pPhaseChangeEffect) == 0x000B98, "Member 'ABFGNPCCharacterBoss::M_pPhaseChangeEffect' has a wrong offset!");
static_assert(offsetof(ABFGNPCCharacterBoss, M_bDisableStomp) == 0x000BA0, "Member 'ABFGNPCCharacterBoss::M_bDisableStomp' has a wrong offset!");
static_assert(offsetof(ABFGNPCCharacterBoss, M_dOnPhaseChangeTriggeredEvent) == 0x000BA8, "Member 'ABFGNPCCharacterBoss::M_dOnPhaseChangeTriggeredEvent' has a wrong offset!");
static_assert(offsetof(ABFGNPCCharacterBoss, M_onPhaseChangedEvent) == 0x000BC0, "Member 'ABFGNPCCharacterBoss::M_onPhaseChangedEvent' has a wrong offset!");
static_assert(offsetof(ABFGNPCCharacterBoss, M_bDebugPatternTestMode) == 0x000BD8, "Member 'ABFGNPCCharacterBoss::M_bDebugPatternTestMode' has a wrong offset!");
static_assert(offsetof(ABFGNPCCharacterBoss, M_pPatternTestTree) == 0x000BE0, "Member 'ABFGNPCCharacterBoss::M_pPatternTestTree' has a wrong offset!");
static_assert(offsetof(ABFGNPCCharacterBoss, M_aPatternTestBank) == 0x000BE8, "Member 'ABFGNPCCharacterBoss::M_aPatternTestBank' has a wrong offset!");
static_assert(offsetof(ABFGNPCCharacterBoss, M_bDebugDrawQuadrants) == 0x000BFC, "Member 'ABFGNPCCharacterBoss::M_bDebugDrawQuadrants' has a wrong offset!");
static_assert(offsetof(ABFGNPCCharacterBoss, M_fDebugQuadrantHeight) == 0x000C00, "Member 'ABFGNPCCharacterBoss::M_fDebugQuadrantHeight' has a wrong offset!");
static_assert(offsetof(ABFGNPCCharacterBoss, M_fDebugQuadrantRadius) == 0x000C04, "Member 'ABFGNPCCharacterBoss::M_fDebugQuadrantRadius' has a wrong offset!");
static_assert(offsetof(ABFGNPCCharacterBoss, M_fDebugQuadrantThickness) == 0x000C08, "Member 'ABFGNPCCharacterBoss::M_fDebugQuadrantThickness' has a wrong offset!");
static_assert(offsetof(ABFGNPCCharacterBoss, OnMetaPatternStartedDelegate) == 0x000C10, "Member 'ABFGNPCCharacterBoss::OnMetaPatternStartedDelegate' has a wrong offset!");
static_assert(offsetof(ABFGNPCCharacterBoss, OnActionCompleteDelegate) == 0x000C28, "Member 'ABFGNPCCharacterBoss::OnActionCompleteDelegate' has a wrong offset!");
static_assert(offsetof(ABFGNPCCharacterBoss, OnActionInterrupted) == 0x000C40, "Member 'ABFGNPCCharacterBoss::OnActionInterrupted' has a wrong offset!");
static_assert(offsetof(ABFGNPCCharacterBoss, M_pReinforcementManagerComponent) == 0x000C70, "Member 'ABFGNPCCharacterBoss::M_pReinforcementManagerComponent' has a wrong offset!");
static_assert(offsetof(ABFGNPCCharacterBoss, M_bEnableRelocationIfTooFar) == 0x000C78, "Member 'ABFGNPCCharacterBoss::M_bEnableRelocationIfTooFar' has a wrong offset!");
static_assert(offsetof(ABFGNPCCharacterBoss, M_pBossDataAsset) == 0x000C80, "Member 'ABFGNPCCharacterBoss::M_pBossDataAsset' has a wrong offset!");
static_assert(offsetof(ABFGNPCCharacterBoss, M_pBossAnimDataTable) == 0x000C88, "Member 'ABFGNPCCharacterBoss::M_pBossAnimDataTable' has a wrong offset!");
static_assert(offsetof(ABFGNPCCharacterBoss, M_vResetLocation) == 0x000C90, "Member 'ABFGNPCCharacterBoss::M_vResetLocation' has a wrong offset!");
static_assert(offsetof(ABFGNPCCharacterBoss, M_oBossAnimData) == 0x000CA0, "Member 'ABFGNPCCharacterBoss::M_oBossAnimData' has a wrong offset!");
static_assert(offsetof(ABFGNPCCharacterBoss, M_oCurrentMetaPattern) == 0x000D78, "Member 'ABFGNPCCharacterBoss::M_oCurrentMetaPattern' has a wrong offset!");
static_assert(offsetof(ABFGNPCCharacterBoss, M_iStepIndex) == 0x000DA0, "Member 'ABFGNPCCharacterBoss::M_iStepIndex' has a wrong offset!");
static_assert(offsetof(ABFGNPCCharacterBoss, M_bHasStepListRepeated) == 0x000DA4, "Member 'ABFGNPCCharacterBoss::M_bHasStepListRepeated' has a wrong offset!");
static_assert(offsetof(ABFGNPCCharacterBoss, M_bDebugSteps) == 0x000DA5, "Member 'ABFGNPCCharacterBoss::M_bDebugSteps' has a wrong offset!");
static_assert(offsetof(ABFGNPCCharacterBoss, M_BlackBoardComponent) == 0x000DC8, "Member 'ABFGNPCCharacterBoss::M_BlackBoardComponent' has a wrong offset!");

// Class BFGCore.BFGNPCCharacterBoss_Armquist
// 0x0120 (0x0EF0 - 0x0DD0)
class ABFGNPCCharacterBoss_Armquist final : public ABFGNPCCharacterBoss
{
public:
	struct FGameplayTag                           M_oAirMineTag;                                     // 0x0DD0(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, DisableEditOnInstance, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FGameplayTag                           M_oAirSupporTag;                                   // 0x0DD8(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, DisableEditOnInstance, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FGameplayTag                           M_oNavySupporTag;                                  // 0x0DE0(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, DisableEditOnInstance, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TArray<class AActor*>                         M_apIgnoredActorsByCharge;                         // 0x0DE8(0x0010)(Edit, ZeroConstructor, DisableEditOnTemplate, NativeAccessSpecifierPublic)
	uint8                                         Pad_DF8[0x18];                                     // 0x0DF8(0x0018)(Fixing Size After Last Property [ Dumper-7 ])
	class UBFGActorComponent_OverheatManager*     M_pOverheatManager;                                // 0x0E10(0x0008)(Edit, ExportObject, ZeroConstructor, EditConst, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class ABFGWeapon_BossBase*                    M_pMachineGunLeft;                                 // 0x0E18(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class ABFGWeapon_BossBase*                    M_pMachineGunRight;                                // 0x0E20(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class ABFGWeapon_BossBase*                    M_pRocketsLeft;                                    // 0x0E28(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class ABFGWeapon_BossBase*                    M_pRocketsRight;                                   // 0x0E30(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UBFGDataAsset_BossData_Armquist*        M_pArmquistDataAsset;                              // 0x0E38(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TSubclassOf<class ABFGEffectActor>            M_pActionCharge_ParticleTrailClass;                // 0x0E40(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class ABFGEffectActor*                        M_pActionCharge_ParticleTrail;                     // 0x0E48(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	struct FTransform                             M_vEffectOffsetTransform;                          // 0x0E50(0x0030)(Edit, IsPlainOldData, NoDestructor, Protected, NativeAccessSpecifierProtected)
	float                                         M_fStompCoolDownTimer;                             // 0x0E80(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_E84[0x4];                                      // 0x0E84(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class UAudioComponent*                        M_pAudioComponent_ReinforcemnetVO;                 // 0x0E88(0x0008)(Edit, BlueprintVisible, ExportObject, ZeroConstructor, EditConst, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UAudioComponent*                        M_pAudioComponent_SupportVO;                       // 0x0E90(0x0008)(Edit, BlueprintVisible, ExportObject, ZeroConstructor, EditConst, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class ABFGBossSupportActor*                   M_pBossSupport_Navy;                               // 0x0E98(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class ABFGBossSupportActor*                   M_pBossSupport_Airforce;                           // 0x0EA0(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          M_bShowAnimData;                                   // 0x0EA8(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          M_bWaitForCatchUpRotation;                         // 0x0EA9(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          M_bAllowCatchUpRotationDuringMetaPatterns;         // 0x0EAA(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_EAB[0xD];                                      // 0x0EAB(0x000D)(Fixing Size After Last Property [ Dumper-7 ])
	class USplineComponent*                       M_pLeapSplineComponent;                            // 0x0EB8(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UTimelineComponent*                     M_tLeapTimelineComponent;                          // 0x0EC0(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_EC8[0x28];                                     // 0x0EC8(0x0028)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void BeginBossAction_Charge();
	void BeginBossAction_Leap(const struct FVector& _vNextPhaseLocation);
	void BeginBossAction_Stomp(const struct FVector& _vStompLocation);
	void CallBossAction_Leap(const struct FVector& _vNextPhaseLocation);
	void EnableStomp();
	void EndBossAction_Charge();
	class FName GetRocketSocketName(EBFGRocketSocket _eRocketSocket);
	float GetSupportDuration_Airforce();
	float GetSupportDuration_Navy();
	bool IsAirforceSupportAvailable();
	bool IsNavySupportAvailable();
	void LeapTimeline_FinishedCallback();
	void LeapTimeline_SpeedInterpolation(float Val);
	void OnAirMineDestroyed(class AActor* _pActor);
	void OnBossAction_Charge_TelegraphComplete();
	void OnChargingBeginHit(class UPrimitiveComponent* HitComponent, class AActor* OtherActor, class UPrimitiveComponent* OtherComp, const struct FVector& NormalImpulse, const struct FHitResult& Hit);
	void OnChargingBeginOverlap(class UPrimitiveComponent* _pOverlappedComponent, class AActor* _pOtherActor, class UPrimitiveComponent* _pOtherComponent, int32 _iOtherBodyIndex, bool _bFromSweep, const struct FHitResult& _sweepResult);
	float RequestSupport();
	bool RequestSupport_Airforce();
	bool RequestSupport_Navy();
	void SetupLeapComponents();
	void SetupLeapSplinePoints(const struct FVector& _vNextPhaseLocation);
	void SpawnAirMines();
	void SpawnBossAOE(TSubclassOf<class ABFGAOE_Boss> _pAOEClass, bool _bUseWarningComponents, float _fTelegraphTime);
	bool TryRetractRocketLaunchers();
	struct FVector UpdateLeapStartingPosition();

	class UBFGActorComponent_OverheatManager* GetOverheatManager() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"BFGNPCCharacterBoss_Armquist">();
	}
	static class ABFGNPCCharacterBoss_Armquist* GetDefaultObj()
	{
		return GetDefaultObjImpl<ABFGNPCCharacterBoss_Armquist>();
	}
};
static_assert(alignof(ABFGNPCCharacterBoss_Armquist) == 0x000010, "Wrong alignment on ABFGNPCCharacterBoss_Armquist");
static_assert(sizeof(ABFGNPCCharacterBoss_Armquist) == 0x000EF0, "Wrong size on ABFGNPCCharacterBoss_Armquist");
static_assert(offsetof(ABFGNPCCharacterBoss_Armquist, M_oAirMineTag) == 0x000DD0, "Member 'ABFGNPCCharacterBoss_Armquist::M_oAirMineTag' has a wrong offset!");
static_assert(offsetof(ABFGNPCCharacterBoss_Armquist, M_oAirSupporTag) == 0x000DD8, "Member 'ABFGNPCCharacterBoss_Armquist::M_oAirSupporTag' has a wrong offset!");
static_assert(offsetof(ABFGNPCCharacterBoss_Armquist, M_oNavySupporTag) == 0x000DE0, "Member 'ABFGNPCCharacterBoss_Armquist::M_oNavySupporTag' has a wrong offset!");
static_assert(offsetof(ABFGNPCCharacterBoss_Armquist, M_apIgnoredActorsByCharge) == 0x000DE8, "Member 'ABFGNPCCharacterBoss_Armquist::M_apIgnoredActorsByCharge' has a wrong offset!");
static_assert(offsetof(ABFGNPCCharacterBoss_Armquist, M_pOverheatManager) == 0x000E10, "Member 'ABFGNPCCharacterBoss_Armquist::M_pOverheatManager' has a wrong offset!");
static_assert(offsetof(ABFGNPCCharacterBoss_Armquist, M_pMachineGunLeft) == 0x000E18, "Member 'ABFGNPCCharacterBoss_Armquist::M_pMachineGunLeft' has a wrong offset!");
static_assert(offsetof(ABFGNPCCharacterBoss_Armquist, M_pMachineGunRight) == 0x000E20, "Member 'ABFGNPCCharacterBoss_Armquist::M_pMachineGunRight' has a wrong offset!");
static_assert(offsetof(ABFGNPCCharacterBoss_Armquist, M_pRocketsLeft) == 0x000E28, "Member 'ABFGNPCCharacterBoss_Armquist::M_pRocketsLeft' has a wrong offset!");
static_assert(offsetof(ABFGNPCCharacterBoss_Armquist, M_pRocketsRight) == 0x000E30, "Member 'ABFGNPCCharacterBoss_Armquist::M_pRocketsRight' has a wrong offset!");
static_assert(offsetof(ABFGNPCCharacterBoss_Armquist, M_pArmquistDataAsset) == 0x000E38, "Member 'ABFGNPCCharacterBoss_Armquist::M_pArmquistDataAsset' has a wrong offset!");
static_assert(offsetof(ABFGNPCCharacterBoss_Armquist, M_pActionCharge_ParticleTrailClass) == 0x000E40, "Member 'ABFGNPCCharacterBoss_Armquist::M_pActionCharge_ParticleTrailClass' has a wrong offset!");
static_assert(offsetof(ABFGNPCCharacterBoss_Armquist, M_pActionCharge_ParticleTrail) == 0x000E48, "Member 'ABFGNPCCharacterBoss_Armquist::M_pActionCharge_ParticleTrail' has a wrong offset!");
static_assert(offsetof(ABFGNPCCharacterBoss_Armquist, M_vEffectOffsetTransform) == 0x000E50, "Member 'ABFGNPCCharacterBoss_Armquist::M_vEffectOffsetTransform' has a wrong offset!");
static_assert(offsetof(ABFGNPCCharacterBoss_Armquist, M_fStompCoolDownTimer) == 0x000E80, "Member 'ABFGNPCCharacterBoss_Armquist::M_fStompCoolDownTimer' has a wrong offset!");
static_assert(offsetof(ABFGNPCCharacterBoss_Armquist, M_pAudioComponent_ReinforcemnetVO) == 0x000E88, "Member 'ABFGNPCCharacterBoss_Armquist::M_pAudioComponent_ReinforcemnetVO' has a wrong offset!");
static_assert(offsetof(ABFGNPCCharacterBoss_Armquist, M_pAudioComponent_SupportVO) == 0x000E90, "Member 'ABFGNPCCharacterBoss_Armquist::M_pAudioComponent_SupportVO' has a wrong offset!");
static_assert(offsetof(ABFGNPCCharacterBoss_Armquist, M_pBossSupport_Navy) == 0x000E98, "Member 'ABFGNPCCharacterBoss_Armquist::M_pBossSupport_Navy' has a wrong offset!");
static_assert(offsetof(ABFGNPCCharacterBoss_Armquist, M_pBossSupport_Airforce) == 0x000EA0, "Member 'ABFGNPCCharacterBoss_Armquist::M_pBossSupport_Airforce' has a wrong offset!");
static_assert(offsetof(ABFGNPCCharacterBoss_Armquist, M_bShowAnimData) == 0x000EA8, "Member 'ABFGNPCCharacterBoss_Armquist::M_bShowAnimData' has a wrong offset!");
static_assert(offsetof(ABFGNPCCharacterBoss_Armquist, M_bWaitForCatchUpRotation) == 0x000EA9, "Member 'ABFGNPCCharacterBoss_Armquist::M_bWaitForCatchUpRotation' has a wrong offset!");
static_assert(offsetof(ABFGNPCCharacterBoss_Armquist, M_bAllowCatchUpRotationDuringMetaPatterns) == 0x000EAA, "Member 'ABFGNPCCharacterBoss_Armquist::M_bAllowCatchUpRotationDuringMetaPatterns' has a wrong offset!");
static_assert(offsetof(ABFGNPCCharacterBoss_Armquist, M_pLeapSplineComponent) == 0x000EB8, "Member 'ABFGNPCCharacterBoss_Armquist::M_pLeapSplineComponent' has a wrong offset!");
static_assert(offsetof(ABFGNPCCharacterBoss_Armquist, M_tLeapTimelineComponent) == 0x000EC0, "Member 'ABFGNPCCharacterBoss_Armquist::M_tLeapTimelineComponent' has a wrong offset!");

// Class BFGCore.BFGNPCCharacterBoss_Roboprez
// 0x00D0 (0x0EA0 - 0x0DD0)
class ABFGNPCCharacterBoss_Roboprez final : public ABFGNPCCharacterBoss
{
public:
	UMulticastDelegateProperty_                   OnTurnInPlaceCompleteDelegate;                     // 0x0DD0(0x0018)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	UMulticastDelegateProperty_                   OnFollowSplinePathCompleteDelegate;                // 0x0DE8(0x0018)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	bool                                          M_bSplinePathFalsifyVelocity;                      // 0x0E00(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_E01[0x3];                                      // 0x0E01(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	class FName                                   M_strWeakSpotSocket;                               // 0x0E04(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_E0C[0x4];                                      // 0x0E0C(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class UBFGDataAsset_BossData_Roboprez*        M_pRoboprezDataAsset;                              // 0x0E10(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class ABFGWeapon_BossBeam*                    M_pWeapon_Beam;                                    // 0x0E18(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class ABFGWeapon_BossBase*                    M_pMachineGunLeft;                                 // 0x0E20(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class ABFGWeapon_BossBase*                    M_pMachineGunRight;                                // 0x0E28(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class ABFGWeapon_BossBase*                    M_pRocketsLeft;                                    // 0x0E30(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class ABFGWeapon_BossBase*                    M_pAirMineLauncherRight;                           // 0x0E38(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class ABFGWeapon_BossBase*                    M_pSeekingRocketsLeft;                             // 0x0E40(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class ABFGWeapon_BossBase*                    M_pSeekingRocketsRight;                            // 0x0E48(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          M_bShowAnimData;                                   // 0x0E50(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          M_bShowAimingAtLocation;                           // 0x0E51(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          M_bWaitForCatchUpRotation;                         // 0x0E52(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          M_bAllowCatchUpRotationDuringMetaPatterns;         // 0x0E53(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          M_bShowRaycastsToDetermineWeakSpotHits;            // 0x0E54(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_E55[0x2B];                                     // 0x0E55(0x002B)(Fixing Size After Last Property [ Dumper-7 ])
	class USplineComponent*                       M_pSplineToFollow;                                 // 0x0E80(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_E88[0x10];                                     // 0x0E88(0x0010)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         M_fSplineMaxSpeedOverride;                         // 0x0E98(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_E9C[0x4];                                      // 0x0E9C(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void OnPlayerUFOEntered();
	void OnPlayerUFOTakeOffComplete();
	void OnWeakSpotHit();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"BFGNPCCharacterBoss_Roboprez">();
	}
	static class ABFGNPCCharacterBoss_Roboprez* GetDefaultObj()
	{
		return GetDefaultObjImpl<ABFGNPCCharacterBoss_Roboprez>();
	}
};
static_assert(alignof(ABFGNPCCharacterBoss_Roboprez) == 0x000010, "Wrong alignment on ABFGNPCCharacterBoss_Roboprez");
static_assert(sizeof(ABFGNPCCharacterBoss_Roboprez) == 0x000EA0, "Wrong size on ABFGNPCCharacterBoss_Roboprez");
static_assert(offsetof(ABFGNPCCharacterBoss_Roboprez, OnTurnInPlaceCompleteDelegate) == 0x000DD0, "Member 'ABFGNPCCharacterBoss_Roboprez::OnTurnInPlaceCompleteDelegate' has a wrong offset!");
static_assert(offsetof(ABFGNPCCharacterBoss_Roboprez, OnFollowSplinePathCompleteDelegate) == 0x000DE8, "Member 'ABFGNPCCharacterBoss_Roboprez::OnFollowSplinePathCompleteDelegate' has a wrong offset!");
static_assert(offsetof(ABFGNPCCharacterBoss_Roboprez, M_bSplinePathFalsifyVelocity) == 0x000E00, "Member 'ABFGNPCCharacterBoss_Roboprez::M_bSplinePathFalsifyVelocity' has a wrong offset!");
static_assert(offsetof(ABFGNPCCharacterBoss_Roboprez, M_strWeakSpotSocket) == 0x000E04, "Member 'ABFGNPCCharacterBoss_Roboprez::M_strWeakSpotSocket' has a wrong offset!");
static_assert(offsetof(ABFGNPCCharacterBoss_Roboprez, M_pRoboprezDataAsset) == 0x000E10, "Member 'ABFGNPCCharacterBoss_Roboprez::M_pRoboprezDataAsset' has a wrong offset!");
static_assert(offsetof(ABFGNPCCharacterBoss_Roboprez, M_pWeapon_Beam) == 0x000E18, "Member 'ABFGNPCCharacterBoss_Roboprez::M_pWeapon_Beam' has a wrong offset!");
static_assert(offsetof(ABFGNPCCharacterBoss_Roboprez, M_pMachineGunLeft) == 0x000E20, "Member 'ABFGNPCCharacterBoss_Roboprez::M_pMachineGunLeft' has a wrong offset!");
static_assert(offsetof(ABFGNPCCharacterBoss_Roboprez, M_pMachineGunRight) == 0x000E28, "Member 'ABFGNPCCharacterBoss_Roboprez::M_pMachineGunRight' has a wrong offset!");
static_assert(offsetof(ABFGNPCCharacterBoss_Roboprez, M_pRocketsLeft) == 0x000E30, "Member 'ABFGNPCCharacterBoss_Roboprez::M_pRocketsLeft' has a wrong offset!");
static_assert(offsetof(ABFGNPCCharacterBoss_Roboprez, M_pAirMineLauncherRight) == 0x000E38, "Member 'ABFGNPCCharacterBoss_Roboprez::M_pAirMineLauncherRight' has a wrong offset!");
static_assert(offsetof(ABFGNPCCharacterBoss_Roboprez, M_pSeekingRocketsLeft) == 0x000E40, "Member 'ABFGNPCCharacterBoss_Roboprez::M_pSeekingRocketsLeft' has a wrong offset!");
static_assert(offsetof(ABFGNPCCharacterBoss_Roboprez, M_pSeekingRocketsRight) == 0x000E48, "Member 'ABFGNPCCharacterBoss_Roboprez::M_pSeekingRocketsRight' has a wrong offset!");
static_assert(offsetof(ABFGNPCCharacterBoss_Roboprez, M_bShowAnimData) == 0x000E50, "Member 'ABFGNPCCharacterBoss_Roboprez::M_bShowAnimData' has a wrong offset!");
static_assert(offsetof(ABFGNPCCharacterBoss_Roboprez, M_bShowAimingAtLocation) == 0x000E51, "Member 'ABFGNPCCharacterBoss_Roboprez::M_bShowAimingAtLocation' has a wrong offset!");
static_assert(offsetof(ABFGNPCCharacterBoss_Roboprez, M_bWaitForCatchUpRotation) == 0x000E52, "Member 'ABFGNPCCharacterBoss_Roboprez::M_bWaitForCatchUpRotation' has a wrong offset!");
static_assert(offsetof(ABFGNPCCharacterBoss_Roboprez, M_bAllowCatchUpRotationDuringMetaPatterns) == 0x000E53, "Member 'ABFGNPCCharacterBoss_Roboprez::M_bAllowCatchUpRotationDuringMetaPatterns' has a wrong offset!");
static_assert(offsetof(ABFGNPCCharacterBoss_Roboprez, M_bShowRaycastsToDetermineWeakSpotHits) == 0x000E54, "Member 'ABFGNPCCharacterBoss_Roboprez::M_bShowRaycastsToDetermineWeakSpotHits' has a wrong offset!");
static_assert(offsetof(ABFGNPCCharacterBoss_Roboprez, M_pSplineToFollow) == 0x000E80, "Member 'ABFGNPCCharacterBoss_Roboprez::M_pSplineToFollow' has a wrong offset!");
static_assert(offsetof(ABFGNPCCharacterBoss_Roboprez, M_fSplineMaxSpeedOverride) == 0x000E98, "Member 'ABFGNPCCharacterBoss_Roboprez::M_fSplineMaxSpeedOverride' has a wrong offset!");

// Class BFGCore.BFGTrafficObstacleProxyComponent
// 0x0000 (0x0128 - 0x0128)
class UBFGTrafficObstacleProxyComponent final : public UActorComponent
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"BFGTrafficObstacleProxyComponent">();
	}
	static class UBFGTrafficObstacleProxyComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UBFGTrafficObstacleProxyComponent>();
	}
};
static_assert(alignof(UBFGTrafficObstacleProxyComponent) == 0x000008, "Wrong alignment on UBFGTrafficObstacleProxyComponent");
static_assert(sizeof(UBFGTrafficObstacleProxyComponent) == 0x000128, "Wrong size on UBFGTrafficObstacleProxyComponent");

// Class BFGCore.BFGNPCCharacterBoss_Silhouette
// 0x01B0 (0x0F80 - 0x0DD0)
class ABFGNPCCharacterBoss_Silhouette final : public ABFGNPCCharacterBoss
{
public:
	class UBFGActorComponent_DamageListener*      M_pDamageListener;                                 // 0x0DD0(0x0008)(Edit, ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UStaticMeshComponent*                   M_pAtomizerBeam_Right_Mesh;                        // 0x0DD8(0x0008)(Edit, BlueprintVisible, ExportObject, ZeroConstructor, EditConst, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TSubclassOf<class ABFGActor_Silhouette_SpinTornado> M_pSpinTornado_ActorClass;                         // 0x0DE0(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TSubclassOf<class UDamageType>                M_pDamageType;                                     // 0x0DE8(0x0008)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_DF0[0x10];                                     // 0x0DF0(0x0010)(Fixing Size After Last Property [ Dumper-7 ])
	class ABFGActor_Silhouette_SpinTornado*       M_pActiveSpinTornado;                              // 0x0E00(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UBFGDataAsset_BossData_Silhouette*      M_pSilhouetteDataAsset;                            // 0x0E08(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class ABFGWeapon_BossProjectile*              M_pAtomizerBeam_Left;                              // 0x0E10(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class ABFGWeapon_BossProjectile*              M_pAtomizerBeam_Right;                             // 0x0E18(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class ABFGWeapon_BossAOE_ParticleExploder*    M_pParticleExploder;                               // 0x0E20(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class ABFGWeapon_BossBeam*                    M_pShockomator;                                    // 0x0E28(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class ABFGWeapon_EnemyNasalProbe*             M_pNasalProbe;                                     // 0x0E30(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class ABFGMissionBoundaries*                  M_pMissionBounds;                                  // 0x0E38(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_E40[0x50];                                     // 0x0E40(0x0050)(Fixing Size After Last Property [ Dumper-7 ])
	class ABGFBoss_Marker_Location*               M_pBeamActor;                                      // 0x0E90(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class FName                                   M_oShieldRatioName;                                // 0x0E98(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	TSubclassOf<class ABFGEffectActor_RBPWreckBeam> M_pRoboprezEffectActor;                            // 0x0EA0(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class ABFGEffectActor_RBPWreckBeam*           M_pEffectActor;                                    // 0x0EA8(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	float                                         M_fBeamMinZ;                                       // 0x0EB0(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	float                                         M_fBeamMaxZ;                                       // 0x0EB4(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	float                                         M_fCoverTolerance;                                 // 0x0EB8(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	bool                                          M_bIsdebugMsgEnabled;                              // 0x0EBC(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_EBD[0x13];                                     // 0x0EBD(0x0013)(Fixing Size After Last Property [ Dumper-7 ])
	class UBFGActorComponent_Levitate*            M_pLevitateComponent;                              // 0x0ED0(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class ABFGNPCCharacterEnemy_PSIStation*       M_pPSIStation;                                     // 0x0ED8(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class USplineComponent*                       M_pEvasionSplineComponent;                         // 0x0EE0(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UTimelineComponent*                     M_tEvasionTimelineComponent;                       // 0x0EE8(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_EF0[0x48];                                     // 0x0EF0(0x0048)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<class ABFGActor_Silhouette_CoverSpot*> M_aCoverSpots;                                     // 0x0F38(0x0010)(ZeroConstructor, NativeAccessSpecifierPrivate)
	uint8                                         Pad_F48[0x8];                                      // 0x0F48(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	class UBFGReadTextureManager*                 M_pTextureReadManager;                             // 0x0F50(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class ABFGReadTextureActor*                   M_pTextureReadActor;                               // 0x0F58(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class APawn*                                  M_pPlayerPawn;                                     // 0x0F60(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	struct FTimerHandle                           M_PlayerisInCoverTimer;                            // 0x0F68(0x0008)(NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class ABFGActor_Silhouette_CoverSpot*         M_pLastCoverActor;                                 // 0x0F70(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_F78[0x8];                                      // 0x0F78(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void BeginBossAction_Evasion(const struct FVector& _vEvasionLocation);
	void BeginBossAction_NasalProbe();
	void BeginBossAction_NasalProbe_EndSequence(bool _bForced);
	void CallBossAction_Evasion();
	void CallBossAction_NasalProbe();
	void ChargeNasalProbe();
	void EndBossAction_NasalProbe_EndSequence();
	void EvasionTimeline_VectorCurveInterpolation(float Val);
	void FireNasalProbe();
	void NasalProbeTelegraphEnd();
	void NasalProbeTelegraphStart();
	void OnBossActionLandingSequence();
	void OnEvadeComplete();
	void OnHoverStateChanged(EBFGLevitationState _eNewHoverState);
	void OnPSIStationDeathStatChanged(class AActor* _pActor, class UBFGActorStat_Bool* _pStat);
	void OnShieldCriticalStateExpired();
	void OnShieldDamaged(class UBFGActorComponent_PawnDamage* _pPawnDamage, float _fDamage, class AActor* _pDamageCauser, class UBFGDamageType* _pDamageType, const struct FVector& _rShotDirection, const struct FHitResult& _oHitResult);
	void OnShieldStatChanged(class AActor* _pOwner, class UBFGActorStat_Float* _pStat);
	void OnSpinWindupComplete();
	void SetupEvasionComponents();
	void SetupEvasionSplinePoints(const struct FVector& _vEndLocation);
	void StartSpin();
	void StopSpin();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"BFGNPCCharacterBoss_Silhouette">();
	}
	static class ABFGNPCCharacterBoss_Silhouette* GetDefaultObj()
	{
		return GetDefaultObjImpl<ABFGNPCCharacterBoss_Silhouette>();
	}
};
static_assert(alignof(ABFGNPCCharacterBoss_Silhouette) == 0x000010, "Wrong alignment on ABFGNPCCharacterBoss_Silhouette");
static_assert(sizeof(ABFGNPCCharacterBoss_Silhouette) == 0x000F80, "Wrong size on ABFGNPCCharacterBoss_Silhouette");
static_assert(offsetof(ABFGNPCCharacterBoss_Silhouette, M_pDamageListener) == 0x000DD0, "Member 'ABFGNPCCharacterBoss_Silhouette::M_pDamageListener' has a wrong offset!");
static_assert(offsetof(ABFGNPCCharacterBoss_Silhouette, M_pAtomizerBeam_Right_Mesh) == 0x000DD8, "Member 'ABFGNPCCharacterBoss_Silhouette::M_pAtomizerBeam_Right_Mesh' has a wrong offset!");
static_assert(offsetof(ABFGNPCCharacterBoss_Silhouette, M_pSpinTornado_ActorClass) == 0x000DE0, "Member 'ABFGNPCCharacterBoss_Silhouette::M_pSpinTornado_ActorClass' has a wrong offset!");
static_assert(offsetof(ABFGNPCCharacterBoss_Silhouette, M_pDamageType) == 0x000DE8, "Member 'ABFGNPCCharacterBoss_Silhouette::M_pDamageType' has a wrong offset!");
static_assert(offsetof(ABFGNPCCharacterBoss_Silhouette, M_pActiveSpinTornado) == 0x000E00, "Member 'ABFGNPCCharacterBoss_Silhouette::M_pActiveSpinTornado' has a wrong offset!");
static_assert(offsetof(ABFGNPCCharacterBoss_Silhouette, M_pSilhouetteDataAsset) == 0x000E08, "Member 'ABFGNPCCharacterBoss_Silhouette::M_pSilhouetteDataAsset' has a wrong offset!");
static_assert(offsetof(ABFGNPCCharacterBoss_Silhouette, M_pAtomizerBeam_Left) == 0x000E10, "Member 'ABFGNPCCharacterBoss_Silhouette::M_pAtomizerBeam_Left' has a wrong offset!");
static_assert(offsetof(ABFGNPCCharacterBoss_Silhouette, M_pAtomizerBeam_Right) == 0x000E18, "Member 'ABFGNPCCharacterBoss_Silhouette::M_pAtomizerBeam_Right' has a wrong offset!");
static_assert(offsetof(ABFGNPCCharacterBoss_Silhouette, M_pParticleExploder) == 0x000E20, "Member 'ABFGNPCCharacterBoss_Silhouette::M_pParticleExploder' has a wrong offset!");
static_assert(offsetof(ABFGNPCCharacterBoss_Silhouette, M_pShockomator) == 0x000E28, "Member 'ABFGNPCCharacterBoss_Silhouette::M_pShockomator' has a wrong offset!");
static_assert(offsetof(ABFGNPCCharacterBoss_Silhouette, M_pNasalProbe) == 0x000E30, "Member 'ABFGNPCCharacterBoss_Silhouette::M_pNasalProbe' has a wrong offset!");
static_assert(offsetof(ABFGNPCCharacterBoss_Silhouette, M_pMissionBounds) == 0x000E38, "Member 'ABFGNPCCharacterBoss_Silhouette::M_pMissionBounds' has a wrong offset!");
static_assert(offsetof(ABFGNPCCharacterBoss_Silhouette, M_pBeamActor) == 0x000E90, "Member 'ABFGNPCCharacterBoss_Silhouette::M_pBeamActor' has a wrong offset!");
static_assert(offsetof(ABFGNPCCharacterBoss_Silhouette, M_oShieldRatioName) == 0x000E98, "Member 'ABFGNPCCharacterBoss_Silhouette::M_oShieldRatioName' has a wrong offset!");
static_assert(offsetof(ABFGNPCCharacterBoss_Silhouette, M_pRoboprezEffectActor) == 0x000EA0, "Member 'ABFGNPCCharacterBoss_Silhouette::M_pRoboprezEffectActor' has a wrong offset!");
static_assert(offsetof(ABFGNPCCharacterBoss_Silhouette, M_pEffectActor) == 0x000EA8, "Member 'ABFGNPCCharacterBoss_Silhouette::M_pEffectActor' has a wrong offset!");
static_assert(offsetof(ABFGNPCCharacterBoss_Silhouette, M_fBeamMinZ) == 0x000EB0, "Member 'ABFGNPCCharacterBoss_Silhouette::M_fBeamMinZ' has a wrong offset!");
static_assert(offsetof(ABFGNPCCharacterBoss_Silhouette, M_fBeamMaxZ) == 0x000EB4, "Member 'ABFGNPCCharacterBoss_Silhouette::M_fBeamMaxZ' has a wrong offset!");
static_assert(offsetof(ABFGNPCCharacterBoss_Silhouette, M_fCoverTolerance) == 0x000EB8, "Member 'ABFGNPCCharacterBoss_Silhouette::M_fCoverTolerance' has a wrong offset!");
static_assert(offsetof(ABFGNPCCharacterBoss_Silhouette, M_bIsdebugMsgEnabled) == 0x000EBC, "Member 'ABFGNPCCharacterBoss_Silhouette::M_bIsdebugMsgEnabled' has a wrong offset!");
static_assert(offsetof(ABFGNPCCharacterBoss_Silhouette, M_pLevitateComponent) == 0x000ED0, "Member 'ABFGNPCCharacterBoss_Silhouette::M_pLevitateComponent' has a wrong offset!");
static_assert(offsetof(ABFGNPCCharacterBoss_Silhouette, M_pPSIStation) == 0x000ED8, "Member 'ABFGNPCCharacterBoss_Silhouette::M_pPSIStation' has a wrong offset!");
static_assert(offsetof(ABFGNPCCharacterBoss_Silhouette, M_pEvasionSplineComponent) == 0x000EE0, "Member 'ABFGNPCCharacterBoss_Silhouette::M_pEvasionSplineComponent' has a wrong offset!");
static_assert(offsetof(ABFGNPCCharacterBoss_Silhouette, M_tEvasionTimelineComponent) == 0x000EE8, "Member 'ABFGNPCCharacterBoss_Silhouette::M_tEvasionTimelineComponent' has a wrong offset!");
static_assert(offsetof(ABFGNPCCharacterBoss_Silhouette, M_aCoverSpots) == 0x000F38, "Member 'ABFGNPCCharacterBoss_Silhouette::M_aCoverSpots' has a wrong offset!");
static_assert(offsetof(ABFGNPCCharacterBoss_Silhouette, M_pTextureReadManager) == 0x000F50, "Member 'ABFGNPCCharacterBoss_Silhouette::M_pTextureReadManager' has a wrong offset!");
static_assert(offsetof(ABFGNPCCharacterBoss_Silhouette, M_pTextureReadActor) == 0x000F58, "Member 'ABFGNPCCharacterBoss_Silhouette::M_pTextureReadActor' has a wrong offset!");
static_assert(offsetof(ABFGNPCCharacterBoss_Silhouette, M_pPlayerPawn) == 0x000F60, "Member 'ABFGNPCCharacterBoss_Silhouette::M_pPlayerPawn' has a wrong offset!");
static_assert(offsetof(ABFGNPCCharacterBoss_Silhouette, M_PlayerisInCoverTimer) == 0x000F68, "Member 'ABFGNPCCharacterBoss_Silhouette::M_PlayerisInCoverTimer' has a wrong offset!");
static_assert(offsetof(ABFGNPCCharacterBoss_Silhouette, M_pLastCoverActor) == 0x000F70, "Member 'ABFGNPCCharacterBoss_Silhouette::M_pLastCoverActor' has a wrong offset!");

// Class BFGCore.BFGNPCCharacterCivilian
// 0x0010 (0x0BF0 - 0x0BE0)
class ABFGNPCCharacterCivilian : public ABFGNPCCharacterHuman
{
public:
	float                                         M_fDefaultHealthBarZOffset;                        // 0x0BD8(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_BDC[0x4];                                      // 0x0BDC(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	TSubclassOf<class UBFGActorComponent_WidgetComponent_Health> M_pDefaultHealthBarClass;                          // 0x0BE0(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UBFGActorComponent_WidgetComponent_Health* M_pHealthBarComponent;                             // 0x0BE8(0x0008)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, Transient, EditConst, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"BFGNPCCharacterCivilian">();
	}
	static class ABFGNPCCharacterCivilian* GetDefaultObj()
	{
		return GetDefaultObjImpl<ABFGNPCCharacterCivilian>();
	}
};
static_assert(alignof(ABFGNPCCharacterCivilian) == 0x000010, "Wrong alignment on ABFGNPCCharacterCivilian");
static_assert(sizeof(ABFGNPCCharacterCivilian) == 0x000BF0, "Wrong size on ABFGNPCCharacterCivilian");
static_assert(offsetof(ABFGNPCCharacterCivilian, M_fDefaultHealthBarZOffset) == 0x000BD8, "Member 'ABFGNPCCharacterCivilian::M_fDefaultHealthBarZOffset' has a wrong offset!");
static_assert(offsetof(ABFGNPCCharacterCivilian, M_pDefaultHealthBarClass) == 0x000BE0, "Member 'ABFGNPCCharacterCivilian::M_pDefaultHealthBarClass' has a wrong offset!");
static_assert(offsetof(ABFGNPCCharacterCivilian, M_pHealthBarComponent) == 0x000BE8, "Member 'ABFGNPCCharacterCivilian::M_pHealthBarComponent' has a wrong offset!");

// Class BFGCore.BFGNPCCharacterEnemy_Mine
// 0x0090 (0x0C70 - 0x0BE0)
class ABFGNPCCharacterEnemy_Mine : public ABFGNPCCharacterEnemy
{
public:
	class UBFGActorComponent_ExplosiveItem*       M_pExplosiveComponent;                             // 0x0BD8(0x0008)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, EditConst, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         M_fRange;                                          // 0x0BE0(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         M_fExplosionDelay;                                 // 0x0BE4(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          M_bIsGroundMine;                                   // 0x0BE8(0x0001)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_BE9[0x7];                                      // 0x0BE9(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	struct FGameplayEffectTagsTimer               M_oAppliedGameplayEffectTag;                       // 0x0BF0(0x0028)(Edit, BlueprintVisible, NativeAccessSpecifierPublic)
	TArray<struct FGameplayEffectTagsTimer>       M_aAppliedGameplayEffectTags;                      // 0x0C18(0x0010)(Edit, BlueprintVisible, ZeroConstructor, NativeAccessSpecifierPublic)
	bool                                          M_bDiesOnExplosion;                                // 0x0C28(0x0001)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_C29[0x3];                                      // 0x0C29(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         M_fAfterDeathActorRemovalDelay;                    // 0x0C2C(0x0004)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          M_bExplodesOnDeath;                                // 0x0C30(0x0001)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          M_bExplodesWhileInPK;                              // 0x0C31(0x0001)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          M_bExplosionBreaksHolobob;                         // 0x0C32(0x0001)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          M_bPKingBreaksHolobob;                             // 0x0C33(0x0001)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          M_bDiesOnPKRelease;                                // 0x0C34(0x0001)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          M_bCanBeTriggeredByNPCs;                           // 0x0C35(0x0001)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_C36[0x2];                                      // 0x0C36(0x0002)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         M_fDriftingRadius;                                 // 0x0C38(0x0004)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         M_fDritingSpeed;                                   // 0x0C3C(0x0004)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          M_bShowTriggerRadiusOnRadar;                       // 0x0C40(0x0001)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          M_bRegisterToActivationManager;                    // 0x0C41(0x0001)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_C42[0x6];                                      // 0x0C42(0x0006)(Fixing Size After Last Property [ Dumper-7 ])
	class UBFGActorComponent_RadarObject_ExactRadius* M_pRadarComponent;                                 // 0x0C48(0x0008)(Edit, BlueprintVisible, ExportObject, ZeroConstructor, DisableEditOnInstance, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_C50[0x18];                                     // 0x0C50(0x0018)(Fixing Size After Last Property [ Dumper-7 ])
	class UBFGBroadphaseManager*                  M_pBroadphase;                                     // 0x0C68(0x0008)(ExportObject, ZeroConstructor, Transient, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)

public:
	void OnPlayerEnteredRange();
	void OnPlayerLeftRange();
	void OnTriggerExplosion();

	float GetExplosionProgress() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"BFGNPCCharacterEnemy_Mine">();
	}
	static class ABFGNPCCharacterEnemy_Mine* GetDefaultObj()
	{
		return GetDefaultObjImpl<ABFGNPCCharacterEnemy_Mine>();
	}
};
static_assert(alignof(ABFGNPCCharacterEnemy_Mine) == 0x000010, "Wrong alignment on ABFGNPCCharacterEnemy_Mine");
static_assert(sizeof(ABFGNPCCharacterEnemy_Mine) == 0x000C70, "Wrong size on ABFGNPCCharacterEnemy_Mine");
static_assert(offsetof(ABFGNPCCharacterEnemy_Mine, M_pExplosiveComponent) == 0x000BD8, "Member 'ABFGNPCCharacterEnemy_Mine::M_pExplosiveComponent' has a wrong offset!");
static_assert(offsetof(ABFGNPCCharacterEnemy_Mine, M_fRange) == 0x000BE0, "Member 'ABFGNPCCharacterEnemy_Mine::M_fRange' has a wrong offset!");
static_assert(offsetof(ABFGNPCCharacterEnemy_Mine, M_fExplosionDelay) == 0x000BE4, "Member 'ABFGNPCCharacterEnemy_Mine::M_fExplosionDelay' has a wrong offset!");
static_assert(offsetof(ABFGNPCCharacterEnemy_Mine, M_bIsGroundMine) == 0x000BE8, "Member 'ABFGNPCCharacterEnemy_Mine::M_bIsGroundMine' has a wrong offset!");
static_assert(offsetof(ABFGNPCCharacterEnemy_Mine, M_oAppliedGameplayEffectTag) == 0x000BF0, "Member 'ABFGNPCCharacterEnemy_Mine::M_oAppliedGameplayEffectTag' has a wrong offset!");
static_assert(offsetof(ABFGNPCCharacterEnemy_Mine, M_aAppliedGameplayEffectTags) == 0x000C18, "Member 'ABFGNPCCharacterEnemy_Mine::M_aAppliedGameplayEffectTags' has a wrong offset!");
static_assert(offsetof(ABFGNPCCharacterEnemy_Mine, M_bDiesOnExplosion) == 0x000C28, "Member 'ABFGNPCCharacterEnemy_Mine::M_bDiesOnExplosion' has a wrong offset!");
static_assert(offsetof(ABFGNPCCharacterEnemy_Mine, M_fAfterDeathActorRemovalDelay) == 0x000C2C, "Member 'ABFGNPCCharacterEnemy_Mine::M_fAfterDeathActorRemovalDelay' has a wrong offset!");
static_assert(offsetof(ABFGNPCCharacterEnemy_Mine, M_bExplodesOnDeath) == 0x000C30, "Member 'ABFGNPCCharacterEnemy_Mine::M_bExplodesOnDeath' has a wrong offset!");
static_assert(offsetof(ABFGNPCCharacterEnemy_Mine, M_bExplodesWhileInPK) == 0x000C31, "Member 'ABFGNPCCharacterEnemy_Mine::M_bExplodesWhileInPK' has a wrong offset!");
static_assert(offsetof(ABFGNPCCharacterEnemy_Mine, M_bExplosionBreaksHolobob) == 0x000C32, "Member 'ABFGNPCCharacterEnemy_Mine::M_bExplosionBreaksHolobob' has a wrong offset!");
static_assert(offsetof(ABFGNPCCharacterEnemy_Mine, M_bPKingBreaksHolobob) == 0x000C33, "Member 'ABFGNPCCharacterEnemy_Mine::M_bPKingBreaksHolobob' has a wrong offset!");
static_assert(offsetof(ABFGNPCCharacterEnemy_Mine, M_bDiesOnPKRelease) == 0x000C34, "Member 'ABFGNPCCharacterEnemy_Mine::M_bDiesOnPKRelease' has a wrong offset!");
static_assert(offsetof(ABFGNPCCharacterEnemy_Mine, M_bCanBeTriggeredByNPCs) == 0x000C35, "Member 'ABFGNPCCharacterEnemy_Mine::M_bCanBeTriggeredByNPCs' has a wrong offset!");
static_assert(offsetof(ABFGNPCCharacterEnemy_Mine, M_fDriftingRadius) == 0x000C38, "Member 'ABFGNPCCharacterEnemy_Mine::M_fDriftingRadius' has a wrong offset!");
static_assert(offsetof(ABFGNPCCharacterEnemy_Mine, M_fDritingSpeed) == 0x000C3C, "Member 'ABFGNPCCharacterEnemy_Mine::M_fDritingSpeed' has a wrong offset!");
static_assert(offsetof(ABFGNPCCharacterEnemy_Mine, M_bShowTriggerRadiusOnRadar) == 0x000C40, "Member 'ABFGNPCCharacterEnemy_Mine::M_bShowTriggerRadiusOnRadar' has a wrong offset!");
static_assert(offsetof(ABFGNPCCharacterEnemy_Mine, M_bRegisterToActivationManager) == 0x000C41, "Member 'ABFGNPCCharacterEnemy_Mine::M_bRegisterToActivationManager' has a wrong offset!");
static_assert(offsetof(ABFGNPCCharacterEnemy_Mine, M_pRadarComponent) == 0x000C48, "Member 'ABFGNPCCharacterEnemy_Mine::M_pRadarComponent' has a wrong offset!");
static_assert(offsetof(ABFGNPCCharacterEnemy_Mine, M_pBroadphase) == 0x000C68, "Member 'ABFGNPCCharacterEnemy_Mine::M_pBroadphase' has a wrong offset!");

// Class BFGCore.BFGTrafficPathFinder_Stack
// 0x0010 (0x0038 - 0x0028)
class UBFGTrafficPathFinder_Stack final : public UObject
{
public:
	TArray<struct FBFGTrafficPathFinder_StackItem> M_aStack;                                          // 0x0028(0x0010)(ZeroConstructor, Transient, NativeAccessSpecifierPrivate)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"BFGTrafficPathFinder_Stack">();
	}
	static class UBFGTrafficPathFinder_Stack* GetDefaultObj()
	{
		return GetDefaultObjImpl<UBFGTrafficPathFinder_Stack>();
	}
};
static_assert(alignof(UBFGTrafficPathFinder_Stack) == 0x000008, "Wrong alignment on UBFGTrafficPathFinder_Stack");
static_assert(sizeof(UBFGTrafficPathFinder_Stack) == 0x000038, "Wrong size on UBFGTrafficPathFinder_Stack");
static_assert(offsetof(UBFGTrafficPathFinder_Stack, M_aStack) == 0x000028, "Member 'UBFGTrafficPathFinder_Stack::M_aStack' has a wrong offset!");

// Class BFGCore.BFGNPCCharacterEnemy_Mine_ParticleExploder
// 0x0040 (0x0CB0 - 0x0C70)
class ABFGNPCCharacterEnemy_Mine_ParticleExploder final : public ABFGNPCCharacterEnemy_Mine
{
public:
	bool                                          M_bTriggered;                                      // 0x0C70(0x0001)(Edit, ZeroConstructor, DisableEditOnTemplate, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_C71[0x7];                                      // 0x0C71(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	UMulticastDelegateProperty_                   M_dOnMineExploded;                                 // 0x0C78(0x0018)(ZeroConstructor, InstancedReference, NativeAccessSpecifierPublic)
	UMulticastDelegateProperty_                   M_dOnMineTriggerRangeEntered;                      // 0x0C90(0x0018)(ZeroConstructor, InstancedReference, NativeAccessSpecifierPublic)
	uint8                                         Pad_CA8[0x8];                                      // 0x0CA8(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void OnTriggered();

	float GetCountdownDuration() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"BFGNPCCharacterEnemy_Mine_ParticleExploder">();
	}
	static class ABFGNPCCharacterEnemy_Mine_ParticleExploder* GetDefaultObj()
	{
		return GetDefaultObjImpl<ABFGNPCCharacterEnemy_Mine_ParticleExploder>();
	}
};
static_assert(alignof(ABFGNPCCharacterEnemy_Mine_ParticleExploder) == 0x000010, "Wrong alignment on ABFGNPCCharacterEnemy_Mine_ParticleExploder");
static_assert(sizeof(ABFGNPCCharacterEnemy_Mine_ParticleExploder) == 0x000CB0, "Wrong size on ABFGNPCCharacterEnemy_Mine_ParticleExploder");
static_assert(offsetof(ABFGNPCCharacterEnemy_Mine_ParticleExploder, M_bTriggered) == 0x000C70, "Member 'ABFGNPCCharacterEnemy_Mine_ParticleExploder::M_bTriggered' has a wrong offset!");
static_assert(offsetof(ABFGNPCCharacterEnemy_Mine_ParticleExploder, M_dOnMineExploded) == 0x000C78, "Member 'ABFGNPCCharacterEnemy_Mine_ParticleExploder::M_dOnMineExploded' has a wrong offset!");
static_assert(offsetof(ABFGNPCCharacterEnemy_Mine_ParticleExploder, M_dOnMineTriggerRangeEntered) == 0x000C90, "Member 'ABFGNPCCharacterEnemy_Mine_ParticleExploder::M_dOnMineTriggerRangeEntered' has a wrong offset!");

// Class BFGCore.BFGNPCCharacterEnemy_Mine_Roboprez
// 0x0020 (0x0C90 - 0x0C70)
class ABFGNPCCharacterEnemy_Mine_Roboprez : public ABFGNPCCharacterEnemy_Mine
{
public:
	float                                         M_fFloatDownFromHeight;                            // 0x0C70(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         M_fFloatDownSpeed;                                 // 0x0C74(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         M_fFloatDownArriveThreshold;                       // 0x0C78(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_C7C[0x14];                                     // 0x0C7C(0x0014)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void OnDetonated(class ABFGWeapon* _pWeapon);
	void StartDecline();

	struct FVector GetSpawnFinalPosition() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"BFGNPCCharacterEnemy_Mine_Roboprez">();
	}
	static class ABFGNPCCharacterEnemy_Mine_Roboprez* GetDefaultObj()
	{
		return GetDefaultObjImpl<ABFGNPCCharacterEnemy_Mine_Roboprez>();
	}
};
static_assert(alignof(ABFGNPCCharacterEnemy_Mine_Roboprez) == 0x000010, "Wrong alignment on ABFGNPCCharacterEnemy_Mine_Roboprez");
static_assert(sizeof(ABFGNPCCharacterEnemy_Mine_Roboprez) == 0x000C90, "Wrong size on ABFGNPCCharacterEnemy_Mine_Roboprez");
static_assert(offsetof(ABFGNPCCharacterEnemy_Mine_Roboprez, M_fFloatDownFromHeight) == 0x000C70, "Member 'ABFGNPCCharacterEnemy_Mine_Roboprez::M_fFloatDownFromHeight' has a wrong offset!");
static_assert(offsetof(ABFGNPCCharacterEnemy_Mine_Roboprez, M_fFloatDownSpeed) == 0x000C74, "Member 'ABFGNPCCharacterEnemy_Mine_Roboprez::M_fFloatDownSpeed' has a wrong offset!");
static_assert(offsetof(ABFGNPCCharacterEnemy_Mine_Roboprez, M_fFloatDownArriveThreshold) == 0x000C78, "Member 'ABFGNPCCharacterEnemy_Mine_Roboprez::M_fFloatDownArriveThreshold' has a wrong offset!");

// Class BFGCore.BFGNPCCharacterEnemy_TeslaCoil
// 0x0040 (0x0C20 - 0x0BE0)
class ABFGNPCCharacterEnemy_TeslaCoil final : public ABFGNPCCharacterEnemy
{
public:
	float                                         M_fOptimalRangeAgainstPlayer;                      // 0x0BD8(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         M_fOptimalRangeAgainstUFO;                         // 0x0BDC(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         M_fMaximumRangeAgainstPlayer;                      // 0x0BE0(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         M_fMaximumRangeAgainstUFO;                         // 0x0BE4(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         M_fChargeupDuration;                               // 0x0BE8(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         M_fCooldownDuration;                               // 0x0BEC(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          M_bCanAttackCryptoOnFoot;                          // 0x0BF0(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_BF1[0xB];                                      // 0x0BF1(0x000B)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         M_fFirstTickStaggerRadius;                         // 0x0BFC(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	int32                                         M_iFirstTickStaggerValue;                          // 0x0C00(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         M_fSecondTickStaggerRadius;                        // 0x0C04(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	int32                                         M_iSecondTickStaggerValue;                         // 0x0C08(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         M_fThirdTickStaggerRadius;                         // 0x0C0C(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	int32                                         M_iThirdTickStaggerValue;                          // 0x0C10(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_C14[0xC];                                      // 0x0C14(0x000C)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void OnChargeStart();
	void OnChargeStop();
	void OnCooldownFinished();
	void OnCooldownStarted();
	void OnFireAttack();

	float GetCurrentCharge() const;
	float GetCurrentCooldown() const;
	bool GetIsCharging() const;
	bool GetIsPlayerInRange() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"BFGNPCCharacterEnemy_TeslaCoil">();
	}
	static class ABFGNPCCharacterEnemy_TeslaCoil* GetDefaultObj()
	{
		return GetDefaultObjImpl<ABFGNPCCharacterEnemy_TeslaCoil>();
	}
};
static_assert(alignof(ABFGNPCCharacterEnemy_TeslaCoil) == 0x000010, "Wrong alignment on ABFGNPCCharacterEnemy_TeslaCoil");
static_assert(sizeof(ABFGNPCCharacterEnemy_TeslaCoil) == 0x000C20, "Wrong size on ABFGNPCCharacterEnemy_TeslaCoil");
static_assert(offsetof(ABFGNPCCharacterEnemy_TeslaCoil, M_fOptimalRangeAgainstPlayer) == 0x000BD8, "Member 'ABFGNPCCharacterEnemy_TeslaCoil::M_fOptimalRangeAgainstPlayer' has a wrong offset!");
static_assert(offsetof(ABFGNPCCharacterEnemy_TeslaCoil, M_fOptimalRangeAgainstUFO) == 0x000BDC, "Member 'ABFGNPCCharacterEnemy_TeslaCoil::M_fOptimalRangeAgainstUFO' has a wrong offset!");
static_assert(offsetof(ABFGNPCCharacterEnemy_TeslaCoil, M_fMaximumRangeAgainstPlayer) == 0x000BE0, "Member 'ABFGNPCCharacterEnemy_TeslaCoil::M_fMaximumRangeAgainstPlayer' has a wrong offset!");
static_assert(offsetof(ABFGNPCCharacterEnemy_TeslaCoil, M_fMaximumRangeAgainstUFO) == 0x000BE4, "Member 'ABFGNPCCharacterEnemy_TeslaCoil::M_fMaximumRangeAgainstUFO' has a wrong offset!");
static_assert(offsetof(ABFGNPCCharacterEnemy_TeslaCoil, M_fChargeupDuration) == 0x000BE8, "Member 'ABFGNPCCharacterEnemy_TeslaCoil::M_fChargeupDuration' has a wrong offset!");
static_assert(offsetof(ABFGNPCCharacterEnemy_TeslaCoil, M_fCooldownDuration) == 0x000BEC, "Member 'ABFGNPCCharacterEnemy_TeslaCoil::M_fCooldownDuration' has a wrong offset!");
static_assert(offsetof(ABFGNPCCharacterEnemy_TeslaCoil, M_bCanAttackCryptoOnFoot) == 0x000BF0, "Member 'ABFGNPCCharacterEnemy_TeslaCoil::M_bCanAttackCryptoOnFoot' has a wrong offset!");
static_assert(offsetof(ABFGNPCCharacterEnemy_TeslaCoil, M_fFirstTickStaggerRadius) == 0x000BFC, "Member 'ABFGNPCCharacterEnemy_TeslaCoil::M_fFirstTickStaggerRadius' has a wrong offset!");
static_assert(offsetof(ABFGNPCCharacterEnemy_TeslaCoil, M_iFirstTickStaggerValue) == 0x000C00, "Member 'ABFGNPCCharacterEnemy_TeslaCoil::M_iFirstTickStaggerValue' has a wrong offset!");
static_assert(offsetof(ABFGNPCCharacterEnemy_TeslaCoil, M_fSecondTickStaggerRadius) == 0x000C04, "Member 'ABFGNPCCharacterEnemy_TeslaCoil::M_fSecondTickStaggerRadius' has a wrong offset!");
static_assert(offsetof(ABFGNPCCharacterEnemy_TeslaCoil, M_iSecondTickStaggerValue) == 0x000C08, "Member 'ABFGNPCCharacterEnemy_TeslaCoil::M_iSecondTickStaggerValue' has a wrong offset!");
static_assert(offsetof(ABFGNPCCharacterEnemy_TeslaCoil, M_fThirdTickStaggerRadius) == 0x000C0C, "Member 'ABFGNPCCharacterEnemy_TeslaCoil::M_fThirdTickStaggerRadius' has a wrong offset!");
static_assert(offsetof(ABFGNPCCharacterEnemy_TeslaCoil, M_iThirdTickStaggerValue) == 0x000C10, "Member 'ABFGNPCCharacterEnemy_TeslaCoil::M_iThirdTickStaggerValue' has a wrong offset!");

// Class BFGCore.BFGTransmogrifyLootManager
// 0x00D8 (0x0108 - 0x0030)
class UBFGTransmogrifyLootManager : public UBFGGameSystem
{
public:
	class ABFGGameState*                          M_pGameState;                                      // 0x0030(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TArray<struct FBFGTransmogrifyLootTableEntry> M_aLightLootTable;                                 // 0x0038(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Protected, NativeAccessSpecifierProtected)
	TArray<struct FBFGTransmogrifyLootTableEntry> M_aMediumLootTable;                                // 0x0048(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Protected, NativeAccessSpecifierProtected)
	TArray<struct FBFGTransmogrifyLootTableEntry> M_aHeavyLootTable;                                 // 0x0058(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Protected, NativeAccessSpecifierProtected)
	TArray<struct FBFGTransmogrifyLootTableEntry> M_aUFOLightLootTable;                              // 0x0068(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Protected, NativeAccessSpecifierProtected)
	TArray<struct FBFGTransmogrifyLootTableEntry> M_aUFOMediumLootTable;                             // 0x0078(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Protected, NativeAccessSpecifierProtected)
	TArray<struct FBFGTransmogrifyLootTableEntry> M_aUFOHeavyLootTable;                              // 0x0088(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Protected, NativeAccessSpecifierProtected)
	TArray<struct FBFGTransmogrifyLootTableEntry> M_aAvailableLightLootTable;                        // 0x0098(0x0010)(ZeroConstructor, Transient, Protected, NativeAccessSpecifierProtected)
	TArray<struct FBFGTransmogrifyLootTableEntry> M_aAvailableMediumLootTable;                       // 0x00A8(0x0010)(ZeroConstructor, Transient, Protected, NativeAccessSpecifierProtected)
	TArray<struct FBFGTransmogrifyLootTableEntry> M_aAvailableHeavyLootTable;                        // 0x00B8(0x0010)(ZeroConstructor, Transient, Protected, NativeAccessSpecifierProtected)
	TArray<struct FBFGTransmogrifyLootTableEntry> M_aUFOAvailableLightLootTable;                     // 0x00C8(0x0010)(ZeroConstructor, Transient, Protected, NativeAccessSpecifierProtected)
	TArray<struct FBFGTransmogrifyLootTableEntry> M_aUFOAvailableMediumLootTable;                    // 0x00D8(0x0010)(ZeroConstructor, Transient, Protected, NativeAccessSpecifierProtected)
	TArray<struct FBFGTransmogrifyLootTableEntry> M_aUFOAvailableHeavyLootTable;                     // 0x00E8(0x0010)(ZeroConstructor, Transient, Protected, NativeAccessSpecifierProtected)
	float                                         M_fSpiralSpaceA;                                   // 0x00F8(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         M_fSpiralSpaceB;                                   // 0x00FC(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         M_fSpiralIncrement;                                // 0x0100(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_104[0x4];                                      // 0x0104(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"BFGTransmogrifyLootManager">();
	}
	static class UBFGTransmogrifyLootManager* GetDefaultObj()
	{
		return GetDefaultObjImpl<UBFGTransmogrifyLootManager>();
	}
};
static_assert(alignof(UBFGTransmogrifyLootManager) == 0x000008, "Wrong alignment on UBFGTransmogrifyLootManager");
static_assert(sizeof(UBFGTransmogrifyLootManager) == 0x000108, "Wrong size on UBFGTransmogrifyLootManager");
static_assert(offsetof(UBFGTransmogrifyLootManager, M_pGameState) == 0x000030, "Member 'UBFGTransmogrifyLootManager::M_pGameState' has a wrong offset!");
static_assert(offsetof(UBFGTransmogrifyLootManager, M_aLightLootTable) == 0x000038, "Member 'UBFGTransmogrifyLootManager::M_aLightLootTable' has a wrong offset!");
static_assert(offsetof(UBFGTransmogrifyLootManager, M_aMediumLootTable) == 0x000048, "Member 'UBFGTransmogrifyLootManager::M_aMediumLootTable' has a wrong offset!");
static_assert(offsetof(UBFGTransmogrifyLootManager, M_aHeavyLootTable) == 0x000058, "Member 'UBFGTransmogrifyLootManager::M_aHeavyLootTable' has a wrong offset!");
static_assert(offsetof(UBFGTransmogrifyLootManager, M_aUFOLightLootTable) == 0x000068, "Member 'UBFGTransmogrifyLootManager::M_aUFOLightLootTable' has a wrong offset!");
static_assert(offsetof(UBFGTransmogrifyLootManager, M_aUFOMediumLootTable) == 0x000078, "Member 'UBFGTransmogrifyLootManager::M_aUFOMediumLootTable' has a wrong offset!");
static_assert(offsetof(UBFGTransmogrifyLootManager, M_aUFOHeavyLootTable) == 0x000088, "Member 'UBFGTransmogrifyLootManager::M_aUFOHeavyLootTable' has a wrong offset!");
static_assert(offsetof(UBFGTransmogrifyLootManager, M_aAvailableLightLootTable) == 0x000098, "Member 'UBFGTransmogrifyLootManager::M_aAvailableLightLootTable' has a wrong offset!");
static_assert(offsetof(UBFGTransmogrifyLootManager, M_aAvailableMediumLootTable) == 0x0000A8, "Member 'UBFGTransmogrifyLootManager::M_aAvailableMediumLootTable' has a wrong offset!");
static_assert(offsetof(UBFGTransmogrifyLootManager, M_aAvailableHeavyLootTable) == 0x0000B8, "Member 'UBFGTransmogrifyLootManager::M_aAvailableHeavyLootTable' has a wrong offset!");
static_assert(offsetof(UBFGTransmogrifyLootManager, M_aUFOAvailableLightLootTable) == 0x0000C8, "Member 'UBFGTransmogrifyLootManager::M_aUFOAvailableLightLootTable' has a wrong offset!");
static_assert(offsetof(UBFGTransmogrifyLootManager, M_aUFOAvailableMediumLootTable) == 0x0000D8, "Member 'UBFGTransmogrifyLootManager::M_aUFOAvailableMediumLootTable' has a wrong offset!");
static_assert(offsetof(UBFGTransmogrifyLootManager, M_aUFOAvailableHeavyLootTable) == 0x0000E8, "Member 'UBFGTransmogrifyLootManager::M_aUFOAvailableHeavyLootTable' has a wrong offset!");
static_assert(offsetof(UBFGTransmogrifyLootManager, M_fSpiralSpaceA) == 0x0000F8, "Member 'UBFGTransmogrifyLootManager::M_fSpiralSpaceA' has a wrong offset!");
static_assert(offsetof(UBFGTransmogrifyLootManager, M_fSpiralSpaceB) == 0x0000FC, "Member 'UBFGTransmogrifyLootManager::M_fSpiralSpaceB' has a wrong offset!");
static_assert(offsetof(UBFGTransmogrifyLootManager, M_fSpiralIncrement) == 0x000100, "Member 'UBFGTransmogrifyLootManager::M_fSpiralIncrement' has a wrong offset!");

// Class BFGCore.BFGNPCCharacterEnemyPsi
// 0x0000 (0x0BE0 - 0x0BE0)
class ABFGNPCCharacterEnemyPsi : public ABFGNPCCharacterEnemy
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"BFGNPCCharacterEnemyPsi">();
	}
	static class ABFGNPCCharacterEnemyPsi* GetDefaultObj()
	{
		return GetDefaultObjImpl<ABFGNPCCharacterEnemyPsi>();
	}
};
static_assert(alignof(ABFGNPCCharacterEnemyPsi) == 0x000010, "Wrong alignment on ABFGNPCCharacterEnemyPsi");
static_assert(sizeof(ABFGNPCCharacterEnemyPsi) == 0x000BE0, "Wrong size on ABFGNPCCharacterEnemyPsi");

// Class BFGCore.BFGNPCCharacterPox
// 0x0010 (0x09E0 - 0x09D0)
class ABFGNPCCharacterPox final : public ABFGNPCCharacter
{
public:
	uint8                                         Pad_9D0[0x8];                                      // 0x09D0(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	class UDataTable*                             M_pDataTableNarrativeSequences;                    // 0x09D8(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)

public:
	void OnPoxLabEnter();
	void OnPoxLabExit();
	void OnSFX_NarrativeSequence_Start(class FName _oSequenceName);
	void OnSFX_NarrativeSequence_Stop();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"BFGNPCCharacterPox">();
	}
	static class ABFGNPCCharacterPox* GetDefaultObj()
	{
		return GetDefaultObjImpl<ABFGNPCCharacterPox>();
	}
};
static_assert(alignof(ABFGNPCCharacterPox) == 0x000010, "Wrong alignment on ABFGNPCCharacterPox");
static_assert(sizeof(ABFGNPCCharacterPox) == 0x0009E0, "Wrong size on ABFGNPCCharacterPox");
static_assert(offsetof(ABFGNPCCharacterPox, M_pDataTableNarrativeSequences) == 0x0009D8, "Member 'ABFGNPCCharacterPox::M_pDataTableNarrativeSequences' has a wrong offset!");

// Class BFGCore.BFGNPCCivilianController
// 0x0000 (0x0600 - 0x0600)
class ABFGNPCCivilianController : public ABFGNPCHumanController
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"BFGNPCCivilianController">();
	}
	static class ABFGNPCCivilianController* GetDefaultObj()
	{
		return GetDefaultObjImpl<ABFGNPCCivilianController>();
	}
};
static_assert(alignof(ABFGNPCCivilianController) == 0x000008, "Wrong alignment on ABFGNPCCivilianController");
static_assert(sizeof(ABFGNPCCivilianController) == 0x000600, "Wrong size on ABFGNPCCivilianController");

// Class BFGCore.BFGTutorialManager
// 0x00D8 (0x0108 - 0x0030)
class UBFGTutorialManager : public UBFGGameSystem
{
public:
	TSoftClassPtr<class UClass>                   M_pTutorialPageClass;                              // 0x0030(0x0028)(Edit, BlueprintVisible, BlueprintReadOnly, DisableEditOnInstance, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TSoftClassPtr<class UClass>                   M_pTutorialHandbookClass;                          // 0x0058(0x0028)(Edit, BlueprintVisible, BlueprintReadOnly, DisableEditOnInstance, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         M_fExpandedDuration;                               // 0x0080(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         M_fExpandedTimer;                                  // 0x0084(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         M_fAliveDuration;                                  // 0x0088(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         M_fAliveTimer;                                     // 0x008C(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         M_iStackSize;                                      // 0x0090(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          M_bPopTutorialsExceedingStackSize;                 // 0x0094(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_95[0x3];                                       // 0x0095(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         M_fIndicatorDurationPopup;                         // 0x0098(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         M_fIndicatorDurationInterpolate;                   // 0x009C(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector2D                              M_vIndicatorOrigin;                                // 0x00A0(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TArray<class UBFGWidget_TutorialPage*>        M_apTutorialPages;                                 // 0x00A8(0x0010)(ExportObject, ZeroConstructor, ContainsInstancedReference, Protected, NativeAccessSpecifierProtected)
	TArray<class UBFGWidget_TutorialPage*>        M_apTutorialPagesPendingForDelete;                 // 0x00B8(0x0010)(ExportObject, ZeroConstructor, ContainsInstancedReference, Protected, NativeAccessSpecifierProtected)
	TScriptInterface<class IBFGTutorialPageTarget> M_pTutorialTarget;                                 // 0x00C8(0x0010)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, UObjectWrapper, NativeAccessSpecifierProtected)
	class UBFGWidget_HUD_TutorialIndicator*       M_pTutorialIndicator;                              // 0x00D8(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TSoftClassPtr<class UClass>                   M_pPausedTutorialClass;                            // 0x00E0(0x0028)(Edit, BlueprintVisible, BlueprintReadOnly, DisableEditOnInstance, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)

public:
	void DismissTutorialOnTop();
	void ExpandTutorialOnTop();
	class UBFGWidget_TutorialPage* FindTutorial(class UBFGDataAsset_TutorialPage* _pContext);
	class UBFGWidget_TutorialPage* GetTutorialOnTop();
	void OnInputDeviceChanged(bool _bIsGamepad);
	void OnTutorialHandbookClosed(class UBFGWidget_TutorialPage* _pSource);
	void OnTutorialIndicatorAnimationStateChanged(EBFGTutorialIndicatorAnimationState _eCurrentState);
	void OnTutorialPageStyleTransitionFinished(class UBFGWidget_TutorialPage* _pSource, EBFGTutorialPageDisplayStyle _eDisplayStyle);
	void OpenHandbookWithTutorialOnTop();
	void PopTutorial();
	void PushTutorial(class UBFGDataAsset_TutorialPage* _pContext);
	void RemoveAllTutorials();
	void RemoveTutorial(class UBFGDataAsset_TutorialPage* _pContext);
	void SetTarget(TScriptInterface<class IBFGTutorialPageTarget> _pTarget);
	void ShowPausedTutorial(TSoftObjectPtr<class UBFGDataAsset_PausedTutorial> _pTutorial);
	void ShrinkTutorialOnTop(bool _bHinted);
	void UnlockTutorial(class UBFGDataAsset_TutorialPage* _pTutorial);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"BFGTutorialManager">();
	}
	static class UBFGTutorialManager* GetDefaultObj()
	{
		return GetDefaultObjImpl<UBFGTutorialManager>();
	}
};
static_assert(alignof(UBFGTutorialManager) == 0x000008, "Wrong alignment on UBFGTutorialManager");
static_assert(sizeof(UBFGTutorialManager) == 0x000108, "Wrong size on UBFGTutorialManager");
static_assert(offsetof(UBFGTutorialManager, M_pTutorialPageClass) == 0x000030, "Member 'UBFGTutorialManager::M_pTutorialPageClass' has a wrong offset!");
static_assert(offsetof(UBFGTutorialManager, M_pTutorialHandbookClass) == 0x000058, "Member 'UBFGTutorialManager::M_pTutorialHandbookClass' has a wrong offset!");
static_assert(offsetof(UBFGTutorialManager, M_fExpandedDuration) == 0x000080, "Member 'UBFGTutorialManager::M_fExpandedDuration' has a wrong offset!");
static_assert(offsetof(UBFGTutorialManager, M_fExpandedTimer) == 0x000084, "Member 'UBFGTutorialManager::M_fExpandedTimer' has a wrong offset!");
static_assert(offsetof(UBFGTutorialManager, M_fAliveDuration) == 0x000088, "Member 'UBFGTutorialManager::M_fAliveDuration' has a wrong offset!");
static_assert(offsetof(UBFGTutorialManager, M_fAliveTimer) == 0x00008C, "Member 'UBFGTutorialManager::M_fAliveTimer' has a wrong offset!");
static_assert(offsetof(UBFGTutorialManager, M_iStackSize) == 0x000090, "Member 'UBFGTutorialManager::M_iStackSize' has a wrong offset!");
static_assert(offsetof(UBFGTutorialManager, M_bPopTutorialsExceedingStackSize) == 0x000094, "Member 'UBFGTutorialManager::M_bPopTutorialsExceedingStackSize' has a wrong offset!");
static_assert(offsetof(UBFGTutorialManager, M_fIndicatorDurationPopup) == 0x000098, "Member 'UBFGTutorialManager::M_fIndicatorDurationPopup' has a wrong offset!");
static_assert(offsetof(UBFGTutorialManager, M_fIndicatorDurationInterpolate) == 0x00009C, "Member 'UBFGTutorialManager::M_fIndicatorDurationInterpolate' has a wrong offset!");
static_assert(offsetof(UBFGTutorialManager, M_vIndicatorOrigin) == 0x0000A0, "Member 'UBFGTutorialManager::M_vIndicatorOrigin' has a wrong offset!");
static_assert(offsetof(UBFGTutorialManager, M_apTutorialPages) == 0x0000A8, "Member 'UBFGTutorialManager::M_apTutorialPages' has a wrong offset!");
static_assert(offsetof(UBFGTutorialManager, M_apTutorialPagesPendingForDelete) == 0x0000B8, "Member 'UBFGTutorialManager::M_apTutorialPagesPendingForDelete' has a wrong offset!");
static_assert(offsetof(UBFGTutorialManager, M_pTutorialTarget) == 0x0000C8, "Member 'UBFGTutorialManager::M_pTutorialTarget' has a wrong offset!");
static_assert(offsetof(UBFGTutorialManager, M_pTutorialIndicator) == 0x0000D8, "Member 'UBFGTutorialManager::M_pTutorialIndicator' has a wrong offset!");
static_assert(offsetof(UBFGTutorialManager, M_pPausedTutorialClass) == 0x0000E0, "Member 'UBFGTutorialManager::M_pPausedTutorialClass' has a wrong offset!");

// Class BFGCore.BFGNPCEnemyController
// 0x0000 (0x0600 - 0x0600)
class ABFGNPCEnemyController : public ABFGNPCHumanController
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"BFGNPCEnemyController">();
	}
	static class ABFGNPCEnemyController* GetDefaultObj()
	{
		return GetDefaultObjImpl<ABFGNPCEnemyController>();
	}
};
static_assert(alignof(ABFGNPCEnemyController) == 0x000008, "Wrong alignment on ABFGNPCEnemyController");
static_assert(sizeof(ABFGNPCEnemyController) == 0x000600, "Wrong size on ABFGNPCEnemyController");

// Class BFGCore.BFGNPCLowRes
// 0x00B8 (0x0490 - 0x03D8)
class ABFGNPCLowRes final : public AActor
{
public:
	class UCapsuleComponent*                      M_pCapsuleComponent;                               // 0x03D8(0x0008)(Edit, BlueprintVisible, ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class USkeletalMeshComponent*                 M_pMesh;                                           // 0x03E0(0x0008)(Edit, BlueprintVisible, ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UBFGNetworkPathAgentComponent*          M_pNetworkPathAgentComponent;                      // 0x03E8(0x0008)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, EditConst, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TSoftObjectPtr<class UDataTable>              M_pInteractAnimationTable;                         // 0x03F0(0x0028)(Transient, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	int32                                         M_iSharingAnimationState;                          // 0x0418(0x0004)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_41C[0x14];                                     // 0x041C(0x0014)(Fixing Size After Last Property [ Dumper-7 ])
	TMap<EBFGNPCCharacter_MoveSpeed, float>       M_aMaxMoveSpeed;                                   // 0x0430(0x0050)(ZeroConstructor, Transient, Protected, NativeAccessSpecifierProtected)
	EBFGNPCCharacter_MoveSpeed                    M_eMoveSpeed;                                      // 0x0480(0x0001)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          M_bIsFourFeet;                                     // 0x0481(0x0001)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          M_bIsPlayingInteract;                              // 0x0482(0x0001)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          M_bCanBeAnimated;                                  // 0x0483(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	EBFGAnimation_Interact                        M_eCurrentInteractAnimation;                       // 0x0484(0x0001)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_485[0x3];                                      // 0x0485(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         M_fHeight;                                         // 0x0488(0x0004)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         M_fDefaultLowTickRate;                             // 0x048C(0x0004)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)

public:
	int32 GetAnimationState() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"BFGNPCLowRes">();
	}
	static class ABFGNPCLowRes* GetDefaultObj()
	{
		return GetDefaultObjImpl<ABFGNPCLowRes>();
	}
};
static_assert(alignof(ABFGNPCLowRes) == 0x000008, "Wrong alignment on ABFGNPCLowRes");
static_assert(sizeof(ABFGNPCLowRes) == 0x000490, "Wrong size on ABFGNPCLowRes");
static_assert(offsetof(ABFGNPCLowRes, M_pCapsuleComponent) == 0x0003D8, "Member 'ABFGNPCLowRes::M_pCapsuleComponent' has a wrong offset!");
static_assert(offsetof(ABFGNPCLowRes, M_pMesh) == 0x0003E0, "Member 'ABFGNPCLowRes::M_pMesh' has a wrong offset!");
static_assert(offsetof(ABFGNPCLowRes, M_pNetworkPathAgentComponent) == 0x0003E8, "Member 'ABFGNPCLowRes::M_pNetworkPathAgentComponent' has a wrong offset!");
static_assert(offsetof(ABFGNPCLowRes, M_pInteractAnimationTable) == 0x0003F0, "Member 'ABFGNPCLowRes::M_pInteractAnimationTable' has a wrong offset!");
static_assert(offsetof(ABFGNPCLowRes, M_iSharingAnimationState) == 0x000418, "Member 'ABFGNPCLowRes::M_iSharingAnimationState' has a wrong offset!");
static_assert(offsetof(ABFGNPCLowRes, M_aMaxMoveSpeed) == 0x000430, "Member 'ABFGNPCLowRes::M_aMaxMoveSpeed' has a wrong offset!");
static_assert(offsetof(ABFGNPCLowRes, M_eMoveSpeed) == 0x000480, "Member 'ABFGNPCLowRes::M_eMoveSpeed' has a wrong offset!");
static_assert(offsetof(ABFGNPCLowRes, M_bIsFourFeet) == 0x000481, "Member 'ABFGNPCLowRes::M_bIsFourFeet' has a wrong offset!");
static_assert(offsetof(ABFGNPCLowRes, M_bIsPlayingInteract) == 0x000482, "Member 'ABFGNPCLowRes::M_bIsPlayingInteract' has a wrong offset!");
static_assert(offsetof(ABFGNPCLowRes, M_bCanBeAnimated) == 0x000483, "Member 'ABFGNPCLowRes::M_bCanBeAnimated' has a wrong offset!");
static_assert(offsetof(ABFGNPCLowRes, M_eCurrentInteractAnimation) == 0x000484, "Member 'ABFGNPCLowRes::M_eCurrentInteractAnimation' has a wrong offset!");
static_assert(offsetof(ABFGNPCLowRes, M_fHeight) == 0x000488, "Member 'ABFGNPCLowRes::M_fHeight' has a wrong offset!");
static_assert(offsetof(ABFGNPCLowRes, M_fDefaultLowTickRate) == 0x00048C, "Member 'ABFGNPCLowRes::M_fDefaultLowTickRate' has a wrong offset!");

// Class BFGCore.BFGObjectiveEntitlement
// 0x0040 (0x0068 - 0x0028)
class UBFGObjectiveEntitlement final : public UObject
{
public:
	uint8                                         Pad_28[0x8];                                       // 0x0028(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	struct FBFGSystemData_ObjectiveMarker_Entitlements M_Data;                                            // 0x0030(0x0038)(Transient, Protected, NativeAccessSpecifierProtected)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"BFGObjectiveEntitlement">();
	}
	static class UBFGObjectiveEntitlement* GetDefaultObj()
	{
		return GetDefaultObjImpl<UBFGObjectiveEntitlement>();
	}
};
static_assert(alignof(UBFGObjectiveEntitlement) == 0x000008, "Wrong alignment on UBFGObjectiveEntitlement");
static_assert(sizeof(UBFGObjectiveEntitlement) == 0x000068, "Wrong size on UBFGObjectiveEntitlement");
static_assert(offsetof(UBFGObjectiveEntitlement, M_Data) == 0x000030, "Member 'UBFGObjectiveEntitlement::M_Data' has a wrong offset!");

// Class BFGCore.BFGVoiceoverCharacterInterface
// 0x0000 (0x0028 - 0x0028)
class IBFGVoiceoverCharacterInterface final : public IInterface
{
public:
	class FName GetVoice();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"BFGVoiceoverCharacterInterface">();
	}
	static class IBFGVoiceoverCharacterInterface* GetDefaultObj()
	{
		return GetDefaultObjImpl<IBFGVoiceoverCharacterInterface>();
	}
};
static_assert(alignof(IBFGVoiceoverCharacterInterface) == 0x000008, "Wrong alignment on IBFGVoiceoverCharacterInterface");
static_assert(sizeof(IBFGVoiceoverCharacterInterface) == 0x000028, "Wrong size on IBFGVoiceoverCharacterInterface");

// Class BFGCore.BFGObjectiveInterface
// 0x0000 (0x0028 - 0x0028)
class IBFGObjectiveInterface final : public IInterface
{
public:
	struct FBFGObjectiveMarkerInfoEntry GetObjectiveMarkerAttachment(const struct FBFGObjectiveMarkerInfoEntry& _entry) const;
	bool IsObjectiveMarkerDisabled() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"BFGObjectiveInterface">();
	}
	static class IBFGObjectiveInterface* GetDefaultObj()
	{
		return GetDefaultObjImpl<IBFGObjectiveInterface>();
	}
};
static_assert(alignof(IBFGObjectiveInterface) == 0x000008, "Wrong alignment on IBFGObjectiveInterface");
static_assert(sizeof(IBFGObjectiveInterface) == 0x000028, "Wrong size on IBFGObjectiveInterface");

// Class BFGCore.BFGObjectiveMarker
// 0x00A0 (0x0478 - 0x03D8)
class ABFGObjectiveMarker : public AActor
{
public:
	class USceneComponent*                        M_pRootComponent;                                  // 0x03D8(0x0008)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, EditConst, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	UMulticastDelegateProperty_                   M_OnMarkerEnabled;                                 // 0x03E0(0x0018)(ZeroConstructor, InstancedReference, NativeAccessSpecifierPublic)
	UMulticastDelegateProperty_                   M_OnMarkerAttached;                                // 0x03F8(0x0018)(ZeroConstructor, InstancedReference, NativeAccessSpecifierPublic)
	UMulticastDelegateProperty_                   M_OnMarkerDied;                                    // 0x0410(0x0018)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	bool                                          M_bIsActive;                                       // 0x0428(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_429[0x7];                                      // 0x0429(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	struct FBFGObjectiveMarkerInfoEntry           M_info;                                            // 0x0430(0x0040)(BlueprintVisible, BlueprintReadOnly, Transient, ContainsInstancedReference, Protected, NativeAccessSpecifierProtected)
	class AActor*                                 M_pObjective;                                      // 0x0470(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)

public:
	void Action__DelegateSignature();
	void ActionBool__DelegateSignature(bool _bEnabled);
	void ActionMarkerInfo__DelegateSignature(const struct FBFGObjectiveMarkerInfoEntry& _markerInfo);
	void AttachToObjective(class AActor* _pActor, class USceneComponent* _pComponent, class FName _strSocket);
	void HideMarker();
	void RequestRemoveMarker();
	void ShowMarker();

	const struct FBFGObjectiveMarkerInfoEntry GetMarkerInfo() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"BFGObjectiveMarker">();
	}
	static class ABFGObjectiveMarker* GetDefaultObj()
	{
		return GetDefaultObjImpl<ABFGObjectiveMarker>();
	}
};
static_assert(alignof(ABFGObjectiveMarker) == 0x000008, "Wrong alignment on ABFGObjectiveMarker");
static_assert(sizeof(ABFGObjectiveMarker) == 0x000478, "Wrong size on ABFGObjectiveMarker");
static_assert(offsetof(ABFGObjectiveMarker, M_pRootComponent) == 0x0003D8, "Member 'ABFGObjectiveMarker::M_pRootComponent' has a wrong offset!");
static_assert(offsetof(ABFGObjectiveMarker, M_OnMarkerEnabled) == 0x0003E0, "Member 'ABFGObjectiveMarker::M_OnMarkerEnabled' has a wrong offset!");
static_assert(offsetof(ABFGObjectiveMarker, M_OnMarkerAttached) == 0x0003F8, "Member 'ABFGObjectiveMarker::M_OnMarkerAttached' has a wrong offset!");
static_assert(offsetof(ABFGObjectiveMarker, M_OnMarkerDied) == 0x000410, "Member 'ABFGObjectiveMarker::M_OnMarkerDied' has a wrong offset!");
static_assert(offsetof(ABFGObjectiveMarker, M_bIsActive) == 0x000428, "Member 'ABFGObjectiveMarker::M_bIsActive' has a wrong offset!");
static_assert(offsetof(ABFGObjectiveMarker, M_info) == 0x000430, "Member 'ABFGObjectiveMarker::M_info' has a wrong offset!");
static_assert(offsetof(ABFGObjectiveMarker, M_pObjective) == 0x000470, "Member 'ABFGObjectiveMarker::M_pObjective' has a wrong offset!");

// Class BFGCore.BFGObjectiveMarkerTemplate
// 0x0018 (0x0048 - 0x0030)
class UBFGObjectiveMarkerTemplate final : public UDataAsset
{
public:
	TArray<struct FBFGObjectiveMarkerInfoEntry>   M_aMarkerEntries;                                  // 0x0030(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, ContainsInstancedReference, NativeAccessSpecifierPublic)
	int32                                         M_markerTypes;                                     // 0x0040(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_44[0x4];                                       // 0x0044(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"BFGObjectiveMarkerTemplate">();
	}
	static class UBFGObjectiveMarkerTemplate* GetDefaultObj()
	{
		return GetDefaultObjImpl<UBFGObjectiveMarkerTemplate>();
	}
};
static_assert(alignof(UBFGObjectiveMarkerTemplate) == 0x000008, "Wrong alignment on UBFGObjectiveMarkerTemplate");
static_assert(sizeof(UBFGObjectiveMarkerTemplate) == 0x000048, "Wrong size on UBFGObjectiveMarkerTemplate");
static_assert(offsetof(UBFGObjectiveMarkerTemplate, M_aMarkerEntries) == 0x000030, "Member 'UBFGObjectiveMarkerTemplate::M_aMarkerEntries' has a wrong offset!");
static_assert(offsetof(UBFGObjectiveMarkerTemplate, M_markerTypes) == 0x000040, "Member 'UBFGObjectiveMarkerTemplate::M_markerTypes' has a wrong offset!");

// Class BFGCore.BFGObjectiveMarkerInstanceList
// 0x0028 (0x0050 - 0x0028)
class UBFGObjectiveMarkerInstanceList final : public UObject
{
public:
	class UBFGObjectiveMarkerGroup*               M_pGroup;                                          // 0x0028(0x0008)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class AActor*                                 M_pObjective;                                      // 0x0030(0x0008)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_38[0x8];                                       // 0x0038(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<class ABFGObjectiveMarker*>            M_aMarkers;                                        // 0x0040(0x0010)(ZeroConstructor, Transient, Protected, NativeAccessSpecifierProtected)

public:
	void OnDeathStatChanged(class AActor* _pOwner, class UBFGActorStat_Bool* _pStat);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"BFGObjectiveMarkerInstanceList">();
	}
	static class UBFGObjectiveMarkerInstanceList* GetDefaultObj()
	{
		return GetDefaultObjImpl<UBFGObjectiveMarkerInstanceList>();
	}
};
static_assert(alignof(UBFGObjectiveMarkerInstanceList) == 0x000008, "Wrong alignment on UBFGObjectiveMarkerInstanceList");
static_assert(sizeof(UBFGObjectiveMarkerInstanceList) == 0x000050, "Wrong size on UBFGObjectiveMarkerInstanceList");
static_assert(offsetof(UBFGObjectiveMarkerInstanceList, M_pGroup) == 0x000028, "Member 'UBFGObjectiveMarkerInstanceList::M_pGroup' has a wrong offset!");
static_assert(offsetof(UBFGObjectiveMarkerInstanceList, M_pObjective) == 0x000030, "Member 'UBFGObjectiveMarkerInstanceList::M_pObjective' has a wrong offset!");
static_assert(offsetof(UBFGObjectiveMarkerInstanceList, M_aMarkers) == 0x000040, "Member 'UBFGObjectiveMarkerInstanceList::M_aMarkers' has a wrong offset!");

// Class BFGCore.BFGObjectiveMarkerSettings
// 0x0068 (0x00A0 - 0x0038)
class UBFGObjectiveMarkerSettings final : public UDeveloperSettings
{
public:
	TSoftObjectPtr<class UBFGObjectiveMarkerTemplate> M_pDefaultMarkerTemplate;                          // 0x0038(0x0028)(Edit, BlueprintVisible, BlueprintReadOnly, Config, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UBFGObjectiveMarkerTemplate*            M_pTemplateLoaded;                                 // 0x0060(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FGameplayTagContainer                  M_tagsDisableObjective_GameplayEffects;            // 0x0068(0x0020)(Edit, BlueprintVisible, BlueprintReadOnly, Config, NativeAccessSpecifierPublic)
	struct FBFGObjectiveMarkerSystemSettings      M_oObjectiveMarkerSystemSettings;                  // 0x0088(0x0018)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Config, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)

public:
	static class UBFGObjectiveMarkerSettings* GetSettings();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"BFGObjectiveMarkerSettings">();
	}
	static class UBFGObjectiveMarkerSettings* GetDefaultObj()
	{
		return GetDefaultObjImpl<UBFGObjectiveMarkerSettings>();
	}
};
static_assert(alignof(UBFGObjectiveMarkerSettings) == 0x000008, "Wrong alignment on UBFGObjectiveMarkerSettings");
static_assert(sizeof(UBFGObjectiveMarkerSettings) == 0x0000A0, "Wrong size on UBFGObjectiveMarkerSettings");
static_assert(offsetof(UBFGObjectiveMarkerSettings, M_pDefaultMarkerTemplate) == 0x000038, "Member 'UBFGObjectiveMarkerSettings::M_pDefaultMarkerTemplate' has a wrong offset!");
static_assert(offsetof(UBFGObjectiveMarkerSettings, M_pTemplateLoaded) == 0x000060, "Member 'UBFGObjectiveMarkerSettings::M_pTemplateLoaded' has a wrong offset!");
static_assert(offsetof(UBFGObjectiveMarkerSettings, M_tagsDisableObjective_GameplayEffects) == 0x000068, "Member 'UBFGObjectiveMarkerSettings::M_tagsDisableObjective_GameplayEffects' has a wrong offset!");
static_assert(offsetof(UBFGObjectiveMarkerSettings, M_oObjectiveMarkerSystemSettings) == 0x000088, "Member 'UBFGObjectiveMarkerSettings::M_oObjectiveMarkerSystemSettings' has a wrong offset!");

// Class BFGCore.BFGObjectRespawnManager
// 0x0048 (0x0078 - 0x0030)
class UBFGObjectRespawnManager final : public UBFGGameSystem
{
public:
	class ABFGGameState*                          M_pGameState;                                      // 0x0030(0x0008)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_38[0x40];                                      // 0x0038(0x0040)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"BFGObjectRespawnManager">();
	}
	static class UBFGObjectRespawnManager* GetDefaultObj()
	{
		return GetDefaultObjImpl<UBFGObjectRespawnManager>();
	}
};
static_assert(alignof(UBFGObjectRespawnManager) == 0x000008, "Wrong alignment on UBFGObjectRespawnManager");
static_assert(sizeof(UBFGObjectRespawnManager) == 0x000078, "Wrong size on UBFGObjectRespawnManager");
static_assert(offsetof(UBFGObjectRespawnManager, M_pGameState) == 0x000030, "Member 'UBFGObjectRespawnManager::M_pGameState' has a wrong offset!");

// Class BFGCore.BFGVoiceoverPlaybackComponent_NoSubtitle
// 0x0010 (0x02A8 - 0x0298)
class UBFGVoiceoverPlaybackComponent_NoSubtitle final : public UBFGVoiceoverPlaybackComponent_Simple
{
public:
	uint8                                         Pad_298[0x10];                                     // 0x0298(0x0010)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"BFGVoiceoverPlaybackComponent_NoSubtitle">();
	}
	static class UBFGVoiceoverPlaybackComponent_NoSubtitle* GetDefaultObj()
	{
		return GetDefaultObjImpl<UBFGVoiceoverPlaybackComponent_NoSubtitle>();
	}
};
static_assert(alignof(UBFGVoiceoverPlaybackComponent_NoSubtitle) == 0x000008, "Wrong alignment on UBFGVoiceoverPlaybackComponent_NoSubtitle");
static_assert(sizeof(UBFGVoiceoverPlaybackComponent_NoSubtitle) == 0x0002A8, "Wrong size on UBFGVoiceoverPlaybackComponent_NoSubtitle");

// Class BFGCore.BFGOceanManager
// 0x0010 (0x0040 - 0x0030)
class UBFGOceanManager final : public UBFGGameSystem
{
public:
	class ABFGGameState*                          M_pGameState;                                      // 0x0030(0x0008)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class ABFGActorOcean*                         M_pActor;                                          // 0x0038(0x0008)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)

public:
	class ABFGActorOcean* GetOceanActor() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"BFGOceanManager">();
	}
	static class UBFGOceanManager* GetDefaultObj()
	{
		return GetDefaultObjImpl<UBFGOceanManager>();
	}
};
static_assert(alignof(UBFGOceanManager) == 0x000008, "Wrong alignment on UBFGOceanManager");
static_assert(sizeof(UBFGOceanManager) == 0x000040, "Wrong size on UBFGOceanManager");
static_assert(offsetof(UBFGOceanManager, M_pGameState) == 0x000030, "Member 'UBFGOceanManager::M_pGameState' has a wrong offset!");
static_assert(offsetof(UBFGOceanManager, M_pActor) == 0x000038, "Member 'UBFGOceanManager::M_pActor' has a wrong offset!");

// Class BFGCore.BFGOverheadWidgetManager
// 0x0100 (0x0130 - 0x0030)
class UBFGOverheadWidgetManager : public UBFGGameSystem
{
public:
	class ABFGGameState*                          M_pGameState;                                      // 0x0030(0x0008)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TArray<struct FBFGOverheadWidgetEntry>        M_aActiveEntries;                                  // 0x0038(0x0010)(ZeroConstructor, Protected, NativeAccessSpecifierProtected)
	TArray<struct FBFGOverheadWidgetTemplate>     M_aTemplates;                                      // 0x0048(0x0010)(ZeroConstructor, Transient, Protected, NativeAccessSpecifierProtected)
	uint8                                         Pad_58[0x50];                                      // 0x0058(0x0050)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<class FString>                         M_aPreloadStrings;                                 // 0x00A8(0x0010)(Edit, ZeroConstructor, DisableEditOnInstance, Protected, NativeAccessSpecifierProtected)
	class UCurveFloat*                            M_pSizeCurve;                                      // 0x00B8(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UCurveFloat*                            M_pOpacityCurve;                                   // 0x00C0(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         M_fEffectLifeTime;                                 // 0x00C8(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         M_fHorizontalSpeed;                                // 0x00CC(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         M_fVerticalSpeed;                                  // 0x00D0(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         M_fUFOMultiplier;                                  // 0x00D4(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TSubclassOf<class UBFGWidget_Overhead>        M_pWidgetClass;                                    // 0x00D8(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UBFGWidget_Overhead*                    M_pWidget;                                         // 0x00E0(0x0008)(ExportObject, ZeroConstructor, Transient, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UBFGWidget_OverheadPanel*               M_pPanel;                                          // 0x00E8(0x0008)(ExportObject, ZeroConstructor, Transient, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_F0[0x40];                                      // 0x00F0(0x0040)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void ActionRadarUpdate__DelegateSignature(class UBFGOverheadWidgetManager* _pRadarManager);
	void AddWidgetAtLocation(const struct FVector& _vLocation, const class FString& _Text);
	void AddWidgetAttachedToActor(class AActor* _pAnchor, const class FString& _Text);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"BFGOverheadWidgetManager">();
	}
	static class UBFGOverheadWidgetManager* GetDefaultObj()
	{
		return GetDefaultObjImpl<UBFGOverheadWidgetManager>();
	}
};
static_assert(alignof(UBFGOverheadWidgetManager) == 0x000008, "Wrong alignment on UBFGOverheadWidgetManager");
static_assert(sizeof(UBFGOverheadWidgetManager) == 0x000130, "Wrong size on UBFGOverheadWidgetManager");
static_assert(offsetof(UBFGOverheadWidgetManager, M_pGameState) == 0x000030, "Member 'UBFGOverheadWidgetManager::M_pGameState' has a wrong offset!");
static_assert(offsetof(UBFGOverheadWidgetManager, M_aActiveEntries) == 0x000038, "Member 'UBFGOverheadWidgetManager::M_aActiveEntries' has a wrong offset!");
static_assert(offsetof(UBFGOverheadWidgetManager, M_aTemplates) == 0x000048, "Member 'UBFGOverheadWidgetManager::M_aTemplates' has a wrong offset!");
static_assert(offsetof(UBFGOverheadWidgetManager, M_aPreloadStrings) == 0x0000A8, "Member 'UBFGOverheadWidgetManager::M_aPreloadStrings' has a wrong offset!");
static_assert(offsetof(UBFGOverheadWidgetManager, M_pSizeCurve) == 0x0000B8, "Member 'UBFGOverheadWidgetManager::M_pSizeCurve' has a wrong offset!");
static_assert(offsetof(UBFGOverheadWidgetManager, M_pOpacityCurve) == 0x0000C0, "Member 'UBFGOverheadWidgetManager::M_pOpacityCurve' has a wrong offset!");
static_assert(offsetof(UBFGOverheadWidgetManager, M_fEffectLifeTime) == 0x0000C8, "Member 'UBFGOverheadWidgetManager::M_fEffectLifeTime' has a wrong offset!");
static_assert(offsetof(UBFGOverheadWidgetManager, M_fHorizontalSpeed) == 0x0000CC, "Member 'UBFGOverheadWidgetManager::M_fHorizontalSpeed' has a wrong offset!");
static_assert(offsetof(UBFGOverheadWidgetManager, M_fVerticalSpeed) == 0x0000D0, "Member 'UBFGOverheadWidgetManager::M_fVerticalSpeed' has a wrong offset!");
static_assert(offsetof(UBFGOverheadWidgetManager, M_fUFOMultiplier) == 0x0000D4, "Member 'UBFGOverheadWidgetManager::M_fUFOMultiplier' has a wrong offset!");
static_assert(offsetof(UBFGOverheadWidgetManager, M_pWidgetClass) == 0x0000D8, "Member 'UBFGOverheadWidgetManager::M_pWidgetClass' has a wrong offset!");
static_assert(offsetof(UBFGOverheadWidgetManager, M_pWidget) == 0x0000E0, "Member 'UBFGOverheadWidgetManager::M_pWidget' has a wrong offset!");
static_assert(offsetof(UBFGOverheadWidgetManager, M_pPanel) == 0x0000E8, "Member 'UBFGOverheadWidgetManager::M_pPanel' has a wrong offset!");

// Class BFGCore.BFGVoiceoverQueueInterface
// 0x0000 (0x0028 - 0x0028)
class IBFGVoiceoverQueueInterface final : public IInterface
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"BFGVoiceoverQueueInterface">();
	}
	static class IBFGVoiceoverQueueInterface* GetDefaultObj()
	{
		return GetDefaultObjImpl<IBFGVoiceoverQueueInterface>();
	}
};
static_assert(alignof(IBFGVoiceoverQueueInterface) == 0x000008, "Wrong alignment on IBFGVoiceoverQueueInterface");
static_assert(sizeof(IBFGVoiceoverQueueInterface) == 0x000028, "Wrong size on IBFGVoiceoverQueueInterface");

// Class BFGCore.BFGPathFollowingComponent
// 0x0010 (0x0330 - 0x0320)
class UBFGPathFollowingComponent final : public UCrowdFollowingComponent
{
public:
	float                                         M_fCylinderRadiusOverride;                         // 0x0320(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         M_fCylinderHeightOverride;                         // 0x0324(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          M_bStoppingEnabled;                                // 0x0328(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          M_bIsStoppingMovement;                             // 0x0329(0x0001)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          M_bStopMovementAtPathEnd;                          // 0x032A(0x0001)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_32B[0x5];                                      // 0x032B(0x0005)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"BFGPathFollowingComponent">();
	}
	static class UBFGPathFollowingComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UBFGPathFollowingComponent>();
	}
};
static_assert(alignof(UBFGPathFollowingComponent) == 0x000008, "Wrong alignment on UBFGPathFollowingComponent");
static_assert(sizeof(UBFGPathFollowingComponent) == 0x000330, "Wrong size on UBFGPathFollowingComponent");
static_assert(offsetof(UBFGPathFollowingComponent, M_fCylinderRadiusOverride) == 0x000320, "Member 'UBFGPathFollowingComponent::M_fCylinderRadiusOverride' has a wrong offset!");
static_assert(offsetof(UBFGPathFollowingComponent, M_fCylinderHeightOverride) == 0x000324, "Member 'UBFGPathFollowingComponent::M_fCylinderHeightOverride' has a wrong offset!");
static_assert(offsetof(UBFGPathFollowingComponent, M_bStoppingEnabled) == 0x000328, "Member 'UBFGPathFollowingComponent::M_bStoppingEnabled' has a wrong offset!");
static_assert(offsetof(UBFGPathFollowingComponent, M_bIsStoppingMovement) == 0x000329, "Member 'UBFGPathFollowingComponent::M_bIsStoppingMovement' has a wrong offset!");
static_assert(offsetof(UBFGPathFollowingComponent, M_bStopMovementAtPathEnd) == 0x00032A, "Member 'UBFGPathFollowingComponent::M_bStopMovementAtPathEnd' has a wrong offset!");

// Class BFGCore.BFGPattern_Beam
// 0x0030 (0x0428 - 0x03F8)
class ABFGPattern_Beam final : public ABFGPattern_Base
{
public:
	float                                         M_fInitialTrackingSpeed;                           // 0x03F8(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         M_fFinalTrackingSpeed;                             // 0x03FC(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         M_fTimeToReachFinalTrackingSpeed;                  // 0x0400(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         M_fBeamFanAngle;                                   // 0x0404(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         M_fBeamFanAngleExpandTime;                         // 0x0408(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_40C[0x4];                                      // 0x040C(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class UCurveVector*                           M_pRotationCurve;                                  // 0x0410(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         M_fRotationDuration;                               // 0x0418(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         M_fRotationDelay;                                  // 0x041C(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EBFGPatternRotationMode                       M_eRotationMode;                                   // 0x0420(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_421[0x7];                                      // 0x0421(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"BFGPattern_Beam">();
	}
	static class ABFGPattern_Beam* GetDefaultObj()
	{
		return GetDefaultObjImpl<ABFGPattern_Beam>();
	}
};
static_assert(alignof(ABFGPattern_Beam) == 0x000008, "Wrong alignment on ABFGPattern_Beam");
static_assert(sizeof(ABFGPattern_Beam) == 0x000428, "Wrong size on ABFGPattern_Beam");
static_assert(offsetof(ABFGPattern_Beam, M_fInitialTrackingSpeed) == 0x0003F8, "Member 'ABFGPattern_Beam::M_fInitialTrackingSpeed' has a wrong offset!");
static_assert(offsetof(ABFGPattern_Beam, M_fFinalTrackingSpeed) == 0x0003FC, "Member 'ABFGPattern_Beam::M_fFinalTrackingSpeed' has a wrong offset!");
static_assert(offsetof(ABFGPattern_Beam, M_fTimeToReachFinalTrackingSpeed) == 0x000400, "Member 'ABFGPattern_Beam::M_fTimeToReachFinalTrackingSpeed' has a wrong offset!");
static_assert(offsetof(ABFGPattern_Beam, M_fBeamFanAngle) == 0x000404, "Member 'ABFGPattern_Beam::M_fBeamFanAngle' has a wrong offset!");
static_assert(offsetof(ABFGPattern_Beam, M_fBeamFanAngleExpandTime) == 0x000408, "Member 'ABFGPattern_Beam::M_fBeamFanAngleExpandTime' has a wrong offset!");
static_assert(offsetof(ABFGPattern_Beam, M_pRotationCurve) == 0x000410, "Member 'ABFGPattern_Beam::M_pRotationCurve' has a wrong offset!");
static_assert(offsetof(ABFGPattern_Beam, M_fRotationDuration) == 0x000418, "Member 'ABFGPattern_Beam::M_fRotationDuration' has a wrong offset!");
static_assert(offsetof(ABFGPattern_Beam, M_fRotationDelay) == 0x00041C, "Member 'ABFGPattern_Beam::M_fRotationDelay' has a wrong offset!");
static_assert(offsetof(ABFGPattern_Beam, M_eRotationMode) == 0x000420, "Member 'ABFGPattern_Beam::M_eRotationMode' has a wrong offset!");

// Class BFGCore.BFGSensor_BehaviourStateLock
// 0x0000 (0x0040 - 0x0040)
class UBFGSensor_BehaviourStateLock final : public UBFGSensor
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"BFGSensor_BehaviourStateLock">();
	}
	static class UBFGSensor_BehaviourStateLock* GetDefaultObj()
	{
		return GetDefaultObjImpl<UBFGSensor_BehaviourStateLock>();
	}
};
static_assert(alignof(UBFGSensor_BehaviourStateLock) == 0x000008, "Wrong alignment on UBFGSensor_BehaviourStateLock");
static_assert(sizeof(UBFGSensor_BehaviourStateLock) == 0x000040, "Wrong size on UBFGSensor_BehaviourStateLock");

// Class BFGCore.BFGPattern_Projectile
// 0x0028 (0x0420 - 0x03F8)
class ABFGPattern_Projectile : public ABFGPattern_Base
{
public:
	struct FRotator                               M_rInitialRotation;                                // 0x03F8(0x000C)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
	struct FRotator                               M_rTotalRotation;                                  // 0x0404(0x000C)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
	float                                         M_fRotationDuration;                               // 0x0410(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         M_fRotationDelay;                                  // 0x0414(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EBFGPatternRotationMode                       M_eRotationMode;                                   // 0x0418(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_419[0x7];                                      // 0x0419(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"BFGPattern_Projectile">();
	}
	static class ABFGPattern_Projectile* GetDefaultObj()
	{
		return GetDefaultObjImpl<ABFGPattern_Projectile>();
	}
};
static_assert(alignof(ABFGPattern_Projectile) == 0x000008, "Wrong alignment on ABFGPattern_Projectile");
static_assert(sizeof(ABFGPattern_Projectile) == 0x000420, "Wrong size on ABFGPattern_Projectile");
static_assert(offsetof(ABFGPattern_Projectile, M_rInitialRotation) == 0x0003F8, "Member 'ABFGPattern_Projectile::M_rInitialRotation' has a wrong offset!");
static_assert(offsetof(ABFGPattern_Projectile, M_rTotalRotation) == 0x000404, "Member 'ABFGPattern_Projectile::M_rTotalRotation' has a wrong offset!");
static_assert(offsetof(ABFGPattern_Projectile, M_fRotationDuration) == 0x000410, "Member 'ABFGPattern_Projectile::M_fRotationDuration' has a wrong offset!");
static_assert(offsetof(ABFGPattern_Projectile, M_fRotationDelay) == 0x000414, "Member 'ABFGPattern_Projectile::M_fRotationDelay' has a wrong offset!");
static_assert(offsetof(ABFGPattern_Projectile, M_eRotationMode) == 0x000418, "Member 'ABFGPattern_Projectile::M_eRotationMode' has a wrong offset!");

// Class BFGCore.BFGPatternTargetMarker
// 0x0018 (0x02B0 - 0x0298)
class UBFGPatternTargetMarker final : public USceneComponent
{
public:
	float                                         M_fDelay;                                          // 0x0298(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          M_bUseAlternateProjectileClass;                    // 0x029C(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          M_bUseSecondAlternateProjectileClass;              // 0x029D(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          M_bIsHoming;                                       // 0x029E(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_29F[0x11];                                     // 0x029F(0x0011)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"BFGPatternTargetMarker">();
	}
	static class UBFGPatternTargetMarker* GetDefaultObj()
	{
		return GetDefaultObjImpl<UBFGPatternTargetMarker>();
	}
};
static_assert(alignof(UBFGPatternTargetMarker) == 0x000008, "Wrong alignment on UBFGPatternTargetMarker");
static_assert(sizeof(UBFGPatternTargetMarker) == 0x0002B0, "Wrong size on UBFGPatternTargetMarker");
static_assert(offsetof(UBFGPatternTargetMarker, M_fDelay) == 0x000298, "Member 'UBFGPatternTargetMarker::M_fDelay' has a wrong offset!");
static_assert(offsetof(UBFGPatternTargetMarker, M_bUseAlternateProjectileClass) == 0x00029C, "Member 'UBFGPatternTargetMarker::M_bUseAlternateProjectileClass' has a wrong offset!");
static_assert(offsetof(UBFGPatternTargetMarker, M_bUseSecondAlternateProjectileClass) == 0x00029D, "Member 'UBFGPatternTargetMarker::M_bUseSecondAlternateProjectileClass' has a wrong offset!");
static_assert(offsetof(UBFGPatternTargetMarker, M_bIsHoming) == 0x00029E, "Member 'UBFGPatternTargetMarker::M_bIsHoming' has a wrong offset!");

// Class BFGCore.BFGPauseManager
// 0x0028 (0x0050 - 0x0028)
class UBFGPauseManager final : public UObject
{
public:
	uint8                                         Pad_28[0x28];                                      // 0x0028(0x0028)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	class UBFGGameInstance* GetGameInstance();

	bool IsPaused() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"BFGPauseManager">();
	}
	static class UBFGPauseManager* GetDefaultObj()
	{
		return GetDefaultObjImpl<UBFGPauseManager>();
	}
};
static_assert(alignof(UBFGPauseManager) == 0x000008, "Wrong alignment on UBFGPauseManager");
static_assert(sizeof(UBFGPauseManager) == 0x000050, "Wrong size on UBFGPauseManager");

// Class BFGCore.BFGPerformanceLocation
// 0x0020 (0x03F8 - 0x03D8)
class ABFGPerformanceLocation final : public AActor
{
public:
	class USceneComponent*                        M_pRoot;                                           // 0x03D8(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          M_bQuestCheckpoint;                                // 0x03E0(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_3E1[0x7];                                      // 0x03E1(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	class FString                                 M_strDisplayName;                                  // 0x03E8(0x0010)(Edit, BlueprintVisible, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

public:
	void UpdateCheckpointLocations();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"BFGPerformanceLocation">();
	}
	static class ABFGPerformanceLocation* GetDefaultObj()
	{
		return GetDefaultObjImpl<ABFGPerformanceLocation>();
	}
};
static_assert(alignof(ABFGPerformanceLocation) == 0x000008, "Wrong alignment on ABFGPerformanceLocation");
static_assert(sizeof(ABFGPerformanceLocation) == 0x0003F8, "Wrong size on ABFGPerformanceLocation");
static_assert(offsetof(ABFGPerformanceLocation, M_pRoot) == 0x0003D8, "Member 'ABFGPerformanceLocation::M_pRoot' has a wrong offset!");
static_assert(offsetof(ABFGPerformanceLocation, M_bQuestCheckpoint) == 0x0003E0, "Member 'ABFGPerformanceLocation::M_bQuestCheckpoint' has a wrong offset!");
static_assert(offsetof(ABFGPerformanceLocation, M_strDisplayName) == 0x0003E8, "Member 'ABFGPerformanceLocation::M_strDisplayName' has a wrong offset!");

// Class BFGCore.BFGSensor_GameplayOverrides
// 0x0000 (0x0040 - 0x0040)
class UBFGSensor_GameplayOverrides final : public UBFGSensor
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"BFGSensor_GameplayOverrides">();
	}
	static class UBFGSensor_GameplayOverrides* GetDefaultObj()
	{
		return GetDefaultObjImpl<UBFGSensor_GameplayOverrides>();
	}
};
static_assert(alignof(UBFGSensor_GameplayOverrides) == 0x000008, "Wrong alignment on UBFGSensor_GameplayOverrides");
static_assert(sizeof(UBFGSensor_GameplayOverrides) == 0x000040, "Wrong size on UBFGSensor_GameplayOverrides");

// Class BFGCore.BFGPhotographySystem
// 0x0020 (0x0050 - 0x0030)
class UBFGPhotographySystem final : public UBFGGameSystem
{
public:
	class ABFGGameState*                          M_pGameState;                                      // 0x0030(0x0008)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UBFGGameInstance*                       M_pGameInstance;                                   // 0x0038(0x0008)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_40[0x10];                                      // 0x0040(0x0010)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"BFGPhotographySystem">();
	}
	static class UBFGPhotographySystem* GetDefaultObj()
	{
		return GetDefaultObjImpl<UBFGPhotographySystem>();
	}
};
static_assert(alignof(UBFGPhotographySystem) == 0x000008, "Wrong alignment on UBFGPhotographySystem");
static_assert(sizeof(UBFGPhotographySystem) == 0x000050, "Wrong size on UBFGPhotographySystem");
static_assert(offsetof(UBFGPhotographySystem, M_pGameState) == 0x000030, "Member 'UBFGPhotographySystem::M_pGameState' has a wrong offset!");
static_assert(offsetof(UBFGPhotographySystem, M_pGameInstance) == 0x000038, "Member 'UBFGPhotographySystem::M_pGameInstance' has a wrong offset!");

// Class BFGCore.BFGPlayCrowdLifeStationAnim
// 0x0160 (0x0188 - 0x0028)
class UBFGPlayCrowdLifeStationAnim final : public UObject
{
public:
	class UBFGNetworkPathAgent*                   M_pAgent;                                          // 0x0028(0x0008)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UBFGCrowdLifeStationComponent*          M_pStation;                                        // 0x0030(0x0008)(ExportObject, ZeroConstructor, Transient, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UBFGCrowdLifeTaskNodeStrategyLowRes*    M_pLowResTaskNodeStrategy;                         // 0x0038(0x0008)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UBFGCrowdLifeTaskNodeStrategyBase*      M_pHighResTaskNodeStrategy;                        // 0x0040(0x0008)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	struct FBFG_PlayCrowdLifeStationAnimTaskMemory M_taskMemory;                                      // 0x0048(0x0140)(Transient, ContainsInstancedReference, Protected, NativeAccessSpecifierProtected)

public:
	void OnAnimationPop(TScriptInterface<class IBFGInteractAnimationPlayerInterface> _pAnimPlayer, const struct FBFGInteractAnimationData& _newAnimData, const struct FBFGInteractAnimationData& _oldAnimData);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"BFGPlayCrowdLifeStationAnim">();
	}
	static class UBFGPlayCrowdLifeStationAnim* GetDefaultObj()
	{
		return GetDefaultObjImpl<UBFGPlayCrowdLifeStationAnim>();
	}
};
static_assert(alignof(UBFGPlayCrowdLifeStationAnim) == 0x000008, "Wrong alignment on UBFGPlayCrowdLifeStationAnim");
static_assert(sizeof(UBFGPlayCrowdLifeStationAnim) == 0x000188, "Wrong size on UBFGPlayCrowdLifeStationAnim");
static_assert(offsetof(UBFGPlayCrowdLifeStationAnim, M_pAgent) == 0x000028, "Member 'UBFGPlayCrowdLifeStationAnim::M_pAgent' has a wrong offset!");
static_assert(offsetof(UBFGPlayCrowdLifeStationAnim, M_pStation) == 0x000030, "Member 'UBFGPlayCrowdLifeStationAnim::M_pStation' has a wrong offset!");
static_assert(offsetof(UBFGPlayCrowdLifeStationAnim, M_pLowResTaskNodeStrategy) == 0x000038, "Member 'UBFGPlayCrowdLifeStationAnim::M_pLowResTaskNodeStrategy' has a wrong offset!");
static_assert(offsetof(UBFGPlayCrowdLifeStationAnim, M_pHighResTaskNodeStrategy) == 0x000040, "Member 'UBFGPlayCrowdLifeStationAnim::M_pHighResTaskNodeStrategy' has a wrong offset!");
static_assert(offsetof(UBFGPlayCrowdLifeStationAnim, M_taskMemory) == 0x000048, "Member 'UBFGPlayCrowdLifeStationAnim::M_taskMemory' has a wrong offset!");

// Class BFGCore.BFGSensor_MissionTarget
// 0x0000 (0x0040 - 0x0040)
class UBFGSensor_MissionTarget final : public UBFGSensor
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"BFGSensor_MissionTarget">();
	}
	static class UBFGSensor_MissionTarget* GetDefaultObj()
	{
		return GetDefaultObjImpl<UBFGSensor_MissionTarget>();
	}
};
static_assert(alignof(UBFGSensor_MissionTarget) == 0x000008, "Wrong alignment on UBFGSensor_MissionTarget");
static_assert(sizeof(UBFGSensor_MissionTarget) == 0x000040, "Wrong size on UBFGSensor_MissionTarget");

// Class BFGCore.BFGPlayerCharacter
// 0x01B0 (0x0AB0 - 0x0900)
class ABFGPlayerCharacter : public ABFGPlayerBase
{
public:
	class UBFGActorComponent_WidgetComponent_Holobob* M_pHolobobWidgetComponent;                         // 0x0900(0x0008)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, EditConst, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UBFGActorComponent_CrowdAgent*          M_pCrowdAgentComponent;                            // 0x0908(0x0008)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, EditConst, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UBFGActorComponent_Animation_Crypto*    M_pAnimationComponent;                             // 0x0910(0x0008)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, EditConst, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UBFGActorComponent_PlayerWeapon*        M_pWeaponComponent;                                // 0x0918(0x0008)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, EditConst, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UBFGActorComponent_PlayerStats*         M_pStatsComponent;                                 // 0x0920(0x0008)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, EditConst, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UCameraComponent*                       M_pFollowCamera;                                   // 0x0928(0x0008)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, EditConst, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UBFGActorComponent_JetpackPilot*        M_pJetpackPilotComponent;                          // 0x0930(0x0008)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, EditConst, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UBFGActorComponent_Dash*                M_pDashComponent;                                  // 0x0938(0x0008)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, EditConst, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UBFGActorComponent_FocusMode*           M_pFocusComponent;                                 // 0x0940(0x0008)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, EditConst, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UBFGActorComponent_PlayerWeaponAndAbilitySelector* M_pWeaponAndAbilitySelection;                      // 0x0948(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UBFGActorComponent_Effect*              M_pEffectComponent;                                // 0x0950(0x0008)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, EditConst, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UBFGActorComponent_PlayerInteractionsCharacter* M_pInteractionsComponent;                          // 0x0958(0x0008)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, EditConst, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UBFGActorComponent_CharacterPhysics*    M_pCharacterPhysicsComponent;                      // 0x0960(0x0008)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, EditConst, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UBFGActorComponent_LockOn*              M_pLockOnComponent;                                // 0x0968(0x0008)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, EditConst, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UBFGVariationDressingComponent*         M_pVariationComponent;                             // 0x0970(0x0008)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, EditConst, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UBFGBuoyancyForceComponent*             M_pBouyancyComponent;                              // 0x0978(0x0008)(Edit, ExportObject, ZeroConstructor, EditConst, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TSubclassOf<class UBFGAnimationInstance>      M_pHolobobAnimationInstance;                       // 0x0980(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   M_voice;                                           // 0x0988(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          M_bShouldShowIndicator;                            // 0x0990(0x0001)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_991[0x7];                                      // 0x0991(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	class UBFGActorComponent_PawnDamage*          M_pDamageComponent;                                // 0x0998(0x0008)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, EditConst, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UNavigationInvokerComponent*            M_pInvokerComponent;                               // 0x09A0(0x0008)(Edit, ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         M_fDeathImpulseStrength;                           // 0x09A8(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         M_fDeathSimulationDuration;                        // 0x09AC(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	EBFGFaction                                   M_faction;                                         // 0x09B0(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_9B1[0x3];                                      // 0x09B1(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         M_fMaxRange_FootstepNoise;                         // 0x09B4(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         M_fAnimYawThreshold;                               // 0x09B8(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         M_fStopAimDownSightDelay;                          // 0x09BC(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         M_fLockOnAimOffsetInterpSpeed;                     // 0x09C0(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class FName                                   M_sNasalEffectSocket;                              // 0x09C4(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_9CC[0x4];                                      // 0x09CC(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	struct FTransform                             M_vNasalEffectOffset;                              // 0x09D0(0x0030)(Edit, IsPlainOldData, NoDestructor, Protected, NativeAccessSpecifierProtected)
	float                                         M_fRotationSwitchDelay;                            // 0x0A00(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class FName                                   M_oShieldRatioName;                                // 0x0A04(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	struct FBFGPlayerCharacterMovementSettings    M_oADSMovementSettings;                            // 0x0A0C(0x001C)(Edit, NoDestructor, Protected, NativeAccessSpecifierProtected)
	int32                                         M_iForceADSCounter;                                // 0x0A28(0x0004)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          M_bPlayerIsADS;                                    // 0x0A2C(0x0001)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          M_bIsTurning;                                      // 0x0A2D(0x0001)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_A2E[0x2];                                      // 0x0A2E(0x0002)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         M_fRotationSwitchTimer;                            // 0x0A30(0x0004)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         M_fAimPitchOffset;                                 // 0x0A34(0x0004)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         M_fAimYawOffset;                                   // 0x0A38(0x0004)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	struct FBFGWaterPlaneInfo                     M_oWaterInfo;                                      // 0x0A3C(0x000C)(Transient, NoDestructor, Protected, NativeAccessSpecifierProtected)
	float                                         M_bIsInWater;                                      // 0x0A48(0x0004)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         M_bWasInWater;                                     // 0x0A4C(0x0004)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UObject*                                M_pFocus;                                          // 0x0A50(0x0008)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         M_fStopAimDownSightTimer;                          // 0x0A58(0x0004)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          M_bIsCurrentlyEnteringOrLeavingUFO;                // 0x0A5C(0x0001)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_A5D[0x7];                                      // 0x0A5D(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	bool                                          M_bIsNasalProbed;                                  // 0x0A64(0x0001)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_A65[0x3];                                      // 0x0A65(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	class UBFGActorComponent_MentallyInteractable* M_pFocusedMentallyInteractable;                    // 0x0A68(0x0008)(ExportObject, ZeroConstructor, Transient, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	struct FGameplayTag                           M_tUpgradeTagShieldEnhancerPack;                   // 0x0A70(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, DisableEditOnInstance, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         M_fShieldEnhancerPackBoost;                        // 0x0A78(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_A7C[0x4];                                      // 0x0A7C(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	struct FGameplayTag                           M_tUpgradeTagShieldEnhancerPlus;                   // 0x0A80(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, DisableEditOnInstance, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         M_fShieldEnhancerPlusBoost;                        // 0x0A88(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_A8C[0x4];                                      // 0x0A8C(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	struct FGameplayTag                           M_tUpgradeTagShieldHarmonicsMaxima;                // 0x0A90(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, DisableEditOnInstance, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         M_fShieldHarmonicsMaximaWindow;                    // 0x0A98(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         M_fShieldLastChanceHarmonicsMaximaWindow;          // 0x0A9C(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_AA0[0x10];                                     // 0x0AA0(0x0010)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void OnDeathStateChanged(class AActor* _pActor, class UBFGActorStat_Bool* _pStat);
	void OnEnteredUFO();
	void OnEnteredWater();
	void OnLeftWater();
	void OnShieldStatChanged(class AActor* _pActor, class UBFGActorStat_Float* _pStat);
	void OnShowTriggerZoneMessage(bool _bIsOutside);
	void OnSkinChanged();

	bool GetIsInWater() const;
	class UBFGPlayerCharacter_Settings* GetSettings() const;
	struct FBFGWaterPlaneInfo GetWaterInfo() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"BFGPlayerCharacter">();
	}
	static class ABFGPlayerCharacter* GetDefaultObj()
	{
		return GetDefaultObjImpl<ABFGPlayerCharacter>();
	}
};
static_assert(alignof(ABFGPlayerCharacter) == 0x000010, "Wrong alignment on ABFGPlayerCharacter");
static_assert(sizeof(ABFGPlayerCharacter) == 0x000AB0, "Wrong size on ABFGPlayerCharacter");
static_assert(offsetof(ABFGPlayerCharacter, M_pHolobobWidgetComponent) == 0x000900, "Member 'ABFGPlayerCharacter::M_pHolobobWidgetComponent' has a wrong offset!");
static_assert(offsetof(ABFGPlayerCharacter, M_pCrowdAgentComponent) == 0x000908, "Member 'ABFGPlayerCharacter::M_pCrowdAgentComponent' has a wrong offset!");
static_assert(offsetof(ABFGPlayerCharacter, M_pAnimationComponent) == 0x000910, "Member 'ABFGPlayerCharacter::M_pAnimationComponent' has a wrong offset!");
static_assert(offsetof(ABFGPlayerCharacter, M_pWeaponComponent) == 0x000918, "Member 'ABFGPlayerCharacter::M_pWeaponComponent' has a wrong offset!");
static_assert(offsetof(ABFGPlayerCharacter, M_pStatsComponent) == 0x000920, "Member 'ABFGPlayerCharacter::M_pStatsComponent' has a wrong offset!");
static_assert(offsetof(ABFGPlayerCharacter, M_pFollowCamera) == 0x000928, "Member 'ABFGPlayerCharacter::M_pFollowCamera' has a wrong offset!");
static_assert(offsetof(ABFGPlayerCharacter, M_pJetpackPilotComponent) == 0x000930, "Member 'ABFGPlayerCharacter::M_pJetpackPilotComponent' has a wrong offset!");
static_assert(offsetof(ABFGPlayerCharacter, M_pDashComponent) == 0x000938, "Member 'ABFGPlayerCharacter::M_pDashComponent' has a wrong offset!");
static_assert(offsetof(ABFGPlayerCharacter, M_pFocusComponent) == 0x000940, "Member 'ABFGPlayerCharacter::M_pFocusComponent' has a wrong offset!");
static_assert(offsetof(ABFGPlayerCharacter, M_pWeaponAndAbilitySelection) == 0x000948, "Member 'ABFGPlayerCharacter::M_pWeaponAndAbilitySelection' has a wrong offset!");
static_assert(offsetof(ABFGPlayerCharacter, M_pEffectComponent) == 0x000950, "Member 'ABFGPlayerCharacter::M_pEffectComponent' has a wrong offset!");
static_assert(offsetof(ABFGPlayerCharacter, M_pInteractionsComponent) == 0x000958, "Member 'ABFGPlayerCharacter::M_pInteractionsComponent' has a wrong offset!");
static_assert(offsetof(ABFGPlayerCharacter, M_pCharacterPhysicsComponent) == 0x000960, "Member 'ABFGPlayerCharacter::M_pCharacterPhysicsComponent' has a wrong offset!");
static_assert(offsetof(ABFGPlayerCharacter, M_pLockOnComponent) == 0x000968, "Member 'ABFGPlayerCharacter::M_pLockOnComponent' has a wrong offset!");
static_assert(offsetof(ABFGPlayerCharacter, M_pVariationComponent) == 0x000970, "Member 'ABFGPlayerCharacter::M_pVariationComponent' has a wrong offset!");
static_assert(offsetof(ABFGPlayerCharacter, M_pBouyancyComponent) == 0x000978, "Member 'ABFGPlayerCharacter::M_pBouyancyComponent' has a wrong offset!");
static_assert(offsetof(ABFGPlayerCharacter, M_pHolobobAnimationInstance) == 0x000980, "Member 'ABFGPlayerCharacter::M_pHolobobAnimationInstance' has a wrong offset!");
static_assert(offsetof(ABFGPlayerCharacter, M_voice) == 0x000988, "Member 'ABFGPlayerCharacter::M_voice' has a wrong offset!");
static_assert(offsetof(ABFGPlayerCharacter, M_bShouldShowIndicator) == 0x000990, "Member 'ABFGPlayerCharacter::M_bShouldShowIndicator' has a wrong offset!");
static_assert(offsetof(ABFGPlayerCharacter, M_pDamageComponent) == 0x000998, "Member 'ABFGPlayerCharacter::M_pDamageComponent' has a wrong offset!");
static_assert(offsetof(ABFGPlayerCharacter, M_pInvokerComponent) == 0x0009A0, "Member 'ABFGPlayerCharacter::M_pInvokerComponent' has a wrong offset!");
static_assert(offsetof(ABFGPlayerCharacter, M_fDeathImpulseStrength) == 0x0009A8, "Member 'ABFGPlayerCharacter::M_fDeathImpulseStrength' has a wrong offset!");
static_assert(offsetof(ABFGPlayerCharacter, M_fDeathSimulationDuration) == 0x0009AC, "Member 'ABFGPlayerCharacter::M_fDeathSimulationDuration' has a wrong offset!");
static_assert(offsetof(ABFGPlayerCharacter, M_faction) == 0x0009B0, "Member 'ABFGPlayerCharacter::M_faction' has a wrong offset!");
static_assert(offsetof(ABFGPlayerCharacter, M_fMaxRange_FootstepNoise) == 0x0009B4, "Member 'ABFGPlayerCharacter::M_fMaxRange_FootstepNoise' has a wrong offset!");
static_assert(offsetof(ABFGPlayerCharacter, M_fAnimYawThreshold) == 0x0009B8, "Member 'ABFGPlayerCharacter::M_fAnimYawThreshold' has a wrong offset!");
static_assert(offsetof(ABFGPlayerCharacter, M_fStopAimDownSightDelay) == 0x0009BC, "Member 'ABFGPlayerCharacter::M_fStopAimDownSightDelay' has a wrong offset!");
static_assert(offsetof(ABFGPlayerCharacter, M_fLockOnAimOffsetInterpSpeed) == 0x0009C0, "Member 'ABFGPlayerCharacter::M_fLockOnAimOffsetInterpSpeed' has a wrong offset!");
static_assert(offsetof(ABFGPlayerCharacter, M_sNasalEffectSocket) == 0x0009C4, "Member 'ABFGPlayerCharacter::M_sNasalEffectSocket' has a wrong offset!");
static_assert(offsetof(ABFGPlayerCharacter, M_vNasalEffectOffset) == 0x0009D0, "Member 'ABFGPlayerCharacter::M_vNasalEffectOffset' has a wrong offset!");
static_assert(offsetof(ABFGPlayerCharacter, M_fRotationSwitchDelay) == 0x000A00, "Member 'ABFGPlayerCharacter::M_fRotationSwitchDelay' has a wrong offset!");
static_assert(offsetof(ABFGPlayerCharacter, M_oShieldRatioName) == 0x000A04, "Member 'ABFGPlayerCharacter::M_oShieldRatioName' has a wrong offset!");
static_assert(offsetof(ABFGPlayerCharacter, M_oADSMovementSettings) == 0x000A0C, "Member 'ABFGPlayerCharacter::M_oADSMovementSettings' has a wrong offset!");
static_assert(offsetof(ABFGPlayerCharacter, M_iForceADSCounter) == 0x000A28, "Member 'ABFGPlayerCharacter::M_iForceADSCounter' has a wrong offset!");
static_assert(offsetof(ABFGPlayerCharacter, M_bPlayerIsADS) == 0x000A2C, "Member 'ABFGPlayerCharacter::M_bPlayerIsADS' has a wrong offset!");
static_assert(offsetof(ABFGPlayerCharacter, M_bIsTurning) == 0x000A2D, "Member 'ABFGPlayerCharacter::M_bIsTurning' has a wrong offset!");
static_assert(offsetof(ABFGPlayerCharacter, M_fRotationSwitchTimer) == 0x000A30, "Member 'ABFGPlayerCharacter::M_fRotationSwitchTimer' has a wrong offset!");
static_assert(offsetof(ABFGPlayerCharacter, M_fAimPitchOffset) == 0x000A34, "Member 'ABFGPlayerCharacter::M_fAimPitchOffset' has a wrong offset!");
static_assert(offsetof(ABFGPlayerCharacter, M_fAimYawOffset) == 0x000A38, "Member 'ABFGPlayerCharacter::M_fAimYawOffset' has a wrong offset!");
static_assert(offsetof(ABFGPlayerCharacter, M_oWaterInfo) == 0x000A3C, "Member 'ABFGPlayerCharacter::M_oWaterInfo' has a wrong offset!");
static_assert(offsetof(ABFGPlayerCharacter, M_bIsInWater) == 0x000A48, "Member 'ABFGPlayerCharacter::M_bIsInWater' has a wrong offset!");
static_assert(offsetof(ABFGPlayerCharacter, M_bWasInWater) == 0x000A4C, "Member 'ABFGPlayerCharacter::M_bWasInWater' has a wrong offset!");
static_assert(offsetof(ABFGPlayerCharacter, M_pFocus) == 0x000A50, "Member 'ABFGPlayerCharacter::M_pFocus' has a wrong offset!");
static_assert(offsetof(ABFGPlayerCharacter, M_fStopAimDownSightTimer) == 0x000A58, "Member 'ABFGPlayerCharacter::M_fStopAimDownSightTimer' has a wrong offset!");
static_assert(offsetof(ABFGPlayerCharacter, M_bIsCurrentlyEnteringOrLeavingUFO) == 0x000A5C, "Member 'ABFGPlayerCharacter::M_bIsCurrentlyEnteringOrLeavingUFO' has a wrong offset!");
static_assert(offsetof(ABFGPlayerCharacter, M_bIsNasalProbed) == 0x000A64, "Member 'ABFGPlayerCharacter::M_bIsNasalProbed' has a wrong offset!");
static_assert(offsetof(ABFGPlayerCharacter, M_pFocusedMentallyInteractable) == 0x000A68, "Member 'ABFGPlayerCharacter::M_pFocusedMentallyInteractable' has a wrong offset!");
static_assert(offsetof(ABFGPlayerCharacter, M_tUpgradeTagShieldEnhancerPack) == 0x000A70, "Member 'ABFGPlayerCharacter::M_tUpgradeTagShieldEnhancerPack' has a wrong offset!");
static_assert(offsetof(ABFGPlayerCharacter, M_fShieldEnhancerPackBoost) == 0x000A78, "Member 'ABFGPlayerCharacter::M_fShieldEnhancerPackBoost' has a wrong offset!");
static_assert(offsetof(ABFGPlayerCharacter, M_tUpgradeTagShieldEnhancerPlus) == 0x000A80, "Member 'ABFGPlayerCharacter::M_tUpgradeTagShieldEnhancerPlus' has a wrong offset!");
static_assert(offsetof(ABFGPlayerCharacter, M_fShieldEnhancerPlusBoost) == 0x000A88, "Member 'ABFGPlayerCharacter::M_fShieldEnhancerPlusBoost' has a wrong offset!");
static_assert(offsetof(ABFGPlayerCharacter, M_tUpgradeTagShieldHarmonicsMaxima) == 0x000A90, "Member 'ABFGPlayerCharacter::M_tUpgradeTagShieldHarmonicsMaxima' has a wrong offset!");
static_assert(offsetof(ABFGPlayerCharacter, M_fShieldHarmonicsMaximaWindow) == 0x000A98, "Member 'ABFGPlayerCharacter::M_fShieldHarmonicsMaximaWindow' has a wrong offset!");
static_assert(offsetof(ABFGPlayerCharacter, M_fShieldLastChanceHarmonicsMaximaWindow) == 0x000A9C, "Member 'ABFGPlayerCharacter::M_fShieldLastChanceHarmonicsMaximaWindow' has a wrong offset!");

// Class BFGCore.BFGPlayerCharacter_Settings
// 0x01D8 (0x0210 - 0x0038)
class UBFGPlayerCharacter_Settings final : public UDeveloperSettings
{
public:
	TSoftClassPtr<class UClass>                   M_pSoftPlayerCharacter;                            // 0x0038(0x0028)(Edit, BlueprintVisible, BlueprintReadOnly, Config, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TSoftClassPtr<class UClass>                   M_pSoftPlayerUFO;                                  // 0x0060(0x0028)(Edit, BlueprintVisible, BlueprintReadOnly, Config, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FBFGPlayerSkill_Tags                   M_skillTag_UFOEnter;                               // 0x0088(0x0018)(Edit, BlueprintVisible, BlueprintReadOnly, Config, NativeAccessSpecifierPublic)
	struct FBFGPlayerSkill_Tags                   M_skillTag_UFOCall;                                // 0x00A0(0x0018)(Edit, BlueprintVisible, BlueprintReadOnly, Config, NativeAccessSpecifierPublic)
	struct FBFGPlayerSkill_Tags                   M_skillTag_UFOLand;                                // 0x00B8(0x0018)(Edit, BlueprintVisible, BlueprintReadOnly, Config, NativeAccessSpecifierPublic)
	struct FGameplayTagContainer                  M_skills_DefaultUnlocked;                          // 0x00D0(0x0020)(Edit, BlueprintVisible, BlueprintReadOnly, Config, NativeAccessSpecifierPublic)
	TArray<struct FSoftObjectPath>                M_aProfileGameplayTags;                            // 0x00F0(0x0010)(Edit, ZeroConstructor, Config, NativeAccessSpecifierPublic)
	struct FGameplayTagContainer                  M_allTags;                                         // 0x0100(0x0020)(Edit, BlueprintVisible, BlueprintReadOnly, Config, NativeAccessSpecifierPublic)
	struct FGameplayTagContainer                  M_unlockedSkinsXMas2020;                           // 0x0120(0x0020)(Edit, BlueprintVisible, BlueprintReadOnly, Config, NativeAccessSpecifierPublic)
	struct FGameplayTagContainer                  M_unlockedSkinsFebruary2021;                       // 0x0140(0x0020)(Edit, BlueprintVisible, BlueprintReadOnly, Config, NativeAccessSpecifierPublic)
	struct FSoftClassPath                         M_weaponSwitchMenu;                                // 0x0160(0x0018)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Config, NativeAccessSpecifierPublic)
	struct FSoftClassPath                         M_weaponSwitchMenuOptionClass;                     // 0x0178(0x0018)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Config, NativeAccessSpecifierPublic)
	TArray<struct FBFGPlayerSettingsWeaponInfo>   M_aWeapons;                                        // 0x0190(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Config, ContainsInstancedReference, NativeAccessSpecifierPublic)
	class FText                                   M_weaponSwitchMenuTitleHint;                       // 0x01A0(0x0018)(Edit, BlueprintVisible, BlueprintReadOnly, Config, NativeAccessSpecifierPublic)
	float                                         M_fDialogTriggerRange;                             // 0x01B8(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Config, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1BC[0x4];                                      // 0x01BC(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	TSoftObjectPtr<class UBFGDataAsset_JetpackParams> M_pDefaultJetpackParams;                           // 0x01C0(0x0028)(Edit, Config, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TSoftObjectPtr<class UBFGDataAsset_DashParams> M_pDefaultDashParams;                              // 0x01E8(0x0028)(Edit, Config, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"BFGPlayerCharacter_Settings">();
	}
	static class UBFGPlayerCharacter_Settings* GetDefaultObj()
	{
		return GetDefaultObjImpl<UBFGPlayerCharacter_Settings>();
	}
};
static_assert(alignof(UBFGPlayerCharacter_Settings) == 0x000008, "Wrong alignment on UBFGPlayerCharacter_Settings");
static_assert(sizeof(UBFGPlayerCharacter_Settings) == 0x000210, "Wrong size on UBFGPlayerCharacter_Settings");
static_assert(offsetof(UBFGPlayerCharacter_Settings, M_pSoftPlayerCharacter) == 0x000038, "Member 'UBFGPlayerCharacter_Settings::M_pSoftPlayerCharacter' has a wrong offset!");
static_assert(offsetof(UBFGPlayerCharacter_Settings, M_pSoftPlayerUFO) == 0x000060, "Member 'UBFGPlayerCharacter_Settings::M_pSoftPlayerUFO' has a wrong offset!");
static_assert(offsetof(UBFGPlayerCharacter_Settings, M_skillTag_UFOEnter) == 0x000088, "Member 'UBFGPlayerCharacter_Settings::M_skillTag_UFOEnter' has a wrong offset!");
static_assert(offsetof(UBFGPlayerCharacter_Settings, M_skillTag_UFOCall) == 0x0000A0, "Member 'UBFGPlayerCharacter_Settings::M_skillTag_UFOCall' has a wrong offset!");
static_assert(offsetof(UBFGPlayerCharacter_Settings, M_skillTag_UFOLand) == 0x0000B8, "Member 'UBFGPlayerCharacter_Settings::M_skillTag_UFOLand' has a wrong offset!");
static_assert(offsetof(UBFGPlayerCharacter_Settings, M_skills_DefaultUnlocked) == 0x0000D0, "Member 'UBFGPlayerCharacter_Settings::M_skills_DefaultUnlocked' has a wrong offset!");
static_assert(offsetof(UBFGPlayerCharacter_Settings, M_aProfileGameplayTags) == 0x0000F0, "Member 'UBFGPlayerCharacter_Settings::M_aProfileGameplayTags' has a wrong offset!");
static_assert(offsetof(UBFGPlayerCharacter_Settings, M_allTags) == 0x000100, "Member 'UBFGPlayerCharacter_Settings::M_allTags' has a wrong offset!");
static_assert(offsetof(UBFGPlayerCharacter_Settings, M_unlockedSkinsXMas2020) == 0x000120, "Member 'UBFGPlayerCharacter_Settings::M_unlockedSkinsXMas2020' has a wrong offset!");
static_assert(offsetof(UBFGPlayerCharacter_Settings, M_unlockedSkinsFebruary2021) == 0x000140, "Member 'UBFGPlayerCharacter_Settings::M_unlockedSkinsFebruary2021' has a wrong offset!");
static_assert(offsetof(UBFGPlayerCharacter_Settings, M_weaponSwitchMenu) == 0x000160, "Member 'UBFGPlayerCharacter_Settings::M_weaponSwitchMenu' has a wrong offset!");
static_assert(offsetof(UBFGPlayerCharacter_Settings, M_weaponSwitchMenuOptionClass) == 0x000178, "Member 'UBFGPlayerCharacter_Settings::M_weaponSwitchMenuOptionClass' has a wrong offset!");
static_assert(offsetof(UBFGPlayerCharacter_Settings, M_aWeapons) == 0x000190, "Member 'UBFGPlayerCharacter_Settings::M_aWeapons' has a wrong offset!");
static_assert(offsetof(UBFGPlayerCharacter_Settings, M_weaponSwitchMenuTitleHint) == 0x0001A0, "Member 'UBFGPlayerCharacter_Settings::M_weaponSwitchMenuTitleHint' has a wrong offset!");
static_assert(offsetof(UBFGPlayerCharacter_Settings, M_fDialogTriggerRange) == 0x0001B8, "Member 'UBFGPlayerCharacter_Settings::M_fDialogTriggerRange' has a wrong offset!");
static_assert(offsetof(UBFGPlayerCharacter_Settings, M_pDefaultJetpackParams) == 0x0001C0, "Member 'UBFGPlayerCharacter_Settings::M_pDefaultJetpackParams' has a wrong offset!");
static_assert(offsetof(UBFGPlayerCharacter_Settings, M_pDefaultDashParams) == 0x0001E8, "Member 'UBFGPlayerCharacter_Settings::M_pDefaultDashParams' has a wrong offset!");

// Class BFGCore.BFGSensor_SeeFriendlyDistractingActor
// 0x0090 (0x00D0 - 0x0040)
class UBFGSensor_SeeFriendlyDistractingActor final : public UBFGSensor
{
public:
	struct FGameplayTagQuery                      M_oImmunityTagQuery;                               // 0x0040(0x0048)(Edit, Protected, NativeAccessSpecifierProtected)
	struct FGameplayTagQuery                      M_oDistractEffectTagQuery;                         // 0x0088(0x0048)(Edit, Protected, NativeAccessSpecifierProtected)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"BFGSensor_SeeFriendlyDistractingActor">();
	}
	static class UBFGSensor_SeeFriendlyDistractingActor* GetDefaultObj()
	{
		return GetDefaultObjImpl<UBFGSensor_SeeFriendlyDistractingActor>();
	}
};
static_assert(alignof(UBFGSensor_SeeFriendlyDistractingActor) == 0x000008, "Wrong alignment on UBFGSensor_SeeFriendlyDistractingActor");
static_assert(sizeof(UBFGSensor_SeeFriendlyDistractingActor) == 0x0000D0, "Wrong size on UBFGSensor_SeeFriendlyDistractingActor");
static_assert(offsetof(UBFGSensor_SeeFriendlyDistractingActor, M_oImmunityTagQuery) == 0x000040, "Member 'UBFGSensor_SeeFriendlyDistractingActor::M_oImmunityTagQuery' has a wrong offset!");
static_assert(offsetof(UBFGSensor_SeeFriendlyDistractingActor, M_oDistractEffectTagQuery) == 0x000088, "Member 'UBFGSensor_SeeFriendlyDistractingActor::M_oDistractEffectTagQuery' has a wrong offset!");

// Class BFGCore.BFGPlayerController_Menus
// 0x0000 (0x0730 - 0x0730)
class ABFGPlayerController_Menus final : public APlayerController
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"BFGPlayerController_Menus">();
	}
	static class ABFGPlayerController_Menus* GetDefaultObj()
	{
		return GetDefaultObjImpl<ABFGPlayerController_Menus>();
	}
};
static_assert(alignof(ABFGPlayerController_Menus) == 0x000008, "Wrong alignment on ABFGPlayerController_Menus");
static_assert(sizeof(ABFGPlayerController_Menus) == 0x000730, "Wrong size on ABFGPlayerController_Menus");

// Class BFGCore.BFGPlayerState
// 0x0138 (0x0638 - 0x0500)
class ABFGPlayerState : public APlayerState
{
public:
	uint8                                         Pad_500[0x10];                                     // 0x0500(0x0010)(Fixing Size After Last Property [ Dumper-7 ])
	struct FGameplayTag                           M_oDefaultSkinTag;                                 // 0x0510(0x0008)(Edit, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UDataTable*                             M_pUpgradesTable;                                  // 0x0518(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UBFGPlayerState_Upgrades*               M_pUpgrades;                                       // 0x0520(0x0008)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_528[0x38];                                     // 0x0528(0x0038)(Fixing Size After Last Property [ Dumper-7 ])
	TMap<class AActor*, int32>                    M_aActorLookupTable;                               // 0x0560(0x0050)(ZeroConstructor, Transient, Protected, NativeAccessSpecifierProtected)
	int32                                         M_iDNA;                                            // 0x05B0(0x0004)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_5B4[0x4];                                      // 0x05B4(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class UBFGPlayerState_Unlocks*                M_pUnlocks;                                        // 0x05B8(0x0008)(ExportObject, ZeroConstructor, Transient, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         M_fMonetaryValueCollected;                         // 0x05C0(0x0004)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_5C4[0x4];                                      // 0x05C4(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	TMap<EItemValueTypeEnum, int32>               M_aAmmo;                                           // 0x05C8(0x0050)(ZeroConstructor, Protected, NativeAccessSpecifierProtected)
	struct FGameplayTag                           M_oSelectedSkinTag;                                // 0x0618(0x0008)(BlueprintVisible, BlueprintReadOnly, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	struct FBFGPlayerData_Collectables            M_collectables;                                    // 0x0620(0x0010)(Transient, Protected, NativeAccessSpecifierProtected)
	uint8                                         Pad_630[0x8];                                      // 0x0630(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UBFGPlayerState_Unlocks* GetPlayerStateUnlocks(const class UObject* _pWorldContext);

	void AddAmmunitionByType(EItemValueTypeEnum _eType, int32 _iAmount);
	void AddAnalProbeAmmunition(int32 _iAmount);
	void AddDisintegratorRayAmmunition(int32 _iAmount);
	void AddIonDetonatorAmmunition(int32 _iAmount);
	void AddSaucerQuantumDeconstructorAmmunition(int32 _iAmount);
	void AddSaucerSonicBoomAmmunition(int32 _iAmount);
	int32 GetAmmunitionByType(EItemValueTypeEnum _eType);
	int32 GetMaxAmmunitionByType(EItemValueTypeEnum _eType);
	class ABFGWeapon* GetWeaponByAmmunitionType(EItemValueTypeEnum _eType);
	void SetSelectedSkin(const struct FGameplayTag& _oNewSkinTag, bool _bIsSkinSelectionMenu, bool _bByUserChanged);

	int32 GetAnalProbAmmunition() const;
	int32 GetDisintegratorAmmunition() const;
	int32 GetIonDetonatorAmmunition() const;
	int32 GetSaucerQuantumAmmunition() const;
	int32 GetSaucerSonicBoomAmmunition() const;
	struct FGameplayTag GetSelectedSkin() const;
	class UBFGPlayerState_Unlocks* GetUnlocks() const;
	class UBFGPlayerState_Upgrades* GetUpgrades() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"BFGPlayerState">();
	}
	static class ABFGPlayerState* GetDefaultObj()
	{
		return GetDefaultObjImpl<ABFGPlayerState>();
	}
};
static_assert(alignof(ABFGPlayerState) == 0x000008, "Wrong alignment on ABFGPlayerState");
static_assert(sizeof(ABFGPlayerState) == 0x000638, "Wrong size on ABFGPlayerState");
static_assert(offsetof(ABFGPlayerState, M_oDefaultSkinTag) == 0x000510, "Member 'ABFGPlayerState::M_oDefaultSkinTag' has a wrong offset!");
static_assert(offsetof(ABFGPlayerState, M_pUpgradesTable) == 0x000518, "Member 'ABFGPlayerState::M_pUpgradesTable' has a wrong offset!");
static_assert(offsetof(ABFGPlayerState, M_pUpgrades) == 0x000520, "Member 'ABFGPlayerState::M_pUpgrades' has a wrong offset!");
static_assert(offsetof(ABFGPlayerState, M_aActorLookupTable) == 0x000560, "Member 'ABFGPlayerState::M_aActorLookupTable' has a wrong offset!");
static_assert(offsetof(ABFGPlayerState, M_iDNA) == 0x0005B0, "Member 'ABFGPlayerState::M_iDNA' has a wrong offset!");
static_assert(offsetof(ABFGPlayerState, M_pUnlocks) == 0x0005B8, "Member 'ABFGPlayerState::M_pUnlocks' has a wrong offset!");
static_assert(offsetof(ABFGPlayerState, M_fMonetaryValueCollected) == 0x0005C0, "Member 'ABFGPlayerState::M_fMonetaryValueCollected' has a wrong offset!");
static_assert(offsetof(ABFGPlayerState, M_aAmmo) == 0x0005C8, "Member 'ABFGPlayerState::M_aAmmo' has a wrong offset!");
static_assert(offsetof(ABFGPlayerState, M_oSelectedSkinTag) == 0x000618, "Member 'ABFGPlayerState::M_oSelectedSkinTag' has a wrong offset!");
static_assert(offsetof(ABFGPlayerState, M_collectables) == 0x000620, "Member 'ABFGPlayerState::M_collectables' has a wrong offset!");

// Class BFGCore.BFGTaskNode_LogEQSFallbackBranch
// 0x0008 (0x0080 - 0x0078)
class UBFGTaskNode_LogEQSFallbackBranch final : public UBFGBTBaseTaskNode
{
public:
	class UEnvQuery*                              M_pFailedQuery;                                    // 0x0078(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"BFGTaskNode_LogEQSFallbackBranch">();
	}
	static class UBFGTaskNode_LogEQSFallbackBranch* GetDefaultObj()
	{
		return GetDefaultObjImpl<UBFGTaskNode_LogEQSFallbackBranch>();
	}
};
static_assert(alignof(UBFGTaskNode_LogEQSFallbackBranch) == 0x000008, "Wrong alignment on UBFGTaskNode_LogEQSFallbackBranch");
static_assert(sizeof(UBFGTaskNode_LogEQSFallbackBranch) == 0x000080, "Wrong size on UBFGTaskNode_LogEQSFallbackBranch");
static_assert(offsetof(UBFGTaskNode_LogEQSFallbackBranch, M_pFailedQuery) == 0x000078, "Member 'UBFGTaskNode_LogEQSFallbackBranch::M_pFailedQuery' has a wrong offset!");

// Class BFGCore.BFGPlayerState_Unlocks
// 0x0118 (0x0140 - 0x0028)
class UBFGPlayerState_Unlocks final : public UObject
{
public:
	uint8                                         Pad_28[0x8];                                       // 0x0028(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	struct FGameplayTagContainer                  M_cachedUnlockedResult;                            // 0x0030(0x0020)(Transient, Protected, NativeAccessSpecifierProtected)
	struct FGameplayTagContainer                  M_cachedEverUnlockedResult;                        // 0x0050(0x0020)(Transient, Protected, NativeAccessSpecifierProtected)
	struct FGameplayTagContainer                  M_gameplayTagsUnlocked;                            // 0x0070(0x0020)(Transient, Protected, NativeAccessSpecifierProtected)
	struct FGameplayTagContainer                  M_gameplayTagsTempLocked;                          // 0x0090(0x0020)(Transient, Protected, NativeAccessSpecifierProtected)
	struct FGameplayTagContainer                  M_gameplayTagsTempUnlocked;                        // 0x00B0(0x0020)(Transient, Protected, NativeAccessSpecifierProtected)
	struct FGameplayTagContainer                  M_NotificationTagsSeen;                            // 0x00D0(0x0020)(Transient, Protected, NativeAccessSpecifierProtected)
	TSet<class FName>                             M_NotificationNamesSeen;                           // 0x00F0(0x0050)(ZeroConstructor, Transient, Protected, NativeAccessSpecifierProtected)

public:
	static void PlayerState_AddNameToNotificationList(class UObject* _pWorldContext, class FName _name);
	static void PlayerState_AddTagtoNotificationList(class UObject* _pWorldContext, const struct FGameplayTag& _tags);
	static bool PlayerState_HasNameInNotificationList(class UObject* _pWorldContext, class FName _name);
	static bool PlayerState_HasTaginNotificationList(class UObject* _pWorldContext, const struct FGameplayTag& _tags);
	static bool PlayerState_IsUnlockedTag(const class UObject* _pWorldContext, const struct FGameplayTag& _tag);
	static bool PlayerState_IsUnlockedTagExact(const class UObject* _pWorldContext, const struct FGameplayTag& _tag);
	static bool PlayerState_IsUnlockedTags(const class UObject* _pWorldContext, const struct FGameplayTagContainer& _tags);
	static bool PlayerState_IsUnlockedTagsExact(const class UObject* _pWorldContext, const struct FGameplayTagContainer& _tags);
	static bool PlayerState_LockTag(class UObject* _pWorldContext, const struct FGameplayTag& _tag);
	static bool PlayerState_LockTags(class UObject* _pWorldContext, const struct FGameplayTagContainer& _tags);
	static bool PlayerState_RemoveLockedTag(class UObject* _pWorldContext, const struct FGameplayTag& _tag);
	static bool PlayerState_RemoveLockedTags(class UObject* _pWorldContext, const struct FGameplayTagContainer& _tags);
	static bool PlayerState_UnlockTag(class UObject* _pWorldContext, const struct FGameplayTag& _tag, bool _bIsPermanent);
	static bool PlayerState_UnlockTags(class UObject* _pWorldContext, const struct FGameplayTagContainer& _tags, bool _bIsPermanent);

	void LockRemoveTag(const struct FGameplayTag& _tag, bool _bIsPermanent);
	void LockRemoveTags(const struct FGameplayTagContainer& _tags, bool _bIsPermanent);
	void RemoveLockedTag(const struct FGameplayTag& _tag);
	void RemoveLockedTags(const struct FGameplayTagContainer& _tags);
	void UnlockTag(const struct FGameplayTag& _tag, bool _bIsPermanent);
	void UnlockTags(const struct FGameplayTagContainer& _tags, bool _bIsPermanent);

	void GetTags(struct FGameplayTagContainer* _tagsOut) const;
	bool IsUnlockedQuery(const struct FGameplayTagQuery& _query) const;
	bool IsUnlockedTag(const struct FGameplayTag& _tag) const;
	bool IsUnlockedTagExact(const struct FGameplayTag& _tag) const;
	bool IsUnlockedTags(const struct FGameplayTagContainer& _tags) const;
	bool IsUnlockedTagsExact(const struct FGameplayTagContainer& _tags) const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"BFGPlayerState_Unlocks">();
	}
	static class UBFGPlayerState_Unlocks* GetDefaultObj()
	{
		return GetDefaultObjImpl<UBFGPlayerState_Unlocks>();
	}
};
static_assert(alignof(UBFGPlayerState_Unlocks) == 0x000008, "Wrong alignment on UBFGPlayerState_Unlocks");
static_assert(sizeof(UBFGPlayerState_Unlocks) == 0x000140, "Wrong size on UBFGPlayerState_Unlocks");
static_assert(offsetof(UBFGPlayerState_Unlocks, M_cachedUnlockedResult) == 0x000030, "Member 'UBFGPlayerState_Unlocks::M_cachedUnlockedResult' has a wrong offset!");
static_assert(offsetof(UBFGPlayerState_Unlocks, M_cachedEverUnlockedResult) == 0x000050, "Member 'UBFGPlayerState_Unlocks::M_cachedEverUnlockedResult' has a wrong offset!");
static_assert(offsetof(UBFGPlayerState_Unlocks, M_gameplayTagsUnlocked) == 0x000070, "Member 'UBFGPlayerState_Unlocks::M_gameplayTagsUnlocked' has a wrong offset!");
static_assert(offsetof(UBFGPlayerState_Unlocks, M_gameplayTagsTempLocked) == 0x000090, "Member 'UBFGPlayerState_Unlocks::M_gameplayTagsTempLocked' has a wrong offset!");
static_assert(offsetof(UBFGPlayerState_Unlocks, M_gameplayTagsTempUnlocked) == 0x0000B0, "Member 'UBFGPlayerState_Unlocks::M_gameplayTagsTempUnlocked' has a wrong offset!");
static_assert(offsetof(UBFGPlayerState_Unlocks, M_NotificationTagsSeen) == 0x0000D0, "Member 'UBFGPlayerState_Unlocks::M_NotificationTagsSeen' has a wrong offset!");
static_assert(offsetof(UBFGPlayerState_Unlocks, M_NotificationNamesSeen) == 0x0000F0, "Member 'UBFGPlayerState_Unlocks::M_NotificationNamesSeen' has a wrong offset!");

// Class BFGCore.BFGPlayerState_Upgrades
// 0x0008 (0x0030 - 0x0028)
class UBFGPlayerState_Upgrades final : public UObject
{
public:
	class ABFGPlayerState*                        M_pPlayerState;                                    // 0x0028(0x0008)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)

public:
	bool TryUpgrade(const struct FGameplayTag& _rUpgradeTag);

	bool HasItemUpgrade(const struct FGameplayTag& _rUpgradeTag) const;
	bool IsItemPurchaseable(const struct FGameplayTag& _rUpgradeTag) const;
	bool IsItemUnlocked(const struct FGameplayTag& _rItemTag) const;
	bool IsUpgradeable(const struct FGameplayTag& _rUpgradeTag) const;
	bool IsUpgraded(const struct FGameplayTag& _rUpgradeTag) const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"BFGPlayerState_Upgrades">();
	}
	static class UBFGPlayerState_Upgrades* GetDefaultObj()
	{
		return GetDefaultObjImpl<UBFGPlayerState_Upgrades>();
	}
};
static_assert(alignof(UBFGPlayerState_Upgrades) == 0x000008, "Wrong alignment on UBFGPlayerState_Upgrades");
static_assert(sizeof(UBFGPlayerState_Upgrades) == 0x000030, "Wrong size on UBFGPlayerState_Upgrades");
static_assert(offsetof(UBFGPlayerState_Upgrades, M_pPlayerState) == 0x000028, "Member 'UBFGPlayerState_Upgrades::M_pPlayerState' has a wrong offset!");

// Class BFGCore.BFGPlayerUFO_Settings
// 0x0058 (0x0090 - 0x0038)
class UBFGPlayerUFO_Settings final : public UDeveloperSettings
{
public:
	struct FSoftClassPath                         M_weaponSwitchMenu;                                // 0x0038(0x0018)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Config, NativeAccessSpecifierPublic)
	struct FSoftClassPath                         M_weaponSwitchMenuOptionClass;                     // 0x0050(0x0018)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Config, NativeAccessSpecifierPublic)
	TArray<struct FBFGPlayerSettingsWeaponInfo>   M_aWeapons;                                        // 0x0068(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Config, ContainsInstancedReference, NativeAccessSpecifierPublic)
	class FText                                   M_weaponSwitchMenuTitleHint;                       // 0x0078(0x0018)(Edit, BlueprintVisible, BlueprintReadOnly, Config, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"BFGPlayerUFO_Settings">();
	}
	static class UBFGPlayerUFO_Settings* GetDefaultObj()
	{
		return GetDefaultObjImpl<UBFGPlayerUFO_Settings>();
	}
};
static_assert(alignof(UBFGPlayerUFO_Settings) == 0x000008, "Wrong alignment on UBFGPlayerUFO_Settings");
static_assert(sizeof(UBFGPlayerUFO_Settings) == 0x000090, "Wrong size on UBFGPlayerUFO_Settings");
static_assert(offsetof(UBFGPlayerUFO_Settings, M_weaponSwitchMenu) == 0x000038, "Member 'UBFGPlayerUFO_Settings::M_weaponSwitchMenu' has a wrong offset!");
static_assert(offsetof(UBFGPlayerUFO_Settings, M_weaponSwitchMenuOptionClass) == 0x000050, "Member 'UBFGPlayerUFO_Settings::M_weaponSwitchMenuOptionClass' has a wrong offset!");
static_assert(offsetof(UBFGPlayerUFO_Settings, M_aWeapons) == 0x000068, "Member 'UBFGPlayerUFO_Settings::M_aWeapons' has a wrong offset!");
static_assert(offsetof(UBFGPlayerUFO_Settings, M_weaponSwitchMenuTitleHint) == 0x000078, "Member 'UBFGPlayerUFO_Settings::M_weaponSwitchMenuTitleHint' has a wrong offset!");

// Class BFGCore.BFGPoolInterface
// 0x0000 (0x0028 - 0x0028)
class IBFGPoolInterface final : public IInterface
{
public:
	void OnRetrieveFromPool(bool _bAutomaticallyReactivateComponents);
	void OnReturnToPool();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"BFGPoolInterface">();
	}
	static class IBFGPoolInterface* GetDefaultObj()
	{
		return GetDefaultObjImpl<IBFGPoolInterface>();
	}
};
static_assert(alignof(IBFGPoolInterface) == 0x000008, "Wrong alignment on IBFGPoolInterface");
static_assert(sizeof(IBFGPoolInterface) == 0x000028, "Wrong size on IBFGPoolInterface");

// Class BFGCore.BFGPrintToStringInterface
// 0x0000 (0x0028 - 0x0028)
class IBFGPrintToStringInterface final : public IInterface
{
public:
	class FString PrintNameToString() const;
	class FString PrintToString() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"BFGPrintToStringInterface">();
	}
	static class IBFGPrintToStringInterface* GetDefaultObj()
	{
		return GetDefaultObjImpl<IBFGPrintToStringInterface>();
	}
};
static_assert(alignof(IBFGPrintToStringInterface) == 0x000008, "Wrong alignment on IBFGPrintToStringInterface");
static_assert(sizeof(IBFGPrintToStringInterface) == 0x000028, "Wrong size on IBFGPrintToStringInterface");

// Class BFGCore.BFGTaskNode_PlayCrowdLifeStationAnim
// 0x0030 (0x00A8 - 0x0078)
class UBFGTaskNode_PlayCrowdLifeStationAnim final : public UBFGBTBaseTaskNode
{
public:
	struct FBlackboardKeySelector                 M_BBKey_CrowdLifeStation;                          // 0x0078(0x0028)(Edit, NativeAccessSpecifierPublic)
	class UBFGPlayCrowdLifeStationAnim*           M_pPlayCrowdLifeAnim;                              // 0x00A0(0x0008)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"BFGTaskNode_PlayCrowdLifeStationAnim">();
	}
	static class UBFGTaskNode_PlayCrowdLifeStationAnim* GetDefaultObj()
	{
		return GetDefaultObjImpl<UBFGTaskNode_PlayCrowdLifeStationAnim>();
	}
};
static_assert(alignof(UBFGTaskNode_PlayCrowdLifeStationAnim) == 0x000008, "Wrong alignment on UBFGTaskNode_PlayCrowdLifeStationAnim");
static_assert(sizeof(UBFGTaskNode_PlayCrowdLifeStationAnim) == 0x0000A8, "Wrong size on UBFGTaskNode_PlayCrowdLifeStationAnim");
static_assert(offsetof(UBFGTaskNode_PlayCrowdLifeStationAnim, M_BBKey_CrowdLifeStation) == 0x000078, "Member 'UBFGTaskNode_PlayCrowdLifeStationAnim::M_BBKey_CrowdLifeStation' has a wrong offset!");
static_assert(offsetof(UBFGTaskNode_PlayCrowdLifeStationAnim, M_pPlayCrowdLifeAnim) == 0x0000A0, "Member 'UBFGTaskNode_PlayCrowdLifeStationAnim::M_pPlayCrowdLifeAnim' has a wrong offset!");

// Class BFGCore.BFGProjectile_AnalProbe
// 0x00A0 (0x0718 - 0x0678)
class ABFGProjectile_AnalProbe : public ABFGProjectile_Object
{
public:
	struct FSoftClassPath                         M_SpawnedAmmoClass;                                // 0x0678(0x0018)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, NativeAccessSpecifierPublic)
	float                                         M_fNoTargetTravelDistance;                         // 0x0690(0x0004)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_694[0x14];                                     // 0x0694(0x0014)(Fixing Size After Last Property [ Dumper-7 ])
	class AActor*                                 M_pTargetActor;                                    // 0x06A8(0x0008)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TArray<class AActor*>                         M_aTargetActorHistory;                             // 0x06B0(0x0010)(ZeroConstructor, Transient, Protected, NativeAccessSpecifierProtected)
	TArray<class AActor*>                         M_apBrainsExtracted;                               // 0x06C0(0x0010)(ZeroConstructor, Transient, Protected, NativeAccessSpecifierProtected)
	int32                                         M_iJumpTargetCount;                                // 0x06D0(0x0004)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_6D4[0x4];                                      // 0x06D4(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class UBFGActorComponent_PawnStats*           M_pTargetActorPawnStats;                           // 0x06D8(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class ABFGWeapon_AnalProbe*                   M_pAnalProbe;                                      // 0x06E0(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         M_fTravelToTime;                                   // 0x06E8(0x0004)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_6EC[0x4];                                      // 0x06EC(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         M_fFullProbingTime;                                // 0x06F0(0x0004)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         M_fFullDamageOverTime;                             // 0x06F4(0x0004)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         M_fFullDamageInterval;                             // 0x06F8(0x0004)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_6FC[0x8];                                      // 0x06FC(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         M_fTravelBackTime;                                 // 0x0704(0x0004)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_708[0x4];                                      // 0x0708(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class FName                                   M_oAmmoPackSpawnSocketName;                        // 0x070C(0x0008)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_714[0x4];                                      // 0x0714(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void OnConnectedToTarget();

	class AActor* GetTargetActor() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"BFGProjectile_AnalProbe">();
	}
	static class ABFGProjectile_AnalProbe* GetDefaultObj()
	{
		return GetDefaultObjImpl<ABFGProjectile_AnalProbe>();
	}
};
static_assert(alignof(ABFGProjectile_AnalProbe) == 0x000008, "Wrong alignment on ABFGProjectile_AnalProbe");
static_assert(sizeof(ABFGProjectile_AnalProbe) == 0x000718, "Wrong size on ABFGProjectile_AnalProbe");
static_assert(offsetof(ABFGProjectile_AnalProbe, M_SpawnedAmmoClass) == 0x000678, "Member 'ABFGProjectile_AnalProbe::M_SpawnedAmmoClass' has a wrong offset!");
static_assert(offsetof(ABFGProjectile_AnalProbe, M_fNoTargetTravelDistance) == 0x000690, "Member 'ABFGProjectile_AnalProbe::M_fNoTargetTravelDistance' has a wrong offset!");
static_assert(offsetof(ABFGProjectile_AnalProbe, M_pTargetActor) == 0x0006A8, "Member 'ABFGProjectile_AnalProbe::M_pTargetActor' has a wrong offset!");
static_assert(offsetof(ABFGProjectile_AnalProbe, M_aTargetActorHistory) == 0x0006B0, "Member 'ABFGProjectile_AnalProbe::M_aTargetActorHistory' has a wrong offset!");
static_assert(offsetof(ABFGProjectile_AnalProbe, M_apBrainsExtracted) == 0x0006C0, "Member 'ABFGProjectile_AnalProbe::M_apBrainsExtracted' has a wrong offset!");
static_assert(offsetof(ABFGProjectile_AnalProbe, M_iJumpTargetCount) == 0x0006D0, "Member 'ABFGProjectile_AnalProbe::M_iJumpTargetCount' has a wrong offset!");
static_assert(offsetof(ABFGProjectile_AnalProbe, M_pTargetActorPawnStats) == 0x0006D8, "Member 'ABFGProjectile_AnalProbe::M_pTargetActorPawnStats' has a wrong offset!");
static_assert(offsetof(ABFGProjectile_AnalProbe, M_pAnalProbe) == 0x0006E0, "Member 'ABFGProjectile_AnalProbe::M_pAnalProbe' has a wrong offset!");
static_assert(offsetof(ABFGProjectile_AnalProbe, M_fTravelToTime) == 0x0006E8, "Member 'ABFGProjectile_AnalProbe::M_fTravelToTime' has a wrong offset!");
static_assert(offsetof(ABFGProjectile_AnalProbe, M_fFullProbingTime) == 0x0006F0, "Member 'ABFGProjectile_AnalProbe::M_fFullProbingTime' has a wrong offset!");
static_assert(offsetof(ABFGProjectile_AnalProbe, M_fFullDamageOverTime) == 0x0006F4, "Member 'ABFGProjectile_AnalProbe::M_fFullDamageOverTime' has a wrong offset!");
static_assert(offsetof(ABFGProjectile_AnalProbe, M_fFullDamageInterval) == 0x0006F8, "Member 'ABFGProjectile_AnalProbe::M_fFullDamageInterval' has a wrong offset!");
static_assert(offsetof(ABFGProjectile_AnalProbe, M_fTravelBackTime) == 0x000704, "Member 'ABFGProjectile_AnalProbe::M_fTravelBackTime' has a wrong offset!");
static_assert(offsetof(ABFGProjectile_AnalProbe, M_oAmmoPackSpawnSocketName) == 0x00070C, "Member 'ABFGProjectile_AnalProbe::M_oAmmoPackSpawnSocketName' has a wrong offset!");

// Class BFGCore.BFGProjectile_BeamDeathray
// 0x0028 (0x0648 - 0x0620)
class ABFGProjectile_BeamDeathray : public ABFGProjectile_Beam
{
public:
	float                                         M_fDeadZoneRadius;                                 // 0x0620(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         M_fDeadzoneDuration;                               // 0x0624(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         M_fDeadzoneTickFrequency;                          // 0x0628(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         M_fDeadzoneTickDamage;                             // 0x062C(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         M_fDeadZonePhysicsImpulse;                         // 0x0630(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         M_iFoliageDetectionRaycastAmount;                  // 0x0634(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         M_iCount;                                          // 0x0638(0x0004)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_63C[0x4];                                      // 0x063C(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class ABFGActorOcean*                         M_pOceanActor;                                     // 0x0640(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)

public:
	void OnHitFoliage(const struct FHitResult& _oHitResult);
	void OnSetOnFire(class AActor* _pActor);
	void OnSpawnDeadzone(const struct FBFGDeathrayZoneData& _oDeadzone);
	void OnTickDeadzone(const struct FBFGDeathrayZoneData& _oDeadzone);
	void UpdateBeamOnOcean(const struct FVector& _vTargetLocation, bool _bHitTarget, const struct FVector& _vImpactNormal);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"BFGProjectile_BeamDeathray">();
	}
	static class ABFGProjectile_BeamDeathray* GetDefaultObj()
	{
		return GetDefaultObjImpl<ABFGProjectile_BeamDeathray>();
	}
};
static_assert(alignof(ABFGProjectile_BeamDeathray) == 0x000008, "Wrong alignment on ABFGProjectile_BeamDeathray");
static_assert(sizeof(ABFGProjectile_BeamDeathray) == 0x000648, "Wrong size on ABFGProjectile_BeamDeathray");
static_assert(offsetof(ABFGProjectile_BeamDeathray, M_fDeadZoneRadius) == 0x000620, "Member 'ABFGProjectile_BeamDeathray::M_fDeadZoneRadius' has a wrong offset!");
static_assert(offsetof(ABFGProjectile_BeamDeathray, M_fDeadzoneDuration) == 0x000624, "Member 'ABFGProjectile_BeamDeathray::M_fDeadzoneDuration' has a wrong offset!");
static_assert(offsetof(ABFGProjectile_BeamDeathray, M_fDeadzoneTickFrequency) == 0x000628, "Member 'ABFGProjectile_BeamDeathray::M_fDeadzoneTickFrequency' has a wrong offset!");
static_assert(offsetof(ABFGProjectile_BeamDeathray, M_fDeadzoneTickDamage) == 0x00062C, "Member 'ABFGProjectile_BeamDeathray::M_fDeadzoneTickDamage' has a wrong offset!");
static_assert(offsetof(ABFGProjectile_BeamDeathray, M_fDeadZonePhysicsImpulse) == 0x000630, "Member 'ABFGProjectile_BeamDeathray::M_fDeadZonePhysicsImpulse' has a wrong offset!");
static_assert(offsetof(ABFGProjectile_BeamDeathray, M_iFoliageDetectionRaycastAmount) == 0x000634, "Member 'ABFGProjectile_BeamDeathray::M_iFoliageDetectionRaycastAmount' has a wrong offset!");
static_assert(offsetof(ABFGProjectile_BeamDeathray, M_iCount) == 0x000638, "Member 'ABFGProjectile_BeamDeathray::M_iCount' has a wrong offset!");
static_assert(offsetof(ABFGProjectile_BeamDeathray, M_pOceanActor) == 0x000640, "Member 'ABFGProjectile_BeamDeathray::M_pOceanActor' has a wrong offset!");

// Class BFGCore.BFGTaskNode_Roboprez_FollowTransitionPath
// 0x0020 (0x0098 - 0x0078)
class UBFGTaskNode_Roboprez_FollowTransitionPath final : public UBFGBTBaseTaskNode
{
public:
	class UBehaviorTreeComponent*                 M_pOwnerComp;                                      // 0x0078(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class ABFGNPCCharacterBoss_Roboprez*          M_pRoboprez;                                       // 0x0080(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class ABFGBoss_TransitionPath*                M_pTransitionPath;                                 // 0x0088(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class AAIController*                          M_pAIController;                                   // 0x0090(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)

public:
	void FollowSplinePath();
	void OnSplinePathComplete();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"BFGTaskNode_Roboprez_FollowTransitionPath">();
	}
	static class UBFGTaskNode_Roboprez_FollowTransitionPath* GetDefaultObj()
	{
		return GetDefaultObjImpl<UBFGTaskNode_Roboprez_FollowTransitionPath>();
	}
};
static_assert(alignof(UBFGTaskNode_Roboprez_FollowTransitionPath) == 0x000008, "Wrong alignment on UBFGTaskNode_Roboprez_FollowTransitionPath");
static_assert(sizeof(UBFGTaskNode_Roboprez_FollowTransitionPath) == 0x000098, "Wrong size on UBFGTaskNode_Roboprez_FollowTransitionPath");
static_assert(offsetof(UBFGTaskNode_Roboprez_FollowTransitionPath, M_pOwnerComp) == 0x000078, "Member 'UBFGTaskNode_Roboprez_FollowTransitionPath::M_pOwnerComp' has a wrong offset!");
static_assert(offsetof(UBFGTaskNode_Roboprez_FollowTransitionPath, M_pRoboprez) == 0x000080, "Member 'UBFGTaskNode_Roboprez_FollowTransitionPath::M_pRoboprez' has a wrong offset!");
static_assert(offsetof(UBFGTaskNode_Roboprez_FollowTransitionPath, M_pTransitionPath) == 0x000088, "Member 'UBFGTaskNode_Roboprez_FollowTransitionPath::M_pTransitionPath' has a wrong offset!");
static_assert(offsetof(UBFGTaskNode_Roboprez_FollowTransitionPath, M_pAIController) == 0x000090, "Member 'UBFGTaskNode_Roboprez_FollowTransitionPath::M_pAIController' has a wrong offset!");

// Class BFGCore.BFGProjectile_BeamEnemy
// 0x0000 (0x0620 - 0x0620)
class ABFGProjectile_BeamEnemy final : public ABFGProjectile_Beam
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"BFGProjectile_BeamEnemy">();
	}
	static class ABFGProjectile_BeamEnemy* GetDefaultObj()
	{
		return GetDefaultObjImpl<ABFGProjectile_BeamEnemy>();
	}
};
static_assert(alignof(ABFGProjectile_BeamEnemy) == 0x000008, "Wrong alignment on ABFGProjectile_BeamEnemy");
static_assert(sizeof(ABFGProjectile_BeamEnemy) == 0x000620, "Wrong size on ABFGProjectile_BeamEnemy");

// Class BFGCore.BFGProjectile_BeamZapomatic
// 0x0090 (0x06B0 - 0x0620)
class ABFGProjectile_BeamZapomatic : public ABFGProjectile_Beam
{
public:
	int32                                         M_iIRIDIUM_NumberPossibleJumps;                    // 0x0620(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         M_fIRIDIUM_InitialJumpDistance;                    // 0x0624(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         M_fIRIDIUM_RangeReductionPerJump;                  // 0x0628(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         M_fIRIDIUM_DamagePercentPerJump;                   // 0x062C(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         M_iIridiumSpreaderNumberOfJumps;                   // 0x0630(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         M_fCompoundRIzer_DamagePercentPerJump;             // 0x0634(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         M_fGortanShockMultiplier_ExtraDamageMultiplier;    // 0x0638(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_63C[0x4];                                      // 0x063C(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	TMap<class AActor*, float>                    M_aZappedActorList;                                // 0x0640(0x0050)(ZeroConstructor, Transient, Protected, NativeAccessSpecifierProtected)
	TArray<struct FBFGZapomaticBeamData>          M_aActiveBeamEffects;                              // 0x0690(0x0010)(ZeroConstructor, Transient, Protected, NativeAccessSpecifierProtected)
	TArray<struct FBFGZapomaticZappedUnitData>    M_aAllHitActorList;                                // 0x06A0(0x0010)(ZeroConstructor, Transient, Protected, NativeAccessSpecifierProtected)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"BFGProjectile_BeamZapomatic">();
	}
	static class ABFGProjectile_BeamZapomatic* GetDefaultObj()
	{
		return GetDefaultObjImpl<ABFGProjectile_BeamZapomatic>();
	}
};
static_assert(alignof(ABFGProjectile_BeamZapomatic) == 0x000008, "Wrong alignment on ABFGProjectile_BeamZapomatic");
static_assert(sizeof(ABFGProjectile_BeamZapomatic) == 0x0006B0, "Wrong size on ABFGProjectile_BeamZapomatic");
static_assert(offsetof(ABFGProjectile_BeamZapomatic, M_iIRIDIUM_NumberPossibleJumps) == 0x000620, "Member 'ABFGProjectile_BeamZapomatic::M_iIRIDIUM_NumberPossibleJumps' has a wrong offset!");
static_assert(offsetof(ABFGProjectile_BeamZapomatic, M_fIRIDIUM_InitialJumpDistance) == 0x000624, "Member 'ABFGProjectile_BeamZapomatic::M_fIRIDIUM_InitialJumpDistance' has a wrong offset!");
static_assert(offsetof(ABFGProjectile_BeamZapomatic, M_fIRIDIUM_RangeReductionPerJump) == 0x000628, "Member 'ABFGProjectile_BeamZapomatic::M_fIRIDIUM_RangeReductionPerJump' has a wrong offset!");
static_assert(offsetof(ABFGProjectile_BeamZapomatic, M_fIRIDIUM_DamagePercentPerJump) == 0x00062C, "Member 'ABFGProjectile_BeamZapomatic::M_fIRIDIUM_DamagePercentPerJump' has a wrong offset!");
static_assert(offsetof(ABFGProjectile_BeamZapomatic, M_iIridiumSpreaderNumberOfJumps) == 0x000630, "Member 'ABFGProjectile_BeamZapomatic::M_iIridiumSpreaderNumberOfJumps' has a wrong offset!");
static_assert(offsetof(ABFGProjectile_BeamZapomatic, M_fCompoundRIzer_DamagePercentPerJump) == 0x000634, "Member 'ABFGProjectile_BeamZapomatic::M_fCompoundRIzer_DamagePercentPerJump' has a wrong offset!");
static_assert(offsetof(ABFGProjectile_BeamZapomatic, M_fGortanShockMultiplier_ExtraDamageMultiplier) == 0x000638, "Member 'ABFGProjectile_BeamZapomatic::M_fGortanShockMultiplier_ExtraDamageMultiplier' has a wrong offset!");
static_assert(offsetof(ABFGProjectile_BeamZapomatic, M_aZappedActorList) == 0x000640, "Member 'ABFGProjectile_BeamZapomatic::M_aZappedActorList' has a wrong offset!");
static_assert(offsetof(ABFGProjectile_BeamZapomatic, M_aActiveBeamEffects) == 0x000690, "Member 'ABFGProjectile_BeamZapomatic::M_aActiveBeamEffects' has a wrong offset!");
static_assert(offsetof(ABFGProjectile_BeamZapomatic, M_aAllHitActorList) == 0x0006A0, "Member 'ABFGProjectile_BeamZapomatic::M_aAllHitActorList' has a wrong offset!");

// Class BFGCore.BFGProjectile_BossAOE
// 0x0090 (0x0708 - 0x0678)
class ABFGProjectile_BossAOE : public ABFGProjectile_Object
{
public:
	TSubclassOf<class ABFGAOE>                    M_pAOEClass;                                       // 0x0678(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UBFGActorComponent_AOEWarningMarker*    M_pWarningMarkerComponent;                         // 0x0680(0x0008)(Edit, ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UCurveFloat*                            M_pWarningMarkerAnimationCurve;                    // 0x0688(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TSubclassOf<class ABFGEffectActor>            M_pTelegraphEffectActorClass;                      // 0x0690(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class ABFGEffectActor*                        M_pTelegraphEffectActor;                           // 0x0698(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UParticleSystem*                        PPFXRocketMuzzleFlash;                             // 0x06A0(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         M_fShiftLocForward;                                // 0x06A8(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_6AC[0x4];                                      // 0x06AC(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class USceneComponent*                        M_pScene;                                          // 0x06B0(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UStaticMeshComponent*                   M_pStaticMeshComponent;                            // 0x06B8(0x0008)(Edit, ExportObject, ZeroConstructor, EditConst, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class USplineComponent*                       M_pSpline;                                         // 0x06C0(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_6C8[0x38];                                     // 0x06C8(0x0038)(Fixing Size After Last Property [ Dumper-7 ])
	class UParticleSystemComponent*               M_pMuzzleFlashParticle;                            // 0x0700(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"BFGProjectile_BossAOE">();
	}
	static class ABFGProjectile_BossAOE* GetDefaultObj()
	{
		return GetDefaultObjImpl<ABFGProjectile_BossAOE>();
	}
};
static_assert(alignof(ABFGProjectile_BossAOE) == 0x000008, "Wrong alignment on ABFGProjectile_BossAOE");
static_assert(sizeof(ABFGProjectile_BossAOE) == 0x000708, "Wrong size on ABFGProjectile_BossAOE");
static_assert(offsetof(ABFGProjectile_BossAOE, M_pAOEClass) == 0x000678, "Member 'ABFGProjectile_BossAOE::M_pAOEClass' has a wrong offset!");
static_assert(offsetof(ABFGProjectile_BossAOE, M_pWarningMarkerComponent) == 0x000680, "Member 'ABFGProjectile_BossAOE::M_pWarningMarkerComponent' has a wrong offset!");
static_assert(offsetof(ABFGProjectile_BossAOE, M_pWarningMarkerAnimationCurve) == 0x000688, "Member 'ABFGProjectile_BossAOE::M_pWarningMarkerAnimationCurve' has a wrong offset!");
static_assert(offsetof(ABFGProjectile_BossAOE, M_pTelegraphEffectActorClass) == 0x000690, "Member 'ABFGProjectile_BossAOE::M_pTelegraphEffectActorClass' has a wrong offset!");
static_assert(offsetof(ABFGProjectile_BossAOE, M_pTelegraphEffectActor) == 0x000698, "Member 'ABFGProjectile_BossAOE::M_pTelegraphEffectActor' has a wrong offset!");
static_assert(offsetof(ABFGProjectile_BossAOE, PPFXRocketMuzzleFlash) == 0x0006A0, "Member 'ABFGProjectile_BossAOE::PPFXRocketMuzzleFlash' has a wrong offset!");
static_assert(offsetof(ABFGProjectile_BossAOE, M_fShiftLocForward) == 0x0006A8, "Member 'ABFGProjectile_BossAOE::M_fShiftLocForward' has a wrong offset!");
static_assert(offsetof(ABFGProjectile_BossAOE, M_pScene) == 0x0006B0, "Member 'ABFGProjectile_BossAOE::M_pScene' has a wrong offset!");
static_assert(offsetof(ABFGProjectile_BossAOE, M_pStaticMeshComponent) == 0x0006B8, "Member 'ABFGProjectile_BossAOE::M_pStaticMeshComponent' has a wrong offset!");
static_assert(offsetof(ABFGProjectile_BossAOE, M_pSpline) == 0x0006C0, "Member 'ABFGProjectile_BossAOE::M_pSpline' has a wrong offset!");
static_assert(offsetof(ABFGProjectile_BossAOE, M_pMuzzleFlashParticle) == 0x000700, "Member 'ABFGProjectile_BossAOE::M_pMuzzleFlashParticle' has a wrong offset!");

// Class BFGCore.BFGProjectile_BossAOE_AirMine
// 0x0008 (0x0710 - 0x0708)
class ABFGProjectile_BossAOE_AirMine final : public ABFGProjectile_BossAOE
{
public:
	TSubclassOf<class ABFGNPCCharacterEnemy_Mine_Roboprez> M_pMineClass;                                      // 0x0708(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"BFGProjectile_BossAOE_AirMine">();
	}
	static class ABFGProjectile_BossAOE_AirMine* GetDefaultObj()
	{
		return GetDefaultObjImpl<ABFGProjectile_BossAOE_AirMine>();
	}
};
static_assert(alignof(ABFGProjectile_BossAOE_AirMine) == 0x000008, "Wrong alignment on ABFGProjectile_BossAOE_AirMine");
static_assert(sizeof(ABFGProjectile_BossAOE_AirMine) == 0x000710, "Wrong size on ABFGProjectile_BossAOE_AirMine");
static_assert(offsetof(ABFGProjectile_BossAOE_AirMine, M_pMineClass) == 0x000708, "Member 'ABFGProjectile_BossAOE_AirMine::M_pMineClass' has a wrong offset!");

// Class BFGCore.BFGProjectile_BossAOE_ParticleExploder
// 0x0008 (0x0710 - 0x0708)
class ABFGProjectile_BossAOE_ParticleExploder final : public ABFGProjectile_BossAOE
{
public:
	TSubclassOf<class ABFGNPCCharacterEnemy_Mine_ParticleExploder> M_pMineClass;                                      // 0x0708(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"BFGProjectile_BossAOE_ParticleExploder">();
	}
	static class ABFGProjectile_BossAOE_ParticleExploder* GetDefaultObj()
	{
		return GetDefaultObjImpl<ABFGProjectile_BossAOE_ParticleExploder>();
	}
};
static_assert(alignof(ABFGProjectile_BossAOE_ParticleExploder) == 0x000008, "Wrong alignment on ABFGProjectile_BossAOE_ParticleExploder");
static_assert(sizeof(ABFGProjectile_BossAOE_ParticleExploder) == 0x000710, "Wrong size on ABFGProjectile_BossAOE_ParticleExploder");
static_assert(offsetof(ABFGProjectile_BossAOE_ParticleExploder, M_pMineClass) == 0x000708, "Member 'ABFGProjectile_BossAOE_ParticleExploder::M_pMineClass' has a wrong offset!");

// Class BFGCore.BFGSpinningWidget
// 0x0098 (0x02F8 - 0x0260)
class UBFGSpinningWidget final : public UBFGWidget_DialogOption
{
public:
	float                                         M_fSpinningSpeed;                                  // 0x0260(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_264[0x4];                                      // 0x0264(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	UMulticastDelegateProperty_                   M_OnIndexChanged;                                  // 0x0268(0x0018)(ZeroConstructor, InstancedReference, NativeAccessSpecifierPublic)
	TArray<class UBFGSpinningWidgetOption*>       M_pOptions;                                        // 0x0280(0x0010)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, ContainsInstancedReference, NativeAccessSpecifierPublic)
	class UCanvasPanel*                           M_pCanvasPanel;                                    // 0x0290(0x0008)(BlueprintVisible, ExportObject, ZeroConstructor, Transient, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         M_fMaxBoundaries;                                  // 0x0298(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         M_fMinBoundaries;                                  // 0x029C(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         M_fMinScaleWidget;                                 // 0x02A0(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         M_fVerticalAlignment;                              // 0x02A4(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	UMulticastDelegateProperty_                   M_OnAccepted;                                      // 0x02A8(0x0018)(ZeroConstructor, InstancedReference, NativeAccessSpecifierPublic)
	int32                                         M_iIndexCurrent;                                   // 0x02C0(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	int32                                         M_iIndexTarget;                                    // 0x02C4(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_2C8[0x20];                                     // 0x02C8(0x0020)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<int32>                                 M_aOptions;                                        // 0x02E8(0x0010)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Protected, NativeAccessSpecifierProtected)

public:
	void Action__DelegateSignature();
	void AddOption(class UBFGSpinningWidgetOption* _pOption);
	void AddOptionToLayout(class UBFGSpinningWidgetOption* _pOption);
	void ClearLayout();
	void ClearOptions();
	class UCanvasPanel* GetCanvasPanel();
	void OnButtonCenter();
	void OnButtonLeft();
	void OnButtonRight();
	void OnSFX_Spin();
	void OnSpinningDone();
	void SetFrameSize(float _fX, float _fY);
	void SpinBack(int32 _iSteps);
	void SpinForward(int32 _iSteps);

	class UBFGSpinningWidgetOption* GetOption(int32 _iIndex) const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"BFGSpinningWidget">();
	}
	static class UBFGSpinningWidget* GetDefaultObj()
	{
		return GetDefaultObjImpl<UBFGSpinningWidget>();
	}
};
static_assert(alignof(UBFGSpinningWidget) == 0x000008, "Wrong alignment on UBFGSpinningWidget");
static_assert(sizeof(UBFGSpinningWidget) == 0x0002F8, "Wrong size on UBFGSpinningWidget");
static_assert(offsetof(UBFGSpinningWidget, M_fSpinningSpeed) == 0x000260, "Member 'UBFGSpinningWidget::M_fSpinningSpeed' has a wrong offset!");
static_assert(offsetof(UBFGSpinningWidget, M_OnIndexChanged) == 0x000268, "Member 'UBFGSpinningWidget::M_OnIndexChanged' has a wrong offset!");
static_assert(offsetof(UBFGSpinningWidget, M_pOptions) == 0x000280, "Member 'UBFGSpinningWidget::M_pOptions' has a wrong offset!");
static_assert(offsetof(UBFGSpinningWidget, M_pCanvasPanel) == 0x000290, "Member 'UBFGSpinningWidget::M_pCanvasPanel' has a wrong offset!");
static_assert(offsetof(UBFGSpinningWidget, M_fMaxBoundaries) == 0x000298, "Member 'UBFGSpinningWidget::M_fMaxBoundaries' has a wrong offset!");
static_assert(offsetof(UBFGSpinningWidget, M_fMinBoundaries) == 0x00029C, "Member 'UBFGSpinningWidget::M_fMinBoundaries' has a wrong offset!");
static_assert(offsetof(UBFGSpinningWidget, M_fMinScaleWidget) == 0x0002A0, "Member 'UBFGSpinningWidget::M_fMinScaleWidget' has a wrong offset!");
static_assert(offsetof(UBFGSpinningWidget, M_fVerticalAlignment) == 0x0002A4, "Member 'UBFGSpinningWidget::M_fVerticalAlignment' has a wrong offset!");
static_assert(offsetof(UBFGSpinningWidget, M_OnAccepted) == 0x0002A8, "Member 'UBFGSpinningWidget::M_OnAccepted' has a wrong offset!");
static_assert(offsetof(UBFGSpinningWidget, M_iIndexCurrent) == 0x0002C0, "Member 'UBFGSpinningWidget::M_iIndexCurrent' has a wrong offset!");
static_assert(offsetof(UBFGSpinningWidget, M_iIndexTarget) == 0x0002C4, "Member 'UBFGSpinningWidget::M_iIndexTarget' has a wrong offset!");
static_assert(offsetof(UBFGSpinningWidget, M_aOptions) == 0x0002E8, "Member 'UBFGSpinningWidget::M_aOptions' has a wrong offset!");

// Class BFGCore.BFGVariableType_MissionGroup
// 0x0000 (0x0090 - 0x0090)
class UBFGVariableType_MissionGroup final : public UBFGVariableType
{
public:
	static const class FName GetState_MissionGroupAborted();
	static const class FName GetState_MissionGroupAvailable();
	static const class FName GetState_MissionGroupFinished();
	static const class FName GetState_MissionGroupInProgress();
	static const class FName GetState_MissionGroupLocked();
	static const class FName GetTypeName_MissionGroup();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"BFGVariableType_MissionGroup">();
	}
	static class UBFGVariableType_MissionGroup* GetDefaultObj()
	{
		return GetDefaultObjImpl<UBFGVariableType_MissionGroup>();
	}
};
static_assert(alignof(UBFGVariableType_MissionGroup) == 0x000008, "Wrong alignment on UBFGVariableType_MissionGroup");
static_assert(sizeof(UBFGVariableType_MissionGroup) == 0x000090, "Wrong size on UBFGVariableType_MissionGroup");

// Class BFGCore.BFGProjectile_Grenade
// 0x0018 (0x0690 - 0x0678)
class ABFGProjectile_Grenade : public ABFGProjectile_Object
{
public:
	float                                         M_fFuseTime;                                       // 0x0678(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         M_fFuseTimer;                                      // 0x067C(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TSubclassOf<class ABFGEffectActor>            M_pEffectTelegraphClass;                           // 0x0680(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class ABFGEffectActor*                        M_pEffectTelegraphComp;                            // 0x0688(0x0008)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)

public:
	void OnFuseDone();
	void OnFuseUpdated();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"BFGProjectile_Grenade">();
	}
	static class ABFGProjectile_Grenade* GetDefaultObj()
	{
		return GetDefaultObjImpl<ABFGProjectile_Grenade>();
	}
};
static_assert(alignof(ABFGProjectile_Grenade) == 0x000008, "Wrong alignment on ABFGProjectile_Grenade");
static_assert(sizeof(ABFGProjectile_Grenade) == 0x000690, "Wrong size on ABFGProjectile_Grenade");
static_assert(offsetof(ABFGProjectile_Grenade, M_fFuseTime) == 0x000678, "Member 'ABFGProjectile_Grenade::M_fFuseTime' has a wrong offset!");
static_assert(offsetof(ABFGProjectile_Grenade, M_fFuseTimer) == 0x00067C, "Member 'ABFGProjectile_Grenade::M_fFuseTimer' has a wrong offset!");
static_assert(offsetof(ABFGProjectile_Grenade, M_pEffectTelegraphClass) == 0x000680, "Member 'ABFGProjectile_Grenade::M_pEffectTelegraphClass' has a wrong offset!");
static_assert(offsetof(ABFGProjectile_Grenade, M_pEffectTelegraphComp) == 0x000688, "Member 'ABFGProjectile_Grenade::M_pEffectTelegraphComp' has a wrong offset!");

// Class BFGCore.BFGStreamingLevelManager
// 0x0120 (0x0150 - 0x0030)
class UBFGStreamingLevelManager final : public UBFGGameSystem
{
public:
	uint8                                         Pad_30[0x8];                                       // 0x0030(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	UMulticastDelegateProperty_                   M_onStateChanged;                                  // 0x0038(0x0018)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	uint8                                         Pad_50[0x20];                                      // 0x0050(0x0020)(Fixing Size After Last Property [ Dumper-7 ])
	class ABFGGameState*                          M_pGameState;                                      // 0x0070(0x0008)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TMap<int32, class UBFGStreamingLevelHandle*>  M_aLevels;                                         // 0x0078(0x0050)(ZeroConstructor, Transient, Protected, NativeAccessSpecifierProtected)
	uint8                                         Pad_C8[0x70];                                      // 0x00C8(0x0070)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<class UBFGStreamingLevelHandle*>       M_apPendingRequests;                               // 0x0138(0x0010)(ZeroConstructor, Transient, Protected, NativeAccessSpecifierProtected)
	uint8                                         Pad_148[0x8];                                      // 0x0148(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void OnGameStarted(class UBFGGameInstance* _pGameInstance, class UWorld* _pWorld);
	void OnLatentActionFinished(int32 _iLinkId);
	class UBFGStreamingLevelHandle* RegisterLevel(TSoftObjectPtr<class UWorld> _pLevel);

	void GameSystem_StreamingLevelLog(bool _bAllLevels) const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"BFGStreamingLevelManager">();
	}
	static class UBFGStreamingLevelManager* GetDefaultObj()
	{
		return GetDefaultObjImpl<UBFGStreamingLevelManager>();
	}
};
static_assert(alignof(UBFGStreamingLevelManager) == 0x000008, "Wrong alignment on UBFGStreamingLevelManager");
static_assert(sizeof(UBFGStreamingLevelManager) == 0x000150, "Wrong size on UBFGStreamingLevelManager");
static_assert(offsetof(UBFGStreamingLevelManager, M_onStateChanged) == 0x000038, "Member 'UBFGStreamingLevelManager::M_onStateChanged' has a wrong offset!");
static_assert(offsetof(UBFGStreamingLevelManager, M_pGameState) == 0x000070, "Member 'UBFGStreamingLevelManager::M_pGameState' has a wrong offset!");
static_assert(offsetof(UBFGStreamingLevelManager, M_aLevels) == 0x000078, "Member 'UBFGStreamingLevelManager::M_aLevels' has a wrong offset!");
static_assert(offsetof(UBFGStreamingLevelManager, M_apPendingRequests) == 0x000138, "Member 'UBFGStreamingLevelManager::M_apPendingRequests' has a wrong offset!");

// Class BFGCore.BFGVariableType_RequestPlayback
// 0x0000 (0x0090 - 0x0090)
class UBFGVariableType_RequestPlayback final : public UBFGVariableType
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"BFGVariableType_RequestPlayback">();
	}
	static class UBFGVariableType_RequestPlayback* GetDefaultObj()
	{
		return GetDefaultObjImpl<UBFGVariableType_RequestPlayback>();
	}
};
static_assert(alignof(UBFGVariableType_RequestPlayback) == 0x000008, "Wrong alignment on UBFGVariableType_RequestPlayback");
static_assert(sizeof(UBFGVariableType_RequestPlayback) == 0x000090, "Wrong size on UBFGVariableType_RequestPlayback");

// Class BFGCore.BFGProjectile_IonDetonator
// 0x00B0 (0x0728 - 0x0678)
class ABFGProjectile_IonDetonator : public ABFGProjectile_Object
{
public:
	float                                         M_fSelfExplosionTime;                              // 0x0678(0x0004)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_67C[0xAC];                                     // 0x067C(0x00AC)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"BFGProjectile_IonDetonator">();
	}
	static class ABFGProjectile_IonDetonator* GetDefaultObj()
	{
		return GetDefaultObjImpl<ABFGProjectile_IonDetonator>();
	}
};
static_assert(alignof(ABFGProjectile_IonDetonator) == 0x000008, "Wrong alignment on ABFGProjectile_IonDetonator");
static_assert(sizeof(ABFGProjectile_IonDetonator) == 0x000728, "Wrong size on ABFGProjectile_IonDetonator");
static_assert(offsetof(ABFGProjectile_IonDetonator, M_fSelfExplosionTime) == 0x000678, "Member 'ABFGProjectile_IonDetonator::M_fSelfExplosionTime' has a wrong offset!");

// Class BFGCore.BFGProjectile_MindLinkProtectiveBubble
// 0x0008 (0x06D8 - 0x06D0)
class ABFGProjectile_MindLinkProtectiveBubble final : public ABFGProjectile_PulseField
{
public:
	class AActor*                                 M_pBubbleTarget;                                   // 0x06D0(0x0008)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)

public:
	void HandleOnDestroyed(class AActor* _pDestroyedActor);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"BFGProjectile_MindLinkProtectiveBubble">();
	}
	static class ABFGProjectile_MindLinkProtectiveBubble* GetDefaultObj()
	{
		return GetDefaultObjImpl<ABFGProjectile_MindLinkProtectiveBubble>();
	}
};
static_assert(alignof(ABFGProjectile_MindLinkProtectiveBubble) == 0x000008, "Wrong alignment on ABFGProjectile_MindLinkProtectiveBubble");
static_assert(sizeof(ABFGProjectile_MindLinkProtectiveBubble) == 0x0006D8, "Wrong size on ABFGProjectile_MindLinkProtectiveBubble");
static_assert(offsetof(ABFGProjectile_MindLinkProtectiveBubble, M_pBubbleTarget) == 0x0006D0, "Member 'ABFGProjectile_MindLinkProtectiveBubble::M_pBubbleTarget' has a wrong offset!");

// Class BFGCore.BFGProjectile_MindLinkPulseField
// 0x0000 (0x06D0 - 0x06D0)
class ABFGProjectile_MindLinkPulseField : public ABFGProjectile_PulseField
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"BFGProjectile_MindLinkPulseField">();
	}
	static class ABFGProjectile_MindLinkPulseField* GetDefaultObj()
	{
		return GetDefaultObjImpl<ABFGProjectile_MindLinkPulseField>();
	}
};
static_assert(alignof(ABFGProjectile_MindLinkPulseField) == 0x000008, "Wrong alignment on ABFGProjectile_MindLinkPulseField");
static_assert(sizeof(ABFGProjectile_MindLinkPulseField) == 0x0006D0, "Wrong size on ABFGProjectile_MindLinkPulseField");

// Class BFGCore.BFGSystemUtils
// 0x0000 (0x0028 - 0x0028)
class UBFGSystemUtils final : public UBlueprintFunctionLibrary
{
public:
	static int32 GetGlobalFrameCounter();
	static class FString GetUnlocalizedStringFromText(const class FText& _tText);
	static bool IsDerivedFrom(class UObject* _pObject, class UClass* _pClass);
	static bool IsPlatform_Default30FpsThrottle();
	static bool IsPlatform_ScorpioOrPro();
	static bool IsPlatformAnyConsole();
	static bool IsPlatformPS4();
	static bool IsPlatformPS5();
	static bool IsPlatformWindows();
	static bool IsPlatformXbox();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"BFGSystemUtils">();
	}
	static class UBFGSystemUtils* GetDefaultObj()
	{
		return GetDefaultObjImpl<UBFGSystemUtils>();
	}
};
static_assert(alignof(UBFGSystemUtils) == 0x000008, "Wrong alignment on UBFGSystemUtils");
static_assert(sizeof(UBFGSystemUtils) == 0x000028, "Wrong size on UBFGSystemUtils");

// Class BFGCore.BFGVehicleController
// 0x0000 (0x0600 - 0x0600)
class ABFGVehicleController : public ABFGAIController
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"BFGVehicleController">();
	}
	static class ABFGVehicleController* GetDefaultObj()
	{
		return GetDefaultObjImpl<ABFGVehicleController>();
	}
};
static_assert(alignof(ABFGVehicleController) == 0x000008, "Wrong alignment on ABFGVehicleController");
static_assert(sizeof(ABFGVehicleController) == 0x000600, "Wrong size on ABFGVehicleController");

// Class BFGCore.BFGProjectile_NasalProbe
// 0x0058 (0x06D0 - 0x0678)
class ABFGProjectile_NasalProbe final : public ABFGProjectile_Object
{
public:
	float                                         M_fBounceUpwardVelocity;                           // 0x0678(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         M_fMinimumDodgeRange;                              // 0x067C(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         M_fHomingDisabledDuration;                         // 0x0680(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         M_fProbeTickDamage;                                // 0x0684(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         M_fProbeTickInterval;                              // 0x0688(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         M_fTimeToDieAfterBounce;                           // 0x068C(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          M_bShowDodgeRange;                                 // 0x0690(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_691[0x7];                                      // 0x0691(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	class UParticleSystem*                        M_pNasalProjectileEffect;                          // 0x0698(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_6A0[0x18];                                     // 0x06A0(0x0018)(Fixing Size After Last Property [ Dumper-7 ])
	class ABFGPlayerCharacter*                    M_pAttachedPlayer;                                 // 0x06B8(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_6C0[0x8];                                      // 0x06C0(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	class UParticleSystemComponent*               M_pNasalProbeProjectileComp;                       // 0x06C8(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)

public:
	void AttachToPlayer(const struct FHitResult& _vHitResult);
	void DetachFromPlayer();
	void OnHomingDisabledTimerComplete();
	void OnNasalProbeImpact(const struct FHitResult& _vHitResult);
	void OnPlayerDashed(class UBFGActorComponent_Dash* _pDashComponent);
	void OnProbeTickTimerComplete();
	void OnProjectileDodgedSuccessfully();
	void OnProjectileHomingReenabled();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"BFGProjectile_NasalProbe">();
	}
	static class ABFGProjectile_NasalProbe* GetDefaultObj()
	{
		return GetDefaultObjImpl<ABFGProjectile_NasalProbe>();
	}
};
static_assert(alignof(ABFGProjectile_NasalProbe) == 0x000008, "Wrong alignment on ABFGProjectile_NasalProbe");
static_assert(sizeof(ABFGProjectile_NasalProbe) == 0x0006D0, "Wrong size on ABFGProjectile_NasalProbe");
static_assert(offsetof(ABFGProjectile_NasalProbe, M_fBounceUpwardVelocity) == 0x000678, "Member 'ABFGProjectile_NasalProbe::M_fBounceUpwardVelocity' has a wrong offset!");
static_assert(offsetof(ABFGProjectile_NasalProbe, M_fMinimumDodgeRange) == 0x00067C, "Member 'ABFGProjectile_NasalProbe::M_fMinimumDodgeRange' has a wrong offset!");
static_assert(offsetof(ABFGProjectile_NasalProbe, M_fHomingDisabledDuration) == 0x000680, "Member 'ABFGProjectile_NasalProbe::M_fHomingDisabledDuration' has a wrong offset!");
static_assert(offsetof(ABFGProjectile_NasalProbe, M_fProbeTickDamage) == 0x000684, "Member 'ABFGProjectile_NasalProbe::M_fProbeTickDamage' has a wrong offset!");
static_assert(offsetof(ABFGProjectile_NasalProbe, M_fProbeTickInterval) == 0x000688, "Member 'ABFGProjectile_NasalProbe::M_fProbeTickInterval' has a wrong offset!");
static_assert(offsetof(ABFGProjectile_NasalProbe, M_fTimeToDieAfterBounce) == 0x00068C, "Member 'ABFGProjectile_NasalProbe::M_fTimeToDieAfterBounce' has a wrong offset!");
static_assert(offsetof(ABFGProjectile_NasalProbe, M_bShowDodgeRange) == 0x000690, "Member 'ABFGProjectile_NasalProbe::M_bShowDodgeRange' has a wrong offset!");
static_assert(offsetof(ABFGProjectile_NasalProbe, M_pNasalProjectileEffect) == 0x000698, "Member 'ABFGProjectile_NasalProbe::M_pNasalProjectileEffect' has a wrong offset!");
static_assert(offsetof(ABFGProjectile_NasalProbe, M_pAttachedPlayer) == 0x0006B8, "Member 'ABFGProjectile_NasalProbe::M_pAttachedPlayer' has a wrong offset!");
static_assert(offsetof(ABFGProjectile_NasalProbe, M_pNasalProbeProjectileComp) == 0x0006C8, "Member 'ABFGProjectile_NasalProbe::M_pNasalProbeProjectileComp' has a wrong offset!");

// Class BFGCore.BFGProjectile_QuantumDeconstructor
// 0x0030 (0x06A8 - 0x0678)
class ABFGProjectile_QuantumDeconstructor : public ABFGProjectile_Object
{
public:
	TSubclassOf<class UDamageType>                M_pDamageType_DirectHit;                           // 0x0678(0x0008)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         M_fExplosionRadius;                                // 0x0680(0x0004)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         M_fExplosionTimeFrame;                             // 0x0684(0x0004)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         M_iExplosionWaveCount;                             // 0x0688(0x0004)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         M_fExplosionMinimumScale;                          // 0x068C(0x0004)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         M_fExplosionMaximumScale;                          // 0x0690(0x0004)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         M_fBuildingDamageOverride;                         // 0x0694(0x0004)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_698[0x10];                                     // 0x0698(0x0010)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	int32 GetCurrentWaveCounter() const;
	float GetScaledMaximumExplosionRadius() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"BFGProjectile_QuantumDeconstructor">();
	}
	static class ABFGProjectile_QuantumDeconstructor* GetDefaultObj()
	{
		return GetDefaultObjImpl<ABFGProjectile_QuantumDeconstructor>();
	}
};
static_assert(alignof(ABFGProjectile_QuantumDeconstructor) == 0x000008, "Wrong alignment on ABFGProjectile_QuantumDeconstructor");
static_assert(sizeof(ABFGProjectile_QuantumDeconstructor) == 0x0006A8, "Wrong size on ABFGProjectile_QuantumDeconstructor");
static_assert(offsetof(ABFGProjectile_QuantumDeconstructor, M_pDamageType_DirectHit) == 0x000678, "Member 'ABFGProjectile_QuantumDeconstructor::M_pDamageType_DirectHit' has a wrong offset!");
static_assert(offsetof(ABFGProjectile_QuantumDeconstructor, M_fExplosionRadius) == 0x000680, "Member 'ABFGProjectile_QuantumDeconstructor::M_fExplosionRadius' has a wrong offset!");
static_assert(offsetof(ABFGProjectile_QuantumDeconstructor, M_fExplosionTimeFrame) == 0x000684, "Member 'ABFGProjectile_QuantumDeconstructor::M_fExplosionTimeFrame' has a wrong offset!");
static_assert(offsetof(ABFGProjectile_QuantumDeconstructor, M_iExplosionWaveCount) == 0x000688, "Member 'ABFGProjectile_QuantumDeconstructor::M_iExplosionWaveCount' has a wrong offset!");
static_assert(offsetof(ABFGProjectile_QuantumDeconstructor, M_fExplosionMinimumScale) == 0x00068C, "Member 'ABFGProjectile_QuantumDeconstructor::M_fExplosionMinimumScale' has a wrong offset!");
static_assert(offsetof(ABFGProjectile_QuantumDeconstructor, M_fExplosionMaximumScale) == 0x000690, "Member 'ABFGProjectile_QuantumDeconstructor::M_fExplosionMaximumScale' has a wrong offset!");
static_assert(offsetof(ABFGProjectile_QuantumDeconstructor, M_fBuildingDamageOverride) == 0x000694, "Member 'ABFGProjectile_QuantumDeconstructor::M_fBuildingDamageOverride' has a wrong offset!");

// Class BFGCore.BFGVehicleSettings
// 0x0030 (0x0068 - 0x0038)
class UBFGVehicleSettings final : public UDeveloperSettings
{
public:
	TArray<class FString>                         LicensePlateTopTextCollection;                     // 0x0038(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Config, NativeAccessSpecifierPublic)
	TArray<class FString>                         LicensePlateBottomTextCollection;                  // 0x0048(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Config, NativeAccessSpecifierPublic)
	TArray<struct FColor>                         LicensePlateColorCollection;                       // 0x0058(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Config, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"BFGVehicleSettings">();
	}
	static class UBFGVehicleSettings* GetDefaultObj()
	{
		return GetDefaultObjImpl<UBFGVehicleSettings>();
	}
};
static_assert(alignof(UBFGVehicleSettings) == 0x000008, "Wrong alignment on UBFGVehicleSettings");
static_assert(sizeof(UBFGVehicleSettings) == 0x000068, "Wrong size on UBFGVehicleSettings");
static_assert(offsetof(UBFGVehicleSettings, LicensePlateTopTextCollection) == 0x000038, "Member 'UBFGVehicleSettings::LicensePlateTopTextCollection' has a wrong offset!");
static_assert(offsetof(UBFGVehicleSettings, LicensePlateBottomTextCollection) == 0x000048, "Member 'UBFGVehicleSettings::LicensePlateBottomTextCollection' has a wrong offset!");
static_assert(offsetof(UBFGVehicleSettings, LicensePlateColorCollection) == 0x000058, "Member 'UBFGVehicleSettings::LicensePlateColorCollection' has a wrong offset!");

// Class BFGCore.BFGProjectile_SonicBoom
// 0x0028 (0x06A0 - 0x0678)
class ABFGProjectile_SonicBoom : public ABFGProjectile_Object
{
public:
	float                                         M_fAoeRadiusInner;                                 // 0x0678(0x0004)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         M_fDamageInner;                                    // 0x067C(0x0004)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         M_fDamageOuter;                                    // 0x0680(0x0004)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         M_fImpulseInner;                                   // 0x0684(0x0004)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         M_fDeathTime;                                      // 0x0688(0x0004)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         M_iEffectSlotID;                                   // 0x068C(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_690[0x10];                                     // 0x0690(0x0010)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void OnInnerExplosion(const struct FVector& _vLocation, float _fRadius);
	void OnVolumeControl11Explosion(const struct FVector& _vLocation, float _fRadius);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"BFGProjectile_SonicBoom">();
	}
	static class ABFGProjectile_SonicBoom* GetDefaultObj()
	{
		return GetDefaultObjImpl<ABFGProjectile_SonicBoom>();
	}
};
static_assert(alignof(ABFGProjectile_SonicBoom) == 0x000008, "Wrong alignment on ABFGProjectile_SonicBoom");
static_assert(sizeof(ABFGProjectile_SonicBoom) == 0x0006A0, "Wrong size on ABFGProjectile_SonicBoom");
static_assert(offsetof(ABFGProjectile_SonicBoom, M_fAoeRadiusInner) == 0x000678, "Member 'ABFGProjectile_SonicBoom::M_fAoeRadiusInner' has a wrong offset!");
static_assert(offsetof(ABFGProjectile_SonicBoom, M_fDamageInner) == 0x00067C, "Member 'ABFGProjectile_SonicBoom::M_fDamageInner' has a wrong offset!");
static_assert(offsetof(ABFGProjectile_SonicBoom, M_fDamageOuter) == 0x000680, "Member 'ABFGProjectile_SonicBoom::M_fDamageOuter' has a wrong offset!");
static_assert(offsetof(ABFGProjectile_SonicBoom, M_fImpulseInner) == 0x000684, "Member 'ABFGProjectile_SonicBoom::M_fImpulseInner' has a wrong offset!");
static_assert(offsetof(ABFGProjectile_SonicBoom, M_fDeathTime) == 0x000688, "Member 'ABFGProjectile_SonicBoom::M_fDeathTime' has a wrong offset!");
static_assert(offsetof(ABFGProjectile_SonicBoom, M_iEffectSlotID) == 0x00068C, "Member 'ABFGProjectile_SonicBoom::M_iEffectSlotID' has a wrong offset!");

// Class BFGCore.BFGProjectile_Transmogrifier
// 0x0048 (0x06C0 - 0x0678)
class ABFGProjectile_Transmogrifier : public ABFGProjectile_Object
{
public:
	TSubclassOf<class UDamageType>                M_pFatalDamageType;                                // 0x0678(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                M_vSingularityOffset;                              // 0x0680(0x000C)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         M_fTransmogrifyDuration;                           // 0x068C(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	struct FVector                                M_vSingularityLocation;                            // 0x0690(0x000C)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_69C[0xC];                                      // 0x069C(0x000C)(Fixing Size After Last Property [ Dumper-7 ])
	class AActor*                                 M_pTransmogrifyTarget;                             // 0x06A8(0x0008)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_6B0[0x8];                                      // 0x06B0(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         M_fLootDelayIncrement;                             // 0x06B8(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_6BC[0x4];                                      // 0x06BC(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"BFGProjectile_Transmogrifier">();
	}
	static class ABFGProjectile_Transmogrifier* GetDefaultObj()
	{
		return GetDefaultObjImpl<ABFGProjectile_Transmogrifier>();
	}
};
static_assert(alignof(ABFGProjectile_Transmogrifier) == 0x000008, "Wrong alignment on ABFGProjectile_Transmogrifier");
static_assert(sizeof(ABFGProjectile_Transmogrifier) == 0x0006C0, "Wrong size on ABFGProjectile_Transmogrifier");
static_assert(offsetof(ABFGProjectile_Transmogrifier, M_pFatalDamageType) == 0x000678, "Member 'ABFGProjectile_Transmogrifier::M_pFatalDamageType' has a wrong offset!");
static_assert(offsetof(ABFGProjectile_Transmogrifier, M_vSingularityOffset) == 0x000680, "Member 'ABFGProjectile_Transmogrifier::M_vSingularityOffset' has a wrong offset!");
static_assert(offsetof(ABFGProjectile_Transmogrifier, M_fTransmogrifyDuration) == 0x00068C, "Member 'ABFGProjectile_Transmogrifier::M_fTransmogrifyDuration' has a wrong offset!");
static_assert(offsetof(ABFGProjectile_Transmogrifier, M_vSingularityLocation) == 0x000690, "Member 'ABFGProjectile_Transmogrifier::M_vSingularityLocation' has a wrong offset!");
static_assert(offsetof(ABFGProjectile_Transmogrifier, M_pTransmogrifyTarget) == 0x0006A8, "Member 'ABFGProjectile_Transmogrifier::M_pTransmogrifyTarget' has a wrong offset!");
static_assert(offsetof(ABFGProjectile_Transmogrifier, M_fLootDelayIncrement) == 0x0006B8, "Member 'ABFGProjectile_Transmogrifier::M_fLootDelayIncrement' has a wrong offset!");

// Class BFGCore.BFGProjectileTargetInterface
// 0x0000 (0x0028 - 0x0028)
class IBFGProjectileTargetInterface final : public IInterface
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"BFGProjectileTargetInterface">();
	}
	static class IBFGProjectileTargetInterface* GetDefaultObj()
	{
		return GetDefaultObjImpl<IBFGProjectileTargetInterface>();
	}
};
static_assert(alignof(IBFGProjectileTargetInterface) == 0x000008, "Wrong alignment on IBFGProjectileTargetInterface");
static_assert(sizeof(IBFGProjectileTargetInterface) == 0x000028, "Wrong size on IBFGProjectileTargetInterface");

// Class BFGCore.BFGPropActor
// 0x00D8 (0x04B0 - 0x03D8)
class ABFGPropActor : public AActor
{
public:
	bool                                          M_bIsPhysicsEnabled;                               // 0x03D8(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          M_bVisibilityEnabled;                              // 0x03D9(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          M_bIsAttached;                                     // 0x03DA(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_3DB[0x1];                                      // 0x03DB(0x0001)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         M_fOnDroppedLifetime;                              // 0x03DC(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          M_bSkeletalMeshComponentPhysicsSupported;          // 0x03E0(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          M_bStaticMeshBlendSupported;                       // 0x03E1(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          M_bDetachedfromParent;                             // 0x03E2(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_3E3[0x5];                                      // 0x03E3(0x0005)(Fixing Size After Last Property [ Dumper-7 ])
	TScriptInterface<class IBFGInteractAnimationPlayerInterface> M_interactAnimationPlayer;                         // 0x03E8(0x0010)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, UObjectWrapper, NativeAccessSpecifierProtected)
	TSoftClassPtr<class UClass>                   M_aInteractAnimationPlayerType;                    // 0x03F8(0x0028)(Edit, BlueprintVisible, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TSoftClassPtr<class UClass>                   M_pInteractAnimationPlayerTypeStaticMesh;          // 0x0420(0x0028)(Edit, BlueprintVisible, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class AActor*                                 M_pRelatedActor;                                   // 0x0448(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UMeshComponent*                         M_pMeshComponent;                                  // 0x0450(0x0008)(ExportObject, ZeroConstructor, Transient, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class AActor*                                 M_pStaticPhysicsActor;                             // 0x0458(0x0008)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          M_bStaticWithPhysicsActive;                        // 0x0460(0x0001)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_461[0x3];                                      // 0x0461(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	struct FVector                                M_vInitialUseLocation;                             // 0x0464(0x000C)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class ABFGPropActor*                          M_pPreviousInstance;                               // 0x0470(0x0008)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_478[0x8];                                      // 0x0478(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	struct FTransform                             M_vSavedSkeletalMeshComponentTransform;            // 0x0480(0x0030)(Transient, IsPlainOldData, NoDestructor, Protected, NativeAccessSpecifierProtected)

public:
	void ActivateAttachedToActor(class AActor* _pAttachTo, const class FName _boneName);
	void ActivatePhysics();
	void ActivateVisibility();
	void DeactivateAttachedToActor();
	void DeactivatePhysics();
	void DeactivateVisibility();
	void OnInteractAnimationChanged(const struct FBFGInteractAnimationData& _newData, const struct FBFGInteractAnimationData& _oldData);
	void OnInteractAnimationChangedCallback(TScriptInterface<class IBFGInteractAnimationPlayerInterface> _pInteractAnimationPlayer, const struct FBFGInteractAnimationData& _newData, const struct FBFGInteractAnimationData& _oldData);
	void OnSwappedToDroppedObject(class ABFGObject_StaticWithPhysics* _pPhysicsObject);
	void OnSwitchedToHighRes(const struct FBFGInteractAnimationData& _animationData);
	void OnSwitchedToLowRes();

	TScriptInterface<class IBFGInteractAnimationPlayerInterface> GetInteractAnimationPlayer() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"BFGPropActor">();
	}
	static class ABFGPropActor* GetDefaultObj()
	{
		return GetDefaultObjImpl<ABFGPropActor>();
	}
};
static_assert(alignof(ABFGPropActor) == 0x000010, "Wrong alignment on ABFGPropActor");
static_assert(sizeof(ABFGPropActor) == 0x0004B0, "Wrong size on ABFGPropActor");
static_assert(offsetof(ABFGPropActor, M_bIsPhysicsEnabled) == 0x0003D8, "Member 'ABFGPropActor::M_bIsPhysicsEnabled' has a wrong offset!");
static_assert(offsetof(ABFGPropActor, M_bVisibilityEnabled) == 0x0003D9, "Member 'ABFGPropActor::M_bVisibilityEnabled' has a wrong offset!");
static_assert(offsetof(ABFGPropActor, M_bIsAttached) == 0x0003DA, "Member 'ABFGPropActor::M_bIsAttached' has a wrong offset!");
static_assert(offsetof(ABFGPropActor, M_fOnDroppedLifetime) == 0x0003DC, "Member 'ABFGPropActor::M_fOnDroppedLifetime' has a wrong offset!");
static_assert(offsetof(ABFGPropActor, M_bSkeletalMeshComponentPhysicsSupported) == 0x0003E0, "Member 'ABFGPropActor::M_bSkeletalMeshComponentPhysicsSupported' has a wrong offset!");
static_assert(offsetof(ABFGPropActor, M_bStaticMeshBlendSupported) == 0x0003E1, "Member 'ABFGPropActor::M_bStaticMeshBlendSupported' has a wrong offset!");
static_assert(offsetof(ABFGPropActor, M_bDetachedfromParent) == 0x0003E2, "Member 'ABFGPropActor::M_bDetachedfromParent' has a wrong offset!");
static_assert(offsetof(ABFGPropActor, M_interactAnimationPlayer) == 0x0003E8, "Member 'ABFGPropActor::M_interactAnimationPlayer' has a wrong offset!");
static_assert(offsetof(ABFGPropActor, M_aInteractAnimationPlayerType) == 0x0003F8, "Member 'ABFGPropActor::M_aInteractAnimationPlayerType' has a wrong offset!");
static_assert(offsetof(ABFGPropActor, M_pInteractAnimationPlayerTypeStaticMesh) == 0x000420, "Member 'ABFGPropActor::M_pInteractAnimationPlayerTypeStaticMesh' has a wrong offset!");
static_assert(offsetof(ABFGPropActor, M_pRelatedActor) == 0x000448, "Member 'ABFGPropActor::M_pRelatedActor' has a wrong offset!");
static_assert(offsetof(ABFGPropActor, M_pMeshComponent) == 0x000450, "Member 'ABFGPropActor::M_pMeshComponent' has a wrong offset!");
static_assert(offsetof(ABFGPropActor, M_pStaticPhysicsActor) == 0x000458, "Member 'ABFGPropActor::M_pStaticPhysicsActor' has a wrong offset!");
static_assert(offsetof(ABFGPropActor, M_bStaticWithPhysicsActive) == 0x000460, "Member 'ABFGPropActor::M_bStaticWithPhysicsActive' has a wrong offset!");
static_assert(offsetof(ABFGPropActor, M_vInitialUseLocation) == 0x000464, "Member 'ABFGPropActor::M_vInitialUseLocation' has a wrong offset!");
static_assert(offsetof(ABFGPropActor, M_pPreviousInstance) == 0x000470, "Member 'ABFGPropActor::M_pPreviousInstance' has a wrong offset!");
static_assert(offsetof(ABFGPropActor, M_vSavedSkeletalMeshComponentTransform) == 0x000480, "Member 'ABFGPropActor::M_vSavedSkeletalMeshComponentTransform' has a wrong offset!");

// Class BFGCore.BFGScriptedSequence_Persistent
// 0x0020 (0x00F8 - 0x00D8)
class UBFGScriptedSequence_Persistent final : public UBFGScriptedSequence
{
public:
	uint8                                         Pad_D8[0x8];                                       // 0x00D8(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	class UBFGVariable*                           M_pRequestVariable;                                // 0x00E0(0x0008)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UBFGVariable*                           M_pStateVariable;                                  // 0x00E8(0x0008)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UBFGVariable*                           M_pTaskNumberVariable;                             // 0x00F0(0x0008)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)

public:
	void OnVariableChanged(class UBFGVariableMirror* _pVarMirror, const class UBFGVariable* _pVariable, int32 _oldValue, int32 _newValue);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"BFGScriptedSequence_Persistent">();
	}
	static class UBFGScriptedSequence_Persistent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UBFGScriptedSequence_Persistent>();
	}
};
static_assert(alignof(UBFGScriptedSequence_Persistent) == 0x000008, "Wrong alignment on UBFGScriptedSequence_Persistent");
static_assert(sizeof(UBFGScriptedSequence_Persistent) == 0x0000F8, "Wrong size on UBFGScriptedSequence_Persistent");
static_assert(offsetof(UBFGScriptedSequence_Persistent, M_pRequestVariable) == 0x0000E0, "Member 'UBFGScriptedSequence_Persistent::M_pRequestVariable' has a wrong offset!");
static_assert(offsetof(UBFGScriptedSequence_Persistent, M_pStateVariable) == 0x0000E8, "Member 'UBFGScriptedSequence_Persistent::M_pStateVariable' has a wrong offset!");
static_assert(offsetof(UBFGScriptedSequence_Persistent, M_pTaskNumberVariable) == 0x0000F0, "Member 'UBFGScriptedSequence_Persistent::M_pTaskNumberVariable' has a wrong offset!");

// Class BFGCore.BFGPsychokinesisTargetInterface
// 0x0000 (0x0028 - 0x0028)
class IBFGPsychokinesisTargetInterface final : public IInterface
{
public:
	bool IsValidTarget();
	void PKAttachTo(class UPhysicsHandleComponent* _pComponent);
	void PKDetached(bool _bForceStopped);
	float PKGetDistanceToHolder();
	struct FVector PKGetSpringArmOffset();
	void PKSetCollisionsEnabled(bool _bEnabled);
	bool PKThrowOverride(class UBFGMentalAbility_Psychokinesis* _pAbility, const struct FVector& _rDirection, float _fCurrentThrowCharge, float _fMaxThrowCharge);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"BFGPsychokinesisTargetInterface">();
	}
	static class IBFGPsychokinesisTargetInterface* GetDefaultObj()
	{
		return GetDefaultObjImpl<IBFGPsychokinesisTargetInterface>();
	}
};
static_assert(alignof(IBFGPsychokinesisTargetInterface) == 0x000008, "Wrong alignment on IBFGPsychokinesisTargetInterface");
static_assert(sizeof(IBFGPsychokinesisTargetInterface) == 0x000028, "Wrong size on IBFGPsychokinesisTargetInterface");

// Class BFGCore.BFGQuest_Challenge
// 0x0030 (0x0058 - 0x0028)
class UBFGQuest_Challenge final : public UObject
{
public:
	uint8                                         Pad_28[0x10];                                      // 0x0028(0x0010)(Fixing Size After Last Property [ Dumper-7 ])
	class UBFGQuest_Manager*                      M_pManager;                                        // 0x0038(0x0008)(ExportObject, ZeroConstructor, Transient, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UBFGDataAsset_ChallengeInfo*            M_pChallengeInfo;                                  // 0x0040(0x0008)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_48[0x10];                                      // 0x0048(0x0010)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	class UBFGDataAsset_ChallengeInfo* GetChallengeAsset() const;
	float GetCurrentScore() const;
	float GetHighScore() const;
	float GetHighScoreOld() const;
	float GetReward() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"BFGQuest_Challenge">();
	}
	static class UBFGQuest_Challenge* GetDefaultObj()
	{
		return GetDefaultObjImpl<UBFGQuest_Challenge>();
	}
};
static_assert(alignof(UBFGQuest_Challenge) == 0x000008, "Wrong alignment on UBFGQuest_Challenge");
static_assert(sizeof(UBFGQuest_Challenge) == 0x000058, "Wrong size on UBFGQuest_Challenge");
static_assert(offsetof(UBFGQuest_Challenge, M_pManager) == 0x000038, "Member 'UBFGQuest_Challenge::M_pManager' has a wrong offset!");
static_assert(offsetof(UBFGQuest_Challenge, M_pChallengeInfo) == 0x000040, "Member 'UBFGQuest_Challenge::M_pChallengeInfo' has a wrong offset!");

// Class BFGCore.BFGQuest_CortexScanObjectiveTracker
// 0x0028 (0x0050 - 0x0028)
class UBFGQuest_CortexScanObjectiveTracker final : public UObject
{
public:
	class FName                                   M_strIdentifier;                                   // 0x0028(0x0008)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TArray<struct FBFGCortexScanObjectiveTracker_Data> M_aData;                                           // 0x0030(0x0010)(ZeroConstructor, Transient, Protected, NativeAccessSpecifierProtected)
	uint8                                         Pad_40[0x10];                                      // 0x0040(0x0010)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"BFGQuest_CortexScanObjectiveTracker">();
	}
	static class UBFGQuest_CortexScanObjectiveTracker* GetDefaultObj()
	{
		return GetDefaultObjImpl<UBFGQuest_CortexScanObjectiveTracker>();
	}
};
static_assert(alignof(UBFGQuest_CortexScanObjectiveTracker) == 0x000008, "Wrong alignment on UBFGQuest_CortexScanObjectiveTracker");
static_assert(sizeof(UBFGQuest_CortexScanObjectiveTracker) == 0x000050, "Wrong size on UBFGQuest_CortexScanObjectiveTracker");
static_assert(offsetof(UBFGQuest_CortexScanObjectiveTracker, M_strIdentifier) == 0x000028, "Member 'UBFGQuest_CortexScanObjectiveTracker::M_strIdentifier' has a wrong offset!");
static_assert(offsetof(UBFGQuest_CortexScanObjectiveTracker, M_aData) == 0x000030, "Member 'UBFGQuest_CortexScanObjectiveTracker::M_aData' has a wrong offset!");

// Class BFGCore.BFGScriptedSequence_TaskGotoStandby
// 0x0010 (0x0060 - 0x0050)
class UBFGScriptedSequence_TaskGotoStandby final : public UBFGScriptedSequence_Task
{
public:
	uint8                                         Pad_50[0x8];                                       // 0x0050(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	class UBFGNetworkPathAgent_AIStateBase*       M_pStateInAI;                                      // 0x0058(0x0008)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)

public:
	static bool CreateAndAddScriptedSequence_TaskGotoStandby(class UBFGScriptedSequence* _pScriptedSequence, bool _bShouldNotFinishSequenceTaskAutomatically);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"BFGScriptedSequence_TaskGotoStandby">();
	}
	static class UBFGScriptedSequence_TaskGotoStandby* GetDefaultObj()
	{
		return GetDefaultObjImpl<UBFGScriptedSequence_TaskGotoStandby>();
	}
};
static_assert(alignof(UBFGScriptedSequence_TaskGotoStandby) == 0x000008, "Wrong alignment on UBFGScriptedSequence_TaskGotoStandby");
static_assert(sizeof(UBFGScriptedSequence_TaskGotoStandby) == 0x000060, "Wrong size on UBFGScriptedSequence_TaskGotoStandby");
static_assert(offsetof(UBFGScriptedSequence_TaskGotoStandby, M_pStateInAI) == 0x000058, "Member 'UBFGScriptedSequence_TaskGotoStandby::M_pStateInAI' has a wrong offset!");

// Class BFGCore.BFGQuest_DelegateBinding
// 0x0010 (0x0038 - 0x0028)
class UBFGQuest_DelegateBinding final : public UDynamicBlueprintBinding
{
public:
	TArray<struct FBlueprintComponentDelegateBinding> M_aDelegateBindings;                               // 0x0028(0x0010)(ZeroConstructor, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"BFGQuest_DelegateBinding">();
	}
	static class UBFGQuest_DelegateBinding* GetDefaultObj()
	{
		return GetDefaultObjImpl<UBFGQuest_DelegateBinding>();
	}
};
static_assert(alignof(UBFGQuest_DelegateBinding) == 0x000008, "Wrong alignment on UBFGQuest_DelegateBinding");
static_assert(sizeof(UBFGQuest_DelegateBinding) == 0x000038, "Wrong size on UBFGQuest_DelegateBinding");
static_assert(offsetof(UBFGQuest_DelegateBinding, M_aDelegateBindings) == 0x000028, "Member 'UBFGQuest_DelegateBinding::M_aDelegateBindings' has a wrong offset!");

// Class BFGCore.BFGQuest_Edge
// 0x0008 (0x0048 - 0x0040)
class UBFGQuest_Edge final : public UGenericGraphEdge
{
public:
	EBFGQuest_EdgeType                            M_edgeType;                                        // 0x0040(0x0001)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_41[0x7];                                       // 0x0041(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"BFGQuest_Edge">();
	}
	static class UBFGQuest_Edge* GetDefaultObj()
	{
		return GetDefaultObjImpl<UBFGQuest_Edge>();
	}
};
static_assert(alignof(UBFGQuest_Edge) == 0x000008, "Wrong alignment on UBFGQuest_Edge");
static_assert(sizeof(UBFGQuest_Edge) == 0x000048, "Wrong size on UBFGQuest_Edge");
static_assert(offsetof(UBFGQuest_Edge, M_edgeType) == 0x000040, "Member 'UBFGQuest_Edge::M_edgeType' has a wrong offset!");

// Class BFGCore.BFGScriptedSequence_TaskVehicleStop
// 0x0010 (0x0060 - 0x0050)
class UBFGScriptedSequence_TaskVehicleStop final : public UBFGScriptedSequence_Task
{
public:
	struct FBFGVehicleStop_Param                  M_stopParamInfo;                                   // 0x0050(0x000C)(Transient, NoDestructor, Protected, NativeAccessSpecifierProtected)
	bool                                          M_doWaitInStandby;                                 // 0x005C(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_5D[0x3];                                       // 0x005D(0x0003)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static bool CreateAndAddScriptedSequence_TaskVehicleStop(class UBFGScriptedSequence* _pScriptedSequence, const struct FBFGScriptedSequence_TaskVehicleStop_Param& _param);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"BFGScriptedSequence_TaskVehicleStop">();
	}
	static class UBFGScriptedSequence_TaskVehicleStop* GetDefaultObj()
	{
		return GetDefaultObjImpl<UBFGScriptedSequence_TaskVehicleStop>();
	}
};
static_assert(alignof(UBFGScriptedSequence_TaskVehicleStop) == 0x000008, "Wrong alignment on UBFGScriptedSequence_TaskVehicleStop");
static_assert(sizeof(UBFGScriptedSequence_TaskVehicleStop) == 0x000060, "Wrong size on UBFGScriptedSequence_TaskVehicleStop");
static_assert(offsetof(UBFGScriptedSequence_TaskVehicleStop, M_stopParamInfo) == 0x000050, "Member 'UBFGScriptedSequence_TaskVehicleStop::M_stopParamInfo' has a wrong offset!");
static_assert(offsetof(UBFGScriptedSequence_TaskVehicleStop, M_doWaitInStandby) == 0x00005C, "Member 'UBFGScriptedSequence_TaskVehicleStop::M_doWaitInStandby' has a wrong offset!");

// Class BFGCore.BFGQuest_ElementBossObjective
// 0x0108 (0x0448 - 0x0340)
class UBFGQuest_ElementBossObjective final : public UBFGQuest_ElementObjectiveBase
{
public:
	EFBFGQuest_Element_ExecutionTime              M_executionTime;                                   // 0x0340(0x0001)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	EBFGQuest_BossObjective                       M_bossObjective;                                   // 0x0341(0x0001)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_342[0x6];                                      // 0x0342(0x0006)(Fixing Size After Last Property [ Dumper-7 ])
	struct FBFGQuest_UIProvider                   M_objectiveUIProvider;                             // 0x0348(0x0050)(Edit, BlueprintVisible, BlueprintReadOnly, DisableEditOnInstance, Protected, NativeAccessSpecifierProtected)
	struct FBFGActorBinding                       M_targetBinding;                                   // 0x0398(0x0090)(Edit, BlueprintVisible, BlueprintReadOnly, DisableEditOnInstance, Protected, NativeAccessSpecifierProtected)
	UMulticastDelegateProperty_                   M_onBossObjectiveReached;                          // 0x0428(0x0018)(ZeroConstructor, InstancedReference, BlueprintAssignable, Protected, NativeAccessSpecifierProtected)
	uint8                                         Pad_440[0x8];                                      // 0x0440(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"BFGQuest_ElementBossObjective">();
	}
	static class UBFGQuest_ElementBossObjective* GetDefaultObj()
	{
		return GetDefaultObjImpl<UBFGQuest_ElementBossObjective>();
	}
};
static_assert(alignof(UBFGQuest_ElementBossObjective) == 0x000008, "Wrong alignment on UBFGQuest_ElementBossObjective");
static_assert(sizeof(UBFGQuest_ElementBossObjective) == 0x000448, "Wrong size on UBFGQuest_ElementBossObjective");
static_assert(offsetof(UBFGQuest_ElementBossObjective, M_executionTime) == 0x000340, "Member 'UBFGQuest_ElementBossObjective::M_executionTime' has a wrong offset!");
static_assert(offsetof(UBFGQuest_ElementBossObjective, M_bossObjective) == 0x000341, "Member 'UBFGQuest_ElementBossObjective::M_bossObjective' has a wrong offset!");
static_assert(offsetof(UBFGQuest_ElementBossObjective, M_objectiveUIProvider) == 0x000348, "Member 'UBFGQuest_ElementBossObjective::M_objectiveUIProvider' has a wrong offset!");
static_assert(offsetof(UBFGQuest_ElementBossObjective, M_targetBinding) == 0x000398, "Member 'UBFGQuest_ElementBossObjective::M_targetBinding' has a wrong offset!");
static_assert(offsetof(UBFGQuest_ElementBossObjective, M_onBossObjectiveReached) == 0x000428, "Member 'UBFGQuest_ElementBossObjective::M_onBossObjectiveReached' has a wrong offset!");

// Class BFGCore.BFGQuest_ElementEscort
// 0x00B0 (0x03F0 - 0x0340)
class UBFGQuest_ElementEscort : public UBFGQuest_ElementObjectiveBase
{
public:
	UMulticastDelegateProperty_                   M_OnEscortStarted;                                 // 0x0340(0x0018)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	UMulticastDelegateProperty_                   M_OnEscortCompleted;                               // 0x0358(0x0018)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	TArray<struct FBFGQuest_ElementEscort_Objective> M_aObjectives;                                     // 0x0370(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, ContainsInstancedReference, NativeAccessSpecifierPublic)
	EFBFGQuest_Element_ExecutionTime              M_executionTime;                                   // 0x0380(0x0001)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	EFBFGQuest_Element_ProcessingMode             M_processingMode;                                  // 0x0381(0x0001)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_382[0x6];                                      // 0x0382(0x0006)(Fixing Size After Last Property [ Dumper-7 ])
	struct FBFGQuest_UIProvider                   M_descriptionProvider;                             // 0x0388(0x0050)(Edit, DisableEditOnInstance, Protected, NativeAccessSpecifierProtected)
	uint8                                         Pad_3D8[0x8];                                      // 0x03D8(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<struct FBFGQuest_ElementEscort_RuntimeObjective> M_aRuntimeData;                                    // 0x03E0(0x0010)(ZeroConstructor, Transient, Protected, NativeAccessSpecifierProtected)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"BFGQuest_ElementEscort">();
	}
	static class UBFGQuest_ElementEscort* GetDefaultObj()
	{
		return GetDefaultObjImpl<UBFGQuest_ElementEscort>();
	}
};
static_assert(alignof(UBFGQuest_ElementEscort) == 0x000008, "Wrong alignment on UBFGQuest_ElementEscort");
static_assert(sizeof(UBFGQuest_ElementEscort) == 0x0003F0, "Wrong size on UBFGQuest_ElementEscort");
static_assert(offsetof(UBFGQuest_ElementEscort, M_OnEscortStarted) == 0x000340, "Member 'UBFGQuest_ElementEscort::M_OnEscortStarted' has a wrong offset!");
static_assert(offsetof(UBFGQuest_ElementEscort, M_OnEscortCompleted) == 0x000358, "Member 'UBFGQuest_ElementEscort::M_OnEscortCompleted' has a wrong offset!");
static_assert(offsetof(UBFGQuest_ElementEscort, M_aObjectives) == 0x000370, "Member 'UBFGQuest_ElementEscort::M_aObjectives' has a wrong offset!");
static_assert(offsetof(UBFGQuest_ElementEscort, M_executionTime) == 0x000380, "Member 'UBFGQuest_ElementEscort::M_executionTime' has a wrong offset!");
static_assert(offsetof(UBFGQuest_ElementEscort, M_processingMode) == 0x000381, "Member 'UBFGQuest_ElementEscort::M_processingMode' has a wrong offset!");
static_assert(offsetof(UBFGQuest_ElementEscort, M_descriptionProvider) == 0x000388, "Member 'UBFGQuest_ElementEscort::M_descriptionProvider' has a wrong offset!");
static_assert(offsetof(UBFGQuest_ElementEscort, M_aRuntimeData) == 0x0003E0, "Member 'UBFGQuest_ElementEscort::M_aRuntimeData' has a wrong offset!");

// Class BFGCore.BFGSensor_Alerted_AlertTimeoutForAnimals
// 0x0010 (0x0050 - 0x0040)
class UBFGSensor_Alerted_AlertTimeoutForAnimals final : public UBFGSensor
{
public:
	float                                         M_fForgetDistance;                                 // 0x0040(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         M_fSafeDistance;                                   // 0x0044(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         M_fDurationForTimeout;                             // 0x0048(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_4C[0x4];                                       // 0x004C(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"BFGSensor_Alerted_AlertTimeoutForAnimals">();
	}
	static class UBFGSensor_Alerted_AlertTimeoutForAnimals* GetDefaultObj()
	{
		return GetDefaultObjImpl<UBFGSensor_Alerted_AlertTimeoutForAnimals>();
	}
};
static_assert(alignof(UBFGSensor_Alerted_AlertTimeoutForAnimals) == 0x000008, "Wrong alignment on UBFGSensor_Alerted_AlertTimeoutForAnimals");
static_assert(sizeof(UBFGSensor_Alerted_AlertTimeoutForAnimals) == 0x000050, "Wrong size on UBFGSensor_Alerted_AlertTimeoutForAnimals");
static_assert(offsetof(UBFGSensor_Alerted_AlertTimeoutForAnimals, M_fForgetDistance) == 0x000040, "Member 'UBFGSensor_Alerted_AlertTimeoutForAnimals::M_fForgetDistance' has a wrong offset!");
static_assert(offsetof(UBFGSensor_Alerted_AlertTimeoutForAnimals, M_fSafeDistance) == 0x000044, "Member 'UBFGSensor_Alerted_AlertTimeoutForAnimals::M_fSafeDistance' has a wrong offset!");
static_assert(offsetof(UBFGSensor_Alerted_AlertTimeoutForAnimals, M_fDurationForTimeout) == 0x000048, "Member 'UBFGSensor_Alerted_AlertTimeoutForAnimals::M_fDurationForTimeout' has a wrong offset!");

// Class BFGCore.BFGQuest_ElementChaseVehicle
// 0x0000 (0x03F0 - 0x03F0)
class UBFGQuest_ElementChaseVehicle final : public UBFGQuest_ElementEscort
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"BFGQuest_ElementChaseVehicle">();
	}
	static class UBFGQuest_ElementChaseVehicle* GetDefaultObj()
	{
		return GetDefaultObjImpl<UBFGQuest_ElementChaseVehicle>();
	}
};
static_assert(alignof(UBFGQuest_ElementChaseVehicle) == 0x000008, "Wrong alignment on UBFGQuest_ElementChaseVehicle");
static_assert(sizeof(UBFGQuest_ElementChaseVehicle) == 0x0003F0, "Wrong size on UBFGQuest_ElementChaseVehicle");

// Class BFGCore.BFGQuest_ElementCollect
// 0x0038 (0x0378 - 0x0340)
class UBFGQuest_ElementCollect final : public UBFGQuest_ElementObjectiveBase
{
public:
	EFBFGQuest_Element_ExecutionTime              M_executionTime;                                   // 0x0340(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_341[0x7];                                      // 0x0341(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<struct FBFGQuest_ElementCollect_Item>  M_aItemsToCollect;                                 // 0x0348(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, ContainsInstancedReference, NativeAccessSpecifierPublic)
	UMulticastDelegateProperty_                   M_OnCollectEvent;                                  // 0x0358(0x0018)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	bool                                          M_bEnableChallengeScore;                           // 0x0370(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EFBFGQuest_Element_ProcessingMode             M_processingMode;                                  // 0x0371(0x0001)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_372[0x6];                                      // 0x0372(0x0006)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	TArray<class UBFGVariable*> GetSparseQuestCounterVariables() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"BFGQuest_ElementCollect">();
	}
	static class UBFGQuest_ElementCollect* GetDefaultObj()
	{
		return GetDefaultObjImpl<UBFGQuest_ElementCollect>();
	}
};
static_assert(alignof(UBFGQuest_ElementCollect) == 0x000008, "Wrong alignment on UBFGQuest_ElementCollect");
static_assert(sizeof(UBFGQuest_ElementCollect) == 0x000378, "Wrong size on UBFGQuest_ElementCollect");
static_assert(offsetof(UBFGQuest_ElementCollect, M_executionTime) == 0x000340, "Member 'UBFGQuest_ElementCollect::M_executionTime' has a wrong offset!");
static_assert(offsetof(UBFGQuest_ElementCollect, M_aItemsToCollect) == 0x000348, "Member 'UBFGQuest_ElementCollect::M_aItemsToCollect' has a wrong offset!");
static_assert(offsetof(UBFGQuest_ElementCollect, M_OnCollectEvent) == 0x000358, "Member 'UBFGQuest_ElementCollect::M_OnCollectEvent' has a wrong offset!");
static_assert(offsetof(UBFGQuest_ElementCollect, M_bEnableChallengeScore) == 0x000370, "Member 'UBFGQuest_ElementCollect::M_bEnableChallengeScore' has a wrong offset!");
static_assert(offsetof(UBFGQuest_ElementCollect, M_processingMode) == 0x000371, "Member 'UBFGQuest_ElementCollect::M_processingMode' has a wrong offset!");

// Class BFGCore.BFGQuest_ElementCutscene
// 0x00C0 (0x03B8 - 0x02F8)
class UBFGQuest_ElementCutscene final : public UBFGQuest_Element
{
public:
	TSoftObjectPtr<class ALevelSequenceActor>     M_softLevelSequence;                               // 0x02F8(0x0028)(Edit, BlueprintVisible, BlueprintReadOnly, DisableEditOnInstance, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TArray<struct FBFGSequence_DynamicActorBinding> M_aSequenceActorBinding;                           // 0x0320(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, NativeAccessSpecifierPublic)
	bool                                          M_bUseCutsceneGameFlowState;                       // 0x0330(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_331[0x7];                                      // 0x0331(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	struct FBFGGameFlowState_CutsceneParameters   M_oCutsceneParameters;                             // 0x0338(0x0060)(Edit, BlueprintVisible, BlueprintReadOnly, DisableEditOnInstance, NativeAccessSpecifierPublic)
	uint8                                         Pad_398[0x18];                                     // 0x0398(0x0018)(Fixing Size After Last Property [ Dumper-7 ])
	class UBFGSequenceRequest*                    M_pSequenceRequest;                                // 0x03B0(0x0008)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"BFGQuest_ElementCutscene">();
	}
	static class UBFGQuest_ElementCutscene* GetDefaultObj()
	{
		return GetDefaultObjImpl<UBFGQuest_ElementCutscene>();
	}
};
static_assert(alignof(UBFGQuest_ElementCutscene) == 0x000008, "Wrong alignment on UBFGQuest_ElementCutscene");
static_assert(sizeof(UBFGQuest_ElementCutscene) == 0x0003B8, "Wrong size on UBFGQuest_ElementCutscene");
static_assert(offsetof(UBFGQuest_ElementCutscene, M_softLevelSequence) == 0x0002F8, "Member 'UBFGQuest_ElementCutscene::M_softLevelSequence' has a wrong offset!");
static_assert(offsetof(UBFGQuest_ElementCutscene, M_aSequenceActorBinding) == 0x000320, "Member 'UBFGQuest_ElementCutscene::M_aSequenceActorBinding' has a wrong offset!");
static_assert(offsetof(UBFGQuest_ElementCutscene, M_bUseCutsceneGameFlowState) == 0x000330, "Member 'UBFGQuest_ElementCutscene::M_bUseCutsceneGameFlowState' has a wrong offset!");
static_assert(offsetof(UBFGQuest_ElementCutscene, M_oCutsceneParameters) == 0x000338, "Member 'UBFGQuest_ElementCutscene::M_oCutsceneParameters' has a wrong offset!");
static_assert(offsetof(UBFGQuest_ElementCutscene, M_pSequenceRequest) == 0x0003B0, "Member 'UBFGQuest_ElementCutscene::M_pSequenceRequest' has a wrong offset!");

// Class BFGCore.BFGQuest_ElementDeliver
// 0x0050 (0x0390 - 0x0340)
class UBFGQuest_ElementDeliver final : public UBFGQuest_ElementObjectiveBase
{
public:
	UMulticastDelegateProperty_                   M_OnDeliverEvent;                                  // 0x0340(0x0018)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	UMulticastDelegateProperty_                   M_OnDeliverFailEvent;                              // 0x0358(0x0018)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	EFBFGQuest_Element_ExecutionTime              M_executionTime;                                   // 0x0370(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	EFBFGQuest_Element_ProcessingMode             M_processingMode;                                  // 0x0371(0x0001)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_372[0x6];                                      // 0x0372(0x0006)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<struct FBFGQuest_ElementDeliver_Objective> M_aObjectives;                                     // 0x0378(0x0010)(Edit, ZeroConstructor, ContainsInstancedReference, Protected, NativeAccessSpecifierProtected)
	bool                                          M_bEnableChallengeScore;                           // 0x0388(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_389[0x7];                                      // 0x0389(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"BFGQuest_ElementDeliver">();
	}
	static class UBFGQuest_ElementDeliver* GetDefaultObj()
	{
		return GetDefaultObjImpl<UBFGQuest_ElementDeliver>();
	}
};
static_assert(alignof(UBFGQuest_ElementDeliver) == 0x000008, "Wrong alignment on UBFGQuest_ElementDeliver");
static_assert(sizeof(UBFGQuest_ElementDeliver) == 0x000390, "Wrong size on UBFGQuest_ElementDeliver");
static_assert(offsetof(UBFGQuest_ElementDeliver, M_OnDeliverEvent) == 0x000340, "Member 'UBFGQuest_ElementDeliver::M_OnDeliverEvent' has a wrong offset!");
static_assert(offsetof(UBFGQuest_ElementDeliver, M_OnDeliverFailEvent) == 0x000358, "Member 'UBFGQuest_ElementDeliver::M_OnDeliverFailEvent' has a wrong offset!");
static_assert(offsetof(UBFGQuest_ElementDeliver, M_executionTime) == 0x000370, "Member 'UBFGQuest_ElementDeliver::M_executionTime' has a wrong offset!");
static_assert(offsetof(UBFGQuest_ElementDeliver, M_processingMode) == 0x000371, "Member 'UBFGQuest_ElementDeliver::M_processingMode' has a wrong offset!");
static_assert(offsetof(UBFGQuest_ElementDeliver, M_aObjectives) == 0x000378, "Member 'UBFGQuest_ElementDeliver::M_aObjectives' has a wrong offset!");
static_assert(offsetof(UBFGQuest_ElementDeliver, M_bEnableChallengeScore) == 0x000388, "Member 'UBFGQuest_ElementDeliver::M_bEnableChallengeScore' has a wrong offset!");

// Class BFGCore.BFGTaskNode_BossUnderCover
// 0x0000 (0x00A0 - 0x00A0)
class UBFGTaskNode_BossUnderCover final : public UBFGTaskNode_BossBase
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"BFGTaskNode_BossUnderCover">();
	}
	static class UBFGTaskNode_BossUnderCover* GetDefaultObj()
	{
		return GetDefaultObjImpl<UBFGTaskNode_BossUnderCover>();
	}
};
static_assert(alignof(UBFGTaskNode_BossUnderCover) == 0x000008, "Wrong alignment on UBFGTaskNode_BossUnderCover");
static_assert(sizeof(UBFGTaskNode_BossUnderCover) == 0x0000A0, "Wrong size on UBFGTaskNode_BossUnderCover");

// Class BFGCore.BFGQuest_ElementEnd
// 0x00B8 (0x03B0 - 0x02F8)
class UBFGQuest_ElementEnd final : public UBFGQuest_Element
{
public:
	bool                                          M_bCommitTags;                                     // 0x02F8(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          M_bCreateSaveAfterFinished;                        // 0x02F9(0x0001)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          M_bResetCheckpoint;                                // 0x02FA(0x0001)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          M_bShowResult;                                     // 0x02FB(0x0001)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2FC[0x4];                                      // 0x02FC(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	TSoftObjectPtr<class UBFGDataAsset_NewspaperInfo> M_softNewspaper;                                   // 0x0300(0x0028)(Edit, DisableEditOnInstance, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TArray<class FText>                           M_aCompletionVOEntries;                            // 0x0328(0x0010)(Edit, ZeroConstructor, DisableEditOnInstance, NativeAccessSpecifierPublic)
	bool                                          M_bCompletionVOBlocks;                             // 0x0338(0x0001)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_339[0x7];                                      // 0x0339(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	TSoftClassPtr<class UClass>                   M_softCompletionNarrativeSequence;                 // 0x0340(0x0028)(Edit, DisableEditOnInstance, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	UMulticastDelegateProperty_                   M_OnEventFinished;                                 // 0x0368(0x0018)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	UMulticastDelegateProperty_                   M_OnEventAborted;                                  // 0x0380(0x0018)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	UMulticastDelegateProperty_                   M_OnEventFailed;                                   // 0x0398(0x0018)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"BFGQuest_ElementEnd">();
	}
	static class UBFGQuest_ElementEnd* GetDefaultObj()
	{
		return GetDefaultObjImpl<UBFGQuest_ElementEnd>();
	}
};
static_assert(alignof(UBFGQuest_ElementEnd) == 0x000008, "Wrong alignment on UBFGQuest_ElementEnd");
static_assert(sizeof(UBFGQuest_ElementEnd) == 0x0003B0, "Wrong size on UBFGQuest_ElementEnd");
static_assert(offsetof(UBFGQuest_ElementEnd, M_bCommitTags) == 0x0002F8, "Member 'UBFGQuest_ElementEnd::M_bCommitTags' has a wrong offset!");
static_assert(offsetof(UBFGQuest_ElementEnd, M_bCreateSaveAfterFinished) == 0x0002F9, "Member 'UBFGQuest_ElementEnd::M_bCreateSaveAfterFinished' has a wrong offset!");
static_assert(offsetof(UBFGQuest_ElementEnd, M_bResetCheckpoint) == 0x0002FA, "Member 'UBFGQuest_ElementEnd::M_bResetCheckpoint' has a wrong offset!");
static_assert(offsetof(UBFGQuest_ElementEnd, M_bShowResult) == 0x0002FB, "Member 'UBFGQuest_ElementEnd::M_bShowResult' has a wrong offset!");
static_assert(offsetof(UBFGQuest_ElementEnd, M_softNewspaper) == 0x000300, "Member 'UBFGQuest_ElementEnd::M_softNewspaper' has a wrong offset!");
static_assert(offsetof(UBFGQuest_ElementEnd, M_aCompletionVOEntries) == 0x000328, "Member 'UBFGQuest_ElementEnd::M_aCompletionVOEntries' has a wrong offset!");
static_assert(offsetof(UBFGQuest_ElementEnd, M_bCompletionVOBlocks) == 0x000338, "Member 'UBFGQuest_ElementEnd::M_bCompletionVOBlocks' has a wrong offset!");
static_assert(offsetof(UBFGQuest_ElementEnd, M_softCompletionNarrativeSequence) == 0x000340, "Member 'UBFGQuest_ElementEnd::M_softCompletionNarrativeSequence' has a wrong offset!");
static_assert(offsetof(UBFGQuest_ElementEnd, M_OnEventFinished) == 0x000368, "Member 'UBFGQuest_ElementEnd::M_OnEventFinished' has a wrong offset!");
static_assert(offsetof(UBFGQuest_ElementEnd, M_OnEventAborted) == 0x000380, "Member 'UBFGQuest_ElementEnd::M_OnEventAborted' has a wrong offset!");
static_assert(offsetof(UBFGQuest_ElementEnd, M_OnEventFailed) == 0x000398, "Member 'UBFGQuest_ElementEnd::M_OnEventFailed' has a wrong offset!");

// Class BFGCore.BFGQuest_ElementFade
// 0x0130 (0x0428 - 0x02F8)
class UBFGQuest_ElementFade final : public UBFGQuest_Element
{
public:
	class FName                                   M_strIdentifier;                                   // 0x02F8(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         M_fFadeTime;                                       // 0x0300(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   M_strFadeName;                                     // 0x0304(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EBFGElementFadeType                           M_type;                                            // 0x030C(0x0001)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          M_bShouldRespawnStaticObjects;                     // 0x030D(0x0001)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          M_bShouldRespawnBuildings;                         // 0x030E(0x0001)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          M_bForceResetProxies;                              // 0x030F(0x0001)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FBFGActorBinding                       M_actorBinding_ProxiesToReset;                     // 0x0310(0x0090)(Edit, DisableEditOnInstance, NativeAccessSpecifierPublic)
	EBFGSensorGameplayOverrideBehavior            M_eSensorGameplayOverrideBehavior;                 // 0x03A0(0x0001)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          M_bDropHolobob;                                    // 0x03A1(0x0001)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_3A2[0x6];                                      // 0x03A2(0x0006)(Fixing Size After Last Property [ Dumper-7 ])
	struct FBFGQuest_StreamingRequester           M_StreamingRequests;                               // 0x03A8(0x0038)(Edit, BlueprintVisible, BlueprintReadOnly, DisableEditOnInstance, ContainsInstancedReference, NativeAccessSpecifierPublic)
	TSoftObjectPtr<class ABFGMissionSpawnManager> M_sopSpawnManager;                                 // 0x03E0(0x0028)(Edit, BlueprintVisible, BlueprintReadOnly, DisableEditOnInstance, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_408[0x20];                                     // 0x0408(0x0020)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"BFGQuest_ElementFade">();
	}
	static class UBFGQuest_ElementFade* GetDefaultObj()
	{
		return GetDefaultObjImpl<UBFGQuest_ElementFade>();
	}
};
static_assert(alignof(UBFGQuest_ElementFade) == 0x000008, "Wrong alignment on UBFGQuest_ElementFade");
static_assert(sizeof(UBFGQuest_ElementFade) == 0x000428, "Wrong size on UBFGQuest_ElementFade");
static_assert(offsetof(UBFGQuest_ElementFade, M_strIdentifier) == 0x0002F8, "Member 'UBFGQuest_ElementFade::M_strIdentifier' has a wrong offset!");
static_assert(offsetof(UBFGQuest_ElementFade, M_fFadeTime) == 0x000300, "Member 'UBFGQuest_ElementFade::M_fFadeTime' has a wrong offset!");
static_assert(offsetof(UBFGQuest_ElementFade, M_strFadeName) == 0x000304, "Member 'UBFGQuest_ElementFade::M_strFadeName' has a wrong offset!");
static_assert(offsetof(UBFGQuest_ElementFade, M_type) == 0x00030C, "Member 'UBFGQuest_ElementFade::M_type' has a wrong offset!");
static_assert(offsetof(UBFGQuest_ElementFade, M_bShouldRespawnStaticObjects) == 0x00030D, "Member 'UBFGQuest_ElementFade::M_bShouldRespawnStaticObjects' has a wrong offset!");
static_assert(offsetof(UBFGQuest_ElementFade, M_bShouldRespawnBuildings) == 0x00030E, "Member 'UBFGQuest_ElementFade::M_bShouldRespawnBuildings' has a wrong offset!");
static_assert(offsetof(UBFGQuest_ElementFade, M_bForceResetProxies) == 0x00030F, "Member 'UBFGQuest_ElementFade::M_bForceResetProxies' has a wrong offset!");
static_assert(offsetof(UBFGQuest_ElementFade, M_actorBinding_ProxiesToReset) == 0x000310, "Member 'UBFGQuest_ElementFade::M_actorBinding_ProxiesToReset' has a wrong offset!");
static_assert(offsetof(UBFGQuest_ElementFade, M_eSensorGameplayOverrideBehavior) == 0x0003A0, "Member 'UBFGQuest_ElementFade::M_eSensorGameplayOverrideBehavior' has a wrong offset!");
static_assert(offsetof(UBFGQuest_ElementFade, M_bDropHolobob) == 0x0003A1, "Member 'UBFGQuest_ElementFade::M_bDropHolobob' has a wrong offset!");
static_assert(offsetof(UBFGQuest_ElementFade, M_StreamingRequests) == 0x0003A8, "Member 'UBFGQuest_ElementFade::M_StreamingRequests' has a wrong offset!");
static_assert(offsetof(UBFGQuest_ElementFade, M_sopSpawnManager) == 0x0003E0, "Member 'UBFGQuest_ElementFade::M_sopSpawnManager' has a wrong offset!");

// Class BFGCore.BFGQuest_ElementKill
// 0x0090 (0x03D0 - 0x0340)
class UBFGQuest_ElementKill final : public UBFGQuest_ElementObjectiveBase
{
public:
	UMulticastDelegateProperty_                   M_OnKilledEvent;                                   // 0x0340(0x0018)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	TArray<struct FBFGQuest_ElementKill_Actor>    M_aToKill;                                         // 0x0358(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, ContainsInstancedReference, NativeAccessSpecifierPublic)
	UMulticastDelegateProperty_                   M_OnWaveStartedEvent;                              // 0x0368(0x0018)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	bool                                          M_bEnableChallengeScore;                           // 0x0380(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          M_bCountEnterWater;                                // 0x0381(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EFBFGQuest_Element_ExecutionTime              M_executionTime;                                   // 0x0382(0x0001)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	EFBFGQuest_Element_ProcessingMode             M_processingMode;                                  // 0x0383(0x0001)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_384[0x4];                                      // 0x0384(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	TSoftObjectPtr<class ABFGMissionSpawnManager> M_sopSpawnManager;                                 // 0x0388(0x0028)(Edit, BlueprintVisible, BlueprintReadOnly, DisableEditOnInstance, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_3B0[0x18];                                     // 0x03B0(0x0018)(Fixing Size After Last Property [ Dumper-7 ])
	class UBFGVariable*                           M_pWaveCounterVariable;                            // 0x03C8(0x0008)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)

public:
	TArray<class UBFGVariable*> GetSparseQuestCounterVariables() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"BFGQuest_ElementKill">();
	}
	static class UBFGQuest_ElementKill* GetDefaultObj()
	{
		return GetDefaultObjImpl<UBFGQuest_ElementKill>();
	}
};
static_assert(alignof(UBFGQuest_ElementKill) == 0x000008, "Wrong alignment on UBFGQuest_ElementKill");
static_assert(sizeof(UBFGQuest_ElementKill) == 0x0003D0, "Wrong size on UBFGQuest_ElementKill");
static_assert(offsetof(UBFGQuest_ElementKill, M_OnKilledEvent) == 0x000340, "Member 'UBFGQuest_ElementKill::M_OnKilledEvent' has a wrong offset!");
static_assert(offsetof(UBFGQuest_ElementKill, M_aToKill) == 0x000358, "Member 'UBFGQuest_ElementKill::M_aToKill' has a wrong offset!");
static_assert(offsetof(UBFGQuest_ElementKill, M_OnWaveStartedEvent) == 0x000368, "Member 'UBFGQuest_ElementKill::M_OnWaveStartedEvent' has a wrong offset!");
static_assert(offsetof(UBFGQuest_ElementKill, M_bEnableChallengeScore) == 0x000380, "Member 'UBFGQuest_ElementKill::M_bEnableChallengeScore' has a wrong offset!");
static_assert(offsetof(UBFGQuest_ElementKill, M_bCountEnterWater) == 0x000381, "Member 'UBFGQuest_ElementKill::M_bCountEnterWater' has a wrong offset!");
static_assert(offsetof(UBFGQuest_ElementKill, M_executionTime) == 0x000382, "Member 'UBFGQuest_ElementKill::M_executionTime' has a wrong offset!");
static_assert(offsetof(UBFGQuest_ElementKill, M_processingMode) == 0x000383, "Member 'UBFGQuest_ElementKill::M_processingMode' has a wrong offset!");
static_assert(offsetof(UBFGQuest_ElementKill, M_sopSpawnManager) == 0x000388, "Member 'UBFGQuest_ElementKill::M_sopSpawnManager' has a wrong offset!");
static_assert(offsetof(UBFGQuest_ElementKill, M_pWaveCounterVariable) == 0x0003C8, "Member 'UBFGQuest_ElementKill::M_pWaveCounterVariable' has a wrong offset!");

// Class BFGCore.BFGQuest_ElementMentalAbility
// 0x0088 (0x03C8 - 0x0340)
class UBFGQuest_ElementMentalAbility final : public UBFGQuest_ElementObjectiveBase
{
public:
	EFBFGQuest_Element_ExecutionTime              M_executionTime;                                   // 0x0340(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_341[0x7];                                      // 0x0341(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<struct FBFGQuest_ElementMentalAbility_Objective> M_aObjectives;                                     // 0x0348(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, ContainsInstancedReference, NativeAccessSpecifierPublic)
	TArray<struct FBFGQuest_ElementMentalAbility_Overrides> M_aOverrides;                                      // 0x0358(0x0010)(Edit, ZeroConstructor, DisableEditOnInstance, NativeAccessSpecifierPublic)
	UMulticastDelegateProperty_                   M_OnUsedAbilityEvent;                              // 0x0368(0x0018)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	UMulticastDelegateProperty_                   M_OnAbilityStateChangedEvent;                      // 0x0380(0x0018)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	EFBFGQuest_Element_ProcessingMode             M_processingMode;                                  // 0x0398(0x0001)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_399[0x7];                                      // 0x0399(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	struct FBFGQuestOverrides                     M_runtimeOverrides;                                // 0x03A0(0x0028)(Transient, Protected, NativeAccessSpecifierProtected)

public:
	TArray<class UBFGVariable*> GetSparseQuestCounterVariables() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"BFGQuest_ElementMentalAbility">();
	}
	static class UBFGQuest_ElementMentalAbility* GetDefaultObj()
	{
		return GetDefaultObjImpl<UBFGQuest_ElementMentalAbility>();
	}
};
static_assert(alignof(UBFGQuest_ElementMentalAbility) == 0x000008, "Wrong alignment on UBFGQuest_ElementMentalAbility");
static_assert(sizeof(UBFGQuest_ElementMentalAbility) == 0x0003C8, "Wrong size on UBFGQuest_ElementMentalAbility");
static_assert(offsetof(UBFGQuest_ElementMentalAbility, M_executionTime) == 0x000340, "Member 'UBFGQuest_ElementMentalAbility::M_executionTime' has a wrong offset!");
static_assert(offsetof(UBFGQuest_ElementMentalAbility, M_aObjectives) == 0x000348, "Member 'UBFGQuest_ElementMentalAbility::M_aObjectives' has a wrong offset!");
static_assert(offsetof(UBFGQuest_ElementMentalAbility, M_aOverrides) == 0x000358, "Member 'UBFGQuest_ElementMentalAbility::M_aOverrides' has a wrong offset!");
static_assert(offsetof(UBFGQuest_ElementMentalAbility, M_OnUsedAbilityEvent) == 0x000368, "Member 'UBFGQuest_ElementMentalAbility::M_OnUsedAbilityEvent' has a wrong offset!");
static_assert(offsetof(UBFGQuest_ElementMentalAbility, M_OnAbilityStateChangedEvent) == 0x000380, "Member 'UBFGQuest_ElementMentalAbility::M_OnAbilityStateChangedEvent' has a wrong offset!");
static_assert(offsetof(UBFGQuest_ElementMentalAbility, M_processingMode) == 0x000398, "Member 'UBFGQuest_ElementMentalAbility::M_processingMode' has a wrong offset!");
static_assert(offsetof(UBFGQuest_ElementMentalAbility, M_runtimeOverrides) == 0x0003A0, "Member 'UBFGQuest_ElementMentalAbility::M_runtimeOverrides' has a wrong offset!");

// Class BFGCore.BFGTaskNode_ExitCrowdFlow
// 0x0028 (0x00A0 - 0x0078)
class UBFGTaskNode_ExitCrowdFlow final : public UBFGBTBaseTaskNode
{
public:
	struct FBlackboardKeySelector                 M_BBKey_CrowdFlowAgent;                            // 0x0078(0x0028)(Edit, BlueprintVisible, Protected, NativeAccessSpecifierProtected)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"BFGTaskNode_ExitCrowdFlow">();
	}
	static class UBFGTaskNode_ExitCrowdFlow* GetDefaultObj()
	{
		return GetDefaultObjImpl<UBFGTaskNode_ExitCrowdFlow>();
	}
};
static_assert(alignof(UBFGTaskNode_ExitCrowdFlow) == 0x000008, "Wrong alignment on UBFGTaskNode_ExitCrowdFlow");
static_assert(sizeof(UBFGTaskNode_ExitCrowdFlow) == 0x0000A0, "Wrong size on UBFGTaskNode_ExitCrowdFlow");
static_assert(offsetof(UBFGTaskNode_ExitCrowdFlow, M_BBKey_CrowdFlowAgent) == 0x000078, "Member 'UBFGTaskNode_ExitCrowdFlow::M_BBKey_CrowdFlowAgent' has a wrong offset!");

// Class BFGCore.BFGQuest_ElementNarrativeSequence
// 0x0198 (0x0490 - 0x02F8)
class UBFGQuest_ElementNarrativeSequence final : public UBFGQuest_Element
{
public:
	TSoftClassPtr<class UClass>                   M_softNarrativeSequence;                           // 0x02F8(0x0028)(Edit, BlueprintVisible, BlueprintReadOnly, DisableEditOnInstance, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TSoftObjectPtr<class UBFGDataAsset_NewspaperInfo> M_softNewspaper;                                   // 0x0320(0x0028)(Edit, DisableEditOnInstance, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	UMulticastDelegateProperty_                   M_OnFinishedEvent;                                 // 0x0348(0x0018)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	bool                                          M_bFailOnNarrativeFail;                            // 0x0360(0x0001)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_361[0x7];                                      // 0x0361(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	struct FBFGQuest_Failure                      M_infoNarrativeFail;                               // 0x0368(0x0088)(Edit, DisableEditOnInstance, Protected, NativeAccessSpecifierProtected)
	bool                                          M_bInfoNarrativeFailUpdated;                       // 0x03F0(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_3F1[0x7];                                      // 0x03F1(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	TSoftObjectPtr<class UBFGDataAsset_NewspaperInfo> M_softNarrativeFailNewspaper;                      // 0x03F8(0x0028)(Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class FText                                   M_strNarrativeFailReason;                          // 0x0420(0x0018)(Protected, NativeAccessSpecifierProtected)
	TSoftClassPtr<class UClass>                   M_softNarrativeFailNarrativeSequence;              // 0x0438(0x0028)(Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          M_bFadeIn;                                         // 0x0460(0x0001)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_461[0x3];                                      // 0x0461(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	struct FBFGFadeEditorInfo                     M_FadeInInfo;                                      // 0x0464(0x000C)(Edit, DisableEditOnInstance, NoDestructor, Protected, NativeAccessSpecifierProtected)
	bool                                          M_bFadeOut;                                        // 0x0470(0x0001)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_471[0x3];                                      // 0x0471(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	struct FBFGFadeEditorInfo                     M_FadeOutInfo;                                     // 0x0474(0x000C)(Edit, DisableEditOnInstance, NoDestructor, Protected, NativeAccessSpecifierProtected)
	uint8                                         Pad_480[0x8];                                      // 0x0480(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	class UBFGNarrativeSequence*                  M_pNarrativeSequence;                              // 0x0488(0x0008)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)

public:
	const TMap<class FName, EUBFGNarrativeSequence_Assessment> GetAssessments() const;
	int32 GetNumStrikes() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"BFGQuest_ElementNarrativeSequence">();
	}
	static class UBFGQuest_ElementNarrativeSequence* GetDefaultObj()
	{
		return GetDefaultObjImpl<UBFGQuest_ElementNarrativeSequence>();
	}
};
static_assert(alignof(UBFGQuest_ElementNarrativeSequence) == 0x000008, "Wrong alignment on UBFGQuest_ElementNarrativeSequence");
static_assert(sizeof(UBFGQuest_ElementNarrativeSequence) == 0x000490, "Wrong size on UBFGQuest_ElementNarrativeSequence");
static_assert(offsetof(UBFGQuest_ElementNarrativeSequence, M_softNarrativeSequence) == 0x0002F8, "Member 'UBFGQuest_ElementNarrativeSequence::M_softNarrativeSequence' has a wrong offset!");
static_assert(offsetof(UBFGQuest_ElementNarrativeSequence, M_softNewspaper) == 0x000320, "Member 'UBFGQuest_ElementNarrativeSequence::M_softNewspaper' has a wrong offset!");
static_assert(offsetof(UBFGQuest_ElementNarrativeSequence, M_OnFinishedEvent) == 0x000348, "Member 'UBFGQuest_ElementNarrativeSequence::M_OnFinishedEvent' has a wrong offset!");
static_assert(offsetof(UBFGQuest_ElementNarrativeSequence, M_bFailOnNarrativeFail) == 0x000360, "Member 'UBFGQuest_ElementNarrativeSequence::M_bFailOnNarrativeFail' has a wrong offset!");
static_assert(offsetof(UBFGQuest_ElementNarrativeSequence, M_infoNarrativeFail) == 0x000368, "Member 'UBFGQuest_ElementNarrativeSequence::M_infoNarrativeFail' has a wrong offset!");
static_assert(offsetof(UBFGQuest_ElementNarrativeSequence, M_bInfoNarrativeFailUpdated) == 0x0003F0, "Member 'UBFGQuest_ElementNarrativeSequence::M_bInfoNarrativeFailUpdated' has a wrong offset!");
static_assert(offsetof(UBFGQuest_ElementNarrativeSequence, M_softNarrativeFailNewspaper) == 0x0003F8, "Member 'UBFGQuest_ElementNarrativeSequence::M_softNarrativeFailNewspaper' has a wrong offset!");
static_assert(offsetof(UBFGQuest_ElementNarrativeSequence, M_strNarrativeFailReason) == 0x000420, "Member 'UBFGQuest_ElementNarrativeSequence::M_strNarrativeFailReason' has a wrong offset!");
static_assert(offsetof(UBFGQuest_ElementNarrativeSequence, M_softNarrativeFailNarrativeSequence) == 0x000438, "Member 'UBFGQuest_ElementNarrativeSequence::M_softNarrativeFailNarrativeSequence' has a wrong offset!");
static_assert(offsetof(UBFGQuest_ElementNarrativeSequence, M_bFadeIn) == 0x000460, "Member 'UBFGQuest_ElementNarrativeSequence::M_bFadeIn' has a wrong offset!");
static_assert(offsetof(UBFGQuest_ElementNarrativeSequence, M_FadeInInfo) == 0x000464, "Member 'UBFGQuest_ElementNarrativeSequence::M_FadeInInfo' has a wrong offset!");
static_assert(offsetof(UBFGQuest_ElementNarrativeSequence, M_bFadeOut) == 0x000470, "Member 'UBFGQuest_ElementNarrativeSequence::M_bFadeOut' has a wrong offset!");
static_assert(offsetof(UBFGQuest_ElementNarrativeSequence, M_FadeOutInfo) == 0x000474, "Member 'UBFGQuest_ElementNarrativeSequence::M_FadeOutInfo' has a wrong offset!");
static_assert(offsetof(UBFGQuest_ElementNarrativeSequence, M_pNarrativeSequence) == 0x000488, "Member 'UBFGQuest_ElementNarrativeSequence::M_pNarrativeSequence' has a wrong offset!");

// Class BFGCore.BFGQuest_ElementProximity
// 0x0130 (0x0430 - 0x0300)
class UBFGQuest_ElementProximity final : public UBFGQuest_ElementObjectiveCustom
{
public:
	UMulticastDelegateProperty_                   M_OnSubgoalReachedEvent;                           // 0x0300(0x0018)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	struct FBFGQuest_ProximityMonitorSettings     M_monitorSettings;                                 // 0x0318(0x0088)(Edit, BlueprintVisible, BlueprintReadOnly, DisableEditOnInstance, Protected, NativeAccessSpecifierProtected)
	struct FBFGObjectiveMarkerInfo                M_markerInfo;                                      // 0x03A0(0x0028)(Edit, BlueprintVisible, BlueprintReadOnly, DisableEditOnInstance, ContainsInstancedReference, Protected, NativeAccessSpecifierProtected)
	struct FBFGQuest_UIProvider                   M_descriptionProvider;                             // 0x03C8(0x0050)(Edit, BlueprintVisible, BlueprintReadOnly, DisableEditOnInstance, Protected, NativeAccessSpecifierProtected)
	bool                                          M_bUIReverseBar;                                   // 0x0418(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_419[0x7];                                      // 0x0419(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	class UBFGQuest_ProximityMonitor*             M_pProximityMonitor;                               // 0x0420(0x0008)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UBFGObjectiveMarkerGroup*               M_pMarkerGroup;                                    // 0x0428(0x0008)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)

public:
	const TArray<int32> GetSubgoalLimits() const;
	float GetTargetDistance() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"BFGQuest_ElementProximity">();
	}
	static class UBFGQuest_ElementProximity* GetDefaultObj()
	{
		return GetDefaultObjImpl<UBFGQuest_ElementProximity>();
	}
};
static_assert(alignof(UBFGQuest_ElementProximity) == 0x000008, "Wrong alignment on UBFGQuest_ElementProximity");
static_assert(sizeof(UBFGQuest_ElementProximity) == 0x000430, "Wrong size on UBFGQuest_ElementProximity");
static_assert(offsetof(UBFGQuest_ElementProximity, M_OnSubgoalReachedEvent) == 0x000300, "Member 'UBFGQuest_ElementProximity::M_OnSubgoalReachedEvent' has a wrong offset!");
static_assert(offsetof(UBFGQuest_ElementProximity, M_monitorSettings) == 0x000318, "Member 'UBFGQuest_ElementProximity::M_monitorSettings' has a wrong offset!");
static_assert(offsetof(UBFGQuest_ElementProximity, M_markerInfo) == 0x0003A0, "Member 'UBFGQuest_ElementProximity::M_markerInfo' has a wrong offset!");
static_assert(offsetof(UBFGQuest_ElementProximity, M_descriptionProvider) == 0x0003C8, "Member 'UBFGQuest_ElementProximity::M_descriptionProvider' has a wrong offset!");
static_assert(offsetof(UBFGQuest_ElementProximity, M_bUIReverseBar) == 0x000418, "Member 'UBFGQuest_ElementProximity::M_bUIReverseBar' has a wrong offset!");
static_assert(offsetof(UBFGQuest_ElementProximity, M_pProximityMonitor) == 0x000420, "Member 'UBFGQuest_ElementProximity::M_pProximityMonitor' has a wrong offset!");
static_assert(offsetof(UBFGQuest_ElementProximity, M_pMarkerGroup) == 0x000428, "Member 'UBFGQuest_ElementProximity::M_pMarkerGroup' has a wrong offset!");

// Class BFGCore.BFGQuest_ElementVandalize
// 0x00C8 (0x03C8 - 0x0300)
class UBFGQuest_ElementVandalize final : public UBFGQuest_ElementObjectiveCustom
{
public:
	UMulticastDelegateProperty_                   M_OnMonetarySumChangedEvent;                       // 0x0300(0x0018)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	TArray<struct FBFGQuest_ElementVandalize_Actor> M_aObjectives;                                     // 0x0318(0x0010)(Edit, ZeroConstructor, ContainsInstancedReference, Protected, NativeAccessSpecifierProtected)
	float                                         M_fVandalizeTargetAmount;                          // 0x0328(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_32C[0x4];                                      // 0x032C(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	struct FBFGQuest_UIProvider                   M_descriptionProvider;                             // 0x0330(0x0050)(Edit, BlueprintVisible, BlueprintReadOnly, DisableEditOnInstance, Protected, NativeAccessSpecifierProtected)
	bool                                          M_bEnableChallengeScore;                           // 0x0380(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_381[0x7];                                      // 0x0381(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	struct FBFGQuest_Objectives                   M_runtimeObjectives;                               // 0x0388(0x0040)(Transient, ContainsInstancedReference, Protected, NativeAccessSpecifierProtected)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"BFGQuest_ElementVandalize">();
	}
	static class UBFGQuest_ElementVandalize* GetDefaultObj()
	{
		return GetDefaultObjImpl<UBFGQuest_ElementVandalize>();
	}
};
static_assert(alignof(UBFGQuest_ElementVandalize) == 0x000008, "Wrong alignment on UBFGQuest_ElementVandalize");
static_assert(sizeof(UBFGQuest_ElementVandalize) == 0x0003C8, "Wrong size on UBFGQuest_ElementVandalize");
static_assert(offsetof(UBFGQuest_ElementVandalize, M_OnMonetarySumChangedEvent) == 0x000300, "Member 'UBFGQuest_ElementVandalize::M_OnMonetarySumChangedEvent' has a wrong offset!");
static_assert(offsetof(UBFGQuest_ElementVandalize, M_aObjectives) == 0x000318, "Member 'UBFGQuest_ElementVandalize::M_aObjectives' has a wrong offset!");
static_assert(offsetof(UBFGQuest_ElementVandalize, M_fVandalizeTargetAmount) == 0x000328, "Member 'UBFGQuest_ElementVandalize::M_fVandalizeTargetAmount' has a wrong offset!");
static_assert(offsetof(UBFGQuest_ElementVandalize, M_descriptionProvider) == 0x000330, "Member 'UBFGQuest_ElementVandalize::M_descriptionProvider' has a wrong offset!");
static_assert(offsetof(UBFGQuest_ElementVandalize, M_bEnableChallengeScore) == 0x000380, "Member 'UBFGQuest_ElementVandalize::M_bEnableChallengeScore' has a wrong offset!");
static_assert(offsetof(UBFGQuest_ElementVandalize, M_runtimeObjectives) == 0x000388, "Member 'UBFGQuest_ElementVandalize::M_runtimeObjectives' has a wrong offset!");

// Class BFGCore.BFGQuest_ElementWaitFor
// 0x0090 (0x0390 - 0x0300)
class UBFGQuest_ElementWaitFor final : public UBFGQuest_ElementObjectiveCustom
{
public:
	bool                                          M_bWaitForAnyObjective;                            // 0x0300(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_301[0x3];                                      // 0x0301(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	int32                                         M_iNumObjectivesToComplete;                        // 0x0304(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          M_bJustWaitForVoiceOvers;                          // 0x0308(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_309[0x7];                                      // 0x0309(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	struct FBFGQuest_UIProvider                   M_descriptionProvider;                             // 0x0310(0x0050)(Edit, Protected, NativeAccessSpecifierProtected)
	uint8                                         Pad_360[0x10];                                     // 0x0360(0x0010)(Fixing Size After Last Property [ Dumper-7 ])
	class UBFGVariable*                           M_pFinishedVariable;                               // 0x0370(0x0008)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UBFGVariable*                           M_pFailedVariable;                                 // 0x0378(0x0008)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TArray<struct FBFGQuest_ElementWaitFor_Objective> M_aObjectives;                                     // 0x0380(0x0010)(ZeroConstructor, Transient, Protected, NativeAccessSpecifierProtected)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"BFGQuest_ElementWaitFor">();
	}
	static class UBFGQuest_ElementWaitFor* GetDefaultObj()
	{
		return GetDefaultObjImpl<UBFGQuest_ElementWaitFor>();
	}
};
static_assert(alignof(UBFGQuest_ElementWaitFor) == 0x000008, "Wrong alignment on UBFGQuest_ElementWaitFor");
static_assert(sizeof(UBFGQuest_ElementWaitFor) == 0x000390, "Wrong size on UBFGQuest_ElementWaitFor");
static_assert(offsetof(UBFGQuest_ElementWaitFor, M_bWaitForAnyObjective) == 0x000300, "Member 'UBFGQuest_ElementWaitFor::M_bWaitForAnyObjective' has a wrong offset!");
static_assert(offsetof(UBFGQuest_ElementWaitFor, M_iNumObjectivesToComplete) == 0x000304, "Member 'UBFGQuest_ElementWaitFor::M_iNumObjectivesToComplete' has a wrong offset!");
static_assert(offsetof(UBFGQuest_ElementWaitFor, M_bJustWaitForVoiceOvers) == 0x000308, "Member 'UBFGQuest_ElementWaitFor::M_bJustWaitForVoiceOvers' has a wrong offset!");
static_assert(offsetof(UBFGQuest_ElementWaitFor, M_descriptionProvider) == 0x000310, "Member 'UBFGQuest_ElementWaitFor::M_descriptionProvider' has a wrong offset!");
static_assert(offsetof(UBFGQuest_ElementWaitFor, M_pFinishedVariable) == 0x000370, "Member 'UBFGQuest_ElementWaitFor::M_pFinishedVariable' has a wrong offset!");
static_assert(offsetof(UBFGQuest_ElementWaitFor, M_pFailedVariable) == 0x000378, "Member 'UBFGQuest_ElementWaitFor::M_pFailedVariable' has a wrong offset!");
static_assert(offsetof(UBFGQuest_ElementWaitFor, M_aObjectives) == 0x000380, "Member 'UBFGQuest_ElementWaitFor::M_aObjectives' has a wrong offset!");

// Class BFGCore.BFGUIInputDeviceTracker
// 0x0050 (0x0078 - 0x0028)
class UBFGUIInputDeviceTracker : public UObject
{
public:
	UMulticastDelegateProperty_                   M_OnInputDeviceChanged;                            // 0x0028(0x0018)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	UMulticastDelegateProperty_                   M_OnWindowModeChanged;                             // 0x0040(0x0018)(ZeroConstructor, Transient, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	TWeakObjectPtr<class UBFGGameInstance>        M_pGameInstance;                                   // 0x0058(0x0008)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TArray<class UBFGRichTextBlockDecorator_InputAction*> M_apInputActionDecorators;                         // 0x0060(0x0010)(ZeroConstructor, Protected, NativeAccessSpecifierProtected)
	uint8                                         Pad_70[0x8];                                       // 0x0070(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void Action__DelegateSignature();
	void ActionBool__DelegateSignature(bool _bValue);
	int32 GetCurrentInputDeviceType();
	bool IsGamepadCurrentDevice();
	void OnWindowModeCommand(bool _bIsFullscreen);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"BFGUIInputDeviceTracker">();
	}
	static class UBFGUIInputDeviceTracker* GetDefaultObj()
	{
		return GetDefaultObjImpl<UBFGUIInputDeviceTracker>();
	}
};
static_assert(alignof(UBFGUIInputDeviceTracker) == 0x000008, "Wrong alignment on UBFGUIInputDeviceTracker");
static_assert(sizeof(UBFGUIInputDeviceTracker) == 0x000078, "Wrong size on UBFGUIInputDeviceTracker");
static_assert(offsetof(UBFGUIInputDeviceTracker, M_OnInputDeviceChanged) == 0x000028, "Member 'UBFGUIInputDeviceTracker::M_OnInputDeviceChanged' has a wrong offset!");
static_assert(offsetof(UBFGUIInputDeviceTracker, M_OnWindowModeChanged) == 0x000040, "Member 'UBFGUIInputDeviceTracker::M_OnWindowModeChanged' has a wrong offset!");
static_assert(offsetof(UBFGUIInputDeviceTracker, M_pGameInstance) == 0x000058, "Member 'UBFGUIInputDeviceTracker::M_pGameInstance' has a wrong offset!");
static_assert(offsetof(UBFGUIInputDeviceTracker, M_apInputActionDecorators) == 0x000060, "Member 'UBFGUIInputDeviceTracker::M_apInputActionDecorators' has a wrong offset!");

// Class BFGCore.BFGQuest_ElementWaitTime
// 0x00B8 (0x03B8 - 0x0300)
class UBFGQuest_ElementWaitTime final : public UBFGQuest_ElementObjectiveCustom
{
public:
	UMulticastDelegateProperty_                   M_OnSubgoalReachedEvent;                           // 0x0300(0x0018)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	EBFGQuest_TimerMode                           M_timerMode;                                       // 0x0318(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_319[0x7];                                      // 0x0319(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	struct FTimespan                              M_duration;                                        // 0x0320(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	struct FTimespan                              M_validateAt;                                      // 0x0328(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TArray<struct FTimespan>                      M_aSubgoalLimits;                                  // 0x0330(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, Protected, NativeAccessSpecifierProtected)
	class FName                                   M_strIdentifier;                                   // 0x0340(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	EFBFGQuest_Element_ExecutionTime              M_executionTime;                                   // 0x0348(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_349[0x3];                                      // 0x0349(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	int32                                         M_iLockedInputGroups;                              // 0x034C(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          M_bShowInHud;                                      // 0x0350(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_351[0x7];                                      // 0x0351(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	struct FBFGQuest_UIProvider                   M_descriptionProvider;                             // 0x0358(0x0050)(Edit, BlueprintVisible, BlueprintReadOnly, DisableEditOnInstance, Protected, NativeAccessSpecifierProtected)
	bool                                          M_bUIReverseBar;                                   // 0x03A8(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          M_bUIShowTotalTime;                                // 0x03A9(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          M_bEnableCombatLockWhenMovementLocked;             // 0x03AA(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	EBFGCombatLock                                M_combatLock;                                      // 0x03AB(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_3AC[0x4];                                      // 0x03AC(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class UBFGQuest_Timer*                        M_pQuestTimer;                                     // 0x03B0(0x0008)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)

public:
	float GetElapsedTimeSinceStart() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"BFGQuest_ElementWaitTime">();
	}
	static class UBFGQuest_ElementWaitTime* GetDefaultObj()
	{
		return GetDefaultObjImpl<UBFGQuest_ElementWaitTime>();
	}
};
static_assert(alignof(UBFGQuest_ElementWaitTime) == 0x000008, "Wrong alignment on UBFGQuest_ElementWaitTime");
static_assert(sizeof(UBFGQuest_ElementWaitTime) == 0x0003B8, "Wrong size on UBFGQuest_ElementWaitTime");
static_assert(offsetof(UBFGQuest_ElementWaitTime, M_OnSubgoalReachedEvent) == 0x000300, "Member 'UBFGQuest_ElementWaitTime::M_OnSubgoalReachedEvent' has a wrong offset!");
static_assert(offsetof(UBFGQuest_ElementWaitTime, M_timerMode) == 0x000318, "Member 'UBFGQuest_ElementWaitTime::M_timerMode' has a wrong offset!");
static_assert(offsetof(UBFGQuest_ElementWaitTime, M_duration) == 0x000320, "Member 'UBFGQuest_ElementWaitTime::M_duration' has a wrong offset!");
static_assert(offsetof(UBFGQuest_ElementWaitTime, M_validateAt) == 0x000328, "Member 'UBFGQuest_ElementWaitTime::M_validateAt' has a wrong offset!");
static_assert(offsetof(UBFGQuest_ElementWaitTime, M_aSubgoalLimits) == 0x000330, "Member 'UBFGQuest_ElementWaitTime::M_aSubgoalLimits' has a wrong offset!");
static_assert(offsetof(UBFGQuest_ElementWaitTime, M_strIdentifier) == 0x000340, "Member 'UBFGQuest_ElementWaitTime::M_strIdentifier' has a wrong offset!");
static_assert(offsetof(UBFGQuest_ElementWaitTime, M_executionTime) == 0x000348, "Member 'UBFGQuest_ElementWaitTime::M_executionTime' has a wrong offset!");
static_assert(offsetof(UBFGQuest_ElementWaitTime, M_iLockedInputGroups) == 0x00034C, "Member 'UBFGQuest_ElementWaitTime::M_iLockedInputGroups' has a wrong offset!");
static_assert(offsetof(UBFGQuest_ElementWaitTime, M_bShowInHud) == 0x000350, "Member 'UBFGQuest_ElementWaitTime::M_bShowInHud' has a wrong offset!");
static_assert(offsetof(UBFGQuest_ElementWaitTime, M_descriptionProvider) == 0x000358, "Member 'UBFGQuest_ElementWaitTime::M_descriptionProvider' has a wrong offset!");
static_assert(offsetof(UBFGQuest_ElementWaitTime, M_bUIReverseBar) == 0x0003A8, "Member 'UBFGQuest_ElementWaitTime::M_bUIReverseBar' has a wrong offset!");
static_assert(offsetof(UBFGQuest_ElementWaitTime, M_bUIShowTotalTime) == 0x0003A9, "Member 'UBFGQuest_ElementWaitTime::M_bUIShowTotalTime' has a wrong offset!");
static_assert(offsetof(UBFGQuest_ElementWaitTime, M_bEnableCombatLockWhenMovementLocked) == 0x0003AA, "Member 'UBFGQuest_ElementWaitTime::M_bEnableCombatLockWhenMovementLocked' has a wrong offset!");
static_assert(offsetof(UBFGQuest_ElementWaitTime, M_combatLock) == 0x0003AB, "Member 'UBFGQuest_ElementWaitTime::M_combatLock' has a wrong offset!");
static_assert(offsetof(UBFGQuest_ElementWaitTime, M_pQuestTimer) == 0x0003B0, "Member 'UBFGQuest_ElementWaitTime::M_pQuestTimer' has a wrong offset!");

// Class BFGCore.BFGQuest_Manager
// 0x0310 (0x0340 - 0x0030)
class UBFGQuest_Manager final : public UBFGGameSystem
{
public:
	uint8                                         Pad_30[0x10];                                      // 0x0030(0x0010)(Fixing Size After Last Property [ Dumper-7 ])
	UMulticastDelegateProperty_                   M_onMainMissionOrChallengeEnded;                   // 0x0040(0x0018)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	uint8                                         Pad_58[0x130];                                     // 0x0058(0x0130)(Fixing Size After Last Property [ Dumper-7 ])
	TMap<struct FGuid, struct FBFGSystemData_QuestManager_CompletionRating> M_aQuestCompletionRating;                          // 0x0188(0x0050)(ZeroConstructor, Transient, Protected, NativeAccessSpecifierProtected)
	uint8                                         Pad_1D8[0x8];                                      // 0x01D8(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	class ABFGGameState*                          M_pGameState;                                      // 0x01E0(0x0008)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UBFGQuestReward_Manager*                M_pQuestRewardManager;                             // 0x01E8(0x0008)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UBFGTriggerManager*                     M_pTriggerManager;                                 // 0x01F0(0x0008)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UBFGQuest_ProximityMonitorManager*      M_pProximityMonitorManager;                        // 0x01F8(0x0008)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TMap<struct FGuid, class UBFGQuest*>          M_aQuests;                                         // 0x0200(0x0050)(ExportObject, ZeroConstructor, Transient, ContainsInstancedReference, Protected, NativeAccessSpecifierProtected)
	TArray<class UBFGQuest*>                      M_aPendingStart;                                   // 0x0250(0x0010)(ZeroConstructor, Transient, Protected, NativeAccessSpecifierProtected)
	TArray<class UBFGQuest*>                      M_apPendingUIUpdate;                               // 0x0260(0x0010)(ZeroConstructor, Transient, Protected, NativeAccessSpecifierProtected)
	TArray<class UBFGQuest_UIData_Source*>        M_apUISources;                                     // 0x0270(0x0010)(ZeroConstructor, Transient, Protected, NativeAccessSpecifierProtected)
	TArray<struct FBFGQuest_UIData_Main>          M_aCurrentUI;                                      // 0x0280(0x0010)(ZeroConstructor, Transient, Protected, NativeAccessSpecifierProtected)
	TArray<class UBFGQuest_Timer*>                M_aQuestTimers;                                    // 0x0290(0x0010)(ExportObject, ZeroConstructor, Transient, ContainsInstancedReference, Protected, NativeAccessSpecifierProtected)
	TArray<class UBFGQuest_Timer*>                M_aRunningTimers;                                  // 0x02A0(0x0010)(ZeroConstructor, Transient, Protected, NativeAccessSpecifierProtected)
	TArray<class UBFGQuest_Challenge*>            M_aQuestChallenges;                                // 0x02B0(0x0010)(ExportObject, ZeroConstructor, Transient, ContainsInstancedReference, Protected, NativeAccessSpecifierProtected)
	TArray<class UBFGQuest_CortexScanObjectiveTracker*> M_apCortexScanTrackers;                            // 0x02C0(0x0010)(ExportObject, ZeroConstructor, Transient, ContainsInstancedReference, Protected, NativeAccessSpecifierProtected)
	TMap<TSoftClassPtr<class UClass>, TSubclassOf<class UBFGQuest>> M_aQuestClasses;                                   // 0x02D0(0x0050)(ZeroConstructor, Transient, Protected, UObjectWrapper, NativeAccessSpecifierProtected)
	uint8                                         Pad_320[0x10];                                     // 0x0320(0x0010)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<class UBFGQuest_StartupMode*>          M_apStartupModes;                                  // 0x0330(0x0010)(ExportObject, ZeroConstructor, Transient, ContainsInstancedReference, Protected, NativeAccessSpecifierProtected)

public:
	void CheatCompleteAdditionalObjective();
	void CheatCompleteChallenge(int32 _iStarRating);
	void CheatCompleteMission();
	void CheatCompleteMissionStep();
	void CheatCompleteMissionTimers();
	bool DetermineIfOpenWorld();
	bool IsQuestInProgress(const TSoftClassPtr<class UClass>& _softQuest);
	bool IsQuestToBeStarted(const TSoftClassPtr<class UClass>& _softQuest);
	void OnQuestVariableChanged_MainMissionOrChallenge(class UBFGVariableMirror* _pVarMirror, const class UBFGVariable* _pVariable, int32 _iOldValue, int32 _iNewValue);
	void OnWorldLoaded(class UBFGGameInstance* _pGameInstance, class UWorld* _pWorld);
	void PrepareLevelSwitch();
	void QuestUIUpdateEvent__DelegateSignature(class UBFGQuest* _pQuest, const class FText& _strText, const TArray<class FText>& _aDescription);

	class UBFGQuest* FindQuestByGuid(const struct FGuid& _guid) const;
	class UBFGQuest* FindQuestOfType(const TSubclassOf<class UBFGQuest>& _pClass) const;
	void GameSystem_QuestLog() const;
	void GameSystem_QuestLogAllWorlds() const;
	class ABFGGameState* GetGameState() const;
	class FString GetMainQuestName(bool _bFilterCurrentWorld, bool _bReturnWorldNameIfNull) const;
	class FString GetMainQuestText() const;
	void GetQuests(TArray<class UBFGQuest*>* _aQuestsOut) const;
	void GetQuestsInProgress(TArray<class UBFGQuest*>* _apQuestsOut) const;
	void GetRunningQuestTimers(TArray<class UBFGQuest_Timer*>* _aTimersOut) const;
	void GotoMotherShip() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"BFGQuest_Manager">();
	}
	static class UBFGQuest_Manager* GetDefaultObj()
	{
		return GetDefaultObjImpl<UBFGQuest_Manager>();
	}
};
static_assert(alignof(UBFGQuest_Manager) == 0x000008, "Wrong alignment on UBFGQuest_Manager");
static_assert(sizeof(UBFGQuest_Manager) == 0x000340, "Wrong size on UBFGQuest_Manager");
static_assert(offsetof(UBFGQuest_Manager, M_onMainMissionOrChallengeEnded) == 0x000040, "Member 'UBFGQuest_Manager::M_onMainMissionOrChallengeEnded' has a wrong offset!");
static_assert(offsetof(UBFGQuest_Manager, M_aQuestCompletionRating) == 0x000188, "Member 'UBFGQuest_Manager::M_aQuestCompletionRating' has a wrong offset!");
static_assert(offsetof(UBFGQuest_Manager, M_pGameState) == 0x0001E0, "Member 'UBFGQuest_Manager::M_pGameState' has a wrong offset!");
static_assert(offsetof(UBFGQuest_Manager, M_pQuestRewardManager) == 0x0001E8, "Member 'UBFGQuest_Manager::M_pQuestRewardManager' has a wrong offset!");
static_assert(offsetof(UBFGQuest_Manager, M_pTriggerManager) == 0x0001F0, "Member 'UBFGQuest_Manager::M_pTriggerManager' has a wrong offset!");
static_assert(offsetof(UBFGQuest_Manager, M_pProximityMonitorManager) == 0x0001F8, "Member 'UBFGQuest_Manager::M_pProximityMonitorManager' has a wrong offset!");
static_assert(offsetof(UBFGQuest_Manager, M_aQuests) == 0x000200, "Member 'UBFGQuest_Manager::M_aQuests' has a wrong offset!");
static_assert(offsetof(UBFGQuest_Manager, M_aPendingStart) == 0x000250, "Member 'UBFGQuest_Manager::M_aPendingStart' has a wrong offset!");
static_assert(offsetof(UBFGQuest_Manager, M_apPendingUIUpdate) == 0x000260, "Member 'UBFGQuest_Manager::M_apPendingUIUpdate' has a wrong offset!");
static_assert(offsetof(UBFGQuest_Manager, M_apUISources) == 0x000270, "Member 'UBFGQuest_Manager::M_apUISources' has a wrong offset!");
static_assert(offsetof(UBFGQuest_Manager, M_aCurrentUI) == 0x000280, "Member 'UBFGQuest_Manager::M_aCurrentUI' has a wrong offset!");
static_assert(offsetof(UBFGQuest_Manager, M_aQuestTimers) == 0x000290, "Member 'UBFGQuest_Manager::M_aQuestTimers' has a wrong offset!");
static_assert(offsetof(UBFGQuest_Manager, M_aRunningTimers) == 0x0002A0, "Member 'UBFGQuest_Manager::M_aRunningTimers' has a wrong offset!");
static_assert(offsetof(UBFGQuest_Manager, M_aQuestChallenges) == 0x0002B0, "Member 'UBFGQuest_Manager::M_aQuestChallenges' has a wrong offset!");
static_assert(offsetof(UBFGQuest_Manager, M_apCortexScanTrackers) == 0x0002C0, "Member 'UBFGQuest_Manager::M_apCortexScanTrackers' has a wrong offset!");
static_assert(offsetof(UBFGQuest_Manager, M_aQuestClasses) == 0x0002D0, "Member 'UBFGQuest_Manager::M_aQuestClasses' has a wrong offset!");
static_assert(offsetof(UBFGQuest_Manager, M_apStartupModes) == 0x000330, "Member 'UBFGQuest_Manager::M_apStartupModes' has a wrong offset!");

// Class BFGCore.BFGQuest_StreamingLevels
// 0x0028 (0x0050 - 0x0028)
class UBFGQuest_StreamingLevels final : public UObject
{
public:
	TArray<class UBFGStreamingLevelHandle*>       M_aSparseHandles;                                  // 0x0028(0x0010)(ZeroConstructor, Transient, Protected, NativeAccessSpecifierProtected)
	class ABFGGameState*                          M_pGameState;                                      // 0x0038(0x0008)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UBFGQuest*                              M_pQuest;                                          // 0x0040(0x0008)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_48[0x8];                                       // 0x0048(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"BFGQuest_StreamingLevels">();
	}
	static class UBFGQuest_StreamingLevels* GetDefaultObj()
	{
		return GetDefaultObjImpl<UBFGQuest_StreamingLevels>();
	}
};
static_assert(alignof(UBFGQuest_StreamingLevels) == 0x000008, "Wrong alignment on UBFGQuest_StreamingLevels");
static_assert(sizeof(UBFGQuest_StreamingLevels) == 0x000050, "Wrong size on UBFGQuest_StreamingLevels");
static_assert(offsetof(UBFGQuest_StreamingLevels, M_aSparseHandles) == 0x000028, "Member 'UBFGQuest_StreamingLevels::M_aSparseHandles' has a wrong offset!");
static_assert(offsetof(UBFGQuest_StreamingLevels, M_pGameState) == 0x000038, "Member 'UBFGQuest_StreamingLevels::M_pGameState' has a wrong offset!");
static_assert(offsetof(UBFGQuest_StreamingLevels, M_pQuest) == 0x000040, "Member 'UBFGQuest_StreamingLevels::M_pQuest' has a wrong offset!");

// Class BFGCore.BFGQuest_Trigger
// 0x0150 (0x0178 - 0x0028)
class UBFGQuest_Trigger : public UObject
{
public:
	class UBFGQuest_Manager*                      M_pManager;                                        // 0x0028(0x0008)(ExportObject, ZeroConstructor, Transient, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_30[0x8];                                       // 0x0030(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	class UBFGQuest*                              M_pQuest;                                          // 0x0038(0x0008)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	struct FBFGActorBinding                       M_triggerBinding;                                  // 0x0040(0x0090)(Transient, Protected, NativeAccessSpecifierProtected)
	struct FBFGActorBinding                       M_pawnBinding;                                     // 0x00D0(0x0090)(Transient, Protected, NativeAccessSpecifierProtected)
	class UBFGVariable*                           M_pOverlapCounter;                                 // 0x0160(0x0008)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_168[0x10];                                     // 0x0168(0x0010)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"BFGQuest_Trigger">();
	}
	static class UBFGQuest_Trigger* GetDefaultObj()
	{
		return GetDefaultObjImpl<UBFGQuest_Trigger>();
	}
};
static_assert(alignof(UBFGQuest_Trigger) == 0x000008, "Wrong alignment on UBFGQuest_Trigger");
static_assert(sizeof(UBFGQuest_Trigger) == 0x000178, "Wrong size on UBFGQuest_Trigger");
static_assert(offsetof(UBFGQuest_Trigger, M_pManager) == 0x000028, "Member 'UBFGQuest_Trigger::M_pManager' has a wrong offset!");
static_assert(offsetof(UBFGQuest_Trigger, M_pQuest) == 0x000038, "Member 'UBFGQuest_Trigger::M_pQuest' has a wrong offset!");
static_assert(offsetof(UBFGQuest_Trigger, M_triggerBinding) == 0x000040, "Member 'UBFGQuest_Trigger::M_triggerBinding' has a wrong offset!");
static_assert(offsetof(UBFGQuest_Trigger, M_pawnBinding) == 0x0000D0, "Member 'UBFGQuest_Trigger::M_pawnBinding' has a wrong offset!");
static_assert(offsetof(UBFGQuest_Trigger, M_pOverlapCounter) == 0x000160, "Member 'UBFGQuest_Trigger::M_pOverlapCounter' has a wrong offset!");

// Class BFGCore.BFGVariableAction_Dialog_Finished
// 0x0000 (0x00F0 - 0x00F0)
class UBFGVariableAction_Dialog_Finished final : public UBFGVariableAction
{
public:
	static const class FName GetActionName_DialogFinished();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"BFGVariableAction_Dialog_Finished">();
	}
	static class UBFGVariableAction_Dialog_Finished* GetDefaultObj()
	{
		return GetDefaultObjImpl<UBFGVariableAction_Dialog_Finished>();
	}
};
static_assert(alignof(UBFGVariableAction_Dialog_Finished) == 0x000008, "Wrong alignment on UBFGVariableAction_Dialog_Finished");
static_assert(sizeof(UBFGVariableAction_Dialog_Finished) == 0x0000F0, "Wrong size on UBFGVariableAction_Dialog_Finished");

// Class BFGCore.BFGQuest_TriggerInTriggerTimer
// 0x0018 (0x0190 - 0x0178)
class UBFGQuest_TriggerInTriggerTimer final : public UBFGQuest_Trigger
{
public:
	float                                         M_fCurrentTime;                                    // 0x0178(0x0004)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         M_fMaxTime;                                        // 0x017C(0x0004)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          M_bAddTimePerActor;                                // 0x0180(0x0001)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_181[0x7];                                      // 0x0181(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	class UBFGVariable*                           M_pReachedCounterPercent;                          // 0x0188(0x0008)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"BFGQuest_TriggerInTriggerTimer">();
	}
	static class UBFGQuest_TriggerInTriggerTimer* GetDefaultObj()
	{
		return GetDefaultObjImpl<UBFGQuest_TriggerInTriggerTimer>();
	}
};
static_assert(alignof(UBFGQuest_TriggerInTriggerTimer) == 0x000008, "Wrong alignment on UBFGQuest_TriggerInTriggerTimer");
static_assert(sizeof(UBFGQuest_TriggerInTriggerTimer) == 0x000190, "Wrong size on UBFGQuest_TriggerInTriggerTimer");
static_assert(offsetof(UBFGQuest_TriggerInTriggerTimer, M_fCurrentTime) == 0x000178, "Member 'UBFGQuest_TriggerInTriggerTimer::M_fCurrentTime' has a wrong offset!");
static_assert(offsetof(UBFGQuest_TriggerInTriggerTimer, M_fMaxTime) == 0x00017C, "Member 'UBFGQuest_TriggerInTriggerTimer::M_fMaxTime' has a wrong offset!");
static_assert(offsetof(UBFGQuest_TriggerInTriggerTimer, M_bAddTimePerActor) == 0x000180, "Member 'UBFGQuest_TriggerInTriggerTimer::M_bAddTimePerActor' has a wrong offset!");
static_assert(offsetof(UBFGQuest_TriggerInTriggerTimer, M_pReachedCounterPercent) == 0x000188, "Member 'UBFGQuest_TriggerInTriggerTimer::M_pReachedCounterPercent' has a wrong offset!");

// Class BFGCore.BFGQuest_UIData_Source
// 0x0040 (0x0068 - 0x0028)
class UBFGQuest_UIData_Source final : public UObject
{
public:
	class UBFGQuest*                              M_pQuest;                                          // 0x0028(0x0008)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_30[0x38];                                      // 0x0030(0x0038)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"BFGQuest_UIData_Source">();
	}
	static class UBFGQuest_UIData_Source* GetDefaultObj()
	{
		return GetDefaultObjImpl<UBFGQuest_UIData_Source>();
	}
};
static_assert(alignof(UBFGQuest_UIData_Source) == 0x000008, "Wrong alignment on UBFGQuest_UIData_Source");
static_assert(sizeof(UBFGQuest_UIData_Source) == 0x000068, "Wrong size on UBFGQuest_UIData_Source");
static_assert(offsetof(UBFGQuest_UIData_Source, M_pQuest) == 0x000028, "Member 'UBFGQuest_UIData_Source::M_pQuest' has a wrong offset!");

// Class BFGCore.BFGTaskNode_SetBossWeaponState
// 0x0008 (0x0080 - 0x0078)
class UBFGTaskNode_SetBossWeaponState final : public UBFGBTBaseTaskNode
{
public:
	int32                                         M_iWeaponIndex;                                    // 0x0078(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          M_bRequestFire;                                    // 0x007C(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_7D[0x3];                                       // 0x007D(0x0003)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"BFGTaskNode_SetBossWeaponState">();
	}
	static class UBFGTaskNode_SetBossWeaponState* GetDefaultObj()
	{
		return GetDefaultObjImpl<UBFGTaskNode_SetBossWeaponState>();
	}
};
static_assert(alignof(UBFGTaskNode_SetBossWeaponState) == 0x000008, "Wrong alignment on UBFGTaskNode_SetBossWeaponState");
static_assert(sizeof(UBFGTaskNode_SetBossWeaponState) == 0x000080, "Wrong size on UBFGTaskNode_SetBossWeaponState");
static_assert(offsetof(UBFGTaskNode_SetBossWeaponState, M_iWeaponIndex) == 0x000078, "Member 'UBFGTaskNode_SetBossWeaponState::M_iWeaponIndex' has a wrong offset!");
static_assert(offsetof(UBFGTaskNode_SetBossWeaponState, M_bRequestFire) == 0x00007C, "Member 'UBFGTaskNode_SetBossWeaponState::M_bRequestFire' has a wrong offset!");

// Class BFGCore.BFGQuestReward_Manager
// 0x0008 (0x0030 - 0x0028)
class UBFGQuestReward_Manager final : public UObject
{
public:
	class ABFGGameState*                          M_pGameState;                                      // 0x0028(0x0008)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"BFGQuestReward_Manager">();
	}
	static class UBFGQuestReward_Manager* GetDefaultObj()
	{
		return GetDefaultObjImpl<UBFGQuestReward_Manager>();
	}
};
static_assert(alignof(UBFGQuestReward_Manager) == 0x000008, "Wrong alignment on UBFGQuestReward_Manager");
static_assert(sizeof(UBFGQuestReward_Manager) == 0x000030, "Wrong size on UBFGQuestReward_Manager");
static_assert(offsetof(UBFGQuestReward_Manager, M_pGameState) == 0x000028, "Member 'UBFGQuestReward_Manager::M_pGameState' has a wrong offset!");

// Class BFGCore.BFGQuestSettings
// 0x0288 (0x02C0 - 0x0038)
class UBFGQuestSettings final : public UDeveloperSettings
{
public:
	TMap<EObjectWeightClass, float>               M_aDefaultMonetaryValues;                          // 0x0038(0x0050)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Config, DisableEditOnInstance, GlobalConfig, NativeAccessSpecifierPublic)
	class FText                                   M_strProximityMonitorFormat;                       // 0x0088(0x0018)(Edit, BlueprintVisible, BlueprintReadOnly, Config, DisableEditOnInstance, GlobalConfig, NativeAccessSpecifierPublic)
	TSoftClassPtr<class UClass>                   M_spProximityMonitorClass;                         // 0x00A0(0x0028)(Edit, BlueprintVisible, BlueprintReadOnly, Config, DisableEditOnInstance, GlobalConfig, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TSoftObjectPtr<class UPaperSprite>            M_spFallbackDefaultIcon;                           // 0x00C8(0x0028)(Edit, BlueprintVisible, BlueprintReadOnly, Config, DisableEditOnInstance, GlobalConfig, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TMap<TSubclassOf<class UBFGQuest_Element>, TSoftObjectPtr<class UPaperSprite>> M_aDefaultIcons;                                   // 0x00F0(0x0050)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Config, DisableEditOnInstance, GlobalConfig, UObjectWrapper, NativeAccessSpecifierPublic)
	class FText                                   M_strProgressBonusFormat;                          // 0x0140(0x0018)(Edit, BlueprintVisible, BlueprintReadOnly, Config, DisableEditOnInstance, GlobalConfig, NativeAccessSpecifierPublic)
	class FText                                   M_strTimeLimitFormat;                              // 0x0158(0x0018)(Edit, BlueprintVisible, BlueprintReadOnly, Config, DisableEditOnInstance, GlobalConfig, NativeAccessSpecifierPublic)
	class FText                                   M_strPersonalBest;                                 // 0x0170(0x0018)(Edit, BlueprintVisible, BlueprintReadOnly, Config, DisableEditOnInstance, GlobalConfig, NativeAccessSpecifierPublic)
	class FText                                   M_strRewardFormat;                                 // 0x0188(0x0018)(Edit, BlueprintVisible, BlueprintReadOnly, Config, DisableEditOnInstance, GlobalConfig, NativeAccessSpecifierPublic)
	TMap<EBFGChallengeType, struct FBFGQuestSettings_ChallengeData> M_aChallengeDefaults;                              // 0x01A0(0x0050)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Config, DisableEditOnInstance, GlobalConfig, NativeAccessSpecifierPublic)
	uint8                                         Pad_1F0[0xD0];                                     // 0x01F0(0x00D0)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UBFGQuestSettings* GetSettings();

	const struct FBFGQuestSettings_ChallengeData GetChallengeDefaults(EBFGChallengeType _eType) const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"BFGQuestSettings">();
	}
	static class UBFGQuestSettings* GetDefaultObj()
	{
		return GetDefaultObjImpl<UBFGQuestSettings>();
	}
};
static_assert(alignof(UBFGQuestSettings) == 0x000008, "Wrong alignment on UBFGQuestSettings");
static_assert(sizeof(UBFGQuestSettings) == 0x0002C0, "Wrong size on UBFGQuestSettings");
static_assert(offsetof(UBFGQuestSettings, M_aDefaultMonetaryValues) == 0x000038, "Member 'UBFGQuestSettings::M_aDefaultMonetaryValues' has a wrong offset!");
static_assert(offsetof(UBFGQuestSettings, M_strProximityMonitorFormat) == 0x000088, "Member 'UBFGQuestSettings::M_strProximityMonitorFormat' has a wrong offset!");
static_assert(offsetof(UBFGQuestSettings, M_spProximityMonitorClass) == 0x0000A0, "Member 'UBFGQuestSettings::M_spProximityMonitorClass' has a wrong offset!");
static_assert(offsetof(UBFGQuestSettings, M_spFallbackDefaultIcon) == 0x0000C8, "Member 'UBFGQuestSettings::M_spFallbackDefaultIcon' has a wrong offset!");
static_assert(offsetof(UBFGQuestSettings, M_aDefaultIcons) == 0x0000F0, "Member 'UBFGQuestSettings::M_aDefaultIcons' has a wrong offset!");
static_assert(offsetof(UBFGQuestSettings, M_strProgressBonusFormat) == 0x000140, "Member 'UBFGQuestSettings::M_strProgressBonusFormat' has a wrong offset!");
static_assert(offsetof(UBFGQuestSettings, M_strTimeLimitFormat) == 0x000158, "Member 'UBFGQuestSettings::M_strTimeLimitFormat' has a wrong offset!");
static_assert(offsetof(UBFGQuestSettings, M_strPersonalBest) == 0x000170, "Member 'UBFGQuestSettings::M_strPersonalBest' has a wrong offset!");
static_assert(offsetof(UBFGQuestSettings, M_strRewardFormat) == 0x000188, "Member 'UBFGQuestSettings::M_strRewardFormat' has a wrong offset!");
static_assert(offsetof(UBFGQuestSettings, M_aChallengeDefaults) == 0x0001A0, "Member 'UBFGQuestSettings::M_aChallengeDefaults' has a wrong offset!");

// Class BFGCore.BFGRadarObjectInterface
// 0x0000 (0x0028 - 0x0028)
class IBFGRadarObjectInterface final : public IInterface
{
public:
	void ChangeStaticInfo(class UBFGDataAsset_RadarObjectStaticInfo* _pStaticInfo);
	void ChangeStaticInfoOverride(class UBFGDataAsset_RadarObjectStaticInfo* _pStaticInfo);
	void SetEnabled(bool _bEnabled);
	void UnregisterFromManager();

	bool IsEnabled() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"BFGRadarObjectInterface">();
	}
	static class IBFGRadarObjectInterface* GetDefaultObj()
	{
		return GetDefaultObjImpl<IBFGRadarObjectInterface>();
	}
};
static_assert(alignof(IBFGRadarObjectInterface) == 0x000008, "Wrong alignment on IBFGRadarObjectInterface");
static_assert(sizeof(IBFGRadarObjectInterface) == 0x000028, "Wrong size on IBFGRadarObjectInterface");

// Class BFGCore.BFGTaskNode_SetWeaponEquipped
// 0x0058 (0x00D0 - 0x0078)
class UBFGTaskNode_SetWeaponEquipped final : public UBFGBTBaseTaskNode
{
public:
	TSoftClassPtr<class UClass>                   M_pWeaponClass;                                    // 0x0078(0x0028)(Edit, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          M_bEquipDefaultWeaponsInOrder;                     // 0x00A0(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          M_bSetEquipped;                                    // 0x00A1(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          M_bSetAiming;                                      // 0x00A2(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_A3[0x5];                                       // 0x00A3(0x0005)(Fixing Size After Last Property [ Dumper-7 ])
	struct FBlackboardKeySelector                 M_BBKeyAttackTarget;                               // 0x00A8(0x0028)(Edit, BlueprintVisible, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"BFGTaskNode_SetWeaponEquipped">();
	}
	static class UBFGTaskNode_SetWeaponEquipped* GetDefaultObj()
	{
		return GetDefaultObjImpl<UBFGTaskNode_SetWeaponEquipped>();
	}
};
static_assert(alignof(UBFGTaskNode_SetWeaponEquipped) == 0x000008, "Wrong alignment on UBFGTaskNode_SetWeaponEquipped");
static_assert(sizeof(UBFGTaskNode_SetWeaponEquipped) == 0x0000D0, "Wrong size on UBFGTaskNode_SetWeaponEquipped");
static_assert(offsetof(UBFGTaskNode_SetWeaponEquipped, M_pWeaponClass) == 0x000078, "Member 'UBFGTaskNode_SetWeaponEquipped::M_pWeaponClass' has a wrong offset!");
static_assert(offsetof(UBFGTaskNode_SetWeaponEquipped, M_bEquipDefaultWeaponsInOrder) == 0x0000A0, "Member 'UBFGTaskNode_SetWeaponEquipped::M_bEquipDefaultWeaponsInOrder' has a wrong offset!");
static_assert(offsetof(UBFGTaskNode_SetWeaponEquipped, M_bSetEquipped) == 0x0000A1, "Member 'UBFGTaskNode_SetWeaponEquipped::M_bSetEquipped' has a wrong offset!");
static_assert(offsetof(UBFGTaskNode_SetWeaponEquipped, M_bSetAiming) == 0x0000A2, "Member 'UBFGTaskNode_SetWeaponEquipped::M_bSetAiming' has a wrong offset!");
static_assert(offsetof(UBFGTaskNode_SetWeaponEquipped, M_BBKeyAttackTarget) == 0x0000A8, "Member 'UBFGTaskNode_SetWeaponEquipped::M_BBKeyAttackTarget' has a wrong offset!");

// Class BFGCore.BFGWeaponSelectorAbilityHint
// 0x0000 (0x0240 - 0x0240)
class UBFGWeaponSelectorAbilityHint final : public UUserWidget
{
public:
	void EnableLeft();
	void EnableRight();
	void InitializeDataInternal(const struct FBFGAbilityHintInfo& _oData);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"BFGWeaponSelectorAbilityHint">();
	}
	static class UBFGWeaponSelectorAbilityHint* GetDefaultObj()
	{
		return GetDefaultObjImpl<UBFGWeaponSelectorAbilityHint>();
	}
};
static_assert(alignof(UBFGWeaponSelectorAbilityHint) == 0x000008, "Wrong alignment on UBFGWeaponSelectorAbilityHint");
static_assert(sizeof(UBFGWeaponSelectorAbilityHint) == 0x000240, "Wrong size on UBFGWeaponSelectorAbilityHint");

// Class BFGCore.BFGWidget_RadialMenu_OptionIcon
// 0x0000 (0x0240 - 0x0240)
class UBFGWidget_RadialMenu_OptionIcon : public UUserWidget
{
public:
	void SetBrush(const struct FSlateBrush& _oBrush);
	void SetHighlighted(bool _bHighlighted);
	void SetState(bool _bUnlocked, bool _bHighlighted);
	void SetUnlocked(bool _bUnlocked);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"BFGWidget_RadialMenu_OptionIcon">();
	}
	static class UBFGWidget_RadialMenu_OptionIcon* GetDefaultObj()
	{
		return GetDefaultObjImpl<UBFGWidget_RadialMenu_OptionIcon>();
	}
};
static_assert(alignof(UBFGWidget_RadialMenu_OptionIcon) == 0x000008, "Wrong alignment on UBFGWidget_RadialMenu_OptionIcon");
static_assert(sizeof(UBFGWidget_RadialMenu_OptionIcon) == 0x000240, "Wrong size on UBFGWidget_RadialMenu_OptionIcon");

// Class BFGCore.BFGWidget_WeaponSelector_Icon
// 0x00F0 (0x0330 - 0x0240)
class UBFGWidget_WeaponSelector_Icon final : public UBFGWidget_RadialMenu_OptionIcon
{
public:
	struct FBFGPlayerSettingsWeaponInfo           M_oPlayerSettingsWeaponInfo;                       // 0x0240(0x00F0)(ContainsInstancedReference, Protected, NativeAccessSpecifierProtected)

public:
	void SetMaxAmmo(int32 _iMaxAmmo);
	void UpdateAmmo(const struct FBFGAmmunitionInfo& _iAmmunitionInfo);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"BFGWidget_WeaponSelector_Icon">();
	}
	static class UBFGWidget_WeaponSelector_Icon* GetDefaultObj()
	{
		return GetDefaultObjImpl<UBFGWidget_WeaponSelector_Icon>();
	}
};
static_assert(alignof(UBFGWidget_WeaponSelector_Icon) == 0x000008, "Wrong alignment on UBFGWidget_WeaponSelector_Icon");
static_assert(sizeof(UBFGWidget_WeaponSelector_Icon) == 0x000330, "Wrong size on UBFGWidget_WeaponSelector_Icon");
static_assert(offsetof(UBFGWidget_WeaponSelector_Icon, M_oPlayerSettingsWeaponInfo) == 0x000240, "Member 'UBFGWidget_WeaponSelector_Icon::M_oPlayerSettingsWeaponInfo' has a wrong offset!");

// Class BFGCore.BFGRadialMenuUserWidget
// 0x00B8 (0x0330 - 0x0278)
class UBFGRadialMenuUserWidget : public UBFGInputUserWidget
{
public:
	UMulticastDelegateProperty_                   OnClosed;                                          // 0x0278(0x0018)(Edit, ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	class FName                                   ValidateActionName;                                // 0x0290(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FText                                   TitleHintText;                                     // 0x0298(0x0018)(Edit, BlueprintVisible, NativeAccessSpecifierPublic)
	TSubclassOf<class UBFGUI_RadialMenu_Option>   M_contextOptionButton;                             // 0x02B0(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TArray<class UBFGUI_RadialMenu_Option*>       M_apOptions;                                       // 0x02B8(0x0010)(ExportObject, ZeroConstructor, Transient, ContainsInstancedReference, Protected, NativeAccessSpecifierProtected)
	TArray<class UCanvasPanelSlot*>               M_apSlots;                                         // 0x02C8(0x0010)(ExportObject, ZeroConstructor, Transient, ContainsInstancedReference, Protected, NativeAccessSpecifierProtected)
	class UCanvasPanelSlot*                       M_pMarkerCanvasSlot;                               // 0x02D8(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, Transient, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UCanvasPanel*                           M_pLayoutPanel;                                    // 0x02E0(0x0008)(Edit, BlueprintVisible, ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UImage*                                 M_pMarkerImage;                                    // 0x02E8(0x0008)(Edit, BlueprintVisible, ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	int32                                         M_iCurrentSelectedItem;                            // 0x02F0(0x0004)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	int32                                         M_iLastSelectedItem;                               // 0x02F4(0x0004)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TArray<struct FVector2D>                      M_avPositions;                                     // 0x02F8(0x0010)(ZeroConstructor, Transient, Protected, NativeAccessSpecifierProtected)
	float                                         M_fLeftX;                                          // 0x0308(0x0004)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         M_fLeftY;                                          // 0x030C(0x0004)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         M_fMarkerRadius;                                   // 0x0310(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	struct FVector2D                              M_fScaleVector;                                    // 0x0314(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	struct FVector2D                              M_vOffset;                                         // 0x031C(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         M_fOptionsRadius;                                  // 0x0324(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          M_bHandlingMouse;                                  // 0x0328(0x0001)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          M_bTrackAxisMove;                                  // 0x0329(0x0001)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_32A[0x6];                                      // 0x032A(0x0006)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void Action__DelegateSignature(class UBFGRadialMenuUserWidget* _pMenu);
	void AddOption(class UBFGUI_RadialMenu_Option* _pOption);
	class UBFGUI_RadialMenu_Option* CreateOption(const class FText& _strText, const class FText& _strTooltip, const class FText& _strDescription, class UObject* _pObject);
	void ExecuteAction(class UBFGUI_RadialMenu_Option* _pOption);
	TArray<class UBFGUI_RadialMenu_Option*> GetOptions();
	int32 GetSelectedElement();
	class UBFGUI_RadialMenu_Option* GetSelectedElementOption();
	void MoveMarkerHorizontal(float _fValue);
	void MoveMarkerVertical(float _fValue);
	void OnShowWeaponInformation(class UBFGUI_RadialMenu_Option* _pOption, bool _bShow);
	void ResetContent();
	void SetCurrentSelectedItem(int32 _iSelected);
	void TriggerExecuteAction();
	void TriggerExecuteAction_Item1();
	void TriggerExecuteAction_Item2();
	void TriggerExecuteAction_Item3();
	void TriggerExecuteAction_Item4();
	void TriggerExecuteAction_ItemRelease();

	int32 GetCurrentSelectedItem() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"BFGRadialMenuUserWidget">();
	}
	static class UBFGRadialMenuUserWidget* GetDefaultObj()
	{
		return GetDefaultObjImpl<UBFGRadialMenuUserWidget>();
	}
};
static_assert(alignof(UBFGRadialMenuUserWidget) == 0x000008, "Wrong alignment on UBFGRadialMenuUserWidget");
static_assert(sizeof(UBFGRadialMenuUserWidget) == 0x000330, "Wrong size on UBFGRadialMenuUserWidget");
static_assert(offsetof(UBFGRadialMenuUserWidget, OnClosed) == 0x000278, "Member 'UBFGRadialMenuUserWidget::OnClosed' has a wrong offset!");
static_assert(offsetof(UBFGRadialMenuUserWidget, ValidateActionName) == 0x000290, "Member 'UBFGRadialMenuUserWidget::ValidateActionName' has a wrong offset!");
static_assert(offsetof(UBFGRadialMenuUserWidget, TitleHintText) == 0x000298, "Member 'UBFGRadialMenuUserWidget::TitleHintText' has a wrong offset!");
static_assert(offsetof(UBFGRadialMenuUserWidget, M_contextOptionButton) == 0x0002B0, "Member 'UBFGRadialMenuUserWidget::M_contextOptionButton' has a wrong offset!");
static_assert(offsetof(UBFGRadialMenuUserWidget, M_apOptions) == 0x0002B8, "Member 'UBFGRadialMenuUserWidget::M_apOptions' has a wrong offset!");
static_assert(offsetof(UBFGRadialMenuUserWidget, M_apSlots) == 0x0002C8, "Member 'UBFGRadialMenuUserWidget::M_apSlots' has a wrong offset!");
static_assert(offsetof(UBFGRadialMenuUserWidget, M_pMarkerCanvasSlot) == 0x0002D8, "Member 'UBFGRadialMenuUserWidget::M_pMarkerCanvasSlot' has a wrong offset!");
static_assert(offsetof(UBFGRadialMenuUserWidget, M_pLayoutPanel) == 0x0002E0, "Member 'UBFGRadialMenuUserWidget::M_pLayoutPanel' has a wrong offset!");
static_assert(offsetof(UBFGRadialMenuUserWidget, M_pMarkerImage) == 0x0002E8, "Member 'UBFGRadialMenuUserWidget::M_pMarkerImage' has a wrong offset!");
static_assert(offsetof(UBFGRadialMenuUserWidget, M_iCurrentSelectedItem) == 0x0002F0, "Member 'UBFGRadialMenuUserWidget::M_iCurrentSelectedItem' has a wrong offset!");
static_assert(offsetof(UBFGRadialMenuUserWidget, M_iLastSelectedItem) == 0x0002F4, "Member 'UBFGRadialMenuUserWidget::M_iLastSelectedItem' has a wrong offset!");
static_assert(offsetof(UBFGRadialMenuUserWidget, M_avPositions) == 0x0002F8, "Member 'UBFGRadialMenuUserWidget::M_avPositions' has a wrong offset!");
static_assert(offsetof(UBFGRadialMenuUserWidget, M_fLeftX) == 0x000308, "Member 'UBFGRadialMenuUserWidget::M_fLeftX' has a wrong offset!");
static_assert(offsetof(UBFGRadialMenuUserWidget, M_fLeftY) == 0x00030C, "Member 'UBFGRadialMenuUserWidget::M_fLeftY' has a wrong offset!");
static_assert(offsetof(UBFGRadialMenuUserWidget, M_fMarkerRadius) == 0x000310, "Member 'UBFGRadialMenuUserWidget::M_fMarkerRadius' has a wrong offset!");
static_assert(offsetof(UBFGRadialMenuUserWidget, M_fScaleVector) == 0x000314, "Member 'UBFGRadialMenuUserWidget::M_fScaleVector' has a wrong offset!");
static_assert(offsetof(UBFGRadialMenuUserWidget, M_vOffset) == 0x00031C, "Member 'UBFGRadialMenuUserWidget::M_vOffset' has a wrong offset!");
static_assert(offsetof(UBFGRadialMenuUserWidget, M_fOptionsRadius) == 0x000324, "Member 'UBFGRadialMenuUserWidget::M_fOptionsRadius' has a wrong offset!");
static_assert(offsetof(UBFGRadialMenuUserWidget, M_bHandlingMouse) == 0x000328, "Member 'UBFGRadialMenuUserWidget::M_bHandlingMouse' has a wrong offset!");
static_assert(offsetof(UBFGRadialMenuUserWidget, M_bTrackAxisMove) == 0x000329, "Member 'UBFGRadialMenuUserWidget::M_bTrackAxisMove' has a wrong offset!");

// Class BFGCore.BFGTaskNode_StartGlobalCooldown
// 0x0030 (0x00A8 - 0x0078)
class UBFGTaskNode_StartGlobalCooldown final : public UBFGBTBaseTaskNode
{
public:
	struct FBlackboardKeySelector                 M_BBKeyAttackTarget;                               // 0x0078(0x0028)(Edit, Protected, NativeAccessSpecifierProtected)
	EBFGGlobalCooldown                            M_cooldown;                                        // 0x00A0(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_A1[0x7];                                       // 0x00A1(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"BFGTaskNode_StartGlobalCooldown">();
	}
	static class UBFGTaskNode_StartGlobalCooldown* GetDefaultObj()
	{
		return GetDefaultObjImpl<UBFGTaskNode_StartGlobalCooldown>();
	}
};
static_assert(alignof(UBFGTaskNode_StartGlobalCooldown) == 0x000008, "Wrong alignment on UBFGTaskNode_StartGlobalCooldown");
static_assert(sizeof(UBFGTaskNode_StartGlobalCooldown) == 0x0000A8, "Wrong size on UBFGTaskNode_StartGlobalCooldown");
static_assert(offsetof(UBFGTaskNode_StartGlobalCooldown, M_BBKeyAttackTarget) == 0x000078, "Member 'UBFGTaskNode_StartGlobalCooldown::M_BBKeyAttackTarget' has a wrong offset!");
static_assert(offsetof(UBFGTaskNode_StartGlobalCooldown, M_cooldown) == 0x0000A0, "Member 'UBFGTaskNode_StartGlobalCooldown::M_cooldown' has a wrong offset!");

// Class BFGCore.BFGRadialMenu_WeaponSelector
// 0x0158 (0x0488 - 0x0330)
class UBFGRadialMenu_WeaponSelector : public UBFGRadialMenuUserWidget
{
public:
	TSoftClassPtr<class UClass>                   M_pAbilityHintWidgetClass;                         // 0x0330(0x0028)(Edit, BlueprintVisible, BlueprintReadOnly, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TArray<struct FBFGAbilityHintInfo>            M_aoAbilityInfoLeft;                               // 0x0358(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Protected, NativeAccessSpecifierProtected)
	TArray<struct FBFGAbilityHintInfo>            M_aoAbilityInfoRight;                              // 0x0368(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Protected, NativeAccessSpecifierProtected)
	struct FSlateBrush                            M_oBrushSelectionWheelBG;                          // 0x0378(0x0088)(Edit, BlueprintVisible, BlueprintReadOnly, Protected, NativeAccessSpecifierProtected)
	struct FSlateBrush                            M_oBrushSelectionWheelCursor;                      // 0x0400(0x0088)(Edit, BlueprintVisible, BlueprintReadOnly, Protected, NativeAccessSpecifierProtected)

public:
	void AddHintToLeftWing(class UBFGWeaponSelectorAbilityHint* _pHint, float _fAnchorVertical, float _fAnchorHorizontal);
	void AddHintToRightWing(class UBFGWeaponSelectorAbilityHint* _pHint, float _fAnchorVertical, float _fAnchorHorizontal);
	void ClearAbilityHints();
	void SetSelectionWheelBGImage(const struct FSlateBrush& _image);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"BFGRadialMenu_WeaponSelector">();
	}
	static class UBFGRadialMenu_WeaponSelector* GetDefaultObj()
	{
		return GetDefaultObjImpl<UBFGRadialMenu_WeaponSelector>();
	}
};
static_assert(alignof(UBFGRadialMenu_WeaponSelector) == 0x000008, "Wrong alignment on UBFGRadialMenu_WeaponSelector");
static_assert(sizeof(UBFGRadialMenu_WeaponSelector) == 0x000488, "Wrong size on UBFGRadialMenu_WeaponSelector");
static_assert(offsetof(UBFGRadialMenu_WeaponSelector, M_pAbilityHintWidgetClass) == 0x000330, "Member 'UBFGRadialMenu_WeaponSelector::M_pAbilityHintWidgetClass' has a wrong offset!");
static_assert(offsetof(UBFGRadialMenu_WeaponSelector, M_aoAbilityInfoLeft) == 0x000358, "Member 'UBFGRadialMenu_WeaponSelector::M_aoAbilityInfoLeft' has a wrong offset!");
static_assert(offsetof(UBFGRadialMenu_WeaponSelector, M_aoAbilityInfoRight) == 0x000368, "Member 'UBFGRadialMenu_WeaponSelector::M_aoAbilityInfoRight' has a wrong offset!");
static_assert(offsetof(UBFGRadialMenu_WeaponSelector, M_oBrushSelectionWheelBG) == 0x000378, "Member 'UBFGRadialMenu_WeaponSelector::M_oBrushSelectionWheelBG' has a wrong offset!");
static_assert(offsetof(UBFGRadialMenu_WeaponSelector, M_oBrushSelectionWheelCursor) == 0x000400, "Member 'UBFGRadialMenu_WeaponSelector::M_oBrushSelectionWheelCursor' has a wrong offset!");

// Class BFGCore.BFGReadTextureActor
// 0x0060 (0x0438 - 0x03D8)
class ABFGReadTextureActor final : public AActor
{
public:
	TSoftObjectPtr<class UTexture2D>              M_pTextureSoftPtr;                                 // 0x03D8(0x0028)(Edit, BlueprintVisible, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UTexture2D*                             M_pTexture;                                        // 0x0400(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class AActor*                                 M_pActorToUVTrace;                                 // 0x0408(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TArray<uint8>                                 M_aTextureArray;                                   // 0x0410(0x0010)(ZeroConstructor, NativeAccessSpecifierPrivate)
	uint32                                        M_iTextureSizeX;                                   // 0x0420(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint32                                        M_iTextureSizeY;                                   // 0x0424(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	struct FVector2D                              M_vUVGizmoMin;                                     // 0x0428(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	struct FVector2D                              M_vUVGizmoMax;                                     // 0x0430(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)

public:
	struct FVector2D CalculateUVFromWorldPosition(const struct FVector& _vWorldPos);
	uint8 GetTextureValue(const struct FVector& _vWorldPos);
	void GetTraceObjExtent(struct FVector* _vOrigin, struct FVector* _vBoxExtent);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"BFGReadTextureActor">();
	}
	static class ABFGReadTextureActor* GetDefaultObj()
	{
		return GetDefaultObjImpl<ABFGReadTextureActor>();
	}
};
static_assert(alignof(ABFGReadTextureActor) == 0x000008, "Wrong alignment on ABFGReadTextureActor");
static_assert(sizeof(ABFGReadTextureActor) == 0x000438, "Wrong size on ABFGReadTextureActor");
static_assert(offsetof(ABFGReadTextureActor, M_pTextureSoftPtr) == 0x0003D8, "Member 'ABFGReadTextureActor::M_pTextureSoftPtr' has a wrong offset!");
static_assert(offsetof(ABFGReadTextureActor, M_pTexture) == 0x000400, "Member 'ABFGReadTextureActor::M_pTexture' has a wrong offset!");
static_assert(offsetof(ABFGReadTextureActor, M_pActorToUVTrace) == 0x000408, "Member 'ABFGReadTextureActor::M_pActorToUVTrace' has a wrong offset!");
static_assert(offsetof(ABFGReadTextureActor, M_aTextureArray) == 0x000410, "Member 'ABFGReadTextureActor::M_aTextureArray' has a wrong offset!");
static_assert(offsetof(ABFGReadTextureActor, M_iTextureSizeX) == 0x000420, "Member 'ABFGReadTextureActor::M_iTextureSizeX' has a wrong offset!");
static_assert(offsetof(ABFGReadTextureActor, M_iTextureSizeY) == 0x000424, "Member 'ABFGReadTextureActor::M_iTextureSizeY' has a wrong offset!");
static_assert(offsetof(ABFGReadTextureActor, M_vUVGizmoMin) == 0x000428, "Member 'ABFGReadTextureActor::M_vUVGizmoMin' has a wrong offset!");
static_assert(offsetof(ABFGReadTextureActor, M_vUVGizmoMax) == 0x000430, "Member 'ABFGReadTextureActor::M_vUVGizmoMax' has a wrong offset!");

// Class BFGCore.BFGReadTextureManager
// 0x0010 (0x0040 - 0x0030)
class UBFGReadTextureManager final : public UBFGGameSystem
{
public:
	class ABFGGameState*                          M_pGameState;                                      // 0x0030(0x0008)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class ABFGReadTextureActor*                   M_pActor;                                          // 0x0038(0x0008)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)

public:
	class ABFGReadTextureActor* GetReadTextureActor() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"BFGReadTextureManager">();
	}
	static class UBFGReadTextureManager* GetDefaultObj()
	{
		return GetDefaultObjImpl<UBFGReadTextureManager>();
	}
};
static_assert(alignof(UBFGReadTextureManager) == 0x000008, "Wrong alignment on UBFGReadTextureManager");
static_assert(sizeof(UBFGReadTextureManager) == 0x000040, "Wrong size on UBFGReadTextureManager");
static_assert(offsetof(UBFGReadTextureManager, M_pGameState) == 0x000030, "Member 'UBFGReadTextureManager::M_pGameState' has a wrong offset!");
static_assert(offsetof(UBFGReadTextureManager, M_pActor) == 0x000038, "Member 'UBFGReadTextureManager::M_pActor' has a wrong offset!");

// Class BFGCore.BFGRestrictedArea
// 0x00E8 (0x0680 - 0x0598)
class ABFGRestrictedArea final : public ABFGMissionCustomTriggerZone
{
public:
	class UBFGActorComponent_RadarObject_RestrictedArea* M_pRadarMarker;                                    // 0x0598(0x0008)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, EditConst, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TArray<struct FBFGActorBinding>               M_aDisguiseWhitelist;                              // 0x05A0(0x0010)(Edit, ZeroConstructor, Protected, NativeAccessSpecifierProtected)
	TArray<struct FBFGActorBinding>               M_aAllowedResponders;                              // 0x05B0(0x0010)(Edit, ZeroConstructor, Protected, NativeAccessSpecifierProtected)
	TArray<class UBFGMissionConsequence*>         M_apDetectedDefaults;                              // 0x05C0(0x0010)(Edit, ExportObject, ZeroConstructor, ContainsInstancedReference, Protected, NativeAccessSpecifierProtected)
	TArray<class UBFGMissionConsequence*>         M_apInsideDefaults;                                // 0x05D0(0x0010)(Edit, ExportObject, ZeroConstructor, ContainsInstancedReference, Protected, NativeAccessSpecifierProtected)
	float                                         M_fGracePeriod;                                    // 0x05E0(0x0004)(Edit, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         M_fConsequenceDelayInside;                         // 0x05E4(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         M_fConsequenceDelayDetected;                       // 0x05E8(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_5EC[0x4];                                      // 0x05EC(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<class AActor*>                         M_apViolators;                                     // 0x05F0(0x0010)(ZeroConstructor, Transient, Protected, NativeAccessSpecifierProtected)
	class UBFGMissionConsequenceCollection*       M_pDetectedCollection;                             // 0x0600(0x0008)(ExportObject, ZeroConstructor, Transient, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TArray<class UBFGMissionConsequenceRequest*>  M_apDetectedRequests;                              // 0x0608(0x0010)(ZeroConstructor, Transient, Protected, NativeAccessSpecifierProtected)
	class UBFGMissionConsequenceCollection*       M_pInsideCollection;                               // 0x0618(0x0008)(ExportObject, ZeroConstructor, Transient, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TArray<class UBFGMissionConsequenceRequest*>  M_apInsideRequests;                                // 0x0620(0x0010)(ZeroConstructor, Transient, Protected, NativeAccessSpecifierProtected)
	TMap<class AActor*, float>                    M_afOverlapTimestamps;                             // 0x0630(0x0050)(ZeroConstructor, Transient, Protected, NativeAccessSpecifierProtected)

public:
	const TArray<class AActor*> GetViolators() const;
	bool IsInsideArea(class AActor* _pActor) const;
	bool IsViolator(class AActor* _pActor) const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"BFGRestrictedArea">();
	}
	static class ABFGRestrictedArea* GetDefaultObj()
	{
		return GetDefaultObjImpl<ABFGRestrictedArea>();
	}
};
static_assert(alignof(ABFGRestrictedArea) == 0x000008, "Wrong alignment on ABFGRestrictedArea");
static_assert(sizeof(ABFGRestrictedArea) == 0x000680, "Wrong size on ABFGRestrictedArea");
static_assert(offsetof(ABFGRestrictedArea, M_pRadarMarker) == 0x000598, "Member 'ABFGRestrictedArea::M_pRadarMarker' has a wrong offset!");
static_assert(offsetof(ABFGRestrictedArea, M_aDisguiseWhitelist) == 0x0005A0, "Member 'ABFGRestrictedArea::M_aDisguiseWhitelist' has a wrong offset!");
static_assert(offsetof(ABFGRestrictedArea, M_aAllowedResponders) == 0x0005B0, "Member 'ABFGRestrictedArea::M_aAllowedResponders' has a wrong offset!");
static_assert(offsetof(ABFGRestrictedArea, M_apDetectedDefaults) == 0x0005C0, "Member 'ABFGRestrictedArea::M_apDetectedDefaults' has a wrong offset!");
static_assert(offsetof(ABFGRestrictedArea, M_apInsideDefaults) == 0x0005D0, "Member 'ABFGRestrictedArea::M_apInsideDefaults' has a wrong offset!");
static_assert(offsetof(ABFGRestrictedArea, M_fGracePeriod) == 0x0005E0, "Member 'ABFGRestrictedArea::M_fGracePeriod' has a wrong offset!");
static_assert(offsetof(ABFGRestrictedArea, M_fConsequenceDelayInside) == 0x0005E4, "Member 'ABFGRestrictedArea::M_fConsequenceDelayInside' has a wrong offset!");
static_assert(offsetof(ABFGRestrictedArea, M_fConsequenceDelayDetected) == 0x0005E8, "Member 'ABFGRestrictedArea::M_fConsequenceDelayDetected' has a wrong offset!");
static_assert(offsetof(ABFGRestrictedArea, M_apViolators) == 0x0005F0, "Member 'ABFGRestrictedArea::M_apViolators' has a wrong offset!");
static_assert(offsetof(ABFGRestrictedArea, M_pDetectedCollection) == 0x000600, "Member 'ABFGRestrictedArea::M_pDetectedCollection' has a wrong offset!");
static_assert(offsetof(ABFGRestrictedArea, M_apDetectedRequests) == 0x000608, "Member 'ABFGRestrictedArea::M_apDetectedRequests' has a wrong offset!");
static_assert(offsetof(ABFGRestrictedArea, M_pInsideCollection) == 0x000618, "Member 'ABFGRestrictedArea::M_pInsideCollection' has a wrong offset!");
static_assert(offsetof(ABFGRestrictedArea, M_apInsideRequests) == 0x000620, "Member 'ABFGRestrictedArea::M_apInsideRequests' has a wrong offset!");
static_assert(offsetof(ABFGRestrictedArea, M_afOverlapTimestamps) == 0x000630, "Member 'ABFGRestrictedArea::M_afOverlapTimestamps' has a wrong offset!");

// Class BFGCore.BFGRichTextBlockDecorator_RebindableKeyboardButton
// 0x0098 (0x00C8 - 0x0030)
class UBFGRichTextBlockDecorator_RebindableKeyboardButton final : public URichTextBlockImageDecorator
{
public:
	EInputSchemeIdentifier                        M_eInputSchemeIdentifier;                          // 0x0030(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_31[0x7];                                       // 0x0031(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	struct FSlateBrush                            M_missingTexture;                                  // 0x0038(0x0088)(Edit, Protected, NativeAccessSpecifierProtected)
	TWeakObjectPtr<class URichTextBlock>          M_pOwner;                                          // 0x00C0(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"BFGRichTextBlockDecorator_RebindableKeyboardButton">();
	}
	static class UBFGRichTextBlockDecorator_RebindableKeyboardButton* GetDefaultObj()
	{
		return GetDefaultObjImpl<UBFGRichTextBlockDecorator_RebindableKeyboardButton>();
	}
};
static_assert(alignof(UBFGRichTextBlockDecorator_RebindableKeyboardButton) == 0x000008, "Wrong alignment on UBFGRichTextBlockDecorator_RebindableKeyboardButton");
static_assert(sizeof(UBFGRichTextBlockDecorator_RebindableKeyboardButton) == 0x0000C8, "Wrong size on UBFGRichTextBlockDecorator_RebindableKeyboardButton");
static_assert(offsetof(UBFGRichTextBlockDecorator_RebindableKeyboardButton, M_eInputSchemeIdentifier) == 0x000030, "Member 'UBFGRichTextBlockDecorator_RebindableKeyboardButton::M_eInputSchemeIdentifier' has a wrong offset!");
static_assert(offsetof(UBFGRichTextBlockDecorator_RebindableKeyboardButton, M_missingTexture) == 0x000038, "Member 'UBFGRichTextBlockDecorator_RebindableKeyboardButton::M_missingTexture' has a wrong offset!");
static_assert(offsetof(UBFGRichTextBlockDecorator_RebindableKeyboardButton, M_pOwner) == 0x0000C0, "Member 'UBFGRichTextBlockDecorator_RebindableKeyboardButton::M_pOwner' has a wrong offset!");

// Class BFGCore.BFGSaveContext
// 0x02D0 (0x02F8 - 0x0028)
class UBFGSaveContext final : public UObject
{
public:
	uint8                                         Pad_28[0x20];                                      // 0x0028(0x0020)(Fixing Size After Last Property [ Dumper-7 ])
	class ABFGUFOLandingSite*                     M_pLandingSite;                                    // 0x0048(0x0008)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TMap<struct FSoftObjectPath, TSoftObjectPtr<class AActor>> M_aSoftActors;                                     // 0x0050(0x0050)(ZeroConstructor, Transient, Protected, UObjectWrapper, NativeAccessSpecifierProtected)
	struct FBFGSaveGame_ActorData                 M_previousActorData;                               // 0x00A0(0x0258)(Transient, Protected, NativeAccessSpecifierProtected)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"BFGSaveContext">();
	}
	static class UBFGSaveContext* GetDefaultObj()
	{
		return GetDefaultObjImpl<UBFGSaveContext>();
	}
};
static_assert(alignof(UBFGSaveContext) == 0x000008, "Wrong alignment on UBFGSaveContext");
static_assert(sizeof(UBFGSaveContext) == 0x0002F8, "Wrong size on UBFGSaveContext");
static_assert(offsetof(UBFGSaveContext, M_pLandingSite) == 0x000048, "Member 'UBFGSaveContext::M_pLandingSite' has a wrong offset!");
static_assert(offsetof(UBFGSaveContext, M_aSoftActors) == 0x000050, "Member 'UBFGSaveContext::M_aSoftActors' has a wrong offset!");
static_assert(offsetof(UBFGSaveContext, M_previousActorData) == 0x0000A0, "Member 'UBFGSaveContext::M_previousActorData' has a wrong offset!");

// Class BFGCore.BFGTaskNode_Boss_EvasionStart
// 0x0038 (0x00D8 - 0x00A0)
class UBFGTaskNode_Boss_EvasionStart final : public UBFGTaskNode_BossBase
{
public:
	struct FBlackboardKeySelector                 M_BBKeyEvasionLocation;                            // 0x00A0(0x0028)(Edit, BlueprintVisible, NativeAccessSpecifierPublic)
	struct FVector                                M_vEvasionLocation;                                // 0x00C8(0x000C)(ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_D4[0x4];                                       // 0x00D4(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"BFGTaskNode_Boss_EvasionStart">();
	}
	static class UBFGTaskNode_Boss_EvasionStart* GetDefaultObj()
	{
		return GetDefaultObjImpl<UBFGTaskNode_Boss_EvasionStart>();
	}
};
static_assert(alignof(UBFGTaskNode_Boss_EvasionStart) == 0x000008, "Wrong alignment on UBFGTaskNode_Boss_EvasionStart");
static_assert(sizeof(UBFGTaskNode_Boss_EvasionStart) == 0x0000D8, "Wrong size on UBFGTaskNode_Boss_EvasionStart");
static_assert(offsetof(UBFGTaskNode_Boss_EvasionStart, M_BBKeyEvasionLocation) == 0x0000A0, "Member 'UBFGTaskNode_Boss_EvasionStart::M_BBKeyEvasionLocation' has a wrong offset!");
static_assert(offsetof(UBFGTaskNode_Boss_EvasionStart, M_vEvasionLocation) == 0x0000C8, "Member 'UBFGTaskNode_Boss_EvasionStart::M_vEvasionLocation' has a wrong offset!");

// Class BFGCore.BFGSaveDataCache
// 0x0080 (0x00A8 - 0x0028)
class UBFGSaveDataCache final : public UObject
{
public:
	uint8                                         Pad_28[0x8];                                       // 0x0028(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	struct FBFGSaveDescription                    M_description;                                     // 0x0030(0x0070)(Transient, Protected, NativeAccessSpecifierProtected)
	class UBFGSaveGame*                           M_pData;                                           // 0x00A0(0x0008)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"BFGSaveDataCache">();
	}
	static class UBFGSaveDataCache* GetDefaultObj()
	{
		return GetDefaultObjImpl<UBFGSaveDataCache>();
	}
};
static_assert(alignof(UBFGSaveDataCache) == 0x000008, "Wrong alignment on UBFGSaveDataCache");
static_assert(sizeof(UBFGSaveDataCache) == 0x0000A8, "Wrong size on UBFGSaveDataCache");
static_assert(offsetof(UBFGSaveDataCache, M_description) == 0x000030, "Member 'UBFGSaveDataCache::M_description' has a wrong offset!");
static_assert(offsetof(UBFGSaveDataCache, M_pData) == 0x0000A0, "Member 'UBFGSaveDataCache::M_pData' has a wrong offset!");

// Class BFGCore.BFGSaveGame
// 0x08F8 (0x0920 - 0x0028)
class UBFGSaveGame final : public USaveGame
{
public:
	int32                                         M_iVersion;                                        // 0x0028(0x0004)(ZeroConstructor, SaveGame, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2C[0x4];                                       // 0x002C(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	struct FBFGSaveGame_SystemData                M_systemData;                                      // 0x0030(0x0408)(SaveGame, NativeAccessSpecifierPublic)
	uint8                                         Pad_438[0x8];                                      // 0x0438(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	struct FBFGSaveGame_PlayerData                M_playerData;                                      // 0x0440(0x0200)(SaveGame, NativeAccessSpecifierPublic)
	struct FBFGSaveGame_ActorData                 M_actorData;                                       // 0x0640(0x0258)(SaveGame, NativeAccessSpecifierPublic)
	struct FBFGSaveDescription                    M_description;                                     // 0x0898(0x0070)(SaveGame, NativeAccessSpecifierPublic)
	int32                                         M_iUserIndex;                                      // 0x0908(0x0004)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_90C[0x4];                                      // 0x090C(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class FString                                 M_strSaveGameFilename;                             // 0x0910(0x0010)(ZeroConstructor, Transient, HasGetValueTypeHash, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"BFGSaveGame">();
	}
	static class UBFGSaveGame* GetDefaultObj()
	{
		return GetDefaultObjImpl<UBFGSaveGame>();
	}
};
static_assert(alignof(UBFGSaveGame) == 0x000010, "Wrong alignment on UBFGSaveGame");
static_assert(sizeof(UBFGSaveGame) == 0x000920, "Wrong size on UBFGSaveGame");
static_assert(offsetof(UBFGSaveGame, M_iVersion) == 0x000028, "Member 'UBFGSaveGame::M_iVersion' has a wrong offset!");
static_assert(offsetof(UBFGSaveGame, M_systemData) == 0x000030, "Member 'UBFGSaveGame::M_systemData' has a wrong offset!");
static_assert(offsetof(UBFGSaveGame, M_playerData) == 0x000440, "Member 'UBFGSaveGame::M_playerData' has a wrong offset!");
static_assert(offsetof(UBFGSaveGame, M_actorData) == 0x000640, "Member 'UBFGSaveGame::M_actorData' has a wrong offset!");
static_assert(offsetof(UBFGSaveGame, M_description) == 0x000898, "Member 'UBFGSaveGame::M_description' has a wrong offset!");
static_assert(offsetof(UBFGSaveGame, M_iUserIndex) == 0x000908, "Member 'UBFGSaveGame::M_iUserIndex' has a wrong offset!");
static_assert(offsetof(UBFGSaveGame, M_strSaveGameFilename) == 0x000910, "Member 'UBFGSaveGame::M_strSaveGameFilename' has a wrong offset!");

// Class BFGCore.BFGSaveOptions
// 0x0108 (0x0130 - 0x0028)
class UBFGSaveOptions final : public USaveGame
{
public:
	UMulticastDelegateProperty_                   M_InputPackChanged;                                // 0x0028(0x0018)(ZeroConstructor, Transient, InstancedReference, BlueprintAssignable, BlueprintCallable, NativeAccessSpecifierPublic)
	int32                                         M_iUserIndex;                                      // 0x0040(0x0004)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_44[0x4];                                       // 0x0044(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class FString                                 M_strLastUsedSavegame;                             // 0x0048(0x0010)(ZeroConstructor, SaveGame, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	int32                                         M_iInputPackIndex;                                 // 0x0058(0x0004)(ZeroConstructor, SaveGame, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          M_bInvertYAimingAxis;                              // 0x005C(0x0001)(ZeroConstructor, SaveGame, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          M_bInvertYAimingAxisMouse;                         // 0x005D(0x0001)(ZeroConstructor, SaveGame, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          M_bEnableLockOn;                                   // 0x005E(0x0001)(ZeroConstructor, SaveGame, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          M_bHoldToFocusMode;                                // 0x005F(0x0001)(ZeroConstructor, SaveGame, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         M_fCryptoMouseSensitivity_V2;                      // 0x0060(0x0004)(ZeroConstructor, SaveGame, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         M_fUFOMouseSensitivity_V2;                         // 0x0064(0x0004)(ZeroConstructor, SaveGame, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         M_fCryptoGamepadSensitivity_V2;                    // 0x0068(0x0004)(ZeroConstructor, SaveGame, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         M_fUFOGamepadSensitivity_V2;                       // 0x006C(0x0004)(ZeroConstructor, SaveGame, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	int32                                         M_iCurrentInputRebindingsVersion;                  // 0x0070(0x0004)(ZeroConstructor, SaveGame, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_74[0x4];                                       // 0x0074(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<struct FBFGInputRebinding>             M_aCurrentInputRebinding;                          // 0x0078(0x0010)(ZeroConstructor, SaveGame, Protected, NativeAccessSpecifierProtected)
	float                                         M_fGamma;                                          // 0x0088(0x0004)(ZeroConstructor, SaveGame, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         M_fVolumeMaster;                                   // 0x008C(0x0004)(ZeroConstructor, SaveGame, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         M_fVolumeMusic;                                    // 0x0090(0x0004)(ZeroConstructor, SaveGame, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         M_fVolumeSFX;                                      // 0x0094(0x0004)(ZeroConstructor, SaveGame, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         M_fVolumeVoices;                                   // 0x0098(0x0004)(ZeroConstructor, SaveGame, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         M_fVolumeUI;                                       // 0x009C(0x0004)(ZeroConstructor, SaveGame, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          M_bEnable3DSound;                                  // 0x00A0(0x0001)(ZeroConstructor, SaveGame, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          M_bEnableSubtitles;                                // 0x00A1(0x0001)(ZeroConstructor, SaveGame, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          M_bEnableMuteInBackground;                         // 0x00A2(0x0001)(ZeroConstructor, SaveGame, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_A3[0x1];                                       // 0x00A3(0x0001)(Fixing Size After Last Property [ Dumper-7 ])
	int32                                         M_iFullscreenMode;                                 // 0x00A4(0x0004)(ZeroConstructor, SaveGame, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	struct FIntPoint                              M_vResolution;                                     // 0x00A8(0x0008)(ZeroConstructor, SaveGame, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          M_bVSyncEnabled;                                   // 0x00B0(0x0001)(ZeroConstructor, SaveGame, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_B1[0x3];                                       // 0x00B1(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	int32                                         M_iViewDistanceQuality;                            // 0x00B4(0x0004)(ZeroConstructor, SaveGame, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	int32                                         M_iAAQuality;                                      // 0x00B8(0x0004)(ZeroConstructor, SaveGame, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	int32                                         M_iPostProcessingQuality;                          // 0x00BC(0x0004)(ZeroConstructor, SaveGame, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	int32                                         M_iShadowQuality;                                  // 0x00C0(0x0004)(ZeroConstructor, SaveGame, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	int32                                         M_iTextureQuality;                                 // 0x00C4(0x0004)(ZeroConstructor, SaveGame, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	int32                                         M_iVFXQuality;                                     // 0x00C8(0x0004)(ZeroConstructor, SaveGame, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	int32                                         M_iFoliageQuality;                                 // 0x00CC(0x0004)(ZeroConstructor, SaveGame, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	int32                                         M_iMaxFPS;                                         // 0x00D0(0x0004)(ZeroConstructor, SaveGame, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	int32                                         M_iLandscapeQuality;                               // 0x00D4(0x0004)(ZeroConstructor, SaveGame, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class FString                                 M_strCultureName;                                  // 0x00D8(0x0010)(ZeroConstructor, SaveGame, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class FName                                   M_oCultureName;                                    // 0x00E8(0x0008)(ZeroConstructor, SaveGame, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         M_bEnableVibration;                                // 0x00F0(0x0004)(ZeroConstructor, SaveGame, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          M_bEnableTutorials;                                // 0x00F4(0x0001)(ZeroConstructor, SaveGame, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_F5[0x3];                                       // 0x00F5(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<struct FBFGAchievementsAwait>          M_aUnlockedAchievementsAwaitingRetry;              // 0x00F8(0x0010)(ZeroConstructor, SaveGame, Protected, NativeAccessSpecifierProtected)
	struct FGameplayTagContainer                  M_profileUnlockTags;                               // 0x0108(0x0020)(SaveGame, Protected, NativeAccessSpecifierProtected)
	bool                                          M_bGiftNotificationViewed;                         // 0x0128(0x0001)(ZeroConstructor, SaveGame, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          M_bFebruaryGiftNotificationViewed;                 // 0x0129(0x0001)(ZeroConstructor, SaveGame, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          M_bHasSeenOnNextGen;                               // 0x012A(0x0001)(ZeroConstructor, SaveGame, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_12B[0x5];                                      // 0x012B(0x0005)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"BFGSaveOptions">();
	}
	static class UBFGSaveOptions* GetDefaultObj()
	{
		return GetDefaultObjImpl<UBFGSaveOptions>();
	}
};
static_assert(alignof(UBFGSaveOptions) == 0x000008, "Wrong alignment on UBFGSaveOptions");
static_assert(sizeof(UBFGSaveOptions) == 0x000130, "Wrong size on UBFGSaveOptions");
static_assert(offsetof(UBFGSaveOptions, M_InputPackChanged) == 0x000028, "Member 'UBFGSaveOptions::M_InputPackChanged' has a wrong offset!");
static_assert(offsetof(UBFGSaveOptions, M_iUserIndex) == 0x000040, "Member 'UBFGSaveOptions::M_iUserIndex' has a wrong offset!");
static_assert(offsetof(UBFGSaveOptions, M_strLastUsedSavegame) == 0x000048, "Member 'UBFGSaveOptions::M_strLastUsedSavegame' has a wrong offset!");
static_assert(offsetof(UBFGSaveOptions, M_iInputPackIndex) == 0x000058, "Member 'UBFGSaveOptions::M_iInputPackIndex' has a wrong offset!");
static_assert(offsetof(UBFGSaveOptions, M_bInvertYAimingAxis) == 0x00005C, "Member 'UBFGSaveOptions::M_bInvertYAimingAxis' has a wrong offset!");
static_assert(offsetof(UBFGSaveOptions, M_bInvertYAimingAxisMouse) == 0x00005D, "Member 'UBFGSaveOptions::M_bInvertYAimingAxisMouse' has a wrong offset!");
static_assert(offsetof(UBFGSaveOptions, M_bEnableLockOn) == 0x00005E, "Member 'UBFGSaveOptions::M_bEnableLockOn' has a wrong offset!");
static_assert(offsetof(UBFGSaveOptions, M_bHoldToFocusMode) == 0x00005F, "Member 'UBFGSaveOptions::M_bHoldToFocusMode' has a wrong offset!");
static_assert(offsetof(UBFGSaveOptions, M_fCryptoMouseSensitivity_V2) == 0x000060, "Member 'UBFGSaveOptions::M_fCryptoMouseSensitivity_V2' has a wrong offset!");
static_assert(offsetof(UBFGSaveOptions, M_fUFOMouseSensitivity_V2) == 0x000064, "Member 'UBFGSaveOptions::M_fUFOMouseSensitivity_V2' has a wrong offset!");
static_assert(offsetof(UBFGSaveOptions, M_fCryptoGamepadSensitivity_V2) == 0x000068, "Member 'UBFGSaveOptions::M_fCryptoGamepadSensitivity_V2' has a wrong offset!");
static_assert(offsetof(UBFGSaveOptions, M_fUFOGamepadSensitivity_V2) == 0x00006C, "Member 'UBFGSaveOptions::M_fUFOGamepadSensitivity_V2' has a wrong offset!");
static_assert(offsetof(UBFGSaveOptions, M_iCurrentInputRebindingsVersion) == 0x000070, "Member 'UBFGSaveOptions::M_iCurrentInputRebindingsVersion' has a wrong offset!");
static_assert(offsetof(UBFGSaveOptions, M_aCurrentInputRebinding) == 0x000078, "Member 'UBFGSaveOptions::M_aCurrentInputRebinding' has a wrong offset!");
static_assert(offsetof(UBFGSaveOptions, M_fGamma) == 0x000088, "Member 'UBFGSaveOptions::M_fGamma' has a wrong offset!");
static_assert(offsetof(UBFGSaveOptions, M_fVolumeMaster) == 0x00008C, "Member 'UBFGSaveOptions::M_fVolumeMaster' has a wrong offset!");
static_assert(offsetof(UBFGSaveOptions, M_fVolumeMusic) == 0x000090, "Member 'UBFGSaveOptions::M_fVolumeMusic' has a wrong offset!");
static_assert(offsetof(UBFGSaveOptions, M_fVolumeSFX) == 0x000094, "Member 'UBFGSaveOptions::M_fVolumeSFX' has a wrong offset!");
static_assert(offsetof(UBFGSaveOptions, M_fVolumeVoices) == 0x000098, "Member 'UBFGSaveOptions::M_fVolumeVoices' has a wrong offset!");
static_assert(offsetof(UBFGSaveOptions, M_fVolumeUI) == 0x00009C, "Member 'UBFGSaveOptions::M_fVolumeUI' has a wrong offset!");
static_assert(offsetof(UBFGSaveOptions, M_bEnable3DSound) == 0x0000A0, "Member 'UBFGSaveOptions::M_bEnable3DSound' has a wrong offset!");
static_assert(offsetof(UBFGSaveOptions, M_bEnableSubtitles) == 0x0000A1, "Member 'UBFGSaveOptions::M_bEnableSubtitles' has a wrong offset!");
static_assert(offsetof(UBFGSaveOptions, M_bEnableMuteInBackground) == 0x0000A2, "Member 'UBFGSaveOptions::M_bEnableMuteInBackground' has a wrong offset!");
static_assert(offsetof(UBFGSaveOptions, M_iFullscreenMode) == 0x0000A4, "Member 'UBFGSaveOptions::M_iFullscreenMode' has a wrong offset!");
static_assert(offsetof(UBFGSaveOptions, M_vResolution) == 0x0000A8, "Member 'UBFGSaveOptions::M_vResolution' has a wrong offset!");
static_assert(offsetof(UBFGSaveOptions, M_bVSyncEnabled) == 0x0000B0, "Member 'UBFGSaveOptions::M_bVSyncEnabled' has a wrong offset!");
static_assert(offsetof(UBFGSaveOptions, M_iViewDistanceQuality) == 0x0000B4, "Member 'UBFGSaveOptions::M_iViewDistanceQuality' has a wrong offset!");
static_assert(offsetof(UBFGSaveOptions, M_iAAQuality) == 0x0000B8, "Member 'UBFGSaveOptions::M_iAAQuality' has a wrong offset!");
static_assert(offsetof(UBFGSaveOptions, M_iPostProcessingQuality) == 0x0000BC, "Member 'UBFGSaveOptions::M_iPostProcessingQuality' has a wrong offset!");
static_assert(offsetof(UBFGSaveOptions, M_iShadowQuality) == 0x0000C0, "Member 'UBFGSaveOptions::M_iShadowQuality' has a wrong offset!");
static_assert(offsetof(UBFGSaveOptions, M_iTextureQuality) == 0x0000C4, "Member 'UBFGSaveOptions::M_iTextureQuality' has a wrong offset!");
static_assert(offsetof(UBFGSaveOptions, M_iVFXQuality) == 0x0000C8, "Member 'UBFGSaveOptions::M_iVFXQuality' has a wrong offset!");
static_assert(offsetof(UBFGSaveOptions, M_iFoliageQuality) == 0x0000CC, "Member 'UBFGSaveOptions::M_iFoliageQuality' has a wrong offset!");
static_assert(offsetof(UBFGSaveOptions, M_iMaxFPS) == 0x0000D0, "Member 'UBFGSaveOptions::M_iMaxFPS' has a wrong offset!");
static_assert(offsetof(UBFGSaveOptions, M_iLandscapeQuality) == 0x0000D4, "Member 'UBFGSaveOptions::M_iLandscapeQuality' has a wrong offset!");
static_assert(offsetof(UBFGSaveOptions, M_strCultureName) == 0x0000D8, "Member 'UBFGSaveOptions::M_strCultureName' has a wrong offset!");
static_assert(offsetof(UBFGSaveOptions, M_oCultureName) == 0x0000E8, "Member 'UBFGSaveOptions::M_oCultureName' has a wrong offset!");
static_assert(offsetof(UBFGSaveOptions, M_bEnableVibration) == 0x0000F0, "Member 'UBFGSaveOptions::M_bEnableVibration' has a wrong offset!");
static_assert(offsetof(UBFGSaveOptions, M_bEnableTutorials) == 0x0000F4, "Member 'UBFGSaveOptions::M_bEnableTutorials' has a wrong offset!");
static_assert(offsetof(UBFGSaveOptions, M_aUnlockedAchievementsAwaitingRetry) == 0x0000F8, "Member 'UBFGSaveOptions::M_aUnlockedAchievementsAwaitingRetry' has a wrong offset!");
static_assert(offsetof(UBFGSaveOptions, M_profileUnlockTags) == 0x000108, "Member 'UBFGSaveOptions::M_profileUnlockTags' has a wrong offset!");
static_assert(offsetof(UBFGSaveOptions, M_bGiftNotificationViewed) == 0x000128, "Member 'UBFGSaveOptions::M_bGiftNotificationViewed' has a wrong offset!");
static_assert(offsetof(UBFGSaveOptions, M_bFebruaryGiftNotificationViewed) == 0x000129, "Member 'UBFGSaveOptions::M_bFebruaryGiftNotificationViewed' has a wrong offset!");
static_assert(offsetof(UBFGSaveOptions, M_bHasSeenOnNextGen) == 0x00012A, "Member 'UBFGSaveOptions::M_bHasSeenOnNextGen' has a wrong offset!");

// Class BFGCore.BFGTaskNode_Boss_FireOutsideBeam
// 0x0030 (0x00D0 - 0x00A0)
class UBFGTaskNode_Boss_FireOutsideBeam final : public UBFGTaskNode_BossBase
{
public:
	struct FMetaPattern                           M_oMetaPattern;                                    // 0x00A0(0x0028)(NativeAccessSpecifierPublic)
	uint8                                         Pad_C8[0x8];                                       // 0x00C8(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"BFGTaskNode_Boss_FireOutsideBeam">();
	}
	static class UBFGTaskNode_Boss_FireOutsideBeam* GetDefaultObj()
	{
		return GetDefaultObjImpl<UBFGTaskNode_Boss_FireOutsideBeam>();
	}
};
static_assert(alignof(UBFGTaskNode_Boss_FireOutsideBeam) == 0x000008, "Wrong alignment on UBFGTaskNode_Boss_FireOutsideBeam");
static_assert(sizeof(UBFGTaskNode_Boss_FireOutsideBeam) == 0x0000D0, "Wrong size on UBFGTaskNode_Boss_FireOutsideBeam");
static_assert(offsetof(UBFGTaskNode_Boss_FireOutsideBeam, M_oMetaPattern) == 0x0000A0, "Member 'UBFGTaskNode_Boss_FireOutsideBeam::M_oMetaPattern' has a wrong offset!");

// Class BFGCore.BFGSaveSlotModel
// 0x0018 (0x0040 - 0x0028)
class UBFGSaveSlotModel final : public UObject
{
public:
	TArray<struct FBFGSaveSlotInfo>               M_aSlotInfo;                                       // 0x0028(0x0010)(ZeroConstructor, Transient, Protected, NativeAccessSpecifierProtected)
	class UBFGSaveSystem*                         M_pSaveSystem;                                     // 0x0038(0x0008)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"BFGSaveSlotModel">();
	}
	static class UBFGSaveSlotModel* GetDefaultObj()
	{
		return GetDefaultObjImpl<UBFGSaveSlotModel>();
	}
};
static_assert(alignof(UBFGSaveSlotModel) == 0x000008, "Wrong alignment on UBFGSaveSlotModel");
static_assert(sizeof(UBFGSaveSlotModel) == 0x000040, "Wrong size on UBFGSaveSlotModel");
static_assert(offsetof(UBFGSaveSlotModel, M_aSlotInfo) == 0x000028, "Member 'UBFGSaveSlotModel::M_aSlotInfo' has a wrong offset!");
static_assert(offsetof(UBFGSaveSlotModel, M_pSaveSystem) == 0x000038, "Member 'UBFGSaveSlotModel::M_pSaveSystem' has a wrong offset!");

// Class BFGCore.BFGSaveSystem
// 0x0090 (0x00B8 - 0x0028)
class UBFGSaveSystem final : public UObject
{
public:
	UMulticastDelegateProperty_                   M_onActionDone;                                    // 0x0028(0x0018)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	UMulticastDelegateProperty_                   M_onSaveDone;                                      // 0x0040(0x0018)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	UMulticastDelegateProperty_                   M_onLoadDone;                                      // 0x0058(0x0018)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	class UBFGGameInstance*                       M_pGameInstance;                                   // 0x0070(0x0008)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TArray<class UBFGSaveSystem_Action*>          M_apPendingActions;                                // 0x0078(0x0010)(ZeroConstructor, Transient, Protected, NativeAccessSpecifierProtected)
	class UBFGSaveSystem_Action*                  M_pCurrentAction;                                  // 0x0088(0x0008)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_90[0x8];                                       // 0x0090(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	class UBFGSaveDataCache*                      M_pSaveCache;                                      // 0x0098(0x0008)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UBFGSaveSlotModel*                      M_pSlotModel;                                      // 0x00A0(0x0008)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UBFGSaveOptions*                        M_pSaveProfileAndOptions;                          // 0x00A8(0x0008)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_B0[0x8];                                       // 0x00B0(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void OnWorldLoaded(class UBFGGameInstance* _pGameInstance, class UWorld* _pWorld);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"BFGSaveSystem">();
	}
	static class UBFGSaveSystem* GetDefaultObj()
	{
		return GetDefaultObjImpl<UBFGSaveSystem>();
	}
};
static_assert(alignof(UBFGSaveSystem) == 0x000008, "Wrong alignment on UBFGSaveSystem");
static_assert(sizeof(UBFGSaveSystem) == 0x0000B8, "Wrong size on UBFGSaveSystem");
static_assert(offsetof(UBFGSaveSystem, M_onActionDone) == 0x000028, "Member 'UBFGSaveSystem::M_onActionDone' has a wrong offset!");
static_assert(offsetof(UBFGSaveSystem, M_onSaveDone) == 0x000040, "Member 'UBFGSaveSystem::M_onSaveDone' has a wrong offset!");
static_assert(offsetof(UBFGSaveSystem, M_onLoadDone) == 0x000058, "Member 'UBFGSaveSystem::M_onLoadDone' has a wrong offset!");
static_assert(offsetof(UBFGSaveSystem, M_pGameInstance) == 0x000070, "Member 'UBFGSaveSystem::M_pGameInstance' has a wrong offset!");
static_assert(offsetof(UBFGSaveSystem, M_apPendingActions) == 0x000078, "Member 'UBFGSaveSystem::M_apPendingActions' has a wrong offset!");
static_assert(offsetof(UBFGSaveSystem, M_pCurrentAction) == 0x000088, "Member 'UBFGSaveSystem::M_pCurrentAction' has a wrong offset!");
static_assert(offsetof(UBFGSaveSystem, M_pSaveCache) == 0x000098, "Member 'UBFGSaveSystem::M_pSaveCache' has a wrong offset!");
static_assert(offsetof(UBFGSaveSystem, M_pSlotModel) == 0x0000A0, "Member 'UBFGSaveSystem::M_pSlotModel' has a wrong offset!");
static_assert(offsetof(UBFGSaveSystem, M_pSaveProfileAndOptions) == 0x0000A8, "Member 'UBFGSaveSystem::M_pSaveProfileAndOptions' has a wrong offset!");

// Class BFGCore.BFGTaskNode_Boss_ResetLocation
// 0x0000 (0x00A0 - 0x00A0)
class UBFGTaskNode_Boss_ResetLocation final : public UBFGTaskNode_BossBase
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"BFGTaskNode_Boss_ResetLocation">();
	}
	static class UBFGTaskNode_Boss_ResetLocation* GetDefaultObj()
	{
		return GetDefaultObjImpl<UBFGTaskNode_Boss_ResetLocation>();
	}
};
static_assert(alignof(UBFGTaskNode_Boss_ResetLocation) == 0x000008, "Wrong alignment on UBFGTaskNode_Boss_ResetLocation");
static_assert(sizeof(UBFGTaskNode_Boss_ResetLocation) == 0x0000A0, "Wrong size on UBFGTaskNode_Boss_ResetLocation");

// Class BFGCore.BFGSaveSystem_DataInterface
// 0x0000 (0x0028 - 0x0028)
class IBFGSaveSystem_DataInterface final : public IInterface
{
public:
	void DoRestore(const TMap<class FName, float>& _aDataValues);

	void DoSnapshot(TMap<class FName, float>* _aDataValuesOut) const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"BFGSaveSystem_DataInterface">();
	}
	static class IBFGSaveSystem_DataInterface* GetDefaultObj()
	{
		return GetDefaultObjImpl<IBFGSaveSystem_DataInterface>();
	}
};
static_assert(alignof(IBFGSaveSystem_DataInterface) == 0x000008, "Wrong alignment on IBFGSaveSystem_DataInterface");
static_assert(sizeof(IBFGSaveSystem_DataInterface) == 0x000028, "Wrong size on IBFGSaveSystem_DataInterface");

// Class BFGCore.BFGSaveSystem_LoadOptionsAction
// 0x0020 (0x0068 - 0x0048)
class UBFGSaveSystem_LoadOptionsAction final : public UBFGSaveSystem_AsyncAction
{
public:
	uint8                                         Pad_48[0x8];                                       // 0x0048(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	class UBFGSaveOptions*                        M_pOptions;                                        // 0x0050(0x0008)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_58[0x8];                                       // 0x0058(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	class UBFGSaveSystem_SaveOptionsAction*       M_pSaveAction;                                     // 0x0060(0x0008)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"BFGSaveSystem_LoadOptionsAction">();
	}
	static class UBFGSaveSystem_LoadOptionsAction* GetDefaultObj()
	{
		return GetDefaultObjImpl<UBFGSaveSystem_LoadOptionsAction>();
	}
};
static_assert(alignof(UBFGSaveSystem_LoadOptionsAction) == 0x000008, "Wrong alignment on UBFGSaveSystem_LoadOptionsAction");
static_assert(sizeof(UBFGSaveSystem_LoadOptionsAction) == 0x000068, "Wrong size on UBFGSaveSystem_LoadOptionsAction");
static_assert(offsetof(UBFGSaveSystem_LoadOptionsAction, M_pOptions) == 0x000050, "Member 'UBFGSaveSystem_LoadOptionsAction::M_pOptions' has a wrong offset!");
static_assert(offsetof(UBFGSaveSystem_LoadOptionsAction, M_pSaveAction) == 0x000060, "Member 'UBFGSaveSystem_LoadOptionsAction::M_pSaveAction' has a wrong offset!");

// Class BFGCore.BFGTaskNode_Boss_SpawnAirMines
// 0x0000 (0x00A0 - 0x00A0)
class UBFGTaskNode_Boss_SpawnAirMines final : public UBFGTaskNode_BossBase
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"BFGTaskNode_Boss_SpawnAirMines">();
	}
	static class UBFGTaskNode_Boss_SpawnAirMines* GetDefaultObj()
	{
		return GetDefaultObjImpl<UBFGTaskNode_Boss_SpawnAirMines>();
	}
};
static_assert(alignof(UBFGTaskNode_Boss_SpawnAirMines) == 0x000008, "Wrong alignment on UBFGTaskNode_Boss_SpawnAirMines");
static_assert(sizeof(UBFGTaskNode_Boss_SpawnAirMines) == 0x0000A0, "Wrong size on UBFGTaskNode_Boss_SpawnAirMines");

// Class BFGCore.BFGSaveSystem_SaveGameAction
// 0x0130 (0x0178 - 0x0048)
class UBFGSaveSystem_SaveGameAction final : public UBFGSaveSystem_AsyncAction
{
public:
	struct FBFGSaveSystem_SaveGameAction_Params   M_params;                                          // 0x0048(0x0028)(Transient, Protected, NativeAccessSpecifierProtected)
	struct FBFGSavedMapDescription                M_targetMap;                                       // 0x0070(0x0038)(Transient, Protected, NativeAccessSpecifierProtected)
	uint8                                         Pad_A8[0x8];                                       // 0x00A8(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	class UBFGSaveSystem_SaveOptionsAction*       M_pProfileSaveAction;                              // 0x00B0(0x0008)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UBFGSaveGame*                           M_pSaveGame;                                       // 0x00B8(0x0008)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	struct FBFGSaveDescription                    M_saveDescr;                                       // 0x00C0(0x0070)(Transient, Protected, NativeAccessSpecifierProtected)
	uint8                                         Pad_130[0x28];                                     // 0x0130(0x0028)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<struct FColor>                         M_aScreenshotData;                                 // 0x0158(0x0010)(ZeroConstructor, Transient, Protected, NativeAccessSpecifierProtected)
	struct FIntVector                             M_aScreenshotSize;                                 // 0x0168(0x000C)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_174[0x4];                                      // 0x0174(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"BFGSaveSystem_SaveGameAction">();
	}
	static class UBFGSaveSystem_SaveGameAction* GetDefaultObj()
	{
		return GetDefaultObjImpl<UBFGSaveSystem_SaveGameAction>();
	}
};
static_assert(alignof(UBFGSaveSystem_SaveGameAction) == 0x000008, "Wrong alignment on UBFGSaveSystem_SaveGameAction");
static_assert(sizeof(UBFGSaveSystem_SaveGameAction) == 0x000178, "Wrong size on UBFGSaveSystem_SaveGameAction");
static_assert(offsetof(UBFGSaveSystem_SaveGameAction, M_params) == 0x000048, "Member 'UBFGSaveSystem_SaveGameAction::M_params' has a wrong offset!");
static_assert(offsetof(UBFGSaveSystem_SaveGameAction, M_targetMap) == 0x000070, "Member 'UBFGSaveSystem_SaveGameAction::M_targetMap' has a wrong offset!");
static_assert(offsetof(UBFGSaveSystem_SaveGameAction, M_pProfileSaveAction) == 0x0000B0, "Member 'UBFGSaveSystem_SaveGameAction::M_pProfileSaveAction' has a wrong offset!");
static_assert(offsetof(UBFGSaveSystem_SaveGameAction, M_pSaveGame) == 0x0000B8, "Member 'UBFGSaveSystem_SaveGameAction::M_pSaveGame' has a wrong offset!");
static_assert(offsetof(UBFGSaveSystem_SaveGameAction, M_saveDescr) == 0x0000C0, "Member 'UBFGSaveSystem_SaveGameAction::M_saveDescr' has a wrong offset!");
static_assert(offsetof(UBFGSaveSystem_SaveGameAction, M_aScreenshotData) == 0x000158, "Member 'UBFGSaveSystem_SaveGameAction::M_aScreenshotData' has a wrong offset!");
static_assert(offsetof(UBFGSaveSystem_SaveGameAction, M_aScreenshotSize) == 0x000168, "Member 'UBFGSaveSystem_SaveGameAction::M_aScreenshotSize' has a wrong offset!");

// Class BFGCore.BFGSaveSystem_SaveOptionsAction
// 0x0018 (0x0060 - 0x0048)
class UBFGSaveSystem_SaveOptionsAction final : public UBFGSaveSystem_AsyncAction
{
public:
	class UBFGSaveOptions*                        M_pProfileAndOptions;                              // 0x0048(0x0008)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UBFGSaveOptions*                        M_pDataToSave;                                     // 0x0050(0x0008)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_58[0x8];                                       // 0x0058(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"BFGSaveSystem_SaveOptionsAction">();
	}
	static class UBFGSaveSystem_SaveOptionsAction* GetDefaultObj()
	{
		return GetDefaultObjImpl<UBFGSaveSystem_SaveOptionsAction>();
	}
};
static_assert(alignof(UBFGSaveSystem_SaveOptionsAction) == 0x000008, "Wrong alignment on UBFGSaveSystem_SaveOptionsAction");
static_assert(sizeof(UBFGSaveSystem_SaveOptionsAction) == 0x000060, "Wrong size on UBFGSaveSystem_SaveOptionsAction");
static_assert(offsetof(UBFGSaveSystem_SaveOptionsAction, M_pProfileAndOptions) == 0x000048, "Member 'UBFGSaveSystem_SaveOptionsAction::M_pProfileAndOptions' has a wrong offset!");
static_assert(offsetof(UBFGSaveSystem_SaveOptionsAction, M_pDataToSave) == 0x000050, "Member 'UBFGSaveSystem_SaveOptionsAction::M_pDataToSave' has a wrong offset!");

// Class BFGCore.BFGSceneComponent_HighlightableSceneObject
// 0x00A8 (0x0340 - 0x0298)
class UBFGSceneComponent_HighlightableSceneObject : public USceneComponent
{
public:
	class UBFGDataAsset_HighlightableSceneObject* M_pStaticInfo;                                     // 0x0298(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          M_bRegisterAsHighlightable;                        // 0x02A0(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          M_bEnabled;                                        // 0x02A1(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_2A2[0x96];                                     // 0x02A2(0x0096)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         M_fClampRadius;                                    // 0x0338(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_33C[0x4];                                      // 0x033C(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void RegisterAtManager();
	void SetEnabled(bool _bEnabled);
	void UnregisterFromManager();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"BFGSceneComponent_HighlightableSceneObject">();
	}
	static class UBFGSceneComponent_HighlightableSceneObject* GetDefaultObj()
	{
		return GetDefaultObjImpl<UBFGSceneComponent_HighlightableSceneObject>();
	}
};
static_assert(alignof(UBFGSceneComponent_HighlightableSceneObject) == 0x000008, "Wrong alignment on UBFGSceneComponent_HighlightableSceneObject");
static_assert(sizeof(UBFGSceneComponent_HighlightableSceneObject) == 0x000340, "Wrong size on UBFGSceneComponent_HighlightableSceneObject");
static_assert(offsetof(UBFGSceneComponent_HighlightableSceneObject, M_pStaticInfo) == 0x000298, "Member 'UBFGSceneComponent_HighlightableSceneObject::M_pStaticInfo' has a wrong offset!");
static_assert(offsetof(UBFGSceneComponent_HighlightableSceneObject, M_bRegisterAsHighlightable) == 0x0002A0, "Member 'UBFGSceneComponent_HighlightableSceneObject::M_bRegisterAsHighlightable' has a wrong offset!");
static_assert(offsetof(UBFGSceneComponent_HighlightableSceneObject, M_bEnabled) == 0x0002A1, "Member 'UBFGSceneComponent_HighlightableSceneObject::M_bEnabled' has a wrong offset!");
static_assert(offsetof(UBFGSceneComponent_HighlightableSceneObject, M_fClampRadius) == 0x000338, "Member 'UBFGSceneComponent_HighlightableSceneObject::M_fClampRadius' has a wrong offset!");

// Class BFGCore.BFGScriptedSequence_TaskCrowdLifeStation
// 0x0088 (0x00D8 - 0x0050)
class UBFGScriptedSequence_TaskCrowdLifeStation final : public UBFGScriptedSequence_Task
{
public:
	TSoftObjectPtr<class ABFGCrowdLife>           M_softCrowdLife;                                   // 0x0050(0x0028)(Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	struct FGameplayTagQuery                      M_stationQuery;                                    // 0x0078(0x0048)(Protected, NativeAccessSpecifierProtected)
	uint8                                         Pad_C0[0x8];                                       // 0x00C0(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	class ABFGCrowdLife*                          M_pCrowdLife;                                      // 0x00C8(0x0008)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UBFGCrowdLifeStationComponent*          M_pStation;                                        // 0x00D0(0x0008)(ExportObject, ZeroConstructor, Transient, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)

public:
	static bool CreateAndAddScriptedSequence_TaskJoinCrowdLifeStation(class UBFGScriptedSequence* _pScriptedSequence, TSoftObjectPtr<class ABFGCrowdLife> _softCrowdLife, const struct FGameplayTagQuery& _stationQuery, bool _bFinishAfterJoin);
	static bool CreateAndAddScriptedSequence_TaskLeaveCrowdLifeStation(class UBFGScriptedSequence* _pScriptedSequence, TSoftObjectPtr<class ABFGCrowdLife> _softCrowdLife, const struct FGameplayTagQuery& _stationQuery, bool _bFollowRandomPath);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"BFGScriptedSequence_TaskCrowdLifeStation">();
	}
	static class UBFGScriptedSequence_TaskCrowdLifeStation* GetDefaultObj()
	{
		return GetDefaultObjImpl<UBFGScriptedSequence_TaskCrowdLifeStation>();
	}
};
static_assert(alignof(UBFGScriptedSequence_TaskCrowdLifeStation) == 0x000008, "Wrong alignment on UBFGScriptedSequence_TaskCrowdLifeStation");
static_assert(sizeof(UBFGScriptedSequence_TaskCrowdLifeStation) == 0x0000D8, "Wrong size on UBFGScriptedSequence_TaskCrowdLifeStation");
static_assert(offsetof(UBFGScriptedSequence_TaskCrowdLifeStation, M_softCrowdLife) == 0x000050, "Member 'UBFGScriptedSequence_TaskCrowdLifeStation::M_softCrowdLife' has a wrong offset!");
static_assert(offsetof(UBFGScriptedSequence_TaskCrowdLifeStation, M_stationQuery) == 0x000078, "Member 'UBFGScriptedSequence_TaskCrowdLifeStation::M_stationQuery' has a wrong offset!");
static_assert(offsetof(UBFGScriptedSequence_TaskCrowdLifeStation, M_pCrowdLife) == 0x0000C8, "Member 'UBFGScriptedSequence_TaskCrowdLifeStation::M_pCrowdLife' has a wrong offset!");
static_assert(offsetof(UBFGScriptedSequence_TaskCrowdLifeStation, M_pStation) == 0x0000D0, "Member 'UBFGScriptedSequence_TaskCrowdLifeStation::M_pStation' has a wrong offset!");

// Class BFGCore.BFGScriptedSequence_TaskInteractWith
// 0x0058 (0x00F8 - 0x00A0)
class UBFGScriptedSequence_TaskInteractWith final : public UBFGScriptedSequence_TaskPlayAnim
{
public:
	TSoftObjectPtr<class AActor>                  M_softInteractable;                                // 0x00A0(0x0028)(Transient, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_C8[0x8];                                       // 0x00C8(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	class AActor*                                 M_pInteractable;                                   // 0x00D0(0x0008)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class AController*                            M_pController;                                     // 0x00D8(0x0008)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_E0[0x18];                                      // 0x00E0(0x0018)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static bool CreateAndAddScriptedSequence_TaskInteractWith(class UBFGScriptedSequence* _pScriptedSequence, TSoftObjectPtr<class AActor> _softInteractable, TSoftObjectPtr<class AActor> _softDestination, const struct FBFGInteractAnimationSequence& _animSequenceData, bool _bLooping, float _fDuration, int32 _iDoInteractAfterAnimSequenceIndex);

	void OnInteractAnimChanged(class UBFGNetworkPathAgent_AIStatePlayInteractAtLocation* _pTask, const struct FBFGInteractAnimationData& _next, const struct FBFGInteractAnimationData& _previous);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"BFGScriptedSequence_TaskInteractWith">();
	}
	static class UBFGScriptedSequence_TaskInteractWith* GetDefaultObj()
	{
		return GetDefaultObjImpl<UBFGScriptedSequence_TaskInteractWith>();
	}
};
static_assert(alignof(UBFGScriptedSequence_TaskInteractWith) == 0x000008, "Wrong alignment on UBFGScriptedSequence_TaskInteractWith");
static_assert(sizeof(UBFGScriptedSequence_TaskInteractWith) == 0x0000F8, "Wrong size on UBFGScriptedSequence_TaskInteractWith");
static_assert(offsetof(UBFGScriptedSequence_TaskInteractWith, M_softInteractable) == 0x0000A0, "Member 'UBFGScriptedSequence_TaskInteractWith::M_softInteractable' has a wrong offset!");
static_assert(offsetof(UBFGScriptedSequence_TaskInteractWith, M_pInteractable) == 0x0000D0, "Member 'UBFGScriptedSequence_TaskInteractWith::M_pInteractable' has a wrong offset!");
static_assert(offsetof(UBFGScriptedSequence_TaskInteractWith, M_pController) == 0x0000D8, "Member 'UBFGScriptedSequence_TaskInteractWith::M_pController' has a wrong offset!");

// Class BFGCore.BFGScriptedSequenceManager
// 0x0028 (0x0050 - 0x0028)
class UBFGScriptedSequenceManager final : public UObject
{
public:
	class ABFGGameState*                          M_pGameState;                                      // 0x0028(0x0008)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TArray<class UBFGScriptedSequence*>           M_apSequences;                                     // 0x0030(0x0010)(ExportObject, ZeroConstructor, Transient, ContainsInstancedReference, Protected, NativeAccessSpecifierProtected)
	TArray<class UBFGScriptedSequence*>           M_apPendingSequenceToRemove;                       // 0x0040(0x0010)(ZeroConstructor, Transient, Protected, NativeAccessSpecifierProtected)

public:
	class UBFGScriptedSequence_Persistent* CreateNew(const class FName& _strIdentifier, const struct FGameplayTagQuery& _pawnGameplayTagQuery, class UObject* _pDebugContext);
	class UBFGScriptedSequence_Persistent* CreateNewSequenceFor(const class FName& _strIdentifier, const TSoftObjectPtr<class AActor>& _softActorReference, class UObject* _pDebugContext);
	class UBFGScriptedSequence_Transient* CreateNewSequenceForTransient(const class FName& _strIdentifier, const TSoftObjectPtr<class AActor>& _softActorReference, class UObject* _pDebugContext);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"BFGScriptedSequenceManager">();
	}
	static class UBFGScriptedSequenceManager* GetDefaultObj()
	{
		return GetDefaultObjImpl<UBFGScriptedSequenceManager>();
	}
};
static_assert(alignof(UBFGScriptedSequenceManager) == 0x000008, "Wrong alignment on UBFGScriptedSequenceManager");
static_assert(sizeof(UBFGScriptedSequenceManager) == 0x000050, "Wrong size on UBFGScriptedSequenceManager");
static_assert(offsetof(UBFGScriptedSequenceManager, M_pGameState) == 0x000028, "Member 'UBFGScriptedSequenceManager::M_pGameState' has a wrong offset!");
static_assert(offsetof(UBFGScriptedSequenceManager, M_apSequences) == 0x000030, "Member 'UBFGScriptedSequenceManager::M_apSequences' has a wrong offset!");
static_assert(offsetof(UBFGScriptedSequenceManager, M_apPendingSequenceToRemove) == 0x000040, "Member 'UBFGScriptedSequenceManager::M_apPendingSequenceToRemove' has a wrong offset!");

// Class BFGCore.BFGSensor_Alerted_ResetTimeoutWhileNotCowering
// 0x0028 (0x0068 - 0x0040)
class UBFGSensor_Alerted_ResetTimeoutWhileNotCowering final : public UBFGSensor
{
public:
	struct FBlackboardKeySelector                 M_BBKeyCowerRequested;                             // 0x0040(0x0028)(Edit, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"BFGSensor_Alerted_ResetTimeoutWhileNotCowering">();
	}
	static class UBFGSensor_Alerted_ResetTimeoutWhileNotCowering* GetDefaultObj()
	{
		return GetDefaultObjImpl<UBFGSensor_Alerted_ResetTimeoutWhileNotCowering>();
	}
};
static_assert(alignof(UBFGSensor_Alerted_ResetTimeoutWhileNotCowering) == 0x000008, "Wrong alignment on UBFGSensor_Alerted_ResetTimeoutWhileNotCowering");
static_assert(sizeof(UBFGSensor_Alerted_ResetTimeoutWhileNotCowering) == 0x000068, "Wrong size on UBFGSensor_Alerted_ResetTimeoutWhileNotCowering");
static_assert(offsetof(UBFGSensor_Alerted_ResetTimeoutWhileNotCowering, M_BBKeyCowerRequested) == 0x000040, "Member 'UBFGSensor_Alerted_ResetTimeoutWhileNotCowering::M_BBKeyCowerRequested' has a wrong offset!");

// Class BFGCore.BFGSensor_Curious_SpotInterval
// 0x0018 (0x0058 - 0x0040)
class UBFGSensor_Curious_SpotInterval final : public UBFGSensor
{
public:
	float                                         M_fSpotInterval;                                   // 0x0040(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         M_fCuriosityTimer;                                 // 0x0044(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         M_fSpotIntervalScaleMinDistance;                   // 0x0048(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         M_fSpotIntervalScaleMaxDistance;                   // 0x004C(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         M_fSpotIntervalScaleMinFactor;                     // 0x0050(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         M_fSpotIntervalScaleMaxFactor;                     // 0x0054(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"BFGSensor_Curious_SpotInterval">();
	}
	static class UBFGSensor_Curious_SpotInterval* GetDefaultObj()
	{
		return GetDefaultObjImpl<UBFGSensor_Curious_SpotInterval>();
	}
};
static_assert(alignof(UBFGSensor_Curious_SpotInterval) == 0x000008, "Wrong alignment on UBFGSensor_Curious_SpotInterval");
static_assert(sizeof(UBFGSensor_Curious_SpotInterval) == 0x000058, "Wrong size on UBFGSensor_Curious_SpotInterval");
static_assert(offsetof(UBFGSensor_Curious_SpotInterval, M_fSpotInterval) == 0x000040, "Member 'UBFGSensor_Curious_SpotInterval::M_fSpotInterval' has a wrong offset!");
static_assert(offsetof(UBFGSensor_Curious_SpotInterval, M_fCuriosityTimer) == 0x000044, "Member 'UBFGSensor_Curious_SpotInterval::M_fCuriosityTimer' has a wrong offset!");
static_assert(offsetof(UBFGSensor_Curious_SpotInterval, M_fSpotIntervalScaleMinDistance) == 0x000048, "Member 'UBFGSensor_Curious_SpotInterval::M_fSpotIntervalScaleMinDistance' has a wrong offset!");
static_assert(offsetof(UBFGSensor_Curious_SpotInterval, M_fSpotIntervalScaleMaxDistance) == 0x00004C, "Member 'UBFGSensor_Curious_SpotInterval::M_fSpotIntervalScaleMaxDistance' has a wrong offset!");
static_assert(offsetof(UBFGSensor_Curious_SpotInterval, M_fSpotIntervalScaleMinFactor) == 0x000050, "Member 'UBFGSensor_Curious_SpotInterval::M_fSpotIntervalScaleMinFactor' has a wrong offset!");
static_assert(offsetof(UBFGSensor_Curious_SpotInterval, M_fSpotIntervalScaleMaxFactor) == 0x000054, "Member 'UBFGSensor_Curious_SpotInterval::M_fSpotIntervalScaleMaxFactor' has a wrong offset!");

// Class BFGCore.BFGSensor_Hypnotized
// 0x0000 (0x0040 - 0x0040)
class UBFGSensor_Hypnotized final : public UBFGSensor
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"BFGSensor_Hypnotized">();
	}
	static class UBFGSensor_Hypnotized* GetDefaultObj()
	{
		return GetDefaultObjImpl<UBFGSensor_Hypnotized>();
	}
};
static_assert(alignof(UBFGSensor_Hypnotized) == 0x000008, "Wrong alignment on UBFGSensor_Hypnotized");
static_assert(sizeof(UBFGSensor_Hypnotized) == 0x000040, "Wrong size on UBFGSensor_Hypnotized");

// Class BFGCore.BFGSensor_Noises
// 0x0058 (0x0098 - 0x0040)
class UBFGSensor_Noises final : public UBFGSensor
{
public:
	float                                         M_fMaxDistToWeaponNoiseNPC;                        // 0x0040(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EBFGBehaviourState_NPC                        M_targetStateWeaponNoise;                          // 0x0044(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_45[0x3];                                       // 0x0045(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	TMap<class FName, EBFGBehaviourState_NPC>     M_aAddionalEvents;                                 // 0x0048(0x0050)(Edit, ZeroConstructor, Protected, NativeAccessSpecifierProtected)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"BFGSensor_Noises">();
	}
	static class UBFGSensor_Noises* GetDefaultObj()
	{
		return GetDefaultObjImpl<UBFGSensor_Noises>();
	}
};
static_assert(alignof(UBFGSensor_Noises) == 0x000008, "Wrong alignment on UBFGSensor_Noises");
static_assert(sizeof(UBFGSensor_Noises) == 0x000098, "Wrong size on UBFGSensor_Noises");
static_assert(offsetof(UBFGSensor_Noises, M_fMaxDistToWeaponNoiseNPC) == 0x000040, "Member 'UBFGSensor_Noises::M_fMaxDistToWeaponNoiseNPC' has a wrong offset!");
static_assert(offsetof(UBFGSensor_Noises, M_targetStateWeaponNoise) == 0x000044, "Member 'UBFGSensor_Noises::M_targetStateWeaponNoise' has a wrong offset!");
static_assert(offsetof(UBFGSensor_Noises, M_aAddionalEvents) == 0x000048, "Member 'UBFGSensor_Noises::M_aAddionalEvents' has a wrong offset!");

// Class BFGCore.BFGSensor_SuspiciousLocation
// 0x0000 (0x0040 - 0x0040)
class UBFGSensor_SuspiciousLocation final : public UBFGSensor
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"BFGSensor_SuspiciousLocation">();
	}
	static class UBFGSensor_SuspiciousLocation* GetDefaultObj()
	{
		return GetDefaultObjImpl<UBFGSensor_SuspiciousLocation>();
	}
};
static_assert(alignof(UBFGSensor_SuspiciousLocation) == 0x000008, "Wrong alignment on UBFGSensor_SuspiciousLocation");
static_assert(sizeof(UBFGSensor_SuspiciousLocation) == 0x000040, "Wrong size on UBFGSensor_SuspiciousLocation");

// Class BFGCore.BFGSequencePivot
// 0x0000 (0x03D8 - 0x03D8)
class ABFGSequencePivot final : public AActor
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"BFGSequencePivot">();
	}
	static class ABFGSequencePivot* GetDefaultObj()
	{
		return GetDefaultObjImpl<ABFGSequencePivot>();
	}
};
static_assert(alignof(ABFGSequencePivot) == 0x000008, "Wrong alignment on ABFGSequencePivot");
static_assert(sizeof(ABFGSequencePivot) == 0x0003D8, "Wrong size on ABFGSequencePivot");

// Class BFGCore.BFGSequenceRequest
// 0x00B0 (0x00D8 - 0x0028)
class UBFGSequenceRequest final : public UObject
{
public:
	uint8                                         Pad_28[0x8];                                       // 0x0028(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	TSoftObjectPtr<class ALevelSequenceActor>     M_softSequence;                                    // 0x0030(0x0028)(Transient, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_58[0x70];                                      // 0x0058(0x0070)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<struct FBFGSequence_DynamicActorBinding> M_aBindings;                                       // 0x00C8(0x0010)(ZeroConstructor, Transient, Protected, NativeAccessSpecifierProtected)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"BFGSequenceRequest">();
	}
	static class UBFGSequenceRequest* GetDefaultObj()
	{
		return GetDefaultObjImpl<UBFGSequenceRequest>();
	}
};
static_assert(alignof(UBFGSequenceRequest) == 0x000008, "Wrong alignment on UBFGSequenceRequest");
static_assert(sizeof(UBFGSequenceRequest) == 0x0000D8, "Wrong size on UBFGSequenceRequest");
static_assert(offsetof(UBFGSequenceRequest, M_softSequence) == 0x000030, "Member 'UBFGSequenceRequest::M_softSequence' has a wrong offset!");
static_assert(offsetof(UBFGSequenceRequest, M_aBindings) == 0x0000C8, "Member 'UBFGSequenceRequest::M_aBindings' has a wrong offset!");

// Class BFGCore.BFGService_Escort_MonitorGoal
// 0x0058 (0x00D0 - 0x0078)
class UBFGService_Escort_MonitorGoal final : public UBFGBTBaseService
{
public:
	struct FBlackboardKeySelector                 M_BBKey_TaskData;                                  // 0x0078(0x0028)(Edit, NativeAccessSpecifierPublic)
	struct FBlackboardKeySelector                 M_BBKey_MoveGoal;                                  // 0x00A0(0x0028)(Edit, NativeAccessSpecifierPublic)
	float                                         M_fReachTollerance;                                // 0x00C8(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         M_fTrafficSystemReachTollerance;                   // 0x00CC(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"BFGService_Escort_MonitorGoal">();
	}
	static class UBFGService_Escort_MonitorGoal* GetDefaultObj()
	{
		return GetDefaultObjImpl<UBFGService_Escort_MonitorGoal>();
	}
};
static_assert(alignof(UBFGService_Escort_MonitorGoal) == 0x000008, "Wrong alignment on UBFGService_Escort_MonitorGoal");
static_assert(sizeof(UBFGService_Escort_MonitorGoal) == 0x0000D0, "Wrong size on UBFGService_Escort_MonitorGoal");
static_assert(offsetof(UBFGService_Escort_MonitorGoal, M_BBKey_TaskData) == 0x000078, "Member 'UBFGService_Escort_MonitorGoal::M_BBKey_TaskData' has a wrong offset!");
static_assert(offsetof(UBFGService_Escort_MonitorGoal, M_BBKey_MoveGoal) == 0x0000A0, "Member 'UBFGService_Escort_MonitorGoal::M_BBKey_MoveGoal' has a wrong offset!");
static_assert(offsetof(UBFGService_Escort_MonitorGoal, M_fReachTollerance) == 0x0000C8, "Member 'UBFGService_Escort_MonitorGoal::M_fReachTollerance' has a wrong offset!");
static_assert(offsetof(UBFGService_Escort_MonitorGoal, M_fTrafficSystemReachTollerance) == 0x0000CC, "Member 'UBFGService_Escort_MonitorGoal::M_fTrafficSystemReachTollerance' has a wrong offset!");

// Class BFGCore.BFGSpawningCompositionActorType
// 0x0038 (0x0090 - 0x0058)
class UBFGSpawningCompositionActorType final : public UBFGSpawningComposition
{
public:
	TArray<struct FBFGSpawningCompositionItemActortype> M_aItems;                                          // 0x0058(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, Protected, NativeAccessSpecifierProtected)
	TSoftObjectPtr<class UDataTable>              M_pActorTable;                                     // 0x0068(0x0028)(Edit, BlueprintVisible, BlueprintReadOnly, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"BFGSpawningCompositionActorType">();
	}
	static class UBFGSpawningCompositionActorType* GetDefaultObj()
	{
		return GetDefaultObjImpl<UBFGSpawningCompositionActorType>();
	}
};
static_assert(alignof(UBFGSpawningCompositionActorType) == 0x000008, "Wrong alignment on UBFGSpawningCompositionActorType");
static_assert(sizeof(UBFGSpawningCompositionActorType) == 0x000090, "Wrong size on UBFGSpawningCompositionActorType");
static_assert(offsetof(UBFGSpawningCompositionActorType, M_aItems) == 0x000058, "Member 'UBFGSpawningCompositionActorType::M_aItems' has a wrong offset!");
static_assert(offsetof(UBFGSpawningCompositionActorType, M_pActorTable) == 0x000068, "Member 'UBFGSpawningCompositionActorType::M_pActorTable' has a wrong offset!");

// Class BFGCore.BFGStatisticsManager
// 0x01C0 (0x01F0 - 0x0030)
class UBFGStatisticsManager : public UBFGGameSystem
{
public:
	UMulticastDelegateProperty_                   M_oGameStatisticChanged;                           // 0x0030(0x0018)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	struct FGameplayTagContainer                  M_tTagCivilian;                                    // 0x0048(0x0020)(Edit, DisableEditOnInstance, NativeAccessSpecifierPublic)
	struct FGameplayTagContainer                  M_tTagFarmer;                                      // 0x0068(0x0020)(Edit, DisableEditOnInstance, NativeAccessSpecifierPublic)
	struct FGameplayTagContainer                  M_tTagCop;                                         // 0x0088(0x0020)(Edit, DisableEditOnInstance, NativeAccessSpecifierPublic)
	struct FGameplayTagContainer                  M_tTagSoldier;                                     // 0x00A8(0x0020)(Edit, DisableEditOnInstance, NativeAccessSpecifierPublic)
	struct FGameplayTagContainer                  M_tTagAgent;                                       // 0x00C8(0x0020)(Edit, DisableEditOnInstance, NativeAccessSpecifierPublic)
	struct FGameplayTagContainer                  M_tTagMutant;                                      // 0x00E8(0x0020)(Edit, DisableEditOnInstance, NativeAccessSpecifierPublic)
	struct FGameplayTagContainer                  M_tTagTank;                                        // 0x0108(0x0020)(Edit, DisableEditOnInstance, NativeAccessSpecifierPublic)
	struct FGameplayTagContainer                  M_tTagPowerSuit;                                   // 0x0128(0x0020)(Edit, DisableEditOnInstance, NativeAccessSpecifierPublic)
	TSubclassOf<class UDamageType>                M_pDamageType_Zapomatic;                           // 0x0148(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TSubclassOf<class UDamageType>                M_pDamageType_Disintegrator;                       // 0x0150(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TSubclassOf<class UDamageType>                M_pDamageType_AnalProbe;                           // 0x0158(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TSubclassOf<class UDamageType>                M_pDamageType_IonDetonator;                        // 0x0160(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TSubclassOf<class UDamageType>                M_pDamageType_DeathRay;                            // 0x0168(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TSubclassOf<class UDamageType>                M_pDamageType_SonicBoom;                           // 0x0170(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TSubclassOf<class UDamageType>                M_pDamageType_QuantumDeconstructor;                // 0x0178(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TSubclassOf<class UDamageType>                M_pDamageType_PK;                                  // 0x0180(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TSubclassOf<class UDamageType>                M_pDamageType_BrainExtract;                        // 0x0188(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class ABFGGameState*                          M_pGameState;                                      // 0x0190(0x0008)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TMap<EBFGGameStatistic, struct FBFGGameStatisticData> M_aStats;                                          // 0x0198(0x0050)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Protected, NativeAccessSpecifierProtected)
	struct FDateTime                              M_oHoursPlayedStartTime;                           // 0x01E8(0x0008)(ZeroConstructor, Transient, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)

public:
	void IncreaseStatistic(EBFGGameStatistic _eGameStat, float _fAmount);
	void OnCreate();
	void SetStatistic(EBFGGameStatistic _eGameStat, float _fValue);

	const TMap<EBFGGameStatistic, struct FBFGGameStatisticData> GetAllStatistics() const;
	struct FBFGGameStatisticData GetStatistic(EBFGGameStatistic _eGameStat) const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"BFGStatisticsManager">();
	}
	static class UBFGStatisticsManager* GetDefaultObj()
	{
		return GetDefaultObjImpl<UBFGStatisticsManager>();
	}
};
static_assert(alignof(UBFGStatisticsManager) == 0x000008, "Wrong alignment on UBFGStatisticsManager");
static_assert(sizeof(UBFGStatisticsManager) == 0x0001F0, "Wrong size on UBFGStatisticsManager");
static_assert(offsetof(UBFGStatisticsManager, M_oGameStatisticChanged) == 0x000030, "Member 'UBFGStatisticsManager::M_oGameStatisticChanged' has a wrong offset!");
static_assert(offsetof(UBFGStatisticsManager, M_tTagCivilian) == 0x000048, "Member 'UBFGStatisticsManager::M_tTagCivilian' has a wrong offset!");
static_assert(offsetof(UBFGStatisticsManager, M_tTagFarmer) == 0x000068, "Member 'UBFGStatisticsManager::M_tTagFarmer' has a wrong offset!");
static_assert(offsetof(UBFGStatisticsManager, M_tTagCop) == 0x000088, "Member 'UBFGStatisticsManager::M_tTagCop' has a wrong offset!");
static_assert(offsetof(UBFGStatisticsManager, M_tTagSoldier) == 0x0000A8, "Member 'UBFGStatisticsManager::M_tTagSoldier' has a wrong offset!");
static_assert(offsetof(UBFGStatisticsManager, M_tTagAgent) == 0x0000C8, "Member 'UBFGStatisticsManager::M_tTagAgent' has a wrong offset!");
static_assert(offsetof(UBFGStatisticsManager, M_tTagMutant) == 0x0000E8, "Member 'UBFGStatisticsManager::M_tTagMutant' has a wrong offset!");
static_assert(offsetof(UBFGStatisticsManager, M_tTagTank) == 0x000108, "Member 'UBFGStatisticsManager::M_tTagTank' has a wrong offset!");
static_assert(offsetof(UBFGStatisticsManager, M_tTagPowerSuit) == 0x000128, "Member 'UBFGStatisticsManager::M_tTagPowerSuit' has a wrong offset!");
static_assert(offsetof(UBFGStatisticsManager, M_pDamageType_Zapomatic) == 0x000148, "Member 'UBFGStatisticsManager::M_pDamageType_Zapomatic' has a wrong offset!");
static_assert(offsetof(UBFGStatisticsManager, M_pDamageType_Disintegrator) == 0x000150, "Member 'UBFGStatisticsManager::M_pDamageType_Disintegrator' has a wrong offset!");
static_assert(offsetof(UBFGStatisticsManager, M_pDamageType_AnalProbe) == 0x000158, "Member 'UBFGStatisticsManager::M_pDamageType_AnalProbe' has a wrong offset!");
static_assert(offsetof(UBFGStatisticsManager, M_pDamageType_IonDetonator) == 0x000160, "Member 'UBFGStatisticsManager::M_pDamageType_IonDetonator' has a wrong offset!");
static_assert(offsetof(UBFGStatisticsManager, M_pDamageType_DeathRay) == 0x000168, "Member 'UBFGStatisticsManager::M_pDamageType_DeathRay' has a wrong offset!");
static_assert(offsetof(UBFGStatisticsManager, M_pDamageType_SonicBoom) == 0x000170, "Member 'UBFGStatisticsManager::M_pDamageType_SonicBoom' has a wrong offset!");
static_assert(offsetof(UBFGStatisticsManager, M_pDamageType_QuantumDeconstructor) == 0x000178, "Member 'UBFGStatisticsManager::M_pDamageType_QuantumDeconstructor' has a wrong offset!");
static_assert(offsetof(UBFGStatisticsManager, M_pDamageType_PK) == 0x000180, "Member 'UBFGStatisticsManager::M_pDamageType_PK' has a wrong offset!");
static_assert(offsetof(UBFGStatisticsManager, M_pDamageType_BrainExtract) == 0x000188, "Member 'UBFGStatisticsManager::M_pDamageType_BrainExtract' has a wrong offset!");
static_assert(offsetof(UBFGStatisticsManager, M_pGameState) == 0x000190, "Member 'UBFGStatisticsManager::M_pGameState' has a wrong offset!");
static_assert(offsetof(UBFGStatisticsManager, M_aStats) == 0x000198, "Member 'UBFGStatisticsManager::M_aStats' has a wrong offset!");
static_assert(offsetof(UBFGStatisticsManager, M_oHoursPlayedStartTime) == 0x0001E8, "Member 'UBFGStatisticsManager::M_oHoursPlayedStartTime' has a wrong offset!");

// Class BFGCore.BFGSubtitleVisibilityManager
// 0x0008 (0x0030 - 0x0028)
class UBFGSubtitleVisibilityManager final : public UObject
{
public:
	uint8                                         Pad_28[0x8];                                       // 0x0028(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"BFGSubtitleVisibilityManager">();
	}
	static class UBFGSubtitleVisibilityManager* GetDefaultObj()
	{
		return GetDefaultObjImpl<UBFGSubtitleVisibilityManager>();
	}
};
static_assert(alignof(UBFGSubtitleVisibilityManager) == 0x000008, "Wrong alignment on UBFGSubtitleVisibilityManager");
static_assert(sizeof(UBFGSubtitleVisibilityManager) == 0x000030, "Wrong size on UBFGSubtitleVisibilityManager");

// Class BFGCore.BFGTankInterface
// 0x0000 (0x0028 - 0x0028)
class IBFGTankInterface final : public IInterface
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"BFGTankInterface">();
	}
	static class IBFGTankInterface* GetDefaultObj()
	{
		return GetDefaultObjImpl<IBFGTankInterface>();
	}
};
static_assert(alignof(IBFGTankInterface) == 0x000008, "Wrong alignment on IBFGTankInterface");
static_assert(sizeof(IBFGTankInterface) == 0x000028, "Wrong size on IBFGTankInterface");

// Class BFGCore.BFGTargetableBuildingPart
// 0x0008 (0x03E0 - 0x03D8)
class ABFGTargetableBuildingPart final : public AActor
{
public:
	class UBFGActorComponent_BuildingLevel*       M_pBuildingLevel;                                  // 0x03D8(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"BFGTargetableBuildingPart">();
	}
	static class ABFGTargetableBuildingPart* GetDefaultObj()
	{
		return GetDefaultObjImpl<ABFGTargetableBuildingPart>();
	}
};
static_assert(alignof(ABFGTargetableBuildingPart) == 0x000008, "Wrong alignment on ABFGTargetableBuildingPart");
static_assert(sizeof(ABFGTargetableBuildingPart) == 0x0003E0, "Wrong size on ABFGTargetableBuildingPart");
static_assert(offsetof(ABFGTargetableBuildingPart, M_pBuildingLevel) == 0x0003D8, "Member 'ABFGTargetableBuildingPart::M_pBuildingLevel' has a wrong offset!");

// Class BFGCore.BFGTaskNode_Action_PatternTest
// 0x0000 (0x00D8 - 0x00D8)
class UBFGTaskNode_Action_PatternTest final : public UBFGTaskNode_Action_MetaPattern
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"BFGTaskNode_Action_PatternTest">();
	}
	static class UBFGTaskNode_Action_PatternTest* GetDefaultObj()
	{
		return GetDefaultObjImpl<UBFGTaskNode_Action_PatternTest>();
	}
};
static_assert(alignof(UBFGTaskNode_Action_PatternTest) == 0x000008, "Wrong alignment on UBFGTaskNode_Action_PatternTest");
static_assert(sizeof(UBFGTaskNode_Action_PatternTest) == 0x0000D8, "Wrong size on UBFGTaskNode_Action_PatternTest");

// Class BFGCore.BFGTaskNode_Boss_EvasionStop
// 0x0000 (0x00A0 - 0x00A0)
class UBFGTaskNode_Boss_EvasionStop final : public UBFGTaskNode_BossBase
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"BFGTaskNode_Boss_EvasionStop">();
	}
	static class UBFGTaskNode_Boss_EvasionStop* GetDefaultObj()
	{
		return GetDefaultObjImpl<UBFGTaskNode_Boss_EvasionStop>();
	}
};
static_assert(alignof(UBFGTaskNode_Boss_EvasionStop) == 0x000008, "Wrong alignment on UBFGTaskNode_Boss_EvasionStop");
static_assert(sizeof(UBFGTaskNode_Boss_EvasionStop) == 0x0000A0, "Wrong size on UBFGTaskNode_Boss_EvasionStop");

// Class BFGCore.BFGTaskNode_Boss_Finish_Step
// 0x0000 (0x0078 - 0x0078)
class UBFGTaskNode_Boss_Finish_Step final : public UBFGBTBaseTaskNode
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"BFGTaskNode_Boss_Finish_Step">();
	}
	static class UBFGTaskNode_Boss_Finish_Step* GetDefaultObj()
	{
		return GetDefaultObjImpl<UBFGTaskNode_Boss_Finish_Step>();
	}
};
static_assert(alignof(UBFGTaskNode_Boss_Finish_Step) == 0x000008, "Wrong alignment on UBFGTaskNode_Boss_Finish_Step");
static_assert(sizeof(UBFGTaskNode_Boss_Finish_Step) == 0x000078, "Wrong size on UBFGTaskNode_Boss_Finish_Step");

// Class BFGCore.BFGTaskNode_Boss_NasalProbe
// 0x0000 (0x00A0 - 0x00A0)
class UBFGTaskNode_Boss_NasalProbe final : public UBFGTaskNode_BossBase
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"BFGTaskNode_Boss_NasalProbe">();
	}
	static class UBFGTaskNode_Boss_NasalProbe* GetDefaultObj()
	{
		return GetDefaultObjImpl<UBFGTaskNode_Boss_NasalProbe>();
	}
};
static_assert(alignof(UBFGTaskNode_Boss_NasalProbe) == 0x000008, "Wrong alignment on UBFGTaskNode_Boss_NasalProbe");
static_assert(sizeof(UBFGTaskNode_Boss_NasalProbe) == 0x0000A0, "Wrong size on UBFGTaskNode_Boss_NasalProbe");

// Class BFGCore.BFGTaskNode_Boss_RequestSupport
// 0x0000 (0x00A0 - 0x00A0)
class UBFGTaskNode_Boss_RequestSupport final : public UBFGTaskNode_BossBase
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"BFGTaskNode_Boss_RequestSupport">();
	}
	static class UBFGTaskNode_Boss_RequestSupport* GetDefaultObj()
	{
		return GetDefaultObjImpl<UBFGTaskNode_Boss_RequestSupport>();
	}
};
static_assert(alignof(UBFGTaskNode_Boss_RequestSupport) == 0x000008, "Wrong alignment on UBFGTaskNode_Boss_RequestSupport");
static_assert(sizeof(UBFGTaskNode_Boss_RequestSupport) == 0x0000A0, "Wrong size on UBFGTaskNode_Boss_RequestSupport");

// Class BFGCore.BFGTaskNode_Boss_RoboprezPhaseTransition0
// 0x0000 (0x00A0 - 0x00A0)
class UBFGTaskNode_Boss_RoboprezPhaseTransition0 final : public UBFGTaskNode_BossBase
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"BFGTaskNode_Boss_RoboprezPhaseTransition0">();
	}
	static class UBFGTaskNode_Boss_RoboprezPhaseTransition0* GetDefaultObj()
	{
		return GetDefaultObjImpl<UBFGTaskNode_Boss_RoboprezPhaseTransition0>();
	}
};
static_assert(alignof(UBFGTaskNode_Boss_RoboprezPhaseTransition0) == 0x000008, "Wrong alignment on UBFGTaskNode_Boss_RoboprezPhaseTransition0");
static_assert(sizeof(UBFGTaskNode_Boss_RoboprezPhaseTransition0) == 0x0000A0, "Wrong size on UBFGTaskNode_Boss_RoboprezPhaseTransition0");

// Class BFGCore.BFGTaskNode_BossActiveDrainPSI
// 0x0000 (0x00A0 - 0x00A0)
class UBFGTaskNode_BossActiveDrainPSI final : public UBFGTaskNode_BossBase
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"BFGTaskNode_BossActiveDrainPSI">();
	}
	static class UBFGTaskNode_BossActiveDrainPSI* GetDefaultObj()
	{
		return GetDefaultObjImpl<UBFGTaskNode_BossActiveDrainPSI>();
	}
};
static_assert(alignof(UBFGTaskNode_BossActiveDrainPSI) == 0x000008, "Wrong alignment on UBFGTaskNode_BossActiveDrainPSI");
static_assert(sizeof(UBFGTaskNode_BossActiveDrainPSI) == 0x0000A0, "Wrong size on UBFGTaskNode_BossActiveDrainPSI");

// Class BFGCore.BFGTaskNode_BossCharge_Enrage
// 0x0008 (0x00A8 - 0x00A0)
class UBFGTaskNode_BossCharge_Enrage final : public UBFGTaskNode_BossBase
{
public:
	float                                         M_fActionWaitTime;                                 // 0x00A0(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_A4[0x4];                                       // 0x00A4(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"BFGTaskNode_BossCharge_Enrage">();
	}
	static class UBFGTaskNode_BossCharge_Enrage* GetDefaultObj()
	{
		return GetDefaultObjImpl<UBFGTaskNode_BossCharge_Enrage>();
	}
};
static_assert(alignof(UBFGTaskNode_BossCharge_Enrage) == 0x000008, "Wrong alignment on UBFGTaskNode_BossCharge_Enrage");
static_assert(sizeof(UBFGTaskNode_BossCharge_Enrage) == 0x0000A8, "Wrong size on UBFGTaskNode_BossCharge_Enrage");
static_assert(offsetof(UBFGTaskNode_BossCharge_Enrage, M_fActionWaitTime) == 0x0000A0, "Member 'UBFGTaskNode_BossCharge_Enrage::M_fActionWaitTime' has a wrong offset!");

// Class BFGCore.BFGTaskNode_BossFirePattern
// 0x0010 (0x0088 - 0x0078)
class UBFGTaskNode_BossFirePattern final : public UBFGBTBaseTaskNode
{
public:
	int32                                         M_iWeaponIndex;                                    // 0x0078(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         M_iWeaponPatternIndex;                             // 0x007C(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_80[0x8];                                       // 0x0080(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void OnPatternFinished(class ABFGWeapon* _pWeapon);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"BFGTaskNode_BossFirePattern">();
	}
	static class UBFGTaskNode_BossFirePattern* GetDefaultObj()
	{
		return GetDefaultObjImpl<UBFGTaskNode_BossFirePattern>();
	}
};
static_assert(alignof(UBFGTaskNode_BossFirePattern) == 0x000008, "Wrong alignment on UBFGTaskNode_BossFirePattern");
static_assert(sizeof(UBFGTaskNode_BossFirePattern) == 0x000088, "Wrong size on UBFGTaskNode_BossFirePattern");
static_assert(offsetof(UBFGTaskNode_BossFirePattern, M_iWeaponIndex) == 0x000078, "Member 'UBFGTaskNode_BossFirePattern::M_iWeaponIndex' has a wrong offset!");
static_assert(offsetof(UBFGTaskNode_BossFirePattern, M_iWeaponPatternIndex) == 0x00007C, "Member 'UBFGTaskNode_BossFirePattern::M_iWeaponPatternIndex' has a wrong offset!");

// Class BFGCore.BFGTaskNode_EndBossPhase
// 0x0000 (0x0078 - 0x0078)
class UBFGTaskNode_EndBossPhase final : public UBFGBTBaseTaskNode
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"BFGTaskNode_EndBossPhase">();
	}
	static class UBFGTaskNode_EndBossPhase* GetDefaultObj()
	{
		return GetDefaultObjImpl<UBFGTaskNode_EndBossPhase>();
	}
};
static_assert(alignof(UBFGTaskNode_EndBossPhase) == 0x000008, "Wrong alignment on UBFGTaskNode_EndBossPhase");
static_assert(sizeof(UBFGTaskNode_EndBossPhase) == 0x000078, "Wrong size on UBFGTaskNode_EndBossPhase");

// Class BFGCore.BFGTaskNode_EnemyCirclingTarget
// 0x0030 (0x00A8 - 0x0078)
class UBFGTaskNode_EnemyCirclingTarget final : public UBFGBTBaseTaskNode
{
public:
	float                                         M_fCirclingTimeOut;                                // 0x0078(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         M_fCirclingSpeed;                                  // 0x007C(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FBlackboardKeySelector                 M_BBKeyAttackTarget;                               // 0x0080(0x0028)(Edit, BlueprintVisible, Protected, NativeAccessSpecifierProtected)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"BFGTaskNode_EnemyCirclingTarget">();
	}
	static class UBFGTaskNode_EnemyCirclingTarget* GetDefaultObj()
	{
		return GetDefaultObjImpl<UBFGTaskNode_EnemyCirclingTarget>();
	}
};
static_assert(alignof(UBFGTaskNode_EnemyCirclingTarget) == 0x000008, "Wrong alignment on UBFGTaskNode_EnemyCirclingTarget");
static_assert(sizeof(UBFGTaskNode_EnemyCirclingTarget) == 0x0000A8, "Wrong size on UBFGTaskNode_EnemyCirclingTarget");
static_assert(offsetof(UBFGTaskNode_EnemyCirclingTarget, M_fCirclingTimeOut) == 0x000078, "Member 'UBFGTaskNode_EnemyCirclingTarget::M_fCirclingTimeOut' has a wrong offset!");
static_assert(offsetof(UBFGTaskNode_EnemyCirclingTarget, M_fCirclingSpeed) == 0x00007C, "Member 'UBFGTaskNode_EnemyCirclingTarget::M_fCirclingSpeed' has a wrong offset!");
static_assert(offsetof(UBFGTaskNode_EnemyCirclingTarget, M_BBKeyAttackTarget) == 0x000080, "Member 'UBFGTaskNode_EnemyCirclingTarget::M_BBKeyAttackTarget' has a wrong offset!");

// Class BFGCore.BFGTaskNode_Hypnotized
// 0x0008 (0x0080 - 0x0078)
class UBFGTaskNode_Hypnotized final : public UBFGBTBaseTaskNode
{
public:
	EBFGHypnotizeState_NPC                        M_hypnotizeState;                                  // 0x0078(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_79[0x7];                                       // 0x0079(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"BFGTaskNode_Hypnotized">();
	}
	static class UBFGTaskNode_Hypnotized* GetDefaultObj()
	{
		return GetDefaultObjImpl<UBFGTaskNode_Hypnotized>();
	}
};
static_assert(alignof(UBFGTaskNode_Hypnotized) == 0x000008, "Wrong alignment on UBFGTaskNode_Hypnotized");
static_assert(sizeof(UBFGTaskNode_Hypnotized) == 0x000080, "Wrong size on UBFGTaskNode_Hypnotized");
static_assert(offsetof(UBFGTaskNode_Hypnotized, M_hypnotizeState) == 0x000078, "Member 'UBFGTaskNode_Hypnotized::M_hypnotizeState' has a wrong offset!");

// Class BFGCore.BFGTaskNode_MoveToCrowdLifeStation
// 0x0028 (0x00A0 - 0x0078)
class UBFGTaskNode_MoveToCrowdLifeStation final : public UBFGBTBaseTaskNode
{
public:
	struct FBlackboardKeySelector                 M_BBKey_CrowdLifeStation;                          // 0x0078(0x0028)(Edit, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"BFGTaskNode_MoveToCrowdLifeStation">();
	}
	static class UBFGTaskNode_MoveToCrowdLifeStation* GetDefaultObj()
	{
		return GetDefaultObjImpl<UBFGTaskNode_MoveToCrowdLifeStation>();
	}
};
static_assert(alignof(UBFGTaskNode_MoveToCrowdLifeStation) == 0x000008, "Wrong alignment on UBFGTaskNode_MoveToCrowdLifeStation");
static_assert(sizeof(UBFGTaskNode_MoveToCrowdLifeStation) == 0x0000A0, "Wrong size on UBFGTaskNode_MoveToCrowdLifeStation");
static_assert(offsetof(UBFGTaskNode_MoveToCrowdLifeStation, M_BBKey_CrowdLifeStation) == 0x000078, "Member 'UBFGTaskNode_MoveToCrowdLifeStation::M_BBKey_CrowdLifeStation' has a wrong offset!");

// Class BFGCore.BFGTaskNode_MoveToLocationThroughNetworkPath
// 0x0050 (0x00C8 - 0x0078)
class UBFGTaskNode_MoveToLocationThroughNetworkPath final : public UBFGBTBaseTaskNode
{
public:
	struct FBlackboardKeySelector                 M_BBKey_MoveToLocation;                            // 0x0078(0x0028)(Edit, NativeAccessSpecifierPublic)
	struct FBlackboardKeySelector                 M_BBKey_CrowdFlowAgent;                            // 0x00A0(0x0028)(Edit, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"BFGTaskNode_MoveToLocationThroughNetworkPath">();
	}
	static class UBFGTaskNode_MoveToLocationThroughNetworkPath* GetDefaultObj()
	{
		return GetDefaultObjImpl<UBFGTaskNode_MoveToLocationThroughNetworkPath>();
	}
};
static_assert(alignof(UBFGTaskNode_MoveToLocationThroughNetworkPath) == 0x000008, "Wrong alignment on UBFGTaskNode_MoveToLocationThroughNetworkPath");
static_assert(sizeof(UBFGTaskNode_MoveToLocationThroughNetworkPath) == 0x0000C8, "Wrong size on UBFGTaskNode_MoveToLocationThroughNetworkPath");
static_assert(offsetof(UBFGTaskNode_MoveToLocationThroughNetworkPath, M_BBKey_MoveToLocation) == 0x000078, "Member 'UBFGTaskNode_MoveToLocationThroughNetworkPath::M_BBKey_MoveToLocation' has a wrong offset!");
static_assert(offsetof(UBFGTaskNode_MoveToLocationThroughNetworkPath, M_BBKey_CrowdFlowAgent) == 0x0000A0, "Member 'UBFGTaskNode_MoveToLocationThroughNetworkPath::M_BBKey_CrowdFlowAgent' has a wrong offset!");

// Class BFGCore.BFGTaskNode_PlayAlertAnimation
// 0x0028 (0x00A0 - 0x0078)
class UBFGTaskNode_PlayAlertAnimation final : public UBFGBTBaseTaskNode
{
public:
	struct FBlackboardKeySelector                 M_bbKeyTarget;                                     // 0x0078(0x0028)(Edit, BlueprintVisible, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"BFGTaskNode_PlayAlertAnimation">();
	}
	static class UBFGTaskNode_PlayAlertAnimation* GetDefaultObj()
	{
		return GetDefaultObjImpl<UBFGTaskNode_PlayAlertAnimation>();
	}
};
static_assert(alignof(UBFGTaskNode_PlayAlertAnimation) == 0x000008, "Wrong alignment on UBFGTaskNode_PlayAlertAnimation");
static_assert(sizeof(UBFGTaskNode_PlayAlertAnimation) == 0x0000A0, "Wrong size on UBFGTaskNode_PlayAlertAnimation");
static_assert(offsetof(UBFGTaskNode_PlayAlertAnimation, M_bbKeyTarget) == 0x000078, "Member 'UBFGTaskNode_PlayAlertAnimation::M_bbKeyTarget' has a wrong offset!");

// Class BFGCore.BFGTaskNode_PlayBumpAnimation
// 0x0030 (0x00A8 - 0x0078)
class UBFGTaskNode_PlayBumpAnimation final : public UBFGBTBaseTaskNode
{
public:
	struct FBlackboardKeySelector                 M_bbKeyTarget;                                     // 0x0078(0x0028)(Edit, BlueprintVisible, NativeAccessSpecifierPublic)
	float                                         M_fVelocityMultiplier;                             // 0x00A0(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_A4[0x4];                                       // 0x00A4(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"BFGTaskNode_PlayBumpAnimation">();
	}
	static class UBFGTaskNode_PlayBumpAnimation* GetDefaultObj()
	{
		return GetDefaultObjImpl<UBFGTaskNode_PlayBumpAnimation>();
	}
};
static_assert(alignof(UBFGTaskNode_PlayBumpAnimation) == 0x000008, "Wrong alignment on UBFGTaskNode_PlayBumpAnimation");
static_assert(sizeof(UBFGTaskNode_PlayBumpAnimation) == 0x0000A8, "Wrong size on UBFGTaskNode_PlayBumpAnimation");
static_assert(offsetof(UBFGTaskNode_PlayBumpAnimation, M_bbKeyTarget) == 0x000078, "Member 'UBFGTaskNode_PlayBumpAnimation::M_bbKeyTarget' has a wrong offset!");
static_assert(offsetof(UBFGTaskNode_PlayBumpAnimation, M_fVelocityMultiplier) == 0x0000A0, "Member 'UBFGTaskNode_PlayBumpAnimation::M_fVelocityMultiplier' has a wrong offset!");

// Class BFGCore.BFGTaskNode_PlayEvadeAnimation
// 0x0030 (0x00A8 - 0x0078)
class UBFGTaskNode_PlayEvadeAnimation final : public UBFGBTBaseTaskNode
{
public:
	struct FBlackboardKeySelector                 M_bbKeyTarget;                                     // 0x0078(0x0028)(Edit, BlueprintVisible, NativeAccessSpecifierPublic)
	EBFGEvadeDirectionMode                        M_eEvadeDirection;                                 // 0x00A0(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          M_bDrawDebug;                                      // 0x00A1(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_A2[0x6];                                       // 0x00A2(0x0006)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"BFGTaskNode_PlayEvadeAnimation">();
	}
	static class UBFGTaskNode_PlayEvadeAnimation* GetDefaultObj()
	{
		return GetDefaultObjImpl<UBFGTaskNode_PlayEvadeAnimation>();
	}
};
static_assert(alignof(UBFGTaskNode_PlayEvadeAnimation) == 0x000008, "Wrong alignment on UBFGTaskNode_PlayEvadeAnimation");
static_assert(sizeof(UBFGTaskNode_PlayEvadeAnimation) == 0x0000A8, "Wrong size on UBFGTaskNode_PlayEvadeAnimation");
static_assert(offsetof(UBFGTaskNode_PlayEvadeAnimation, M_bbKeyTarget) == 0x000078, "Member 'UBFGTaskNode_PlayEvadeAnimation::M_bbKeyTarget' has a wrong offset!");
static_assert(offsetof(UBFGTaskNode_PlayEvadeAnimation, M_eEvadeDirection) == 0x0000A0, "Member 'UBFGTaskNode_PlayEvadeAnimation::M_eEvadeDirection' has a wrong offset!");
static_assert(offsetof(UBFGTaskNode_PlayEvadeAnimation, M_bDrawDebug) == 0x0000A1, "Member 'UBFGTaskNode_PlayEvadeAnimation::M_bDrawDebug' has a wrong offset!");

// Class BFGCore.BFGTaskNode_PlayLeaveCrowdLifeStationAnimation
// 0x0050 (0x00C8 - 0x0078)
class UBFGTaskNode_PlayLeaveCrowdLifeStationAnimation final : public UBFGBTBaseTaskNode
{
public:
	struct FBlackboardKeySelector                 M_BBKeyState;                                      // 0x0078(0x0028)(Edit, NativeAccessSpecifierPublic)
	struct FBlackboardKeySelector                 M_bbKeyPlayAlertAnimation;                         // 0x00A0(0x0028)(Edit, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"BFGTaskNode_PlayLeaveCrowdLifeStationAnimation">();
	}
	static class UBFGTaskNode_PlayLeaveCrowdLifeStationAnimation* GetDefaultObj()
	{
		return GetDefaultObjImpl<UBFGTaskNode_PlayLeaveCrowdLifeStationAnimation>();
	}
};
static_assert(alignof(UBFGTaskNode_PlayLeaveCrowdLifeStationAnimation) == 0x000008, "Wrong alignment on UBFGTaskNode_PlayLeaveCrowdLifeStationAnimation");
static_assert(sizeof(UBFGTaskNode_PlayLeaveCrowdLifeStationAnimation) == 0x0000C8, "Wrong size on UBFGTaskNode_PlayLeaveCrowdLifeStationAnimation");
static_assert(offsetof(UBFGTaskNode_PlayLeaveCrowdLifeStationAnimation, M_BBKeyState) == 0x000078, "Member 'UBFGTaskNode_PlayLeaveCrowdLifeStationAnimation::M_BBKeyState' has a wrong offset!");
static_assert(offsetof(UBFGTaskNode_PlayLeaveCrowdLifeStationAnimation, M_bbKeyPlayAlertAnimation) == 0x0000A0, "Member 'UBFGTaskNode_PlayLeaveCrowdLifeStationAnimation::M_bbKeyPlayAlertAnimation' has a wrong offset!");

// Class BFGCore.BFGTaskNode_SetBBEnvQuery
// 0x0030 (0x00A8 - 0x0078)
class UBFGTaskNode_SetBBEnvQuery final : public UBFGBTBaseTaskNode
{
public:
	class UEnvQuery*                              M_pEnvQuery;                                       // 0x0078(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	struct FBlackboardKeySelector                 M_BBKey;                                           // 0x0080(0x0028)(Edit, BlueprintVisible, Protected, NativeAccessSpecifierProtected)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"BFGTaskNode_SetBBEnvQuery">();
	}
	static class UBFGTaskNode_SetBBEnvQuery* GetDefaultObj()
	{
		return GetDefaultObjImpl<UBFGTaskNode_SetBBEnvQuery>();
	}
};
static_assert(alignof(UBFGTaskNode_SetBBEnvQuery) == 0x000008, "Wrong alignment on UBFGTaskNode_SetBBEnvQuery");
static_assert(sizeof(UBFGTaskNode_SetBBEnvQuery) == 0x0000A8, "Wrong size on UBFGTaskNode_SetBBEnvQuery");
static_assert(offsetof(UBFGTaskNode_SetBBEnvQuery, M_pEnvQuery) == 0x000078, "Member 'UBFGTaskNode_SetBBEnvQuery::M_pEnvQuery' has a wrong offset!");
static_assert(offsetof(UBFGTaskNode_SetBBEnvQuery, M_BBKey) == 0x000080, "Member 'UBFGTaskNode_SetBBEnvQuery::M_BBKey' has a wrong offset!");

// Class BFGCore.BFGTaskNode_SetBehaviorState
// 0x00B0 (0x0128 - 0x0078)
class UBFGTaskNode_SetBehaviorState final : public UBFGBTBaseTaskNode
{
public:
	struct FBFGBehaviorState                      M_behaviorState;                                   // 0x0078(0x0058)(Edit, BlueprintVisible, NativeAccessSpecifierPublic)
	struct FBlackboardKeySelector                 M_BBKeyState;                                      // 0x00D0(0x0028)(Edit, BlueprintVisible, NativeAccessSpecifierPublic)
	struct FBlackboardKeySelector                 M_bbKeySuspiciousActor;                            // 0x00F8(0x0028)(Edit, BlueprintVisible, NativeAccessSpecifierPublic)
	float                                         M_fTimeout;                                        // 0x0120(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_124[0x4];                                      // 0x0124(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"BFGTaskNode_SetBehaviorState">();
	}
	static class UBFGTaskNode_SetBehaviorState* GetDefaultObj()
	{
		return GetDefaultObjImpl<UBFGTaskNode_SetBehaviorState>();
	}
};
static_assert(alignof(UBFGTaskNode_SetBehaviorState) == 0x000008, "Wrong alignment on UBFGTaskNode_SetBehaviorState");
static_assert(sizeof(UBFGTaskNode_SetBehaviorState) == 0x000128, "Wrong size on UBFGTaskNode_SetBehaviorState");
static_assert(offsetof(UBFGTaskNode_SetBehaviorState, M_behaviorState) == 0x000078, "Member 'UBFGTaskNode_SetBehaviorState::M_behaviorState' has a wrong offset!");
static_assert(offsetof(UBFGTaskNode_SetBehaviorState, M_BBKeyState) == 0x0000D0, "Member 'UBFGTaskNode_SetBehaviorState::M_BBKeyState' has a wrong offset!");
static_assert(offsetof(UBFGTaskNode_SetBehaviorState, M_bbKeySuspiciousActor) == 0x0000F8, "Member 'UBFGTaskNode_SetBehaviorState::M_bbKeySuspiciousActor' has a wrong offset!");
static_assert(offsetof(UBFGTaskNode_SetBehaviorState, M_fTimeout) == 0x000120, "Member 'UBFGTaskNode_SetBehaviorState::M_fTimeout' has a wrong offset!");

// Class BFGCore.BFGTaskNode_SetMovementMode
// 0x0008 (0x0080 - 0x0078)
class UBFGTaskNode_SetMovementMode final : public UBFGBTBaseTaskNode
{
public:
	EMovementMode                                 M_eMovementMode;                                   // 0x0078(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          M_bAlwaysFail;                                     // 0x0079(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_7A[0x6];                                       // 0x007A(0x0006)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"BFGTaskNode_SetMovementMode">();
	}
	static class UBFGTaskNode_SetMovementMode* GetDefaultObj()
	{
		return GetDefaultObjImpl<UBFGTaskNode_SetMovementMode>();
	}
};
static_assert(alignof(UBFGTaskNode_SetMovementMode) == 0x000008, "Wrong alignment on UBFGTaskNode_SetMovementMode");
static_assert(sizeof(UBFGTaskNode_SetMovementMode) == 0x000080, "Wrong size on UBFGTaskNode_SetMovementMode");
static_assert(offsetof(UBFGTaskNode_SetMovementMode, M_eMovementMode) == 0x000078, "Member 'UBFGTaskNode_SetMovementMode::M_eMovementMode' has a wrong offset!");
static_assert(offsetof(UBFGTaskNode_SetMovementMode, M_bAlwaysFail) == 0x000079, "Member 'UBFGTaskNode_SetMovementMode::M_bAlwaysFail' has a wrong offset!");

// Class BFGCore.BFGTaskNode_SetMovementProperties
// 0x0030 (0x00A8 - 0x0078)
class UBFGTaskNode_SetMovementProperties final : public UBFGBTBaseTaskNode
{
public:
	EBFGNPCCharacter_MoveSpeed                    M_moveSpeed;                                       // 0x0078(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          M_bOrientRotationToMovement;                       // 0x0079(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          M_bEnableAimCatchUpRotation;                       // 0x007A(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          M_bFocusActor;                                     // 0x007B(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_7C[0x4];                                       // 0x007C(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	struct FBlackboardKeySelector                 M_BBKeyFocusActor;                                 // 0x0080(0x0028)(Edit, Protected, NativeAccessSpecifierProtected)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"BFGTaskNode_SetMovementProperties">();
	}
	static class UBFGTaskNode_SetMovementProperties* GetDefaultObj()
	{
		return GetDefaultObjImpl<UBFGTaskNode_SetMovementProperties>();
	}
};
static_assert(alignof(UBFGTaskNode_SetMovementProperties) == 0x000008, "Wrong alignment on UBFGTaskNode_SetMovementProperties");
static_assert(sizeof(UBFGTaskNode_SetMovementProperties) == 0x0000A8, "Wrong size on UBFGTaskNode_SetMovementProperties");
static_assert(offsetof(UBFGTaskNode_SetMovementProperties, M_moveSpeed) == 0x000078, "Member 'UBFGTaskNode_SetMovementProperties::M_moveSpeed' has a wrong offset!");
static_assert(offsetof(UBFGTaskNode_SetMovementProperties, M_bOrientRotationToMovement) == 0x000079, "Member 'UBFGTaskNode_SetMovementProperties::M_bOrientRotationToMovement' has a wrong offset!");
static_assert(offsetof(UBFGTaskNode_SetMovementProperties, M_bEnableAimCatchUpRotation) == 0x00007A, "Member 'UBFGTaskNode_SetMovementProperties::M_bEnableAimCatchUpRotation' has a wrong offset!");
static_assert(offsetof(UBFGTaskNode_SetMovementProperties, M_bFocusActor) == 0x00007B, "Member 'UBFGTaskNode_SetMovementProperties::M_bFocusActor' has a wrong offset!");
static_assert(offsetof(UBFGTaskNode_SetMovementProperties, M_BBKeyFocusActor) == 0x000080, "Member 'UBFGTaskNode_SetMovementProperties::M_BBKeyFocusActor' has a wrong offset!");

// Class BFGCore.BFGTaskNode_SpawnAOE
// 0x0010 (0x0088 - 0x0078)
class UBFGTaskNode_SpawnAOE final : public UBFGBTBaseTaskNode
{
public:
	TSubclassOf<class ABFGAOE>                    M_pAOE;                                            // 0x0078(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_80[0x8];                                       // 0x0080(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"BFGTaskNode_SpawnAOE">();
	}
	static class UBFGTaskNode_SpawnAOE* GetDefaultObj()
	{
		return GetDefaultObjImpl<UBFGTaskNode_SpawnAOE>();
	}
};
static_assert(alignof(UBFGTaskNode_SpawnAOE) == 0x000008, "Wrong alignment on UBFGTaskNode_SpawnAOE");
static_assert(sizeof(UBFGTaskNode_SpawnAOE) == 0x000088, "Wrong size on UBFGTaskNode_SpawnAOE");
static_assert(offsetof(UBFGTaskNode_SpawnAOE, M_pAOE) == 0x000078, "Member 'UBFGTaskNode_SpawnAOE::M_pAOE' has a wrong offset!");

// Class BFGCore.BFGTaskNode_SpawnReinforcements
// 0x0030 (0x00D0 - 0x00A0)
class UBFGTaskNode_SpawnReinforcements final : public UBFGTaskNode_BossBase
{
public:
	struct FBlackboardKeySelector                 M_BBCanCallReinforcements;                         // 0x00A0(0x0028)(Edit, BlueprintVisible, NativeAccessSpecifierPublic)
	uint8                                         Pad_C8[0x8];                                       // 0x00C8(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"BFGTaskNode_SpawnReinforcements">();
	}
	static class UBFGTaskNode_SpawnReinforcements* GetDefaultObj()
	{
		return GetDefaultObjImpl<UBFGTaskNode_SpawnReinforcements>();
	}
};
static_assert(alignof(UBFGTaskNode_SpawnReinforcements) == 0x000008, "Wrong alignment on UBFGTaskNode_SpawnReinforcements");
static_assert(sizeof(UBFGTaskNode_SpawnReinforcements) == 0x0000D0, "Wrong size on UBFGTaskNode_SpawnReinforcements");
static_assert(offsetof(UBFGTaskNode_SpawnReinforcements, M_BBCanCallReinforcements) == 0x0000A0, "Member 'UBFGTaskNode_SpawnReinforcements::M_BBCanCallReinforcements' has a wrong offset!");

// Class BFGCore.BFGTaskNode_StopActiveMovement
// 0x0008 (0x0080 - 0x0078)
class UBFGTaskNode_StopActiveMovement final : public UBFGBTBaseTaskNode
{
public:
	bool                                          M_bStopImmediately;                                // 0x0078(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_79[0x7];                                       // 0x0079(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"BFGTaskNode_StopActiveMovement">();
	}
	static class UBFGTaskNode_StopActiveMovement* GetDefaultObj()
	{
		return GetDefaultObjImpl<UBFGTaskNode_StopActiveMovement>();
	}
};
static_assert(alignof(UBFGTaskNode_StopActiveMovement) == 0x000008, "Wrong alignment on UBFGTaskNode_StopActiveMovement");
static_assert(sizeof(UBFGTaskNode_StopActiveMovement) == 0x000080, "Wrong size on UBFGTaskNode_StopActiveMovement");
static_assert(offsetof(UBFGTaskNode_StopActiveMovement, M_bStopImmediately) == 0x000078, "Member 'UBFGTaskNode_StopActiveMovement::M_bStopImmediately' has a wrong offset!");

// Class BFGCore.BFGTaskNode_SwitchAttackTarget
// 0x0050 (0x00C0 - 0x0070)
class UBFGTaskNode_SwitchAttackTarget final : public UBTTaskNode
{
public:
	struct FBlackboardKeySelector                 M_BBInAttackTarget;                                // 0x0070(0x0028)(Edit, BlueprintVisible, NativeAccessSpecifierPublic)
	struct FBlackboardKeySelector                 M_BBOutAttackTarget;                               // 0x0098(0x0028)(Edit, BlueprintVisible, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"BFGTaskNode_SwitchAttackTarget">();
	}
	static class UBFGTaskNode_SwitchAttackTarget* GetDefaultObj()
	{
		return GetDefaultObjImpl<UBFGTaskNode_SwitchAttackTarget>();
	}
};
static_assert(alignof(UBFGTaskNode_SwitchAttackTarget) == 0x000008, "Wrong alignment on UBFGTaskNode_SwitchAttackTarget");
static_assert(sizeof(UBFGTaskNode_SwitchAttackTarget) == 0x0000C0, "Wrong size on UBFGTaskNode_SwitchAttackTarget");
static_assert(offsetof(UBFGTaskNode_SwitchAttackTarget, M_BBInAttackTarget) == 0x000070, "Member 'UBFGTaskNode_SwitchAttackTarget::M_BBInAttackTarget' has a wrong offset!");
static_assert(offsetof(UBFGTaskNode_SwitchAttackTarget, M_BBOutAttackTarget) == 0x000098, "Member 'UBFGTaskNode_SwitchAttackTarget::M_BBOutAttackTarget' has a wrong offset!");

// Class BFGCore.BFGTaskNode_VehicleFlee
// 0x0000 (0x0138 - 0x0138)
class UBFGTaskNode_VehicleFlee final : public UBFGTaskNode_VehicleBase
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"BFGTaskNode_VehicleFlee">();
	}
	static class UBFGTaskNode_VehicleFlee* GetDefaultObj()
	{
		return GetDefaultObjImpl<UBFGTaskNode_VehicleFlee>();
	}
};
static_assert(alignof(UBFGTaskNode_VehicleFlee) == 0x000008, "Wrong alignment on UBFGTaskNode_VehicleFlee");
static_assert(sizeof(UBFGTaskNode_VehicleFlee) == 0x000138, "Wrong size on UBFGTaskNode_VehicleFlee");

// Class BFGCore.BFGTaskNode_VehicleRandomNav
// 0x0000 (0x0138 - 0x0138)
class UBFGTaskNode_VehicleRandomNav final : public UBFGTaskNode_VehicleBase
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"BFGTaskNode_VehicleRandomNav">();
	}
	static class UBFGTaskNode_VehicleRandomNav* GetDefaultObj()
	{
		return GetDefaultObjImpl<UBFGTaskNode_VehicleRandomNav>();
	}
};
static_assert(alignof(UBFGTaskNode_VehicleRandomNav) == 0x000008, "Wrong alignment on UBFGTaskNode_VehicleRandomNav");
static_assert(sizeof(UBFGTaskNode_VehicleRandomNav) == 0x000138, "Wrong size on UBFGTaskNode_VehicleRandomNav");

// Class BFGCore.BFGTaskNode_VehicleReleasePassengers
// 0x0000 (0x0138 - 0x0138)
class UBFGTaskNode_VehicleReleasePassengers final : public UBFGTaskNode_VehicleBase
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"BFGTaskNode_VehicleReleasePassengers">();
	}
	static class UBFGTaskNode_VehicleReleasePassengers* GetDefaultObj()
	{
		return GetDefaultObjImpl<UBFGTaskNode_VehicleReleasePassengers>();
	}
};
static_assert(alignof(UBFGTaskNode_VehicleReleasePassengers) == 0x000008, "Wrong alignment on UBFGTaskNode_VehicleReleasePassengers");
static_assert(sizeof(UBFGTaskNode_VehicleReleasePassengers) == 0x000138, "Wrong size on UBFGTaskNode_VehicleReleasePassengers");

// Class BFGCore.BFGTaskNode_VehicleStandBy
// 0x0008 (0x0140 - 0x0138)
class UBFGTaskNode_VehicleStandBy final : public UBFGTaskNode_VehicleBase
{
public:
	bool                                          M_bStandByAtTargetLocation;                        // 0x0138(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_139[0x3];                                      // 0x0139(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         M_fTolerance;                                      // 0x013C(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"BFGTaskNode_VehicleStandBy">();
	}
	static class UBFGTaskNode_VehicleStandBy* GetDefaultObj()
	{
		return GetDefaultObjImpl<UBFGTaskNode_VehicleStandBy>();
	}
};
static_assert(alignof(UBFGTaskNode_VehicleStandBy) == 0x000008, "Wrong alignment on UBFGTaskNode_VehicleStandBy");
static_assert(sizeof(UBFGTaskNode_VehicleStandBy) == 0x000140, "Wrong size on UBFGTaskNode_VehicleStandBy");
static_assert(offsetof(UBFGTaskNode_VehicleStandBy, M_bStandByAtTargetLocation) == 0x000138, "Member 'UBFGTaskNode_VehicleStandBy::M_bStandByAtTargetLocation' has a wrong offset!");
static_assert(offsetof(UBFGTaskNode_VehicleStandBy, M_fTolerance) == 0x00013C, "Member 'UBFGTaskNode_VehicleStandBy::M_fTolerance' has a wrong offset!");

// Class BFGCore.BFGTaskNode_VehicleTakePassengers
// 0x0000 (0x0138 - 0x0138)
class UBFGTaskNode_VehicleTakePassengers final : public UBFGTaskNode_VehicleBase
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"BFGTaskNode_VehicleTakePassengers">();
	}
	static class UBFGTaskNode_VehicleTakePassengers* GetDefaultObj()
	{
		return GetDefaultObjImpl<UBFGTaskNode_VehicleTakePassengers>();
	}
};
static_assert(alignof(UBFGTaskNode_VehicleTakePassengers) == 0x000008, "Wrong alignment on UBFGTaskNode_VehicleTakePassengers");
static_assert(sizeof(UBFGTaskNode_VehicleTakePassengers) == 0x000138, "Wrong size on UBFGTaskNode_VehicleTakePassengers");

// Class BFGCore.BFGTaskNode_VehicleWaitPassengers
// 0x0000 (0x0138 - 0x0138)
class UBFGTaskNode_VehicleWaitPassengers final : public UBFGTaskNode_VehicleBase
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"BFGTaskNode_VehicleWaitPassengers">();
	}
	static class UBFGTaskNode_VehicleWaitPassengers* GetDefaultObj()
	{
		return GetDefaultObjImpl<UBFGTaskNode_VehicleWaitPassengers>();
	}
};
static_assert(alignof(UBFGTaskNode_VehicleWaitPassengers) == 0x000008, "Wrong alignment on UBFGTaskNode_VehicleWaitPassengers");
static_assert(sizeof(UBFGTaskNode_VehicleWaitPassengers) == 0x000138, "Wrong size on UBFGTaskNode_VehicleWaitPassengers");

// Class BFGCore.BFGTaskNode_WeaponReload
// 0x0008 (0x0080 - 0x0078)
class UBFGTaskNode_WeaponReload final : public UBFGBTBaseTaskNode
{
public:
	bool                                          M_bWaitForFinishReload;                            // 0x0078(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_79[0x7];                                       // 0x0079(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"BFGTaskNode_WeaponReload">();
	}
	static class UBFGTaskNode_WeaponReload* GetDefaultObj()
	{
		return GetDefaultObjImpl<UBFGTaskNode_WeaponReload>();
	}
};
static_assert(alignof(UBFGTaskNode_WeaponReload) == 0x000008, "Wrong alignment on UBFGTaskNode_WeaponReload");
static_assert(sizeof(UBFGTaskNode_WeaponReload) == 0x000080, "Wrong size on UBFGTaskNode_WeaponReload");
static_assert(offsetof(UBFGTaskNode_WeaponReload, M_bWaitForFinishReload) == 0x000078, "Member 'UBFGTaskNode_WeaponReload::M_bWaitForFinishReload' has a wrong offset!");

// Class BFGCore.BFGTimeDilationManager
// 0x0020 (0x0050 - 0x0030)
class UBFGTimeDilationManager final : public UBFGGameSystem
{
public:
	class ABFGGameState*                          M_pGameState;                                      // 0x0030(0x0008)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TArray<struct FTimeDilationModifier>          M_aModifiers;                                      // 0x0038(0x0010)(ZeroConstructor, Transient, Protected, NativeAccessSpecifierProtected)
	float                                         M_fCurrentTimeDilation;                            // 0x0048(0x0004)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_4C[0x4];                                       // 0x004C(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"BFGTimeDilationManager">();
	}
	static class UBFGTimeDilationManager* GetDefaultObj()
	{
		return GetDefaultObjImpl<UBFGTimeDilationManager>();
	}
};
static_assert(alignof(UBFGTimeDilationManager) == 0x000008, "Wrong alignment on UBFGTimeDilationManager");
static_assert(sizeof(UBFGTimeDilationManager) == 0x000050, "Wrong size on UBFGTimeDilationManager");
static_assert(offsetof(UBFGTimeDilationManager, M_pGameState) == 0x000030, "Member 'UBFGTimeDilationManager::M_pGameState' has a wrong offset!");
static_assert(offsetof(UBFGTimeDilationManager, M_aModifiers) == 0x000038, "Member 'UBFGTimeDilationManager::M_aModifiers' has a wrong offset!");
static_assert(offsetof(UBFGTimeDilationManager, M_fCurrentTimeDilation) == 0x000048, "Member 'UBFGTimeDilationManager::M_fCurrentTimeDilation' has a wrong offset!");

// Class BFGCore.BFGTrafficCrowdManager
// 0x0570 (0x05A0 - 0x0030)
class UBFGTrafficCrowdManager : public UBFGGameSystem
{
public:
	uint8                                         Pad_30[0x60];                                      // 0x0030(0x0060)(Fixing Size After Last Property [ Dumper-7 ])
	class ABFGGameState*                          M_pGameState;                                      // 0x0090(0x0008)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UBFGGameInstance*                       M_pGameInstance;                                   // 0x0098(0x0008)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UBFGScriptedSequenceManager*            M_pScriptedSequenceManager;                        // 0x00A0(0x0008)(ExportObject, ZeroConstructor, Transient, InstancedReference, IsPlainOldData, NoDestructor, Protected, PersistentInstance, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TArray<class UBFGNetworkPath*>                M_apNetworkPaths;                                  // 0x00A8(0x0010)(ExportObject, ZeroConstructor, Transient, ContainsInstancedReference, Protected, NativeAccessSpecifierProtected)
	TArray<class UBFGNetworkPath*>                M_apNetworkPathsCopy;                              // 0x00B8(0x0010)(ZeroConstructor, Transient, Protected, NativeAccessSpecifierProtected)
	TArray<class UBFGNetworkPath*>                M_apCrossWalks;                                    // 0x00C8(0x0010)(ZeroConstructor, Transient, Protected, NativeAccessSpecifierProtected)
	TArray<class UBFGNetworkPathAgent*>           M_apAgents;                                        // 0x00D8(0x0010)(ExportObject, ZeroConstructor, Transient, ContainsInstancedReference, Protected, NativeAccessSpecifierProtected)
	TArray<class UBFGNetworkPathAgent*>           M_apAgentsCopy;                                    // 0x00E8(0x0010)(ZeroConstructor, Transient, Protected, NativeAccessSpecifierProtected)
	TArray<class UBFGNetworkPathIntersection*>    M_apIntersections;                                 // 0x00F8(0x0010)(ExportObject, ZeroConstructor, Transient, ContainsInstancedReference, Protected, NativeAccessSpecifierProtected)
	TArray<class UBFGNetworkPathIntersection*>    M_apIntersectionsCopy;                             // 0x0108(0x0010)(ZeroConstructor, Transient, Protected, NativeAccessSpecifierProtected)
	TArray<class UBFGCrowdLifeStationComponent*>  M_apCrowdLifeStations;                             // 0x0118(0x0010)(ExportObject, ZeroConstructor, Transient, ContainsInstancedReference, Protected, NativeAccessSpecifierProtected)
	TArray<class UBFGCrowdScriptConComponent*>    M_apScriptCons;                                    // 0x0128(0x0010)(ExportObject, ZeroConstructor, Transient, ContainsInstancedReference, Protected, NativeAccessSpecifierProtected)
	class UBFGTrafficLodManager*                  M_pTrafficLodManager;                              // 0x0138(0x0008)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TArray<class UBFGNetworkPathAgentComponent*>  M_apComponentsToRegister;                          // 0x0140(0x0010)(ExportObject, ZeroConstructor, Transient, ContainsInstancedReference, Protected, NativeAccessSpecifierProtected)
	TArray<class AActor*>                         M_apGraveyardActors;                               // 0x0150(0x0010)(ZeroConstructor, Transient, Protected, NativeAccessSpecifierProtected)
	struct FTickTrafficCrowdFunction              M_TickFunction;                                    // 0x0160(0x0078)(ContainsInstancedReference, Protected, NativeAccessSpecifierProtected)
	struct FWidgetPool                            M_DebugWidgetPool;                                 // 0x01D8(0x0070)(ContainsInstancedReference, Protected, NativeAccessSpecifierProtected)
	class UCanvasPanel*                           M_pDebugCanvasPanel;                               // 0x0248(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TArray<struct FRadarWidgetPair>               M_aDebugWidgetsInUse;                              // 0x0250(0x0010)(ZeroConstructor, ContainsInstancedReference, Protected, NativeAccessSpecifierProtected)
	class ABFGDeferredActorSpawnSystem*           M_pDeferredActorSpawner;                           // 0x0260(0x0008)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_268[0x18];                                     // 0x0268(0x0018)(Fixing Size After Last Property [ Dumper-7 ])
	class ABFGTrafficCrowdManagerSettingsActor*   M_pSettingsActor;                                  // 0x0280(0x0008)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TSoftObjectPtr<class UBFGSpawningComposition> M_pDefaultCivilianSpawningComposition;             // 0x0288(0x0028)(Edit, BlueprintVisible, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TSoftClassPtr<class UClass>                   M_pNavQueryFilter_ExludeRoads;                     // 0x02B0(0x0028)(Edit, DisableEditOnInstance, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TSoftObjectPtr<class UBFGSpawningComposition> M_pDefaultEnemySpawningComposition;                // 0x02D8(0x0028)(Edit, BlueprintVisible, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TSoftClassPtr<class UClass>                   M_pDefaultBasicVehicleClass;                       // 0x0300(0x0028)(Edit, DisableEditOnInstance, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TSoftClassPtr<class UClass>                   M_pDefaultBasicVehicleTankClass;                   // 0x0328(0x0028)(Edit, DisableEditOnInstance, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TSoftObjectPtr<class UBFGDataAsset_RadarObjectStaticInfo> M_pDefaultRadarObjectStaticInfo_EnemyVehicles;     // 0x0350(0x0028)(Edit, DisableEditOnInstance, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TSoftObjectPtr<class UDataTable>              M_pDefaultVehicleDefinitionTable;                  // 0x0378(0x0028)(Edit, DisableEditOnInstance, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	struct FGameplayTagContainer                  M_oAgentDespawnForbiddenTags;                      // 0x03A0(0x0020)(Edit, DisableEditOnInstance, Protected, NativeAccessSpecifierProtected)
	class UBFGMentalAbility_Psychokinesis*        M_pCachedPKComponent;                              // 0x03C0(0x0008)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_3C8[0x180];                                    // 0x03C8(0x0180)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<struct FQueuedDamageEvent>             M_aPendingDamageEvents;                            // 0x0548(0x0010)(ZeroConstructor, Transient, ContainsInstancedReference, Protected, NativeAccessSpecifierProtected)
	class ABFGCrowdManagerSettings*               M_pCrowdManagerSettings;                           // 0x0558(0x0008)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_560[0x10];                                     // 0x0560(0x0010)(Fixing Size After Last Property [ Dumper-7 ])
	class UBFGNetworkPath_RelativeDistanceCalculator* M_pRelativeDistanceCalculator;                     // 0x0570(0x0008)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UBFGTrafficGoalActorPool*               M_pGoalActorPool;                                  // 0x0578(0x0008)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UBFGPlayerState_Unlocks*                M_pPlayerStateUnlocks;                             // 0x0580(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_588[0x18];                                     // 0x0588(0x0018)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static bool UnlockInitialAgentBehaviour(const class UObject* WorldContextObject, const TSoftObjectPtr<class AActor>& _softActorReference);

	void DeregisterObstacleProxy(class AActor* _pObstacle);
	TArray<class UBFGNetworkPathAgent*> GetAgentsForTagsAndActorList(const struct FGameplayTagQuery& _query, const TArray<TSoftObjectPtr<class AActor>>& _aExplicitActorList);
	void HideOpportunityWidgets(const TArray<TSubclassOf<class AActor>>& _aClassWhiteList, const struct FGameplayTagQuery& _query, const TArray<TSoftObjectPtr<class AActor>>& _aExplicitActorList);
	void OnWorldLoaded(class UBFGGameInstance* _pGameInstance, class UWorld* _pWorld);
	void PrePopulateAroundPosition(const struct FVector& _vVector, bool _bRemoveAllAgents, double _fMaxTime);
	void RegisterObstacleProxy(class AActor* _pObstacle, bool _bLocalizeAlongPath, bool _bIsPlayer);
	bool RequestDespawnAgentWithSoftReference(const TSoftObjectPtr<class AActor>& _softReference, EBFGNetworkPathAgentDespawnRequest _eRequest, float _fTimeOut);
	void SetCrowdflowAllowedByTagQueryOverrideByGameplayTag(const struct FGameplayTagQuery& _query, const struct FGameplayTagQuery& _override);
	void SetCrowdflowAvailableByGameplayTag(const struct FGameplayTagQuery& _query, bool _bState);
	void SetCrowdLifeStationsAvailableByGameplayTag(const struct FGameplayTagQuery& _query, bool _bState);
	void SetCrowdScriptConsAvailableByGameplayTag(const struct FGameplayTagQuery& _query, bool _bState);
	void ShowOpportunityWidgets(const struct FBFGAgentInstanceOpportunityData& _data, const TArray<TSubclassOf<class AActor>>& _aClassWhiteList, const struct FGameplayTagQuery& _query, const TArray<TSoftObjectPtr<class AActor>>& _aExplicitActorList);
	void ToggleCrowdSpawningCompositionUnlockAll();

	class UBFGNetworkPathAgent* FindAgentWithSoftReference(const TSoftObjectPtr<class AActor>& _softReference) const;
	class UBFGScriptedSequenceManager* GetScriptedSequenceManager() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"BFGTrafficCrowdManager">();
	}
	static class UBFGTrafficCrowdManager* GetDefaultObj()
	{
		return GetDefaultObjImpl<UBFGTrafficCrowdManager>();
	}
};
static_assert(alignof(UBFGTrafficCrowdManager) == 0x000008, "Wrong alignment on UBFGTrafficCrowdManager");
static_assert(sizeof(UBFGTrafficCrowdManager) == 0x0005A0, "Wrong size on UBFGTrafficCrowdManager");
static_assert(offsetof(UBFGTrafficCrowdManager, M_pGameState) == 0x000090, "Member 'UBFGTrafficCrowdManager::M_pGameState' has a wrong offset!");
static_assert(offsetof(UBFGTrafficCrowdManager, M_pGameInstance) == 0x000098, "Member 'UBFGTrafficCrowdManager::M_pGameInstance' has a wrong offset!");
static_assert(offsetof(UBFGTrafficCrowdManager, M_pScriptedSequenceManager) == 0x0000A0, "Member 'UBFGTrafficCrowdManager::M_pScriptedSequenceManager' has a wrong offset!");
static_assert(offsetof(UBFGTrafficCrowdManager, M_apNetworkPaths) == 0x0000A8, "Member 'UBFGTrafficCrowdManager::M_apNetworkPaths' has a wrong offset!");
static_assert(offsetof(UBFGTrafficCrowdManager, M_apNetworkPathsCopy) == 0x0000B8, "Member 'UBFGTrafficCrowdManager::M_apNetworkPathsCopy' has a wrong offset!");
static_assert(offsetof(UBFGTrafficCrowdManager, M_apCrossWalks) == 0x0000C8, "Member 'UBFGTrafficCrowdManager::M_apCrossWalks' has a wrong offset!");
static_assert(offsetof(UBFGTrafficCrowdManager, M_apAgents) == 0x0000D8, "Member 'UBFGTrafficCrowdManager::M_apAgents' has a wrong offset!");
static_assert(offsetof(UBFGTrafficCrowdManager, M_apAgentsCopy) == 0x0000E8, "Member 'UBFGTrafficCrowdManager::M_apAgentsCopy' has a wrong offset!");
static_assert(offsetof(UBFGTrafficCrowdManager, M_apIntersections) == 0x0000F8, "Member 'UBFGTrafficCrowdManager::M_apIntersections' has a wrong offset!");
static_assert(offsetof(UBFGTrafficCrowdManager, M_apIntersectionsCopy) == 0x000108, "Member 'UBFGTrafficCrowdManager::M_apIntersectionsCopy' has a wrong offset!");
static_assert(offsetof(UBFGTrafficCrowdManager, M_apCrowdLifeStations) == 0x000118, "Member 'UBFGTrafficCrowdManager::M_apCrowdLifeStations' has a wrong offset!");
static_assert(offsetof(UBFGTrafficCrowdManager, M_apScriptCons) == 0x000128, "Member 'UBFGTrafficCrowdManager::M_apScriptCons' has a wrong offset!");
static_assert(offsetof(UBFGTrafficCrowdManager, M_pTrafficLodManager) == 0x000138, "Member 'UBFGTrafficCrowdManager::M_pTrafficLodManager' has a wrong offset!");
static_assert(offsetof(UBFGTrafficCrowdManager, M_apComponentsToRegister) == 0x000140, "Member 'UBFGTrafficCrowdManager::M_apComponentsToRegister' has a wrong offset!");
static_assert(offsetof(UBFGTrafficCrowdManager, M_apGraveyardActors) == 0x000150, "Member 'UBFGTrafficCrowdManager::M_apGraveyardActors' has a wrong offset!");
static_assert(offsetof(UBFGTrafficCrowdManager, M_TickFunction) == 0x000160, "Member 'UBFGTrafficCrowdManager::M_TickFunction' has a wrong offset!");
static_assert(offsetof(UBFGTrafficCrowdManager, M_DebugWidgetPool) == 0x0001D8, "Member 'UBFGTrafficCrowdManager::M_DebugWidgetPool' has a wrong offset!");
static_assert(offsetof(UBFGTrafficCrowdManager, M_pDebugCanvasPanel) == 0x000248, "Member 'UBFGTrafficCrowdManager::M_pDebugCanvasPanel' has a wrong offset!");
static_assert(offsetof(UBFGTrafficCrowdManager, M_aDebugWidgetsInUse) == 0x000250, "Member 'UBFGTrafficCrowdManager::M_aDebugWidgetsInUse' has a wrong offset!");
static_assert(offsetof(UBFGTrafficCrowdManager, M_pDeferredActorSpawner) == 0x000260, "Member 'UBFGTrafficCrowdManager::M_pDeferredActorSpawner' has a wrong offset!");
static_assert(offsetof(UBFGTrafficCrowdManager, M_pSettingsActor) == 0x000280, "Member 'UBFGTrafficCrowdManager::M_pSettingsActor' has a wrong offset!");
static_assert(offsetof(UBFGTrafficCrowdManager, M_pDefaultCivilianSpawningComposition) == 0x000288, "Member 'UBFGTrafficCrowdManager::M_pDefaultCivilianSpawningComposition' has a wrong offset!");
static_assert(offsetof(UBFGTrafficCrowdManager, M_pNavQueryFilter_ExludeRoads) == 0x0002B0, "Member 'UBFGTrafficCrowdManager::M_pNavQueryFilter_ExludeRoads' has a wrong offset!");
static_assert(offsetof(UBFGTrafficCrowdManager, M_pDefaultEnemySpawningComposition) == 0x0002D8, "Member 'UBFGTrafficCrowdManager::M_pDefaultEnemySpawningComposition' has a wrong offset!");
static_assert(offsetof(UBFGTrafficCrowdManager, M_pDefaultBasicVehicleClass) == 0x000300, "Member 'UBFGTrafficCrowdManager::M_pDefaultBasicVehicleClass' has a wrong offset!");
static_assert(offsetof(UBFGTrafficCrowdManager, M_pDefaultBasicVehicleTankClass) == 0x000328, "Member 'UBFGTrafficCrowdManager::M_pDefaultBasicVehicleTankClass' has a wrong offset!");
static_assert(offsetof(UBFGTrafficCrowdManager, M_pDefaultRadarObjectStaticInfo_EnemyVehicles) == 0x000350, "Member 'UBFGTrafficCrowdManager::M_pDefaultRadarObjectStaticInfo_EnemyVehicles' has a wrong offset!");
static_assert(offsetof(UBFGTrafficCrowdManager, M_pDefaultVehicleDefinitionTable) == 0x000378, "Member 'UBFGTrafficCrowdManager::M_pDefaultVehicleDefinitionTable' has a wrong offset!");
static_assert(offsetof(UBFGTrafficCrowdManager, M_oAgentDespawnForbiddenTags) == 0x0003A0, "Member 'UBFGTrafficCrowdManager::M_oAgentDespawnForbiddenTags' has a wrong offset!");
static_assert(offsetof(UBFGTrafficCrowdManager, M_pCachedPKComponent) == 0x0003C0, "Member 'UBFGTrafficCrowdManager::M_pCachedPKComponent' has a wrong offset!");
static_assert(offsetof(UBFGTrafficCrowdManager, M_aPendingDamageEvents) == 0x000548, "Member 'UBFGTrafficCrowdManager::M_aPendingDamageEvents' has a wrong offset!");
static_assert(offsetof(UBFGTrafficCrowdManager, M_pCrowdManagerSettings) == 0x000558, "Member 'UBFGTrafficCrowdManager::M_pCrowdManagerSettings' has a wrong offset!");
static_assert(offsetof(UBFGTrafficCrowdManager, M_pRelativeDistanceCalculator) == 0x000570, "Member 'UBFGTrafficCrowdManager::M_pRelativeDistanceCalculator' has a wrong offset!");
static_assert(offsetof(UBFGTrafficCrowdManager, M_pGoalActorPool) == 0x000578, "Member 'UBFGTrafficCrowdManager::M_pGoalActorPool' has a wrong offset!");
static_assert(offsetof(UBFGTrafficCrowdManager, M_pPlayerStateUnlocks) == 0x000580, "Member 'UBFGTrafficCrowdManager::M_pPlayerStateUnlocks' has a wrong offset!");

// Class BFGCore.BFGTrafficGoalActor
// 0x0000 (0x03D8 - 0x03D8)
class ABFGTrafficGoalActor final : public AActor
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"BFGTrafficGoalActor">();
	}
	static class ABFGTrafficGoalActor* GetDefaultObj()
	{
		return GetDefaultObjImpl<ABFGTrafficGoalActor>();
	}
};
static_assert(alignof(ABFGTrafficGoalActor) == 0x000008, "Wrong alignment on ABFGTrafficGoalActor");
static_assert(sizeof(ABFGTrafficGoalActor) == 0x0003D8, "Wrong size on ABFGTrafficGoalActor");

// Class BFGCore.BFGTrafficGoalActorPool
// 0x0020 (0x0048 - 0x0028)
class UBFGTrafficGoalActorPool final : public UObject
{
public:
	uint8                                         Pad_28[0x8];                                       // 0x0028(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	class UBFGTrafficCrowdManager*                M_pManager;                                        // 0x0030(0x0008)(ExportObject, ZeroConstructor, Transient, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TArray<class AActor*>                         M_apFree;                                          // 0x0038(0x0010)(ZeroConstructor, Transient, Protected, NativeAccessSpecifierProtected)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"BFGTrafficGoalActorPool">();
	}
	static class UBFGTrafficGoalActorPool* GetDefaultObj()
	{
		return GetDefaultObjImpl<UBFGTrafficGoalActorPool>();
	}
};
static_assert(alignof(UBFGTrafficGoalActorPool) == 0x000008, "Wrong alignment on UBFGTrafficGoalActorPool");
static_assert(sizeof(UBFGTrafficGoalActorPool) == 0x000048, "Wrong size on UBFGTrafficGoalActorPool");
static_assert(offsetof(UBFGTrafficGoalActorPool, M_pManager) == 0x000030, "Member 'UBFGTrafficGoalActorPool::M_pManager' has a wrong offset!");
static_assert(offsetof(UBFGTrafficGoalActorPool, M_apFree) == 0x000038, "Member 'UBFGTrafficGoalActorPool::M_apFree' has a wrong offset!");

// Class BFGCore.BFGTrafficPathFinder_Network
// 0x0100 (0x0128 - 0x0028)
class UBFGTrafficPathFinder_Network final : public UObject
{
public:
	TArray<class UBFGNetworkPath*>                M_apNetworkPath;                                   // 0x0028(0x0010)(ZeroConstructor, Transient, NativeAccessSpecifierPrivate)
	TMap<struct FGuid, struct FGuid>              M_aForwardPathWaypoints;                           // 0x0038(0x0050)(ZeroConstructor, Transient, NativeAccessSpecifierPrivate)
	TMap<struct FGuid, struct FGuid>              M_aBackwardPathWaypoints;                          // 0x0088(0x0050)(ZeroConstructor, Transient, NativeAccessSpecifierPrivate)
	TMap<struct FGuid, struct FBFGTrafficPathFinder_PathWaypoint> M_aPathWaypointsMap;                               // 0x00D8(0x0050)(ZeroConstructor, Transient, NativeAccessSpecifierPrivate)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"BFGTrafficPathFinder_Network">();
	}
	static class UBFGTrafficPathFinder_Network* GetDefaultObj()
	{
		return GetDefaultObjImpl<UBFGTrafficPathFinder_Network>();
	}
};
static_assert(alignof(UBFGTrafficPathFinder_Network) == 0x000008, "Wrong alignment on UBFGTrafficPathFinder_Network");
static_assert(sizeof(UBFGTrafficPathFinder_Network) == 0x000128, "Wrong size on UBFGTrafficPathFinder_Network");
static_assert(offsetof(UBFGTrafficPathFinder_Network, M_apNetworkPath) == 0x000028, "Member 'UBFGTrafficPathFinder_Network::M_apNetworkPath' has a wrong offset!");
static_assert(offsetof(UBFGTrafficPathFinder_Network, M_aForwardPathWaypoints) == 0x000038, "Member 'UBFGTrafficPathFinder_Network::M_aForwardPathWaypoints' has a wrong offset!");
static_assert(offsetof(UBFGTrafficPathFinder_Network, M_aBackwardPathWaypoints) == 0x000088, "Member 'UBFGTrafficPathFinder_Network::M_aBackwardPathWaypoints' has a wrong offset!");
static_assert(offsetof(UBFGTrafficPathFinder_Network, M_aPathWaypointsMap) == 0x0000D8, "Member 'UBFGTrafficPathFinder_Network::M_aPathWaypointsMap' has a wrong offset!");

// Class BFGCore.BFGTrafficPathFinder_Parser
// 0x0030 (0x0058 - 0x0028)
class UBFGTrafficPathFinder_Parser final : public UObject
{
public:
	struct FGuid                                  M_currentWaypointId;                               // 0x0028(0x0010)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	struct FGuid                                  M_previousWaypointId;                              // 0x0038(0x0010)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	int32                                         M_iCurrentIndex;                                   // 0x0048(0x0004)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_4C[0x4];                                       // 0x004C(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class UBFGTrafficPathFinder_Network*          M_pNetwork;                                        // 0x0050(0x0008)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"BFGTrafficPathFinder_Parser">();
	}
	static class UBFGTrafficPathFinder_Parser* GetDefaultObj()
	{
		return GetDefaultObjImpl<UBFGTrafficPathFinder_Parser>();
	}
};
static_assert(alignof(UBFGTrafficPathFinder_Parser) == 0x000008, "Wrong alignment on UBFGTrafficPathFinder_Parser");
static_assert(sizeof(UBFGTrafficPathFinder_Parser) == 0x000058, "Wrong size on UBFGTrafficPathFinder_Parser");
static_assert(offsetof(UBFGTrafficPathFinder_Parser, M_currentWaypointId) == 0x000028, "Member 'UBFGTrafficPathFinder_Parser::M_currentWaypointId' has a wrong offset!");
static_assert(offsetof(UBFGTrafficPathFinder_Parser, M_previousWaypointId) == 0x000038, "Member 'UBFGTrafficPathFinder_Parser::M_previousWaypointId' has a wrong offset!");
static_assert(offsetof(UBFGTrafficPathFinder_Parser, M_iCurrentIndex) == 0x000048, "Member 'UBFGTrafficPathFinder_Parser::M_iCurrentIndex' has a wrong offset!");
static_assert(offsetof(UBFGTrafficPathFinder_Parser, M_pNetwork) == 0x000050, "Member 'UBFGTrafficPathFinder_Parser::M_pNetwork' has a wrong offset!");

// Class BFGCore.BFGTrafficPathFinder_Tester
// 0x0040 (0x0068 - 0x0028)
class UBFGTrafficPathFinder_Tester final : public UObject
{
public:
	class UBFGNetworkPathAgent*                   M_pAgent;                                          // 0x0028(0x0008)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UBFGNetworkPath*                        M_pStartPath;                                      // 0x0030(0x0008)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	int32                                         M_iStartDirection;                                 // 0x0038(0x0004)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	struct FVector                                M_vTargetLocation;                                 // 0x003C(0x000C)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	int32                                         M_iTargetDirection;                                // 0x0048(0x0004)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_4C[0x4];                                       // 0x004C(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class UBFGTrafficPathFinder*                  M_pPathFinder;                                     // 0x0050(0x0008)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UBFGNetworkPath_ScriptedPath*           M_pScriptedPath;                                   // 0x0058(0x0008)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	float                                         M_fTimer;                                          // 0x0060(0x0004)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_64[0x4];                                       // 0x0064(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"BFGTrafficPathFinder_Tester">();
	}
	static class UBFGTrafficPathFinder_Tester* GetDefaultObj()
	{
		return GetDefaultObjImpl<UBFGTrafficPathFinder_Tester>();
	}
};
static_assert(alignof(UBFGTrafficPathFinder_Tester) == 0x000008, "Wrong alignment on UBFGTrafficPathFinder_Tester");
static_assert(sizeof(UBFGTrafficPathFinder_Tester) == 0x000068, "Wrong size on UBFGTrafficPathFinder_Tester");
static_assert(offsetof(UBFGTrafficPathFinder_Tester, M_pAgent) == 0x000028, "Member 'UBFGTrafficPathFinder_Tester::M_pAgent' has a wrong offset!");
static_assert(offsetof(UBFGTrafficPathFinder_Tester, M_pStartPath) == 0x000030, "Member 'UBFGTrafficPathFinder_Tester::M_pStartPath' has a wrong offset!");
static_assert(offsetof(UBFGTrafficPathFinder_Tester, M_iStartDirection) == 0x000038, "Member 'UBFGTrafficPathFinder_Tester::M_iStartDirection' has a wrong offset!");
static_assert(offsetof(UBFGTrafficPathFinder_Tester, M_vTargetLocation) == 0x00003C, "Member 'UBFGTrafficPathFinder_Tester::M_vTargetLocation' has a wrong offset!");
static_assert(offsetof(UBFGTrafficPathFinder_Tester, M_iTargetDirection) == 0x000048, "Member 'UBFGTrafficPathFinder_Tester::M_iTargetDirection' has a wrong offset!");
static_assert(offsetof(UBFGTrafficPathFinder_Tester, M_pPathFinder) == 0x000050, "Member 'UBFGTrafficPathFinder_Tester::M_pPathFinder' has a wrong offset!");
static_assert(offsetof(UBFGTrafficPathFinder_Tester, M_pScriptedPath) == 0x000058, "Member 'UBFGTrafficPathFinder_Tester::M_pScriptedPath' has a wrong offset!");
static_assert(offsetof(UBFGTrafficPathFinder_Tester, M_fTimer) == 0x000060, "Member 'UBFGTrafficPathFinder_Tester::M_fTimer' has a wrong offset!");

// Class BFGCore.BFGTrafficPathFinder_Visitor
// 0x0068 (0x0090 - 0x0028)
class UBFGTrafficPathFinder_Visitor final : public UObject
{
public:
	TMap<struct FGuid, struct FBFGTrafficPathFinder_VisitedPath> M_aVisitedPathMap;                                 // 0x0028(0x0050)(ZeroConstructor, Transient, ContainsInstancedReference, NativeAccessSpecifierPrivate)
	TArray<struct FGuid>                          M_apDirtyVisitedPath;                              // 0x0078(0x0010)(ZeroConstructor, Transient, NativeAccessSpecifierPrivate)
	class UBFGTrafficPathFinder_Network*          M_pNetwork;                                        // 0x0088(0x0008)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)

public:
	void OnVisitedPathDirty(const struct FGuid& _path);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"BFGTrafficPathFinder_Visitor">();
	}
	static class UBFGTrafficPathFinder_Visitor* GetDefaultObj()
	{
		return GetDefaultObjImpl<UBFGTrafficPathFinder_Visitor>();
	}
};
static_assert(alignof(UBFGTrafficPathFinder_Visitor) == 0x000008, "Wrong alignment on UBFGTrafficPathFinder_Visitor");
static_assert(sizeof(UBFGTrafficPathFinder_Visitor) == 0x000090, "Wrong size on UBFGTrafficPathFinder_Visitor");
static_assert(offsetof(UBFGTrafficPathFinder_Visitor, M_aVisitedPathMap) == 0x000028, "Member 'UBFGTrafficPathFinder_Visitor::M_aVisitedPathMap' has a wrong offset!");
static_assert(offsetof(UBFGTrafficPathFinder_Visitor, M_apDirtyVisitedPath) == 0x000078, "Member 'UBFGTrafficPathFinder_Visitor::M_apDirtyVisitedPath' has a wrong offset!");
static_assert(offsetof(UBFGTrafficPathFinder_Visitor, M_pNetwork) == 0x000088, "Member 'UBFGTrafficPathFinder_Visitor::M_pNetwork' has a wrong offset!");

// Class BFGCore.BFGTriggerManager
// 0x00B0 (0x00D8 - 0x0028)
class UBFGTriggerManager final : public UObject
{
public:
	uint8                                         Pad_28[0x8];                                       // 0x0028(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	class ABFGGameState*                          M_pGameState;                                      // 0x0030(0x0008)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UBFGBroadphaseManager*                  M_pBroadphase;                                     // 0x0038(0x0008)(ExportObject, ZeroConstructor, Transient, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UBFGQuest_Manager*                      M_pQuestManager;                                   // 0x0040(0x0008)(ExportObject, ZeroConstructor, Transient, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TArray<class UBFGQuest_Trigger*>              M_aQuestTriggers;                                  // 0x0048(0x0010)(ExportObject, ZeroConstructor, Transient, ContainsInstancedReference, Protected, NativeAccessSpecifierProtected)
	TArray<class ABFGMissionTriggerZone*>         M_aTriggerZones;                                   // 0x0058(0x0010)(ZeroConstructor, Transient, Protected, NativeAccessSpecifierProtected)
	TArray<class ABFGMissionCustomTriggerZone*>   M_apNonNavigableTriggerZones;                      // 0x0068(0x0010)(ZeroConstructor, Transient, Protected, NativeAccessSpecifierProtected)
	TArray<class AActor*>                         M_apActivators;                                    // 0x0078(0x0010)(ZeroConstructor, Transient, Protected, NativeAccessSpecifierProtected)
	TMap<class AActor*, struct FBFGMissionCustomTriggerZone_StatusCollection> M_aActivatorData;                                  // 0x0088(0x0050)(ZeroConstructor, Transient, Protected, NativeAccessSpecifierProtected)

public:
	bool CheckIsBoxInNonNavigableArea(const struct FBox& _box) const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"BFGTriggerManager">();
	}
	static class UBFGTriggerManager* GetDefaultObj()
	{
		return GetDefaultObjImpl<UBFGTriggerManager>();
	}
};
static_assert(alignof(UBFGTriggerManager) == 0x000008, "Wrong alignment on UBFGTriggerManager");
static_assert(sizeof(UBFGTriggerManager) == 0x0000D8, "Wrong size on UBFGTriggerManager");
static_assert(offsetof(UBFGTriggerManager, M_pGameState) == 0x000030, "Member 'UBFGTriggerManager::M_pGameState' has a wrong offset!");
static_assert(offsetof(UBFGTriggerManager, M_pBroadphase) == 0x000038, "Member 'UBFGTriggerManager::M_pBroadphase' has a wrong offset!");
static_assert(offsetof(UBFGTriggerManager, M_pQuestManager) == 0x000040, "Member 'UBFGTriggerManager::M_pQuestManager' has a wrong offset!");
static_assert(offsetof(UBFGTriggerManager, M_aQuestTriggers) == 0x000048, "Member 'UBFGTriggerManager::M_aQuestTriggers' has a wrong offset!");
static_assert(offsetof(UBFGTriggerManager, M_aTriggerZones) == 0x000058, "Member 'UBFGTriggerManager::M_aTriggerZones' has a wrong offset!");
static_assert(offsetof(UBFGTriggerManager, M_apNonNavigableTriggerZones) == 0x000068, "Member 'UBFGTriggerManager::M_apNonNavigableTriggerZones' has a wrong offset!");
static_assert(offsetof(UBFGTriggerManager, M_apActivators) == 0x000078, "Member 'UBFGTriggerManager::M_apActivators' has a wrong offset!");
static_assert(offsetof(UBFGTriggerManager, M_aActivatorData) == 0x000088, "Member 'UBFGTriggerManager::M_aActivatorData' has a wrong offset!");

// Class BFGCore.BFGTutorialPageTarget
// 0x0000 (0x0028 - 0x0028)
class IBFGTutorialPageTarget final : public IInterface
{
public:
	void AddPage(class UBFGWidget_TutorialPage* _pTutorialPage);
	void Clear();
	void RemovePage(class UBFGWidget_TutorialPage* _pTutorialPage);
	void SetStackSize(int32 _iStackSize);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"BFGTutorialPageTarget">();
	}
	static class IBFGTutorialPageTarget* GetDefaultObj()
	{
		return GetDefaultObjImpl<IBFGTutorialPageTarget>();
	}
};
static_assert(alignof(IBFGTutorialPageTarget) == 0x000008, "Wrong alignment on IBFGTutorialPageTarget");
static_assert(sizeof(IBFGTutorialPageTarget) == 0x000028, "Wrong size on IBFGTutorialPageTarget");

// Class BFGCore.BFGUFOAbility_AbductoBeam
// 0x0000 (0x0460 - 0x0460)
class UBFGUFOAbility_AbductoBeam : public UBFGMentalAbility_Psychokinesis
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"BFGUFOAbility_AbductoBeam">();
	}
	static class UBFGUFOAbility_AbductoBeam* GetDefaultObj()
	{
		return GetDefaultObjImpl<UBFGUFOAbility_AbductoBeam>();
	}
};
static_assert(alignof(UBFGUFOAbility_AbductoBeam) == 0x000008, "Wrong alignment on UBFGUFOAbility_AbductoBeam");
static_assert(sizeof(UBFGUFOAbility_AbductoBeam) == 0x000460, "Wrong size on UBFGUFOAbility_AbductoBeam");

// Class BFGCore.BFGUFOAbility_Drain
// 0x0020 (0x01E8 - 0x01C8)
class UBFGUFOAbility_Drain : public UBFGMentalAbilityBase
{
public:
	float                                         M_fDrainPerTick;                                   // 0x01C8(0x0004)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         M_fShieldGainMultiplier;                           // 0x01CC(0x0004)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         M_fDrainTickRate;                                  // 0x01D0(0x0004)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         M_fDrainPerSmashBonus;                             // 0x01D4(0x0004)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1D8[0x10];                                     // 0x01D8(0x0010)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void OnDrainDamageTicked(float _fDamageAmount);

	int32 GetSmashCounter() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"BFGUFOAbility_Drain">();
	}
	static class UBFGUFOAbility_Drain* GetDefaultObj()
	{
		return GetDefaultObjImpl<UBFGUFOAbility_Drain>();
	}
};
static_assert(alignof(UBFGUFOAbility_Drain) == 0x000008, "Wrong alignment on UBFGUFOAbility_Drain");
static_assert(sizeof(UBFGUFOAbility_Drain) == 0x0001E8, "Wrong size on UBFGUFOAbility_Drain");
static_assert(offsetof(UBFGUFOAbility_Drain, M_fDrainPerTick) == 0x0001C8, "Member 'UBFGUFOAbility_Drain::M_fDrainPerTick' has a wrong offset!");
static_assert(offsetof(UBFGUFOAbility_Drain, M_fShieldGainMultiplier) == 0x0001CC, "Member 'UBFGUFOAbility_Drain::M_fShieldGainMultiplier' has a wrong offset!");
static_assert(offsetof(UBFGUFOAbility_Drain, M_fDrainTickRate) == 0x0001D0, "Member 'UBFGUFOAbility_Drain::M_fDrainTickRate' has a wrong offset!");
static_assert(offsetof(UBFGUFOAbility_Drain, M_fDrainPerSmashBonus) == 0x0001D4, "Member 'UBFGUFOAbility_Drain::M_fDrainPerSmashBonus' has a wrong offset!");

// Class BFGCore.BFGUFOLandingSite
// 0x0070 (0x0448 - 0x03D8)
class ABFGUFOLandingSite : public AActor
{
public:
	uint8                                         Pad_3D8[0x10];                                     // 0x03D8(0x0010)(Fixing Size After Last Property [ Dumper-7 ])
	class UBFGActorComponent_Objective*           M_pObjectiveComponent;                             // 0x03E8(0x0008)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, EditConst, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FGameplayTagContainer                  M_gameplayTags;                                    // 0x03F0(0x0020)(Edit, BlueprintVisible, BlueprintReadOnly, NativeAccessSpecifierPublic)
	struct FGameplayTag                           M_tSaucerSkillTag;                                 // 0x0410(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          M_bIsDefaultSite;                                  // 0x0418(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_419[0x3];                                      // 0x0419(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         M_fPlayerNotificationDistance;                     // 0x041C(0x0004)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          M_bWasOutsideRange;                                // 0x0420(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_421[0x7];                                      // 0x0421(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	class USceneComponent*                        M_pObjectiveMarkerParentComponent;                 // 0x0428(0x0008)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, EditConst, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          M_bUnlocked;                                       // 0x0430(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_431[0x3];                                      // 0x0431(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         M_fUFOInteractDistance;                            // 0x0434(0x0004)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         M_fPlayerInteractDistance;                         // 0x0438(0x0004)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_43C[0x5];                                      // 0x043C(0x0005)(Fixing Size After Last Property [ Dumper-7 ])
	bool                                          M_bIsSpawn;                                        // 0x0441(0x0001)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_442[0x6];                                      // 0x0442(0x0006)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void CallUFO();
	void GetCharacterLocation(struct FVector* _vLocationOut, struct FRotator* _rotationOut);
	void GetUFOLocation(struct FVector* _vLocationOut, struct FRotator* _rotationOut);
	void OnPlayerEntersRange();
	void OnPlayerLeavesRange();
	void OnScreenFadingStateChanged(bool _bFaded);
	void OnUFOEntersRange();
	void OnUFOLeavesRange();
	void ResetCallUFO();
	void SetUnlocked(bool _bUnlocked);

	float GetDistanceToPlayer() const;
	float GetDistanceToUFO() const;
	bool GetIsPlayerInNotificationRange() const;
	bool GetIsPlayerInRange() const;
	bool GetIsUFOInRange() const;
	bool HasLandedUFO() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"BFGUFOLandingSite">();
	}
	static class ABFGUFOLandingSite* GetDefaultObj()
	{
		return GetDefaultObjImpl<ABFGUFOLandingSite>();
	}
};
static_assert(alignof(ABFGUFOLandingSite) == 0x000008, "Wrong alignment on ABFGUFOLandingSite");
static_assert(sizeof(ABFGUFOLandingSite) == 0x000448, "Wrong size on ABFGUFOLandingSite");
static_assert(offsetof(ABFGUFOLandingSite, M_pObjectiveComponent) == 0x0003E8, "Member 'ABFGUFOLandingSite::M_pObjectiveComponent' has a wrong offset!");
static_assert(offsetof(ABFGUFOLandingSite, M_gameplayTags) == 0x0003F0, "Member 'ABFGUFOLandingSite::M_gameplayTags' has a wrong offset!");
static_assert(offsetof(ABFGUFOLandingSite, M_tSaucerSkillTag) == 0x000410, "Member 'ABFGUFOLandingSite::M_tSaucerSkillTag' has a wrong offset!");
static_assert(offsetof(ABFGUFOLandingSite, M_bIsDefaultSite) == 0x000418, "Member 'ABFGUFOLandingSite::M_bIsDefaultSite' has a wrong offset!");
static_assert(offsetof(ABFGUFOLandingSite, M_fPlayerNotificationDistance) == 0x00041C, "Member 'ABFGUFOLandingSite::M_fPlayerNotificationDistance' has a wrong offset!");
static_assert(offsetof(ABFGUFOLandingSite, M_bWasOutsideRange) == 0x000420, "Member 'ABFGUFOLandingSite::M_bWasOutsideRange' has a wrong offset!");
static_assert(offsetof(ABFGUFOLandingSite, M_pObjectiveMarkerParentComponent) == 0x000428, "Member 'ABFGUFOLandingSite::M_pObjectiveMarkerParentComponent' has a wrong offset!");
static_assert(offsetof(ABFGUFOLandingSite, M_bUnlocked) == 0x000430, "Member 'ABFGUFOLandingSite::M_bUnlocked' has a wrong offset!");
static_assert(offsetof(ABFGUFOLandingSite, M_fUFOInteractDistance) == 0x000434, "Member 'ABFGUFOLandingSite::M_fUFOInteractDistance' has a wrong offset!");
static_assert(offsetof(ABFGUFOLandingSite, M_fPlayerInteractDistance) == 0x000438, "Member 'ABFGUFOLandingSite::M_fPlayerInteractDistance' has a wrong offset!");
static_assert(offsetof(ABFGUFOLandingSite, M_bIsSpawn) == 0x000441, "Member 'ABFGUFOLandingSite::M_bIsSpawn' has a wrong offset!");

// Class BFGCore.BFGUFOManager
// 0x0070 (0x00A0 - 0x0030)
class UBFGUFOManager : public UBFGGameSystem
{
public:
	uint8                                         Pad_30[0x30];                                      // 0x0030(0x0030)(Fixing Size After Last Property [ Dumper-7 ])
	TSubclassOf<class ABFGPlayerUFO>              M_pUFOClass;                                       // 0x0060(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class ABFGGameState*                          M_pGameState;                                      // 0x0068(0x0008)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TArray<TWeakObjectPtr<class ABFGUFOLandingSite>> M_apLandingSites;                                  // 0x0070(0x0010)(ZeroConstructor, Transient, Protected, UObjectWrapper, NativeAccessSpecifierProtected)
	class ABFGUFOLandingSite*                     M_pLastUsedSite;                                   // 0x0080(0x0008)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TWeakObjectPtr<class ABFGPlayerUFO>           M_spUFO;                                           // 0x0088(0x0008)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TArray<struct FBFGSystemData_UFOManager_SiteData> M_aSiteStatus;                                     // 0x0090(0x0010)(ZeroConstructor, Transient, Protected, NativeAccessSpecifierProtected)

public:
	void CheatSpawnCryptoAtClosestLandingSite();
	void CheatSpawnUFOAtClosestLandingSite();
	void OnFadingStateFinished(class FName _strFadeIdentifier, bool _bFadeOut);
	void SetUFO(class ABFGPlayerUFO* _pUFO);

	class ABFGPlayerUFO* GetUFO() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"BFGUFOManager">();
	}
	static class UBFGUFOManager* GetDefaultObj()
	{
		return GetDefaultObjImpl<UBFGUFOManager>();
	}
};
static_assert(alignof(UBFGUFOManager) == 0x000008, "Wrong alignment on UBFGUFOManager");
static_assert(sizeof(UBFGUFOManager) == 0x0000A0, "Wrong size on UBFGUFOManager");
static_assert(offsetof(UBFGUFOManager, M_pUFOClass) == 0x000060, "Member 'UBFGUFOManager::M_pUFOClass' has a wrong offset!");
static_assert(offsetof(UBFGUFOManager, M_pGameState) == 0x000068, "Member 'UBFGUFOManager::M_pGameState' has a wrong offset!");
static_assert(offsetof(UBFGUFOManager, M_apLandingSites) == 0x000070, "Member 'UBFGUFOManager::M_apLandingSites' has a wrong offset!");
static_assert(offsetof(UBFGUFOManager, M_pLastUsedSite) == 0x000080, "Member 'UBFGUFOManager::M_pLastUsedSite' has a wrong offset!");
static_assert(offsetof(UBFGUFOManager, M_spUFO) == 0x000088, "Member 'UBFGUFOManager::M_spUFO' has a wrong offset!");
static_assert(offsetof(UBFGUFOManager, M_aSiteStatus) == 0x000090, "Member 'UBFGUFOManager::M_aSiteStatus' has a wrong offset!");

// Class BFGCore.BFGVariableAction_AITaskState_Complete
// 0x0000 (0x00F0 - 0x00F0)
class UBFGVariableAction_AITaskState_Complete final : public UBFGVariableAction
{
public:
	static const class FName GetActionName_AITaskState_Complete();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"BFGVariableAction_AITaskState_Complete">();
	}
	static class UBFGVariableAction_AITaskState_Complete* GetDefaultObj()
	{
		return GetDefaultObjImpl<UBFGVariableAction_AITaskState_Complete>();
	}
};
static_assert(alignof(UBFGVariableAction_AITaskState_Complete) == 0x000008, "Wrong alignment on UBFGVariableAction_AITaskState_Complete");
static_assert(sizeof(UBFGVariableAction_AITaskState_Complete) == 0x0000F0, "Wrong size on UBFGVariableAction_AITaskState_Complete");

// Class BFGCore.BFGVariableAction_Boolean_SetTrue
// 0x0000 (0x00F0 - 0x00F0)
class UBFGVariableAction_Boolean_SetTrue final : public UBFGVariableAction
{
public:
	static const class FName GetActionName_BooleanSetTrue();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"BFGVariableAction_Boolean_SetTrue">();
	}
	static class UBFGVariableAction_Boolean_SetTrue* GetDefaultObj()
	{
		return GetDefaultObjImpl<UBFGVariableAction_Boolean_SetTrue>();
	}
};
static_assert(alignof(UBFGVariableAction_Boolean_SetTrue) == 0x000008, "Wrong alignment on UBFGVariableAction_Boolean_SetTrue");
static_assert(sizeof(UBFGVariableAction_Boolean_SetTrue) == 0x0000F0, "Wrong size on UBFGVariableAction_Boolean_SetTrue");

// Class BFGCore.BFGVariableAction_MissionGroup_Abort
// 0x0000 (0x00F0 - 0x00F0)
class UBFGVariableAction_MissionGroup_Abort final : public UBFGVariableAction
{
public:
	static const class FName GetActionName_MissionGroupAbort();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"BFGVariableAction_MissionGroup_Abort">();
	}
	static class UBFGVariableAction_MissionGroup_Abort* GetDefaultObj()
	{
		return GetDefaultObjImpl<UBFGVariableAction_MissionGroup_Abort>();
	}
};
static_assert(alignof(UBFGVariableAction_MissionGroup_Abort) == 0x000008, "Wrong alignment on UBFGVariableAction_MissionGroup_Abort");
static_assert(sizeof(UBFGVariableAction_MissionGroup_Abort) == 0x0000F0, "Wrong size on UBFGVariableAction_MissionGroup_Abort");

// Class BFGCore.BFGVariableAction_Quest_MakeAvailable
// 0x0000 (0x00F0 - 0x00F0)
class UBFGVariableAction_Quest_MakeAvailable final : public UBFGVariableAction
{
public:
	static const class FName GetActionName_QuestMakeAvailabe();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"BFGVariableAction_Quest_MakeAvailable">();
	}
	static class UBFGVariableAction_Quest_MakeAvailable* GetDefaultObj()
	{
		return GetDefaultObjImpl<UBFGVariableAction_Quest_MakeAvailable>();
	}
};
static_assert(alignof(UBFGVariableAction_Quest_MakeAvailable) == 0x000008, "Wrong alignment on UBFGVariableAction_Quest_MakeAvailable");
static_assert(sizeof(UBFGVariableAction_Quest_MakeAvailable) == 0x0000F0, "Wrong size on UBFGVariableAction_Quest_MakeAvailable");

// Class BFGCore.BFGVariableAction_Quest_Accept
// 0x0000 (0x00F0 - 0x00F0)
class UBFGVariableAction_Quest_Accept final : public UBFGVariableAction
{
public:
	static const class FName GetActionName_QuestAccept();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"BFGVariableAction_Quest_Accept">();
	}
	static class UBFGVariableAction_Quest_Accept* GetDefaultObj()
	{
		return GetDefaultObjImpl<UBFGVariableAction_Quest_Accept>();
	}
};
static_assert(alignof(UBFGVariableAction_Quest_Accept) == 0x000008, "Wrong alignment on UBFGVariableAction_Quest_Accept");
static_assert(sizeof(UBFGVariableAction_Quest_Accept) == 0x0000F0, "Wrong size on UBFGVariableAction_Quest_Accept");

// Class BFGCore.BFGVariableAction_Quest_Fail
// 0x0000 (0x00F0 - 0x00F0)
class UBFGVariableAction_Quest_Fail final : public UBFGVariableAction
{
public:
	static const class FName GetActionName_QuestFail();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"BFGVariableAction_Quest_Fail">();
	}
	static class UBFGVariableAction_Quest_Fail* GetDefaultObj()
	{
		return GetDefaultObjImpl<UBFGVariableAction_Quest_Fail>();
	}
};
static_assert(alignof(UBFGVariableAction_Quest_Fail) == 0x000008, "Wrong alignment on UBFGVariableAction_Quest_Fail");
static_assert(sizeof(UBFGVariableAction_Quest_Fail) == 0x0000F0, "Wrong size on UBFGVariableAction_Quest_Fail");

// Class BFGCore.BFGVariableAction_QuestCompletion_Completed
// 0x0000 (0x00F0 - 0x00F0)
class UBFGVariableAction_QuestCompletion_Completed final : public UBFGVariableAction
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"BFGVariableAction_QuestCompletion_Completed">();
	}
	static class UBFGVariableAction_QuestCompletion_Completed* GetDefaultObj()
	{
		return GetDefaultObjImpl<UBFGVariableAction_QuestCompletion_Completed>();
	}
};
static_assert(alignof(UBFGVariableAction_QuestCompletion_Completed) == 0x000008, "Wrong alignment on UBFGVariableAction_QuestCompletion_Completed");
static_assert(sizeof(UBFGVariableAction_QuestCompletion_Completed) == 0x0000F0, "Wrong size on UBFGVariableAction_QuestCompletion_Completed");

// Class BFGCore.BFGVariableAction_QuestCompletion_Replay
// 0x0000 (0x00F0 - 0x00F0)
class UBFGVariableAction_QuestCompletion_Replay final : public UBFGVariableAction
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"BFGVariableAction_QuestCompletion_Replay">();
	}
	static class UBFGVariableAction_QuestCompletion_Replay* GetDefaultObj()
	{
		return GetDefaultObjImpl<UBFGVariableAction_QuestCompletion_Replay>();
	}
};
static_assert(alignof(UBFGVariableAction_QuestCompletion_Replay) == 0x000008, "Wrong alignment on UBFGVariableAction_QuestCompletion_Replay");
static_assert(sizeof(UBFGVariableAction_QuestCompletion_Replay) == 0x0000F0, "Wrong size on UBFGVariableAction_QuestCompletion_Replay");

// Class BFGCore.BFGVariableAction_QuestCounter_Increase
// 0x0000 (0x00F0 - 0x00F0)
class UBFGVariableAction_QuestCounter_Increase final : public UBFGVariableAction
{
public:
	static const class FName GetActionName_QuestCounterIncrease();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"BFGVariableAction_QuestCounter_Increase">();
	}
	static class UBFGVariableAction_QuestCounter_Increase* GetDefaultObj()
	{
		return GetDefaultObjImpl<UBFGVariableAction_QuestCounter_Increase>();
	}
};
static_assert(alignof(UBFGVariableAction_QuestCounter_Increase) == 0x000008, "Wrong alignment on UBFGVariableAction_QuestCounter_Increase");
static_assert(sizeof(UBFGVariableAction_QuestCounter_Increase) == 0x0000F0, "Wrong size on UBFGVariableAction_QuestCounter_Increase");

// Class BFGCore.BFGVariableAction_RequestPlayback_Start
// 0x0000 (0x00F0 - 0x00F0)
class UBFGVariableAction_RequestPlayback_Start final : public UBFGVariableAction
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"BFGVariableAction_RequestPlayback_Start">();
	}
	static class UBFGVariableAction_RequestPlayback_Start* GetDefaultObj()
	{
		return GetDefaultObjImpl<UBFGVariableAction_RequestPlayback_Start>();
	}
};
static_assert(alignof(UBFGVariableAction_RequestPlayback_Start) == 0x000008, "Wrong alignment on UBFGVariableAction_RequestPlayback_Start");
static_assert(sizeof(UBFGVariableAction_RequestPlayback_Start) == 0x0000F0, "Wrong size on UBFGVariableAction_RequestPlayback_Start");

// Class BFGCore.BFGVariableAction_ScriptedSequence_Failed
// 0x0000 (0x00F0 - 0x00F0)
class UBFGVariableAction_ScriptedSequence_Failed final : public UBFGVariableAction
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"BFGVariableAction_ScriptedSequence_Failed">();
	}
	static class UBFGVariableAction_ScriptedSequence_Failed* GetDefaultObj()
	{
		return GetDefaultObjImpl<UBFGVariableAction_ScriptedSequence_Failed>();
	}
};
static_assert(alignof(UBFGVariableAction_ScriptedSequence_Failed) == 0x000008, "Wrong alignment on UBFGVariableAction_ScriptedSequence_Failed");
static_assert(sizeof(UBFGVariableAction_ScriptedSequence_Failed) == 0x0000F0, "Wrong size on UBFGVariableAction_ScriptedSequence_Failed");

// Class BFGCore.BFGVariableAction_ScriptedSequence_Completed
// 0x0000 (0x00F0 - 0x00F0)
class UBFGVariableAction_ScriptedSequence_Completed final : public UBFGVariableAction
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"BFGVariableAction_ScriptedSequence_Completed">();
	}
	static class UBFGVariableAction_ScriptedSequence_Completed* GetDefaultObj()
	{
		return GetDefaultObjImpl<UBFGVariableAction_ScriptedSequence_Completed>();
	}
};
static_assert(alignof(UBFGVariableAction_ScriptedSequence_Completed) == 0x000008, "Wrong alignment on UBFGVariableAction_ScriptedSequence_Completed");
static_assert(sizeof(UBFGVariableAction_ScriptedSequence_Completed) == 0x0000F0, "Wrong size on UBFGVariableAction_ScriptedSequence_Completed");

// Class BFGCore.BFGVariableAction_Timer_Start
// 0x0000 (0x00F0 - 0x00F0)
class UBFGVariableAction_Timer_Start final : public UBFGVariableAction
{
public:
	static const class FName GetActionName_TimerStart();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"BFGVariableAction_Timer_Start">();
	}
	static class UBFGVariableAction_Timer_Start* GetDefaultObj()
	{
		return GetDefaultObjImpl<UBFGVariableAction_Timer_Start>();
	}
};
static_assert(alignof(UBFGVariableAction_Timer_Start) == 0x000008, "Wrong alignment on UBFGVariableAction_Timer_Start");
static_assert(sizeof(UBFGVariableAction_Timer_Start) == 0x0000F0, "Wrong size on UBFGVariableAction_Timer_Start");

// Class BFGCore.BFGVariableAction_Timer_Run
// 0x0000 (0x00F0 - 0x00F0)
class UBFGVariableAction_Timer_Run final : public UBFGVariableAction
{
public:
	static const class FName GetActionName_TimerRun();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"BFGVariableAction_Timer_Run">();
	}
	static class UBFGVariableAction_Timer_Run* GetDefaultObj()
	{
		return GetDefaultObjImpl<UBFGVariableAction_Timer_Run>();
	}
};
static_assert(alignof(UBFGVariableAction_Timer_Run) == 0x000008, "Wrong alignment on UBFGVariableAction_Timer_Run");
static_assert(sizeof(UBFGVariableAction_Timer_Run) == 0x0000F0, "Wrong size on UBFGVariableAction_Timer_Run");

// Class BFGCore.BFGVariableMirror_Settings
// 0x0000 (0x0038 - 0x0038)
class UBFGVariableMirror_Settings final : public UDeveloperSettings
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"BFGVariableMirror_Settings">();
	}
	static class UBFGVariableMirror_Settings* GetDefaultObj()
	{
		return GetDefaultObjImpl<UBFGVariableMirror_Settings>();
	}
};
static_assert(alignof(UBFGVariableMirror_Settings) == 0x000008, "Wrong alignment on UBFGVariableMirror_Settings");
static_assert(sizeof(UBFGVariableMirror_Settings) == 0x000038, "Wrong size on UBFGVariableMirror_Settings");

// Class BFGCore.BFGVariableMirror
// 0x02F0 (0x0320 - 0x0030)
class UBFGVariableMirror final : public UBFGGameSystem
{
public:
	uint8                                         Pad_30[0x8];                                       // 0x0030(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	UMulticastDelegateProperty_                   M_OnValueChanged;                                  // 0x0038(0x0018)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	uint8                                         Pad_50[0x70];                                      // 0x0050(0x0070)(Fixing Size After Last Property [ Dumper-7 ])
	class ABFGGameState*                          M_pGameState;                                      // 0x00C0(0x0008)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UBFGVariableMessageServer*              M_pMessageServer;                                  // 0x00C8(0x0008)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TSet<TSubclassOf<class UBFGVariableType>>     M_aRuntimeTypeClasses;                             // 0x00D0(0x0050)(ZeroConstructor, Transient, Protected, UObjectWrapper, NativeAccessSpecifierProtected)
	TSet<TSubclassOf<class UBFGVariableAction>>   M_aRuntimeActionClasses;                           // 0x0120(0x0050)(ZeroConstructor, Transient, Protected, UObjectWrapper, NativeAccessSpecifierProtected)
	TMap<struct FGuid, class UBFGVariableAction*> M_aActions;                                        // 0x0170(0x0050)(ZeroConstructor, Transient, Protected, NativeAccessSpecifierProtected)
	TMap<struct FGuid, class UBFGVariable*>       M_aVariablesByGuid;                                // 0x01C0(0x0050)(ZeroConstructor, Transient, Protected, NativeAccessSpecifierProtected)
	TMap<class FName, class UBFGVariable*>        M_aVariablesByName;                                // 0x0210(0x0050)(ZeroConstructor, Transient, Protected, NativeAccessSpecifierProtected)
	uint8                                         Pad_260[0x50];                                     // 0x0260(0x0050)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<class UBFGVariableType*>               M_aVariableTypes;                                  // 0x02B0(0x0010)(ZeroConstructor, Transient, Protected, NativeAccessSpecifierProtected)
	TArray<class UBFGCustomDataVariable*>         M_apCustomDataVariables;                           // 0x02C0(0x0010)(ZeroConstructor, Transient, Protected, NativeAccessSpecifierProtected)
	TMap<class FName, float>                      M_aCustomDataValues;                               // 0x02D0(0x0050)(ZeroConstructor, Transient, Protected, NativeAccessSpecifierProtected)

public:
	void ApplyActionWithName(const class UBFGVariable* _pVariable, const class FName& _actionName);
	bool SetValue(const class UBFGVariable* _pVariable, int32 _value, bool _bReplicate, bool _bDoCallbacks);

	void GameSystem_VarMirrorLog() const;
	void GameSystem_VarMirrorLogName(class FName _strPartialVarName) const;
	class UBFGVariableAction* GetAction(const struct FGuid& _actionGuid) const;
	class UBFGVariableAction* GetActionByName(const class FName& _name) const;
	const TMap<struct FGuid, class UBFGVariable*> GetAllVariables() const;
	class UBFGVariableMirror_Settings* GetSettings() const;
	int32 GetValue(const class UBFGVariable* _pVariable) const;
	const class FName GetValueName(const class UBFGVariable* _pVariable) const;
	const class FName GetValueNameForValue(const class UBFGVariable* _pVariable, int32 _value) const;
	class UBFGVariable* GetVariable(const struct FGuid& _variableGuid) const;
	class UBFGVariable* GetVariableByName(const class FName& _name) const;
	class UBFGVariableType* GetVariableType(const class FName& _name) const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"BFGVariableMirror">();
	}
	static class UBFGVariableMirror* GetDefaultObj()
	{
		return GetDefaultObjImpl<UBFGVariableMirror>();
	}
};
static_assert(alignof(UBFGVariableMirror) == 0x000008, "Wrong alignment on UBFGVariableMirror");
static_assert(sizeof(UBFGVariableMirror) == 0x000320, "Wrong size on UBFGVariableMirror");
static_assert(offsetof(UBFGVariableMirror, M_OnValueChanged) == 0x000038, "Member 'UBFGVariableMirror::M_OnValueChanged' has a wrong offset!");
static_assert(offsetof(UBFGVariableMirror, M_pGameState) == 0x0000C0, "Member 'UBFGVariableMirror::M_pGameState' has a wrong offset!");
static_assert(offsetof(UBFGVariableMirror, M_pMessageServer) == 0x0000C8, "Member 'UBFGVariableMirror::M_pMessageServer' has a wrong offset!");
static_assert(offsetof(UBFGVariableMirror, M_aRuntimeTypeClasses) == 0x0000D0, "Member 'UBFGVariableMirror::M_aRuntimeTypeClasses' has a wrong offset!");
static_assert(offsetof(UBFGVariableMirror, M_aRuntimeActionClasses) == 0x000120, "Member 'UBFGVariableMirror::M_aRuntimeActionClasses' has a wrong offset!");
static_assert(offsetof(UBFGVariableMirror, M_aActions) == 0x000170, "Member 'UBFGVariableMirror::M_aActions' has a wrong offset!");
static_assert(offsetof(UBFGVariableMirror, M_aVariablesByGuid) == 0x0001C0, "Member 'UBFGVariableMirror::M_aVariablesByGuid' has a wrong offset!");
static_assert(offsetof(UBFGVariableMirror, M_aVariablesByName) == 0x000210, "Member 'UBFGVariableMirror::M_aVariablesByName' has a wrong offset!");
static_assert(offsetof(UBFGVariableMirror, M_aVariableTypes) == 0x0002B0, "Member 'UBFGVariableMirror::M_aVariableTypes' has a wrong offset!");
static_assert(offsetof(UBFGVariableMirror, M_apCustomDataVariables) == 0x0002C0, "Member 'UBFGVariableMirror::M_apCustomDataVariables' has a wrong offset!");
static_assert(offsetof(UBFGVariableMirror, M_aCustomDataValues) == 0x0002D0, "Member 'UBFGVariableMirror::M_aCustomDataValues' has a wrong offset!");

// Class BFGCore.BFGVariableType_AITaskState
// 0x0000 (0x0090 - 0x0090)
class UBFGVariableType_AITaskState final : public UBFGVariableType
{
public:
	static const class FName GetState_AITaskState_Available();
	static const class FName GetState_AITaskState_Completed();
	static const class FName GetState_AITaskState_Executing();
	static const class FName GetTypeName_AITaskState();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"BFGVariableType_AITaskState">();
	}
	static class UBFGVariableType_AITaskState* GetDefaultObj()
	{
		return GetDefaultObjImpl<UBFGVariableType_AITaskState>();
	}
};
static_assert(alignof(UBFGVariableType_AITaskState) == 0x000008, "Wrong alignment on UBFGVariableType_AITaskState");
static_assert(sizeof(UBFGVariableType_AITaskState) == 0x000090, "Wrong size on UBFGVariableType_AITaskState");

// Class BFGCore.BFGVariableType_Boolean
// 0x0000 (0x0090 - 0x0090)
class UBFGVariableType_Boolean final : public UBFGVariableType
{
public:
	static const class FName GetState_BooleanFalse();
	static const class FName GetState_BooleanTrue();
	static const class FName GetTypeName_Boolean();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"BFGVariableType_Boolean">();
	}
	static class UBFGVariableType_Boolean* GetDefaultObj()
	{
		return GetDefaultObjImpl<UBFGVariableType_Boolean>();
	}
};
static_assert(alignof(UBFGVariableType_Boolean) == 0x000008, "Wrong alignment on UBFGVariableType_Boolean");
static_assert(sizeof(UBFGVariableType_Boolean) == 0x000090, "Wrong size on UBFGVariableType_Boolean");

// Class BFGCore.BFGVariableType_QuestCompletion
// 0x0000 (0x0090 - 0x0090)
class UBFGVariableType_QuestCompletion final : public UBFGVariableType
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"BFGVariableType_QuestCompletion">();
	}
	static class UBFGVariableType_QuestCompletion* GetDefaultObj()
	{
		return GetDefaultObjImpl<UBFGVariableType_QuestCompletion>();
	}
};
static_assert(alignof(UBFGVariableType_QuestCompletion) == 0x000008, "Wrong alignment on UBFGVariableType_QuestCompletion");
static_assert(sizeof(UBFGVariableType_QuestCompletion) == 0x000090, "Wrong size on UBFGVariableType_QuestCompletion");

// Class BFGCore.BFGVariableType_QuestCounter
// 0x0000 (0x0090 - 0x0090)
class UBFGVariableType_QuestCounter final : public UBFGVariableType
{
public:
	static int32 GetMaxSupported_QuestCounterQuantity();
	static int32 GetQuestCounterForValue(int32 _iValue);
	static const class FName GetTypeName_QuestCounter();
	static int32 GetValueForQuestCounter(int32 _iQuantity);
	static class FName GetValueNameByQuestCounter(int32 _iQuantity);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"BFGVariableType_QuestCounter">();
	}
	static class UBFGVariableType_QuestCounter* GetDefaultObj()
	{
		return GetDefaultObjImpl<UBFGVariableType_QuestCounter>();
	}
};
static_assert(alignof(UBFGVariableType_QuestCounter) == 0x000008, "Wrong alignment on UBFGVariableType_QuestCounter");
static_assert(sizeof(UBFGVariableType_QuestCounter) == 0x000090, "Wrong size on UBFGVariableType_QuestCounter");

// Class BFGCore.BFGVariableType_ScriptedSequence
// 0x0000 (0x0090 - 0x0090)
class UBFGVariableType_ScriptedSequence final : public UBFGVariableType
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"BFGVariableType_ScriptedSequence">();
	}
	static class UBFGVariableType_ScriptedSequence* GetDefaultObj()
	{
		return GetDefaultObjImpl<UBFGVariableType_ScriptedSequence>();
	}
};
static_assert(alignof(UBFGVariableType_ScriptedSequence) == 0x000008, "Wrong alignment on UBFGVariableType_ScriptedSequence");
static_assert(sizeof(UBFGVariableType_ScriptedSequence) == 0x000090, "Wrong size on UBFGVariableType_ScriptedSequence");

// Class BFGCore.BFGVariableType_Timer
// 0x0000 (0x0090 - 0x0090)
class UBFGVariableType_Timer final : public UBFGVariableType
{
public:
	static const class FName GetState_TimerEnd();
	static const class FName GetState_TimerRunning();
	static const class FName GetState_TimerStart();
	static const class FName GetState_TimerStopped();
	static const class FName GetTypeName_Timer();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"BFGVariableType_Timer">();
	}
	static class UBFGVariableType_Timer* GetDefaultObj()
	{
		return GetDefaultObjImpl<UBFGVariableType_Timer>();
	}
};
static_assert(alignof(UBFGVariableType_Timer) == 0x000008, "Wrong alignment on UBFGVariableType_Timer");
static_assert(sizeof(UBFGVariableType_Timer) == 0x000090, "Wrong size on UBFGVariableType_Timer");

// Class BFGCore.BFGVehicleInterface
// 0x0000 (0x0028 - 0x0028)
class IBFGVehicleInterface final : public IInterface
{
public:
	void DestroySpotLight(bool _bRightSpot, bool _bLeftSpot);
	bool DetachVehicleComponent(class UStaticMeshComponent* MeshToDetach, float ImpulseAngularJitter, float VelocityFactorDivisor);
	void InterfaceSetupVehicle();
	bool ReleaseVehicleComponent(class UStaticMeshComponent* MeshToRelease);

	void SetEngineMeshesHiddenInGame(bool _bHidden) const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"BFGVehicleInterface">();
	}
	static class IBFGVehicleInterface* GetDefaultObj()
	{
		return GetDefaultObjImpl<IBFGVehicleInterface>();
	}
};
static_assert(alignof(IBFGVehicleInterface) == 0x000008, "Wrong alignment on IBFGVehicleInterface");
static_assert(sizeof(IBFGVehicleInterface) == 0x000028, "Wrong size on IBFGVehicleInterface");

// Class BFGCore.BFGVehiclePassengerContainer
// 0x0278 (0x02A0 - 0x0028)
class UBFGVehiclePassengerContainer final : public UObject
{
public:
	EBFGVehiclePassenger_AnimationSetupID         M_ePassengerAnimationSetup;                        // 0x0028(0x0001)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_29[0x7];                                       // 0x0029(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	struct FBFGVehiclePassenger_AnimationSetup    M_passengerAnimationSetup;                         // 0x0030(0x0030)(Transient, Protected, NativeAccessSpecifierProtected)
	TArray<struct FBFGVehiclePassengerSpot>       M_aPassengerSpots;                                 // 0x0060(0x0010)(ZeroConstructor, Transient, Protected, NativeAccessSpecifierProtected)
	struct FBFGVehiclePassengerSpot               M_driverSpot;                                      // 0x0070(0x0190)(Transient, Protected, NativeAccessSpecifierProtected)
	class UBFGNetworkPathAgent_Vehicle*           M_pVehicle;                                        // 0x0200(0x0008)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          M_bInitialized;                                    // 0x0208(0x0001)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          M_bPassengersSpawned;                              // 0x0209(0x0001)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_20A[0x2];                                      // 0x020A(0x0002)(Fixing Size After Last Property [ Dumper-7 ])
	class FName                                   M_BackDoorBoneName;                                // 0x020C(0x0008)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class FName                                   M_transportExitSocketName;                         // 0x0214(0x0008)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_21C[0x4];                                      // 0x021C(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	struct FTransform                             M_transportExitRelativeTransform;                  // 0x0220(0x0030)(Transient, IsPlainOldData, NoDestructor, Protected, NativeAccessSpecifierProtected)
	bool                                          M_bTransportExitLocationCached;                    // 0x0250(0x0001)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_251[0x7];                                      // 0x0251(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	TSoftObjectPtr<class UBFGSpawningComposition> M_pNPCSpawningCompostion;                          // 0x0258(0x0028)(Transient, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TArray<int32>                                 M_aTransportSpotsExitOrder;                        // 0x0280(0x0010)(ZeroConstructor, Transient, Protected, NativeAccessSpecifierProtected)
	bool                                          M_bDriverIsDead;                                   // 0x0290(0x0001)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_291[0xF];                                      // 0x0291(0x000F)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void OnInteractAnimationChangedCallback(TScriptInterface<class IBFGInteractAnimationPlayerInterface> _pInteractAnimationPlayer, const struct FBFGInteractAnimationData& _newData, const struct FBFGInteractAnimationData& _oldData);
	void OnPassengerKilled(class UBFGNetworkPathAgent* _pAgent, class AActor* _pActor, bool _bAttached);
	void OnVehicleDestroyed(class UBFGNetworkPathAgent* _pAgent);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"BFGVehiclePassengerContainer">();
	}
	static class UBFGVehiclePassengerContainer* GetDefaultObj()
	{
		return GetDefaultObjImpl<UBFGVehiclePassengerContainer>();
	}
};
static_assert(alignof(UBFGVehiclePassengerContainer) == 0x000010, "Wrong alignment on UBFGVehiclePassengerContainer");
static_assert(sizeof(UBFGVehiclePassengerContainer) == 0x0002A0, "Wrong size on UBFGVehiclePassengerContainer");
static_assert(offsetof(UBFGVehiclePassengerContainer, M_ePassengerAnimationSetup) == 0x000028, "Member 'UBFGVehiclePassengerContainer::M_ePassengerAnimationSetup' has a wrong offset!");
static_assert(offsetof(UBFGVehiclePassengerContainer, M_passengerAnimationSetup) == 0x000030, "Member 'UBFGVehiclePassengerContainer::M_passengerAnimationSetup' has a wrong offset!");
static_assert(offsetof(UBFGVehiclePassengerContainer, M_aPassengerSpots) == 0x000060, "Member 'UBFGVehiclePassengerContainer::M_aPassengerSpots' has a wrong offset!");
static_assert(offsetof(UBFGVehiclePassengerContainer, M_driverSpot) == 0x000070, "Member 'UBFGVehiclePassengerContainer::M_driverSpot' has a wrong offset!");
static_assert(offsetof(UBFGVehiclePassengerContainer, M_pVehicle) == 0x000200, "Member 'UBFGVehiclePassengerContainer::M_pVehicle' has a wrong offset!");
static_assert(offsetof(UBFGVehiclePassengerContainer, M_bInitialized) == 0x000208, "Member 'UBFGVehiclePassengerContainer::M_bInitialized' has a wrong offset!");
static_assert(offsetof(UBFGVehiclePassengerContainer, M_bPassengersSpawned) == 0x000209, "Member 'UBFGVehiclePassengerContainer::M_bPassengersSpawned' has a wrong offset!");
static_assert(offsetof(UBFGVehiclePassengerContainer, M_BackDoorBoneName) == 0x00020C, "Member 'UBFGVehiclePassengerContainer::M_BackDoorBoneName' has a wrong offset!");
static_assert(offsetof(UBFGVehiclePassengerContainer, M_transportExitSocketName) == 0x000214, "Member 'UBFGVehiclePassengerContainer::M_transportExitSocketName' has a wrong offset!");
static_assert(offsetof(UBFGVehiclePassengerContainer, M_transportExitRelativeTransform) == 0x000220, "Member 'UBFGVehiclePassengerContainer::M_transportExitRelativeTransform' has a wrong offset!");
static_assert(offsetof(UBFGVehiclePassengerContainer, M_bTransportExitLocationCached) == 0x000250, "Member 'UBFGVehiclePassengerContainer::M_bTransportExitLocationCached' has a wrong offset!");
static_assert(offsetof(UBFGVehiclePassengerContainer, M_pNPCSpawningCompostion) == 0x000258, "Member 'UBFGVehiclePassengerContainer::M_pNPCSpawningCompostion' has a wrong offset!");
static_assert(offsetof(UBFGVehiclePassengerContainer, M_aTransportSpotsExitOrder) == 0x000280, "Member 'UBFGVehiclePassengerContainer::M_aTransportSpotsExitOrder' has a wrong offset!");
static_assert(offsetof(UBFGVehiclePassengerContainer, M_bDriverIsDead) == 0x000290, "Member 'UBFGVehiclePassengerContainer::M_bDriverIsDead' has a wrong offset!");

// Class BFGCore.BFGVirtualCrowdManager
// 0x00B8 (0x00E8 - 0x0030)
class UBFGVirtualCrowdManager : public UBFGGameSystem
{
public:
	TSubclassOf<class ABFGVirtualCrowd>           M_pVirtualCrowdClass;                              // 0x0030(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	TMap<class FName, struct FBFGVehicleVariationEntry> M_VehicleVariationTable;                           // 0x0038(0x0050)(ZeroConstructor, Transient, NativeAccessSpecifierPrivate)
	TMap<class FName, struct FBFGNPCSubVariationEntry> M_NPCSubVariationTable;                            // 0x0088(0x0050)(ZeroConstructor, Transient, NativeAccessSpecifierPrivate)
	class ABFGGameState*                          M_pGameState;                                      // 0x00D8(0x0008)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_E0[0x8];                                       // 0x00E0(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	class ABFGVirtualCrowd* GetCrowdActor();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"BFGVirtualCrowdManager">();
	}
	static class UBFGVirtualCrowdManager* GetDefaultObj()
	{
		return GetDefaultObjImpl<UBFGVirtualCrowdManager>();
	}
};
static_assert(alignof(UBFGVirtualCrowdManager) == 0x000008, "Wrong alignment on UBFGVirtualCrowdManager");
static_assert(sizeof(UBFGVirtualCrowdManager) == 0x0000E8, "Wrong size on UBFGVirtualCrowdManager");
static_assert(offsetof(UBFGVirtualCrowdManager, M_pVirtualCrowdClass) == 0x000030, "Member 'UBFGVirtualCrowdManager::M_pVirtualCrowdClass' has a wrong offset!");
static_assert(offsetof(UBFGVirtualCrowdManager, M_VehicleVariationTable) == 0x000038, "Member 'UBFGVirtualCrowdManager::M_VehicleVariationTable' has a wrong offset!");
static_assert(offsetof(UBFGVirtualCrowdManager, M_NPCSubVariationTable) == 0x000088, "Member 'UBFGVirtualCrowdManager::M_NPCSubVariationTable' has a wrong offset!");
static_assert(offsetof(UBFGVirtualCrowdManager, M_pGameState) == 0x0000D8, "Member 'UBFGVirtualCrowdManager::M_pGameState' has a wrong offset!");

// Class BFGCore.BFGVisibilityChecker_Box
// 0x0008 (0x03E0 - 0x03D8)
class ABFGVisibilityChecker_Box final : public AActor
{
public:
	class UBoxComponent*                          M_pVisibilityProxyComponent;                       // 0x03D8(0x0008)(Edit, ExportObject, ZeroConstructor, EditConst, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"BFGVisibilityChecker_Box">();
	}
	static class ABFGVisibilityChecker_Box* GetDefaultObj()
	{
		return GetDefaultObjImpl<ABFGVisibilityChecker_Box>();
	}
};
static_assert(alignof(ABFGVisibilityChecker_Box) == 0x000008, "Wrong alignment on ABFGVisibilityChecker_Box");
static_assert(sizeof(ABFGVisibilityChecker_Box) == 0x0003E0, "Wrong size on ABFGVisibilityChecker_Box");
static_assert(offsetof(ABFGVisibilityChecker_Box, M_pVisibilityProxyComponent) == 0x0003D8, "Member 'ABFGVisibilityChecker_Box::M_pVisibilityProxyComponent' has a wrong offset!");

// Class BFGCore.BFGVoiceoverItemResolver
// 0x0010 (0x0038 - 0x0028)
class UBFGVoiceoverItemResolver final : public UObject
{
public:
	class ABFGGameState*                          M_pGameState;                                      // 0x0028(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UBFGVoiceoverSettings*                  M_pSettings;                                       // 0x0030(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"BFGVoiceoverItemResolver">();
	}
	static class UBFGVoiceoverItemResolver* GetDefaultObj()
	{
		return GetDefaultObjImpl<UBFGVoiceoverItemResolver>();
	}
};
static_assert(alignof(UBFGVoiceoverItemResolver) == 0x000008, "Wrong alignment on UBFGVoiceoverItemResolver");
static_assert(sizeof(UBFGVoiceoverItemResolver) == 0x000038, "Wrong size on UBFGVoiceoverItemResolver");
static_assert(offsetof(UBFGVoiceoverItemResolver, M_pGameState) == 0x000028, "Member 'UBFGVoiceoverItemResolver::M_pGameState' has a wrong offset!");
static_assert(offsetof(UBFGVoiceoverItemResolver, M_pSettings) == 0x000030, "Member 'UBFGVoiceoverItemResolver::M_pSettings' has a wrong offset!");

// Class BFGCore.BFGVoiceoverPlaybackActor
// 0x02B0 (0x0688 - 0x03D8)
class ABFGVoiceoverPlaybackActor final : public AActor
{
public:
	UMulticastDelegateProperty_                   M_onPlaybackStoppedEvent;                          // 0x03D8(0x0018)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	EBFGPlaybackComponentState                    M_currentState;                                    // 0x03F0(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_3F1[0x7];                                      // 0x03F1(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	struct FBFGVoiceoverPlaybackRequest           M_currentRequest;                                  // 0x03F8(0x0130)(NativeAccessSpecifierPrivate)
	struct FBFGVoiceoverPlaybackRequest           M_nextRequest;                                     // 0x0528(0x0130)(NativeAccessSpecifierPrivate)
	uint8                                         Pad_658[0x1];                                      // 0x0658(0x0001)(Fixing Size After Last Property [ Dumper-7 ])
	bool                                          M_bHasNextRequest;                                 // 0x0659(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_65A[0x2];                                      // 0x065A(0x0002)(Fixing Size After Last Property [ Dumper-7 ])
	int32                                         M_iWaitingForClients;                              // 0x065C(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	float                                         M_fRemainingTimeout;                               // 0x0660(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	float                                         M_fRemainingWaiting;                               // 0x0664(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UBFGVoiceoverSystem*                    M_pVoiceoverSystem;                                // 0x0668(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class ABFGPlayerController*                   M_pPlayerController;                               // 0x0670(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UBFGVoiceoverPlaybackComponent*         M_pPlaybackComponent;                              // 0x0678(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	bool                                          M_bDebugEnabled;                                   // 0x0680(0x0001)(Net, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_681[0x7];                                      // 0x0681(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void BFGOnItemPlaybackStopped_Delegate__DelegateSignature();
	void CancelItem_NetMulticast(float _fOverrideFadeoutDuration);
	void OnItemPlaybackStopped();
	void PlayItem_NetMulticast(const struct FBFGVoiceoverPlaybackRequest& _queueItem);
	void SetPauseItem_NetMulticast(bool _bIsPaused);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"BFGVoiceoverPlaybackActor">();
	}
	static class ABFGVoiceoverPlaybackActor* GetDefaultObj()
	{
		return GetDefaultObjImpl<ABFGVoiceoverPlaybackActor>();
	}
};
static_assert(alignof(ABFGVoiceoverPlaybackActor) == 0x000008, "Wrong alignment on ABFGVoiceoverPlaybackActor");
static_assert(sizeof(ABFGVoiceoverPlaybackActor) == 0x000688, "Wrong size on ABFGVoiceoverPlaybackActor");
static_assert(offsetof(ABFGVoiceoverPlaybackActor, M_onPlaybackStoppedEvent) == 0x0003D8, "Member 'ABFGVoiceoverPlaybackActor::M_onPlaybackStoppedEvent' has a wrong offset!");
static_assert(offsetof(ABFGVoiceoverPlaybackActor, M_currentState) == 0x0003F0, "Member 'ABFGVoiceoverPlaybackActor::M_currentState' has a wrong offset!");
static_assert(offsetof(ABFGVoiceoverPlaybackActor, M_currentRequest) == 0x0003F8, "Member 'ABFGVoiceoverPlaybackActor::M_currentRequest' has a wrong offset!");
static_assert(offsetof(ABFGVoiceoverPlaybackActor, M_nextRequest) == 0x000528, "Member 'ABFGVoiceoverPlaybackActor::M_nextRequest' has a wrong offset!");
static_assert(offsetof(ABFGVoiceoverPlaybackActor, M_bHasNextRequest) == 0x000659, "Member 'ABFGVoiceoverPlaybackActor::M_bHasNextRequest' has a wrong offset!");
static_assert(offsetof(ABFGVoiceoverPlaybackActor, M_iWaitingForClients) == 0x00065C, "Member 'ABFGVoiceoverPlaybackActor::M_iWaitingForClients' has a wrong offset!");
static_assert(offsetof(ABFGVoiceoverPlaybackActor, M_fRemainingTimeout) == 0x000660, "Member 'ABFGVoiceoverPlaybackActor::M_fRemainingTimeout' has a wrong offset!");
static_assert(offsetof(ABFGVoiceoverPlaybackActor, M_fRemainingWaiting) == 0x000664, "Member 'ABFGVoiceoverPlaybackActor::M_fRemainingWaiting' has a wrong offset!");
static_assert(offsetof(ABFGVoiceoverPlaybackActor, M_pVoiceoverSystem) == 0x000668, "Member 'ABFGVoiceoverPlaybackActor::M_pVoiceoverSystem' has a wrong offset!");
static_assert(offsetof(ABFGVoiceoverPlaybackActor, M_pPlayerController) == 0x000670, "Member 'ABFGVoiceoverPlaybackActor::M_pPlayerController' has a wrong offset!");
static_assert(offsetof(ABFGVoiceoverPlaybackActor, M_pPlaybackComponent) == 0x000678, "Member 'ABFGVoiceoverPlaybackActor::M_pPlaybackComponent' has a wrong offset!");
static_assert(offsetof(ABFGVoiceoverPlaybackActor, M_bDebugEnabled) == 0x000680, "Member 'ABFGVoiceoverPlaybackActor::M_bDebugEnabled' has a wrong offset!");

// Class BFGCore.BFGVoiceoverPlaybackComponent_Furocom
// 0x0050 (0x02E8 - 0x0298)
class UBFGVoiceoverPlaybackComponent_Furocom final : public UBFGVoiceoverPlaybackComponent_Simple
{
public:
	uint8                                         Pad_298[0x8];                                      // 0x0298(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	class FText                                   M_strSubtitleText;                                 // 0x02A0(0x0018)(BlueprintVisible, BlueprintReadOnly, NativeAccessSpecifierPublic)
	class FText                                   M_strSpeakerVoice;                                 // 0x02B8(0x0018)(BlueprintVisible, BlueprintReadOnly, NativeAccessSpecifierPublic)
	bool                                          M_bShowWidget;                                     // 0x02D0(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2D1[0x7];                                      // 0x02D1(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	class UTexture2D*                             M_pSpeakerPortrait;                                // 0x02D8(0x0008)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2E0[0x8];                                      // 0x02E0(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"BFGVoiceoverPlaybackComponent_Furocom">();
	}
	static class UBFGVoiceoverPlaybackComponent_Furocom* GetDefaultObj()
	{
		return GetDefaultObjImpl<UBFGVoiceoverPlaybackComponent_Furocom>();
	}
};
static_assert(alignof(UBFGVoiceoverPlaybackComponent_Furocom) == 0x000008, "Wrong alignment on UBFGVoiceoverPlaybackComponent_Furocom");
static_assert(sizeof(UBFGVoiceoverPlaybackComponent_Furocom) == 0x0002E8, "Wrong size on UBFGVoiceoverPlaybackComponent_Furocom");
static_assert(offsetof(UBFGVoiceoverPlaybackComponent_Furocom, M_strSubtitleText) == 0x0002A0, "Member 'UBFGVoiceoverPlaybackComponent_Furocom::M_strSubtitleText' has a wrong offset!");
static_assert(offsetof(UBFGVoiceoverPlaybackComponent_Furocom, M_strSpeakerVoice) == 0x0002B8, "Member 'UBFGVoiceoverPlaybackComponent_Furocom::M_strSpeakerVoice' has a wrong offset!");
static_assert(offsetof(UBFGVoiceoverPlaybackComponent_Furocom, M_bShowWidget) == 0x0002D0, "Member 'UBFGVoiceoverPlaybackComponent_Furocom::M_bShowWidget' has a wrong offset!");
static_assert(offsetof(UBFGVoiceoverPlaybackComponent_Furocom, M_pSpeakerPortrait) == 0x0002D8, "Member 'UBFGVoiceoverPlaybackComponent_Furocom::M_pSpeakerPortrait' has a wrong offset!");

// Class BFGCore.BFGVoiceoverQueue
// 0x02B0 (0x02D8 - 0x0028)
class UBFGVoiceoverQueue final : public UObject
{
public:
	uint8                                         Pad_28[0x10];                                      // 0x0028(0x0010)(Fixing Size After Last Property [ Dumper-7 ])
	struct FBFGVoiceoverQueuedRequest             M_currentPlayingElement;                           // 0x0038(0x0140)(Protected, NativeAccessSpecifierProtected)
	TArray<struct FBFGVoiceoverQueuedRequest>     M_aPlaybackQueue;                                  // 0x0178(0x0010)(ZeroConstructor, Protected, NativeAccessSpecifierProtected)
	uint8                                         Pad_188[0x8];                                      // 0x0188(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	TSet<class UBFGVoiceoverGroup*>               M_apMutedGroupExceptions;                          // 0x0190(0x0050)(ZeroConstructor, Protected, NativeAccessSpecifierProtected)
	TSet<class UBFGVoiceoverGroup*>               M_apPreviousMutedGroupExceptions;                  // 0x01E0(0x0050)(ZeroConstructor, Protected, NativeAccessSpecifierProtected)
	uint8                                         Pad_230[0x8];                                      // 0x0230(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	class UBFGVoiceoverGroup*                     M_pLastPlayedGroup;                                // 0x0238(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_240[0x50];                                     // 0x0240(0x0050)(Fixing Size After Last Property [ Dumper-7 ])
	class ABFGGameState*                          M_pGameState;                                      // 0x0290(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class ABFGVoiceoverPlaybackActor*             M_pPlaybackActor;                                  // 0x0298(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UBFGVoiceoverStatistics*                M_pStatistics;                                     // 0x02A0(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UBFGVoiceoverItemResolver*              M_pResolver;                                       // 0x02A8(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UBFGVoiceoverSettings*                  M_pSettings;                                       // 0x02B0(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_2B8[0x20];                                     // 0x02B8(0x0020)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	int32 CountSpeakerInQueue(class FName _speakerVoice);
	void OnItemPlaybackStopped();

	class UBFGVoiceoverPlaybackComponent* GetCurrentPlayingComponent() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"BFGVoiceoverQueue">();
	}
	static class UBFGVoiceoverQueue* GetDefaultObj()
	{
		return GetDefaultObjImpl<UBFGVoiceoverQueue>();
	}
};
static_assert(alignof(UBFGVoiceoverQueue) == 0x000008, "Wrong alignment on UBFGVoiceoverQueue");
static_assert(sizeof(UBFGVoiceoverQueue) == 0x0002D8, "Wrong size on UBFGVoiceoverQueue");
static_assert(offsetof(UBFGVoiceoverQueue, M_currentPlayingElement) == 0x000038, "Member 'UBFGVoiceoverQueue::M_currentPlayingElement' has a wrong offset!");
static_assert(offsetof(UBFGVoiceoverQueue, M_aPlaybackQueue) == 0x000178, "Member 'UBFGVoiceoverQueue::M_aPlaybackQueue' has a wrong offset!");
static_assert(offsetof(UBFGVoiceoverQueue, M_apMutedGroupExceptions) == 0x000190, "Member 'UBFGVoiceoverQueue::M_apMutedGroupExceptions' has a wrong offset!");
static_assert(offsetof(UBFGVoiceoverQueue, M_apPreviousMutedGroupExceptions) == 0x0001E0, "Member 'UBFGVoiceoverQueue::M_apPreviousMutedGroupExceptions' has a wrong offset!");
static_assert(offsetof(UBFGVoiceoverQueue, M_pLastPlayedGroup) == 0x000238, "Member 'UBFGVoiceoverQueue::M_pLastPlayedGroup' has a wrong offset!");
static_assert(offsetof(UBFGVoiceoverQueue, M_pGameState) == 0x000290, "Member 'UBFGVoiceoverQueue::M_pGameState' has a wrong offset!");
static_assert(offsetof(UBFGVoiceoverQueue, M_pPlaybackActor) == 0x000298, "Member 'UBFGVoiceoverQueue::M_pPlaybackActor' has a wrong offset!");
static_assert(offsetof(UBFGVoiceoverQueue, M_pStatistics) == 0x0002A0, "Member 'UBFGVoiceoverQueue::M_pStatistics' has a wrong offset!");
static_assert(offsetof(UBFGVoiceoverQueue, M_pResolver) == 0x0002A8, "Member 'UBFGVoiceoverQueue::M_pResolver' has a wrong offset!");
static_assert(offsetof(UBFGVoiceoverQueue, M_pSettings) == 0x0002B0, "Member 'UBFGVoiceoverQueue::M_pSettings' has a wrong offset!");

// Class BFGCore.BFGVoiceoverQueueDefinition
// 0x0010 (0x0040 - 0x0030)
class UBFGVoiceoverQueueDefinition final : public UDataAsset
{
public:
	class FString                                 M_strDescription;                                  // 0x0030(0x0010)(Edit, BlueprintVisible, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"BFGVoiceoverQueueDefinition">();
	}
	static class UBFGVoiceoverQueueDefinition* GetDefaultObj()
	{
		return GetDefaultObjImpl<UBFGVoiceoverQueueDefinition>();
	}
};
static_assert(alignof(UBFGVoiceoverQueueDefinition) == 0x000008, "Wrong alignment on UBFGVoiceoverQueueDefinition");
static_assert(sizeof(UBFGVoiceoverQueueDefinition) == 0x000040, "Wrong size on UBFGVoiceoverQueueDefinition");
static_assert(offsetof(UBFGVoiceoverQueueDefinition, M_strDescription) == 0x000030, "Member 'UBFGVoiceoverQueueDefinition::M_strDescription' has a wrong offset!");

// Class BFGCore.BFGVoiceoverRouter
// 0x0098 (0x00C0 - 0x0028)
class UBFGVoiceoverRouter final : public UObject
{
public:
	uint8                                         Pad_28[0x8];                                       // 0x0028(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	class ABFGGameState*                          M_pGameState;                                      // 0x0030(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TMap<class UBFGVoiceoverQueueDefinition*, TScriptInterface<class IBFGVoiceoverQueueInterface>> M_apQueues;                                        // 0x0038(0x0050)(ZeroConstructor, Protected, UObjectWrapper, NativeAccessSpecifierProtected)
	class UBFGVoiceoverSettings*                  M_pSettings;                                       // 0x0088(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UBFGVoiceoverItemResolver*              M_pResolver;                                       // 0x0090(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_98[0x28];                                      // 0x0098(0x0028)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void OnItemEvent(const struct FBFGVoiceoverItem& _item, const EBFGVoiceoverItemEventType _type);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"BFGVoiceoverRouter">();
	}
	static class UBFGVoiceoverRouter* GetDefaultObj()
	{
		return GetDefaultObjImpl<UBFGVoiceoverRouter>();
	}
};
static_assert(alignof(UBFGVoiceoverRouter) == 0x000008, "Wrong alignment on UBFGVoiceoverRouter");
static_assert(sizeof(UBFGVoiceoverRouter) == 0x0000C0, "Wrong size on UBFGVoiceoverRouter");
static_assert(offsetof(UBFGVoiceoverRouter, M_pGameState) == 0x000030, "Member 'UBFGVoiceoverRouter::M_pGameState' has a wrong offset!");
static_assert(offsetof(UBFGVoiceoverRouter, M_apQueues) == 0x000038, "Member 'UBFGVoiceoverRouter::M_apQueues' has a wrong offset!");
static_assert(offsetof(UBFGVoiceoverRouter, M_pSettings) == 0x000088, "Member 'UBFGVoiceoverRouter::M_pSettings' has a wrong offset!");
static_assert(offsetof(UBFGVoiceoverRouter, M_pResolver) == 0x000090, "Member 'UBFGVoiceoverRouter::M_pResolver' has a wrong offset!");

// Class BFGCore.BFGVoiceoverSettings
// 0x0140 (0x0178 - 0x0038)
class UBFGVoiceoverSettings final : public UDeveloperSettings
{
public:
	TSoftObjectPtr<class UBFGVoiceoverGroup>      M_pDefaultGroup;                                   // 0x0038(0x0028)(Edit, Config, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TSoftClassPtr<class UClass>                   M_pDefaultPlaybackComponment;                      // 0x0060(0x0028)(Edit, Config, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   M_keySpeaker;                                      // 0x0088(0x0008)(Edit, ZeroConstructor, Config, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   M_keyWaveFileName;                                 // 0x0090(0x0008)(Edit, ZeroConstructor, Config, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   M_keyGroup;                                        // 0x0098(0x0008)(Edit, ZeroConstructor, Config, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FString                                 M_strSoundLookupPattern;                           // 0x00A0(0x0010)(Edit, ZeroConstructor, Config, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TMap<class FName, TSoftObjectPtr<class UBFGVoiceoverGroup>> M_apResolveGroups;                                 // 0x00B0(0x0050)(Edit, ZeroConstructor, Config, UObjectWrapper, NativeAccessSpecifierPublic)
	TSoftObjectPtr<class USoundBase>              M_pFallbackSoundAsset;                             // 0x0100(0x0028)(Edit, Config, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TMap<class FName, TSoftObjectPtr<class UTexture2D>> M_apSpeakerPortraits;                              // 0x0128(0x0050)(Edit, ZeroConstructor, Config, UObjectWrapper, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"BFGVoiceoverSettings">();
	}
	static class UBFGVoiceoverSettings* GetDefaultObj()
	{
		return GetDefaultObjImpl<UBFGVoiceoverSettings>();
	}
};
static_assert(alignof(UBFGVoiceoverSettings) == 0x000008, "Wrong alignment on UBFGVoiceoverSettings");
static_assert(sizeof(UBFGVoiceoverSettings) == 0x000178, "Wrong size on UBFGVoiceoverSettings");
static_assert(offsetof(UBFGVoiceoverSettings, M_pDefaultGroup) == 0x000038, "Member 'UBFGVoiceoverSettings::M_pDefaultGroup' has a wrong offset!");
static_assert(offsetof(UBFGVoiceoverSettings, M_pDefaultPlaybackComponment) == 0x000060, "Member 'UBFGVoiceoverSettings::M_pDefaultPlaybackComponment' has a wrong offset!");
static_assert(offsetof(UBFGVoiceoverSettings, M_keySpeaker) == 0x000088, "Member 'UBFGVoiceoverSettings::M_keySpeaker' has a wrong offset!");
static_assert(offsetof(UBFGVoiceoverSettings, M_keyWaveFileName) == 0x000090, "Member 'UBFGVoiceoverSettings::M_keyWaveFileName' has a wrong offset!");
static_assert(offsetof(UBFGVoiceoverSettings, M_keyGroup) == 0x000098, "Member 'UBFGVoiceoverSettings::M_keyGroup' has a wrong offset!");
static_assert(offsetof(UBFGVoiceoverSettings, M_strSoundLookupPattern) == 0x0000A0, "Member 'UBFGVoiceoverSettings::M_strSoundLookupPattern' has a wrong offset!");
static_assert(offsetof(UBFGVoiceoverSettings, M_apResolveGroups) == 0x0000B0, "Member 'UBFGVoiceoverSettings::M_apResolveGroups' has a wrong offset!");
static_assert(offsetof(UBFGVoiceoverSettings, M_pFallbackSoundAsset) == 0x000100, "Member 'UBFGVoiceoverSettings::M_pFallbackSoundAsset' has a wrong offset!");
static_assert(offsetof(UBFGVoiceoverSettings, M_apSpeakerPortraits) == 0x000128, "Member 'UBFGVoiceoverSettings::M_apSpeakerPortraits' has a wrong offset!");

// Class BFGCore.BFGVoiceoverUtils
// 0x0000 (0x0028 - 0x0028)
class UBFGVoiceoverUtils final : public UObject
{
public:
	static bool AreAllVoiceoverGroupsMuted(class UObject* _pWorldContextObject);
	static bool IsAnyVoiceoverPlaying(class UObject* _pWorldContextObject);
	static bool IsVoiceoverGroupMuted(class UObject* _pWorldContextObject, TSoftObjectPtr<class UBFGVoiceoverGroup> _pGroup);
	static EBFGVoiceoverPlaybackState IsVoiceoverGroupPlaying(class UObject* _pWorldContextObject, TSoftObjectPtr<class UBFGVoiceoverGroup> _pGroup);
	static EBFGVoiceoverPlaybackState IsVoiceoverPlaying(class UObject* _pWorldContextObject, const class FText& _stringTableEntry);
	static void MuteAllVoiceoverGroups(class UObject* _pWorldContextObject, bool _bCancelIfPlayingItem);
	static void MuteVoiceoverGroup(class UObject* _pWorldContextObject, TSoftObjectPtr<class UBFGVoiceoverGroup> _pGroup, bool _bCancelIfPlayingItem);
	static void PlayVoiceover(class UObject* _pWorldContextObject, const class FText& _stringTableEntry, const struct FBFGVoiceoverPlaybackRequest& _request, const struct FLatentActionInfo& _latentInfo, EBFGVoiceoverResultType* _outResult);
	static void SetRunWhileGameplayPaused(class UObject* _pWorldContextObject, bool _bRunWhileGameplayPaused);
	static void StopAllVoiceoversInGroup(class UObject* _pWorldContextObject, TSoftObjectPtr<class UBFGVoiceoverGroup> _pGroup, bool _bCancelIfPlayingItem);
	static void StopAllVoicovers(class UObject* _pWorldContextObject, bool _bCancelPlayingItem, float _fOverrideFadeoutDuration);
	static void StopVoiceover(class UObject* _pWorldContextObject, const class FText& _stringTableEntry, bool _bCancelIfPlayingItem);
	static void TriggerVoiceover(class UObject* _pWorldContextObject, const class FText& _stringTableEntry, const struct FBFGVoiceoverPlaybackRequest& _request);
	static void UnmuteAllVoiceoverGroups(class UObject* _pWorldContextObject, float _fSilenceDuration, bool _bRestoreExceptions);
	static void UnmuteVoiceoverGroup(class UObject* _pWorldContextObject, TSoftObjectPtr<class UBFGVoiceoverGroup> _pGroup, float _fAddSilenceDuration);
	static void WaitForVoiceover(class UObject* _pWorldContextObject, const class FText& _stringTableEntry, const struct FLatentActionInfo& _latentInfo, EBFGVoiceoverResultType* _outResult);
	static void WaitForVoiceoverGroup(class UObject* _pWorldContextObject, TSoftObjectPtr<class UBFGVoiceoverGroup> _pGroup, const struct FLatentActionInfo& _latentInfo);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"BFGVoiceoverUtils">();
	}
	static class UBFGVoiceoverUtils* GetDefaultObj()
	{
		return GetDefaultObjImpl<UBFGVoiceoverUtils>();
	}
};
static_assert(alignof(UBFGVoiceoverUtils) == 0x000008, "Wrong alignment on UBFGVoiceoverUtils");
static_assert(sizeof(UBFGVoiceoverUtils) == 0x000028, "Wrong size on UBFGVoiceoverUtils");

// Class BFGCore.BFGWaterManager
// 0x20080 (0x200B0 - 0x0030)
class UBFGWaterManager final : public UBFGGameSystem
{
public:
	class ABFGGameState*                          M_pGameState;                                      // 0x0030(0x0008)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	TMap<class AActor*, struct FBFGWaterManagerCachedActor> M_oWaterActorCache;                                // 0x0038(0x0050)(ZeroConstructor, Transient, ContainsInstancedReference, NativeAccessSpecifierPrivate)
	uint8                                         Pad_88[0x20018];                                   // 0x0088(0x20018)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<class AActor*>                         M_aPendingActors;                                  // 0x200A0(0x0010)(ZeroConstructor, Transient, NativeAccessSpecifierPrivate)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"BFGWaterManager">();
	}
	static class UBFGWaterManager* GetDefaultObj()
	{
		return GetDefaultObjImpl<UBFGWaterManager>();
	}
};
static_assert(alignof(UBFGWaterManager) == 0x000008, "Wrong alignment on UBFGWaterManager");
static_assert(sizeof(UBFGWaterManager) == 0x0200B0, "Wrong size on UBFGWaterManager");
static_assert(offsetof(UBFGWaterManager, M_pGameState) == 0x000030, "Member 'UBFGWaterManager::M_pGameState' has a wrong offset!");
static_assert(offsetof(UBFGWaterManager, M_oWaterActorCache) == 0x000038, "Member 'UBFGWaterManager::M_oWaterActorCache' has a wrong offset!");
static_assert(offsetof(UBFGWaterManager, M_aPendingActors) == 0x0200A0, "Member 'UBFGWaterManager::M_aPendingActors' has a wrong offset!");

// Class BFGCore.BFGWeapon_AnalProbe
// 0x00B8 (0x0808 - 0x0750)
class ABFGWeapon_AnalProbe : public ABFGWeapon_BaseProjectile
{
public:
	struct FGameplayTag                           M_tUpgradeTagSnifferSensors;                       // 0x0750(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, DisableEditOnInstance, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FGameplayTag                           M_tUpgradeTagProboscisSensors;                     // 0x0758(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, DisableEditOnInstance, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FGameplayTag                           M_tUpgradeTagCentipedalProbulator;                 // 0x0760(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, DisableEditOnInstance, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FGameplayTag                           M_tUpgradeTagButtPressureAmplifier;                // 0x0768(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, DisableEditOnInstance, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FGameplayTag                           M_tUpgradeTagButtPressureMaximizer;                // 0x0770(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, DisableEditOnInstance, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FGameplayTag                           M_tUpgradeTagRectalPackagerSupreme;                // 0x0778(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, DisableEditOnInstance, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         M_iUpgradeRectalPackagerSupremeExtraAmmoCount;     // 0x0780(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   M_oWeaponAttachSocket;                             // 0x0784(0x0008)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class FName                                   M_oUserAttachSocket;                               // 0x078C(0x0008)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_794[0x4];                                      // 0x0794(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<class ABFGProjectile_AnalProbe*>       M_apProjectiles;                                   // 0x0798(0x0010)(ZeroConstructor, Transient, Protected, NativeAccessSpecifierProtected)
	uint8                                         Pad_7A8[0x4];                                      // 0x07A8(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         M_fMinigameSinFrequency;                           // 0x07AC(0x0004)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         M_fDefaultMinigameSuccessThreshold;                // 0x07B0(0x0004)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	struct FVector                                M_vMinigameLazerNonCritColour;                     // 0x07B4(0x000C)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	struct FVector                                M_vMinigameLazerCritColour;                        // 0x07C0(0x000C)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         M_fMinigameLazerColourInterpSpeed;                 // 0x07CC(0x0004)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         M_fMinigameOffset;                                 // 0x07D0(0x0004)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_7D4[0x8];                                      // 0x07D4(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         M_fMissedShotReloadTime;                           // 0x07DC(0x0004)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TArray<float>                                 M_fMissedReloadTimers;                             // 0x07E0(0x0010)(ZeroConstructor, Transient, Protected, NativeAccessSpecifierProtected)
	float                                         M_fSnifferSensorsSuccessThresholdOverride;         // 0x07F0(0x0004)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         M_fProboscisSensorsSuccessThresholdOverride;       // 0x07F4(0x0004)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	int32                                         M_iCentipedalProbulatorMaxJumps;                   // 0x07F8(0x0004)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         M_fCentipedalProbulatorRadius;                     // 0x07FC(0x0004)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         M_fButtPressureAmplifierDamage;                    // 0x0800(0x0004)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         M_fButtPressureMaximizerDamage;                    // 0x0804(0x0004)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)

public:
	float GetMinigameSuccessThreshold() const;
	float GetMinigameValue() const;
	bool IsMiniGameActive() const;
	bool IsShotInAir() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"BFGWeapon_AnalProbe">();
	}
	static class ABFGWeapon_AnalProbe* GetDefaultObj()
	{
		return GetDefaultObjImpl<ABFGWeapon_AnalProbe>();
	}
};
static_assert(alignof(ABFGWeapon_AnalProbe) == 0x000008, "Wrong alignment on ABFGWeapon_AnalProbe");
static_assert(sizeof(ABFGWeapon_AnalProbe) == 0x000808, "Wrong size on ABFGWeapon_AnalProbe");
static_assert(offsetof(ABFGWeapon_AnalProbe, M_tUpgradeTagSnifferSensors) == 0x000750, "Member 'ABFGWeapon_AnalProbe::M_tUpgradeTagSnifferSensors' has a wrong offset!");
static_assert(offsetof(ABFGWeapon_AnalProbe, M_tUpgradeTagProboscisSensors) == 0x000758, "Member 'ABFGWeapon_AnalProbe::M_tUpgradeTagProboscisSensors' has a wrong offset!");
static_assert(offsetof(ABFGWeapon_AnalProbe, M_tUpgradeTagCentipedalProbulator) == 0x000760, "Member 'ABFGWeapon_AnalProbe::M_tUpgradeTagCentipedalProbulator' has a wrong offset!");
static_assert(offsetof(ABFGWeapon_AnalProbe, M_tUpgradeTagButtPressureAmplifier) == 0x000768, "Member 'ABFGWeapon_AnalProbe::M_tUpgradeTagButtPressureAmplifier' has a wrong offset!");
static_assert(offsetof(ABFGWeapon_AnalProbe, M_tUpgradeTagButtPressureMaximizer) == 0x000770, "Member 'ABFGWeapon_AnalProbe::M_tUpgradeTagButtPressureMaximizer' has a wrong offset!");
static_assert(offsetof(ABFGWeapon_AnalProbe, M_tUpgradeTagRectalPackagerSupreme) == 0x000778, "Member 'ABFGWeapon_AnalProbe::M_tUpgradeTagRectalPackagerSupreme' has a wrong offset!");
static_assert(offsetof(ABFGWeapon_AnalProbe, M_iUpgradeRectalPackagerSupremeExtraAmmoCount) == 0x000780, "Member 'ABFGWeapon_AnalProbe::M_iUpgradeRectalPackagerSupremeExtraAmmoCount' has a wrong offset!");
static_assert(offsetof(ABFGWeapon_AnalProbe, M_oWeaponAttachSocket) == 0x000784, "Member 'ABFGWeapon_AnalProbe::M_oWeaponAttachSocket' has a wrong offset!");
static_assert(offsetof(ABFGWeapon_AnalProbe, M_oUserAttachSocket) == 0x00078C, "Member 'ABFGWeapon_AnalProbe::M_oUserAttachSocket' has a wrong offset!");
static_assert(offsetof(ABFGWeapon_AnalProbe, M_apProjectiles) == 0x000798, "Member 'ABFGWeapon_AnalProbe::M_apProjectiles' has a wrong offset!");
static_assert(offsetof(ABFGWeapon_AnalProbe, M_fMinigameSinFrequency) == 0x0007AC, "Member 'ABFGWeapon_AnalProbe::M_fMinigameSinFrequency' has a wrong offset!");
static_assert(offsetof(ABFGWeapon_AnalProbe, M_fDefaultMinigameSuccessThreshold) == 0x0007B0, "Member 'ABFGWeapon_AnalProbe::M_fDefaultMinigameSuccessThreshold' has a wrong offset!");
static_assert(offsetof(ABFGWeapon_AnalProbe, M_vMinigameLazerNonCritColour) == 0x0007B4, "Member 'ABFGWeapon_AnalProbe::M_vMinigameLazerNonCritColour' has a wrong offset!");
static_assert(offsetof(ABFGWeapon_AnalProbe, M_vMinigameLazerCritColour) == 0x0007C0, "Member 'ABFGWeapon_AnalProbe::M_vMinigameLazerCritColour' has a wrong offset!");
static_assert(offsetof(ABFGWeapon_AnalProbe, M_fMinigameLazerColourInterpSpeed) == 0x0007CC, "Member 'ABFGWeapon_AnalProbe::M_fMinigameLazerColourInterpSpeed' has a wrong offset!");
static_assert(offsetof(ABFGWeapon_AnalProbe, M_fMinigameOffset) == 0x0007D0, "Member 'ABFGWeapon_AnalProbe::M_fMinigameOffset' has a wrong offset!");
static_assert(offsetof(ABFGWeapon_AnalProbe, M_fMissedShotReloadTime) == 0x0007DC, "Member 'ABFGWeapon_AnalProbe::M_fMissedShotReloadTime' has a wrong offset!");
static_assert(offsetof(ABFGWeapon_AnalProbe, M_fMissedReloadTimers) == 0x0007E0, "Member 'ABFGWeapon_AnalProbe::M_fMissedReloadTimers' has a wrong offset!");
static_assert(offsetof(ABFGWeapon_AnalProbe, M_fSnifferSensorsSuccessThresholdOverride) == 0x0007F0, "Member 'ABFGWeapon_AnalProbe::M_fSnifferSensorsSuccessThresholdOverride' has a wrong offset!");
static_assert(offsetof(ABFGWeapon_AnalProbe, M_fProboscisSensorsSuccessThresholdOverride) == 0x0007F4, "Member 'ABFGWeapon_AnalProbe::M_fProboscisSensorsSuccessThresholdOverride' has a wrong offset!");
static_assert(offsetof(ABFGWeapon_AnalProbe, M_iCentipedalProbulatorMaxJumps) == 0x0007F8, "Member 'ABFGWeapon_AnalProbe::M_iCentipedalProbulatorMaxJumps' has a wrong offset!");
static_assert(offsetof(ABFGWeapon_AnalProbe, M_fCentipedalProbulatorRadius) == 0x0007FC, "Member 'ABFGWeapon_AnalProbe::M_fCentipedalProbulatorRadius' has a wrong offset!");
static_assert(offsetof(ABFGWeapon_AnalProbe, M_fButtPressureAmplifierDamage) == 0x000800, "Member 'ABFGWeapon_AnalProbe::M_fButtPressureAmplifierDamage' has a wrong offset!");
static_assert(offsetof(ABFGWeapon_AnalProbe, M_fButtPressureMaximizerDamage) == 0x000804, "Member 'ABFGWeapon_AnalProbe::M_fButtPressureMaximizerDamage' has a wrong offset!");

// Class BFGCore.BFGWeapon_BossAOE_ParticleExploder
// 0x0018 (0x0940 - 0x0928)
class ABFGWeapon_BossAOE_ParticleExploder final : public ABFGWeapon_BossAOE
{
public:
	TArray<class ABFGNPCCharacterEnemy_Mine_ParticleExploder*> M_aMines;                                          // 0x0928(0x0010)(ZeroConstructor, Protected, NativeAccessSpecifierProtected)
	int32                                         M_iMaxMines;                                       // 0x0938(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         M_fMaxMinesTriggerDelay;                           // 0x093C(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)

public:
	void OnMineExploded(class ABFGNPCCharacterEnemy_Mine_ParticleExploder* _pMine);
	void OnMineTriggerRangeEntered(class ABFGNPCCharacterEnemy_Mine_ParticleExploder* _pMine);
	void OnTriggerAllMines();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"BFGWeapon_BossAOE_ParticleExploder">();
	}
	static class ABFGWeapon_BossAOE_ParticleExploder* GetDefaultObj()
	{
		return GetDefaultObjImpl<ABFGWeapon_BossAOE_ParticleExploder>();
	}
};
static_assert(alignof(ABFGWeapon_BossAOE_ParticleExploder) == 0x000008, "Wrong alignment on ABFGWeapon_BossAOE_ParticleExploder");
static_assert(sizeof(ABFGWeapon_BossAOE_ParticleExploder) == 0x000940, "Wrong size on ABFGWeapon_BossAOE_ParticleExploder");
static_assert(offsetof(ABFGWeapon_BossAOE_ParticleExploder, M_aMines) == 0x000928, "Member 'ABFGWeapon_BossAOE_ParticleExploder::M_aMines' has a wrong offset!");
static_assert(offsetof(ABFGWeapon_BossAOE_ParticleExploder, M_iMaxMines) == 0x000938, "Member 'ABFGWeapon_BossAOE_ParticleExploder::M_iMaxMines' has a wrong offset!");
static_assert(offsetof(ABFGWeapon_BossAOE_ParticleExploder, M_fMaxMinesTriggerDelay) == 0x00093C, "Member 'ABFGWeapon_BossAOE_ParticleExploder::M_fMaxMinesTriggerDelay' has a wrong offset!");

// Class BFGCore.BFGWeapon_BossBeam
// 0x0190 (0x0A30 - 0x08A0)
class ABFGWeapon_BossBeam final : public ABFGWeapon_BossBase
{
public:
	struct FSoftClassPath                         M_BeamClass;                                       // 0x08A0(0x0018)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, NativeAccessSpecifierPublic)
	class UParticleSystem*                        M_pBeamChargeUpClass;                              // 0x08B8(0x0008)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   M_sChargeSocket;                                   // 0x08C0(0x0008)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_8C8[0x8];                                      // 0x08C8(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	struct FTransform                             M_vChargeOffset;                                   // 0x08D0(0x0030)(Edit, BlueprintVisible, DisableEditOnInstance, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
	float                                         M_fBeamLength;                                     // 0x0900(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         M_fChargeTimer;                                    // 0x0904(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TSubclassOf<class UDamageType>                M_pDamageType;                                     // 0x0908(0x0008)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         M_fBeamDamage;                                     // 0x0910(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          M_bBeamDebugLine;                                  // 0x0914(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_915[0x3];                                      // 0x0915(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         M_fBeamTrackingPitchRatio;                         // 0x0918(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_91C[0x4];                                      // 0x091C(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class UStaticMeshComponent*                   M_pBeamFanMesh;                                    // 0x0920(0x0008)(Edit, BlueprintVisible, ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class ABFGProjectile_Beam*                    M_pBeam;                                           // 0x0928(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UParticleSystemComponent*               M_pBeamChargeUp;                                   // 0x0930(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_938[0xF0];                                     // 0x0938(0x00F0)(Fixing Size After Last Property [ Dumper-7 ])
	bool                                          M_bShowAimingAtLocation;                           // 0x0A28(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          M_bIncludePatternRotationInAimingAtLocation;       // 0x0A29(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          M_bOverrideAimFunctions;                           // 0x0A2A(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          M_bUseVirtualAimingAtRange;                        // 0x0A2B(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         M_fVirtualAimingAtRange;                           // 0x0A2C(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"BFGWeapon_BossBeam">();
	}
	static class ABFGWeapon_BossBeam* GetDefaultObj()
	{
		return GetDefaultObjImpl<ABFGWeapon_BossBeam>();
	}
};
static_assert(alignof(ABFGWeapon_BossBeam) == 0x000010, "Wrong alignment on ABFGWeapon_BossBeam");
static_assert(sizeof(ABFGWeapon_BossBeam) == 0x000A30, "Wrong size on ABFGWeapon_BossBeam");
static_assert(offsetof(ABFGWeapon_BossBeam, M_BeamClass) == 0x0008A0, "Member 'ABFGWeapon_BossBeam::M_BeamClass' has a wrong offset!");
static_assert(offsetof(ABFGWeapon_BossBeam, M_pBeamChargeUpClass) == 0x0008B8, "Member 'ABFGWeapon_BossBeam::M_pBeamChargeUpClass' has a wrong offset!");
static_assert(offsetof(ABFGWeapon_BossBeam, M_sChargeSocket) == 0x0008C0, "Member 'ABFGWeapon_BossBeam::M_sChargeSocket' has a wrong offset!");
static_assert(offsetof(ABFGWeapon_BossBeam, M_vChargeOffset) == 0x0008D0, "Member 'ABFGWeapon_BossBeam::M_vChargeOffset' has a wrong offset!");
static_assert(offsetof(ABFGWeapon_BossBeam, M_fBeamLength) == 0x000900, "Member 'ABFGWeapon_BossBeam::M_fBeamLength' has a wrong offset!");
static_assert(offsetof(ABFGWeapon_BossBeam, M_fChargeTimer) == 0x000904, "Member 'ABFGWeapon_BossBeam::M_fChargeTimer' has a wrong offset!");
static_assert(offsetof(ABFGWeapon_BossBeam, M_pDamageType) == 0x000908, "Member 'ABFGWeapon_BossBeam::M_pDamageType' has a wrong offset!");
static_assert(offsetof(ABFGWeapon_BossBeam, M_fBeamDamage) == 0x000910, "Member 'ABFGWeapon_BossBeam::M_fBeamDamage' has a wrong offset!");
static_assert(offsetof(ABFGWeapon_BossBeam, M_bBeamDebugLine) == 0x000914, "Member 'ABFGWeapon_BossBeam::M_bBeamDebugLine' has a wrong offset!");
static_assert(offsetof(ABFGWeapon_BossBeam, M_fBeamTrackingPitchRatio) == 0x000918, "Member 'ABFGWeapon_BossBeam::M_fBeamTrackingPitchRatio' has a wrong offset!");
static_assert(offsetof(ABFGWeapon_BossBeam, M_pBeamFanMesh) == 0x000920, "Member 'ABFGWeapon_BossBeam::M_pBeamFanMesh' has a wrong offset!");
static_assert(offsetof(ABFGWeapon_BossBeam, M_pBeam) == 0x000928, "Member 'ABFGWeapon_BossBeam::M_pBeam' has a wrong offset!");
static_assert(offsetof(ABFGWeapon_BossBeam, M_pBeamChargeUp) == 0x000930, "Member 'ABFGWeapon_BossBeam::M_pBeamChargeUp' has a wrong offset!");
static_assert(offsetof(ABFGWeapon_BossBeam, M_bShowAimingAtLocation) == 0x000A28, "Member 'ABFGWeapon_BossBeam::M_bShowAimingAtLocation' has a wrong offset!");
static_assert(offsetof(ABFGWeapon_BossBeam, M_bIncludePatternRotationInAimingAtLocation) == 0x000A29, "Member 'ABFGWeapon_BossBeam::M_bIncludePatternRotationInAimingAtLocation' has a wrong offset!");
static_assert(offsetof(ABFGWeapon_BossBeam, M_bOverrideAimFunctions) == 0x000A2A, "Member 'ABFGWeapon_BossBeam::M_bOverrideAimFunctions' has a wrong offset!");
static_assert(offsetof(ABFGWeapon_BossBeam, M_bUseVirtualAimingAtRange) == 0x000A2B, "Member 'ABFGWeapon_BossBeam::M_bUseVirtualAimingAtRange' has a wrong offset!");
static_assert(offsetof(ABFGWeapon_BossBeam, M_fVirtualAimingAtRange) == 0x000A2C, "Member 'ABFGWeapon_BossBeam::M_fVirtualAimingAtRange' has a wrong offset!");

// Class BFGCore.BFGWeapon_DisintegratorRay
// 0x0090 (0x07E0 - 0x0750)
class ABFGWeapon_DisintegratorRay : public ABFGWeapon_BaseProjectile
{
public:
	struct FGameplayTag                           M_tUpgradeTagProtonClip;                           // 0x0750(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, DisableEditOnInstance, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FGameplayTag                           M_tUpgradeTagProtonMagazine;                       // 0x0758(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, DisableEditOnInstance, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FGameplayTag                           M_tUpgradeTagSeekerMatrix;                         // 0x0760(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, DisableEditOnInstance, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FGameplayTag                           M_tUpgradeTagCascadeIncinerator;                   // 0x0768(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, DisableEditOnInstance, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FGameplayTag                           M_tUpgradeTagCascadeImmolator;                     // 0x0770(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, DisableEditOnInstance, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FGameplayTag                           M_tUpgradeTagTriFusionChambers;                    // 0x0778(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, DisableEditOnInstance, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         M_fTrifusionChambers_ShotAngle;                    // 0x0780(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_784[0x4];                                      // 0x0784(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class UClass*                                 M_pTrifusionChambers_ExtraBulletClass;             // 0x0788(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         M_iProtonClip_ExtraAmmo;                           // 0x0790(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         M_iProtonMagazine_ExtraAmmo;                       // 0x0794(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         M_fCascadeIncienerator_DotDPS;                     // 0x0798(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         M_fCascadeImmolator_DotDPS;                        // 0x079C(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FGameplayTag                           M_oCascadeIncienerator_DotEffectTag;               // 0x07A0(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, DisableEditOnInstance, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         M_fCascadeIncienerator_MaximumDotDuration;         // 0x07A8(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         M_fCascadeIncienerator_StackLimit;                 // 0x07AC(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TSubclassOf<class UDamageType>                M_fCascadeIncienerator_DamageType;                 // 0x07B0(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         M_fSetOnFireHealthThreshhold;                      // 0x07B8(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         M_fSetOnFireChance;                                // 0x07BC(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         M_fDotTickRate;                                    // 0x07C0(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FGameplayTag                           M_oOnFireGameplayEffectTag;                        // 0x07C4(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, DisableEditOnInstance, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         M_fSeekerMatrix_AttackspeedMultiplier;             // 0x07CC(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TArray<struct FBFGDisintegratorDotInfo>       M_aDottedActorList;                                // 0x07D0(0x0010)(ZeroConstructor, Protected, NativeAccessSpecifierProtected)

public:
	void OnDotApplied(class AActor* _pTarget, int32 _iStackCount);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"BFGWeapon_DisintegratorRay">();
	}
	static class ABFGWeapon_DisintegratorRay* GetDefaultObj()
	{
		return GetDefaultObjImpl<ABFGWeapon_DisintegratorRay>();
	}
};
static_assert(alignof(ABFGWeapon_DisintegratorRay) == 0x000008, "Wrong alignment on ABFGWeapon_DisintegratorRay");
static_assert(sizeof(ABFGWeapon_DisintegratorRay) == 0x0007E0, "Wrong size on ABFGWeapon_DisintegratorRay");
static_assert(offsetof(ABFGWeapon_DisintegratorRay, M_tUpgradeTagProtonClip) == 0x000750, "Member 'ABFGWeapon_DisintegratorRay::M_tUpgradeTagProtonClip' has a wrong offset!");
static_assert(offsetof(ABFGWeapon_DisintegratorRay, M_tUpgradeTagProtonMagazine) == 0x000758, "Member 'ABFGWeapon_DisintegratorRay::M_tUpgradeTagProtonMagazine' has a wrong offset!");
static_assert(offsetof(ABFGWeapon_DisintegratorRay, M_tUpgradeTagSeekerMatrix) == 0x000760, "Member 'ABFGWeapon_DisintegratorRay::M_tUpgradeTagSeekerMatrix' has a wrong offset!");
static_assert(offsetof(ABFGWeapon_DisintegratorRay, M_tUpgradeTagCascadeIncinerator) == 0x000768, "Member 'ABFGWeapon_DisintegratorRay::M_tUpgradeTagCascadeIncinerator' has a wrong offset!");
static_assert(offsetof(ABFGWeapon_DisintegratorRay, M_tUpgradeTagCascadeImmolator) == 0x000770, "Member 'ABFGWeapon_DisintegratorRay::M_tUpgradeTagCascadeImmolator' has a wrong offset!");
static_assert(offsetof(ABFGWeapon_DisintegratorRay, M_tUpgradeTagTriFusionChambers) == 0x000778, "Member 'ABFGWeapon_DisintegratorRay::M_tUpgradeTagTriFusionChambers' has a wrong offset!");
static_assert(offsetof(ABFGWeapon_DisintegratorRay, M_fTrifusionChambers_ShotAngle) == 0x000780, "Member 'ABFGWeapon_DisintegratorRay::M_fTrifusionChambers_ShotAngle' has a wrong offset!");
static_assert(offsetof(ABFGWeapon_DisintegratorRay, M_pTrifusionChambers_ExtraBulletClass) == 0x000788, "Member 'ABFGWeapon_DisintegratorRay::M_pTrifusionChambers_ExtraBulletClass' has a wrong offset!");
static_assert(offsetof(ABFGWeapon_DisintegratorRay, M_iProtonClip_ExtraAmmo) == 0x000790, "Member 'ABFGWeapon_DisintegratorRay::M_iProtonClip_ExtraAmmo' has a wrong offset!");
static_assert(offsetof(ABFGWeapon_DisintegratorRay, M_iProtonMagazine_ExtraAmmo) == 0x000794, "Member 'ABFGWeapon_DisintegratorRay::M_iProtonMagazine_ExtraAmmo' has a wrong offset!");
static_assert(offsetof(ABFGWeapon_DisintegratorRay, M_fCascadeIncienerator_DotDPS) == 0x000798, "Member 'ABFGWeapon_DisintegratorRay::M_fCascadeIncienerator_DotDPS' has a wrong offset!");
static_assert(offsetof(ABFGWeapon_DisintegratorRay, M_fCascadeImmolator_DotDPS) == 0x00079C, "Member 'ABFGWeapon_DisintegratorRay::M_fCascadeImmolator_DotDPS' has a wrong offset!");
static_assert(offsetof(ABFGWeapon_DisintegratorRay, M_oCascadeIncienerator_DotEffectTag) == 0x0007A0, "Member 'ABFGWeapon_DisintegratorRay::M_oCascadeIncienerator_DotEffectTag' has a wrong offset!");
static_assert(offsetof(ABFGWeapon_DisintegratorRay, M_fCascadeIncienerator_MaximumDotDuration) == 0x0007A8, "Member 'ABFGWeapon_DisintegratorRay::M_fCascadeIncienerator_MaximumDotDuration' has a wrong offset!");
static_assert(offsetof(ABFGWeapon_DisintegratorRay, M_fCascadeIncienerator_StackLimit) == 0x0007AC, "Member 'ABFGWeapon_DisintegratorRay::M_fCascadeIncienerator_StackLimit' has a wrong offset!");
static_assert(offsetof(ABFGWeapon_DisintegratorRay, M_fCascadeIncienerator_DamageType) == 0x0007B0, "Member 'ABFGWeapon_DisintegratorRay::M_fCascadeIncienerator_DamageType' has a wrong offset!");
static_assert(offsetof(ABFGWeapon_DisintegratorRay, M_fSetOnFireHealthThreshhold) == 0x0007B8, "Member 'ABFGWeapon_DisintegratorRay::M_fSetOnFireHealthThreshhold' has a wrong offset!");
static_assert(offsetof(ABFGWeapon_DisintegratorRay, M_fSetOnFireChance) == 0x0007BC, "Member 'ABFGWeapon_DisintegratorRay::M_fSetOnFireChance' has a wrong offset!");
static_assert(offsetof(ABFGWeapon_DisintegratorRay, M_fDotTickRate) == 0x0007C0, "Member 'ABFGWeapon_DisintegratorRay::M_fDotTickRate' has a wrong offset!");
static_assert(offsetof(ABFGWeapon_DisintegratorRay, M_oOnFireGameplayEffectTag) == 0x0007C4, "Member 'ABFGWeapon_DisintegratorRay::M_oOnFireGameplayEffectTag' has a wrong offset!");
static_assert(offsetof(ABFGWeapon_DisintegratorRay, M_fSeekerMatrix_AttackspeedMultiplier) == 0x0007CC, "Member 'ABFGWeapon_DisintegratorRay::M_fSeekerMatrix_AttackspeedMultiplier' has a wrong offset!");
static_assert(offsetof(ABFGWeapon_DisintegratorRay, M_aDottedActorList) == 0x0007D0, "Member 'ABFGWeapon_DisintegratorRay::M_aDottedActorList' has a wrong offset!");

// Class BFGCore.BFGWeapon_EnemyGun
// 0x0000 (0x0850 - 0x0850)
class ABFGWeapon_EnemyGun : public ABFGWeapon_Enemy
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"BFGWeapon_EnemyGun">();
	}
	static class ABFGWeapon_EnemyGun* GetDefaultObj()
	{
		return GetDefaultObjImpl<ABFGWeapon_EnemyGun>();
	}
};
static_assert(alignof(ABFGWeapon_EnemyGun) == 0x000008, "Wrong alignment on ABFGWeapon_EnemyGun");
static_assert(sizeof(ABFGWeapon_EnemyGun) == 0x000850, "Wrong size on ABFGWeapon_EnemyGun");

// Class BFGCore.BFGWeapon_EnemyNasalProbe
// 0x0010 (0x0860 - 0x0850)
class ABFGWeapon_EnemyNasalProbe final : public ABFGWeapon_Enemy
{
public:
	float                                         M_fNasalProbeRange;                                // 0x0850(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   M_strHandSocket;                                   // 0x0854(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_85C[0x4];                                      // 0x085C(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	class ABFGProjectile_Object* FireNasalProbe(int32 _iRetargetAttempts);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"BFGWeapon_EnemyNasalProbe">();
	}
	static class ABFGWeapon_EnemyNasalProbe* GetDefaultObj()
	{
		return GetDefaultObjImpl<ABFGWeapon_EnemyNasalProbe>();
	}
};
static_assert(alignof(ABFGWeapon_EnemyNasalProbe) == 0x000008, "Wrong alignment on ABFGWeapon_EnemyNasalProbe");
static_assert(sizeof(ABFGWeapon_EnemyNasalProbe) == 0x000860, "Wrong size on ABFGWeapon_EnemyNasalProbe");
static_assert(offsetof(ABFGWeapon_EnemyNasalProbe, M_fNasalProbeRange) == 0x000850, "Member 'ABFGWeapon_EnemyNasalProbe::M_fNasalProbeRange' has a wrong offset!");
static_assert(offsetof(ABFGWeapon_EnemyNasalProbe, M_strHandSocket) == 0x000854, "Member 'ABFGWeapon_EnemyNasalProbe::M_strHandSocket' has a wrong offset!");

// Class BFGCore.BFGWeapon_EnemyTank
// 0x0030 (0x0880 - 0x0850)
class ABFGWeapon_EnemyTank final : public ABFGWeapon_EnemyGun
{
public:
	float                                         M_fRecoilStrength;                                 // 0x0850(0x0004)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_854[0x4];                                      // 0x0854(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class UBFGPoseableMeshComponent*              M_pTurretComponent;                                // 0x0858(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class FName                                   M_boneToYaw;                                       // 0x0860(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class FName                                   M_boneToPitch;                                     // 0x0868(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_870[0x10];                                     // 0x0870(0x0010)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"BFGWeapon_EnemyTank">();
	}
	static class ABFGWeapon_EnemyTank* GetDefaultObj()
	{
		return GetDefaultObjImpl<ABFGWeapon_EnemyTank>();
	}
};
static_assert(alignof(ABFGWeapon_EnemyTank) == 0x000008, "Wrong alignment on ABFGWeapon_EnemyTank");
static_assert(sizeof(ABFGWeapon_EnemyTank) == 0x000880, "Wrong size on ABFGWeapon_EnemyTank");
static_assert(offsetof(ABFGWeapon_EnemyTank, M_fRecoilStrength) == 0x000850, "Member 'ABFGWeapon_EnemyTank::M_fRecoilStrength' has a wrong offset!");
static_assert(offsetof(ABFGWeapon_EnemyTank, M_pTurretComponent) == 0x000858, "Member 'ABFGWeapon_EnemyTank::M_pTurretComponent' has a wrong offset!");
static_assert(offsetof(ABFGWeapon_EnemyTank, M_boneToYaw) == 0x000860, "Member 'ABFGWeapon_EnemyTank::M_boneToYaw' has a wrong offset!");
static_assert(offsetof(ABFGWeapon_EnemyTank, M_boneToPitch) == 0x000868, "Member 'ABFGWeapon_EnemyTank::M_boneToPitch' has a wrong offset!");

// Class BFGCore.BFGWeapon_MindLinkPulseField
// 0x0010 (0x0860 - 0x0850)
class ABFGWeapon_MindLinkPulseField final : public ABFGWeapon_Enemy
{
public:
	float                                         M_fPredictionOffset;                               // 0x0850(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	struct FVector                                M_vCurrentTargetLocation;                          // 0x0854(0x000C)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"BFGWeapon_MindLinkPulseField">();
	}
	static class ABFGWeapon_MindLinkPulseField* GetDefaultObj()
	{
		return GetDefaultObjImpl<ABFGWeapon_MindLinkPulseField>();
	}
};
static_assert(alignof(ABFGWeapon_MindLinkPulseField) == 0x000008, "Wrong alignment on ABFGWeapon_MindLinkPulseField");
static_assert(sizeof(ABFGWeapon_MindLinkPulseField) == 0x000860, "Wrong size on ABFGWeapon_MindLinkPulseField");
static_assert(offsetof(ABFGWeapon_MindLinkPulseField, M_fPredictionOffset) == 0x000850, "Member 'ABFGWeapon_MindLinkPulseField::M_fPredictionOffset' has a wrong offset!");
static_assert(offsetof(ABFGWeapon_MindLinkPulseField, M_vCurrentTargetLocation) == 0x000854, "Member 'ABFGWeapon_MindLinkPulseField::M_vCurrentTargetLocation' has a wrong offset!");

// Class BFGCore.BFGWeapon_MultiMissiles
// 0x0098 (0x08E8 - 0x0850)
class ABFGWeapon_MultiMissiles final : public ABFGWeapon_Enemy
{
public:
	class UStaticMesh*                            M_pProjectileProxyMesh;                            // 0x0850(0x0008)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	struct FVector                                M_vAttachmentOffset;                               // 0x0858(0x000C)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	struct FVector                                M_vOnDeathProjectileImpulse;                       // 0x0864(0x000C)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class FName                                   M_originBoneName;                                  // 0x0870(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class FName                                   M_directionBoneName;                               // 0x0878(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_880[0x18];                                     // 0x0880(0x0018)(Fixing Size After Last Property [ Dumper-7 ])
	TMap<int32, class UStaticMeshComponent*>      M_aMissileProxyMeshes;                             // 0x0898(0x0050)(ExportObject, ZeroConstructor, ContainsInstancedReference, Protected, NativeAccessSpecifierProtected)

public:
	void OnHolderDeath(class AActor* _pActor, class UBFGActorStat_Bool* _pStat);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"BFGWeapon_MultiMissiles">();
	}
	static class ABFGWeapon_MultiMissiles* GetDefaultObj()
	{
		return GetDefaultObjImpl<ABFGWeapon_MultiMissiles>();
	}
};
static_assert(alignof(ABFGWeapon_MultiMissiles) == 0x000008, "Wrong alignment on ABFGWeapon_MultiMissiles");
static_assert(sizeof(ABFGWeapon_MultiMissiles) == 0x0008E8, "Wrong size on ABFGWeapon_MultiMissiles");
static_assert(offsetof(ABFGWeapon_MultiMissiles, M_pProjectileProxyMesh) == 0x000850, "Member 'ABFGWeapon_MultiMissiles::M_pProjectileProxyMesh' has a wrong offset!");
static_assert(offsetof(ABFGWeapon_MultiMissiles, M_vAttachmentOffset) == 0x000858, "Member 'ABFGWeapon_MultiMissiles::M_vAttachmentOffset' has a wrong offset!");
static_assert(offsetof(ABFGWeapon_MultiMissiles, M_vOnDeathProjectileImpulse) == 0x000864, "Member 'ABFGWeapon_MultiMissiles::M_vOnDeathProjectileImpulse' has a wrong offset!");
static_assert(offsetof(ABFGWeapon_MultiMissiles, M_originBoneName) == 0x000870, "Member 'ABFGWeapon_MultiMissiles::M_originBoneName' has a wrong offset!");
static_assert(offsetof(ABFGWeapon_MultiMissiles, M_directionBoneName) == 0x000878, "Member 'ABFGWeapon_MultiMissiles::M_directionBoneName' has a wrong offset!");
static_assert(offsetof(ABFGWeapon_MultiMissiles, M_aMissileProxyMeshes) == 0x000898, "Member 'ABFGWeapon_MultiMissiles::M_aMissileProxyMeshes' has a wrong offset!");

// Class BFGCore.BFGWeapon_RoboprezAirMineLauncher
// 0x0018 (0x0948 - 0x0930)
class ABFGWeapon_RoboprezAirMineLauncher final : public ABFGWeapon_RoboprezAOE
{
public:
	uint8                                         Pad_930[0x18];                                     // 0x0930(0x0018)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"BFGWeapon_RoboprezAirMineLauncher">();
	}
	static class ABFGWeapon_RoboprezAirMineLauncher* GetDefaultObj()
	{
		return GetDefaultObjImpl<ABFGWeapon_RoboprezAirMineLauncher>();
	}
};
static_assert(alignof(ABFGWeapon_RoboprezAirMineLauncher) == 0x000008, "Wrong alignment on ABFGWeapon_RoboprezAirMineLauncher");
static_assert(sizeof(ABFGWeapon_RoboprezAirMineLauncher) == 0x000948, "Wrong size on ABFGWeapon_RoboprezAirMineLauncher");

// Class BFGCore.BFGWeapon_TurretAntiAir
// 0x0028 (0x0878 - 0x0850)
class ABFGWeapon_TurretAntiAir : public ABFGWeapon_Enemy
{
public:
	uint8                                         Pad_850[0x18];                                     // 0x0850(0x0018)(Fixing Size After Last Property [ Dumper-7 ])
	class FName                                   M_originBoneName;                                  // 0x0868(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class FName                                   M_directionBoneName;                               // 0x0870(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"BFGWeapon_TurretAntiAir">();
	}
	static class ABFGWeapon_TurretAntiAir* GetDefaultObj()
	{
		return GetDefaultObjImpl<ABFGWeapon_TurretAntiAir>();
	}
};
static_assert(alignof(ABFGWeapon_TurretAntiAir) == 0x000008, "Wrong alignment on ABFGWeapon_TurretAntiAir");
static_assert(sizeof(ABFGWeapon_TurretAntiAir) == 0x000878, "Wrong size on ABFGWeapon_TurretAntiAir");
static_assert(offsetof(ABFGWeapon_TurretAntiAir, M_originBoneName) == 0x000868, "Member 'ABFGWeapon_TurretAntiAir::M_originBoneName' has a wrong offset!");
static_assert(offsetof(ABFGWeapon_TurretAntiAir, M_directionBoneName) == 0x000870, "Member 'ABFGWeapon_TurretAntiAir::M_directionBoneName' has a wrong offset!");

// Class BFGCore.BFGWeapon_UFO_SonicBoom
// 0x0068 (0x07B8 - 0x0750)
class ABFGWeapon_UFO_SonicBoom : public ABFGWeapon_BaseProjectile
{
public:
	struct FGameplayTag                           M_tUpgradeTagFlangeWahWahCrossover;                // 0x0750(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, DisableEditOnInstance, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FGameplayTag                           M_tUpgradeTagChorusPhaseOscillator;                // 0x0758(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, DisableEditOnInstance, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FGameplayTag                           M_tUpgradeTagVolumeControl11;                      // 0x0760(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, DisableEditOnInstance, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FGameplayTag                           M_tUpgradeTagEightTrackBooms;                      // 0x0768(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, DisableEditOnInstance, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FGameplayTag                           M_tUpgradeTagCassetteTapeBooms;                    // 0x0770(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, DisableEditOnInstance, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FGameplayTag                           M_tUpgradeTagBadaBooms;                            // 0x0778(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, DisableEditOnInstance, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         M_fFlangeWahWahCrossover_DirectDamageMultiplier;   // 0x0780(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         M_fChorusPhaseOscillator_DirectDamageMultiplier;   // 0x0784(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         M_fEightTrackBooms_AmmoAmount;                     // 0x0788(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         M_fCassetteTapeBooms_AmmoAmount;                   // 0x078C(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         M_fVolumeControl11_WaveRange;                      // 0x0790(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         M_fVolumeControl11_WaveDamage;                     // 0x0794(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         M_fEightTrackBooms_SuckRangeMultiplier;            // 0x0798(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         M_fEightTrackBooms_SuckSpeed;                      // 0x079C(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TArray<class ABFGProjectile_SonicBoom*>       M_apReservedEffectSlots;                           // 0x07A0(0x0010)(ZeroConstructor, Protected, NativeAccessSpecifierProtected)
	uint8                                         Pad_7B0[0x8];                                      // 0x07B0(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"BFGWeapon_UFO_SonicBoom">();
	}
	static class ABFGWeapon_UFO_SonicBoom* GetDefaultObj()
	{
		return GetDefaultObjImpl<ABFGWeapon_UFO_SonicBoom>();
	}
};
static_assert(alignof(ABFGWeapon_UFO_SonicBoom) == 0x000008, "Wrong alignment on ABFGWeapon_UFO_SonicBoom");
static_assert(sizeof(ABFGWeapon_UFO_SonicBoom) == 0x0007B8, "Wrong size on ABFGWeapon_UFO_SonicBoom");
static_assert(offsetof(ABFGWeapon_UFO_SonicBoom, M_tUpgradeTagFlangeWahWahCrossover) == 0x000750, "Member 'ABFGWeapon_UFO_SonicBoom::M_tUpgradeTagFlangeWahWahCrossover' has a wrong offset!");
static_assert(offsetof(ABFGWeapon_UFO_SonicBoom, M_tUpgradeTagChorusPhaseOscillator) == 0x000758, "Member 'ABFGWeapon_UFO_SonicBoom::M_tUpgradeTagChorusPhaseOscillator' has a wrong offset!");
static_assert(offsetof(ABFGWeapon_UFO_SonicBoom, M_tUpgradeTagVolumeControl11) == 0x000760, "Member 'ABFGWeapon_UFO_SonicBoom::M_tUpgradeTagVolumeControl11' has a wrong offset!");
static_assert(offsetof(ABFGWeapon_UFO_SonicBoom, M_tUpgradeTagEightTrackBooms) == 0x000768, "Member 'ABFGWeapon_UFO_SonicBoom::M_tUpgradeTagEightTrackBooms' has a wrong offset!");
static_assert(offsetof(ABFGWeapon_UFO_SonicBoom, M_tUpgradeTagCassetteTapeBooms) == 0x000770, "Member 'ABFGWeapon_UFO_SonicBoom::M_tUpgradeTagCassetteTapeBooms' has a wrong offset!");
static_assert(offsetof(ABFGWeapon_UFO_SonicBoom, M_tUpgradeTagBadaBooms) == 0x000778, "Member 'ABFGWeapon_UFO_SonicBoom::M_tUpgradeTagBadaBooms' has a wrong offset!");
static_assert(offsetof(ABFGWeapon_UFO_SonicBoom, M_fFlangeWahWahCrossover_DirectDamageMultiplier) == 0x000780, "Member 'ABFGWeapon_UFO_SonicBoom::M_fFlangeWahWahCrossover_DirectDamageMultiplier' has a wrong offset!");
static_assert(offsetof(ABFGWeapon_UFO_SonicBoom, M_fChorusPhaseOscillator_DirectDamageMultiplier) == 0x000784, "Member 'ABFGWeapon_UFO_SonicBoom::M_fChorusPhaseOscillator_DirectDamageMultiplier' has a wrong offset!");
static_assert(offsetof(ABFGWeapon_UFO_SonicBoom, M_fEightTrackBooms_AmmoAmount) == 0x000788, "Member 'ABFGWeapon_UFO_SonicBoom::M_fEightTrackBooms_AmmoAmount' has a wrong offset!");
static_assert(offsetof(ABFGWeapon_UFO_SonicBoom, M_fCassetteTapeBooms_AmmoAmount) == 0x00078C, "Member 'ABFGWeapon_UFO_SonicBoom::M_fCassetteTapeBooms_AmmoAmount' has a wrong offset!");
static_assert(offsetof(ABFGWeapon_UFO_SonicBoom, M_fVolumeControl11_WaveRange) == 0x000790, "Member 'ABFGWeapon_UFO_SonicBoom::M_fVolumeControl11_WaveRange' has a wrong offset!");
static_assert(offsetof(ABFGWeapon_UFO_SonicBoom, M_fVolumeControl11_WaveDamage) == 0x000794, "Member 'ABFGWeapon_UFO_SonicBoom::M_fVolumeControl11_WaveDamage' has a wrong offset!");
static_assert(offsetof(ABFGWeapon_UFO_SonicBoom, M_fEightTrackBooms_SuckRangeMultiplier) == 0x000798, "Member 'ABFGWeapon_UFO_SonicBoom::M_fEightTrackBooms_SuckRangeMultiplier' has a wrong offset!");
static_assert(offsetof(ABFGWeapon_UFO_SonicBoom, M_fEightTrackBooms_SuckSpeed) == 0x00079C, "Member 'ABFGWeapon_UFO_SonicBoom::M_fEightTrackBooms_SuckSpeed' has a wrong offset!");
static_assert(offsetof(ABFGWeapon_UFO_SonicBoom, M_apReservedEffectSlots) == 0x0007A0, "Member 'ABFGWeapon_UFO_SonicBoom::M_apReservedEffectSlots' has a wrong offset!");

// Class BFGCore.BFGWeapon_ZapOMatic
// 0x0038 (0x0778 - 0x0740)
class ABFGWeapon_ZapOMatic : public ABFGWeapon_BaseRay
{
public:
	struct FGameplayTag                           M_tUpgradeTagIridiumArcSplitter;                   // 0x0740(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, DisableEditOnInstance, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FGameplayTag                           M_tUpgradeTagIridiumArcSpreader;                   // 0x0748(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, DisableEditOnInstance, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FGameplayTag                           M_tUpgradeTagCompoundRIzer;                        // 0x0750(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, DisableEditOnInstance, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FGameplayTag                           M_tUpgradeTagFluxocellCapacitor;                   // 0x0758(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, DisableEditOnInstance, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FGameplayTag                           M_tUpgradeTagFluxocellAccumulator;                 // 0x0760(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, DisableEditOnInstance, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FGameplayTag                           M_tUpgradeTagGortanShockMultiplier;                // 0x0768(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, DisableEditOnInstance, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         M_fFluxocellCapacitor_MaxCharge;                   // 0x0770(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         M_fFluxocellAccumulator_MaxCharge;                 // 0x0774(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"BFGWeapon_ZapOMatic">();
	}
	static class ABFGWeapon_ZapOMatic* GetDefaultObj()
	{
		return GetDefaultObjImpl<ABFGWeapon_ZapOMatic>();
	}
};
static_assert(alignof(ABFGWeapon_ZapOMatic) == 0x000008, "Wrong alignment on ABFGWeapon_ZapOMatic");
static_assert(sizeof(ABFGWeapon_ZapOMatic) == 0x000778, "Wrong size on ABFGWeapon_ZapOMatic");
static_assert(offsetof(ABFGWeapon_ZapOMatic, M_tUpgradeTagIridiumArcSplitter) == 0x000740, "Member 'ABFGWeapon_ZapOMatic::M_tUpgradeTagIridiumArcSplitter' has a wrong offset!");
static_assert(offsetof(ABFGWeapon_ZapOMatic, M_tUpgradeTagIridiumArcSpreader) == 0x000748, "Member 'ABFGWeapon_ZapOMatic::M_tUpgradeTagIridiumArcSpreader' has a wrong offset!");
static_assert(offsetof(ABFGWeapon_ZapOMatic, M_tUpgradeTagCompoundRIzer) == 0x000750, "Member 'ABFGWeapon_ZapOMatic::M_tUpgradeTagCompoundRIzer' has a wrong offset!");
static_assert(offsetof(ABFGWeapon_ZapOMatic, M_tUpgradeTagFluxocellCapacitor) == 0x000758, "Member 'ABFGWeapon_ZapOMatic::M_tUpgradeTagFluxocellCapacitor' has a wrong offset!");
static_assert(offsetof(ABFGWeapon_ZapOMatic, M_tUpgradeTagFluxocellAccumulator) == 0x000760, "Member 'ABFGWeapon_ZapOMatic::M_tUpgradeTagFluxocellAccumulator' has a wrong offset!");
static_assert(offsetof(ABFGWeapon_ZapOMatic, M_tUpgradeTagGortanShockMultiplier) == 0x000768, "Member 'ABFGWeapon_ZapOMatic::M_tUpgradeTagGortanShockMultiplier' has a wrong offset!");
static_assert(offsetof(ABFGWeapon_ZapOMatic, M_fFluxocellCapacitor_MaxCharge) == 0x000770, "Member 'ABFGWeapon_ZapOMatic::M_fFluxocellCapacitor_MaxCharge' has a wrong offset!");
static_assert(offsetof(ABFGWeapon_ZapOMatic, M_fFluxocellAccumulator_MaxCharge) == 0x000774, "Member 'ABFGWeapon_ZapOMatic::M_fFluxocellAccumulator_MaxCharge' has a wrong offset!");

// Class BFGCore.BFGWeaponTargetMarker
// 0x0008 (0x03E0 - 0x03D8)
class ABFGWeaponTargetMarker : public AActor
{
public:
	struct FColor                                 M_oColor;                                          // 0x03D8(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_3DC[0x4];                                      // 0x03DC(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void OnColorSet();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"BFGWeaponTargetMarker">();
	}
	static class ABFGWeaponTargetMarker* GetDefaultObj()
	{
		return GetDefaultObjImpl<ABFGWeaponTargetMarker>();
	}
};
static_assert(alignof(ABFGWeaponTargetMarker) == 0x000008, "Wrong alignment on ABFGWeaponTargetMarker");
static_assert(sizeof(ABFGWeaponTargetMarker) == 0x0003E0, "Wrong size on ABFGWeaponTargetMarker");
static_assert(offsetof(ABFGWeaponTargetMarker, M_oColor) == 0x0003D8, "Member 'ABFGWeaponTargetMarker::M_oColor' has a wrong offset!");

// Class BFGCore.BFGActorComponent_WidgetAlert
// 0x0008 (0x07E0 - 0x07D8)
class UBFGActorComponent_WidgetAlert : public UBFGActorComponent_WidgetComponent
{
public:
	float                                         M_fEnabledDuration;                                // 0x07D8(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_7DC[0x4];                                      // 0x07DC(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void OnAIStateChanged(EBFGBehaviourState_NPC _eState);
	void OnDeadStateChanged(bool _bState);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"BFGActorComponent_WidgetAlert">();
	}
	static class UBFGActorComponent_WidgetAlert* GetDefaultObj()
	{
		return GetDefaultObjImpl<UBFGActorComponent_WidgetAlert>();
	}
};
static_assert(alignof(UBFGActorComponent_WidgetAlert) == 0x000008, "Wrong alignment on UBFGActorComponent_WidgetAlert");
static_assert(sizeof(UBFGActorComponent_WidgetAlert) == 0x0007E0, "Wrong size on UBFGActorComponent_WidgetAlert");
static_assert(offsetof(UBFGActorComponent_WidgetAlert, M_fEnabledDuration) == 0x0007D8, "Member 'UBFGActorComponent_WidgetAlert::M_fEnabledDuration' has a wrong offset!");

// Class BFGCore.BFGWidget_AR_AlertOverhead
// 0x0000 (0x02A8 - 0x02A8)
class UBFGWidget_AR_AlertOverhead : public UBFGWidget_AR_ActorComponentWidget
{
public:
	void UpdateState(EBFGBehaviourState_NPC _eState);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"BFGWidget_AR_AlertOverhead">();
	}
	static class UBFGWidget_AR_AlertOverhead* GetDefaultObj()
	{
		return GetDefaultObjImpl<UBFGWidget_AR_AlertOverhead>();
	}
};
static_assert(alignof(UBFGWidget_AR_AlertOverhead) == 0x000008, "Wrong alignment on UBFGWidget_AR_AlertOverhead");
static_assert(sizeof(UBFGWidget_AR_AlertOverhead) == 0x0002A8, "Wrong size on UBFGWidget_AR_AlertOverhead");

// Class BFGCore.BFGWidget_AR_SimpleOverheadText
// 0x0038 (0x0330 - 0x02F8)
class UBFGWidget_AR_SimpleOverheadText final : public UBFGWidget_HUD
{
public:
	uint8                                         Pad_2F8[0x8];                                      // 0x02F8(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	class FText                                   M_sCurrentText;                                    // 0x0300(0x0018)(BlueprintVisible, BlueprintReadOnly, NativeAccessSpecifierPublic)
	class UCanvasPanel*                           M_pCanvasPanel;                                    // 0x0318(0x0008)(BlueprintVisible, ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UListView*                              M_pListView;                                       // 0x0320(0x0008)(BlueprintVisible, ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          M_bShowWidget;                                     // 0x0328(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_329[0x3];                                      // 0x0329(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	int32                                         M_iIndex;                                          // 0x032C(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

public:
	void ChangeText(const class FText& _newText);
	void ShowWidget(bool _bShow);
	void UpdateData();
	void UpdateRichtTextBox(int32 _iIndex, const class FText& _strText);

	class UBFGGameInstance* GetBFGGameInstance() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"BFGWidget_AR_SimpleOverheadText">();
	}
	static class UBFGWidget_AR_SimpleOverheadText* GetDefaultObj()
	{
		return GetDefaultObjImpl<UBFGWidget_AR_SimpleOverheadText>();
	}
};
static_assert(alignof(UBFGWidget_AR_SimpleOverheadText) == 0x000008, "Wrong alignment on UBFGWidget_AR_SimpleOverheadText");
static_assert(sizeof(UBFGWidget_AR_SimpleOverheadText) == 0x000330, "Wrong size on UBFGWidget_AR_SimpleOverheadText");
static_assert(offsetof(UBFGWidget_AR_SimpleOverheadText, M_sCurrentText) == 0x000300, "Member 'UBFGWidget_AR_SimpleOverheadText::M_sCurrentText' has a wrong offset!");
static_assert(offsetof(UBFGWidget_AR_SimpleOverheadText, M_pCanvasPanel) == 0x000318, "Member 'UBFGWidget_AR_SimpleOverheadText::M_pCanvasPanel' has a wrong offset!");
static_assert(offsetof(UBFGWidget_AR_SimpleOverheadText, M_pListView) == 0x000320, "Member 'UBFGWidget_AR_SimpleOverheadText::M_pListView' has a wrong offset!");
static_assert(offsetof(UBFGWidget_AR_SimpleOverheadText, M_bShowWidget) == 0x000328, "Member 'UBFGWidget_AR_SimpleOverheadText::M_bShowWidget' has a wrong offset!");
static_assert(offsetof(UBFGWidget_AR_SimpleOverheadText, M_iIndex) == 0x00032C, "Member 'UBFGWidget_AR_SimpleOverheadText::M_iIndex' has a wrong offset!");

// Class BFGCore.BFGWidget_Archive_FuronHandbook
// 0x0030 (0x0520 - 0x04F0)
class UBFGWidget_Archive_FuronHandbook final : public UBFGWidget_Archive_SubMenu
{
public:
	class UDataTable*                             M_pTable;                                          // 0x04F0(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TSoftClassPtr<class UClass>                   M_pChapterWidgetClass;                             // 0x04F8(0x0028)(Edit, DisableEditOnInstance, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)

public:
	void AddChapterToLayout(class UBFGWidget_Archive_FuronHandbookChapter* _pChapter);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"BFGWidget_Archive_FuronHandbook">();
	}
	static class UBFGWidget_Archive_FuronHandbook* GetDefaultObj()
	{
		return GetDefaultObjImpl<UBFGWidget_Archive_FuronHandbook>();
	}
};
static_assert(alignof(UBFGWidget_Archive_FuronHandbook) == 0x000008, "Wrong alignment on UBFGWidget_Archive_FuronHandbook");
static_assert(sizeof(UBFGWidget_Archive_FuronHandbook) == 0x000520, "Wrong size on UBFGWidget_Archive_FuronHandbook");
static_assert(offsetof(UBFGWidget_Archive_FuronHandbook, M_pTable) == 0x0004F0, "Member 'UBFGWidget_Archive_FuronHandbook::M_pTable' has a wrong offset!");
static_assert(offsetof(UBFGWidget_Archive_FuronHandbook, M_pChapterWidgetClass) == 0x0004F8, "Member 'UBFGWidget_Archive_FuronHandbook::M_pChapterWidgetClass' has a wrong offset!");

// Class BFGCore.BFGFuronigamiSelectionInfo_Image
// 0x0028 (0x00E8 - 0x00C0)
class UBFGFuronigamiSelectionInfo_Image final : public UBFGFuronigamiSelectionInfo
{
public:
	TSoftObjectPtr<class UTexture2D>              M_pContent;                                        // 0x00C0(0x0028)(Edit, BlueprintVisible, BlueprintReadOnly, DisableEditOnInstance, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"BFGFuronigamiSelectionInfo_Image">();
	}
	static class UBFGFuronigamiSelectionInfo_Image* GetDefaultObj()
	{
		return GetDefaultObjImpl<UBFGFuronigamiSelectionInfo_Image>();
	}
};
static_assert(alignof(UBFGFuronigamiSelectionInfo_Image) == 0x000008, "Wrong alignment on UBFGFuronigamiSelectionInfo_Image");
static_assert(sizeof(UBFGFuronigamiSelectionInfo_Image) == 0x0000E8, "Wrong size on UBFGFuronigamiSelectionInfo_Image");
static_assert(offsetof(UBFGFuronigamiSelectionInfo_Image, M_pContent) == 0x0000C0, "Member 'UBFGFuronigamiSelectionInfo_Image::M_pContent' has a wrong offset!");

// Class BFGCore.BFGFuronigamiSelectionInfo_Video
// 0x0028 (0x00E8 - 0x00C0)
class UBFGFuronigamiSelectionInfo_Video final : public UBFGFuronigamiSelectionInfo
{
public:
	TSoftObjectPtr<class UMediaSource>            M_pContent;                                        // 0x00C0(0x0028)(Edit, BlueprintVisible, BlueprintReadOnly, DisableEditOnInstance, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"BFGFuronigamiSelectionInfo_Video">();
	}
	static class UBFGFuronigamiSelectionInfo_Video* GetDefaultObj()
	{
		return GetDefaultObjImpl<UBFGFuronigamiSelectionInfo_Video>();
	}
};
static_assert(alignof(UBFGFuronigamiSelectionInfo_Video) == 0x000008, "Wrong alignment on UBFGFuronigamiSelectionInfo_Video");
static_assert(sizeof(UBFGFuronigamiSelectionInfo_Video) == 0x0000E8, "Wrong size on UBFGFuronigamiSelectionInfo_Video");
static_assert(offsetof(UBFGFuronigamiSelectionInfo_Video, M_pContent) == 0x0000C0, "Member 'UBFGFuronigamiSelectionInfo_Video::M_pContent' has a wrong offset!");

// Class BFGCore.BFGWidget_Archive_HolobobDeck
// 0x0058 (0x0548 - 0x04F0)
class UBFGWidget_Archive_HolobobDeck final : public UBFGWidget_Archive_SubMenu
{
public:
	float                                         M_fMaxScrollSpeed;                                 // 0x04F0(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          M_bShouldSort;                                     // 0x04F4(0x0001)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_4F5[0x3];                                      // 0x04F5(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<struct FBFGHolobobDeckSelectionInfo>   M_aHoloPoxDeckEntries;                             // 0x04F8(0x0010)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Protected, NativeAccessSpecifierProtected)
	class FText                                   M_strLockText;                                     // 0x0508(0x0018)(Edit, DisableEditOnInstance, Protected, NativeAccessSpecifierProtected)
	class FText                                   M_strConfirmationPromptText_Message;               // 0x0520(0x0018)(Edit, DisableEditOnInstance, Protected, NativeAccessSpecifierProtected)
	uint8                                         Pad_538[0x10];                                     // 0x0538(0x0010)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void ChangeButtonDescription(class FText* _strText, EButtonState _oButtonState);
	void OnAddOptiontoLayout(class UBFGWidget_DialogOption* _pOption);
	void OnClearOptionLayout();
	void OnConfimationPromptClosed(bool _bResult);
	void OnRewardGained(const class FText& _inTopic, const class FText& _inDescription);
	void OnShowContentLayout(bool _bShow);
	void OnUpdateInfoMission(int32 _iIndex);
	void Scroll(float _fValue);
	void ScrolltoWidget(class UBFGWidget_DialogOption* _pOption);
	void UpdateMissionInfo(int32 _iIndex);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"BFGWidget_Archive_HolobobDeck">();
	}
	static class UBFGWidget_Archive_HolobobDeck* GetDefaultObj()
	{
		return GetDefaultObjImpl<UBFGWidget_Archive_HolobobDeck>();
	}
};
static_assert(alignof(UBFGWidget_Archive_HolobobDeck) == 0x000008, "Wrong alignment on UBFGWidget_Archive_HolobobDeck");
static_assert(sizeof(UBFGWidget_Archive_HolobobDeck) == 0x000548, "Wrong size on UBFGWidget_Archive_HolobobDeck");
static_assert(offsetof(UBFGWidget_Archive_HolobobDeck, M_fMaxScrollSpeed) == 0x0004F0, "Member 'UBFGWidget_Archive_HolobobDeck::M_fMaxScrollSpeed' has a wrong offset!");
static_assert(offsetof(UBFGWidget_Archive_HolobobDeck, M_bShouldSort) == 0x0004F4, "Member 'UBFGWidget_Archive_HolobobDeck::M_bShouldSort' has a wrong offset!");
static_assert(offsetof(UBFGWidget_Archive_HolobobDeck, M_aHoloPoxDeckEntries) == 0x0004F8, "Member 'UBFGWidget_Archive_HolobobDeck::M_aHoloPoxDeckEntries' has a wrong offset!");
static_assert(offsetof(UBFGWidget_Archive_HolobobDeck, M_strLockText) == 0x000508, "Member 'UBFGWidget_Archive_HolobobDeck::M_strLockText' has a wrong offset!");
static_assert(offsetof(UBFGWidget_Archive_HolobobDeck, M_strConfirmationPromptText_Message) == 0x000520, "Member 'UBFGWidget_Archive_HolobobDeck::M_strConfirmationPromptText_Message' has a wrong offset!");

// Class BFGCore.BFGWidget_DialogOption_InvasionReport
// 0x0020 (0x0298 - 0x0278)
class UBFGWidget_DialogOption_InvasionReport final : public UBFGWidget_DialogOption_Customizable
{
public:
	class FText                                   M_strTopic;                                        // 0x0278(0x0018)(BlueprintVisible, BlueprintReadOnly, NativeAccessSpecifierPublic)
	float                                         M_fAmount;                                         // 0x0290(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_294[0x4];                                      // 0x0294(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"BFGWidget_DialogOption_InvasionReport">();
	}
	static class UBFGWidget_DialogOption_InvasionReport* GetDefaultObj()
	{
		return GetDefaultObjImpl<UBFGWidget_DialogOption_InvasionReport>();
	}
};
static_assert(alignof(UBFGWidget_DialogOption_InvasionReport) == 0x000008, "Wrong alignment on UBFGWidget_DialogOption_InvasionReport");
static_assert(sizeof(UBFGWidget_DialogOption_InvasionReport) == 0x000298, "Wrong size on UBFGWidget_DialogOption_InvasionReport");
static_assert(offsetof(UBFGWidget_DialogOption_InvasionReport, M_strTopic) == 0x000278, "Member 'UBFGWidget_DialogOption_InvasionReport::M_strTopic' has a wrong offset!");
static_assert(offsetof(UBFGWidget_DialogOption_InvasionReport, M_fAmount) == 0x000290, "Member 'UBFGWidget_DialogOption_InvasionReport::M_fAmount' has a wrong offset!");

// Class BFGCore.BFGSkinSelectionInfo
// 0x00E8 (0x0118 - 0x0030)
class UBFGSkinSelectionInfo final : public UDataAsset
{
public:
	class FText                                   M_strTopic;                                        // 0x0030(0x0018)(Edit, BlueprintVisible, BlueprintReadOnly, DisableEditOnInstance, NativeAccessSpecifierPublic)
	class FText                                   M_strDescription;                                  // 0x0048(0x0018)(Edit, BlueprintVisible, BlueprintReadOnly, DisableEditOnInstance, NativeAccessSpecifierPublic)
	struct FSlateBrush                            M_iconSprite;                                      // 0x0060(0x0088)(Edit, BlueprintVisible, BlueprintReadOnly, DisableEditOnInstance, NativeAccessSpecifierPublic)
	struct FGameplayTag                           M_oSkinTag;                                        // 0x00E8(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, DisableEditOnInstance, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EBFGDLCItem                                   M_DLCToCheck;                                      // 0x00F0(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_F1[0x7];                                       // 0x00F1(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	class FText                                   M_strUnlockCondition;                              // 0x00F8(0x0018)(Edit, BlueprintVisible, BlueprintReadOnly, DisableEditOnInstance, NativeAccessSpecifierPublic)
	bool                                          M_bHideFromSkinSelection;                          // 0x0110(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_111[0x7];                                      // 0x0111(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"BFGSkinSelectionInfo">();
	}
	static class UBFGSkinSelectionInfo* GetDefaultObj()
	{
		return GetDefaultObjImpl<UBFGSkinSelectionInfo>();
	}
};
static_assert(alignof(UBFGSkinSelectionInfo) == 0x000008, "Wrong alignment on UBFGSkinSelectionInfo");
static_assert(sizeof(UBFGSkinSelectionInfo) == 0x000118, "Wrong size on UBFGSkinSelectionInfo");
static_assert(offsetof(UBFGSkinSelectionInfo, M_strTopic) == 0x000030, "Member 'UBFGSkinSelectionInfo::M_strTopic' has a wrong offset!");
static_assert(offsetof(UBFGSkinSelectionInfo, M_strDescription) == 0x000048, "Member 'UBFGSkinSelectionInfo::M_strDescription' has a wrong offset!");
static_assert(offsetof(UBFGSkinSelectionInfo, M_iconSprite) == 0x000060, "Member 'UBFGSkinSelectionInfo::M_iconSprite' has a wrong offset!");
static_assert(offsetof(UBFGSkinSelectionInfo, M_oSkinTag) == 0x0000E8, "Member 'UBFGSkinSelectionInfo::M_oSkinTag' has a wrong offset!");
static_assert(offsetof(UBFGSkinSelectionInfo, M_DLCToCheck) == 0x0000F0, "Member 'UBFGSkinSelectionInfo::M_DLCToCheck' has a wrong offset!");
static_assert(offsetof(UBFGSkinSelectionInfo, M_strUnlockCondition) == 0x0000F8, "Member 'UBFGSkinSelectionInfo::M_strUnlockCondition' has a wrong offset!");
static_assert(offsetof(UBFGSkinSelectionInfo, M_bHideFromSkinSelection) == 0x000110, "Member 'UBFGSkinSelectionInfo::M_bHideFromSkinSelection' has a wrong offset!");

// Class BFGCore.BFGWidget_Archive_SkinMenu
// 0x0078 (0x0568 - 0x04F0)
class UBFGWidget_Archive_SkinMenu final : public UBFGWidget_Archive_SubMenu
{
public:
	class UBFGSpinningWidget*                     M_pSpinningWidget;                                 // 0x04F0(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, Transient, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TArray<class UBFGSkinSelectionInfo*>          M_aSkinInfo;                                       // 0x04F8(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, Protected, NativeAccessSpecifierProtected)
	TArray<class UBFGSkinSelectionInfo*>          M_aAvailableSkins;                                 // 0x0508(0x0010)(ZeroConstructor, Protected, NativeAccessSpecifierProtected)
	TSoftClassPtr<class UClass>                   M_pSpinningWidgetOptionClass;                      // 0x0518(0x0028)(Edit, BlueprintVisible, BlueprintReadOnly, DisableEditOnInstance, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	int32                                         M_iCurrentIndex;                                   // 0x0540(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_544[0x4];                                      // 0x0544(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class UObjectLibrary*                         M_pPreloadLibrary;                                 // 0x0548(0x0008)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class FString                                 M_strAssetFolder;                                  // 0x0550(0x0010)(Edit, ZeroConstructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          M_bHasEventSend;                                   // 0x0560(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_561[0x7];                                      // 0x0561(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	class UBFGSpinningWidget* GetSpinningWidget();
	bool HasSpinningWidget();
	void OnChangeSkin();
	void OnRotateSkin(float _fValue);
	void OnUpdateSkinConditionText(const bool _bShowText, const class FText& _strText);
	void ProcessAdvance();
	void UpdateDescriptionPanel(int32 _iIndex);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"BFGWidget_Archive_SkinMenu">();
	}
	static class UBFGWidget_Archive_SkinMenu* GetDefaultObj()
	{
		return GetDefaultObjImpl<UBFGWidget_Archive_SkinMenu>();
	}
};
static_assert(alignof(UBFGWidget_Archive_SkinMenu) == 0x000008, "Wrong alignment on UBFGWidget_Archive_SkinMenu");
static_assert(sizeof(UBFGWidget_Archive_SkinMenu) == 0x000568, "Wrong size on UBFGWidget_Archive_SkinMenu");
static_assert(offsetof(UBFGWidget_Archive_SkinMenu, M_pSpinningWidget) == 0x0004F0, "Member 'UBFGWidget_Archive_SkinMenu::M_pSpinningWidget' has a wrong offset!");
static_assert(offsetof(UBFGWidget_Archive_SkinMenu, M_aSkinInfo) == 0x0004F8, "Member 'UBFGWidget_Archive_SkinMenu::M_aSkinInfo' has a wrong offset!");
static_assert(offsetof(UBFGWidget_Archive_SkinMenu, M_aAvailableSkins) == 0x000508, "Member 'UBFGWidget_Archive_SkinMenu::M_aAvailableSkins' has a wrong offset!");
static_assert(offsetof(UBFGWidget_Archive_SkinMenu, M_pSpinningWidgetOptionClass) == 0x000518, "Member 'UBFGWidget_Archive_SkinMenu::M_pSpinningWidgetOptionClass' has a wrong offset!");
static_assert(offsetof(UBFGWidget_Archive_SkinMenu, M_iCurrentIndex) == 0x000540, "Member 'UBFGWidget_Archive_SkinMenu::M_iCurrentIndex' has a wrong offset!");
static_assert(offsetof(UBFGWidget_Archive_SkinMenu, M_pPreloadLibrary) == 0x000548, "Member 'UBFGWidget_Archive_SkinMenu::M_pPreloadLibrary' has a wrong offset!");
static_assert(offsetof(UBFGWidget_Archive_SkinMenu, M_strAssetFolder) == 0x000550, "Member 'UBFGWidget_Archive_SkinMenu::M_strAssetFolder' has a wrong offset!");
static_assert(offsetof(UBFGWidget_Archive_SkinMenu, M_bHasEventSend) == 0x000560, "Member 'UBFGWidget_Archive_SkinMenu::M_bHasEventSend' has a wrong offset!");

// Class BFGCore.BFGWidget_ContextualHint
// 0x0028 (0x0320 - 0x02F8)
class UBFGWidget_ContextualHint : public UBFGWidget_HUD
{
public:
	float                                         M_fContextualTime;                                 // 0x02F8(0x0004)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         M_fCurrentRation;                                  // 0x02FC(0x0004)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UBFGDataAsset_TutorialInputAction*      M_pInputActionHint;                                // 0x0300(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EContextualHintMode                           M_eMode;                                           // 0x0308(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_309[0x7];                                      // 0x0309(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	class UBFGActorComponent_PlayerInteractions*  M_pPlayerInteractionsComponent;                    // 0x0310(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UBFGActorComponent_InputActions*        M_pPlayerInputActionsComponent;                    // 0x0318(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"BFGWidget_ContextualHint">();
	}
	static class UBFGWidget_ContextualHint* GetDefaultObj()
	{
		return GetDefaultObjImpl<UBFGWidget_ContextualHint>();
	}
};
static_assert(alignof(UBFGWidget_ContextualHint) == 0x000008, "Wrong alignment on UBFGWidget_ContextualHint");
static_assert(sizeof(UBFGWidget_ContextualHint) == 0x000320, "Wrong size on UBFGWidget_ContextualHint");
static_assert(offsetof(UBFGWidget_ContextualHint, M_fContextualTime) == 0x0002F8, "Member 'UBFGWidget_ContextualHint::M_fContextualTime' has a wrong offset!");
static_assert(offsetof(UBFGWidget_ContextualHint, M_fCurrentRation) == 0x0002FC, "Member 'UBFGWidget_ContextualHint::M_fCurrentRation' has a wrong offset!");
static_assert(offsetof(UBFGWidget_ContextualHint, M_pInputActionHint) == 0x000300, "Member 'UBFGWidget_ContextualHint::M_pInputActionHint' has a wrong offset!");
static_assert(offsetof(UBFGWidget_ContextualHint, M_eMode) == 0x000308, "Member 'UBFGWidget_ContextualHint::M_eMode' has a wrong offset!");
static_assert(offsetof(UBFGWidget_ContextualHint, M_pPlayerInteractionsComponent) == 0x000310, "Member 'UBFGWidget_ContextualHint::M_pPlayerInteractionsComponent' has a wrong offset!");
static_assert(offsetof(UBFGWidget_ContextualHint, M_pPlayerInputActionsComponent) == 0x000318, "Member 'UBFGWidget_ContextualHint::M_pPlayerInputActionsComponent' has a wrong offset!");

// Class BFGCore.BFGWidget_ControllerDisconnected
// 0x0010 (0x0438 - 0x0428)
class UBFGWidget_ControllerDisconnected final : public UBFGWidget_GenericDialog
{
public:
	uint8                                         Pad_428[0x8];                                      // 0x0428(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	class UBFGUserSignInManager*                  M_pManager;                                        // 0x0430(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)

public:
	void OnApplicationPostInputKeyDownEvent(const struct FKeyEvent& _keyEvent);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"BFGWidget_ControllerDisconnected">();
	}
	static class UBFGWidget_ControllerDisconnected* GetDefaultObj()
	{
		return GetDefaultObjImpl<UBFGWidget_ControllerDisconnected>();
	}
};
static_assert(alignof(UBFGWidget_ControllerDisconnected) == 0x000008, "Wrong alignment on UBFGWidget_ControllerDisconnected");
static_assert(sizeof(UBFGWidget_ControllerDisconnected) == 0x000438, "Wrong size on UBFGWidget_ControllerDisconnected");
static_assert(offsetof(UBFGWidget_ControllerDisconnected, M_pManager) == 0x000430, "Member 'UBFGWidget_ControllerDisconnected::M_pManager' has a wrong offset!");

// Class BFGCore.BFGWidget_CreditsTextPanel
// 0x0018 (0x0258 - 0x0240)
class UBFGWidget_CreditsTextPanel final : public UUserWidget
{
public:
	UMulticastDelegateProperty_                   OnCreditsTextPanelDone;                            // 0x0240(0x0018)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)

public:
	void Action_OnCreditsTextPanelDone__DelegateSignature(class UBFGWidget_CreditsTextPanel* _pPanel);
	void ForceDisappear();
	void RegisterDone();
	void SetFont(const struct FSlateFontInfo& _oFontInfo);
	void SetText(const class FText& _rText);
	void TriggerScrollAnimation(float _fPlaybackSpeed);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"BFGWidget_CreditsTextPanel">();
	}
	static class UBFGWidget_CreditsTextPanel* GetDefaultObj()
	{
		return GetDefaultObjImpl<UBFGWidget_CreditsTextPanel>();
	}
};
static_assert(alignof(UBFGWidget_CreditsTextPanel) == 0x000008, "Wrong alignment on UBFGWidget_CreditsTextPanel");
static_assert(sizeof(UBFGWidget_CreditsTextPanel) == 0x000258, "Wrong size on UBFGWidget_CreditsTextPanel");
static_assert(offsetof(UBFGWidget_CreditsTextPanel, OnCreditsTextPanelDone) == 0x000240, "Member 'UBFGWidget_CreditsTextPanel::OnCreditsTextPanelDone' has a wrong offset!");

// Class BFGCore.BFGWidget_DialogOption_AssignKey
// 0x0030 (0x02A8 - 0x0278)
class UBFGWidget_DialogOption_AssignKey final : public UBFGWidget_DialogOption_Customizable
{
public:
	UMulticastDelegateProperty_                   M_OnKeyAssignmentBegin;                            // 0x0278(0x0018)(ZeroConstructor, InstancedReference, NativeAccessSpecifierPublic)
	TArray<struct FKey>                           M_aoKeySlots;                                      // 0x0290(0x0010)(ZeroConstructor, Protected, NativeAccessSpecifierProtected)
	uint8                                         Pad_2A0[0x8];                                      // 0x02A0(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void ActionKeyAssignment__DelegateSignature(class UBFGWidget_DialogOption_AssignKey* _pOption, const struct FKey& _oKey, int32 _iIndex);
	void OnKeySlotClicked(int32 _iIndex);
	void SetCurrentSlotIndex(int32 _iSlotIndex);
	void SetKeySlotText(int32 _iIndexSlot, const class FText& _strText);
	void UpdateSlotIndexHighlightState(int32 _Index, bool _bHighlighted);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"BFGWidget_DialogOption_AssignKey">();
	}
	static class UBFGWidget_DialogOption_AssignKey* GetDefaultObj()
	{
		return GetDefaultObjImpl<UBFGWidget_DialogOption_AssignKey>();
	}
};
static_assert(alignof(UBFGWidget_DialogOption_AssignKey) == 0x000008, "Wrong alignment on UBFGWidget_DialogOption_AssignKey");
static_assert(sizeof(UBFGWidget_DialogOption_AssignKey) == 0x0002A8, "Wrong size on UBFGWidget_DialogOption_AssignKey");
static_assert(offsetof(UBFGWidget_DialogOption_AssignKey, M_OnKeyAssignmentBegin) == 0x000278, "Member 'UBFGWidget_DialogOption_AssignKey::M_OnKeyAssignmentBegin' has a wrong offset!");
static_assert(offsetof(UBFGWidget_DialogOption_AssignKey, M_aoKeySlots) == 0x000290, "Member 'UBFGWidget_DialogOption_AssignKey::M_aoKeySlots' has a wrong offset!");

// Class BFGCore.BFGWidget_DialogOption_Selector
// 0x0038 (0x02B0 - 0x0278)
class UBFGWidget_DialogOption_Selector final : public UBFGWidget_DialogOption_Customizable
{
public:
	UMulticastDelegateProperty_                   M_OnOptionChanged;                                 // 0x0278(0x0018)(ZeroConstructor, InstancedReference, NativeAccessSpecifierPublic)
	TSubclassOf<class UBFGWidget_SelectorItem>    M_pSelectorItemClass;                              // 0x0290(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TArray<class UBFGWidget_SelectorItem*>        M_apOptions;                                       // 0x0298(0x0010)(ExportObject, ZeroConstructor, ContainsInstancedReference, Protected, NativeAccessSpecifierProtected)
	uint8                                         Pad_2A8[0x8];                                      // 0x02A8(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void ActionSelector__DelegateSignature(class UBFGWidget_DialogOption_Selector* _pSelector);
	void AddOptionToLayout(class UBFGWidget_SelectorItem* _pOption);
	void OnOptionClicked(int32 _iOption);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"BFGWidget_DialogOption_Selector">();
	}
	static class UBFGWidget_DialogOption_Selector* GetDefaultObj()
	{
		return GetDefaultObjImpl<UBFGWidget_DialogOption_Selector>();
	}
};
static_assert(alignof(UBFGWidget_DialogOption_Selector) == 0x000008, "Wrong alignment on UBFGWidget_DialogOption_Selector");
static_assert(sizeof(UBFGWidget_DialogOption_Selector) == 0x0002B0, "Wrong size on UBFGWidget_DialogOption_Selector");
static_assert(offsetof(UBFGWidget_DialogOption_Selector, M_OnOptionChanged) == 0x000278, "Member 'UBFGWidget_DialogOption_Selector::M_OnOptionChanged' has a wrong offset!");
static_assert(offsetof(UBFGWidget_DialogOption_Selector, M_pSelectorItemClass) == 0x000290, "Member 'UBFGWidget_DialogOption_Selector::M_pSelectorItemClass' has a wrong offset!");
static_assert(offsetof(UBFGWidget_DialogOption_Selector, M_apOptions) == 0x000298, "Member 'UBFGWidget_DialogOption_Selector::M_apOptions' has a wrong offset!");

// Class BFGCore.BFGWidget_DialogOption_Slider
// 0x0030 (0x02A8 - 0x0278)
class UBFGWidget_DialogOption_Slider final : public UBFGWidget_DialogOption_Customizable
{
public:
	UMulticastDelegateProperty_                   M_OnValueChanged;                                  // 0x0278(0x0018)(ZeroConstructor, InstancedReference, NativeAccessSpecifierPublic)
	uint8                                         Pad_290[0x14];                                     // 0x0290(0x0014)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         M_fSliderSpeed;                                    // 0x02A4(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)

public:
	void ActionSlider__DelegateSignature(class UBFGWidget_DialogOption_Slider* _pSlider);
	void SetRelativeValue(float _fValue, bool _bBroadcast);
	void SetValueAsAbsolute(float _fValue, bool _bBroadcast);
	void UpdateFloat(float _fValue);
	void UpdatePercent(int32 _iPercent);
	void UpdateSlider(float _fValue);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"BFGWidget_DialogOption_Slider">();
	}
	static class UBFGWidget_DialogOption_Slider* GetDefaultObj()
	{
		return GetDefaultObjImpl<UBFGWidget_DialogOption_Slider>();
	}
};
static_assert(alignof(UBFGWidget_DialogOption_Slider) == 0x000008, "Wrong alignment on UBFGWidget_DialogOption_Slider");
static_assert(sizeof(UBFGWidget_DialogOption_Slider) == 0x0002A8, "Wrong size on UBFGWidget_DialogOption_Slider");
static_assert(offsetof(UBFGWidget_DialogOption_Slider, M_OnValueChanged) == 0x000278, "Member 'UBFGWidget_DialogOption_Slider::M_OnValueChanged' has a wrong offset!");
static_assert(offsetof(UBFGWidget_DialogOption_Slider, M_fSliderSpeed) == 0x0002A4, "Member 'UBFGWidget_DialogOption_Slider::M_fSliderSpeed' has a wrong offset!");

// Class BFGCore.BFGWidget_KeyAssignmentWindow
// 0x0070 (0x02B0 - 0x0240)
class UBFGWidget_KeyAssignmentWindow final : public UUserWidget
{
public:
	UMulticastDelegateProperty_                   M_OnOptionRequiresUpdate;                          // 0x0240(0x0018)(ZeroConstructor, InstancedReference, NativeAccessSpecifierPublic)
	UMulticastDelegateProperty_                   M_OnKeyAssignmentDone;                             // 0x0258(0x0018)(ZeroConstructor, InstancedReference, NativeAccessSpecifierPublic)
	uint8                                         Pad_270[0x10];                                     // 0x0270(0x0010)(Fixing Size After Last Property [ Dumper-7 ])
	class UBFGWidget_DialogOption_AssignKey*      M_pTargetOption;                                   // 0x0280(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UBFGInputRebindingSystem*               M_pRebindingSystem;                                // 0x0288(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_290[0x20];                                     // 0x0290(0x0020)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void Action__DelegateSignature();
	void ActionName__DelegateSignature(class FName _oName);
	void OnAssignmentStateChanged(EBFGKeyAssignmentState _eCurrentState);
	void OnButtonClicked_Accept();
	void OnButtonClicked_Cancel();
	void OnButtonHover_Accept(bool _bHover);
	void OnButtonHover_Cancel(bool _bHover);
	void OnCurrentKeySet(const class FText& _strCurrentKey);
	void OnIndexSet(int32 _iIndex);
	void OnUsedControlTextSet(const class FText& _strUsedControl);
	void RemoveFromLayoutAnimated();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"BFGWidget_KeyAssignmentWindow">();
	}
	static class UBFGWidget_KeyAssignmentWindow* GetDefaultObj()
	{
		return GetDefaultObjImpl<UBFGWidget_KeyAssignmentWindow>();
	}
};
static_assert(alignof(UBFGWidget_KeyAssignmentWindow) == 0x000008, "Wrong alignment on UBFGWidget_KeyAssignmentWindow");
static_assert(sizeof(UBFGWidget_KeyAssignmentWindow) == 0x0002B0, "Wrong size on UBFGWidget_KeyAssignmentWindow");
static_assert(offsetof(UBFGWidget_KeyAssignmentWindow, M_OnOptionRequiresUpdate) == 0x000240, "Member 'UBFGWidget_KeyAssignmentWindow::M_OnOptionRequiresUpdate' has a wrong offset!");
static_assert(offsetof(UBFGWidget_KeyAssignmentWindow, M_OnKeyAssignmentDone) == 0x000258, "Member 'UBFGWidget_KeyAssignmentWindow::M_OnKeyAssignmentDone' has a wrong offset!");
static_assert(offsetof(UBFGWidget_KeyAssignmentWindow, M_pTargetOption) == 0x000280, "Member 'UBFGWidget_KeyAssignmentWindow::M_pTargetOption' has a wrong offset!");
static_assert(offsetof(UBFGWidget_KeyAssignmentWindow, M_pRebindingSystem) == 0x000288, "Member 'UBFGWidget_KeyAssignmentWindow::M_pRebindingSystem' has a wrong offset!");

// Class BFGCore.BFGWidget_GameplayEnd_Background
// 0x0000 (0x0240 - 0x0240)
class UBFGWidget_GameplayEnd_Background final : public UUserWidget
{
public:
	void StartFadeInAnim();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"BFGWidget_GameplayEnd_Background">();
	}
	static class UBFGWidget_GameplayEnd_Background* GetDefaultObj()
	{
		return GetDefaultObjImpl<UBFGWidget_GameplayEnd_Background>();
	}
};
static_assert(alignof(UBFGWidget_GameplayEnd_Background) == 0x000008, "Wrong alignment on UBFGWidget_GameplayEnd_Background");
static_assert(sizeof(UBFGWidget_GameplayEnd_Background) == 0x000240, "Wrong size on UBFGWidget_GameplayEnd_Background");

// Class BFGCore.BFGWidget_GameplayEnd_BackgroundBlur
// 0x0010 (0x0250 - 0x0240)
class UBFGWidget_GameplayEnd_BackgroundBlur final : public UUserWidget
{
public:
	float                                         M_fFullyBlurredThreshold;                          // 0x0240(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_244[0xC];                                      // 0x0244(0x000C)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void StartBlurAnimation();

	float GetBlurStrength() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"BFGWidget_GameplayEnd_BackgroundBlur">();
	}
	static class UBFGWidget_GameplayEnd_BackgroundBlur* GetDefaultObj()
	{
		return GetDefaultObjImpl<UBFGWidget_GameplayEnd_BackgroundBlur>();
	}
};
static_assert(alignof(UBFGWidget_GameplayEnd_BackgroundBlur) == 0x000008, "Wrong alignment on UBFGWidget_GameplayEnd_BackgroundBlur");
static_assert(sizeof(UBFGWidget_GameplayEnd_BackgroundBlur) == 0x000250, "Wrong size on UBFGWidget_GameplayEnd_BackgroundBlur");
static_assert(offsetof(UBFGWidget_GameplayEnd_BackgroundBlur, M_fFullyBlurredThreshold) == 0x000240, "Member 'UBFGWidget_GameplayEnd_BackgroundBlur::M_fFullyBlurredThreshold' has a wrong offset!");

// Class BFGCore.BFGWidget_GameplayTags
// 0x0000 (0x0240 - 0x0240)
class UBFGWidget_GameplayTags final : public UUserWidget
{
public:
	void Event__DelegateSignature(class UBFGWidget_GameplayTagOption* _pWidget);
	void UpdateData(const TArray<class UBFGMentalAbilityBase*>& _apAvailableAbilities);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"BFGWidget_GameplayTags">();
	}
	static class UBFGWidget_GameplayTags* GetDefaultObj()
	{
		return GetDefaultObjImpl<UBFGWidget_GameplayTags>();
	}
};
static_assert(alignof(UBFGWidget_GameplayTags) == 0x000008, "Wrong alignment on UBFGWidget_GameplayTags");
static_assert(sizeof(UBFGWidget_GameplayTags) == 0x000240, "Wrong size on UBFGWidget_GameplayTags");

// Class BFGCore.BFGWidget_GenericHold
// 0x0048 (0x02C0 - 0x0278)
class UBFGWidget_GenericHold final : public UBFGInputUserWidget
{
public:
	UMulticastDelegateProperty_                   M_onTriggered;                                     // 0x0278(0x0018)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	class FText                                   M_strText;                                         // 0x0290(0x0018)(Edit, BlueprintVisible, BlueprintReadOnly, Protected, NativeAccessSpecifierProtected)
	EBFGWidget_GenericHold_Button                 M_eButton;                                         // 0x02A8(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_2A9[0x3];                                      // 0x02A9(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         M_fTimeLimit;                                      // 0x02AC(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         M_fFadeOutTime;                                    // 0x02B0(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_2B4[0xC];                                      // 0x02B4(0x000C)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void Enable(bool _bIsEnabled, bool _bAnimate);
	void Hide_Internal(bool _bAnimate);
	void Show(bool _bIsVisible, bool _bAnimate);
	void Show_Internal(bool _bAnimate);
	void UpdateProgress(float _fPercentage);

	class FText GetBtnHint() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"BFGWidget_GenericHold">();
	}
	static class UBFGWidget_GenericHold* GetDefaultObj()
	{
		return GetDefaultObjImpl<UBFGWidget_GenericHold>();
	}
};
static_assert(alignof(UBFGWidget_GenericHold) == 0x000008, "Wrong alignment on UBFGWidget_GenericHold");
static_assert(sizeof(UBFGWidget_GenericHold) == 0x0002C0, "Wrong size on UBFGWidget_GenericHold");
static_assert(offsetof(UBFGWidget_GenericHold, M_onTriggered) == 0x000278, "Member 'UBFGWidget_GenericHold::M_onTriggered' has a wrong offset!");
static_assert(offsetof(UBFGWidget_GenericHold, M_strText) == 0x000290, "Member 'UBFGWidget_GenericHold::M_strText' has a wrong offset!");
static_assert(offsetof(UBFGWidget_GenericHold, M_eButton) == 0x0002A8, "Member 'UBFGWidget_GenericHold::M_eButton' has a wrong offset!");
static_assert(offsetof(UBFGWidget_GenericHold, M_fTimeLimit) == 0x0002AC, "Member 'UBFGWidget_GenericHold::M_fTimeLimit' has a wrong offset!");
static_assert(offsetof(UBFGWidget_GenericHold, M_fFadeOutTime) == 0x0002B0, "Member 'UBFGWidget_GenericHold::M_fFadeOutTime' has a wrong offset!");

// Class BFGCore.BFGWidget_HUD_Crosshair
// 0x0028 (0x0320 - 0x02F8)
class UBFGWidget_HUD_Crosshair : public UBFGWidget_HUD
{
public:
	int32                                         M_iAmmoCurrent;                                    // 0x02F8(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2FC[0x4];                                      // 0x02FC(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class UUserWidget*                            M_pWeaponIcon;                                     // 0x0300(0x0008)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         M_iAmmoMax;                                        // 0x0308(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   M_sWeaponName;                                     // 0x030C(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_314[0x4];                                      // 0x0314(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class ABFGWeapon*                             M_pWeapon;                                         // 0x0318(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

public:
	class ABFGWeapon* GetWeapon();
	void SetWeapon(class ABFGWeapon* _pWeapon);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"BFGWidget_HUD_Crosshair">();
	}
	static class UBFGWidget_HUD_Crosshair* GetDefaultObj()
	{
		return GetDefaultObjImpl<UBFGWidget_HUD_Crosshair>();
	}
};
static_assert(alignof(UBFGWidget_HUD_Crosshair) == 0x000008, "Wrong alignment on UBFGWidget_HUD_Crosshair");
static_assert(sizeof(UBFGWidget_HUD_Crosshair) == 0x000320, "Wrong size on UBFGWidget_HUD_Crosshair");
static_assert(offsetof(UBFGWidget_HUD_Crosshair, M_iAmmoCurrent) == 0x0002F8, "Member 'UBFGWidget_HUD_Crosshair::M_iAmmoCurrent' has a wrong offset!");
static_assert(offsetof(UBFGWidget_HUD_Crosshair, M_pWeaponIcon) == 0x000300, "Member 'UBFGWidget_HUD_Crosshair::M_pWeaponIcon' has a wrong offset!");
static_assert(offsetof(UBFGWidget_HUD_Crosshair, M_iAmmoMax) == 0x000308, "Member 'UBFGWidget_HUD_Crosshair::M_iAmmoMax' has a wrong offset!");
static_assert(offsetof(UBFGWidget_HUD_Crosshair, M_sWeaponName) == 0x00030C, "Member 'UBFGWidget_HUD_Crosshair::M_sWeaponName' has a wrong offset!");
static_assert(offsetof(UBFGWidget_HUD_Crosshair, M_pWeapon) == 0x000318, "Member 'UBFGWidget_HUD_Crosshair::M_pWeapon' has a wrong offset!");

// Class BFGCore.BFGWidget_HUD_HealthIndicator
// 0x0010 (0x0308 - 0x02F8)
class UBFGWidget_HUD_HealthIndicator final : public UBFGWidget_HUD
{
public:
	int32                                         M_iAmmoCurrent;                                    // 0x02F8(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         M_fCurrentValue;                                   // 0x02FC(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class AActor*                                 M_pActor;                                          // 0x0300(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

public:
	void SetActor(class AActor* PActor);
	void SetHealth(float _fValue);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"BFGWidget_HUD_HealthIndicator">();
	}
	static class UBFGWidget_HUD_HealthIndicator* GetDefaultObj()
	{
		return GetDefaultObjImpl<UBFGWidget_HUD_HealthIndicator>();
	}
};
static_assert(alignof(UBFGWidget_HUD_HealthIndicator) == 0x000008, "Wrong alignment on UBFGWidget_HUD_HealthIndicator");
static_assert(sizeof(UBFGWidget_HUD_HealthIndicator) == 0x000308, "Wrong size on UBFGWidget_HUD_HealthIndicator");
static_assert(offsetof(UBFGWidget_HUD_HealthIndicator, M_iAmmoCurrent) == 0x0002F8, "Member 'UBFGWidget_HUD_HealthIndicator::M_iAmmoCurrent' has a wrong offset!");
static_assert(offsetof(UBFGWidget_HUD_HealthIndicator, M_fCurrentValue) == 0x0002FC, "Member 'UBFGWidget_HUD_HealthIndicator::M_fCurrentValue' has a wrong offset!");
static_assert(offsetof(UBFGWidget_HUD_HealthIndicator, M_pActor) == 0x000300, "Member 'UBFGWidget_HUD_HealthIndicator::M_pActor' has a wrong offset!");

// Class BFGCore.BFGWidget_HUD_MissionStats
// 0x0020 (0x0318 - 0x02F8)
class UBFGWidget_HUD_MissionStats final : public UBFGWidget_HUD
{
public:
	uint8                                         Pad_2F8[0x8];                                      // 0x02F8(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	int32                                         M_fHealth;                                         // 0x0300(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   M_sMissionName;                                    // 0x0304(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   M_sMissionDescription;                             // 0x030C(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_314[0x4];                                      // 0x0314(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"BFGWidget_HUD_MissionStats">();
	}
	static class UBFGWidget_HUD_MissionStats* GetDefaultObj()
	{
		return GetDefaultObjImpl<UBFGWidget_HUD_MissionStats>();
	}
};
static_assert(alignof(UBFGWidget_HUD_MissionStats) == 0x000008, "Wrong alignment on UBFGWidget_HUD_MissionStats");
static_assert(sizeof(UBFGWidget_HUD_MissionStats) == 0x000318, "Wrong size on UBFGWidget_HUD_MissionStats");
static_assert(offsetof(UBFGWidget_HUD_MissionStats, M_fHealth) == 0x000300, "Member 'UBFGWidget_HUD_MissionStats::M_fHealth' has a wrong offset!");
static_assert(offsetof(UBFGWidget_HUD_MissionStats, M_sMissionName) == 0x000304, "Member 'UBFGWidget_HUD_MissionStats::M_sMissionName' has a wrong offset!");
static_assert(offsetof(UBFGWidget_HUD_MissionStats, M_sMissionDescription) == 0x00030C, "Member 'UBFGWidget_HUD_MissionStats::M_sMissionDescription' has a wrong offset!");

// Class BFGCore.BFGWidget_HUD_OrthoBox
// 0x0040 (0x0338 - 0x02F8)
class UBFGWidget_HUD_OrthoBox : public UBFGWidget_HUD
{
public:
	uint8                                         Pad_2F8[0x8];                                      // 0x02F8(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	class FText                                   M_strcurrentMessage;                               // 0x0300(0x0018)(Edit, BlueprintVisible, BlueprintReadOnly, DisableEditOnInstance, NativeAccessSpecifierPublic)
	TArray<class FText>                           M_aBufferStrings;                                  // 0x0318(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, NativeAccessSpecifierPublic)
	class UTexture2D*                             M_pSpeakerPortrait;                                // 0x0328(0x0008)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          M_bShow;                                           // 0x0330(0x0001)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_331[0x7];                                      // 0x0331(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void OnUpdateMessage();
	void PlayHideAnimation();
	void PlayShowAnimation();
	void ShowWidget(bool _bShow);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"BFGWidget_HUD_OrthoBox">();
	}
	static class UBFGWidget_HUD_OrthoBox* GetDefaultObj()
	{
		return GetDefaultObjImpl<UBFGWidget_HUD_OrthoBox>();
	}
};
static_assert(alignof(UBFGWidget_HUD_OrthoBox) == 0x000008, "Wrong alignment on UBFGWidget_HUD_OrthoBox");
static_assert(sizeof(UBFGWidget_HUD_OrthoBox) == 0x000338, "Wrong size on UBFGWidget_HUD_OrthoBox");
static_assert(offsetof(UBFGWidget_HUD_OrthoBox, M_strcurrentMessage) == 0x000300, "Member 'UBFGWidget_HUD_OrthoBox::M_strcurrentMessage' has a wrong offset!");
static_assert(offsetof(UBFGWidget_HUD_OrthoBox, M_aBufferStrings) == 0x000318, "Member 'UBFGWidget_HUD_OrthoBox::M_aBufferStrings' has a wrong offset!");
static_assert(offsetof(UBFGWidget_HUD_OrthoBox, M_pSpeakerPortrait) == 0x000328, "Member 'UBFGWidget_HUD_OrthoBox::M_pSpeakerPortrait' has a wrong offset!");
static_assert(offsetof(UBFGWidget_HUD_OrthoBox, M_bShow) == 0x000330, "Member 'UBFGWidget_HUD_OrthoBox::M_bShow' has a wrong offset!");

// Class BFGCore.BFGWidget_SubquestEntry
// 0x0060 (0x02A0 - 0x0240)
class UBFGWidget_SubquestEntry : public UUserWidget
{
public:
	class UPaperSprite*                           M_pIconSprite;                                     // 0x0240(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class FText                                   M_strText;                                         // 0x0248(0x0018)(BlueprintVisible, BlueprintReadOnly, Protected, NativeAccessSpecifierProtected)
	EBFGQuest_UI_BarType                          M_eBarType;                                        // 0x0260(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_261[0x3];                                      // 0x0261(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	int32                                         M_iValueCurrent;                                   // 0x0264(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	int32                                         M_iValueMax;                                       // 0x0268(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	int32                                         M_iSegmentsSucceeded;                              // 0x026C(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	int32                                         M_iSegmentsFailed;                                 // 0x0270(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	int32                                         M_iTimeLimit;                                      // 0x0274(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TArray<int32>                                 M_aRewardPositions;                                // 0x0278(0x0010)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Protected, NativeAccessSpecifierProtected)
	uint8                                         Pad_288[0x18];                                     // 0x0288(0x0018)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void RebuildLayoutNative();
	void TriggerFinishedAnimation(bool _bFailed);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"BFGWidget_SubquestEntry">();
	}
	static class UBFGWidget_SubquestEntry* GetDefaultObj()
	{
		return GetDefaultObjImpl<UBFGWidget_SubquestEntry>();
	}
};
static_assert(alignof(UBFGWidget_SubquestEntry) == 0x000008, "Wrong alignment on UBFGWidget_SubquestEntry");
static_assert(sizeof(UBFGWidget_SubquestEntry) == 0x0002A0, "Wrong size on UBFGWidget_SubquestEntry");
static_assert(offsetof(UBFGWidget_SubquestEntry, M_pIconSprite) == 0x000240, "Member 'UBFGWidget_SubquestEntry::M_pIconSprite' has a wrong offset!");
static_assert(offsetof(UBFGWidget_SubquestEntry, M_strText) == 0x000248, "Member 'UBFGWidget_SubquestEntry::M_strText' has a wrong offset!");
static_assert(offsetof(UBFGWidget_SubquestEntry, M_eBarType) == 0x000260, "Member 'UBFGWidget_SubquestEntry::M_eBarType' has a wrong offset!");
static_assert(offsetof(UBFGWidget_SubquestEntry, M_iValueCurrent) == 0x000264, "Member 'UBFGWidget_SubquestEntry::M_iValueCurrent' has a wrong offset!");
static_assert(offsetof(UBFGWidget_SubquestEntry, M_iValueMax) == 0x000268, "Member 'UBFGWidget_SubquestEntry::M_iValueMax' has a wrong offset!");
static_assert(offsetof(UBFGWidget_SubquestEntry, M_iSegmentsSucceeded) == 0x00026C, "Member 'UBFGWidget_SubquestEntry::M_iSegmentsSucceeded' has a wrong offset!");
static_assert(offsetof(UBFGWidget_SubquestEntry, M_iSegmentsFailed) == 0x000270, "Member 'UBFGWidget_SubquestEntry::M_iSegmentsFailed' has a wrong offset!");
static_assert(offsetof(UBFGWidget_SubquestEntry, M_iTimeLimit) == 0x000274, "Member 'UBFGWidget_SubquestEntry::M_iTimeLimit' has a wrong offset!");
static_assert(offsetof(UBFGWidget_SubquestEntry, M_aRewardPositions) == 0x000278, "Member 'UBFGWidget_SubquestEntry::M_aRewardPositions' has a wrong offset!");

// Class BFGCore.BFGWidget_HUD_QuickSlot
// 0x0078 (0x0370 - 0x02F8)
class UBFGWidget_HUD_QuickSlot final : public UBFGWidget_HUD
{
public:
	uint8                                         Pad_2F8[0x8];                                      // 0x02F8(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	class FName                                   M_sMissionName;                                    // 0x0300(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UUserWidget*                            M_pUpWidget;                                       // 0x0308(0x0008)(Edit, BlueprintVisible, ExportObject, ZeroConstructor, DisableEditOnInstance, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UUserWidget*                            M_pRightWidget;                                    // 0x0310(0x0008)(Edit, BlueprintVisible, ExportObject, ZeroConstructor, DisableEditOnInstance, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UUserWidget*                            M_pBottomWidget;                                   // 0x0318(0x0008)(Edit, BlueprintVisible, ExportObject, ZeroConstructor, DisableEditOnInstance, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UUserWidget*                            M_pLeftWidget;                                     // 0x0320(0x0008)(Edit, BlueprintVisible, ExportObject, ZeroConstructor, DisableEditOnInstance, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FBFGInputPattern                       M_InputPatternUP;                                  // 0x0328(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, DisableEditOnInstance, NativeAccessSpecifierPublic)
	struct FBFGInputPattern                       M_InputPatternRight;                               // 0x0338(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, DisableEditOnInstance, NativeAccessSpecifierPublic)
	struct FBFGInputPattern                       M_InputPatternBottom;                              // 0x0348(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, DisableEditOnInstance, NativeAccessSpecifierPublic)
	struct FBFGInputPattern                       M_InputPatternLeft;                                // 0x0358(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, DisableEditOnInstance, NativeAccessSpecifierPublic)
	uint8                                         Pad_368[0x8];                                      // 0x0368(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"BFGWidget_HUD_QuickSlot">();
	}
	static class UBFGWidget_HUD_QuickSlot* GetDefaultObj()
	{
		return GetDefaultObjImpl<UBFGWidget_HUD_QuickSlot>();
	}
};
static_assert(alignof(UBFGWidget_HUD_QuickSlot) == 0x000008, "Wrong alignment on UBFGWidget_HUD_QuickSlot");
static_assert(sizeof(UBFGWidget_HUD_QuickSlot) == 0x000370, "Wrong size on UBFGWidget_HUD_QuickSlot");
static_assert(offsetof(UBFGWidget_HUD_QuickSlot, M_sMissionName) == 0x000300, "Member 'UBFGWidget_HUD_QuickSlot::M_sMissionName' has a wrong offset!");
static_assert(offsetof(UBFGWidget_HUD_QuickSlot, M_pUpWidget) == 0x000308, "Member 'UBFGWidget_HUD_QuickSlot::M_pUpWidget' has a wrong offset!");
static_assert(offsetof(UBFGWidget_HUD_QuickSlot, M_pRightWidget) == 0x000310, "Member 'UBFGWidget_HUD_QuickSlot::M_pRightWidget' has a wrong offset!");
static_assert(offsetof(UBFGWidget_HUD_QuickSlot, M_pBottomWidget) == 0x000318, "Member 'UBFGWidget_HUD_QuickSlot::M_pBottomWidget' has a wrong offset!");
static_assert(offsetof(UBFGWidget_HUD_QuickSlot, M_pLeftWidget) == 0x000320, "Member 'UBFGWidget_HUD_QuickSlot::M_pLeftWidget' has a wrong offset!");
static_assert(offsetof(UBFGWidget_HUD_QuickSlot, M_InputPatternUP) == 0x000328, "Member 'UBFGWidget_HUD_QuickSlot::M_InputPatternUP' has a wrong offset!");
static_assert(offsetof(UBFGWidget_HUD_QuickSlot, M_InputPatternRight) == 0x000338, "Member 'UBFGWidget_HUD_QuickSlot::M_InputPatternRight' has a wrong offset!");
static_assert(offsetof(UBFGWidget_HUD_QuickSlot, M_InputPatternBottom) == 0x000348, "Member 'UBFGWidget_HUD_QuickSlot::M_InputPatternBottom' has a wrong offset!");
static_assert(offsetof(UBFGWidget_HUD_QuickSlot, M_InputPatternLeft) == 0x000358, "Member 'UBFGWidget_HUD_QuickSlot::M_InputPatternLeft' has a wrong offset!");

// Class BFGCore.BFGWidget_HUD_Radar
// 0x0188 (0x0480 - 0x02F8)
class UBFGWidget_HUD_Radar : public UBFGWidget_HUD
{
public:
	uint8                                         Pad_2F8[0x4];                                      // 0x02F8(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         M_fCanvasRadius;                                   // 0x02FC(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         M_fWorldRadius;                                    // 0x0300(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         M_fWorldRadiusUFO;                                 // 0x0304(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_308[0x8];                                      // 0x0308(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<class UImage*>                         M_apImagePool;                                     // 0x0310(0x0010)(ExportObject, ZeroConstructor, Transient, ContainsInstancedReference, Protected, NativeAccessSpecifierProtected)
	TArray<class UMeshWidget*>                    M_aMeshPool;                                       // 0x0320(0x0010)(ExportObject, ZeroConstructor, Transient, ContainsInstancedReference, Protected, NativeAccessSpecifierProtected)
	class UCanvasPanel*                           M_pCanvasPanel;                                    // 0x0330(0x0008)(ExportObject, ZeroConstructor, Transient, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UBFGRadarManager*                       M_pRadarManager;                                   // 0x0338(0x0008)(ExportObject, ZeroConstructor, Transient, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TArray<struct FRadarWidgetPair>               M_apWidgetsInUse;                                  // 0x0340(0x0010)(ZeroConstructor, ContainsInstancedReference, Protected, NativeAccessSpecifierProtected)
	TArray<struct FDeferredElementUpdate>         M_aDeferredCreate;                                 // 0x0350(0x0010)(ZeroConstructor, ContainsInstancedReference, Protected, NativeAccessSpecifierProtected)
	TArray<struct FDeferredMaterialCreate>        M_aDeferredMaterialCreate;                         // 0x0360(0x0010)(ZeroConstructor, Protected, NativeAccessSpecifierProtected)
	TArray<TScriptInterface<class IBFGRadarObjectInterface>> M_aDefferedForceUpdates;                           // 0x0370(0x0010)(ZeroConstructor, Protected, UObjectWrapper, NativeAccessSpecifierProtected)
	struct FWidgetPool                            M_ImagePool;                                       // 0x0380(0x0070)(ContainsInstancedReference, Protected, NativeAccessSpecifierProtected)
	struct FWidgetPool                            M_WidgetMeshPool;                                  // 0x03F0(0x0070)(ContainsInstancedReference, Protected, NativeAccessSpecifierProtected)
	uint8                                         Pad_460[0x20];                                     // 0x0460(0x0020)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	class UCanvasPanel* GetRadarPanel();
	void OnRadarObjectsUpdated(class UBFGRadarManager* _pRadarManager);
	void UpdateOrientation(float _fAngle);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"BFGWidget_HUD_Radar">();
	}
	static class UBFGWidget_HUD_Radar* GetDefaultObj()
	{
		return GetDefaultObjImpl<UBFGWidget_HUD_Radar>();
	}
};
static_assert(alignof(UBFGWidget_HUD_Radar) == 0x000008, "Wrong alignment on UBFGWidget_HUD_Radar");
static_assert(sizeof(UBFGWidget_HUD_Radar) == 0x000480, "Wrong size on UBFGWidget_HUD_Radar");
static_assert(offsetof(UBFGWidget_HUD_Radar, M_fCanvasRadius) == 0x0002FC, "Member 'UBFGWidget_HUD_Radar::M_fCanvasRadius' has a wrong offset!");
static_assert(offsetof(UBFGWidget_HUD_Radar, M_fWorldRadius) == 0x000300, "Member 'UBFGWidget_HUD_Radar::M_fWorldRadius' has a wrong offset!");
static_assert(offsetof(UBFGWidget_HUD_Radar, M_fWorldRadiusUFO) == 0x000304, "Member 'UBFGWidget_HUD_Radar::M_fWorldRadiusUFO' has a wrong offset!");
static_assert(offsetof(UBFGWidget_HUD_Radar, M_apImagePool) == 0x000310, "Member 'UBFGWidget_HUD_Radar::M_apImagePool' has a wrong offset!");
static_assert(offsetof(UBFGWidget_HUD_Radar, M_aMeshPool) == 0x000320, "Member 'UBFGWidget_HUD_Radar::M_aMeshPool' has a wrong offset!");
static_assert(offsetof(UBFGWidget_HUD_Radar, M_pCanvasPanel) == 0x000330, "Member 'UBFGWidget_HUD_Radar::M_pCanvasPanel' has a wrong offset!");
static_assert(offsetof(UBFGWidget_HUD_Radar, M_pRadarManager) == 0x000338, "Member 'UBFGWidget_HUD_Radar::M_pRadarManager' has a wrong offset!");
static_assert(offsetof(UBFGWidget_HUD_Radar, M_apWidgetsInUse) == 0x000340, "Member 'UBFGWidget_HUD_Radar::M_apWidgetsInUse' has a wrong offset!");
static_assert(offsetof(UBFGWidget_HUD_Radar, M_aDeferredCreate) == 0x000350, "Member 'UBFGWidget_HUD_Radar::M_aDeferredCreate' has a wrong offset!");
static_assert(offsetof(UBFGWidget_HUD_Radar, M_aDeferredMaterialCreate) == 0x000360, "Member 'UBFGWidget_HUD_Radar::M_aDeferredMaterialCreate' has a wrong offset!");
static_assert(offsetof(UBFGWidget_HUD_Radar, M_aDefferedForceUpdates) == 0x000370, "Member 'UBFGWidget_HUD_Radar::M_aDefferedForceUpdates' has a wrong offset!");
static_assert(offsetof(UBFGWidget_HUD_Radar, M_ImagePool) == 0x000380, "Member 'UBFGWidget_HUD_Radar::M_ImagePool' has a wrong offset!");
static_assert(offsetof(UBFGWidget_HUD_Radar, M_WidgetMeshPool) == 0x0003F0, "Member 'UBFGWidget_HUD_Radar::M_WidgetMeshPool' has a wrong offset!");

// Class BFGCore.BFGWidget_HUD_TutorialPanel
// 0x0040 (0x0338 - 0x02F8)
class UBFGWidget_HUD_TutorialPanel : public UBFGWidget_HUD
{
public:
	uint8                                         Pad_2F8[0x10];                                     // 0x02F8(0x0010)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         M_fMaxRenderOffsetPerPage;                         // 0x0308(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         M_fMaxTotalRenderOffset;                           // 0x030C(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         M_fMinOpacity;                                     // 0x0310(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         M_iMaxStackCount;                                  // 0x0314(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TArray<class UCanvasPanelSlot*>               M_apSlots;                                         // 0x0318(0x0010)(ExportObject, ZeroConstructor, ContainsInstancedReference, Protected, NativeAccessSpecifierProtected)
	TArray<TWeakObjectPtr<class UBFGWidget_TutorialPage>> M_apTutorialPages;                                 // 0x0328(0x0010)(ExportObject, ZeroConstructor, ContainsInstancedReference, Protected, UObjectWrapper, NativeAccessSpecifierProtected)

public:
	class UCanvasPanelSlot* AddPageToCanvas(class UBFGWidget_TutorialPage* InPage);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"BFGWidget_HUD_TutorialPanel">();
	}
	static class UBFGWidget_HUD_TutorialPanel* GetDefaultObj()
	{
		return GetDefaultObjImpl<UBFGWidget_HUD_TutorialPanel>();
	}
};
static_assert(alignof(UBFGWidget_HUD_TutorialPanel) == 0x000008, "Wrong alignment on UBFGWidget_HUD_TutorialPanel");
static_assert(sizeof(UBFGWidget_HUD_TutorialPanel) == 0x000338, "Wrong size on UBFGWidget_HUD_TutorialPanel");
static_assert(offsetof(UBFGWidget_HUD_TutorialPanel, M_fMaxRenderOffsetPerPage) == 0x000308, "Member 'UBFGWidget_HUD_TutorialPanel::M_fMaxRenderOffsetPerPage' has a wrong offset!");
static_assert(offsetof(UBFGWidget_HUD_TutorialPanel, M_fMaxTotalRenderOffset) == 0x00030C, "Member 'UBFGWidget_HUD_TutorialPanel::M_fMaxTotalRenderOffset' has a wrong offset!");
static_assert(offsetof(UBFGWidget_HUD_TutorialPanel, M_fMinOpacity) == 0x000310, "Member 'UBFGWidget_HUD_TutorialPanel::M_fMinOpacity' has a wrong offset!");
static_assert(offsetof(UBFGWidget_HUD_TutorialPanel, M_iMaxStackCount) == 0x000314, "Member 'UBFGWidget_HUD_TutorialPanel::M_iMaxStackCount' has a wrong offset!");
static_assert(offsetof(UBFGWidget_HUD_TutorialPanel, M_apSlots) == 0x000318, "Member 'UBFGWidget_HUD_TutorialPanel::M_apSlots' has a wrong offset!");
static_assert(offsetof(UBFGWidget_HUD_TutorialPanel, M_apTutorialPages) == 0x000328, "Member 'UBFGWidget_HUD_TutorialPanel::M_apTutorialPages' has a wrong offset!");

// Class BFGCore.BFGUIQuickSlotItem
// 0x00A8 (0x00D0 - 0x0028)
class UBFGUIQuickSlotItem final : public UObject
{
public:
	struct FSlateBrush                            M_oBrush;                                          // 0x0028(0x0088)(BlueprintVisible, BlueprintReadOnly, NativeAccessSpecifierPublic)
	struct FGameplayTag                           M_UnlockTag;                                       // 0x00B0(0x0008)(BlueprintVisible, BlueprintReadOnly, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TSubclassOf<class ABFGWeapon>                 M_pWeaponClass;                                    // 0x00B8(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   M_strInputActionName;                              // 0x00C0(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          M_bIsUnlocked;                                     // 0x00C8(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          M_bIsEquipped;                                     // 0x00C9(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_CA[0x6];                                       // 0x00CA(0x0006)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"BFGUIQuickSlotItem">();
	}
	static class UBFGUIQuickSlotItem* GetDefaultObj()
	{
		return GetDefaultObjImpl<UBFGUIQuickSlotItem>();
	}
};
static_assert(alignof(UBFGUIQuickSlotItem) == 0x000008, "Wrong alignment on UBFGUIQuickSlotItem");
static_assert(sizeof(UBFGUIQuickSlotItem) == 0x0000D0, "Wrong size on UBFGUIQuickSlotItem");
static_assert(offsetof(UBFGUIQuickSlotItem, M_oBrush) == 0x000028, "Member 'UBFGUIQuickSlotItem::M_oBrush' has a wrong offset!");
static_assert(offsetof(UBFGUIQuickSlotItem, M_UnlockTag) == 0x0000B0, "Member 'UBFGUIQuickSlotItem::M_UnlockTag' has a wrong offset!");
static_assert(offsetof(UBFGUIQuickSlotItem, M_pWeaponClass) == 0x0000B8, "Member 'UBFGUIQuickSlotItem::M_pWeaponClass' has a wrong offset!");
static_assert(offsetof(UBFGUIQuickSlotItem, M_strInputActionName) == 0x0000C0, "Member 'UBFGUIQuickSlotItem::M_strInputActionName' has a wrong offset!");
static_assert(offsetof(UBFGUIQuickSlotItem, M_bIsUnlocked) == 0x0000C8, "Member 'UBFGUIQuickSlotItem::M_bIsUnlocked' has a wrong offset!");
static_assert(offsetof(UBFGUIQuickSlotItem, M_bIsEquipped) == 0x0000C9, "Member 'UBFGUIQuickSlotItem::M_bIsEquipped' has a wrong offset!");

// Class BFGCore.BFGGameFlowState_KeyAssignmentWarning
// 0x0010 (0x0118 - 0x0108)
class UBFGGameFlowState_KeyAssignmentWarning final : public UBFGGameFlowState_GenericDialog_Customizable
{
public:
	uint8                                         Pad_108[0x10];                                     // 0x0108(0x0010)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"BFGGameFlowState_KeyAssignmentWarning">();
	}
	static class UBFGGameFlowState_KeyAssignmentWarning* GetDefaultObj()
	{
		return GetDefaultObjImpl<UBFGGameFlowState_KeyAssignmentWarning>();
	}
};
static_assert(alignof(UBFGGameFlowState_KeyAssignmentWarning) == 0x000008, "Wrong alignment on UBFGGameFlowState_KeyAssignmentWarning");
static_assert(sizeof(UBFGGameFlowState_KeyAssignmentWarning) == 0x000118, "Wrong size on UBFGGameFlowState_KeyAssignmentWarning");

// Class BFGCore.BFGWidget_LinearGraph
// 0x0030 (0x0290 - 0x0260)
class UBFGWidget_LinearGraph : public UBFGWidget_DialogOption
{
public:
	TArray<class UBFGWidget_LinearGraphNode*>     M_apNodes;                                         // 0x0260(0x0010)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, ContainsInstancedReference, NativeAccessSpecifierPublic)
	uint8                                         Pad_270[0x20];                                     // 0x0270(0x0020)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void ActionLinearGraphNode__DelegateSignature(class UBFGWidget_LinearGraph* _pGraph, int32 _iNodeIndex);
	void ClearSelection();
	void SetOptionSelected(int32 IIndex);
	void UpdateNodeStatus();
	void UpdateStates();

	bool HasNodes() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"BFGWidget_LinearGraph">();
	}
	static class UBFGWidget_LinearGraph* GetDefaultObj()
	{
		return GetDefaultObjImpl<UBFGWidget_LinearGraph>();
	}
};
static_assert(alignof(UBFGWidget_LinearGraph) == 0x000008, "Wrong alignment on UBFGWidget_LinearGraph");
static_assert(sizeof(UBFGWidget_LinearGraph) == 0x000290, "Wrong size on UBFGWidget_LinearGraph");
static_assert(offsetof(UBFGWidget_LinearGraph, M_apNodes) == 0x000260, "Member 'UBFGWidget_LinearGraph::M_apNodes' has a wrong offset!");

// Class BFGCore.BFGWidget_MissionResults
// 0x0098 (0x04C0 - 0x0428)
class UBFGWidget_MissionResults final : public UBFGWidget_GenericDialog
{
public:
	struct FBFGMissionResultInfo                  M_oInfo;                                           // 0x0428(0x0090)(BlueprintVisible, BlueprintReadOnly, Protected, NativeAccessSpecifierProtected)
	uint8                                         Pad_4B8[0x8];                                      // 0x04B8(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void EnableContinueButton(bool _bEnable);
	void EnableExitButton(bool _bEnable);
	void EnableMinimalMissionResultInfo(bool _bEnable);
	void EnableMissionFailedInfo(bool _bEnable);
	void EnableMissionResultInfo(bool _bEnable);
	void EnableReplayButton(bool _bEnable);
	void OnRewardGained(const class FText& _inTopic, const class FText& _inDescription);
	void OnShowAnimationFinished();
	void SetMissionResultInternal(const struct FBFGMissionResultInfo& _oResultInfo, EBFGMissionResultType _ResultType);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"BFGWidget_MissionResults">();
	}
	static class UBFGWidget_MissionResults* GetDefaultObj()
	{
		return GetDefaultObjImpl<UBFGWidget_MissionResults>();
	}
};
static_assert(alignof(UBFGWidget_MissionResults) == 0x000008, "Wrong alignment on UBFGWidget_MissionResults");
static_assert(sizeof(UBFGWidget_MissionResults) == 0x0004C0, "Wrong size on UBFGWidget_MissionResults");
static_assert(offsetof(UBFGWidget_MissionResults, M_oInfo) == 0x000428, "Member 'UBFGWidget_MissionResults::M_oInfo' has a wrong offset!");

// Class BFGCore.BFGWidget_Mothership_Main
// 0x0090 (0x04B8 - 0x0428)
class UBFGWidget_Mothership_Main final : public UBFGWidget_GenericDialog
{
public:
	bool                                          M_bIsGamePad;                                      // 0x0428(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_429[0x3];                                      // 0x0429(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	int32                                         M_iAmountofDNA;                                    // 0x042C(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	UMulticastDelegateProperty_                   M_OnPostConstruct;                                 // 0x0430(0x0018)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, InstancedReference, NativeAccessSpecifierPublic)
	TMap<class FName, struct FBFGDialogNotificationINode> M_aoArchiveNotificationNodes;                      // 0x0448(0x0050)(ZeroConstructor, Protected, NativeAccessSpecifierProtected)
	class ABFGPlayerState*                        M_pCachedPlayerState;                              // 0x0498(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TArray<class UBFGWidget_Mothership_Submenu*>  M_apSubmenus;                                      // 0x04A0(0x0010)(ExportObject, ZeroConstructor, ContainsInstancedReference, NativeAccessSpecifierPrivate)
	uint8                                         Pad_4B0[0x8];                                      // 0x04B0(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void AddSubmenuToLayout(class UBFGWidget_Mothership_Submenu* _pWidget);
	void EnableButtonAccept(bool _bEnable);
	void EnableButtonBack(bool _bEnable);
	void EnableButtonOption1(bool _bEnable);
	void GatherInformationfromSubMenus();
	void OnButton1Clicked();
	void OnChildNotificationSeen(class FName _oHandlerName);
	void OnCutsceneFinished();
	void OnCutsceneStarted();
	void OnMenuContextChanged(const TArray<struct FBFGTreeMenuContext>& _apMenuContext);
	void OnPostConstruct();
	void OnUpdateDNAAmount();
	void OnUpdateDNAAmountWidget(int32 _fDNA);
	void SetButtonTextAccept(const class FText& _oButtonTextAccept);
	void SetButtonTextBack(const class FText& _oButtonTextBack);
	void SetButtonTextOption1(const class FText& _oButtonTextOption1);
	void SetTitle(const class FText& _oTitle);

	class UBFGWidget_Mothership_Submenu* GetActiveSubmenu() const;
	int32 GetIndexSubmenu(class UBFGWidget_Mothership_Submenu* _pSubmenu) const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"BFGWidget_Mothership_Main">();
	}
	static class UBFGWidget_Mothership_Main* GetDefaultObj()
	{
		return GetDefaultObjImpl<UBFGWidget_Mothership_Main>();
	}
};
static_assert(alignof(UBFGWidget_Mothership_Main) == 0x000008, "Wrong alignment on UBFGWidget_Mothership_Main");
static_assert(sizeof(UBFGWidget_Mothership_Main) == 0x0004B8, "Wrong size on UBFGWidget_Mothership_Main");
static_assert(offsetof(UBFGWidget_Mothership_Main, M_bIsGamePad) == 0x000428, "Member 'UBFGWidget_Mothership_Main::M_bIsGamePad' has a wrong offset!");
static_assert(offsetof(UBFGWidget_Mothership_Main, M_iAmountofDNA) == 0x00042C, "Member 'UBFGWidget_Mothership_Main::M_iAmountofDNA' has a wrong offset!");
static_assert(offsetof(UBFGWidget_Mothership_Main, M_OnPostConstruct) == 0x000430, "Member 'UBFGWidget_Mothership_Main::M_OnPostConstruct' has a wrong offset!");
static_assert(offsetof(UBFGWidget_Mothership_Main, M_aoArchiveNotificationNodes) == 0x000448, "Member 'UBFGWidget_Mothership_Main::M_aoArchiveNotificationNodes' has a wrong offset!");
static_assert(offsetof(UBFGWidget_Mothership_Main, M_pCachedPlayerState) == 0x000498, "Member 'UBFGWidget_Mothership_Main::M_pCachedPlayerState' has a wrong offset!");
static_assert(offsetof(UBFGWidget_Mothership_Main, M_apSubmenus) == 0x0004A0, "Member 'UBFGWidget_Mothership_Main::M_apSubmenus' has a wrong offset!");

// Class BFGCore.BFGWidgetMissionSelectionNode
// 0x0048 (0x0288 - 0x0240)
class UBFGWidgetMissionSelectionNode final : public UUserWidget
{
public:
	uint8                                         Pad_240[0x38];                                     // 0x0240(0x0038)(Fixing Size After Last Property [ Dumper-7 ])
	class FName                                   M_oWorldIdentifier;                                // 0x0278(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UCanvasPanelSlot*                       M_pSlot;                                           // 0x0280(0x0008)(BlueprintVisible, ExportObject, ZeroConstructor, Transient, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)

public:
	struct FVector2D GetPosition();
	void OnClicked();
	void OnDoubleClicked();
	void OnSetHighlighted();
	void OnSetSelected();
	void OnSetUnhighlighted();
	void SetDisabled();
	void SetHighlighted(bool _bHighlighted);
	void SetNewContentAvailable(bool _bNewContentAvailable);
	void SetPosition(const struct FVector2D& _vPos);
	void SetSelected(bool _bSelected);
	void SetSpecial();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"BFGWidgetMissionSelectionNode">();
	}
	static class UBFGWidgetMissionSelectionNode* GetDefaultObj()
	{
		return GetDefaultObjImpl<UBFGWidgetMissionSelectionNode>();
	}
};
static_assert(alignof(UBFGWidgetMissionSelectionNode) == 0x000008, "Wrong alignment on UBFGWidgetMissionSelectionNode");
static_assert(sizeof(UBFGWidgetMissionSelectionNode) == 0x000288, "Wrong size on UBFGWidgetMissionSelectionNode");
static_assert(offsetof(UBFGWidgetMissionSelectionNode, M_oWorldIdentifier) == 0x000278, "Member 'UBFGWidgetMissionSelectionNode::M_oWorldIdentifier' has a wrong offset!");
static_assert(offsetof(UBFGWidgetMissionSelectionNode, M_pSlot) == 0x000280, "Member 'UBFGWidgetMissionSelectionNode::M_pSlot' has a wrong offset!");

// Class BFGCore.BFGWidget_MotherShip_PoxLab
// 0x00C8 (0x0390 - 0x02C8)
class UBFGWidget_MotherShip_PoxLab final : public UBFGWidget_Mothership_Submenu
{
public:
	UMulticastDelegateProperty_                   M_OnUpgradePurchased;                              // 0x02C8(0x0018)(ZeroConstructor, InstancedReference, NativeAccessSpecifierPublic)
	uint8                                         Pad_2E0[0x18];                                     // 0x02E0(0x0018)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<class UBFGDataAssetPoxLabUpgrade*>     M_aUpgradeList;                                    // 0x02F8(0x0010)(ZeroConstructor, NativeAccessSpecifierPublic)
	EBFGMotherShipPoxLabType                      M_eState;                                          // 0x0308(0x0001)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_309[0x3];                                      // 0x0309(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	int32                                         M_iAmountDNA;                                      // 0x030C(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         M_iCurrentIndex;                                   // 0x0310(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_314[0x4];                                      // 0x0314(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class UBFGWidget_PoxLabSubmenu*               M_pSubMenuCrypto;                                  // 0x0318(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UBFGWidget_PoxLabSubmenu*               M_pSubMenuSaucer;                                  // 0x0320(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TSoftClassPtr<class UClass>                   M_pSubMenuClass;                                   // 0x0328(0x0028)(Edit, BlueprintVisible, BlueprintReadOnly, DisableEditOnInstance, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TSoftClassPtr<class UClass>                   M_pSpinningWidgetClass;                            // 0x0350(0x0028)(Edit, BlueprintVisible, BlueprintReadOnly, DisableEditOnInstance, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TArray<struct FBFGUpgradeInfo>                M_aCurrentUpgradeEntries;                          // 0x0378(0x0010)(BlueprintVisible, ZeroConstructor, NativeAccessSpecifierPublic)
	bool                                          M_bInvRotation;                                    // 0x0388(0x0001)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_389[0x7];                                      // 0x0389(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void AddUniqueUpgrade(class UBFGDataAssetPoxLabUpgrade* _pUpgrade);
	void AddUpgrade(class UBFGDataAssetPoxLabUpgrade* _pUpgrade);
	void ComputeDNAAmount(bool _bSuccess);
	void EnableWidget(EBFGMotherShipPoxLabType _eType);
	class UBFGWidgetPoxLabEntryPoint* GetEntryWidget();
	class UBFGWidget_PoxLabSubmenu* GetSubMenu(EBFGMotherShipPoxLabType _eType);
	void InitializeUpgrades(EBFGMotherShipPoxLabType _ePoxLabType, const TArray<class UBFGDataAssetPoxLabUpgrade*>& _apUpgrades, int32 _iDNA);
	void OnEntryPointOptionClicked(EBFGMotherShipPoxLabType _eType);
	void OnNotifyUpgradeStatus(bool _bSuccess);
	void OnUpdateDescriptionPanel(const struct FBFGUpgradeItem& _pUpgrade, bool _bUpgraded, bool _bIsPurchaseAble);
	void OnUpdateDNAAmount(int32 _iAmountDNA);
	void OnUpdateUpgradeWidget();
	void OnUpgradeAvailable(EBFGMotherShipPoxLabType _eType, bool _bUpgradeAvailable);
	void RemoveUpgradeAt(int32 _iIndex);
	void SetState(EBFGMotherShipPoxLabType _eState);
	void UpdateWidgetState(EBFGMotherShipPoxLabType _eState);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"BFGWidget_MotherShip_PoxLab">();
	}
	static class UBFGWidget_MotherShip_PoxLab* GetDefaultObj()
	{
		return GetDefaultObjImpl<UBFGWidget_MotherShip_PoxLab>();
	}
};
static_assert(alignof(UBFGWidget_MotherShip_PoxLab) == 0x000008, "Wrong alignment on UBFGWidget_MotherShip_PoxLab");
static_assert(sizeof(UBFGWidget_MotherShip_PoxLab) == 0x000390, "Wrong size on UBFGWidget_MotherShip_PoxLab");
static_assert(offsetof(UBFGWidget_MotherShip_PoxLab, M_OnUpgradePurchased) == 0x0002C8, "Member 'UBFGWidget_MotherShip_PoxLab::M_OnUpgradePurchased' has a wrong offset!");
static_assert(offsetof(UBFGWidget_MotherShip_PoxLab, M_aUpgradeList) == 0x0002F8, "Member 'UBFGWidget_MotherShip_PoxLab::M_aUpgradeList' has a wrong offset!");
static_assert(offsetof(UBFGWidget_MotherShip_PoxLab, M_eState) == 0x000308, "Member 'UBFGWidget_MotherShip_PoxLab::M_eState' has a wrong offset!");
static_assert(offsetof(UBFGWidget_MotherShip_PoxLab, M_iAmountDNA) == 0x00030C, "Member 'UBFGWidget_MotherShip_PoxLab::M_iAmountDNA' has a wrong offset!");
static_assert(offsetof(UBFGWidget_MotherShip_PoxLab, M_iCurrentIndex) == 0x000310, "Member 'UBFGWidget_MotherShip_PoxLab::M_iCurrentIndex' has a wrong offset!");
static_assert(offsetof(UBFGWidget_MotherShip_PoxLab, M_pSubMenuCrypto) == 0x000318, "Member 'UBFGWidget_MotherShip_PoxLab::M_pSubMenuCrypto' has a wrong offset!");
static_assert(offsetof(UBFGWidget_MotherShip_PoxLab, M_pSubMenuSaucer) == 0x000320, "Member 'UBFGWidget_MotherShip_PoxLab::M_pSubMenuSaucer' has a wrong offset!");
static_assert(offsetof(UBFGWidget_MotherShip_PoxLab, M_pSubMenuClass) == 0x000328, "Member 'UBFGWidget_MotherShip_PoxLab::M_pSubMenuClass' has a wrong offset!");
static_assert(offsetof(UBFGWidget_MotherShip_PoxLab, M_pSpinningWidgetClass) == 0x000350, "Member 'UBFGWidget_MotherShip_PoxLab::M_pSpinningWidgetClass' has a wrong offset!");
static_assert(offsetof(UBFGWidget_MotherShip_PoxLab, M_aCurrentUpgradeEntries) == 0x000378, "Member 'UBFGWidget_MotherShip_PoxLab::M_aCurrentUpgradeEntries' has a wrong offset!");
static_assert(offsetof(UBFGWidget_MotherShip_PoxLab, M_bInvRotation) == 0x000388, "Member 'UBFGWidget_MotherShip_PoxLab::M_bInvRotation' has a wrong offset!");

// Class BFGCore.BFGWidget_MovieSubtitles
// 0x0040 (0x0280 - 0x0240)
class UBFGWidget_MovieSubtitles final : public UUserWidget
{
public:
	TSoftObjectPtr<class UDataTable>              M_pDataTable;                                      // 0x0240(0x0028)(Edit, BlueprintVisible, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_268[0x18];                                     // 0x0268(0x0018)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void ClearSubtitle();
	void SetNewSubtitle(const class FText& _strNewSubtitle);
	void SetTimeMS(int32 _iTime);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"BFGWidget_MovieSubtitles">();
	}
	static class UBFGWidget_MovieSubtitles* GetDefaultObj()
	{
		return GetDefaultObjImpl<UBFGWidget_MovieSubtitles>();
	}
};
static_assert(alignof(UBFGWidget_MovieSubtitles) == 0x000008, "Wrong alignment on UBFGWidget_MovieSubtitles");
static_assert(sizeof(UBFGWidget_MovieSubtitles) == 0x000280, "Wrong size on UBFGWidget_MovieSubtitles");
static_assert(offsetof(UBFGWidget_MovieSubtitles, M_pDataTable) == 0x000240, "Member 'UBFGWidget_MovieSubtitles::M_pDataTable' has a wrong offset!");

// Class BFGCore.BFGWidget_NarrativeSequence
// 0x0028 (0x0450 - 0x0428)
class UBFGWidget_NarrativeSequence final : public UBFGWidget_GenericDialog
{
public:
	uint8                                         Pad_428[0x8];                                      // 0x0428(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	class UCurveLinearColor*                      M_pMoodColorCurve;                                 // 0x0430(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_438[0x18];                                     // 0x0438(0x0018)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void EnableSkipButton(bool _bShow, bool _bAnimate);
	void OnMoodChanged(float _fMood);
	void OnSkip();
	void ShowStrikes(bool _bShow);

	const TArray<class UBFGWidget_DialogOption*> GetOptions() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"BFGWidget_NarrativeSequence">();
	}
	static class UBFGWidget_NarrativeSequence* GetDefaultObj()
	{
		return GetDefaultObjImpl<UBFGWidget_NarrativeSequence>();
	}
};
static_assert(alignof(UBFGWidget_NarrativeSequence) == 0x000008, "Wrong alignment on UBFGWidget_NarrativeSequence");
static_assert(sizeof(UBFGWidget_NarrativeSequence) == 0x000450, "Wrong size on UBFGWidget_NarrativeSequence");
static_assert(offsetof(UBFGWidget_NarrativeSequence, M_pMoodColorCurve) == 0x000430, "Member 'UBFGWidget_NarrativeSequence::M_pMoodColorCurve' has a wrong offset!");

// Class BFGCore.BFGDataAsset_NewspaperInfo
// 0x0180 (0x01B0 - 0x0030)
class UBFGDataAsset_NewspaperInfo final : public UDataAsset
{
public:
	TSoftClassPtr<class UClass>                   M_pNewspaperContentClass;                          // 0x0030(0x0028)(Edit, BlueprintVisible, BlueprintReadOnly, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FText                                   M_oTextTitleSubs;                                  // 0x0058(0x0018)(Edit, BlueprintVisible, BlueprintReadOnly, NativeAccessSpecifierPublic)
	class FText                                   M_oTextSubtitleSubs;                               // 0x0070(0x0018)(Edit, BlueprintVisible, BlueprintReadOnly, NativeAccessSpecifierPublic)
	class FText                                   M_oTextTitle;                                      // 0x0088(0x0018)(Edit, BlueprintVisible, BlueprintReadOnly, NativeAccessSpecifierPublic)
	class FText                                   M_oTextSubtitle;                                   // 0x00A0(0x0018)(Edit, BlueprintVisible, BlueprintReadOnly, NativeAccessSpecifierPublic)
	class FText                                   M_oTextParagraph01;                                // 0x00B8(0x0018)(Edit, BlueprintVisible, BlueprintReadOnly, NativeAccessSpecifierPublic)
	class FText                                   M_oTextParagraph02;                                // 0x00D0(0x0018)(Edit, BlueprintVisible, BlueprintReadOnly, NativeAccessSpecifierPublic)
	class FText                                   M_oTextHeadline01;                                 // 0x00E8(0x0018)(Edit, BlueprintVisible, BlueprintReadOnly, NativeAccessSpecifierPublic)
	class FText                                   M_oTextHeadline02;                                 // 0x0100(0x0018)(Edit, BlueprintVisible, BlueprintReadOnly, NativeAccessSpecifierPublic)
	struct FSlateBrush                            M_oImageFront;                                     // 0x0118(0x0088)(Edit, BlueprintVisible, BlueprintReadOnly, NativeAccessSpecifierPublic)
	TArray<struct FSlateBrush>                    M_oImagesAds;                                      // 0x01A0(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"BFGDataAsset_NewspaperInfo">();
	}
	static class UBFGDataAsset_NewspaperInfo* GetDefaultObj()
	{
		return GetDefaultObjImpl<UBFGDataAsset_NewspaperInfo>();
	}
};
static_assert(alignof(UBFGDataAsset_NewspaperInfo) == 0x000008, "Wrong alignment on UBFGDataAsset_NewspaperInfo");
static_assert(sizeof(UBFGDataAsset_NewspaperInfo) == 0x0001B0, "Wrong size on UBFGDataAsset_NewspaperInfo");
static_assert(offsetof(UBFGDataAsset_NewspaperInfo, M_pNewspaperContentClass) == 0x000030, "Member 'UBFGDataAsset_NewspaperInfo::M_pNewspaperContentClass' has a wrong offset!");
static_assert(offsetof(UBFGDataAsset_NewspaperInfo, M_oTextTitleSubs) == 0x000058, "Member 'UBFGDataAsset_NewspaperInfo::M_oTextTitleSubs' has a wrong offset!");
static_assert(offsetof(UBFGDataAsset_NewspaperInfo, M_oTextSubtitleSubs) == 0x000070, "Member 'UBFGDataAsset_NewspaperInfo::M_oTextSubtitleSubs' has a wrong offset!");
static_assert(offsetof(UBFGDataAsset_NewspaperInfo, M_oTextTitle) == 0x000088, "Member 'UBFGDataAsset_NewspaperInfo::M_oTextTitle' has a wrong offset!");
static_assert(offsetof(UBFGDataAsset_NewspaperInfo, M_oTextSubtitle) == 0x0000A0, "Member 'UBFGDataAsset_NewspaperInfo::M_oTextSubtitle' has a wrong offset!");
static_assert(offsetof(UBFGDataAsset_NewspaperInfo, M_oTextParagraph01) == 0x0000B8, "Member 'UBFGDataAsset_NewspaperInfo::M_oTextParagraph01' has a wrong offset!");
static_assert(offsetof(UBFGDataAsset_NewspaperInfo, M_oTextParagraph02) == 0x0000D0, "Member 'UBFGDataAsset_NewspaperInfo::M_oTextParagraph02' has a wrong offset!");
static_assert(offsetof(UBFGDataAsset_NewspaperInfo, M_oTextHeadline01) == 0x0000E8, "Member 'UBFGDataAsset_NewspaperInfo::M_oTextHeadline01' has a wrong offset!");
static_assert(offsetof(UBFGDataAsset_NewspaperInfo, M_oTextHeadline02) == 0x000100, "Member 'UBFGDataAsset_NewspaperInfo::M_oTextHeadline02' has a wrong offset!");
static_assert(offsetof(UBFGDataAsset_NewspaperInfo, M_oImageFront) == 0x000118, "Member 'UBFGDataAsset_NewspaperInfo::M_oImageFront' has a wrong offset!");
static_assert(offsetof(UBFGDataAsset_NewspaperInfo, M_oImagesAds) == 0x0001A0, "Member 'UBFGDataAsset_NewspaperInfo::M_oImagesAds' has a wrong offset!");

// Class BFGCore.BFGWidget_OverheadPanel
// 0x0010 (0x0250 - 0x0240)
class UBFGWidget_OverheadPanel final : public UUserWidget
{
public:
	uint8                                         Pad_240[0x10];                                     // 0x0240(0x0010)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"BFGWidget_OverheadPanel">();
	}
	static class UBFGWidget_OverheadPanel* GetDefaultObj()
	{
		return GetDefaultObjImpl<UBFGWidget_OverheadPanel>();
	}
};
static_assert(alignof(UBFGWidget_OverheadPanel) == 0x000008, "Wrong alignment on UBFGWidget_OverheadPanel");
static_assert(sizeof(UBFGWidget_OverheadPanel) == 0x000250, "Wrong size on UBFGWidget_OverheadPanel");

// Class BFGCore.BFGWidget_PausedTutorial
// 0x0018 (0x0440 - 0x0428)
class UBFGWidget_PausedTutorial final : public UBFGWidget_GenericDialog
{
public:
	class UBFGDataAsset_PausedTutorial*           M_pAsset;                                          // 0x0428(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_430[0x10];                                     // 0x0430(0x0010)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void OnClickAccept();
	void OnClickSkip();
	void OnStepActive(int32 _iIndex);
	void OnStepFinished();
	void SetSkipEnabled(bool _bEnabled);
	void SetTitle(const class FText& _strTitle);
	void SetupStep(int32 _iIndex, const class FText& _strDescription, const struct FSlateBrush& _oImage);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"BFGWidget_PausedTutorial">();
	}
	static class UBFGWidget_PausedTutorial* GetDefaultObj()
	{
		return GetDefaultObjImpl<UBFGWidget_PausedTutorial>();
	}
};
static_assert(alignof(UBFGWidget_PausedTutorial) == 0x000008, "Wrong alignment on UBFGWidget_PausedTutorial");
static_assert(sizeof(UBFGWidget_PausedTutorial) == 0x000440, "Wrong size on UBFGWidget_PausedTutorial");
static_assert(offsetof(UBFGWidget_PausedTutorial, M_pAsset) == 0x000428, "Member 'UBFGWidget_PausedTutorial::M_pAsset' has a wrong offset!");

// Class BFGCore.BFGWidget_PoxLab_UpgradeGraph
// 0x0090 (0x0320 - 0x0290)
class UBFGWidget_PoxLab_UpgradeGraph final : public UBFGWidget_LinearGraph
{
public:
	TSoftClassPtr<class UClass>                   M_pUpgradeNodeGraphClass;                          // 0x0290(0x0028)(Edit, BlueprintVisible, BlueprintReadOnly, DisableEditOnInstance, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	UMulticastDelegateProperty_                   M_OnUpgradeItemChanged;                            // 0x02B8(0x0018)(ZeroConstructor, InstancedReference, NativeAccessSpecifierPublic)
	UMulticastDelegateProperty_                   M_OnUpgradeItemPurchased;                          // 0x02D0(0x0018)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	UMulticastDelegateProperty_                   M_OnUpgradeItemNoDNA;                              // 0x02E8(0x0018)(ZeroConstructor, InstancedReference, NativeAccessSpecifierPublic)
	UMulticastDelegateProperty_                   M_OnRegister;                                      // 0x0300(0x0018)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	uint8                                         Pad_318[0x8];                                      // 0x0318(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void EnableBar(int32 _iIndex, bool _bEnable);
	class UHorizontalBox* GetHorizontalBox();
	void InitializeGraph(struct FBFGPlayerState_UpgradesQueryResponse* _rGraphEntries, int32 _iUpgradeIndex);
	void OnConfimationPromptClosed(bool _bResult);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"BFGWidget_PoxLab_UpgradeGraph">();
	}
	static class UBFGWidget_PoxLab_UpgradeGraph* GetDefaultObj()
	{
		return GetDefaultObjImpl<UBFGWidget_PoxLab_UpgradeGraph>();
	}
};
static_assert(alignof(UBFGWidget_PoxLab_UpgradeGraph) == 0x000008, "Wrong alignment on UBFGWidget_PoxLab_UpgradeGraph");
static_assert(sizeof(UBFGWidget_PoxLab_UpgradeGraph) == 0x000320, "Wrong size on UBFGWidget_PoxLab_UpgradeGraph");
static_assert(offsetof(UBFGWidget_PoxLab_UpgradeGraph, M_pUpgradeNodeGraphClass) == 0x000290, "Member 'UBFGWidget_PoxLab_UpgradeGraph::M_pUpgradeNodeGraphClass' has a wrong offset!");
static_assert(offsetof(UBFGWidget_PoxLab_UpgradeGraph, M_OnUpgradeItemChanged) == 0x0002B8, "Member 'UBFGWidget_PoxLab_UpgradeGraph::M_OnUpgradeItemChanged' has a wrong offset!");
static_assert(offsetof(UBFGWidget_PoxLab_UpgradeGraph, M_OnUpgradeItemPurchased) == 0x0002D0, "Member 'UBFGWidget_PoxLab_UpgradeGraph::M_OnUpgradeItemPurchased' has a wrong offset!");
static_assert(offsetof(UBFGWidget_PoxLab_UpgradeGraph, M_OnUpgradeItemNoDNA) == 0x0002E8, "Member 'UBFGWidget_PoxLab_UpgradeGraph::M_OnUpgradeItemNoDNA' has a wrong offset!");
static_assert(offsetof(UBFGWidget_PoxLab_UpgradeGraph, M_OnRegister) == 0x000300, "Member 'UBFGWidget_PoxLab_UpgradeGraph::M_OnRegister' has a wrong offset!");

// Class BFGCore.BFGWidget_PoxLabSubmenu
// 0x0090 (0x04B8 - 0x0428)
class UBFGWidget_PoxLabSubmenu final : public UBFGWidget_GenericDialog
{
public:
	class UBFGSpinningWidget*                     M_pSpinningWidget;                                 // 0x0428(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, Transient, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UBFGWidget_PoxLab_UpgradeGraph*         M_pUpgradeGraphUp;                                 // 0x0430(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, Transient, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UBFGWidget_PoxLab_UpgradeGraph*         M_pUpgradeGraphDown;                               // 0x0438(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, Transient, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TArray<class UBFGDataAssetPoxLabUpgrade*>     M_aUpgradeList;                                    // 0x0440(0x0010)(ZeroConstructor, NativeAccessSpecifierPublic)
	TSoftClassPtr<class UClass>                   M_pSpinningWidgetOptionClass;                      // 0x0450(0x0028)(Edit, BlueprintVisible, BlueprintReadOnly, DisableEditOnInstance, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EBFGMotherShipPoxLabType                      M_eState;                                          // 0x0478(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_479[0x7];                                      // 0x0479(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	UMulticastDelegateProperty_                   M_OnUpgradeAvailable;                              // 0x0480(0x0018)(ZeroConstructor, InstancedReference, NativeAccessSpecifierPublic)
	EBFGSelectionStatePoxLab                      M_eSelectionState;                                 // 0x0498(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          M_bIsGamePad;                                      // 0x0499(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_49A[0x6];                                      // 0x049A(0x0006)(Fixing Size After Last Property [ Dumper-7 ])
	class FText                                   M_strName;                                         // 0x04A0(0x0018)(Edit, BlueprintVisible, BlueprintReadOnly, NativeAccessSpecifierPublic)

public:
	void ActionPoxUpgradeNotify__DelegateSignature(EBFGMotherShipPoxLabType _eType, bool _bValue);
	class UBFGWidget_PoxLab_UpgradeGraph* GetLinearGraph(EBFGPoxLabSubmenu _ePanel);
	class UBFGSpinningWidget* GetSpinningWidget();
	void OnShowItemDescription(EBFGSelectionStatePoxLab _eSelectionState);
	void OnUpdateSubMenu(EBFGSelectionStatePoxLab _eNewState);
	void OnUpdateUpgradeDescriptionPanel(const class FText& _strUpgradeName, const class FText& _strUpgradeDescription, int32 _iUpgradeCost);
	void UpdateDescriptionPanel(int32 _iIndex);
	void UpdateSelectionState();
	void UpdateSpinningWidget(float _fValueX, float _fValueY);
	void UpdateUpgradeItemPanel(class UBFGDataAssetPoxLabUpgrade* _pUpgradeItem);
	void UpdateUpgradeNoDNA();

	int32 GetCurrentDNA() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"BFGWidget_PoxLabSubmenu">();
	}
	static class UBFGWidget_PoxLabSubmenu* GetDefaultObj()
	{
		return GetDefaultObjImpl<UBFGWidget_PoxLabSubmenu>();
	}
};
static_assert(alignof(UBFGWidget_PoxLabSubmenu) == 0x000008, "Wrong alignment on UBFGWidget_PoxLabSubmenu");
static_assert(sizeof(UBFGWidget_PoxLabSubmenu) == 0x0004B8, "Wrong size on UBFGWidget_PoxLabSubmenu");
static_assert(offsetof(UBFGWidget_PoxLabSubmenu, M_pSpinningWidget) == 0x000428, "Member 'UBFGWidget_PoxLabSubmenu::M_pSpinningWidget' has a wrong offset!");
static_assert(offsetof(UBFGWidget_PoxLabSubmenu, M_pUpgradeGraphUp) == 0x000430, "Member 'UBFGWidget_PoxLabSubmenu::M_pUpgradeGraphUp' has a wrong offset!");
static_assert(offsetof(UBFGWidget_PoxLabSubmenu, M_pUpgradeGraphDown) == 0x000438, "Member 'UBFGWidget_PoxLabSubmenu::M_pUpgradeGraphDown' has a wrong offset!");
static_assert(offsetof(UBFGWidget_PoxLabSubmenu, M_aUpgradeList) == 0x000440, "Member 'UBFGWidget_PoxLabSubmenu::M_aUpgradeList' has a wrong offset!");
static_assert(offsetof(UBFGWidget_PoxLabSubmenu, M_pSpinningWidgetOptionClass) == 0x000450, "Member 'UBFGWidget_PoxLabSubmenu::M_pSpinningWidgetOptionClass' has a wrong offset!");
static_assert(offsetof(UBFGWidget_PoxLabSubmenu, M_eState) == 0x000478, "Member 'UBFGWidget_PoxLabSubmenu::M_eState' has a wrong offset!");
static_assert(offsetof(UBFGWidget_PoxLabSubmenu, M_OnUpgradeAvailable) == 0x000480, "Member 'UBFGWidget_PoxLabSubmenu::M_OnUpgradeAvailable' has a wrong offset!");
static_assert(offsetof(UBFGWidget_PoxLabSubmenu, M_eSelectionState) == 0x000498, "Member 'UBFGWidget_PoxLabSubmenu::M_eSelectionState' has a wrong offset!");
static_assert(offsetof(UBFGWidget_PoxLabSubmenu, M_bIsGamePad) == 0x000499, "Member 'UBFGWidget_PoxLabSubmenu::M_bIsGamePad' has a wrong offset!");
static_assert(offsetof(UBFGWidget_PoxLabSubmenu, M_strName) == 0x0004A0, "Member 'UBFGWidget_PoxLabSubmenu::M_strName' has a wrong offset!");

// Class BFGCore.BFGWidget_Tutorial_CustomInputHint
// 0x0000 (0x0240 - 0x0240)
class UBFGWidget_Tutorial_CustomInputHint final : public UUserWidget
{
public:
	void SwitchToGamepad();
	void SwitchToKBM();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"BFGWidget_Tutorial_CustomInputHint">();
	}
	static class UBFGWidget_Tutorial_CustomInputHint* GetDefaultObj()
	{
		return GetDefaultObjImpl<UBFGWidget_Tutorial_CustomInputHint>();
	}
};
static_assert(alignof(UBFGWidget_Tutorial_CustomInputHint) == 0x000008, "Wrong alignment on UBFGWidget_Tutorial_CustomInputHint");
static_assert(sizeof(UBFGWidget_Tutorial_CustomInputHint) == 0x000240, "Wrong size on UBFGWidget_Tutorial_CustomInputHint");

// Class BFGCore.BFGWidget_TutorialHandbookChapter
// 0x0010 (0x0250 - 0x0240)
class UBFGWidget_TutorialHandbookChapter final : public UUserWidget
{
public:
	class UBFGDataAsset_TutorialChapter*          M_pDataChapter;                                    // 0x0240(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_248[0x8];                                      // 0x0248(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void AddOptionToOptionsList(class UBFGWidget_TutorialHandbookEntry* _pOption);
	void ClearOptionsList();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"BFGWidget_TutorialHandbookChapter">();
	}
	static class UBFGWidget_TutorialHandbookChapter* GetDefaultObj()
	{
		return GetDefaultObjImpl<UBFGWidget_TutorialHandbookChapter>();
	}
};
static_assert(alignof(UBFGWidget_TutorialHandbookChapter) == 0x000008, "Wrong alignment on UBFGWidget_TutorialHandbookChapter");
static_assert(sizeof(UBFGWidget_TutorialHandbookChapter) == 0x000250, "Wrong size on UBFGWidget_TutorialHandbookChapter");
static_assert(offsetof(UBFGWidget_TutorialHandbookChapter, M_pDataChapter) == 0x000240, "Member 'UBFGWidget_TutorialHandbookChapter::M_pDataChapter' has a wrong offset!");

// Class BFGCore.BFGInputHintBlock
// 0x0078 (0x02B8 - 0x0240)
class UBFGInputHintBlock : public UBFGLabeledImage
{
public:
	TMap<int32, struct FInputHintBlockGridMapping> M_aHintGridMapping;                                // 0x0240(0x0050)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, NativeAccessSpecifierPublic)
	float                                         M_fSingleHintHeightOverride;                       // 0x0290(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_294[0x4];                                      // 0x0294(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<class UImage*>                         M_apImages;                                        // 0x0298(0x0010)(ExportObject, ZeroConstructor, ContainsInstancedReference, NativeAccessSpecifierPublic)
	class UBFGDataAsset_TutorialInputAction*      M_pInputAction;                                    // 0x02A8(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          M_bIsGamePad;                                      // 0x02B0(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2B1[0x7];                                      // 0x02B1(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	class UGridSlot* AddImageToGrid(class UImage* _pImage);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"BFGInputHintBlock">();
	}
	static class UBFGInputHintBlock* GetDefaultObj()
	{
		return GetDefaultObjImpl<UBFGInputHintBlock>();
	}
};
static_assert(alignof(UBFGInputHintBlock) == 0x000008, "Wrong alignment on UBFGInputHintBlock");
static_assert(sizeof(UBFGInputHintBlock) == 0x0002B8, "Wrong size on UBFGInputHintBlock");
static_assert(offsetof(UBFGInputHintBlock, M_aHintGridMapping) == 0x000240, "Member 'UBFGInputHintBlock::M_aHintGridMapping' has a wrong offset!");
static_assert(offsetof(UBFGInputHintBlock, M_fSingleHintHeightOverride) == 0x000290, "Member 'UBFGInputHintBlock::M_fSingleHintHeightOverride' has a wrong offset!");
static_assert(offsetof(UBFGInputHintBlock, M_apImages) == 0x000298, "Member 'UBFGInputHintBlock::M_apImages' has a wrong offset!");
static_assert(offsetof(UBFGInputHintBlock, M_pInputAction) == 0x0002A8, "Member 'UBFGInputHintBlock::M_pInputAction' has a wrong offset!");
static_assert(offsetof(UBFGInputHintBlock, M_bIsGamePad) == 0x0002B0, "Member 'UBFGInputHintBlock::M_bIsGamePad' has a wrong offset!");

// Class BFGCore.BFGLabeledImage_InputAction
// 0x0010 (0x0250 - 0x0240)
class UBFGLabeledImage_InputAction : public UBFGLabeledImage
{
public:
	class UBFGDataAsset_TutorialInputAction*      M_pInputAction;                                    // 0x0240(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          M_bIsGamePad;                                      // 0x0248(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_249[0x7];                                      // 0x0249(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void SetType(EBFGInputActionWidgetType _eType);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"BFGLabeledImage_InputAction">();
	}
	static class UBFGLabeledImage_InputAction* GetDefaultObj()
	{
		return GetDefaultObjImpl<UBFGLabeledImage_InputAction>();
	}
};
static_assert(alignof(UBFGLabeledImage_InputAction) == 0x000008, "Wrong alignment on UBFGLabeledImage_InputAction");
static_assert(sizeof(UBFGLabeledImage_InputAction) == 0x000250, "Wrong size on UBFGLabeledImage_InputAction");
static_assert(offsetof(UBFGLabeledImage_InputAction, M_pInputAction) == 0x000240, "Member 'UBFGLabeledImage_InputAction::M_pInputAction' has a wrong offset!");
static_assert(offsetof(UBFGLabeledImage_InputAction, M_bIsGamePad) == 0x000248, "Member 'UBFGLabeledImage_InputAction::M_bIsGamePad' has a wrong offset!");

// Class BFGCore.BFGWidget_UserSignedOut
// 0x0020 (0x0448 - 0x0428)
class UBFGWidget_UserSignedOut final : public UBFGWidget_GenericDialog
{
public:
	uint8                                         Pad_428[0x8];                                      // 0x0428(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	class UBFGUserSignInManager*                  M_pManager;                                        // 0x0430(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TSubclassOf<class UBFGInputAction_UI>         M_pInputActionSwitchProfile;                       // 0x0438(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TSubclassOf<class UBFGInputAction_UI>         M_pInputActionBackToMainMenu;                      // 0x0440(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)

public:
	void OnApplicationPostInputKeyDownEvent(const struct FKeyEvent& _keyEvent);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"BFGWidget_UserSignedOut">();
	}
	static class UBFGWidget_UserSignedOut* GetDefaultObj()
	{
		return GetDefaultObjImpl<UBFGWidget_UserSignedOut>();
	}
};
static_assert(alignof(UBFGWidget_UserSignedOut) == 0x000008, "Wrong alignment on UBFGWidget_UserSignedOut");
static_assert(sizeof(UBFGWidget_UserSignedOut) == 0x000448, "Wrong size on UBFGWidget_UserSignedOut");
static_assert(offsetof(UBFGWidget_UserSignedOut, M_pManager) == 0x000430, "Member 'UBFGWidget_UserSignedOut::M_pManager' has a wrong offset!");
static_assert(offsetof(UBFGWidget_UserSignedOut, M_pInputActionSwitchProfile) == 0x000438, "Member 'UBFGWidget_UserSignedOut::M_pInputActionSwitchProfile' has a wrong offset!");
static_assert(offsetof(UBFGWidget_UserSignedOut, M_pInputActionBackToMainMenu) == 0x000440, "Member 'UBFGWidget_UserSignedOut::M_pInputActionBackToMainMenu' has a wrong offset!");

// Class BFGCore.BFGWidgetAnimationState
// 0x0038 (0x0060 - 0x0028)
class UBFGWidgetAnimationState final : public UObject
{
public:
	float                                         M_fTransitionTimer;                                // 0x0028(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EBFGWidgetAnimationSubState                   M_eCurrentSubState;                                // 0x002C(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2D[0x3];                                       // 0x002D(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	UMulticastDelegateProperty_                   M_OnTransitionFinished;                            // 0x0030(0x0018)(Edit, ZeroConstructor, DisableEditOnInstance, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	UMulticastDelegateProperty_                   M_OnTransitionBegin;                               // 0x0048(0x0018)(Edit, ZeroConstructor, DisableEditOnInstance, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)

public:
	void ActionSubState__DelegateSignature(class UBFGWidgetAnimationState* _pTargetState, EBFGWidgetAnimationSubState _eSubState);
	void RequestSubState(EBFGWidgetAnimationSubState _eTargetSubState, bool _bForce);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"BFGWidgetAnimationState">();
	}
	static class UBFGWidgetAnimationState* GetDefaultObj()
	{
		return GetDefaultObjImpl<UBFGWidgetAnimationState>();
	}
};
static_assert(alignof(UBFGWidgetAnimationState) == 0x000008, "Wrong alignment on UBFGWidgetAnimationState");
static_assert(sizeof(UBFGWidgetAnimationState) == 0x000060, "Wrong size on UBFGWidgetAnimationState");
static_assert(offsetof(UBFGWidgetAnimationState, M_fTransitionTimer) == 0x000028, "Member 'UBFGWidgetAnimationState::M_fTransitionTimer' has a wrong offset!");
static_assert(offsetof(UBFGWidgetAnimationState, M_eCurrentSubState) == 0x00002C, "Member 'UBFGWidgetAnimationState::M_eCurrentSubState' has a wrong offset!");
static_assert(offsetof(UBFGWidgetAnimationState, M_OnTransitionFinished) == 0x000030, "Member 'UBFGWidgetAnimationState::M_OnTransitionFinished' has a wrong offset!");
static_assert(offsetof(UBFGWidgetAnimationState, M_OnTransitionBegin) == 0x000048, "Member 'UBFGWidgetAnimationState::M_OnTransitionBegin' has a wrong offset!");

// Class BFGCore.BFGWidgetPoolManager
// 0x0018 (0x0048 - 0x0030)
class UBFGWidgetPoolManager final : public UBFGGameSystem
{
public:
	TWeakObjectPtr<class ABFGGameState>           M_pGameState;                                      // 0x0030(0x0008)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TArray<struct FBFGUserWidgetPool>             M_aPools;                                          // 0x0038(0x0010)(ZeroConstructor, ContainsInstancedReference, Protected, NativeAccessSpecifierProtected)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"BFGWidgetPoolManager">();
	}
	static class UBFGWidgetPoolManager* GetDefaultObj()
	{
		return GetDefaultObjImpl<UBFGWidgetPoolManager>();
	}
};
static_assert(alignof(UBFGWidgetPoolManager) == 0x000008, "Wrong alignment on UBFGWidgetPoolManager");
static_assert(sizeof(UBFGWidgetPoolManager) == 0x000048, "Wrong size on UBFGWidgetPoolManager");
static_assert(offsetof(UBFGWidgetPoolManager, M_pGameState) == 0x000030, "Member 'UBFGWidgetPoolManager::M_pGameState' has a wrong offset!");
static_assert(offsetof(UBFGWidgetPoolManager, M_aPools) == 0x000038, "Member 'UBFGWidgetPoolManager::M_aPools' has a wrong offset!");

// Class BFGCore.BGFBoss_Marker_Location
// 0x0008 (0x03E0 - 0x03D8)
class ABGFBoss_Marker_Location final : public AActor
{
public:
	int32                                         M_iPhaseRelated;                                   // 0x03D8(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EBossMarkerType                               M_eMarkerType;                                     // 0x03DC(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_3DD[0x3];                                      // 0x03DD(0x0003)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"BGFBoss_Marker_Location">();
	}
	static class ABGFBoss_Marker_Location* GetDefaultObj()
	{
		return GetDefaultObjImpl<ABGFBoss_Marker_Location>();
	}
};
static_assert(alignof(ABGFBoss_Marker_Location) == 0x000008, "Wrong alignment on ABGFBoss_Marker_Location");
static_assert(sizeof(ABGFBoss_Marker_Location) == 0x0003E0, "Wrong size on ABGFBoss_Marker_Location");
static_assert(offsetof(ABGFBoss_Marker_Location, M_iPhaseRelated) == 0x0003D8, "Member 'ABGFBoss_Marker_Location::M_iPhaseRelated' has a wrong offset!");
static_assert(offsetof(ABGFBoss_Marker_Location, M_eMarkerType) == 0x0003DC, "Member 'ABGFBoss_Marker_Location::M_eMarkerType' has a wrong offset!");

// Class BFGCore.BFGBuoyancyForceComponent
// 0x00C8 (0x01F0 - 0x0128)
class UBFGBuoyancyForceComponent final : public UActorComponent
{
public:
	float                                         MeshDensity;                                       // 0x0128(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         FluidDensity;                                      // 0x012C(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         FluidLinearDamping;                                // 0x0130(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         FluidAngularDamping;                               // 0x0134(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                VelocityDamper;                                    // 0x0138(0x000C)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, AdvancedDisplay, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          ClampMaxVelocity;                                  // 0x0144(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_145[0x3];                                      // 0x0145(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         MaxUnderwaterVelocity;                             // 0x0148(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         TestPointRadius;                                   // 0x014C(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TArray<struct FVector>                        TestPoints;                                        // 0x0150(0x0010)(Edit, BlueprintVisible, ZeroConstructor, NativeAccessSpecifierPublic)
	bool                                          ApplyForceToBones;                                 // 0x0160(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          SnapToSurfaceIfNoPhysics;                          // 0x0161(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          TwoGerstnerIterations;                             // 0x0162(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_163[0x5];                                      // 0x0163(0x0005)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<float>                                 PointDensityOverride;                              // 0x0168(0x0010)(Edit, BlueprintVisible, ZeroConstructor, AdvancedDisplay, NativeAccessSpecifierPublic)
	TArray<struct FBFGBuoyancyBoneOverride>       BoneOverride;                                      // 0x0178(0x0010)(Edit, BlueprintVisible, ZeroConstructor, AdvancedDisplay, NativeAccessSpecifierPublic)
	bool                                          DrawDebugPoints;                                   // 0x0188(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, AdvancedDisplay, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          EnableStayUprightConstraint;                       // 0x0189(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, AdvancedDisplay, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_18A[0x2];                                      // 0x018A(0x0002)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         StayUprightStiffness;                              // 0x018C(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, AdvancedDisplay, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         StayUprightDamping;                                // 0x0190(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, AdvancedDisplay, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FRotator                               StayUprightDesiredRotation;                        // 0x0194(0x000C)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, AdvancedDisplay, NativeAccessSpecifierPublic)
	bool                                          EnableWaveForces;                                  // 0x01A0(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, AdvancedDisplay, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1A1[0x3];                                      // 0x01A1(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         WaveForceMultiplier;                               // 0x01A4(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, AdvancedDisplay, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	ETickingGroup                                 TickGroup;                                         // 0x01A8(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, AdvancedDisplay, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          M_bOnlyUpdateWhenPhysicsEnabled;                   // 0x01A9(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1AA[0x2];                                      // 0x01AA(0x0002)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         M_fWaterTickFrequency;                             // 0x01AC(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         M_fWaterTickDamage;                                // 0x01B0(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         M_fWaterSplashVelocityTreshhold;                   // 0x01B4(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1B8[0x8];                                      // 0x01B8(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	class UBFGOceanManager*                       OceanManager;                                      // 0x01C0(0x0008)(ExportObject, ZeroConstructor, Transient, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_1C8[0x10];                                     // 0x01C8(0x0010)(Fixing Size After Last Property [ Dumper-7 ])
	class UBFGActorComponent_PawnStats*           M_pPawnStats;                                      // 0x01D8(0x0008)(ExportObject, ZeroConstructor, Transient, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UBFGActorComponent_Effect*              M_pEffects;                                        // 0x01E0(0x0008)(ExportObject, ZeroConstructor, Transient, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class USceneComponent*                        M_pAttachParent;                                   // 0x01E8(0x0008)(ExportObject, ZeroConstructor, Transient, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)

public:
	void CreateTestPointsFromCollisionMesh();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"BFGBuoyancyForceComponent">();
	}
	static class UBFGBuoyancyForceComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UBFGBuoyancyForceComponent>();
	}
};
static_assert(alignof(UBFGBuoyancyForceComponent) == 0x000008, "Wrong alignment on UBFGBuoyancyForceComponent");
static_assert(sizeof(UBFGBuoyancyForceComponent) == 0x0001F0, "Wrong size on UBFGBuoyancyForceComponent");
static_assert(offsetof(UBFGBuoyancyForceComponent, MeshDensity) == 0x000128, "Member 'UBFGBuoyancyForceComponent::MeshDensity' has a wrong offset!");
static_assert(offsetof(UBFGBuoyancyForceComponent, FluidDensity) == 0x00012C, "Member 'UBFGBuoyancyForceComponent::FluidDensity' has a wrong offset!");
static_assert(offsetof(UBFGBuoyancyForceComponent, FluidLinearDamping) == 0x000130, "Member 'UBFGBuoyancyForceComponent::FluidLinearDamping' has a wrong offset!");
static_assert(offsetof(UBFGBuoyancyForceComponent, FluidAngularDamping) == 0x000134, "Member 'UBFGBuoyancyForceComponent::FluidAngularDamping' has a wrong offset!");
static_assert(offsetof(UBFGBuoyancyForceComponent, VelocityDamper) == 0x000138, "Member 'UBFGBuoyancyForceComponent::VelocityDamper' has a wrong offset!");
static_assert(offsetof(UBFGBuoyancyForceComponent, ClampMaxVelocity) == 0x000144, "Member 'UBFGBuoyancyForceComponent::ClampMaxVelocity' has a wrong offset!");
static_assert(offsetof(UBFGBuoyancyForceComponent, MaxUnderwaterVelocity) == 0x000148, "Member 'UBFGBuoyancyForceComponent::MaxUnderwaterVelocity' has a wrong offset!");
static_assert(offsetof(UBFGBuoyancyForceComponent, TestPointRadius) == 0x00014C, "Member 'UBFGBuoyancyForceComponent::TestPointRadius' has a wrong offset!");
static_assert(offsetof(UBFGBuoyancyForceComponent, TestPoints) == 0x000150, "Member 'UBFGBuoyancyForceComponent::TestPoints' has a wrong offset!");
static_assert(offsetof(UBFGBuoyancyForceComponent, ApplyForceToBones) == 0x000160, "Member 'UBFGBuoyancyForceComponent::ApplyForceToBones' has a wrong offset!");
static_assert(offsetof(UBFGBuoyancyForceComponent, SnapToSurfaceIfNoPhysics) == 0x000161, "Member 'UBFGBuoyancyForceComponent::SnapToSurfaceIfNoPhysics' has a wrong offset!");
static_assert(offsetof(UBFGBuoyancyForceComponent, TwoGerstnerIterations) == 0x000162, "Member 'UBFGBuoyancyForceComponent::TwoGerstnerIterations' has a wrong offset!");
static_assert(offsetof(UBFGBuoyancyForceComponent, PointDensityOverride) == 0x000168, "Member 'UBFGBuoyancyForceComponent::PointDensityOverride' has a wrong offset!");
static_assert(offsetof(UBFGBuoyancyForceComponent, BoneOverride) == 0x000178, "Member 'UBFGBuoyancyForceComponent::BoneOverride' has a wrong offset!");
static_assert(offsetof(UBFGBuoyancyForceComponent, DrawDebugPoints) == 0x000188, "Member 'UBFGBuoyancyForceComponent::DrawDebugPoints' has a wrong offset!");
static_assert(offsetof(UBFGBuoyancyForceComponent, EnableStayUprightConstraint) == 0x000189, "Member 'UBFGBuoyancyForceComponent::EnableStayUprightConstraint' has a wrong offset!");
static_assert(offsetof(UBFGBuoyancyForceComponent, StayUprightStiffness) == 0x00018C, "Member 'UBFGBuoyancyForceComponent::StayUprightStiffness' has a wrong offset!");
static_assert(offsetof(UBFGBuoyancyForceComponent, StayUprightDamping) == 0x000190, "Member 'UBFGBuoyancyForceComponent::StayUprightDamping' has a wrong offset!");
static_assert(offsetof(UBFGBuoyancyForceComponent, StayUprightDesiredRotation) == 0x000194, "Member 'UBFGBuoyancyForceComponent::StayUprightDesiredRotation' has a wrong offset!");
static_assert(offsetof(UBFGBuoyancyForceComponent, EnableWaveForces) == 0x0001A0, "Member 'UBFGBuoyancyForceComponent::EnableWaveForces' has a wrong offset!");
static_assert(offsetof(UBFGBuoyancyForceComponent, WaveForceMultiplier) == 0x0001A4, "Member 'UBFGBuoyancyForceComponent::WaveForceMultiplier' has a wrong offset!");
static_assert(offsetof(UBFGBuoyancyForceComponent, TickGroup) == 0x0001A8, "Member 'UBFGBuoyancyForceComponent::TickGroup' has a wrong offset!");
static_assert(offsetof(UBFGBuoyancyForceComponent, M_bOnlyUpdateWhenPhysicsEnabled) == 0x0001A9, "Member 'UBFGBuoyancyForceComponent::M_bOnlyUpdateWhenPhysicsEnabled' has a wrong offset!");
static_assert(offsetof(UBFGBuoyancyForceComponent, M_fWaterTickFrequency) == 0x0001AC, "Member 'UBFGBuoyancyForceComponent::M_fWaterTickFrequency' has a wrong offset!");
static_assert(offsetof(UBFGBuoyancyForceComponent, M_fWaterTickDamage) == 0x0001B0, "Member 'UBFGBuoyancyForceComponent::M_fWaterTickDamage' has a wrong offset!");
static_assert(offsetof(UBFGBuoyancyForceComponent, M_fWaterSplashVelocityTreshhold) == 0x0001B4, "Member 'UBFGBuoyancyForceComponent::M_fWaterSplashVelocityTreshhold' has a wrong offset!");
static_assert(offsetof(UBFGBuoyancyForceComponent, OceanManager) == 0x0001C0, "Member 'UBFGBuoyancyForceComponent::OceanManager' has a wrong offset!");
static_assert(offsetof(UBFGBuoyancyForceComponent, M_pPawnStats) == 0x0001D8, "Member 'UBFGBuoyancyForceComponent::M_pPawnStats' has a wrong offset!");
static_assert(offsetof(UBFGBuoyancyForceComponent, M_pEffects) == 0x0001E0, "Member 'UBFGBuoyancyForceComponent::M_pEffects' has a wrong offset!");
static_assert(offsetof(UBFGBuoyancyForceComponent, M_pAttachParent) == 0x0001E8, "Member 'UBFGBuoyancyForceComponent::M_pAttachParent' has a wrong offset!");

// Class BFGCore.BFGContextualAction
// 0x0000 (0x0028 - 0x0028)
class IBFGContextualAction final : public IInterface
{
public:
	class AActor* GetActor();
	bool IsActionEnabled();
	bool IsFocusable();
	void OnFocused(class AController* _pUser);
	void OnLostFocus();
	void OnUsed(class AController* _pUser);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"BFGContextualAction">();
	}
	static class IBFGContextualAction* GetDefaultObj()
	{
		return GetDefaultObjImpl<IBFGContextualAction>();
	}
};
static_assert(alignof(IBFGContextualAction) == 0x000008, "Wrong alignment on IBFGContextualAction");
static_assert(sizeof(IBFGContextualAction) == 0x000028, "Wrong size on IBFGContextualAction");

// Class BFGCore.BFGDataProvider
// 0x0000 (0x0028 - 0x0028)
class IBFGDataProvider final : public IInterface
{
public:
	void GetArrayEnumasInt(TArray<int32>* _results, class FName _name, int32 _iIndex);
	void GetArrayFloat(TArray<float>* _result, class FName _name, int32 _iIndex);
	void GetArrayInt(TArray<int32>* _result, class FName _name, int32 _iIndex);
	void GetArrayName(TArray<class FName>* _result, class FName _name, int32 _iIndex);
	void GetArrayObject(TArray<class UObject*>* _results, class FName _name, int32 _iIndex);
	void GetArrayString(TArray<class FString>* _result, class FName _name, int32 _iIndex);
	void GetArrayText(TArray<class FText>* _result, class FName _name, int32 _iIndex);
	void GetArrayVector(TArray<struct FVector>* _result, class FName _name, int32 _iIndex);
	bool GetBool(class FName _name, int32 _iIndex);
	int32 GetEnumasInt(class FName _name, int32 _iIndex);
	float GetFloat(class FName _name, int32 _iIndex);
	int32 GetInt(class FName _name, int32 _iIndex);
	class FName GetName(class FName _name, int32 _iIndex);
	class UObject* GetObject(class FName _name, int32 _iIndex);
	class FString GetString(class FName _nam, int32 _iIndex);
	class FText GetText(class FName _name, int32 _iIndex);
	class UTexture2D* GetTexture(class FName _name, int32 _iIndex);
	struct FVector GetVector(class FName _name, int32 _iIndex);
	class UUserWidget* GetWidget(class FName _name, int32 _iIndex);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"BFGDataProvider">();
	}
	static class IBFGDataProvider* GetDefaultObj()
	{
		return GetDefaultObjImpl<IBFGDataProvider>();
	}
};
static_assert(alignof(IBFGDataProvider) == 0x000008, "Wrong alignment on IBFGDataProvider");
static_assert(sizeof(IBFGDataProvider) == 0x000028, "Wrong size on IBFGDataProvider");

// Class BFGCore.BFGInteractAnimationPlayerInterface
// 0x0000 (0x0028 - 0x0028)
class IBFGInteractAnimationPlayerInterface final : public IInterface
{
public:
	bool PlayInteractAnimationSequence(const struct FBFGInteractAnimationSequence& _sequence, bool _bInterupt);
	void Update(float _fDeltaTime);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"BFGInteractAnimationPlayerInterface">();
	}
	static class IBFGInteractAnimationPlayerInterface* GetDefaultObj()
	{
		return GetDefaultObjImpl<IBFGInteractAnimationPlayerInterface>();
	}
};
static_assert(alignof(IBFGInteractAnimationPlayerInterface) == 0x000008, "Wrong alignment on IBFGInteractAnimationPlayerInterface");
static_assert(sizeof(IBFGInteractAnimationPlayerInterface) == 0x000028, "Wrong size on IBFGInteractAnimationPlayerInterface");

// Class BFGCore.MeshWidget
// 0x0028 (0x0140 - 0x0118)
class UMeshWidget final : public UWidget
{
public:
	class USlateVectorArtData*                    CachedData;                                        // 0x0118(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TDelegate<void(const struct FGeometry& MyGeometry, struct FPointerEvent& MouseEvent)> OnMouseButtonDownEvent;                            // 0x0120(0x0010)(Edit, ZeroConstructor, InstancedReference, NoDestructor, NativeAccessSpecifierPublic)
	uint8                                         Pad_130[0x10];                                     // 0x0130(0x0010)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"MeshWidget">();
	}
	static class UMeshWidget* GetDefaultObj()
	{
		return GetDefaultObjImpl<UMeshWidget>();
	}
};
static_assert(alignof(UMeshWidget) == 0x000008, "Wrong alignment on UMeshWidget");
static_assert(sizeof(UMeshWidget) == 0x000140, "Wrong size on UMeshWidget");
static_assert(offsetof(UMeshWidget, CachedData) == 0x000118, "Member 'UMeshWidget::CachedData' has a wrong offset!");
static_assert(offsetof(UMeshWidget, OnMouseButtonDownEvent) == 0x000120, "Member 'UMeshWidget::OnMouseButtonDownEvent' has a wrong offset!");

}

