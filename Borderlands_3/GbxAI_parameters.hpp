#pragma once

/*
* SDK generated by Dumper-7
*
* https://github.com/Encryqed/Dumper-7
*/

// Package: GbxAI

#include "Basic.hpp"

#include "AIModule_structs.hpp"
#include "GbxAI_structs.hpp"
#include "GbxGameSystemCore_structs.hpp"
#include "CoreUObject_structs.hpp"
#include "Engine_structs.hpp"
#include "GameplayTags_structs.hpp"


namespace SDK::Params
{

// Function GbxAI.AIActionBase.StopBP
// 0x0028 (0x0028 - 0x0000)
struct AIActionBase_StopBP final
{
public:
	class UAIActionBase*                          Action;                                            // 0x0000(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FAIActionBlueprintContext              Context;                                           // 0x0008(0x0018)(ConstParm, Parm, OutParm, ReferenceParm, NoDestructor, NativeAccessSpecifierPublic)
	bool                                          bSucceeded;                                        // 0x0020(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_21[0x7];                                       // 0x0021(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(AIActionBase_StopBP) == 0x000008, "Wrong alignment on AIActionBase_StopBP");
static_assert(sizeof(AIActionBase_StopBP) == 0x000028, "Wrong size on AIActionBase_StopBP");
static_assert(offsetof(AIActionBase_StopBP, Action) == 0x000000, "Member 'AIActionBase_StopBP::Action' has a wrong offset!");
static_assert(offsetof(AIActionBase_StopBP, Context) == 0x000008, "Member 'AIActionBase_StopBP::Context' has a wrong offset!");
static_assert(offsetof(AIActionBase_StopBP, bSucceeded) == 0x000020, "Member 'AIActionBase_StopBP::bSucceeded' has a wrong offset!");

// Function GbxAI.AIActionBase.CreateSubobjectNoName
// 0x0010 (0x0010 - 0x0000)
struct AIActionBase_CreateSubobjectNoName final
{
public:
	class UClass*                                 Class_0;                                           // 0x0000(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UObject*                                ReturnValue;                                       // 0x0008(0x0008)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(AIActionBase_CreateSubobjectNoName) == 0x000008, "Wrong alignment on AIActionBase_CreateSubobjectNoName");
static_assert(sizeof(AIActionBase_CreateSubobjectNoName) == 0x000010, "Wrong size on AIActionBase_CreateSubobjectNoName");
static_assert(offsetof(AIActionBase_CreateSubobjectNoName, Class_0) == 0x000000, "Member 'AIActionBase_CreateSubobjectNoName::Class_0' has a wrong offset!");
static_assert(offsetof(AIActionBase_CreateSubobjectNoName, ReturnValue) == 0x000008, "Member 'AIActionBase_CreateSubobjectNoName::ReturnValue' has a wrong offset!");

// Function GbxAI.AIActionBlueprint.ShouldSkipBlackboardProperty
// 0x0010 (0x0010 - 0x0000)
struct AIActionBlueprint_ShouldSkipBlackboardProperty final
{
public:
	class UProperty*                              Property;                                          // 0x0000(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          ReturnValue;                                       // 0x0008(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_9[0x7];                                        // 0x0009(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(AIActionBlueprint_ShouldSkipBlackboardProperty) == 0x000008, "Wrong alignment on AIActionBlueprint_ShouldSkipBlackboardProperty");
static_assert(sizeof(AIActionBlueprint_ShouldSkipBlackboardProperty) == 0x000010, "Wrong size on AIActionBlueprint_ShouldSkipBlackboardProperty");
static_assert(offsetof(AIActionBlueprint_ShouldSkipBlackboardProperty, Property) == 0x000000, "Member 'AIActionBlueprint_ShouldSkipBlackboardProperty::Property' has a wrong offset!");
static_assert(offsetof(AIActionBlueprint_ShouldSkipBlackboardProperty, ReturnValue) == 0x000008, "Member 'AIActionBlueprint_ShouldSkipBlackboardProperty::ReturnValue' has a wrong offset!");

// Function GbxAI.AIAction.CreateSubAction
// 0x0018 (0x0018 - 0x0000)
struct AIAction_CreateSubAction final
{
public:
	class UClass*                                 ActionClass;                                       // 0x0000(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   Name_0;                                            // 0x0008(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UAIAction*                              ReturnValue;                                       // 0x0010(0x0008)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(AIAction_CreateSubAction) == 0x000008, "Wrong alignment on AIAction_CreateSubAction");
static_assert(sizeof(AIAction_CreateSubAction) == 0x000018, "Wrong size on AIAction_CreateSubAction");
static_assert(offsetof(AIAction_CreateSubAction, ActionClass) == 0x000000, "Member 'AIAction_CreateSubAction::ActionClass' has a wrong offset!");
static_assert(offsetof(AIAction_CreateSubAction, Name_0) == 0x000008, "Member 'AIAction_CreateSubAction::Name_0' has a wrong offset!");
static_assert(offsetof(AIAction_CreateSubAction, ReturnValue) == 0x000010, "Member 'AIAction_CreateSubAction::ReturnValue' has a wrong offset!");

// Function GbxAI.AIAction_Composite.CreateChild
// 0x0010 (0x0010 - 0x0000)
struct AIAction_Composite_CreateChild final
{
public:
	class FName                                   ChildName;                                         // 0x0000(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UAIAction_CompositeChild*               ReturnValue;                                       // 0x0008(0x0008)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(AIAction_Composite_CreateChild) == 0x000008, "Wrong alignment on AIAction_Composite_CreateChild");
static_assert(sizeof(AIAction_Composite_CreateChild) == 0x000010, "Wrong size on AIAction_Composite_CreateChild");
static_assert(offsetof(AIAction_Composite_CreateChild, ChildName) == 0x000000, "Member 'AIAction_Composite_CreateChild::ChildName' has a wrong offset!");
static_assert(offsetof(AIAction_Composite_CreateChild, ReturnValue) == 0x000008, "Member 'AIAction_Composite_CreateChild::ReturnValue' has a wrong offset!");

// Function GbxAI.GameplayTask_RunScriptedAIAction.RunScriptedAIAction_Actor
// 0x0018 (0x0018 - 0x0000)
struct GameplayTask_RunScriptedAIAction_RunScriptedAIAction_Actor final
{
public:
	class AActor*                                 Actor;                                             // 0x0000(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TSubclassOf<class UAIAction>                  Action;                                            // 0x0008(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UGameplayTask_RunScriptedAIAction*      ReturnValue;                                       // 0x0010(0x0008)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(GameplayTask_RunScriptedAIAction_RunScriptedAIAction_Actor) == 0x000008, "Wrong alignment on GameplayTask_RunScriptedAIAction_RunScriptedAIAction_Actor");
static_assert(sizeof(GameplayTask_RunScriptedAIAction_RunScriptedAIAction_Actor) == 0x000018, "Wrong size on GameplayTask_RunScriptedAIAction_RunScriptedAIAction_Actor");
static_assert(offsetof(GameplayTask_RunScriptedAIAction_RunScriptedAIAction_Actor, Actor) == 0x000000, "Member 'GameplayTask_RunScriptedAIAction_RunScriptedAIAction_Actor::Actor' has a wrong offset!");
static_assert(offsetof(GameplayTask_RunScriptedAIAction_RunScriptedAIAction_Actor, Action) == 0x000008, "Member 'GameplayTask_RunScriptedAIAction_RunScriptedAIAction_Actor::Action' has a wrong offset!");
static_assert(offsetof(GameplayTask_RunScriptedAIAction_RunScriptedAIAction_Actor, ReturnValue) == 0x000010, "Member 'GameplayTask_RunScriptedAIAction_RunScriptedAIAction_Actor::ReturnValue' has a wrong offset!");

// Function GbxAI.GameplayTask_RunScriptedAIAction.RunScriptedAIAction_AIActionComponent
// 0x0018 (0x0018 - 0x0000)
struct GameplayTask_RunScriptedAIAction_RunScriptedAIAction_AIActionComponent final
{
public:
	class UAIActionComponent*                     AIActionComponent;                                 // 0x0000(0x0008)(Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TSubclassOf<class UAIAction>                  Action;                                            // 0x0008(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UGameplayTask_RunScriptedAIAction*      ReturnValue;                                       // 0x0010(0x0008)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(GameplayTask_RunScriptedAIAction_RunScriptedAIAction_AIActionComponent) == 0x000008, "Wrong alignment on GameplayTask_RunScriptedAIAction_RunScriptedAIAction_AIActionComponent");
static_assert(sizeof(GameplayTask_RunScriptedAIAction_RunScriptedAIAction_AIActionComponent) == 0x000018, "Wrong size on GameplayTask_RunScriptedAIAction_RunScriptedAIAction_AIActionComponent");
static_assert(offsetof(GameplayTask_RunScriptedAIAction_RunScriptedAIAction_AIActionComponent, AIActionComponent) == 0x000000, "Member 'GameplayTask_RunScriptedAIAction_RunScriptedAIAction_AIActionComponent::AIActionComponent' has a wrong offset!");
static_assert(offsetof(GameplayTask_RunScriptedAIAction_RunScriptedAIAction_AIActionComponent, Action) == 0x000008, "Member 'GameplayTask_RunScriptedAIAction_RunScriptedAIAction_AIActionComponent::Action' has a wrong offset!");
static_assert(offsetof(GameplayTask_RunScriptedAIAction_RunScriptedAIAction_AIActionComponent, ReturnValue) == 0x000010, "Member 'GameplayTask_RunScriptedAIAction_RunScriptedAIAction_AIActionComponent::ReturnValue' has a wrong offset!");

// Function GbxAI.GameplayTask_RunScriptedAIAction.RunScriptedAIAction_Controller
// 0x0018 (0x0018 - 0x0000)
struct GameplayTask_RunScriptedAIAction_RunScriptedAIAction_Controller final
{
public:
	class AGbxAIController*                       Controller;                                        // 0x0000(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TSubclassOf<class UAIAction>                  Action;                                            // 0x0008(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UGameplayTask_RunScriptedAIAction*      ReturnValue;                                       // 0x0010(0x0008)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(GameplayTask_RunScriptedAIAction_RunScriptedAIAction_Controller) == 0x000008, "Wrong alignment on GameplayTask_RunScriptedAIAction_RunScriptedAIAction_Controller");
static_assert(sizeof(GameplayTask_RunScriptedAIAction_RunScriptedAIAction_Controller) == 0x000018, "Wrong size on GameplayTask_RunScriptedAIAction_RunScriptedAIAction_Controller");
static_assert(offsetof(GameplayTask_RunScriptedAIAction_RunScriptedAIAction_Controller, Controller) == 0x000000, "Member 'GameplayTask_RunScriptedAIAction_RunScriptedAIAction_Controller::Controller' has a wrong offset!");
static_assert(offsetof(GameplayTask_RunScriptedAIAction_RunScriptedAIAction_Controller, Action) == 0x000008, "Member 'GameplayTask_RunScriptedAIAction_RunScriptedAIAction_Controller::Action' has a wrong offset!");
static_assert(offsetof(GameplayTask_RunScriptedAIAction_RunScriptedAIAction_Controller, ReturnValue) == 0x000010, "Member 'GameplayTask_RunScriptedAIAction_RunScriptedAIAction_Controller::ReturnValue' has a wrong offset!");

// Function GbxAI.GameplayTask_RunScriptedAIAction.RunScriptedAIAction_Object
// 0x0018 (0x0018 - 0x0000)
struct GameplayTask_RunScriptedAIAction_RunScriptedAIAction_Object final
{
public:
	class UObject*                                Object;                                            // 0x0000(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TSubclassOf<class UAIAction>                  Action;                                            // 0x0008(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UGameplayTask_RunScriptedAIAction*      ReturnValue;                                       // 0x0010(0x0008)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(GameplayTask_RunScriptedAIAction_RunScriptedAIAction_Object) == 0x000008, "Wrong alignment on GameplayTask_RunScriptedAIAction_RunScriptedAIAction_Object");
static_assert(sizeof(GameplayTask_RunScriptedAIAction_RunScriptedAIAction_Object) == 0x000018, "Wrong size on GameplayTask_RunScriptedAIAction_RunScriptedAIAction_Object");
static_assert(offsetof(GameplayTask_RunScriptedAIAction_RunScriptedAIAction_Object, Object) == 0x000000, "Member 'GameplayTask_RunScriptedAIAction_RunScriptedAIAction_Object::Object' has a wrong offset!");
static_assert(offsetof(GameplayTask_RunScriptedAIAction_RunScriptedAIAction_Object, Action) == 0x000008, "Member 'GameplayTask_RunScriptedAIAction_RunScriptedAIAction_Object::Action' has a wrong offset!");
static_assert(offsetof(GameplayTask_RunScriptedAIAction_RunScriptedAIAction_Object, ReturnValue) == 0x000010, "Member 'GameplayTask_RunScriptedAIAction_RunScriptedAIAction_Object::ReturnValue' has a wrong offset!");

// Function GbxAI.AIActionComponent.AbortScriptedAIAction
// 0x0001 (0x0001 - 0x0000)
struct AIActionComponent_AbortScriptedAIAction final
{
public:
	bool                                          bStopImmediately;                                  // 0x0000(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(AIActionComponent_AbortScriptedAIAction) == 0x000001, "Wrong alignment on AIActionComponent_AbortScriptedAIAction");
static_assert(sizeof(AIActionComponent_AbortScriptedAIAction) == 0x000001, "Wrong size on AIActionComponent_AbortScriptedAIAction");
static_assert(offsetof(AIActionComponent_AbortScriptedAIAction, bStopImmediately) == 0x000000, "Member 'AIActionComponent_AbortScriptedAIAction::bStopImmediately' has a wrong offset!");

// Function GbxAI.AIActionComponent.ReplaceMainAIAction
// 0x0008 (0x0008 - 0x0000)
struct AIActionComponent_ReplaceMainAIAction final
{
public:
	TSubclassOf<class UAIAction>                  Action;                                            // 0x0000(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(AIActionComponent_ReplaceMainAIAction) == 0x000008, "Wrong alignment on AIActionComponent_ReplaceMainAIAction");
static_assert(sizeof(AIActionComponent_ReplaceMainAIAction) == 0x000008, "Wrong size on AIActionComponent_ReplaceMainAIAction");
static_assert(offsetof(AIActionComponent_ReplaceMainAIAction, Action) == 0x000000, "Member 'AIActionComponent_ReplaceMainAIAction::Action' has a wrong offset!");

// Function GbxAI.AIActionComponent.GetBlackboardData
// 0x0008 (0x0008 - 0x0000)
struct AIActionComponent_GetBlackboardData final
{
public:
	class UBlackboardData*                        ReturnValue;                                       // 0x0000(0x0008)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(AIActionComponent_GetBlackboardData) == 0x000008, "Wrong alignment on AIActionComponent_GetBlackboardData");
static_assert(sizeof(AIActionComponent_GetBlackboardData) == 0x000008, "Wrong size on AIActionComponent_GetBlackboardData");
static_assert(offsetof(AIActionComponent_GetBlackboardData, ReturnValue) == 0x000000, "Member 'AIActionComponent_GetBlackboardData::ReturnValue' has a wrong offset!");

// Function GbxAI.AIAction_CompositeChild.CreateAction
// 0x0010 (0x0010 - 0x0000)
struct AIAction_CompositeChild_CreateAction final
{
public:
	class UClass*                                 ActionClass;                                       // 0x0000(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UAIAction*                              ReturnValue;                                       // 0x0008(0x0008)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(AIAction_CompositeChild_CreateAction) == 0x000008, "Wrong alignment on AIAction_CompositeChild_CreateAction");
static_assert(sizeof(AIAction_CompositeChild_CreateAction) == 0x000010, "Wrong size on AIAction_CompositeChild_CreateAction");
static_assert(offsetof(AIAction_CompositeChild_CreateAction, ActionClass) == 0x000000, "Member 'AIAction_CompositeChild_CreateAction::ActionClass' has a wrong offset!");
static_assert(offsetof(AIAction_CompositeChild_CreateAction, ReturnValue) == 0x000008, "Member 'AIAction_CompositeChild_CreateAction::ReturnValue' has a wrong offset!");

// Function GbxAI.SmartObjectPreviewComponent.OnCycleActor
// 0x0001 (0x0001 - 0x0000)
struct SmartObjectPreviewComponent_OnCycleActor final
{
public:
	ECycleDirection                               Direction;                                         // 0x0000(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(SmartObjectPreviewComponent_OnCycleActor) == 0x000001, "Wrong alignment on SmartObjectPreviewComponent_OnCycleActor");
static_assert(sizeof(SmartObjectPreviewComponent_OnCycleActor) == 0x000001, "Wrong size on SmartObjectPreviewComponent_OnCycleActor");
static_assert(offsetof(SmartObjectPreviewComponent_OnCycleActor, Direction) == 0x000000, "Member 'SmartObjectPreviewComponent_OnCycleActor::Direction' has a wrong offset!");

// Function GbxAI.AIAction_MoveSpline.ChangeSplineOffset
// 0x0010 (0x0010 - 0x0000)
struct AIAction_MoveSpline_ChangeSplineOffset final
{
public:
	class AActor*                                 TargetActor;                                       // 0x0000(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         Offset;                                            // 0x0008(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          ReturnValue;                                       // 0x000C(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_D[0x3];                                        // 0x000D(0x0003)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(AIAction_MoveSpline_ChangeSplineOffset) == 0x000008, "Wrong alignment on AIAction_MoveSpline_ChangeSplineOffset");
static_assert(sizeof(AIAction_MoveSpline_ChangeSplineOffset) == 0x000010, "Wrong size on AIAction_MoveSpline_ChangeSplineOffset");
static_assert(offsetof(AIAction_MoveSpline_ChangeSplineOffset, TargetActor) == 0x000000, "Member 'AIAction_MoveSpline_ChangeSplineOffset::TargetActor' has a wrong offset!");
static_assert(offsetof(AIAction_MoveSpline_ChangeSplineOffset, Offset) == 0x000008, "Member 'AIAction_MoveSpline_ChangeSplineOffset::Offset' has a wrong offset!");
static_assert(offsetof(AIAction_MoveSpline_ChangeSplineOffset, ReturnValue) == 0x00000C, "Member 'AIAction_MoveSpline_ChangeSplineOffset::ReturnValue' has a wrong offset!");

// Function GbxAI.AIAction_MoveSpline.SetupMoveSpline
// 0x0018 (0x0018 - 0x0000)
struct AIAction_MoveSpline_SetupMoveSpline final
{
public:
	class AActor*                                 TargetActor;                                       // 0x0000(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UObject*                                TargetSpline;                                      // 0x0008(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         Offset;                                            // 0x0010(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bIsReverse;                                        // 0x0014(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          ReturnValue;                                       // 0x0015(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_16[0x2];                                       // 0x0016(0x0002)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(AIAction_MoveSpline_SetupMoveSpline) == 0x000008, "Wrong alignment on AIAction_MoveSpline_SetupMoveSpline");
static_assert(sizeof(AIAction_MoveSpline_SetupMoveSpline) == 0x000018, "Wrong size on AIAction_MoveSpline_SetupMoveSpline");
static_assert(offsetof(AIAction_MoveSpline_SetupMoveSpline, TargetActor) == 0x000000, "Member 'AIAction_MoveSpline_SetupMoveSpline::TargetActor' has a wrong offset!");
static_assert(offsetof(AIAction_MoveSpline_SetupMoveSpline, TargetSpline) == 0x000008, "Member 'AIAction_MoveSpline_SetupMoveSpline::TargetSpline' has a wrong offset!");
static_assert(offsetof(AIAction_MoveSpline_SetupMoveSpline, Offset) == 0x000010, "Member 'AIAction_MoveSpline_SetupMoveSpline::Offset' has a wrong offset!");
static_assert(offsetof(AIAction_MoveSpline_SetupMoveSpline, bIsReverse) == 0x000014, "Member 'AIAction_MoveSpline_SetupMoveSpline::bIsReverse' has a wrong offset!");
static_assert(offsetof(AIAction_MoveSpline_SetupMoveSpline, ReturnValue) == 0x000015, "Member 'AIAction_MoveSpline_SetupMoveSpline::ReturnValue' has a wrong offset!");

// Function GbxAI.Cover.SetEnabled
// 0x0001 (0x0001 - 0x0000)
struct Cover_SetEnabled final
{
public:
	bool                                          bEnabled;                                          // 0x0000(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(Cover_SetEnabled) == 0x000001, "Wrong alignment on Cover_SetEnabled");
static_assert(sizeof(Cover_SetEnabled) == 0x000001, "Wrong size on Cover_SetEnabled");
static_assert(offsetof(Cover_SetEnabled, bEnabled) == 0x000000, "Member 'Cover_SetEnabled::bEnabled' has a wrong offset!");

// Function GbxAI.Cover.IsEnabled
// 0x0001 (0x0001 - 0x0000)
struct Cover_IsEnabled final
{
public:
	bool                                          ReturnValue;                                       // 0x0000(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(Cover_IsEnabled) == 0x000001, "Wrong alignment on Cover_IsEnabled");
static_assert(sizeof(Cover_IsEnabled) == 0x000001, "Wrong size on Cover_IsEnabled");
static_assert(offsetof(Cover_IsEnabled, ReturnValue) == 0x000000, "Member 'Cover_IsEnabled::ReturnValue' has a wrong offset!");

// Function GbxAI.AIAction_StateMachineChild.GetAvailableStates
// 0x0010 (0x0010 - 0x0000)
struct AIAction_StateMachineChild_GetAvailableStates final
{
public:
	TArray<class UAIAction_StateMachineChild*>    Array;                                             // 0x0000(0x0010)(Parm, OutParm, ZeroConstructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(AIAction_StateMachineChild_GetAvailableStates) == 0x000008, "Wrong alignment on AIAction_StateMachineChild_GetAvailableStates");
static_assert(sizeof(AIAction_StateMachineChild_GetAvailableStates) == 0x000010, "Wrong size on AIAction_StateMachineChild_GetAvailableStates");
static_assert(offsetof(AIAction_StateMachineChild_GetAvailableStates, Array) == 0x000000, "Member 'AIAction_StateMachineChild_GetAvailableStates::Array' has a wrong offset!");

// Function GbxAI.AIAspect_ActorCollision.GetOnCollisionOptions
// 0x0010 (0x0010 - 0x0000)
struct AIAspect_ActorCollision_GetOnCollisionOptions final
{
public:
	TArray<class FName>                           Options;                                           // 0x0000(0x0010)(Parm, OutParm, ZeroConstructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(AIAspect_ActorCollision_GetOnCollisionOptions) == 0x000008, "Wrong alignment on AIAspect_ActorCollision_GetOnCollisionOptions");
static_assert(sizeof(AIAspect_ActorCollision_GetOnCollisionOptions) == 0x000010, "Wrong size on AIAspect_ActorCollision_GetOnCollisionOptions");
static_assert(offsetof(AIAspect_ActorCollision_GetOnCollisionOptions, Options) == 0x000000, "Member 'AIAspect_ActorCollision_GetOnCollisionOptions::Options' has a wrong offset!");

// Function GbxAI.AIAspect_ActorCollision.OnPawnHit
// 0x00B0 (0x00B0 - 0x0000)
struct AIAspect_ActorCollision_OnPawnHit final
{
public:
	class AActor*                                 SelfActor;                                         // 0x0000(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class AActor*                                 OtherActor;                                        // 0x0008(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                NormalImpulse;                                     // 0x0010(0x000C)(Parm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1C[0x4];                                       // 0x001C(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	struct FHitResult                             Hit;                                               // 0x0020(0x0090)(ConstParm, Parm, OutParm, ReferenceParm, IsPlainOldData, NoDestructor, ContainsInstancedReference, NativeAccessSpecifierPublic)
};
static_assert(alignof(AIAspect_ActorCollision_OnPawnHit) == 0x000008, "Wrong alignment on AIAspect_ActorCollision_OnPawnHit");
static_assert(sizeof(AIAspect_ActorCollision_OnPawnHit) == 0x0000B0, "Wrong size on AIAspect_ActorCollision_OnPawnHit");
static_assert(offsetof(AIAspect_ActorCollision_OnPawnHit, SelfActor) == 0x000000, "Member 'AIAspect_ActorCollision_OnPawnHit::SelfActor' has a wrong offset!");
static_assert(offsetof(AIAspect_ActorCollision_OnPawnHit, OtherActor) == 0x000008, "Member 'AIAspect_ActorCollision_OnPawnHit::OtherActor' has a wrong offset!");
static_assert(offsetof(AIAspect_ActorCollision_OnPawnHit, NormalImpulse) == 0x000010, "Member 'AIAspect_ActorCollision_OnPawnHit::NormalImpulse' has a wrong offset!");
static_assert(offsetof(AIAspect_ActorCollision_OnPawnHit, Hit) == 0x000020, "Member 'AIAspect_ActorCollision_OnPawnHit::Hit' has a wrong offset!");

// Function GbxAI.AIAspect_Condition.GetConditionDataDescription
// 0x00A0 (0x00A0 - 0x0000)
struct AIAspect_Condition_GetConditionDataDescription final
{
public:
	struct FAIAspectSettings_ConditionData        ConditionData;                                     // 0x0000(0x0090)(ConstParm, Parm, OutParm, ReferenceParm, NoDestructor, ContainsInstancedReference, NativeAccessSpecifierPublic)
	class FString                                 ReturnValue;                                       // 0x0090(0x0010)(Parm, OutParm, ZeroConstructor, ReturnParm, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(AIAspect_Condition_GetConditionDataDescription) == 0x000008, "Wrong alignment on AIAspect_Condition_GetConditionDataDescription");
static_assert(sizeof(AIAspect_Condition_GetConditionDataDescription) == 0x0000A0, "Wrong size on AIAspect_Condition_GetConditionDataDescription");
static_assert(offsetof(AIAspect_Condition_GetConditionDataDescription, ConditionData) == 0x000000, "Member 'AIAspect_Condition_GetConditionDataDescription::ConditionData' has a wrong offset!");
static_assert(offsetof(AIAspect_Condition_GetConditionDataDescription, ReturnValue) == 0x000090, "Member 'AIAspect_Condition_GetConditionDataDescription::ReturnValue' has a wrong offset!");

// Function GbxAI.AIAspect_BlackboardKey.GetSettingsDescription
// 0x0028 (0x0028 - 0x0000)
struct AIAspect_BlackboardKey_GetSettingsDescription final
{
public:
	struct FAIAspectSettings_BlackboardKey        BBKeySettings;                                     // 0x0000(0x0018)(ConstParm, Parm, OutParm, ReferenceParm, NoDestructor, NativeAccessSpecifierPublic)
	class FString                                 ReturnValue;                                       // 0x0018(0x0010)(Parm, OutParm, ZeroConstructor, ReturnParm, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(AIAspect_BlackboardKey_GetSettingsDescription) == 0x000008, "Wrong alignment on AIAspect_BlackboardKey_GetSettingsDescription");
static_assert(sizeof(AIAspect_BlackboardKey_GetSettingsDescription) == 0x000028, "Wrong size on AIAspect_BlackboardKey_GetSettingsDescription");
static_assert(offsetof(AIAspect_BlackboardKey_GetSettingsDescription, BBKeySettings) == 0x000000, "Member 'AIAspect_BlackboardKey_GetSettingsDescription::BBKeySettings' has a wrong offset!");
static_assert(offsetof(AIAspect_BlackboardKey_GetSettingsDescription, ReturnValue) == 0x000018, "Member 'AIAspect_BlackboardKey_GetSettingsDescription::ReturnValue' has a wrong offset!");

// Function GbxAI.AIAspect_Navigation.GetNavSettingsDescription
// 0x0158 (0x0158 - 0x0000)
struct AIAspect_Navigation_GetNavSettingsDescription final
{
public:
	struct FAIAspectSettings_Navigation           NavSettings;                                       // 0x0000(0x0140)(ConstParm, Parm, OutParm, ReferenceParm, NoDestructor, ContainsInstancedReference, NativeAccessSpecifierPublic)
	class UProperty*                              Property;                                          // 0x0140(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FString                                 ReturnValue;                                       // 0x0148(0x0010)(Parm, OutParm, ZeroConstructor, ReturnParm, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(AIAspect_Navigation_GetNavSettingsDescription) == 0x000008, "Wrong alignment on AIAspect_Navigation_GetNavSettingsDescription");
static_assert(sizeof(AIAspect_Navigation_GetNavSettingsDescription) == 0x000158, "Wrong size on AIAspect_Navigation_GetNavSettingsDescription");
static_assert(offsetof(AIAspect_Navigation_GetNavSettingsDescription, NavSettings) == 0x000000, "Member 'AIAspect_Navigation_GetNavSettingsDescription::NavSettings' has a wrong offset!");
static_assert(offsetof(AIAspect_Navigation_GetNavSettingsDescription, Property) == 0x000140, "Member 'AIAspect_Navigation_GetNavSettingsDescription::Property' has a wrong offset!");
static_assert(offsetof(AIAspect_Navigation_GetNavSettingsDescription, ReturnValue) == 0x000148, "Member 'AIAspect_Navigation_GetNavSettingsDescription::ReturnValue' has a wrong offset!");

// Function GbxAI.AIAspect_EnvQuery.GetQuerySettingsDescription
// 0x03B8 (0x03B8 - 0x0000)
struct AIAspect_EnvQuery_GetQuerySettingsDescription final
{
public:
	struct FAIAspectSettings_EnvQuery             QuerySettings;                                     // 0x0000(0x03A0)(ConstParm, Parm, OutParm, ReferenceParm, ContainsInstancedReference, NativeAccessSpecifierPublic)
	class UProperty*                              Property;                                          // 0x03A0(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FString                                 ReturnValue;                                       // 0x03A8(0x0010)(Parm, OutParm, ZeroConstructor, ReturnParm, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(AIAspect_EnvQuery_GetQuerySettingsDescription) == 0x000008, "Wrong alignment on AIAspect_EnvQuery_GetQuerySettingsDescription");
static_assert(sizeof(AIAspect_EnvQuery_GetQuerySettingsDescription) == 0x0003B8, "Wrong size on AIAspect_EnvQuery_GetQuerySettingsDescription");
static_assert(offsetof(AIAspect_EnvQuery_GetQuerySettingsDescription, QuerySettings) == 0x000000, "Member 'AIAspect_EnvQuery_GetQuerySettingsDescription::QuerySettings' has a wrong offset!");
static_assert(offsetof(AIAspect_EnvQuery_GetQuerySettingsDescription, Property) == 0x0003A0, "Member 'AIAspect_EnvQuery_GetQuerySettingsDescription::Property' has a wrong offset!");
static_assert(offsetof(AIAspect_EnvQuery_GetQuerySettingsDescription, ReturnValue) == 0x0003A8, "Member 'AIAspect_EnvQuery_GetQuerySettingsDescription::ReturnValue' has a wrong offset!");

// Function GbxAI.AIAspect_Leap.GetQuerySettingsDescription
// 0x0070 (0x0070 - 0x0000)
struct AIAspect_Leap_GetQuerySettingsDescription final
{
public:
	struct FAIAspectSettings_Leap                 LeapSettings;                                      // 0x0000(0x0058)(ConstParm, Parm, OutParm, ReferenceParm, NoDestructor, NativeAccessSpecifierPublic)
	class UProperty*                              Property;                                          // 0x0058(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FString                                 ReturnValue;                                       // 0x0060(0x0010)(Parm, OutParm, ZeroConstructor, ReturnParm, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(AIAspect_Leap_GetQuerySettingsDescription) == 0x000008, "Wrong alignment on AIAspect_Leap_GetQuerySettingsDescription");
static_assert(sizeof(AIAspect_Leap_GetQuerySettingsDescription) == 0x000070, "Wrong size on AIAspect_Leap_GetQuerySettingsDescription");
static_assert(offsetof(AIAspect_Leap_GetQuerySettingsDescription, LeapSettings) == 0x000000, "Member 'AIAspect_Leap_GetQuerySettingsDescription::LeapSettings' has a wrong offset!");
static_assert(offsetof(AIAspect_Leap_GetQuerySettingsDescription, Property) == 0x000058, "Member 'AIAspect_Leap_GetQuerySettingsDescription::Property' has a wrong offset!");
static_assert(offsetof(AIAspect_Leap_GetQuerySettingsDescription, ReturnValue) == 0x000060, "Member 'AIAspect_Leap_GetQuerySettingsDescription::ReturnValue' has a wrong offset!");

// Function GbxAI.GameplayTask_ScriptedAction.OnActorSpawned
// 0x0010 (0x0010 - 0x0000)
struct GameplayTask_ScriptedAction_OnActorSpawned final
{
public:
	class ASpawner*                               Spawner;                                           // 0x0000(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class AActor*                                 Actor;                                             // 0x0008(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(GameplayTask_ScriptedAction_OnActorSpawned) == 0x000008, "Wrong alignment on GameplayTask_ScriptedAction_OnActorSpawned");
static_assert(sizeof(GameplayTask_ScriptedAction_OnActorSpawned) == 0x000010, "Wrong size on GameplayTask_ScriptedAction_OnActorSpawned");
static_assert(offsetof(GameplayTask_ScriptedAction_OnActorSpawned, Spawner) == 0x000000, "Member 'GameplayTask_ScriptedAction_OnActorSpawned::Spawner' has a wrong offset!");
static_assert(offsetof(GameplayTask_ScriptedAction_OnActorSpawned, Actor) == 0x000008, "Member 'GameplayTask_ScriptedAction_OnActorSpawned::Actor' has a wrong offset!");

// Function GbxAI.GameplayTask_ScriptedMove.BeginScriptedMove
// 0x0038 (0x0038 - 0x0000)
struct GameplayTask_ScriptedMove_BeginScriptedMove final
{
public:
	class AActor*                                 Target;                                            // 0x0000(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class AActor*                                 StartNode;                                         // 0x0008(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EScriptedActionRule                           SuccessRule;                                       // 0x0010(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, AdvancedDisplay, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EScriptedActionRule                           FailRule;                                          // 0x0011(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, AdvancedDisplay, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bAddSpawned;                                       // 0x0012(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, AdvancedDisplay, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_13[0x5];                                       // 0x0013(0x0005)(Fixing Size After Last Property [ Dumper-7 ])
	class UStanceDataProvider*                    OptionalStance;                                    // 0x0018(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, AdvancedDisplay, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class AActor*                                 OptionalLookAtActor;                               // 0x0020(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, AdvancedDisplay, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bTeleportOnFail_0;                                 // 0x0028(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, AdvancedDisplay, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_29[0x7];                                       // 0x0029(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	class UGameplayTask_ScriptedMove*             ReturnValue;                                       // 0x0030(0x0008)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(GameplayTask_ScriptedMove_BeginScriptedMove) == 0x000008, "Wrong alignment on GameplayTask_ScriptedMove_BeginScriptedMove");
static_assert(sizeof(GameplayTask_ScriptedMove_BeginScriptedMove) == 0x000038, "Wrong size on GameplayTask_ScriptedMove_BeginScriptedMove");
static_assert(offsetof(GameplayTask_ScriptedMove_BeginScriptedMove, Target) == 0x000000, "Member 'GameplayTask_ScriptedMove_BeginScriptedMove::Target' has a wrong offset!");
static_assert(offsetof(GameplayTask_ScriptedMove_BeginScriptedMove, StartNode) == 0x000008, "Member 'GameplayTask_ScriptedMove_BeginScriptedMove::StartNode' has a wrong offset!");
static_assert(offsetof(GameplayTask_ScriptedMove_BeginScriptedMove, SuccessRule) == 0x000010, "Member 'GameplayTask_ScriptedMove_BeginScriptedMove::SuccessRule' has a wrong offset!");
static_assert(offsetof(GameplayTask_ScriptedMove_BeginScriptedMove, FailRule) == 0x000011, "Member 'GameplayTask_ScriptedMove_BeginScriptedMove::FailRule' has a wrong offset!");
static_assert(offsetof(GameplayTask_ScriptedMove_BeginScriptedMove, bAddSpawned) == 0x000012, "Member 'GameplayTask_ScriptedMove_BeginScriptedMove::bAddSpawned' has a wrong offset!");
static_assert(offsetof(GameplayTask_ScriptedMove_BeginScriptedMove, OptionalStance) == 0x000018, "Member 'GameplayTask_ScriptedMove_BeginScriptedMove::OptionalStance' has a wrong offset!");
static_assert(offsetof(GameplayTask_ScriptedMove_BeginScriptedMove, OptionalLookAtActor) == 0x000020, "Member 'GameplayTask_ScriptedMove_BeginScriptedMove::OptionalLookAtActor' has a wrong offset!");
static_assert(offsetof(GameplayTask_ScriptedMove_BeginScriptedMove, bTeleportOnFail_0) == 0x000028, "Member 'GameplayTask_ScriptedMove_BeginScriptedMove::bTeleportOnFail_0' has a wrong offset!");
static_assert(offsetof(GameplayTask_ScriptedMove_BeginScriptedMove, ReturnValue) == 0x000030, "Member 'GameplayTask_ScriptedMove_BeginScriptedMove::ReturnValue' has a wrong offset!");

// Function GbxAI.GameplayTask_ScriptedMove.BeginScriptedMove2
// 0x0028 (0x0028 - 0x0000)
struct GameplayTask_ScriptedMove_BeginScriptedMove2 final
{
public:
	class AActor*                                 User;                                              // 0x0000(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class AActor*                                 StartAINode;                                       // 0x0008(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UStanceDataProvider*                    OptionalStance;                                    // 0x0010(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class AActor*                                 OptionalLookAtActor;                               // 0x0018(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UGameplayTask_ScriptedMove*             ReturnValue;                                       // 0x0020(0x0008)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(GameplayTask_ScriptedMove_BeginScriptedMove2) == 0x000008, "Wrong alignment on GameplayTask_ScriptedMove_BeginScriptedMove2");
static_assert(sizeof(GameplayTask_ScriptedMove_BeginScriptedMove2) == 0x000028, "Wrong size on GameplayTask_ScriptedMove_BeginScriptedMove2");
static_assert(offsetof(GameplayTask_ScriptedMove_BeginScriptedMove2, User) == 0x000000, "Member 'GameplayTask_ScriptedMove_BeginScriptedMove2::User' has a wrong offset!");
static_assert(offsetof(GameplayTask_ScriptedMove_BeginScriptedMove2, StartAINode) == 0x000008, "Member 'GameplayTask_ScriptedMove_BeginScriptedMove2::StartAINode' has a wrong offset!");
static_assert(offsetof(GameplayTask_ScriptedMove_BeginScriptedMove2, OptionalStance) == 0x000010, "Member 'GameplayTask_ScriptedMove_BeginScriptedMove2::OptionalStance' has a wrong offset!");
static_assert(offsetof(GameplayTask_ScriptedMove_BeginScriptedMove2, OptionalLookAtActor) == 0x000018, "Member 'GameplayTask_ScriptedMove_BeginScriptedMove2::OptionalLookAtActor' has a wrong offset!");
static_assert(offsetof(GameplayTask_ScriptedMove_BeginScriptedMove2, ReturnValue) == 0x000020, "Member 'GameplayTask_ScriptedMove_BeginScriptedMove2::ReturnValue' has a wrong offset!");

// Function GbxAI.GameplayTask_ScriptedMove.BeginScriptedMoveActor
// 0x0028 (0x0028 - 0x0000)
struct GameplayTask_ScriptedMove_BeginScriptedMoveActor final
{
public:
	class AAIController*                          Target;                                            // 0x0000(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class AActor*                                 StartNode;                                         // 0x0008(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UStanceDataProvider*                    OptionalStance;                                    // 0x0010(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class AActor*                                 OptionalLookAtActor;                               // 0x0018(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UGameplayTask_ScriptedMove*             ReturnValue;                                       // 0x0020(0x0008)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(GameplayTask_ScriptedMove_BeginScriptedMoveActor) == 0x000008, "Wrong alignment on GameplayTask_ScriptedMove_BeginScriptedMoveActor");
static_assert(sizeof(GameplayTask_ScriptedMove_BeginScriptedMoveActor) == 0x000028, "Wrong size on GameplayTask_ScriptedMove_BeginScriptedMoveActor");
static_assert(offsetof(GameplayTask_ScriptedMove_BeginScriptedMoveActor, Target) == 0x000000, "Member 'GameplayTask_ScriptedMove_BeginScriptedMoveActor::Target' has a wrong offset!");
static_assert(offsetof(GameplayTask_ScriptedMove_BeginScriptedMoveActor, StartNode) == 0x000008, "Member 'GameplayTask_ScriptedMove_BeginScriptedMoveActor::StartNode' has a wrong offset!");
static_assert(offsetof(GameplayTask_ScriptedMove_BeginScriptedMoveActor, OptionalStance) == 0x000010, "Member 'GameplayTask_ScriptedMove_BeginScriptedMoveActor::OptionalStance' has a wrong offset!");
static_assert(offsetof(GameplayTask_ScriptedMove_BeginScriptedMoveActor, OptionalLookAtActor) == 0x000018, "Member 'GameplayTask_ScriptedMove_BeginScriptedMoveActor::OptionalLookAtActor' has a wrong offset!");
static_assert(offsetof(GameplayTask_ScriptedMove_BeginScriptedMoveActor, ReturnValue) == 0x000020, "Member 'GameplayTask_ScriptedMove_BeginScriptedMoveActor::ReturnValue' has a wrong offset!");

// Function GbxAI.AIAspect_Loop.GetSettingsDescription
// 0x01A8 (0x01A8 - 0x0000)
struct AIAspect_Loop_GetSettingsDescription final
{
public:
	struct FAIAspectSettings_Loop                 LoopSettings;                                      // 0x0000(0x0198)(ConstParm, Parm, OutParm, ReferenceParm, NoDestructor, ContainsInstancedReference, NativeAccessSpecifierPublic)
	class FString                                 ReturnValue;                                       // 0x0198(0x0010)(Parm, OutParm, ZeroConstructor, ReturnParm, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(AIAspect_Loop_GetSettingsDescription) == 0x000008, "Wrong alignment on AIAspect_Loop_GetSettingsDescription");
static_assert(sizeof(AIAspect_Loop_GetSettingsDescription) == 0x0001A8, "Wrong size on AIAspect_Loop_GetSettingsDescription");
static_assert(offsetof(AIAspect_Loop_GetSettingsDescription, LoopSettings) == 0x000000, "Member 'AIAspect_Loop_GetSettingsDescription::LoopSettings' has a wrong offset!");
static_assert(offsetof(AIAspect_Loop_GetSettingsDescription, ReturnValue) == 0x000198, "Member 'AIAspect_Loop_GetSettingsDescription::ReturnValue' has a wrong offset!");

// Function GbxAI.GameplayTask_ScriptedRoute.BeginScriptedRoute
// 0x0020 (0x0020 - 0x0000)
struct GameplayTask_ScriptedRoute_BeginScriptedRoute final
{
public:
	class AActor*                                 User;                                              // 0x0000(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class AActor*                                 FirstAINode;                                       // 0x0008(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UStanceDataProvider*                    OptionalStance;                                    // 0x0010(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UGameplayTask_ScriptedRoute*            ReturnValue;                                       // 0x0018(0x0008)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(GameplayTask_ScriptedRoute_BeginScriptedRoute) == 0x000008, "Wrong alignment on GameplayTask_ScriptedRoute_BeginScriptedRoute");
static_assert(sizeof(GameplayTask_ScriptedRoute_BeginScriptedRoute) == 0x000020, "Wrong size on GameplayTask_ScriptedRoute_BeginScriptedRoute");
static_assert(offsetof(GameplayTask_ScriptedRoute_BeginScriptedRoute, User) == 0x000000, "Member 'GameplayTask_ScriptedRoute_BeginScriptedRoute::User' has a wrong offset!");
static_assert(offsetof(GameplayTask_ScriptedRoute_BeginScriptedRoute, FirstAINode) == 0x000008, "Member 'GameplayTask_ScriptedRoute_BeginScriptedRoute::FirstAINode' has a wrong offset!");
static_assert(offsetof(GameplayTask_ScriptedRoute_BeginScriptedRoute, OptionalStance) == 0x000010, "Member 'GameplayTask_ScriptedRoute_BeginScriptedRoute::OptionalStance' has a wrong offset!");
static_assert(offsetof(GameplayTask_ScriptedRoute_BeginScriptedRoute, ReturnValue) == 0x000018, "Member 'GameplayTask_ScriptedRoute_BeginScriptedRoute::ReturnValue' has a wrong offset!");

// Function GbxAI.GameplayTask_ScriptedRoute.BeginScriptedRoute2
// 0x0028 (0x0028 - 0x0000)
struct GameplayTask_ScriptedRoute_BeginScriptedRoute2 final
{
public:
	class AActor*                                 Target;                                            // 0x0000(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class AActor*                                 FirstAINode;                                       // 0x0008(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EScriptedActionRule                           SuccessRule;                                       // 0x0010(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, AdvancedDisplay, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EScriptedActionRule                           FailRule;                                          // 0x0011(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, AdvancedDisplay, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bAddSpawned;                                       // 0x0012(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, AdvancedDisplay, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_13[0x5];                                       // 0x0013(0x0005)(Fixing Size After Last Property [ Dumper-7 ])
	class UStanceDataProvider*                    OptionalStance;                                    // 0x0018(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, AdvancedDisplay, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UGameplayTask_ScriptedRoute*            ReturnValue;                                       // 0x0020(0x0008)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(GameplayTask_ScriptedRoute_BeginScriptedRoute2) == 0x000008, "Wrong alignment on GameplayTask_ScriptedRoute_BeginScriptedRoute2");
static_assert(sizeof(GameplayTask_ScriptedRoute_BeginScriptedRoute2) == 0x000028, "Wrong size on GameplayTask_ScriptedRoute_BeginScriptedRoute2");
static_assert(offsetof(GameplayTask_ScriptedRoute_BeginScriptedRoute2, Target) == 0x000000, "Member 'GameplayTask_ScriptedRoute_BeginScriptedRoute2::Target' has a wrong offset!");
static_assert(offsetof(GameplayTask_ScriptedRoute_BeginScriptedRoute2, FirstAINode) == 0x000008, "Member 'GameplayTask_ScriptedRoute_BeginScriptedRoute2::FirstAINode' has a wrong offset!");
static_assert(offsetof(GameplayTask_ScriptedRoute_BeginScriptedRoute2, SuccessRule) == 0x000010, "Member 'GameplayTask_ScriptedRoute_BeginScriptedRoute2::SuccessRule' has a wrong offset!");
static_assert(offsetof(GameplayTask_ScriptedRoute_BeginScriptedRoute2, FailRule) == 0x000011, "Member 'GameplayTask_ScriptedRoute_BeginScriptedRoute2::FailRule' has a wrong offset!");
static_assert(offsetof(GameplayTask_ScriptedRoute_BeginScriptedRoute2, bAddSpawned) == 0x000012, "Member 'GameplayTask_ScriptedRoute_BeginScriptedRoute2::bAddSpawned' has a wrong offset!");
static_assert(offsetof(GameplayTask_ScriptedRoute_BeginScriptedRoute2, OptionalStance) == 0x000018, "Member 'GameplayTask_ScriptedRoute_BeginScriptedRoute2::OptionalStance' has a wrong offset!");
static_assert(offsetof(GameplayTask_ScriptedRoute_BeginScriptedRoute2, ReturnValue) == 0x000020, "Member 'GameplayTask_ScriptedRoute_BeginScriptedRoute2::ReturnValue' has a wrong offset!");

// Function GbxAI.AIAspect_Rotation.GetRotationChannelSettingsDescription
// 0x01D0 (0x01D0 - 0x0000)
struct AIAspect_Rotation_GetRotationChannelSettingsDescription final
{
public:
	struct FAIAspectSettings_RotationChannel      RotationChannelSettings;                           // 0x0000(0x01B8)(ConstParm, Parm, OutParm, ReferenceParm, NoDestructor, ContainsInstancedReference, NativeAccessSpecifierPublic)
	class UProperty*                              Property;                                          // 0x01B8(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FString                                 ReturnValue;                                       // 0x01C0(0x0010)(Parm, OutParm, ZeroConstructor, ReturnParm, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(AIAspect_Rotation_GetRotationChannelSettingsDescription) == 0x000008, "Wrong alignment on AIAspect_Rotation_GetRotationChannelSettingsDescription");
static_assert(sizeof(AIAspect_Rotation_GetRotationChannelSettingsDescription) == 0x0001D0, "Wrong size on AIAspect_Rotation_GetRotationChannelSettingsDescription");
static_assert(offsetof(AIAspect_Rotation_GetRotationChannelSettingsDescription, RotationChannelSettings) == 0x000000, "Member 'AIAspect_Rotation_GetRotationChannelSettingsDescription::RotationChannelSettings' has a wrong offset!");
static_assert(offsetof(AIAspect_Rotation_GetRotationChannelSettingsDescription, Property) == 0x0001B8, "Member 'AIAspect_Rotation_GetRotationChannelSettingsDescription::Property' has a wrong offset!");
static_assert(offsetof(AIAspect_Rotation_GetRotationChannelSettingsDescription, ReturnValue) == 0x0001C0, "Member 'AIAspect_Rotation_GetRotationChannelSettingsDescription::ReturnValue' has a wrong offset!");

// Function GbxAI.AIAspect_Rotation.GetRotationSettingsDescription
// 0x0568 (0x0568 - 0x0000)
struct AIAspect_Rotation_GetRotationSettingsDescription final
{
public:
	struct FAIAspectSettings_Rotation             RotationSettings;                                  // 0x0000(0x0550)(ConstParm, Parm, OutParm, ReferenceParm, NoDestructor, ContainsInstancedReference, NativeAccessSpecifierPublic)
	class UProperty*                              Property;                                          // 0x0550(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FString                                 ReturnValue;                                       // 0x0558(0x0010)(Parm, OutParm, ZeroConstructor, ReturnParm, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(AIAspect_Rotation_GetRotationSettingsDescription) == 0x000008, "Wrong alignment on AIAspect_Rotation_GetRotationSettingsDescription");
static_assert(sizeof(AIAspect_Rotation_GetRotationSettingsDescription) == 0x000568, "Wrong size on AIAspect_Rotation_GetRotationSettingsDescription");
static_assert(offsetof(AIAspect_Rotation_GetRotationSettingsDescription, RotationSettings) == 0x000000, "Member 'AIAspect_Rotation_GetRotationSettingsDescription::RotationSettings' has a wrong offset!");
static_assert(offsetof(AIAspect_Rotation_GetRotationSettingsDescription, Property) == 0x000550, "Member 'AIAspect_Rotation_GetRotationSettingsDescription::Property' has a wrong offset!");
static_assert(offsetof(AIAspect_Rotation_GetRotationSettingsDescription, ReturnValue) == 0x000558, "Member 'AIAspect_Rotation_GetRotationSettingsDescription::ReturnValue' has a wrong offset!");

// Function GbxAI.GameplayTask_ScriptedLand.BeginScriptedLand
// 0x0010 (0x0010 - 0x0000)
struct GameplayTask_ScriptedLand_BeginScriptedLand final
{
public:
	class AActor*                                 Lander;                                            // 0x0000(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UGameplayTask_ScriptedLand*             ReturnValue;                                       // 0x0008(0x0008)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(GameplayTask_ScriptedLand_BeginScriptedLand) == 0x000008, "Wrong alignment on GameplayTask_ScriptedLand_BeginScriptedLand");
static_assert(sizeof(GameplayTask_ScriptedLand_BeginScriptedLand) == 0x000010, "Wrong size on GameplayTask_ScriptedLand_BeginScriptedLand");
static_assert(offsetof(GameplayTask_ScriptedLand_BeginScriptedLand, Lander) == 0x000000, "Member 'GameplayTask_ScriptedLand_BeginScriptedLand::Lander' has a wrong offset!");
static_assert(offsetof(GameplayTask_ScriptedLand_BeginScriptedLand, ReturnValue) == 0x000008, "Member 'GameplayTask_ScriptedLand_BeginScriptedLand::ReturnValue' has a wrong offset!");

// Function GbxAI.GbxAction_Navigation.K2_GetEntryLocation
// 0x000C (0x000C - 0x0000)
struct GbxAction_Navigation_K2_GetEntryLocation final
{
public:
	struct FVector                                ReturnValue;                                       // 0x0000(0x000C)(Parm, OutParm, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(GbxAction_Navigation_K2_GetEntryLocation) == 0x000004, "Wrong alignment on GbxAction_Navigation_K2_GetEntryLocation");
static_assert(sizeof(GbxAction_Navigation_K2_GetEntryLocation) == 0x00000C, "Wrong size on GbxAction_Navigation_K2_GetEntryLocation");
static_assert(offsetof(GbxAction_Navigation_K2_GetEntryLocation, ReturnValue) == 0x000000, "Member 'GbxAction_Navigation_K2_GetEntryLocation::ReturnValue' has a wrong offset!");

// Function GbxAI.GbxAction_Navigation.K2_GetExitLocation
// 0x000C (0x000C - 0x0000)
struct GbxAction_Navigation_K2_GetExitLocation final
{
public:
	struct FVector                                ReturnValue;                                       // 0x0000(0x000C)(Parm, OutParm, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(GbxAction_Navigation_K2_GetExitLocation) == 0x000004, "Wrong alignment on GbxAction_Navigation_K2_GetExitLocation");
static_assert(sizeof(GbxAction_Navigation_K2_GetExitLocation) == 0x00000C, "Wrong size on GbxAction_Navigation_K2_GetExitLocation");
static_assert(offsetof(GbxAction_Navigation_K2_GetExitLocation, ReturnValue) == 0x000000, "Member 'GbxAction_Navigation_K2_GetExitLocation::ReturnValue' has a wrong offset!");

// Function GbxAI.GbxAction_NavJump.OnExit
// 0x0008 (0x0008 - 0x0000)
struct GbxAction_NavJump_OnExit final
{
public:
	class AActor*                                 Actor;                                             // 0x0000(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(GbxAction_NavJump_OnExit) == 0x000008, "Wrong alignment on GbxAction_NavJump_OnExit");
static_assert(sizeof(GbxAction_NavJump_OnExit) == 0x000008, "Wrong size on GbxAction_NavJump_OnExit");
static_assert(offsetof(GbxAction_NavJump_OnExit, Actor) == 0x000000, "Member 'GbxAction_NavJump_OnExit::Actor' has a wrong offset!");

// Function GbxAI.GbxAction_NavJump.OnIdle
// 0x0008 (0x0008 - 0x0000)
struct GbxAction_NavJump_OnIdle final
{
public:
	class AActor*                                 Actor;                                             // 0x0000(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(GbxAction_NavJump_OnIdle) == 0x000008, "Wrong alignment on GbxAction_NavJump_OnIdle");
static_assert(sizeof(GbxAction_NavJump_OnIdle) == 0x000008, "Wrong size on GbxAction_NavJump_OnIdle");
static_assert(offsetof(GbxAction_NavJump_OnIdle, Actor) == 0x000000, "Member 'GbxAction_NavJump_OnIdle::Actor' has a wrong offset!");

// Function GbxAI.AIAspect_Teleport.GetTeleportSettingsDescription
// 0x0150 (0x0150 - 0x0000)
struct AIAspect_Teleport_GetTeleportSettingsDescription final
{
public:
	struct FAIAspectSettings_Teleport             TeleportSettings;                                  // 0x0000(0x0138)(ConstParm, Parm, OutParm, ReferenceParm, NoDestructor, ContainsInstancedReference, NativeAccessSpecifierPublic)
	class UProperty*                              Property;                                          // 0x0138(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FString                                 ReturnValue;                                       // 0x0140(0x0010)(Parm, OutParm, ZeroConstructor, ReturnParm, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(AIAspect_Teleport_GetTeleportSettingsDescription) == 0x000008, "Wrong alignment on AIAspect_Teleport_GetTeleportSettingsDescription");
static_assert(sizeof(AIAspect_Teleport_GetTeleportSettingsDescription) == 0x000150, "Wrong size on AIAspect_Teleport_GetTeleportSettingsDescription");
static_assert(offsetof(AIAspect_Teleport_GetTeleportSettingsDescription, TeleportSettings) == 0x000000, "Member 'AIAspect_Teleport_GetTeleportSettingsDescription::TeleportSettings' has a wrong offset!");
static_assert(offsetof(AIAspect_Teleport_GetTeleportSettingsDescription, Property) == 0x000138, "Member 'AIAspect_Teleport_GetTeleportSettingsDescription::Property' has a wrong offset!");
static_assert(offsetof(AIAspect_Teleport_GetTeleportSettingsDescription, ReturnValue) == 0x000140, "Member 'AIAspect_Teleport_GetTeleportSettingsDescription::ReturnValue' has a wrong offset!");

// Function GbxAI.Territory.GetTerritoryComponent
// 0x0008 (0x0008 - 0x0000)
struct Territory_GetTerritoryComponent final
{
public:
	class UTerritoryComponent*                    ReturnValue;                                       // 0x0000(0x0008)(ExportObject, Parm, OutParm, ZeroConstructor, ReturnParm, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(Territory_GetTerritoryComponent) == 0x000008, "Wrong alignment on Territory_GetTerritoryComponent");
static_assert(sizeof(Territory_GetTerritoryComponent) == 0x000008, "Wrong size on Territory_GetTerritoryComponent");
static_assert(offsetof(Territory_GetTerritoryComponent, ReturnValue) == 0x000000, "Member 'Territory_GetTerritoryComponent::ReturnValue' has a wrong offset!");

// Function GbxAI.AIAspect_Weapon.GetWeaponSettingsDescription
// 0x03E8 (0x03E8 - 0x0000)
struct AIAspect_Weapon_GetWeaponSettingsDescription final
{
public:
	struct FAIAspectSettings_Weapon               WeaponSettings;                                    // 0x0000(0x03D0)(ConstParm, Parm, OutParm, ReferenceParm, ContainsInstancedReference, NativeAccessSpecifierPublic)
	class UProperty*                              Property;                                          // 0x03D0(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FString                                 ReturnValue;                                       // 0x03D8(0x0010)(Parm, OutParm, ZeroConstructor, ReturnParm, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(AIAspect_Weapon_GetWeaponSettingsDescription) == 0x000008, "Wrong alignment on AIAspect_Weapon_GetWeaponSettingsDescription");
static_assert(sizeof(AIAspect_Weapon_GetWeaponSettingsDescription) == 0x0003E8, "Wrong size on AIAspect_Weapon_GetWeaponSettingsDescription");
static_assert(offsetof(AIAspect_Weapon_GetWeaponSettingsDescription, WeaponSettings) == 0x000000, "Member 'AIAspect_Weapon_GetWeaponSettingsDescription::WeaponSettings' has a wrong offset!");
static_assert(offsetof(AIAspect_Weapon_GetWeaponSettingsDescription, Property) == 0x0003D0, "Member 'AIAspect_Weapon_GetWeaponSettingsDescription::Property' has a wrong offset!");
static_assert(offsetof(AIAspect_Weapon_GetWeaponSettingsDescription, ReturnValue) == 0x0003D8, "Member 'AIAspect_Weapon_GetWeaponSettingsDescription::ReturnValue' has a wrong offset!");

// Function GbxAI.AICloakComponent.ForceCloak
// 0x0001 (0x0001 - 0x0000)
struct AICloakComponent_ForceCloak final
{
public:
	bool                                          bInCanPlayActions;                                 // 0x0000(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(AICloakComponent_ForceCloak) == 0x000001, "Wrong alignment on AICloakComponent_ForceCloak");
static_assert(sizeof(AICloakComponent_ForceCloak) == 0x000001, "Wrong size on AICloakComponent_ForceCloak");
static_assert(offsetof(AICloakComponent_ForceCloak, bInCanPlayActions) == 0x000000, "Member 'AICloakComponent_ForceCloak::bInCanPlayActions' has a wrong offset!");

// Function GbxAI.AICloakComponent.ForceUncloak
// 0x0001 (0x0001 - 0x0000)
struct AICloakComponent_ForceUncloak final
{
public:
	bool                                          bInCanPlayActions;                                 // 0x0000(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(AICloakComponent_ForceUncloak) == 0x000001, "Wrong alignment on AICloakComponent_ForceUncloak");
static_assert(sizeof(AICloakComponent_ForceUncloak) == 0x000001, "Wrong size on AICloakComponent_ForceUncloak");
static_assert(offsetof(AICloakComponent_ForceUncloak, bInCanPlayActions) == 0x000000, "Member 'AICloakComponent_ForceUncloak::bInCanPlayActions' has a wrong offset!");

// Function GbxAI.AICloakComponent.SetCloakData
// 0x0008 (0x0008 - 0x0000)
struct AICloakComponent_SetCloakData final
{
public:
	class UAICloakData*                           NewCloakData;                                      // 0x0000(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(AICloakComponent_SetCloakData) == 0x000008, "Wrong alignment on AICloakComponent_SetCloakData");
static_assert(sizeof(AICloakComponent_SetCloakData) == 0x000008, "Wrong size on AICloakComponent_SetCloakData");
static_assert(offsetof(AICloakComponent_SetCloakData, NewCloakData) == 0x000000, "Member 'AICloakComponent_SetCloakData::NewCloakData' has a wrong offset!");

// Function GbxAI.AICloakComponent.GetCloakData
// 0x0008 (0x0008 - 0x0000)
struct AICloakComponent_GetCloakData final
{
public:
	class UAICloakData*                           ReturnValue;                                       // 0x0000(0x0008)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(AICloakComponent_GetCloakData) == 0x000008, "Wrong alignment on AICloakComponent_GetCloakData");
static_assert(sizeof(AICloakComponent_GetCloakData) == 0x000008, "Wrong size on AICloakComponent_GetCloakData");
static_assert(offsetof(AICloakComponent_GetCloakData, ReturnValue) == 0x000000, "Member 'AICloakComponent_GetCloakData::ReturnValue' has a wrong offset!");

// Function GbxAI.AICloakComponent.IsCloaked
// 0x0001 (0x0001 - 0x0000)
struct AICloakComponent_IsCloaked final
{
public:
	bool                                          ReturnValue;                                       // 0x0000(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(AICloakComponent_IsCloaked) == 0x000001, "Wrong alignment on AICloakComponent_IsCloaked");
static_assert(sizeof(AICloakComponent_IsCloaked) == 0x000001, "Wrong size on AICloakComponent_IsCloaked");
static_assert(offsetof(AICloakComponent_IsCloaked, ReturnValue) == 0x000000, "Member 'AICloakComponent_IsCloaked::ReturnValue' has a wrong offset!");

// Function GbxAI.AICloakComponent.IsCloakStateForced
// 0x0001 (0x0001 - 0x0000)
struct AICloakComponent_IsCloakStateForced final
{
public:
	bool                                          ReturnValue;                                       // 0x0000(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(AICloakComponent_IsCloakStateForced) == 0x000001, "Wrong alignment on AICloakComponent_IsCloakStateForced");
static_assert(sizeof(AICloakComponent_IsCloakStateForced) == 0x000001, "Wrong size on AICloakComponent_IsCloakStateForced");
static_assert(offsetof(AICloakComponent_IsCloakStateForced, ReturnValue) == 0x000000, "Member 'AICloakComponent_IsCloakStateForced::ReturnValue' has a wrong offset!");

// Function GbxAI.AICloakComponent.IsPlayingAction
// 0x0001 (0x0001 - 0x0000)
struct AICloakComponent_IsPlayingAction final
{
public:
	bool                                          ReturnValue;                                       // 0x0000(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(AICloakComponent_IsPlayingAction) == 0x000001, "Wrong alignment on AICloakComponent_IsPlayingAction");
static_assert(sizeof(AICloakComponent_IsPlayingAction) == 0x000001, "Wrong size on AICloakComponent_IsPlayingAction");
static_assert(offsetof(AICloakComponent_IsPlayingAction, ReturnValue) == 0x000000, "Member 'AICloakComponent_IsPlayingAction::ReturnValue' has a wrong offset!");

// Function GbxAI.GbxAction_NavLerp.OnAlmostDone
// 0x0008 (0x0008 - 0x0000)
struct GbxAction_NavLerp_OnAlmostDone final
{
public:
	class AActor*                                 Actor;                                             // 0x0000(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(GbxAction_NavLerp_OnAlmostDone) == 0x000008, "Wrong alignment on GbxAction_NavLerp_OnAlmostDone");
static_assert(sizeof(GbxAction_NavLerp_OnAlmostDone) == 0x000008, "Wrong size on GbxAction_NavLerp_OnAlmostDone");
static_assert(offsetof(GbxAction_NavLerp_OnAlmostDone, Actor) == 0x000000, "Member 'GbxAction_NavLerp_OnAlmostDone::Actor' has a wrong offset!");

// Function GbxAI.AIGroupBlueprintLibrary.AddAITicket
// 0x0030 (0x0030 - 0x0000)
struct AIGroupBlueprintLibrary_AddAITicket final
{
public:
	struct FAITicketHandle                        OutTicketHandle;                                   // 0x0000(0x0010)(Parm, OutParm, NoDestructor, NativeAccessSpecifierPublic)
	class AAIController*                          AIUser;                                            // 0x0010(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UAITicketDataAsset*                     Ticket;                                            // 0x0018(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         Value;                                             // 0x0020(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         MaxDuration;                                       // 0x0024(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bPriority;                                         // 0x0028(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bInterruptible;                                    // 0x0029(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          ReturnValue;                                       // 0x002A(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2B[0x5];                                       // 0x002B(0x0005)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(AIGroupBlueprintLibrary_AddAITicket) == 0x000008, "Wrong alignment on AIGroupBlueprintLibrary_AddAITicket");
static_assert(sizeof(AIGroupBlueprintLibrary_AddAITicket) == 0x000030, "Wrong size on AIGroupBlueprintLibrary_AddAITicket");
static_assert(offsetof(AIGroupBlueprintLibrary_AddAITicket, OutTicketHandle) == 0x000000, "Member 'AIGroupBlueprintLibrary_AddAITicket::OutTicketHandle' has a wrong offset!");
static_assert(offsetof(AIGroupBlueprintLibrary_AddAITicket, AIUser) == 0x000010, "Member 'AIGroupBlueprintLibrary_AddAITicket::AIUser' has a wrong offset!");
static_assert(offsetof(AIGroupBlueprintLibrary_AddAITicket, Ticket) == 0x000018, "Member 'AIGroupBlueprintLibrary_AddAITicket::Ticket' has a wrong offset!");
static_assert(offsetof(AIGroupBlueprintLibrary_AddAITicket, Value) == 0x000020, "Member 'AIGroupBlueprintLibrary_AddAITicket::Value' has a wrong offset!");
static_assert(offsetof(AIGroupBlueprintLibrary_AddAITicket, MaxDuration) == 0x000024, "Member 'AIGroupBlueprintLibrary_AddAITicket::MaxDuration' has a wrong offset!");
static_assert(offsetof(AIGroupBlueprintLibrary_AddAITicket, bPriority) == 0x000028, "Member 'AIGroupBlueprintLibrary_AddAITicket::bPriority' has a wrong offset!");
static_assert(offsetof(AIGroupBlueprintLibrary_AddAITicket, bInterruptible) == 0x000029, "Member 'AIGroupBlueprintLibrary_AddAITicket::bInterruptible' has a wrong offset!");
static_assert(offsetof(AIGroupBlueprintLibrary_AddAITicket, ReturnValue) == 0x00002A, "Member 'AIGroupBlueprintLibrary_AddAITicket::ReturnValue' has a wrong offset!");

// Function GbxAI.AIGroupBlueprintLibrary.CanUseAITicket
// 0x0018 (0x0018 - 0x0000)
struct AIGroupBlueprintLibrary_CanUseAITicket final
{
public:
	class AAIController*                          AIUser;                                            // 0x0000(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UAITicketDataAsset*                     Ticket;                                            // 0x0008(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         Value;                                             // 0x0010(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bInterruptible;                                    // 0x0014(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          ReturnValue;                                       // 0x0015(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_16[0x2];                                       // 0x0016(0x0002)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(AIGroupBlueprintLibrary_CanUseAITicket) == 0x000008, "Wrong alignment on AIGroupBlueprintLibrary_CanUseAITicket");
static_assert(sizeof(AIGroupBlueprintLibrary_CanUseAITicket) == 0x000018, "Wrong size on AIGroupBlueprintLibrary_CanUseAITicket");
static_assert(offsetof(AIGroupBlueprintLibrary_CanUseAITicket, AIUser) == 0x000000, "Member 'AIGroupBlueprintLibrary_CanUseAITicket::AIUser' has a wrong offset!");
static_assert(offsetof(AIGroupBlueprintLibrary_CanUseAITicket, Ticket) == 0x000008, "Member 'AIGroupBlueprintLibrary_CanUseAITicket::Ticket' has a wrong offset!");
static_assert(offsetof(AIGroupBlueprintLibrary_CanUseAITicket, Value) == 0x000010, "Member 'AIGroupBlueprintLibrary_CanUseAITicket::Value' has a wrong offset!");
static_assert(offsetof(AIGroupBlueprintLibrary_CanUseAITicket, bInterruptible) == 0x000014, "Member 'AIGroupBlueprintLibrary_CanUseAITicket::bInterruptible' has a wrong offset!");
static_assert(offsetof(AIGroupBlueprintLibrary_CanUseAITicket, ReturnValue) == 0x000015, "Member 'AIGroupBlueprintLibrary_CanUseAITicket::ReturnValue' has a wrong offset!");

// Function GbxAI.AIGroupBlueprintLibrary.ClearAITicket
// 0x0018 (0x0018 - 0x0000)
struct AIGroupBlueprintLibrary_ClearAITicket final
{
public:
	class AAIController*                          AIUser;                                            // 0x0000(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UAITicketDataAsset*                     Ticket;                                            // 0x0008(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         HoldDuration;                                      // 0x0010(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_14[0x4];                                       // 0x0014(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(AIGroupBlueprintLibrary_ClearAITicket) == 0x000008, "Wrong alignment on AIGroupBlueprintLibrary_ClearAITicket");
static_assert(sizeof(AIGroupBlueprintLibrary_ClearAITicket) == 0x000018, "Wrong size on AIGroupBlueprintLibrary_ClearAITicket");
static_assert(offsetof(AIGroupBlueprintLibrary_ClearAITicket, AIUser) == 0x000000, "Member 'AIGroupBlueprintLibrary_ClearAITicket::AIUser' has a wrong offset!");
static_assert(offsetof(AIGroupBlueprintLibrary_ClearAITicket, Ticket) == 0x000008, "Member 'AIGroupBlueprintLibrary_ClearAITicket::Ticket' has a wrong offset!");
static_assert(offsetof(AIGroupBlueprintLibrary_ClearAITicket, HoldDuration) == 0x000010, "Member 'AIGroupBlueprintLibrary_ClearAITicket::HoldDuration' has a wrong offset!");

// Function GbxAI.AIGroupBlueprintLibrary.ClearTicket
// 0x0018 (0x0018 - 0x0000)
struct AIGroupBlueprintLibrary_ClearTicket final
{
public:
	struct FAITicketHandle                        TicketHandle;                                      // 0x0000(0x0010)(Parm, OutParm, ReferenceParm, NoDestructor, NativeAccessSpecifierPublic)
	float                                         HoldDuration;                                      // 0x0010(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_14[0x4];                                       // 0x0014(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(AIGroupBlueprintLibrary_ClearTicket) == 0x000008, "Wrong alignment on AIGroupBlueprintLibrary_ClearTicket");
static_assert(sizeof(AIGroupBlueprintLibrary_ClearTicket) == 0x000018, "Wrong size on AIGroupBlueprintLibrary_ClearTicket");
static_assert(offsetof(AIGroupBlueprintLibrary_ClearTicket, TicketHandle) == 0x000000, "Member 'AIGroupBlueprintLibrary_ClearTicket::TicketHandle' has a wrong offset!");
static_assert(offsetof(AIGroupBlueprintLibrary_ClearTicket, HoldDuration) == 0x000010, "Member 'AIGroupBlueprintLibrary_ClearTicket::HoldDuration' has a wrong offset!");

// Function GbxAI.AIGroupBlueprintLibrary.IsTicketValid
// 0x0018 (0x0018 - 0x0000)
struct AIGroupBlueprintLibrary_IsTicketValid final
{
public:
	struct FAITicketHandle                        TicketHandle;                                      // 0x0000(0x0010)(Parm, OutParm, ReferenceParm, NoDestructor, NativeAccessSpecifierPublic)
	bool                                          ReturnValue;                                       // 0x0010(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_11[0x7];                                       // 0x0011(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(AIGroupBlueprintLibrary_IsTicketValid) == 0x000008, "Wrong alignment on AIGroupBlueprintLibrary_IsTicketValid");
static_assert(sizeof(AIGroupBlueprintLibrary_IsTicketValid) == 0x000018, "Wrong size on AIGroupBlueprintLibrary_IsTicketValid");
static_assert(offsetof(AIGroupBlueprintLibrary_IsTicketValid, TicketHandle) == 0x000000, "Member 'AIGroupBlueprintLibrary_IsTicketValid::TicketHandle' has a wrong offset!");
static_assert(offsetof(AIGroupBlueprintLibrary_IsTicketValid, ReturnValue) == 0x000010, "Member 'AIGroupBlueprintLibrary_IsTicketValid::ReturnValue' has a wrong offset!");

// Function GbxAI.AIGroupBlueprintLibrary.IsUsingAITicket
// 0x0018 (0x0018 - 0x0000)
struct AIGroupBlueprintLibrary_IsUsingAITicket final
{
public:
	class AAIController*                          AIUser;                                            // 0x0000(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UAITicketDataAsset*                     Ticket;                                            // 0x0008(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bInterruptible;                                    // 0x0010(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          ReturnValue;                                       // 0x0011(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_12[0x6];                                       // 0x0012(0x0006)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(AIGroupBlueprintLibrary_IsUsingAITicket) == 0x000008, "Wrong alignment on AIGroupBlueprintLibrary_IsUsingAITicket");
static_assert(sizeof(AIGroupBlueprintLibrary_IsUsingAITicket) == 0x000018, "Wrong size on AIGroupBlueprintLibrary_IsUsingAITicket");
static_assert(offsetof(AIGroupBlueprintLibrary_IsUsingAITicket, AIUser) == 0x000000, "Member 'AIGroupBlueprintLibrary_IsUsingAITicket::AIUser' has a wrong offset!");
static_assert(offsetof(AIGroupBlueprintLibrary_IsUsingAITicket, Ticket) == 0x000008, "Member 'AIGroupBlueprintLibrary_IsUsingAITicket::Ticket' has a wrong offset!");
static_assert(offsetof(AIGroupBlueprintLibrary_IsUsingAITicket, bInterruptible) == 0x000010, "Member 'AIGroupBlueprintLibrary_IsUsingAITicket::bInterruptible' has a wrong offset!");
static_assert(offsetof(AIGroupBlueprintLibrary_IsUsingAITicket, ReturnValue) == 0x000011, "Member 'AIGroupBlueprintLibrary_IsUsingAITicket::ReturnValue' has a wrong offset!");

// Function GbxAI.AIGroupState.OnThreatActorDied
// 0x0010 (0x0010 - 0x0000)
struct AIGroupState_OnThreatActorDied final
{
public:
	class AActor*                                 DamageReceiver;                                    // 0x0000(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class AActor*                                 DamageCauser;                                      // 0x0008(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(AIGroupState_OnThreatActorDied) == 0x000008, "Wrong alignment on AIGroupState_OnThreatActorDied");
static_assert(sizeof(AIGroupState_OnThreatActorDied) == 0x000010, "Wrong size on AIGroupState_OnThreatActorDied");
static_assert(offsetof(AIGroupState_OnThreatActorDied, DamageReceiver) == 0x000000, "Member 'AIGroupState_OnThreatActorDied::DamageReceiver' has a wrong offset!");
static_assert(offsetof(AIGroupState_OnThreatActorDied, DamageCauser) == 0x000008, "Member 'AIGroupState_OnThreatActorDied::DamageCauser' has a wrong offset!");

// Function GbxAI.AINode.OnPawnArrivedNodeCB
// 0x0010 (0x0010 - 0x0000)
struct AINode_OnPawnArrivedNodeCB final
{
public:
	class AActor*                                 NodeActor;                                         // 0x0000(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class APawn*                                  ArrivedPawn;                                       // 0x0008(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(AINode_OnPawnArrivedNodeCB) == 0x000008, "Wrong alignment on AINode_OnPawnArrivedNodeCB");
static_assert(sizeof(AINode_OnPawnArrivedNodeCB) == 0x000010, "Wrong size on AINode_OnPawnArrivedNodeCB");
static_assert(offsetof(AINode_OnPawnArrivedNodeCB, NodeActor) == 0x000000, "Member 'AINode_OnPawnArrivedNodeCB::NodeActor' has a wrong offset!");
static_assert(offsetof(AINode_OnPawnArrivedNodeCB, ArrivedPawn) == 0x000008, "Member 'AINode_OnPawnArrivedNodeCB::ArrivedPawn' has a wrong offset!");

// Function GbxAI.AINode.OnPawnDepartedNodeCB
// 0x0010 (0x0010 - 0x0000)
struct AINode_OnPawnDepartedNodeCB final
{
public:
	class AActor*                                 NodeActor;                                         // 0x0000(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class APawn*                                  DepartedPawn;                                      // 0x0008(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(AINode_OnPawnDepartedNodeCB) == 0x000008, "Wrong alignment on AINode_OnPawnDepartedNodeCB");
static_assert(sizeof(AINode_OnPawnDepartedNodeCB) == 0x000010, "Wrong size on AINode_OnPawnDepartedNodeCB");
static_assert(offsetof(AINode_OnPawnDepartedNodeCB, NodeActor) == 0x000000, "Member 'AINode_OnPawnDepartedNodeCB::NodeActor' has a wrong offset!");
static_assert(offsetof(AINode_OnPawnDepartedNodeCB, DepartedPawn) == 0x000008, "Member 'AINode_OnPawnDepartedNodeCB::DepartedPawn' has a wrong offset!");

// Function GbxAI.AINodeBlueprintLibrary.ChooseRandomNode
// 0x0018 (0x0018 - 0x0000)
struct AINodeBlueprintLibrary_ChooseRandomNode final
{
public:
	class UObject*                                WorldContextObject;                                // 0x0000(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bIncludeDisabled;                                  // 0x0008(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_9[0x7];                                        // 0x0009(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	class AActor*                                 ReturnValue;                                       // 0x0010(0x0008)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(AINodeBlueprintLibrary_ChooseRandomNode) == 0x000008, "Wrong alignment on AINodeBlueprintLibrary_ChooseRandomNode");
static_assert(sizeof(AINodeBlueprintLibrary_ChooseRandomNode) == 0x000018, "Wrong size on AINodeBlueprintLibrary_ChooseRandomNode");
static_assert(offsetof(AINodeBlueprintLibrary_ChooseRandomNode, WorldContextObject) == 0x000000, "Member 'AINodeBlueprintLibrary_ChooseRandomNode::WorldContextObject' has a wrong offset!");
static_assert(offsetof(AINodeBlueprintLibrary_ChooseRandomNode, bIncludeDisabled) == 0x000008, "Member 'AINodeBlueprintLibrary_ChooseRandomNode::bIncludeDisabled' has a wrong offset!");
static_assert(offsetof(AINodeBlueprintLibrary_ChooseRandomNode, ReturnValue) == 0x000010, "Member 'AINodeBlueprintLibrary_ChooseRandomNode::ReturnValue' has a wrong offset!");

// Function GbxAI.AINodeBlueprintLibrary.FindAllNodes
// 0x0020 (0x0020 - 0x0000)
struct AINodeBlueprintLibrary_FindAllNodes final
{
public:
	TArray<class AActor*>                         OutputNodes;                                       // 0x0000(0x0010)(Parm, OutParm, ZeroConstructor, NativeAccessSpecifierPublic)
	class UObject*                                WorldContextObject;                                // 0x0010(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bIncludeDisabled;                                  // 0x0018(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_19[0x7];                                       // 0x0019(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(AINodeBlueprintLibrary_FindAllNodes) == 0x000008, "Wrong alignment on AINodeBlueprintLibrary_FindAllNodes");
static_assert(sizeof(AINodeBlueprintLibrary_FindAllNodes) == 0x000020, "Wrong size on AINodeBlueprintLibrary_FindAllNodes");
static_assert(offsetof(AINodeBlueprintLibrary_FindAllNodes, OutputNodes) == 0x000000, "Member 'AINodeBlueprintLibrary_FindAllNodes::OutputNodes' has a wrong offset!");
static_assert(offsetof(AINodeBlueprintLibrary_FindAllNodes, WorldContextObject) == 0x000010, "Member 'AINodeBlueprintLibrary_FindAllNodes::WorldContextObject' has a wrong offset!");
static_assert(offsetof(AINodeBlueprintLibrary_FindAllNodes, bIncludeDisabled) == 0x000018, "Member 'AINodeBlueprintLibrary_FindAllNodes::bIncludeDisabled' has a wrong offset!");

// Function GbxAI.AINodeBlueprintLibrary.FindNearestNode
// 0x0020 (0x0020 - 0x0000)
struct AINodeBlueprintLibrary_FindNearestNode final
{
public:
	class UObject*                                WorldContextObject;                                // 0x0000(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                Location;                                          // 0x0008(0x000C)(ConstParm, Parm, OutParm, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bIncludeDisabled;                                  // 0x0014(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_15[0x3];                                       // 0x0015(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	class AActor*                                 ReturnValue;                                       // 0x0018(0x0008)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(AINodeBlueprintLibrary_FindNearestNode) == 0x000008, "Wrong alignment on AINodeBlueprintLibrary_FindNearestNode");
static_assert(sizeof(AINodeBlueprintLibrary_FindNearestNode) == 0x000020, "Wrong size on AINodeBlueprintLibrary_FindNearestNode");
static_assert(offsetof(AINodeBlueprintLibrary_FindNearestNode, WorldContextObject) == 0x000000, "Member 'AINodeBlueprintLibrary_FindNearestNode::WorldContextObject' has a wrong offset!");
static_assert(offsetof(AINodeBlueprintLibrary_FindNearestNode, Location) == 0x000008, "Member 'AINodeBlueprintLibrary_FindNearestNode::Location' has a wrong offset!");
static_assert(offsetof(AINodeBlueprintLibrary_FindNearestNode, bIncludeDisabled) == 0x000014, "Member 'AINodeBlueprintLibrary_FindNearestNode::bIncludeDisabled' has a wrong offset!");
static_assert(offsetof(AINodeBlueprintLibrary_FindNearestNode, ReturnValue) == 0x000018, "Member 'AINodeBlueprintLibrary_FindNearestNode::ReturnValue' has a wrong offset!");

// Function GbxAI.AINodeComponent.BreakLinkTo
// 0x0010 (0x0010 - 0x0000)
struct AINodeComponent_BreakLinkTo final
{
public:
	class AActor*                                 Node;                                              // 0x0000(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          ReturnValue;                                       // 0x0008(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_9[0x7];                                        // 0x0009(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(AINodeComponent_BreakLinkTo) == 0x000008, "Wrong alignment on AINodeComponent_BreakLinkTo");
static_assert(sizeof(AINodeComponent_BreakLinkTo) == 0x000010, "Wrong size on AINodeComponent_BreakLinkTo");
static_assert(offsetof(AINodeComponent_BreakLinkTo, Node) == 0x000000, "Member 'AINodeComponent_BreakLinkTo::Node' has a wrong offset!");
static_assert(offsetof(AINodeComponent_BreakLinkTo, ReturnValue) == 0x000008, "Member 'AINodeComponent_BreakLinkTo::ReturnValue' has a wrong offset!");

// Function GbxAI.AINodeComponent.CreateLinkTo
// 0x0010 (0x0010 - 0x0000)
struct AINodeComponent_CreateLinkTo final
{
public:
	class AActor*                                 Node;                                              // 0x0000(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         Weight;                                            // 0x0008(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_C[0x4];                                        // 0x000C(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(AINodeComponent_CreateLinkTo) == 0x000008, "Wrong alignment on AINodeComponent_CreateLinkTo");
static_assert(sizeof(AINodeComponent_CreateLinkTo) == 0x000010, "Wrong size on AINodeComponent_CreateLinkTo");
static_assert(offsetof(AINodeComponent_CreateLinkTo, Node) == 0x000000, "Member 'AINodeComponent_CreateLinkTo::Node' has a wrong offset!");
static_assert(offsetof(AINodeComponent_CreateLinkTo, Weight) == 0x000008, "Member 'AINodeComponent_CreateLinkTo::Weight' has a wrong offset!");

// Function GbxAI.AINodeComponent.GetLinkedNode
// 0x0010 (0x0010 - 0x0000)
struct AINodeComponent_GetLinkedNode final
{
public:
	int32                                         I;                                                 // 0x0000(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_4[0x4];                                        // 0x0004(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class AActor*                                 ReturnValue;                                       // 0x0008(0x0008)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(AINodeComponent_GetLinkedNode) == 0x000008, "Wrong alignment on AINodeComponent_GetLinkedNode");
static_assert(sizeof(AINodeComponent_GetLinkedNode) == 0x000010, "Wrong size on AINodeComponent_GetLinkedNode");
static_assert(offsetof(AINodeComponent_GetLinkedNode, I) == 0x000000, "Member 'AINodeComponent_GetLinkedNode::I' has a wrong offset!");
static_assert(offsetof(AINodeComponent_GetLinkedNode, ReturnValue) == 0x000008, "Member 'AINodeComponent_GetLinkedNode::ReturnValue' has a wrong offset!");

// Function GbxAI.AINodeComponent.GetLinkedNodeNum
// 0x0004 (0x0004 - 0x0000)
struct AINodeComponent_GetLinkedNodeNum final
{
public:
	int32                                         ReturnValue;                                       // 0x0000(0x0004)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(AINodeComponent_GetLinkedNodeNum) == 0x000004, "Wrong alignment on AINodeComponent_GetLinkedNodeNum");
static_assert(sizeof(AINodeComponent_GetLinkedNodeNum) == 0x000004, "Wrong size on AINodeComponent_GetLinkedNodeNum");
static_assert(offsetof(AINodeComponent_GetLinkedNodeNum, ReturnValue) == 0x000000, "Member 'AINodeComponent_GetLinkedNodeNum::ReturnValue' has a wrong offset!");

// Function GbxAI.AINodeComponent.HasArrived
// 0x0014 (0x0014 - 0x0000)
struct AINodeComponent_HasArrived final
{
public:
	struct FVector                                Point;                                             // 0x0000(0x000C)(Parm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         Error;                                             // 0x000C(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          ReturnValue;                                       // 0x0010(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_11[0x3];                                       // 0x0011(0x0003)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(AINodeComponent_HasArrived) == 0x000004, "Wrong alignment on AINodeComponent_HasArrived");
static_assert(sizeof(AINodeComponent_HasArrived) == 0x000014, "Wrong size on AINodeComponent_HasArrived");
static_assert(offsetof(AINodeComponent_HasArrived, Point) == 0x000000, "Member 'AINodeComponent_HasArrived::Point' has a wrong offset!");
static_assert(offsetof(AINodeComponent_HasArrived, Error) == 0x00000C, "Member 'AINodeComponent_HasArrived::Error' has a wrong offset!");
static_assert(offsetof(AINodeComponent_HasArrived, ReturnValue) == 0x000010, "Member 'AINodeComponent_HasArrived::ReturnValue' has a wrong offset!");

// Function GbxAI.AINodeComponent.HasLinkFrom
// 0x0010 (0x0010 - 0x0000)
struct AINodeComponent_HasLinkFrom final
{
public:
	class AActor*                                 Node;                                              // 0x0000(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          ReturnValue;                                       // 0x0008(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_9[0x7];                                        // 0x0009(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(AINodeComponent_HasLinkFrom) == 0x000008, "Wrong alignment on AINodeComponent_HasLinkFrom");
static_assert(sizeof(AINodeComponent_HasLinkFrom) == 0x000010, "Wrong size on AINodeComponent_HasLinkFrom");
static_assert(offsetof(AINodeComponent_HasLinkFrom, Node) == 0x000000, "Member 'AINodeComponent_HasLinkFrom::Node' has a wrong offset!");
static_assert(offsetof(AINodeComponent_HasLinkFrom, ReturnValue) == 0x000008, "Member 'AINodeComponent_HasLinkFrom::ReturnValue' has a wrong offset!");

// Function GbxAI.AINodeComponent.HasLinkTo
// 0x0010 (0x0010 - 0x0000)
struct AINodeComponent_HasLinkTo final
{
public:
	class AActor*                                 Node;                                              // 0x0000(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          ReturnValue;                                       // 0x0008(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_9[0x7];                                        // 0x0009(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(AINodeComponent_HasLinkTo) == 0x000008, "Wrong alignment on AINodeComponent_HasLinkTo");
static_assert(sizeof(AINodeComponent_HasLinkTo) == 0x000010, "Wrong size on AINodeComponent_HasLinkTo");
static_assert(offsetof(AINodeComponent_HasLinkTo, Node) == 0x000000, "Member 'AINodeComponent_HasLinkTo::Node' has a wrong offset!");
static_assert(offsetof(AINodeComponent_HasLinkTo, ReturnValue) == 0x000008, "Member 'AINodeComponent_HasLinkTo::ReturnValue' has a wrong offset!");

// Function GbxAI.AINodeComponent.SelectNextNode
// 0x0008 (0x0008 - 0x0000)
struct AINodeComponent_SelectNextNode final
{
public:
	class AActor*                                 ReturnValue;                                       // 0x0000(0x0008)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(AINodeComponent_SelectNextNode) == 0x000008, "Wrong alignment on AINodeComponent_SelectNextNode");
static_assert(sizeof(AINodeComponent_SelectNextNode) == 0x000008, "Wrong size on AINodeComponent_SelectNextNode");
static_assert(offsetof(AINodeComponent_SelectNextNode, ReturnValue) == 0x000000, "Member 'AINodeComponent_SelectNextNode::ReturnValue' has a wrong offset!");

// Function GbxAI.AITargetingBlueprintLibrary.AICanCommunicate
// 0x0018 (0x0018 - 0x0000)
struct AITargetingBlueprintLibrary_AICanCommunicate final
{
public:
	class AActor*                                 AIActor;                                           // 0x0000(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         Radius;                                            // 0x0008(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         MinSenseAgeDelta;                                  // 0x000C(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          ReturnValue;                                       // 0x0010(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_11[0x7];                                       // 0x0011(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(AITargetingBlueprintLibrary_AICanCommunicate) == 0x000008, "Wrong alignment on AITargetingBlueprintLibrary_AICanCommunicate");
static_assert(sizeof(AITargetingBlueprintLibrary_AICanCommunicate) == 0x000018, "Wrong size on AITargetingBlueprintLibrary_AICanCommunicate");
static_assert(offsetof(AITargetingBlueprintLibrary_AICanCommunicate, AIActor) == 0x000000, "Member 'AITargetingBlueprintLibrary_AICanCommunicate::AIActor' has a wrong offset!");
static_assert(offsetof(AITargetingBlueprintLibrary_AICanCommunicate, Radius) == 0x000008, "Member 'AITargetingBlueprintLibrary_AICanCommunicate::Radius' has a wrong offset!");
static_assert(offsetof(AITargetingBlueprintLibrary_AICanCommunicate, MinSenseAgeDelta) == 0x00000C, "Member 'AITargetingBlueprintLibrary_AICanCommunicate::MinSenseAgeDelta' has a wrong offset!");
static_assert(offsetof(AITargetingBlueprintLibrary_AICanCommunicate, ReturnValue) == 0x000010, "Member 'AITargetingBlueprintLibrary_AICanCommunicate::ReturnValue' has a wrong offset!");

// Function GbxAI.AITargetingBlueprintLibrary.AIGetScriptedTarget
// 0x0010 (0x0010 - 0x0000)
struct AITargetingBlueprintLibrary_AIGetScriptedTarget final
{
public:
	class AActor*                                 AIActor;                                           // 0x0000(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class AActor*                                 ReturnValue;                                       // 0x0008(0x0008)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(AITargetingBlueprintLibrary_AIGetScriptedTarget) == 0x000008, "Wrong alignment on AITargetingBlueprintLibrary_AIGetScriptedTarget");
static_assert(sizeof(AITargetingBlueprintLibrary_AIGetScriptedTarget) == 0x000010, "Wrong size on AITargetingBlueprintLibrary_AIGetScriptedTarget");
static_assert(offsetof(AITargetingBlueprintLibrary_AIGetScriptedTarget, AIActor) == 0x000000, "Member 'AITargetingBlueprintLibrary_AIGetScriptedTarget::AIActor' has a wrong offset!");
static_assert(offsetof(AITargetingBlueprintLibrary_AIGetScriptedTarget, ReturnValue) == 0x000008, "Member 'AITargetingBlueprintLibrary_AIGetScriptedTarget::ReturnValue' has a wrong offset!");

// Function GbxAI.AITargetingBlueprintLibrary.AIPlayerProvoke
// 0x0008 (0x0008 - 0x0000)
struct AITargetingBlueprintLibrary_AIPlayerProvoke final
{
public:
	class AActor*                                 AITarget;                                          // 0x0000(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(AITargetingBlueprintLibrary_AIPlayerProvoke) == 0x000008, "Wrong alignment on AITargetingBlueprintLibrary_AIPlayerProvoke");
static_assert(sizeof(AITargetingBlueprintLibrary_AIPlayerProvoke) == 0x000008, "Wrong size on AITargetingBlueprintLibrary_AIPlayerProvoke");
static_assert(offsetof(AITargetingBlueprintLibrary_AIPlayerProvoke, AITarget) == 0x000000, "Member 'AITargetingBlueprintLibrary_AIPlayerProvoke::AITarget' has a wrong offset!");

// Function GbxAI.AITargetingBlueprintLibrary.AIProvoke
// 0x0010 (0x0010 - 0x0000)
struct AITargetingBlueprintLibrary_AIProvoke final
{
public:
	class AActor*                                 AITarget;                                          // 0x0000(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class AActor*                                 Source;                                            // 0x0008(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(AITargetingBlueprintLibrary_AIProvoke) == 0x000008, "Wrong alignment on AITargetingBlueprintLibrary_AIProvoke");
static_assert(sizeof(AITargetingBlueprintLibrary_AIProvoke) == 0x000010, "Wrong size on AITargetingBlueprintLibrary_AIProvoke");
static_assert(offsetof(AITargetingBlueprintLibrary_AIProvoke, AITarget) == 0x000000, "Member 'AITargetingBlueprintLibrary_AIProvoke::AITarget' has a wrong offset!");
static_assert(offsetof(AITargetingBlueprintLibrary_AIProvoke, Source) == 0x000008, "Member 'AITargetingBlueprintLibrary_AIProvoke::Source' has a wrong offset!");

// Function GbxAI.AITargetingBlueprintLibrary.AIProvokeSpecificSense
// 0x0028 (0x0028 - 0x0000)
struct AITargetingBlueprintLibrary_AIProvokeSpecificSense final
{
public:
	class AActor*                                 AITarget;                                          // 0x0000(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class AActor*                                 Source;                                            // 0x0008(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TSubclassOf<class UAISense>                   SenseType;                                         // 0x0010(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                StimulusLocation;                                  // 0x0018(0x000C)(Parm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_24[0x4];                                       // 0x0024(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(AITargetingBlueprintLibrary_AIProvokeSpecificSense) == 0x000008, "Wrong alignment on AITargetingBlueprintLibrary_AIProvokeSpecificSense");
static_assert(sizeof(AITargetingBlueprintLibrary_AIProvokeSpecificSense) == 0x000028, "Wrong size on AITargetingBlueprintLibrary_AIProvokeSpecificSense");
static_assert(offsetof(AITargetingBlueprintLibrary_AIProvokeSpecificSense, AITarget) == 0x000000, "Member 'AITargetingBlueprintLibrary_AIProvokeSpecificSense::AITarget' has a wrong offset!");
static_assert(offsetof(AITargetingBlueprintLibrary_AIProvokeSpecificSense, Source) == 0x000008, "Member 'AITargetingBlueprintLibrary_AIProvokeSpecificSense::Source' has a wrong offset!");
static_assert(offsetof(AITargetingBlueprintLibrary_AIProvokeSpecificSense, SenseType) == 0x000010, "Member 'AITargetingBlueprintLibrary_AIProvokeSpecificSense::SenseType' has a wrong offset!");
static_assert(offsetof(AITargetingBlueprintLibrary_AIProvokeSpecificSense, StimulusLocation) == 0x000018, "Member 'AITargetingBlueprintLibrary_AIProvokeSpecificSense::StimulusLocation' has a wrong offset!");

// Function GbxAI.AITargetingBlueprintLibrary.AISendCommunication
// 0x0010 (0x0010 - 0x0000)
struct AITargetingBlueprintLibrary_AISendCommunication final
{
public:
	class AActor*                                 AIActor;                                           // 0x0000(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         Radius;                                            // 0x0008(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_C[0x4];                                        // 0x000C(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(AITargetingBlueprintLibrary_AISendCommunication) == 0x000008, "Wrong alignment on AITargetingBlueprintLibrary_AISendCommunication");
static_assert(sizeof(AITargetingBlueprintLibrary_AISendCommunication) == 0x000010, "Wrong size on AITargetingBlueprintLibrary_AISendCommunication");
static_assert(offsetof(AITargetingBlueprintLibrary_AISendCommunication, AIActor) == 0x000000, "Member 'AITargetingBlueprintLibrary_AISendCommunication::AIActor' has a wrong offset!");
static_assert(offsetof(AITargetingBlueprintLibrary_AISendCommunication, Radius) == 0x000008, "Member 'AITargetingBlueprintLibrary_AISendCommunication::Radius' has a wrong offset!");

// Function GbxAI.AITargetingBlueprintLibrary.AISetScriptedTarget
// 0x0010 (0x0010 - 0x0000)
struct AITargetingBlueprintLibrary_AISetScriptedTarget final
{
public:
	class AActor*                                 AIActor;                                           // 0x0000(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class AActor*                                 TargetActor;                                       // 0x0008(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(AITargetingBlueprintLibrary_AISetScriptedTarget) == 0x000008, "Wrong alignment on AITargetingBlueprintLibrary_AISetScriptedTarget");
static_assert(sizeof(AITargetingBlueprintLibrary_AISetScriptedTarget) == 0x000010, "Wrong size on AITargetingBlueprintLibrary_AISetScriptedTarget");
static_assert(offsetof(AITargetingBlueprintLibrary_AISetScriptedTarget, AIActor) == 0x000000, "Member 'AITargetingBlueprintLibrary_AISetScriptedTarget::AIActor' has a wrong offset!");
static_assert(offsetof(AITargetingBlueprintLibrary_AISetScriptedTarget, TargetActor) == 0x000008, "Member 'AITargetingBlueprintLibrary_AISetScriptedTarget::TargetActor' has a wrong offset!");

// Function GbxAI.AITargetingBlueprintLibrary.AISetTargetInBlackboard
// 0x0020 (0x0020 - 0x0000)
struct AITargetingBlueprintLibrary_AISetTargetInBlackboard final
{
public:
	class AActor*                                 AIActor;                                           // 0x0000(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FGbxBlackboardKeySelector              Key;                                               // 0x0008(0x0010)(ConstParm, Parm, OutParm, ReferenceParm, NoDestructor, NativeAccessSpecifierPublic)
	int32                                         TargetIndex;                                       // 0x0018(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1C[0x4];                                       // 0x001C(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(AITargetingBlueprintLibrary_AISetTargetInBlackboard) == 0x000008, "Wrong alignment on AITargetingBlueprintLibrary_AISetTargetInBlackboard");
static_assert(sizeof(AITargetingBlueprintLibrary_AISetTargetInBlackboard) == 0x000020, "Wrong size on AITargetingBlueprintLibrary_AISetTargetInBlackboard");
static_assert(offsetof(AITargetingBlueprintLibrary_AISetTargetInBlackboard, AIActor) == 0x000000, "Member 'AITargetingBlueprintLibrary_AISetTargetInBlackboard::AIActor' has a wrong offset!");
static_assert(offsetof(AITargetingBlueprintLibrary_AISetTargetInBlackboard, Key) == 0x000008, "Member 'AITargetingBlueprintLibrary_AISetTargetInBlackboard::Key' has a wrong offset!");
static_assert(offsetof(AITargetingBlueprintLibrary_AISetTargetInBlackboard, TargetIndex) == 0x000018, "Member 'AITargetingBlueprintLibrary_AISetTargetInBlackboard::TargetIndex' has a wrong offset!");

// Function GbxAI.AITargetingBlueprintLibrary.ApplyTargetScoringBoost
// 0x0018 (0x0018 - 0x0000)
struct AITargetingBlueprintLibrary_ApplyTargetScoringBoost final
{
public:
	class AActor*                                 TargetActor;                                       // 0x0000(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   BoostName;                                         // 0x0008(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EAITargetScoringBoost                         ScoringBoost;                                      // 0x0010(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_11[0x3];                                       // 0x0011(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         DurationInSeconds;                                 // 0x0014(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(AITargetingBlueprintLibrary_ApplyTargetScoringBoost) == 0x000008, "Wrong alignment on AITargetingBlueprintLibrary_ApplyTargetScoringBoost");
static_assert(sizeof(AITargetingBlueprintLibrary_ApplyTargetScoringBoost) == 0x000018, "Wrong size on AITargetingBlueprintLibrary_ApplyTargetScoringBoost");
static_assert(offsetof(AITargetingBlueprintLibrary_ApplyTargetScoringBoost, TargetActor) == 0x000000, "Member 'AITargetingBlueprintLibrary_ApplyTargetScoringBoost::TargetActor' has a wrong offset!");
static_assert(offsetof(AITargetingBlueprintLibrary_ApplyTargetScoringBoost, BoostName) == 0x000008, "Member 'AITargetingBlueprintLibrary_ApplyTargetScoringBoost::BoostName' has a wrong offset!");
static_assert(offsetof(AITargetingBlueprintLibrary_ApplyTargetScoringBoost, ScoringBoost) == 0x000010, "Member 'AITargetingBlueprintLibrary_ApplyTargetScoringBoost::ScoringBoost' has a wrong offset!");
static_assert(offsetof(AITargetingBlueprintLibrary_ApplyTargetScoringBoost, DurationInSeconds) == 0x000014, "Member 'AITargetingBlueprintLibrary_ApplyTargetScoringBoost::DurationInSeconds' has a wrong offset!");

// Function GbxAI.AITargetingBlueprintLibrary.CalcTargetGroupLocation
// 0x0020 (0x0020 - 0x0000)
struct AITargetingBlueprintLibrary_CalcTargetGroupLocation final
{
public:
	class AActor*                                 AIActor;                                           // 0x0000(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         GroupDistance;                                     // 0x0008(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                Result;                                            // 0x000C(0x000C)(Parm, OutParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          ReturnValue;                                       // 0x0018(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_19[0x7];                                       // 0x0019(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(AITargetingBlueprintLibrary_CalcTargetGroupLocation) == 0x000008, "Wrong alignment on AITargetingBlueprintLibrary_CalcTargetGroupLocation");
static_assert(sizeof(AITargetingBlueprintLibrary_CalcTargetGroupLocation) == 0x000020, "Wrong size on AITargetingBlueprintLibrary_CalcTargetGroupLocation");
static_assert(offsetof(AITargetingBlueprintLibrary_CalcTargetGroupLocation, AIActor) == 0x000000, "Member 'AITargetingBlueprintLibrary_CalcTargetGroupLocation::AIActor' has a wrong offset!");
static_assert(offsetof(AITargetingBlueprintLibrary_CalcTargetGroupLocation, GroupDistance) == 0x000008, "Member 'AITargetingBlueprintLibrary_CalcTargetGroupLocation::GroupDistance' has a wrong offset!");
static_assert(offsetof(AITargetingBlueprintLibrary_CalcTargetGroupLocation, Result) == 0x00000C, "Member 'AITargetingBlueprintLibrary_CalcTargetGroupLocation::Result' has a wrong offset!");
static_assert(offsetof(AITargetingBlueprintLibrary_CalcTargetGroupLocation, ReturnValue) == 0x000018, "Member 'AITargetingBlueprintLibrary_CalcTargetGroupLocation::ReturnValue' has a wrong offset!");

// Function GbxAI.AITargetingBlueprintLibrary.GetBestKnownLocation
// 0x0028 (0x0028 - 0x0000)
struct AITargetingBlueprintLibrary_GetBestKnownLocation final
{
public:
	class AActor*                                 AIActor;                                           // 0x0000(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class AActor*                                 TargetActor;                                       // 0x0008(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   Socket;                                            // 0x0010(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                ReturnValue;                                       // 0x0018(0x000C)(Parm, OutParm, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_24[0x4];                                       // 0x0024(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(AITargetingBlueprintLibrary_GetBestKnownLocation) == 0x000008, "Wrong alignment on AITargetingBlueprintLibrary_GetBestKnownLocation");
static_assert(sizeof(AITargetingBlueprintLibrary_GetBestKnownLocation) == 0x000028, "Wrong size on AITargetingBlueprintLibrary_GetBestKnownLocation");
static_assert(offsetof(AITargetingBlueprintLibrary_GetBestKnownLocation, AIActor) == 0x000000, "Member 'AITargetingBlueprintLibrary_GetBestKnownLocation::AIActor' has a wrong offset!");
static_assert(offsetof(AITargetingBlueprintLibrary_GetBestKnownLocation, TargetActor) == 0x000008, "Member 'AITargetingBlueprintLibrary_GetBestKnownLocation::TargetActor' has a wrong offset!");
static_assert(offsetof(AITargetingBlueprintLibrary_GetBestKnownLocation, Socket) == 0x000010, "Member 'AITargetingBlueprintLibrary_GetBestKnownLocation::Socket' has a wrong offset!");
static_assert(offsetof(AITargetingBlueprintLibrary_GetBestKnownLocation, ReturnValue) == 0x000018, "Member 'AITargetingBlueprintLibrary_GetBestKnownLocation::ReturnValue' has a wrong offset!");

// Function GbxAI.AITargetingBlueprintLibrary.GetNumTargetsInRange
// 0x0010 (0x0010 - 0x0000)
struct AITargetingBlueprintLibrary_GetNumTargetsInRange final
{
public:
	class AActor*                                 AIActor;                                           // 0x0000(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         Radius;                                            // 0x0008(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         ReturnValue;                                       // 0x000C(0x0004)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(AITargetingBlueprintLibrary_GetNumTargetsInRange) == 0x000008, "Wrong alignment on AITargetingBlueprintLibrary_GetNumTargetsInRange");
static_assert(sizeof(AITargetingBlueprintLibrary_GetNumTargetsInRange) == 0x000010, "Wrong size on AITargetingBlueprintLibrary_GetNumTargetsInRange");
static_assert(offsetof(AITargetingBlueprintLibrary_GetNumTargetsInRange, AIActor) == 0x000000, "Member 'AITargetingBlueprintLibrary_GetNumTargetsInRange::AIActor' has a wrong offset!");
static_assert(offsetof(AITargetingBlueprintLibrary_GetNumTargetsInRange, Radius) == 0x000008, "Member 'AITargetingBlueprintLibrary_GetNumTargetsInRange::Radius' has a wrong offset!");
static_assert(offsetof(AITargetingBlueprintLibrary_GetNumTargetsInRange, ReturnValue) == 0x00000C, "Member 'AITargetingBlueprintLibrary_GetNumTargetsInRange::ReturnValue' has a wrong offset!");

// Function GbxAI.AITargetingBlueprintLibrary.GetTargetSenseAge
// 0x03A0 (0x03A0 - 0x0000)
struct AITargetingBlueprintLibrary_GetTargetSenseAge final
{
public:
	struct FTargetActorInfo                       TargetInfo;                                        // 0x0000(0x0390)(ConstParm, Parm, OutParm, ReferenceParm, NoDestructor, ContainsInstancedReference, NativeAccessSpecifierPublic)
	TSubclassOf<class UAISense>                   Sense;                                             // 0x0390(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         ReturnValue;                                       // 0x0398(0x0004)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_39C[0x4];                                      // 0x039C(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(AITargetingBlueprintLibrary_GetTargetSenseAge) == 0x000008, "Wrong alignment on AITargetingBlueprintLibrary_GetTargetSenseAge");
static_assert(sizeof(AITargetingBlueprintLibrary_GetTargetSenseAge) == 0x0003A0, "Wrong size on AITargetingBlueprintLibrary_GetTargetSenseAge");
static_assert(offsetof(AITargetingBlueprintLibrary_GetTargetSenseAge, TargetInfo) == 0x000000, "Member 'AITargetingBlueprintLibrary_GetTargetSenseAge::TargetInfo' has a wrong offset!");
static_assert(offsetof(AITargetingBlueprintLibrary_GetTargetSenseAge, Sense) == 0x000390, "Member 'AITargetingBlueprintLibrary_GetTargetSenseAge::Sense' has a wrong offset!");
static_assert(offsetof(AITargetingBlueprintLibrary_GetTargetSenseAge, ReturnValue) == 0x000398, "Member 'AITargetingBlueprintLibrary_GetTargetSenseAge::ReturnValue' has a wrong offset!");

// Function GbxAI.AITargetingBlueprintLibrary.IsThreatenedBy
// 0x0018 (0x0018 - 0x0000)
struct AITargetingBlueprintLibrary_IsThreatenedBy final
{
public:
	class AActor*                                 AIActor;                                           // 0x0000(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class AActor*                                 Target;                                            // 0x0008(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          ReturnValue;                                       // 0x0010(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_11[0x7];                                       // 0x0011(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(AITargetingBlueprintLibrary_IsThreatenedBy) == 0x000008, "Wrong alignment on AITargetingBlueprintLibrary_IsThreatenedBy");
static_assert(sizeof(AITargetingBlueprintLibrary_IsThreatenedBy) == 0x000018, "Wrong size on AITargetingBlueprintLibrary_IsThreatenedBy");
static_assert(offsetof(AITargetingBlueprintLibrary_IsThreatenedBy, AIActor) == 0x000000, "Member 'AITargetingBlueprintLibrary_IsThreatenedBy::AIActor' has a wrong offset!");
static_assert(offsetof(AITargetingBlueprintLibrary_IsThreatenedBy, Target) == 0x000008, "Member 'AITargetingBlueprintLibrary_IsThreatenedBy::Target' has a wrong offset!");
static_assert(offsetof(AITargetingBlueprintLibrary_IsThreatenedBy, ReturnValue) == 0x000010, "Member 'AITargetingBlueprintLibrary_IsThreatenedBy::ReturnValue' has a wrong offset!");

// Function GbxAI.AITargetingBlueprintLibrary.IsThreatenedByInfo
// 0x03A0 (0x03A0 - 0x0000)
struct AITargetingBlueprintLibrary_IsThreatenedByInfo final
{
public:
	class AActor*                                 AIActor;                                           // 0x0000(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FTargetActorInfo                       TargetInfo;                                        // 0x0008(0x0390)(ConstParm, Parm, OutParm, ReferenceParm, NoDestructor, ContainsInstancedReference, NativeAccessSpecifierPublic)
	bool                                          ReturnValue;                                       // 0x0398(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_399[0x7];                                      // 0x0399(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(AITargetingBlueprintLibrary_IsThreatenedByInfo) == 0x000008, "Wrong alignment on AITargetingBlueprintLibrary_IsThreatenedByInfo");
static_assert(sizeof(AITargetingBlueprintLibrary_IsThreatenedByInfo) == 0x0003A0, "Wrong size on AITargetingBlueprintLibrary_IsThreatenedByInfo");
static_assert(offsetof(AITargetingBlueprintLibrary_IsThreatenedByInfo, AIActor) == 0x000000, "Member 'AITargetingBlueprintLibrary_IsThreatenedByInfo::AIActor' has a wrong offset!");
static_assert(offsetof(AITargetingBlueprintLibrary_IsThreatenedByInfo, TargetInfo) == 0x000008, "Member 'AITargetingBlueprintLibrary_IsThreatenedByInfo::TargetInfo' has a wrong offset!");
static_assert(offsetof(AITargetingBlueprintLibrary_IsThreatenedByInfo, ReturnValue) == 0x000398, "Member 'AITargetingBlueprintLibrary_IsThreatenedByInfo::ReturnValue' has a wrong offset!");

// Function GbxAI.AIUseComponent.GetCurrentObject
// 0x0008 (0x0008 - 0x0000)
struct AIUseComponent_GetCurrentObject final
{
public:
	class AActor*                                 ReturnValue;                                       // 0x0000(0x0008)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(AIUseComponent_GetCurrentObject) == 0x000008, "Wrong alignment on AIUseComponent_GetCurrentObject");
static_assert(sizeof(AIUseComponent_GetCurrentObject) == 0x000008, "Wrong size on AIUseComponent_GetCurrentObject");
static_assert(offsetof(AIUseComponent_GetCurrentObject, ReturnValue) == 0x000000, "Member 'AIUseComponent_GetCurrentObject::ReturnValue' has a wrong offset!");

// Function GbxAI.AIUseComponent.OnUseCompleted
// 0x0010 (0x0010 - 0x0000)
struct AIUseComponent_OnUseCompleted final
{
public:
	class UAITask*                                Task;                                              // 0x0000(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	ESmartObjectTaskResult                        Result;                                            // 0x0008(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_9[0x7];                                        // 0x0009(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(AIUseComponent_OnUseCompleted) == 0x000008, "Wrong alignment on AIUseComponent_OnUseCompleted");
static_assert(sizeof(AIUseComponent_OnUseCompleted) == 0x000010, "Wrong size on AIUseComponent_OnUseCompleted");
static_assert(offsetof(AIUseComponent_OnUseCompleted, Task) == 0x000000, "Member 'AIUseComponent_OnUseCompleted::Task' has a wrong offset!");
static_assert(offsetof(AIUseComponent_OnUseCompleted, Result) == 0x000008, "Member 'AIUseComponent_OnUseCompleted::Result' has a wrong offset!");

// Function GbxAI.AIUseComponent.RequestUse
// 0x0018 (0x0018 - 0x0000)
struct AIUseComponent_RequestUse final
{
public:
	class AActor*                                 SmartObject;                                       // 0x0000(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FGameplayTag                           ActionName;                                        // 0x0008(0x0008)(Parm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bAbortExisting;                                    // 0x0010(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bUntilInterrupted;                                 // 0x0011(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          ReturnValue;                                       // 0x0012(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_13[0x5];                                       // 0x0013(0x0005)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(AIUseComponent_RequestUse) == 0x000008, "Wrong alignment on AIUseComponent_RequestUse");
static_assert(sizeof(AIUseComponent_RequestUse) == 0x000018, "Wrong size on AIUseComponent_RequestUse");
static_assert(offsetof(AIUseComponent_RequestUse, SmartObject) == 0x000000, "Member 'AIUseComponent_RequestUse::SmartObject' has a wrong offset!");
static_assert(offsetof(AIUseComponent_RequestUse, ActionName) == 0x000008, "Member 'AIUseComponent_RequestUse::ActionName' has a wrong offset!");
static_assert(offsetof(AIUseComponent_RequestUse, bAbortExisting) == 0x000010, "Member 'AIUseComponent_RequestUse::bAbortExisting' has a wrong offset!");
static_assert(offsetof(AIUseComponent_RequestUse, bUntilInterrupted) == 0x000011, "Member 'AIUseComponent_RequestUse::bUntilInterrupted' has a wrong offset!");
static_assert(offsetof(AIUseComponent_RequestUse, ReturnValue) == 0x000012, "Member 'AIUseComponent_RequestUse::ReturnValue' has a wrong offset!");

// Function GbxAI.AIUseComponent.StopUse
// 0x0001 (0x0001 - 0x0000)
struct AIUseComponent_StopUse final
{
public:
	bool                                          bSucceeded;                                        // 0x0000(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(AIUseComponent_StopUse) == 0x000001, "Wrong alignment on AIUseComponent_StopUse");
static_assert(sizeof(AIUseComponent_StopUse) == 0x000001, "Wrong size on AIUseComponent_StopUse");
static_assert(offsetof(AIUseComponent_StopUse, bSucceeded) == 0x000000, "Member 'AIUseComponent_StopUse::bSucceeded' has a wrong offset!");

// Function GbxAI.AIUseSlotComponent.GetAvailableSocketNames
// 0x0010 (0x0010 - 0x0000)
struct AIUseSlotComponent_GetAvailableSocketNames final
{
public:
	TArray<class FName>                           Array;                                             // 0x0000(0x0010)(Parm, OutParm, ZeroConstructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(AIUseSlotComponent_GetAvailableSocketNames) == 0x000008, "Wrong alignment on AIUseSlotComponent_GetAvailableSocketNames");
static_assert(sizeof(AIUseSlotComponent_GetAvailableSocketNames) == 0x000010, "Wrong size on AIUseSlotComponent_GetAvailableSocketNames");
static_assert(offsetof(AIUseSlotComponent_GetAvailableSocketNames, Array) == 0x000000, "Member 'AIUseSlotComponent_GetAvailableSocketNames::Array' has a wrong offset!");

// Function GbxAI.AIWeaponUserComponent.WantsToFire
// 0x0001 (0x0001 - 0x0000)
struct AIWeaponUserComponent_WantsToFire final
{
public:
	bool                                          ReturnValue;                                       // 0x0000(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(AIWeaponUserComponent_WantsToFire) == 0x000001, "Wrong alignment on AIWeaponUserComponent_WantsToFire");
static_assert(sizeof(AIWeaponUserComponent_WantsToFire) == 0x000001, "Wrong size on AIWeaponUserComponent_WantsToFire");
static_assert(offsetof(AIWeaponUserComponent_WantsToFire, ReturnValue) == 0x000000, "Member 'AIWeaponUserComponent_WantsToFire::ReturnValue' has a wrong offset!");

// Function GbxAI.CoverSlotComponent.SetEnabled
// 0x0001 (0x0001 - 0x0000)
struct CoverSlotComponent_SetEnabled final
{
public:
	bool                                          bNewEnabled;                                       // 0x0000(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(CoverSlotComponent_SetEnabled) == 0x000001, "Wrong alignment on CoverSlotComponent_SetEnabled");
static_assert(sizeof(CoverSlotComponent_SetEnabled) == 0x000001, "Wrong size on CoverSlotComponent_SetEnabled");
static_assert(offsetof(CoverSlotComponent_SetEnabled, bNewEnabled) == 0x000000, "Member 'CoverSlotComponent_SetEnabled::bNewEnabled' has a wrong offset!");

// Function GbxAI.CoverSlotComponent.IsEnabled
// 0x0001 (0x0001 - 0x0000)
struct CoverSlotComponent_IsEnabled final
{
public:
	bool                                          ReturnValue;                                       // 0x0000(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(CoverSlotComponent_IsEnabled) == 0x000001, "Wrong alignment on CoverSlotComponent_IsEnabled");
static_assert(sizeof(CoverSlotComponent_IsEnabled) == 0x000001, "Wrong size on CoverSlotComponent_IsEnabled");
static_assert(offsetof(CoverSlotComponent_IsEnabled, ReturnValue) == 0x000000, "Member 'CoverSlotComponent_IsEnabled::ReturnValue' has a wrong offset!");

// Function GbxAI.CoverUserComponent.OnMovementModeChanged
// 0x0010 (0x0010 - 0x0000)
struct CoverUserComponent_OnMovementModeChanged final
{
public:
	class ACharacter*                             Character;                                         // 0x0000(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EMovementMode                                 PrevMovementMode;                                  // 0x0008(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         PreviousCustomMode;                                // 0x0009(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_A[0x6];                                        // 0x000A(0x0006)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(CoverUserComponent_OnMovementModeChanged) == 0x000008, "Wrong alignment on CoverUserComponent_OnMovementModeChanged");
static_assert(sizeof(CoverUserComponent_OnMovementModeChanged) == 0x000010, "Wrong size on CoverUserComponent_OnMovementModeChanged");
static_assert(offsetof(CoverUserComponent_OnMovementModeChanged, Character) == 0x000000, "Member 'CoverUserComponent_OnMovementModeChanged::Character' has a wrong offset!");
static_assert(offsetof(CoverUserComponent_OnMovementModeChanged, PrevMovementMode) == 0x000008, "Member 'CoverUserComponent_OnMovementModeChanged::PrevMovementMode' has a wrong offset!");
static_assert(offsetof(CoverUserComponent_OnMovementModeChanged, PreviousCustomMode) == 0x000009, "Member 'CoverUserComponent_OnMovementModeChanged::PreviousCustomMode' has a wrong offset!");

// Function GbxAI.CoverUserComponent.SetEnterTransitionTable
// 0x0008 (0x0008 - 0x0000)
struct CoverUserComponent_SetEnterTransitionTable final
{
public:
	class UGbxCoverTransitionTable*               NewTable;                                          // 0x0000(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(CoverUserComponent_SetEnterTransitionTable) == 0x000008, "Wrong alignment on CoverUserComponent_SetEnterTransitionTable");
static_assert(sizeof(CoverUserComponent_SetEnterTransitionTable) == 0x000008, "Wrong size on CoverUserComponent_SetEnterTransitionTable");
static_assert(offsetof(CoverUserComponent_SetEnterTransitionTable, NewTable) == 0x000000, "Member 'CoverUserComponent_SetEnterTransitionTable::NewTable' has a wrong offset!");

// Function GbxAI.CoverUserComponent.GetStyle
// 0x0008 (0x0008 - 0x0000)
struct CoverUserComponent_GetStyle final
{
public:
	class UCoverStyleData*                        ReturnValue;                                       // 0x0000(0x0008)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(CoverUserComponent_GetStyle) == 0x000008, "Wrong alignment on CoverUserComponent_GetStyle");
static_assert(sizeof(CoverUserComponent_GetStyle) == 0x000008, "Wrong size on CoverUserComponent_GetStyle");
static_assert(offsetof(CoverUserComponent_GetStyle, ReturnValue) == 0x000000, "Member 'CoverUserComponent_GetStyle::ReturnValue' has a wrong offset!");

// Function GbxAI.GameplayTask_ScriptedCover.BeginScriptedCover
// 0x0018 (0x0018 - 0x0000)
struct GameplayTask_ScriptedCover_BeginScriptedCover final
{
public:
	class AActor*                                 User;                                              // 0x0000(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class ACover*                                 Cover;                                             // 0x0008(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UGameplayTask_ScriptedCover*            ReturnValue;                                       // 0x0010(0x0008)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(GameplayTask_ScriptedCover_BeginScriptedCover) == 0x000008, "Wrong alignment on GameplayTask_ScriptedCover_BeginScriptedCover");
static_assert(sizeof(GameplayTask_ScriptedCover_BeginScriptedCover) == 0x000018, "Wrong size on GameplayTask_ScriptedCover_BeginScriptedCover");
static_assert(offsetof(GameplayTask_ScriptedCover_BeginScriptedCover, User) == 0x000000, "Member 'GameplayTask_ScriptedCover_BeginScriptedCover::User' has a wrong offset!");
static_assert(offsetof(GameplayTask_ScriptedCover_BeginScriptedCover, Cover) == 0x000008, "Member 'GameplayTask_ScriptedCover_BeginScriptedCover::Cover' has a wrong offset!");
static_assert(offsetof(GameplayTask_ScriptedCover_BeginScriptedCover, ReturnValue) == 0x000010, "Member 'GameplayTask_ScriptedCover_BeginScriptedCover::ReturnValue' has a wrong offset!");

// Function GbxAI.GameplayTask_ScriptedCover.EndScriptedCover
// 0x0008 (0x0008 - 0x0000)
struct GameplayTask_ScriptedCover_EndScriptedCover final
{
public:
	class AActor*                                 User;                                              // 0x0000(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(GameplayTask_ScriptedCover_EndScriptedCover) == 0x000008, "Wrong alignment on GameplayTask_ScriptedCover_EndScriptedCover");
static_assert(sizeof(GameplayTask_ScriptedCover_EndScriptedCover) == 0x000008, "Wrong size on GameplayTask_ScriptedCover_EndScriptedCover");
static_assert(offsetof(GameplayTask_ScriptedCover_EndScriptedCover, User) == 0x000000, "Member 'GameplayTask_ScriptedCover_EndScriptedCover::User' has a wrong offset!");

// Function GbxAI.GameplayTask_ScriptedFollow.BeginScriptedFollow
// 0x0020 (0x0020 - 0x0000)
struct GameplayTask_ScriptedFollow_BeginScriptedFollow final
{
public:
	class AActor*                                 Follower;                                          // 0x0000(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class AActor*                                 ActorToFollow_0;                                   // 0x0008(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UStanceDataProvider*                    OptionalStance;                                    // 0x0010(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UGameplayTask_ScriptedFollow*           ReturnValue;                                       // 0x0018(0x0008)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(GameplayTask_ScriptedFollow_BeginScriptedFollow) == 0x000008, "Wrong alignment on GameplayTask_ScriptedFollow_BeginScriptedFollow");
static_assert(sizeof(GameplayTask_ScriptedFollow_BeginScriptedFollow) == 0x000020, "Wrong size on GameplayTask_ScriptedFollow_BeginScriptedFollow");
static_assert(offsetof(GameplayTask_ScriptedFollow_BeginScriptedFollow, Follower) == 0x000000, "Member 'GameplayTask_ScriptedFollow_BeginScriptedFollow::Follower' has a wrong offset!");
static_assert(offsetof(GameplayTask_ScriptedFollow_BeginScriptedFollow, ActorToFollow_0) == 0x000008, "Member 'GameplayTask_ScriptedFollow_BeginScriptedFollow::ActorToFollow_0' has a wrong offset!");
static_assert(offsetof(GameplayTask_ScriptedFollow_BeginScriptedFollow, OptionalStance) == 0x000010, "Member 'GameplayTask_ScriptedFollow_BeginScriptedFollow::OptionalStance' has a wrong offset!");
static_assert(offsetof(GameplayTask_ScriptedFollow_BeginScriptedFollow, ReturnValue) == 0x000018, "Member 'GameplayTask_ScriptedFollow_BeginScriptedFollow::ReturnValue' has a wrong offset!");

// Function GbxAI.GameplayTask_ScriptedLead.BeginScriptedLead
// 0x0028 (0x0028 - 0x0000)
struct GameplayTask_ScriptedLead_BeginScriptedLead final
{
public:
	class AActor*                                 Leader;                                            // 0x0000(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class AActor*                                 DestAINode;                                        // 0x0008(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class AActor*                                 ActorToLead_0;                                     // 0x0010(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UStanceDataProvider*                    OptionalStance;                                    // 0x0018(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UGameplayTask_ScriptedLead*             ReturnValue;                                       // 0x0020(0x0008)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(GameplayTask_ScriptedLead_BeginScriptedLead) == 0x000008, "Wrong alignment on GameplayTask_ScriptedLead_BeginScriptedLead");
static_assert(sizeof(GameplayTask_ScriptedLead_BeginScriptedLead) == 0x000028, "Wrong size on GameplayTask_ScriptedLead_BeginScriptedLead");
static_assert(offsetof(GameplayTask_ScriptedLead_BeginScriptedLead, Leader) == 0x000000, "Member 'GameplayTask_ScriptedLead_BeginScriptedLead::Leader' has a wrong offset!");
static_assert(offsetof(GameplayTask_ScriptedLead_BeginScriptedLead, DestAINode) == 0x000008, "Member 'GameplayTask_ScriptedLead_BeginScriptedLead::DestAINode' has a wrong offset!");
static_assert(offsetof(GameplayTask_ScriptedLead_BeginScriptedLead, ActorToLead_0) == 0x000010, "Member 'GameplayTask_ScriptedLead_BeginScriptedLead::ActorToLead_0' has a wrong offset!");
static_assert(offsetof(GameplayTask_ScriptedLead_BeginScriptedLead, OptionalStance) == 0x000018, "Member 'GameplayTask_ScriptedLead_BeginScriptedLead::OptionalStance' has a wrong offset!");
static_assert(offsetof(GameplayTask_ScriptedLead_BeginScriptedLead, ReturnValue) == 0x000020, "Member 'GameplayTask_ScriptedLead_BeginScriptedLead::ReturnValue' has a wrong offset!");

// Function GbxAI.GameplayTask_ScriptedMoveSpline.BeginScriptedMoveOnSpline
// 0x0040 (0x0040 - 0x0000)
struct GameplayTask_ScriptedMoveSpline_BeginScriptedMoveOnSpline final
{
public:
	class AActor*                                 Target_0;                                          // 0x0000(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class AActor*                                 StartSpline;                                       // 0x0008(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EScriptedActionRule                           SuccessRule;                                       // 0x0010(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, AdvancedDisplay, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EScriptedActionRule                           FailRule;                                          // 0x0011(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, AdvancedDisplay, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_12[0x2];                                       // 0x0012(0x0002)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         Offset;                                            // 0x0014(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, AdvancedDisplay, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bReverse;                                          // 0x0018(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bAddSpawned;                                       // 0x0019(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, AdvancedDisplay, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1A[0x6];                                       // 0x001A(0x0006)(Fixing Size After Last Property [ Dumper-7 ])
	class UStanceDataProvider*                    OptionalStance;                                    // 0x0020(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, AdvancedDisplay, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class AActor*                                 OptionalLookAtActor;                               // 0x0028(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, AdvancedDisplay, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TSubclassOf<class UAIAction>                  OptionalAIAction_0;                                // 0x0030(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, AdvancedDisplay, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UGameplayTask_ScriptedMoveSpline*       ReturnValue;                                       // 0x0038(0x0008)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(GameplayTask_ScriptedMoveSpline_BeginScriptedMoveOnSpline) == 0x000008, "Wrong alignment on GameplayTask_ScriptedMoveSpline_BeginScriptedMoveOnSpline");
static_assert(sizeof(GameplayTask_ScriptedMoveSpline_BeginScriptedMoveOnSpline) == 0x000040, "Wrong size on GameplayTask_ScriptedMoveSpline_BeginScriptedMoveOnSpline");
static_assert(offsetof(GameplayTask_ScriptedMoveSpline_BeginScriptedMoveOnSpline, Target_0) == 0x000000, "Member 'GameplayTask_ScriptedMoveSpline_BeginScriptedMoveOnSpline::Target_0' has a wrong offset!");
static_assert(offsetof(GameplayTask_ScriptedMoveSpline_BeginScriptedMoveOnSpline, StartSpline) == 0x000008, "Member 'GameplayTask_ScriptedMoveSpline_BeginScriptedMoveOnSpline::StartSpline' has a wrong offset!");
static_assert(offsetof(GameplayTask_ScriptedMoveSpline_BeginScriptedMoveOnSpline, SuccessRule) == 0x000010, "Member 'GameplayTask_ScriptedMoveSpline_BeginScriptedMoveOnSpline::SuccessRule' has a wrong offset!");
static_assert(offsetof(GameplayTask_ScriptedMoveSpline_BeginScriptedMoveOnSpline, FailRule) == 0x000011, "Member 'GameplayTask_ScriptedMoveSpline_BeginScriptedMoveOnSpline::FailRule' has a wrong offset!");
static_assert(offsetof(GameplayTask_ScriptedMoveSpline_BeginScriptedMoveOnSpline, Offset) == 0x000014, "Member 'GameplayTask_ScriptedMoveSpline_BeginScriptedMoveOnSpline::Offset' has a wrong offset!");
static_assert(offsetof(GameplayTask_ScriptedMoveSpline_BeginScriptedMoveOnSpline, bReverse) == 0x000018, "Member 'GameplayTask_ScriptedMoveSpline_BeginScriptedMoveOnSpline::bReverse' has a wrong offset!");
static_assert(offsetof(GameplayTask_ScriptedMoveSpline_BeginScriptedMoveOnSpline, bAddSpawned) == 0x000019, "Member 'GameplayTask_ScriptedMoveSpline_BeginScriptedMoveOnSpline::bAddSpawned' has a wrong offset!");
static_assert(offsetof(GameplayTask_ScriptedMoveSpline_BeginScriptedMoveOnSpline, OptionalStance) == 0x000020, "Member 'GameplayTask_ScriptedMoveSpline_BeginScriptedMoveOnSpline::OptionalStance' has a wrong offset!");
static_assert(offsetof(GameplayTask_ScriptedMoveSpline_BeginScriptedMoveOnSpline, OptionalLookAtActor) == 0x000028, "Member 'GameplayTask_ScriptedMoveSpline_BeginScriptedMoveOnSpline::OptionalLookAtActor' has a wrong offset!");
static_assert(offsetof(GameplayTask_ScriptedMoveSpline_BeginScriptedMoveOnSpline, OptionalAIAction_0) == 0x000030, "Member 'GameplayTask_ScriptedMoveSpline_BeginScriptedMoveOnSpline::OptionalAIAction_0' has a wrong offset!");
static_assert(offsetof(GameplayTask_ScriptedMoveSpline_BeginScriptedMoveOnSpline, ReturnValue) == 0x000038, "Member 'GameplayTask_ScriptedMoveSpline_BeginScriptedMoveOnSpline::ReturnValue' has a wrong offset!");

// DelegateFunction GbxAI.GameplayTask_ScriptedMoveSpline.TaskScriptedMoveDelegate__DelegateSignature
// 0x0008 (0x0008 - 0x0000)
struct GameplayTask_ScriptedMoveSpline_TaskScriptedMoveDelegate__DelegateSignature final
{
public:
	class AActor*                                 Targeted;                                          // 0x0000(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(GameplayTask_ScriptedMoveSpline_TaskScriptedMoveDelegate__DelegateSignature) == 0x000008, "Wrong alignment on GameplayTask_ScriptedMoveSpline_TaskScriptedMoveDelegate__DelegateSignature");
static_assert(sizeof(GameplayTask_ScriptedMoveSpline_TaskScriptedMoveDelegate__DelegateSignature) == 0x000008, "Wrong size on GameplayTask_ScriptedMoveSpline_TaskScriptedMoveDelegate__DelegateSignature");
static_assert(offsetof(GameplayTask_ScriptedMoveSpline_TaskScriptedMoveDelegate__DelegateSignature, Targeted) == 0x000000, "Member 'GameplayTask_ScriptedMoveSpline_TaskScriptedMoveDelegate__DelegateSignature::Targeted' has a wrong offset!");

// Function GbxAI.GameplayTask_ScriptedMoveToLevelSequence.BeginScriptedMoveToLevelSequence
// 0x0028 (0x0028 - 0x0000)
struct GameplayTask_ScriptedMoveToLevelSequence_BeginScriptedMoveToLevelSequence final
{
public:
	class AActor*                                 Target;                                            // 0x0000(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class AGbxLevelSequenceActor*                 LevelSequenceActor_0;                              // 0x0008(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bStartSequence;                                    // 0x0010(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_11[0x7];                                       // 0x0011(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	class UStanceDataProvider*                    OptionalStance;                                    // 0x0018(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, AdvancedDisplay, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UGameplayTask_ScriptedMoveToLevelSequence* ReturnValue;                                       // 0x0020(0x0008)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(GameplayTask_ScriptedMoveToLevelSequence_BeginScriptedMoveToLevelSequence) == 0x000008, "Wrong alignment on GameplayTask_ScriptedMoveToLevelSequence_BeginScriptedMoveToLevelSequence");
static_assert(sizeof(GameplayTask_ScriptedMoveToLevelSequence_BeginScriptedMoveToLevelSequence) == 0x000028, "Wrong size on GameplayTask_ScriptedMoveToLevelSequence_BeginScriptedMoveToLevelSequence");
static_assert(offsetof(GameplayTask_ScriptedMoveToLevelSequence_BeginScriptedMoveToLevelSequence, Target) == 0x000000, "Member 'GameplayTask_ScriptedMoveToLevelSequence_BeginScriptedMoveToLevelSequence::Target' has a wrong offset!");
static_assert(offsetof(GameplayTask_ScriptedMoveToLevelSequence_BeginScriptedMoveToLevelSequence, LevelSequenceActor_0) == 0x000008, "Member 'GameplayTask_ScriptedMoveToLevelSequence_BeginScriptedMoveToLevelSequence::LevelSequenceActor_0' has a wrong offset!");
static_assert(offsetof(GameplayTask_ScriptedMoveToLevelSequence_BeginScriptedMoveToLevelSequence, bStartSequence) == 0x000010, "Member 'GameplayTask_ScriptedMoveToLevelSequence_BeginScriptedMoveToLevelSequence::bStartSequence' has a wrong offset!");
static_assert(offsetof(GameplayTask_ScriptedMoveToLevelSequence_BeginScriptedMoveToLevelSequence, OptionalStance) == 0x000018, "Member 'GameplayTask_ScriptedMoveToLevelSequence_BeginScriptedMoveToLevelSequence::OptionalStance' has a wrong offset!");
static_assert(offsetof(GameplayTask_ScriptedMoveToLevelSequence_BeginScriptedMoveToLevelSequence, ReturnValue) == 0x000020, "Member 'GameplayTask_ScriptedMoveToLevelSequence_BeginScriptedMoveToLevelSequence::ReturnValue' has a wrong offset!");

// Function GbxAI.GameplayTask_ScriptedMoveToLevelSequence.BeginScriptedMoveToLevelSequenceMulti
// 0x0030 (0x0030 - 0x0000)
struct GameplayTask_ScriptedMoveToLevelSequence_BeginScriptedMoveToLevelSequenceMulti final
{
public:
	TArray<class AActor*>                         Targets;                                           // 0x0000(0x0010)(ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, NativeAccessSpecifierPublic)
	class AGbxLevelSequenceActor*                 LevelSequenceActor_0;                              // 0x0010(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bStartSequence;                                    // 0x0018(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_19[0x7];                                       // 0x0019(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	class UStanceDataProvider*                    OptionalStance;                                    // 0x0020(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, AdvancedDisplay, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UGameplayTask_ScriptedMoveToLevelSequence* ReturnValue;                                       // 0x0028(0x0008)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(GameplayTask_ScriptedMoveToLevelSequence_BeginScriptedMoveToLevelSequenceMulti) == 0x000008, "Wrong alignment on GameplayTask_ScriptedMoveToLevelSequence_BeginScriptedMoveToLevelSequenceMulti");
static_assert(sizeof(GameplayTask_ScriptedMoveToLevelSequence_BeginScriptedMoveToLevelSequenceMulti) == 0x000030, "Wrong size on GameplayTask_ScriptedMoveToLevelSequence_BeginScriptedMoveToLevelSequenceMulti");
static_assert(offsetof(GameplayTask_ScriptedMoveToLevelSequence_BeginScriptedMoveToLevelSequenceMulti, Targets) == 0x000000, "Member 'GameplayTask_ScriptedMoveToLevelSequence_BeginScriptedMoveToLevelSequenceMulti::Targets' has a wrong offset!");
static_assert(offsetof(GameplayTask_ScriptedMoveToLevelSequence_BeginScriptedMoveToLevelSequenceMulti, LevelSequenceActor_0) == 0x000010, "Member 'GameplayTask_ScriptedMoveToLevelSequence_BeginScriptedMoveToLevelSequenceMulti::LevelSequenceActor_0' has a wrong offset!");
static_assert(offsetof(GameplayTask_ScriptedMoveToLevelSequence_BeginScriptedMoveToLevelSequenceMulti, bStartSequence) == 0x000018, "Member 'GameplayTask_ScriptedMoveToLevelSequence_BeginScriptedMoveToLevelSequenceMulti::bStartSequence' has a wrong offset!");
static_assert(offsetof(GameplayTask_ScriptedMoveToLevelSequence_BeginScriptedMoveToLevelSequenceMulti, OptionalStance) == 0x000020, "Member 'GameplayTask_ScriptedMoveToLevelSequence_BeginScriptedMoveToLevelSequenceMulti::OptionalStance' has a wrong offset!");
static_assert(offsetof(GameplayTask_ScriptedMoveToLevelSequence_BeginScriptedMoveToLevelSequenceMulti, ReturnValue) == 0x000028, "Member 'GameplayTask_ScriptedMoveToLevelSequence_BeginScriptedMoveToLevelSequenceMulti::ReturnValue' has a wrong offset!");

// DelegateFunction GbxAI.GameplayTask_ScriptedMoveToLevelSequence.TaskScriptedMoveActorDelegate__DelegateSignature
// 0x0008 (0x0008 - 0x0000)
struct GameplayTask_ScriptedMoveToLevelSequence_TaskScriptedMoveActorDelegate__DelegateSignature final
{
public:
	class AActor*                                 Actor;                                             // 0x0000(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(GameplayTask_ScriptedMoveToLevelSequence_TaskScriptedMoveActorDelegate__DelegateSignature) == 0x000008, "Wrong alignment on GameplayTask_ScriptedMoveToLevelSequence_TaskScriptedMoveActorDelegate__DelegateSignature");
static_assert(sizeof(GameplayTask_ScriptedMoveToLevelSequence_TaskScriptedMoveActorDelegate__DelegateSignature) == 0x000008, "Wrong size on GameplayTask_ScriptedMoveToLevelSequence_TaskScriptedMoveActorDelegate__DelegateSignature");
static_assert(offsetof(GameplayTask_ScriptedMoveToLevelSequence_TaskScriptedMoveActorDelegate__DelegateSignature, Actor) == 0x000000, "Member 'GameplayTask_ScriptedMoveToLevelSequence_TaskScriptedMoveActorDelegate__DelegateSignature::Actor' has a wrong offset!");

// Function GbxAI.GameplayTask_SmartAction.BeginSmartAction
// 0x0020 (0x0020 - 0x0000)
struct GameplayTask_SmartAction_BeginSmartAction final
{
public:
	class AActor*                                 User;                                              // 0x0000(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class AActor*                                 SmartObject;                                       // 0x0008(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FGameplayTag                           ActionTag;                                         // 0x0010(0x0008)(Parm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UGameplayTask_SmartAction*              ReturnValue;                                       // 0x0018(0x0008)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(GameplayTask_SmartAction_BeginSmartAction) == 0x000008, "Wrong alignment on GameplayTask_SmartAction_BeginSmartAction");
static_assert(sizeof(GameplayTask_SmartAction_BeginSmartAction) == 0x000020, "Wrong size on GameplayTask_SmartAction_BeginSmartAction");
static_assert(offsetof(GameplayTask_SmartAction_BeginSmartAction, User) == 0x000000, "Member 'GameplayTask_SmartAction_BeginSmartAction::User' has a wrong offset!");
static_assert(offsetof(GameplayTask_SmartAction_BeginSmartAction, SmartObject) == 0x000008, "Member 'GameplayTask_SmartAction_BeginSmartAction::SmartObject' has a wrong offset!");
static_assert(offsetof(GameplayTask_SmartAction_BeginSmartAction, ActionTag) == 0x000010, "Member 'GameplayTask_SmartAction_BeginSmartAction::ActionTag' has a wrong offset!");
static_assert(offsetof(GameplayTask_SmartAction_BeginSmartAction, ReturnValue) == 0x000018, "Member 'GameplayTask_SmartAction_BeginSmartAction::ReturnValue' has a wrong offset!");

// Function GbxAI.GameplayTask_SmartAction.EndSmartAction
// 0x0008 (0x0008 - 0x0000)
struct GameplayTask_SmartAction_EndSmartAction final
{
public:
	class AActor*                                 User;                                              // 0x0000(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(GameplayTask_SmartAction_EndSmartAction) == 0x000008, "Wrong alignment on GameplayTask_SmartAction_EndSmartAction");
static_assert(sizeof(GameplayTask_SmartAction_EndSmartAction) == 0x000008, "Wrong size on GameplayTask_SmartAction_EndSmartAction");
static_assert(offsetof(GameplayTask_SmartAction_EndSmartAction, User) == 0x000000, "Member 'GameplayTask_SmartAction_EndSmartAction::User' has a wrong offset!");

// Function GbxAI.GameplayTask_SmartAction.BeginCallback
// 0x0018 (0x0018 - 0x0000)
struct GameplayTask_SmartAction_BeginCallback final
{
public:
	class AActor*                                 User;                                              // 0x0000(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class AActor*                                 SmartObject;                                       // 0x0008(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FGameplayTag                           ActionTag;                                         // 0x0010(0x0008)(Parm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(GameplayTask_SmartAction_BeginCallback) == 0x000008, "Wrong alignment on GameplayTask_SmartAction_BeginCallback");
static_assert(sizeof(GameplayTask_SmartAction_BeginCallback) == 0x000018, "Wrong size on GameplayTask_SmartAction_BeginCallback");
static_assert(offsetof(GameplayTask_SmartAction_BeginCallback, User) == 0x000000, "Member 'GameplayTask_SmartAction_BeginCallback::User' has a wrong offset!");
static_assert(offsetof(GameplayTask_SmartAction_BeginCallback, SmartObject) == 0x000008, "Member 'GameplayTask_SmartAction_BeginCallback::SmartObject' has a wrong offset!");
static_assert(offsetof(GameplayTask_SmartAction_BeginCallback, ActionTag) == 0x000010, "Member 'GameplayTask_SmartAction_BeginCallback::ActionTag' has a wrong offset!");

// Function GbxAI.GameplayTask_SmartAction.InterruptCallback
// 0x0018 (0x0018 - 0x0000)
struct GameplayTask_SmartAction_InterruptCallback final
{
public:
	class AActor*                                 User;                                              // 0x0000(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class AActor*                                 SmartObject;                                       // 0x0008(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FGameplayTag                           ActionTag;                                         // 0x0010(0x0008)(Parm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(GameplayTask_SmartAction_InterruptCallback) == 0x000008, "Wrong alignment on GameplayTask_SmartAction_InterruptCallback");
static_assert(sizeof(GameplayTask_SmartAction_InterruptCallback) == 0x000018, "Wrong size on GameplayTask_SmartAction_InterruptCallback");
static_assert(offsetof(GameplayTask_SmartAction_InterruptCallback, User) == 0x000000, "Member 'GameplayTask_SmartAction_InterruptCallback::User' has a wrong offset!");
static_assert(offsetof(GameplayTask_SmartAction_InterruptCallback, SmartObject) == 0x000008, "Member 'GameplayTask_SmartAction_InterruptCallback::SmartObject' has a wrong offset!");
static_assert(offsetof(GameplayTask_SmartAction_InterruptCallback, ActionTag) == 0x000010, "Member 'GameplayTask_SmartAction_InterruptCallback::ActionTag' has a wrong offset!");

// Function GbxAI.GameplayTask_SmartAction.ReserveCallback
// 0x0018 (0x0018 - 0x0000)
struct GameplayTask_SmartAction_ReserveCallback final
{
public:
	class AActor*                                 User;                                              // 0x0000(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class AActor*                                 SmartObject;                                       // 0x0008(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FGameplayTag                           ActionTag;                                         // 0x0010(0x0008)(Parm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(GameplayTask_SmartAction_ReserveCallback) == 0x000008, "Wrong alignment on GameplayTask_SmartAction_ReserveCallback");
static_assert(sizeof(GameplayTask_SmartAction_ReserveCallback) == 0x000018, "Wrong size on GameplayTask_SmartAction_ReserveCallback");
static_assert(offsetof(GameplayTask_SmartAction_ReserveCallback, User) == 0x000000, "Member 'GameplayTask_SmartAction_ReserveCallback::User' has a wrong offset!");
static_assert(offsetof(GameplayTask_SmartAction_ReserveCallback, SmartObject) == 0x000008, "Member 'GameplayTask_SmartAction_ReserveCallback::SmartObject' has a wrong offset!");
static_assert(offsetof(GameplayTask_SmartAction_ReserveCallback, ActionTag) == 0x000010, "Member 'GameplayTask_SmartAction_ReserveCallback::ActionTag' has a wrong offset!");

// Function GbxAI.GameplayTask_SmartAction.SuccessCallback
// 0x0018 (0x0018 - 0x0000)
struct GameplayTask_SmartAction_SuccessCallback final
{
public:
	class AActor*                                 User;                                              // 0x0000(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class AActor*                                 SmartObject;                                       // 0x0008(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FGameplayTag                           ActionTag;                                         // 0x0010(0x0008)(Parm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(GameplayTask_SmartAction_SuccessCallback) == 0x000008, "Wrong alignment on GameplayTask_SmartAction_SuccessCallback");
static_assert(sizeof(GameplayTask_SmartAction_SuccessCallback) == 0x000018, "Wrong size on GameplayTask_SmartAction_SuccessCallback");
static_assert(offsetof(GameplayTask_SmartAction_SuccessCallback, User) == 0x000000, "Member 'GameplayTask_SmartAction_SuccessCallback::User' has a wrong offset!");
static_assert(offsetof(GameplayTask_SmartAction_SuccessCallback, SmartObject) == 0x000008, "Member 'GameplayTask_SmartAction_SuccessCallback::SmartObject' has a wrong offset!");
static_assert(offsetof(GameplayTask_SmartAction_SuccessCallback, ActionTag) == 0x000010, "Member 'GameplayTask_SmartAction_SuccessCallback::ActionTag' has a wrong offset!");

// Function GbxAI.GameplayTask_SmartAction.UnreserveCallback
// 0x0018 (0x0018 - 0x0000)
struct GameplayTask_SmartAction_UnreserveCallback final
{
public:
	class AActor*                                 User;                                              // 0x0000(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class AActor*                                 SmartObject;                                       // 0x0008(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FGameplayTag                           ActionTag;                                         // 0x0010(0x0008)(Parm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(GameplayTask_SmartAction_UnreserveCallback) == 0x000008, "Wrong alignment on GameplayTask_SmartAction_UnreserveCallback");
static_assert(sizeof(GameplayTask_SmartAction_UnreserveCallback) == 0x000018, "Wrong size on GameplayTask_SmartAction_UnreserveCallback");
static_assert(offsetof(GameplayTask_SmartAction_UnreserveCallback, User) == 0x000000, "Member 'GameplayTask_SmartAction_UnreserveCallback::User' has a wrong offset!");
static_assert(offsetof(GameplayTask_SmartAction_UnreserveCallback, SmartObject) == 0x000008, "Member 'GameplayTask_SmartAction_UnreserveCallback::SmartObject' has a wrong offset!");
static_assert(offsetof(GameplayTask_SmartAction_UnreserveCallback, ActionTag) == 0x000010, "Member 'GameplayTask_SmartAction_UnreserveCallback::ActionTag' has a wrong offset!");

// Function GbxAI.GbxAIBlueprintLibrary.AIIsWithinTerritory
// 0x0010 (0x0010 - 0x0000)
struct GbxAIBlueprintLibrary_AIIsWithinTerritory final
{
public:
	class AActor*                                 AIActor;                                           // 0x0000(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	ETerritoryType                                Zone;                                              // 0x0008(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          ReturnValue;                                       // 0x0009(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_A[0x6];                                        // 0x000A(0x0006)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(GbxAIBlueprintLibrary_AIIsWithinTerritory) == 0x000008, "Wrong alignment on GbxAIBlueprintLibrary_AIIsWithinTerritory");
static_assert(sizeof(GbxAIBlueprintLibrary_AIIsWithinTerritory) == 0x000010, "Wrong size on GbxAIBlueprintLibrary_AIIsWithinTerritory");
static_assert(offsetof(GbxAIBlueprintLibrary_AIIsWithinTerritory, AIActor) == 0x000000, "Member 'GbxAIBlueprintLibrary_AIIsWithinTerritory::AIActor' has a wrong offset!");
static_assert(offsetof(GbxAIBlueprintLibrary_AIIsWithinTerritory, Zone) == 0x000008, "Member 'GbxAIBlueprintLibrary_AIIsWithinTerritory::Zone' has a wrong offset!");
static_assert(offsetof(GbxAIBlueprintLibrary_AIIsWithinTerritory, ReturnValue) == 0x000009, "Member 'GbxAIBlueprintLibrary_AIIsWithinTerritory::ReturnValue' has a wrong offset!");

// Function GbxAI.GbxAIBlueprintLibrary.AIScriptedAction
// 0x0010 (0x0010 - 0x0000)
struct GbxAIBlueprintLibrary_AIScriptedAction final
{
public:
	class AActor*                                 Actor;                                             // 0x0000(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TSubclassOf<class UAIAction>                  Action;                                            // 0x0008(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(GbxAIBlueprintLibrary_AIScriptedAction) == 0x000008, "Wrong alignment on GbxAIBlueprintLibrary_AIScriptedAction");
static_assert(sizeof(GbxAIBlueprintLibrary_AIScriptedAction) == 0x000010, "Wrong size on GbxAIBlueprintLibrary_AIScriptedAction");
static_assert(offsetof(GbxAIBlueprintLibrary_AIScriptedAction, Actor) == 0x000000, "Member 'GbxAIBlueprintLibrary_AIScriptedAction::Actor' has a wrong offset!");
static_assert(offsetof(GbxAIBlueprintLibrary_AIScriptedAction, Action) == 0x000008, "Member 'GbxAIBlueprintLibrary_AIScriptedAction::Action' has a wrong offset!");

// Function GbxAI.GbxAIBlueprintLibrary.AIScriptedUseWeapon
// 0x0010 (0x0010 - 0x0000)
struct GbxAIBlueprintLibrary_AIScriptedUseWeapon final
{
public:
	class AActor*                                 Actor;                                             // 0x0000(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bUseWeapon;                                        // 0x0008(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_9[0x7];                                        // 0x0009(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(GbxAIBlueprintLibrary_AIScriptedUseWeapon) == 0x000008, "Wrong alignment on GbxAIBlueprintLibrary_AIScriptedUseWeapon");
static_assert(sizeof(GbxAIBlueprintLibrary_AIScriptedUseWeapon) == 0x000010, "Wrong size on GbxAIBlueprintLibrary_AIScriptedUseWeapon");
static_assert(offsetof(GbxAIBlueprintLibrary_AIScriptedUseWeapon, Actor) == 0x000000, "Member 'GbxAIBlueprintLibrary_AIScriptedUseWeapon::Actor' has a wrong offset!");
static_assert(offsetof(GbxAIBlueprintLibrary_AIScriptedUseWeapon, bUseWeapon) == 0x000008, "Member 'GbxAIBlueprintLibrary_AIScriptedUseWeapon::bUseWeapon' has a wrong offset!");

// Function GbxAI.GbxAIBlueprintLibrary.GetBlackboardValueAsActorAndLocation
// 0x0048 (0x0048 - 0x0000)
struct GbxAIBlueprintLibrary_GetBlackboardValueAsActorAndLocation final
{
public:
	class UBTNode*                                BTNode;                                            // 0x0000(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FBlackboardKeySelector                 Key;                                               // 0x0008(0x0028)(ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
	class AActor*                                 Actor;                                             // 0x0030(0x0008)(Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                Location;                                          // 0x0038(0x000C)(Parm, OutParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          ReturnValue;                                       // 0x0044(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_45[0x3];                                       // 0x0045(0x0003)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(GbxAIBlueprintLibrary_GetBlackboardValueAsActorAndLocation) == 0x000008, "Wrong alignment on GbxAIBlueprintLibrary_GetBlackboardValueAsActorAndLocation");
static_assert(sizeof(GbxAIBlueprintLibrary_GetBlackboardValueAsActorAndLocation) == 0x000048, "Wrong size on GbxAIBlueprintLibrary_GetBlackboardValueAsActorAndLocation");
static_assert(offsetof(GbxAIBlueprintLibrary_GetBlackboardValueAsActorAndLocation, BTNode) == 0x000000, "Member 'GbxAIBlueprintLibrary_GetBlackboardValueAsActorAndLocation::BTNode' has a wrong offset!");
static_assert(offsetof(GbxAIBlueprintLibrary_GetBlackboardValueAsActorAndLocation, Key) == 0x000008, "Member 'GbxAIBlueprintLibrary_GetBlackboardValueAsActorAndLocation::Key' has a wrong offset!");
static_assert(offsetof(GbxAIBlueprintLibrary_GetBlackboardValueAsActorAndLocation, Actor) == 0x000030, "Member 'GbxAIBlueprintLibrary_GetBlackboardValueAsActorAndLocation::Actor' has a wrong offset!");
static_assert(offsetof(GbxAIBlueprintLibrary_GetBlackboardValueAsActorAndLocation, Location) == 0x000038, "Member 'GbxAIBlueprintLibrary_GetBlackboardValueAsActorAndLocation::Location' has a wrong offset!");
static_assert(offsetof(GbxAIBlueprintLibrary_GetBlackboardValueAsActorAndLocation, ReturnValue) == 0x000044, "Member 'GbxAIBlueprintLibrary_GetBlackboardValueAsActorAndLocation::ReturnValue' has a wrong offset!");

// Function GbxAI.GbxAIBlueprintLibrary.GetValueAsActorAndLocation
// 0x0048 (0x0048 - 0x0000)
struct GbxAIBlueprintLibrary_GetValueAsActorAndLocation final
{
public:
	class UBlackboardComponent*                   Blackboard;                                        // 0x0000(0x0008)(Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FBlackboardKeySelector                 Key;                                               // 0x0008(0x0028)(ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
	class AActor*                                 Actor;                                             // 0x0030(0x0008)(Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                Location;                                          // 0x0038(0x000C)(Parm, OutParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          ReturnValue;                                       // 0x0044(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_45[0x3];                                       // 0x0045(0x0003)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(GbxAIBlueprintLibrary_GetValueAsActorAndLocation) == 0x000008, "Wrong alignment on GbxAIBlueprintLibrary_GetValueAsActorAndLocation");
static_assert(sizeof(GbxAIBlueprintLibrary_GetValueAsActorAndLocation) == 0x000048, "Wrong size on GbxAIBlueprintLibrary_GetValueAsActorAndLocation");
static_assert(offsetof(GbxAIBlueprintLibrary_GetValueAsActorAndLocation, Blackboard) == 0x000000, "Member 'GbxAIBlueprintLibrary_GetValueAsActorAndLocation::Blackboard' has a wrong offset!");
static_assert(offsetof(GbxAIBlueprintLibrary_GetValueAsActorAndLocation, Key) == 0x000008, "Member 'GbxAIBlueprintLibrary_GetValueAsActorAndLocation::Key' has a wrong offset!");
static_assert(offsetof(GbxAIBlueprintLibrary_GetValueAsActorAndLocation, Actor) == 0x000030, "Member 'GbxAIBlueprintLibrary_GetValueAsActorAndLocation::Actor' has a wrong offset!");
static_assert(offsetof(GbxAIBlueprintLibrary_GetValueAsActorAndLocation, Location) == 0x000038, "Member 'GbxAIBlueprintLibrary_GetValueAsActorAndLocation::Location' has a wrong offset!");
static_assert(offsetof(GbxAIBlueprintLibrary_GetValueAsActorAndLocation, ReturnValue) == 0x000044, "Member 'GbxAIBlueprintLibrary_GetValueAsActorAndLocation::ReturnValue' has a wrong offset!");

// Function GbxAI.GbxAIBlueprintLibrary.IsActorThreatened
// 0x0010 (0x0010 - 0x0000)
struct GbxAIBlueprintLibrary_IsActorThreatened final
{
public:
	class AActor*                                 InActor;                                           // 0x0000(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          ReturnValue;                                       // 0x0008(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_9[0x7];                                        // 0x0009(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(GbxAIBlueprintLibrary_IsActorThreatened) == 0x000008, "Wrong alignment on GbxAIBlueprintLibrary_IsActorThreatened");
static_assert(sizeof(GbxAIBlueprintLibrary_IsActorThreatened) == 0x000010, "Wrong size on GbxAIBlueprintLibrary_IsActorThreatened");
static_assert(offsetof(GbxAIBlueprintLibrary_IsActorThreatened, InActor) == 0x000000, "Member 'GbxAIBlueprintLibrary_IsActorThreatened::InActor' has a wrong offset!");
static_assert(offsetof(GbxAIBlueprintLibrary_IsActorThreatened, ReturnValue) == 0x000008, "Member 'GbxAIBlueprintLibrary_IsActorThreatened::ReturnValue' has a wrong offset!");

// Function GbxAI.GbxAIBlueprintLibrary.ResetTeamForAllAIChildren
// 0x0008 (0x0008 - 0x0000)
struct GbxAIBlueprintLibrary_ResetTeamForAllAIChildren final
{
public:
	class AActor*                                 Actor;                                             // 0x0000(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(GbxAIBlueprintLibrary_ResetTeamForAllAIChildren) == 0x000008, "Wrong alignment on GbxAIBlueprintLibrary_ResetTeamForAllAIChildren");
static_assert(sizeof(GbxAIBlueprintLibrary_ResetTeamForAllAIChildren) == 0x000008, "Wrong size on GbxAIBlueprintLibrary_ResetTeamForAllAIChildren");
static_assert(offsetof(GbxAIBlueprintLibrary_ResetTeamForAllAIChildren, Actor) == 0x000000, "Member 'GbxAIBlueprintLibrary_ResetTeamForAllAIChildren::Actor' has a wrong offset!");

// Function GbxAI.GbxAIBlueprintLibrary.SetAINavAreaData
// 0x0010 (0x0010 - 0x0000)
struct GbxAIBlueprintLibrary_SetAINavAreaData final
{
public:
	class AActor*                                 InActor;                                           // 0x0000(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UGbxNavAreaData*                        NavAreaData;                                       // 0x0008(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(GbxAIBlueprintLibrary_SetAINavAreaData) == 0x000008, "Wrong alignment on GbxAIBlueprintLibrary_SetAINavAreaData");
static_assert(sizeof(GbxAIBlueprintLibrary_SetAINavAreaData) == 0x000010, "Wrong size on GbxAIBlueprintLibrary_SetAINavAreaData");
static_assert(offsetof(GbxAIBlueprintLibrary_SetAINavAreaData, InActor) == 0x000000, "Member 'GbxAIBlueprintLibrary_SetAINavAreaData::InActor' has a wrong offset!");
static_assert(offsetof(GbxAIBlueprintLibrary_SetAINavAreaData, NavAreaData) == 0x000008, "Member 'GbxAIBlueprintLibrary_SetAINavAreaData::NavAreaData' has a wrong offset!");

// Function GbxAI.GbxAIBlueprintLibrary.SetAIPathFindingData
// 0x0010 (0x0010 - 0x0000)
struct GbxAIBlueprintLibrary_SetAIPathFindingData final
{
public:
	class AActor*                                 InActor;                                           // 0x0000(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UHavokPathFindingData*                  PathFindingData;                                   // 0x0008(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(GbxAIBlueprintLibrary_SetAIPathFindingData) == 0x000008, "Wrong alignment on GbxAIBlueprintLibrary_SetAIPathFindingData");
static_assert(sizeof(GbxAIBlueprintLibrary_SetAIPathFindingData) == 0x000010, "Wrong size on GbxAIBlueprintLibrary_SetAIPathFindingData");
static_assert(offsetof(GbxAIBlueprintLibrary_SetAIPathFindingData, InActor) == 0x000000, "Member 'GbxAIBlueprintLibrary_SetAIPathFindingData::InActor' has a wrong offset!");
static_assert(offsetof(GbxAIBlueprintLibrary_SetAIPathFindingData, PathFindingData) == 0x000008, "Member 'GbxAIBlueprintLibrary_SetAIPathFindingData::PathFindingData' has a wrong offset!");

// Function GbxAI.GbxAIBlueprintLibrary.SetPerceivableToAllAI
// 0x0010 (0x0010 - 0x0000)
struct GbxAIBlueprintLibrary_SetPerceivableToAllAI final
{
public:
	class AActor*                                 Actor;                                             // 0x0000(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bPerceivable;                                      // 0x0008(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_9[0x7];                                        // 0x0009(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(GbxAIBlueprintLibrary_SetPerceivableToAllAI) == 0x000008, "Wrong alignment on GbxAIBlueprintLibrary_SetPerceivableToAllAI");
static_assert(sizeof(GbxAIBlueprintLibrary_SetPerceivableToAllAI) == 0x000010, "Wrong size on GbxAIBlueprintLibrary_SetPerceivableToAllAI");
static_assert(offsetof(GbxAIBlueprintLibrary_SetPerceivableToAllAI, Actor) == 0x000000, "Member 'GbxAIBlueprintLibrary_SetPerceivableToAllAI::Actor' has a wrong offset!");
static_assert(offsetof(GbxAIBlueprintLibrary_SetPerceivableToAllAI, bPerceivable) == 0x000008, "Member 'GbxAIBlueprintLibrary_SetPerceivableToAllAI::bPerceivable' has a wrong offset!");

// Function GbxAI.GbxAIController.AddChildActor
// 0x0008 (0x0008 - 0x0000)
struct GbxAIController_AddChildActor final
{
public:
	class AActor*                                 NewChild;                                          // 0x0000(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(GbxAIController_AddChildActor) == 0x000008, "Wrong alignment on GbxAIController_AddChildActor");
static_assert(sizeof(GbxAIController_AddChildActor) == 0x000008, "Wrong size on GbxAIController_AddChildActor");
static_assert(offsetof(GbxAIController_AddChildActor, NewChild) == 0x000000, "Member 'GbxAIController_AddChildActor::NewChild' has a wrong offset!");

// Function GbxAI.GbxAIController.AddChildActors
// 0x0010 (0x0010 - 0x0000)
struct GbxAIController_AddChildActors final
{
public:
	TArray<class AActor*>                         NewChildren;                                       // 0x0000(0x0010)(ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, NativeAccessSpecifierPublic)
};
static_assert(alignof(GbxAIController_AddChildActors) == 0x000008, "Wrong alignment on GbxAIController_AddChildActors");
static_assert(sizeof(GbxAIController_AddChildActors) == 0x000010, "Wrong size on GbxAIController_AddChildActors");
static_assert(offsetof(GbxAIController_AddChildActors, NewChildren) == 0x000000, "Member 'GbxAIController_AddChildActors::NewChildren' has a wrong offset!");

// Function GbxAI.GbxAIController.CheckPauseWhileFalling
// 0x0010 (0x0010 - 0x0000)
struct GbxAIController_CheckPauseWhileFalling final
{
public:
	class ACharacter*                             TheCharacter;                                      // 0x0000(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EMovementMode                                 PrevMovementMode;                                  // 0x0008(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         PreviousCustomMode;                                // 0x0009(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_A[0x6];                                        // 0x000A(0x0006)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(GbxAIController_CheckPauseWhileFalling) == 0x000008, "Wrong alignment on GbxAIController_CheckPauseWhileFalling");
static_assert(sizeof(GbxAIController_CheckPauseWhileFalling) == 0x000010, "Wrong size on GbxAIController_CheckPauseWhileFalling");
static_assert(offsetof(GbxAIController_CheckPauseWhileFalling, TheCharacter) == 0x000000, "Member 'GbxAIController_CheckPauseWhileFalling::TheCharacter' has a wrong offset!");
static_assert(offsetof(GbxAIController_CheckPauseWhileFalling, PrevMovementMode) == 0x000008, "Member 'GbxAIController_CheckPauseWhileFalling::PrevMovementMode' has a wrong offset!");
static_assert(offsetof(GbxAIController_CheckPauseWhileFalling, PreviousCustomMode) == 0x000009, "Member 'GbxAIController_CheckPauseWhileFalling::PreviousCustomMode' has a wrong offset!");

// Function GbxAI.GbxAIController.ChildDestroyed
// 0x0008 (0x0008 - 0x0000)
struct GbxAIController_ChildDestroyed final
{
public:
	class AActor*                                 DestroyedActor;                                    // 0x0000(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(GbxAIController_ChildDestroyed) == 0x000008, "Wrong alignment on GbxAIController_ChildDestroyed");
static_assert(sizeof(GbxAIController_ChildDestroyed) == 0x000008, "Wrong size on GbxAIController_ChildDestroyed");
static_assert(offsetof(GbxAIController_ChildDestroyed, DestroyedActor) == 0x000000, "Member 'GbxAIController_ChildDestroyed::DestroyedActor' has a wrong offset!");

// Function GbxAI.GbxAIController.OnMyWeaponHitSomething
// 0x0018 (0x0018 - 0x0000)
struct GbxAIController_OnMyWeaponHitSomething final
{
public:
	class AActor*                                 HitActor;                                          // 0x0000(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                HitLocation;                                       // 0x0008(0x000C)(Parm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_14[0x4];                                       // 0x0014(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(GbxAIController_OnMyWeaponHitSomething) == 0x000008, "Wrong alignment on GbxAIController_OnMyWeaponHitSomething");
static_assert(sizeof(GbxAIController_OnMyWeaponHitSomething) == 0x000018, "Wrong size on GbxAIController_OnMyWeaponHitSomething");
static_assert(offsetof(GbxAIController_OnMyWeaponHitSomething, HitActor) == 0x000000, "Member 'GbxAIController_OnMyWeaponHitSomething::HitActor' has a wrong offset!");
static_assert(offsetof(GbxAIController_OnMyWeaponHitSomething, HitLocation) == 0x000008, "Member 'GbxAIController_OnMyWeaponHitSomething::HitLocation' has a wrong offset!");

// Function GbxAI.GbxAIController.SetObstacleAvoidanceLock
// 0x0010 (0x0010 - 0x0000)
struct GbxAIController_SetObstacleAvoidanceLock final
{
public:
	bool                                          bDisable;                                          // 0x0000(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1[0x7];                                        // 0x0001(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	class FName                                   Reason;                                            // 0x0008(0x0008)(ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(GbxAIController_SetObstacleAvoidanceLock) == 0x000004, "Wrong alignment on GbxAIController_SetObstacleAvoidanceLock");
static_assert(sizeof(GbxAIController_SetObstacleAvoidanceLock) == 0x000010, "Wrong size on GbxAIController_SetObstacleAvoidanceLock");
static_assert(offsetof(GbxAIController_SetObstacleAvoidanceLock, bDisable) == 0x000000, "Member 'GbxAIController_SetObstacleAvoidanceLock::bDisable' has a wrong offset!");
static_assert(offsetof(GbxAIController_SetObstacleAvoidanceLock, Reason) == 0x000008, "Member 'GbxAIController_SetObstacleAvoidanceLock::Reason' has a wrong offset!");

// Function GbxAI.GbxAIController.SetTerritory
// 0x0008 (0x0008 - 0x0000)
struct GbxAIController_SetTerritory final
{
public:
	class UTerritoryComponent*                    Territory;                                         // 0x0000(0x0008)(Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(GbxAIController_SetTerritory) == 0x000008, "Wrong alignment on GbxAIController_SetTerritory");
static_assert(sizeof(GbxAIController_SetTerritory) == 0x000008, "Wrong size on GbxAIController_SetTerritory");
static_assert(offsetof(GbxAIController_SetTerritory, Territory) == 0x000000, "Member 'GbxAIController_SetTerritory::Territory' has a wrong offset!");

// Function GbxAI.GbxAIController.GetAIActionComponent
// 0x0008 (0x0008 - 0x0000)
struct GbxAIController_GetAIActionComponent final
{
public:
	class UAIActionComponent*                     ReturnValue;                                       // 0x0000(0x0008)(ExportObject, Parm, OutParm, ZeroConstructor, ReturnParm, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(GbxAIController_GetAIActionComponent) == 0x000008, "Wrong alignment on GbxAIController_GetAIActionComponent");
static_assert(sizeof(GbxAIController_GetAIActionComponent) == 0x000008, "Wrong size on GbxAIController_GetAIActionComponent");
static_assert(offsetof(GbxAIController_GetAIActionComponent, ReturnValue) == 0x000000, "Member 'GbxAIController_GetAIActionComponent::ReturnValue' has a wrong offset!");

// Function GbxAI.GbxAIController.GetAIGroupList
// 0x0018 (0x0018 - 0x0000)
struct GbxAIController_GetAIGroupList final
{
public:
	TArray<class AActor*>                         AIGroupList;                                       // 0x0000(0x0010)(Parm, OutParm, ZeroConstructor, NativeAccessSpecifierPublic)
	bool                                          bIncludeSelf;                                      // 0x0010(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_11[0x3];                                       // 0x0011(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         InRadius;                                          // 0x0014(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(GbxAIController_GetAIGroupList) == 0x000008, "Wrong alignment on GbxAIController_GetAIGroupList");
static_assert(sizeof(GbxAIController_GetAIGroupList) == 0x000018, "Wrong size on GbxAIController_GetAIGroupList");
static_assert(offsetof(GbxAIController_GetAIGroupList, AIGroupList) == 0x000000, "Member 'GbxAIController_GetAIGroupList::AIGroupList' has a wrong offset!");
static_assert(offsetof(GbxAIController_GetAIGroupList, bIncludeSelf) == 0x000010, "Member 'GbxAIController_GetAIGroupList::bIncludeSelf' has a wrong offset!");
static_assert(offsetof(GbxAIController_GetAIGroupList, InRadius) == 0x000014, "Member 'GbxAIController_GetAIGroupList::InRadius' has a wrong offset!");

// Function GbxAI.GbxAIController.GetAIGroupSize
// 0x0004 (0x0004 - 0x0000)
struct GbxAIController_GetAIGroupSize final
{
public:
	int32                                         ReturnValue;                                       // 0x0000(0x0004)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(GbxAIController_GetAIGroupSize) == 0x000004, "Wrong alignment on GbxAIController_GetAIGroupSize");
static_assert(sizeof(GbxAIController_GetAIGroupSize) == 0x000004, "Wrong size on GbxAIController_GetAIGroupSize");
static_assert(offsetof(GbxAIController_GetAIGroupSize, ReturnValue) == 0x000000, "Member 'GbxAIController_GetAIGroupSize::ReturnValue' has a wrong offset!");

// Function GbxAI.GbxAIController.GetBlackboardAsset
// 0x0008 (0x0008 - 0x0000)
struct GbxAIController_GetBlackboardAsset final
{
public:
	class UBlackboardData*                        ReturnValue;                                       // 0x0000(0x0008)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(GbxAIController_GetBlackboardAsset) == 0x000008, "Wrong alignment on GbxAIController_GetBlackboardAsset");
static_assert(sizeof(GbxAIController_GetBlackboardAsset) == 0x000008, "Wrong size on GbxAIController_GetBlackboardAsset");
static_assert(offsetof(GbxAIController_GetBlackboardAsset, ReturnValue) == 0x000000, "Member 'GbxAIController_GetBlackboardAsset::ReturnValue' has a wrong offset!");

// Function GbxAI.GbxAIController.GetBlackboardComponent
// 0x0008 (0x0008 - 0x0000)
struct GbxAIController_GetBlackboardComponent final
{
public:
	class UBlackboardComponent*                   ReturnValue;                                       // 0x0000(0x0008)(ExportObject, Parm, OutParm, ZeroConstructor, ReturnParm, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(GbxAIController_GetBlackboardComponent) == 0x000008, "Wrong alignment on GbxAIController_GetBlackboardComponent");
static_assert(sizeof(GbxAIController_GetBlackboardComponent) == 0x000008, "Wrong size on GbxAIController_GetBlackboardComponent");
static_assert(offsetof(GbxAIController_GetBlackboardComponent, ReturnValue) == 0x000000, "Member 'GbxAIController_GetBlackboardComponent::ReturnValue' has a wrong offset!");

// Function GbxAI.GbxAIController.GetChildActors
// 0x0010 (0x0010 - 0x0000)
struct GbxAIController_GetChildActors final
{
public:
	TArray<class AActor*>                         ReturnValue;                                       // 0x0000(0x0010)(ConstParm, Parm, OutParm, ZeroConstructor, ReturnParm, ReferenceParm, NativeAccessSpecifierPublic)
};
static_assert(alignof(GbxAIController_GetChildActors) == 0x000008, "Wrong alignment on GbxAIController_GetChildActors");
static_assert(sizeof(GbxAIController_GetChildActors) == 0x000010, "Wrong size on GbxAIController_GetChildActors");
static_assert(offsetof(GbxAIController_GetChildActors, ReturnValue) == 0x000000, "Member 'GbxAIController_GetChildActors::ReturnValue' has a wrong offset!");

// Function GbxAI.GbxAIController.GetGbxActionComponent
// 0x0008 (0x0008 - 0x0000)
struct GbxAIController_GetGbxActionComponent final
{
public:
	class UGbxActionComponent*                    ReturnValue;                                       // 0x0000(0x0008)(ExportObject, Parm, OutParm, ZeroConstructor, ReturnParm, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(GbxAIController_GetGbxActionComponent) == 0x000008, "Wrong alignment on GbxAIController_GetGbxActionComponent");
static_assert(sizeof(GbxAIController_GetGbxActionComponent) == 0x000008, "Wrong size on GbxAIController_GetGbxActionComponent");
static_assert(offsetof(GbxAIController_GetGbxActionComponent, ReturnValue) == 0x000000, "Member 'GbxAIController_GetGbxActionComponent::ReturnValue' has a wrong offset!");

// Function GbxAI.GbxAIController.GetGbxCharacter
// 0x0008 (0x0008 - 0x0000)
struct GbxAIController_GetGbxCharacter final
{
public:
	class AGbxCharacter*                          ReturnValue;                                       // 0x0000(0x0008)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(GbxAIController_GetGbxCharacter) == 0x000008, "Wrong alignment on GbxAIController_GetGbxCharacter");
static_assert(sizeof(GbxAIController_GetGbxCharacter) == 0x000008, "Wrong size on GbxAIController_GetGbxCharacter");
static_assert(offsetof(GbxAIController_GetGbxCharacter, ReturnValue) == 0x000000, "Member 'GbxAIController_GetGbxCharacter::ReturnValue' has a wrong offset!");

// Function GbxAI.GbxAIController.GetGroupState
// 0x0008 (0x0008 - 0x0000)
struct GbxAIController_GetGroupState final
{
public:
	class UAIGroupState*                          ReturnValue;                                       // 0x0000(0x0008)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(GbxAIController_GetGroupState) == 0x000008, "Wrong alignment on GbxAIController_GetGroupState");
static_assert(sizeof(GbxAIController_GetGroupState) == 0x000008, "Wrong size on GbxAIController_GetGroupState");
static_assert(offsetof(GbxAIController_GetGroupState, ReturnValue) == 0x000000, "Member 'GbxAIController_GetGroupState::ReturnValue' has a wrong offset!");

// Function GbxAI.GbxAIController.GetMovementComponent
// 0x0008 (0x0008 - 0x0000)
struct GbxAIController_GetMovementComponent final
{
public:
	class UGbxCharacterMovementComponent*         ReturnValue;                                       // 0x0000(0x0008)(ExportObject, Parm, OutParm, ZeroConstructor, ReturnParm, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(GbxAIController_GetMovementComponent) == 0x000008, "Wrong alignment on GbxAIController_GetMovementComponent");
static_assert(sizeof(GbxAIController_GetMovementComponent) == 0x000008, "Wrong size on GbxAIController_GetMovementComponent");
static_assert(offsetof(GbxAIController_GetMovementComponent, ReturnValue) == 0x000000, "Member 'GbxAIController_GetMovementComponent::ReturnValue' has a wrong offset!");

// Function GbxAI.GbxAIController.GetNavComponent
// 0x0008 (0x0008 - 0x0000)
struct GbxAIController_GetNavComponent final
{
public:
	class UGbxNavComponent*                       ReturnValue;                                       // 0x0000(0x0008)(ExportObject, Parm, OutParm, ZeroConstructor, ReturnParm, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(GbxAIController_GetNavComponent) == 0x000008, "Wrong alignment on GbxAIController_GetNavComponent");
static_assert(sizeof(GbxAIController_GetNavComponent) == 0x000008, "Wrong size on GbxAIController_GetNavComponent");
static_assert(offsetof(GbxAIController_GetNavComponent, ReturnValue) == 0x000000, "Member 'GbxAIController_GetNavComponent::ReturnValue' has a wrong offset!");

// Function GbxAI.GbxAIController.GetNumChildActors
// 0x0004 (0x0004 - 0x0000)
struct GbxAIController_GetNumChildActors final
{
public:
	int32                                         ReturnValue;                                       // 0x0000(0x0004)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(GbxAIController_GetNumChildActors) == 0x000004, "Wrong alignment on GbxAIController_GetNumChildActors");
static_assert(sizeof(GbxAIController_GetNumChildActors) == 0x000004, "Wrong size on GbxAIController_GetNumChildActors");
static_assert(offsetof(GbxAIController_GetNumChildActors, ReturnValue) == 0x000000, "Member 'GbxAIController_GetNumChildActors::ReturnValue' has a wrong offset!");

// Function GbxAI.GbxAIController.GetPerceptionComponent
// 0x0008 (0x0008 - 0x0000)
struct GbxAIController_GetPerceptionComponent final
{
public:
	const class UAIPerceptionComponent*           ReturnValue;                                       // 0x0000(0x0008)(ConstParm, ExportObject, Parm, OutParm, ZeroConstructor, ReturnParm, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(GbxAIController_GetPerceptionComponent) == 0x000008, "Wrong alignment on GbxAIController_GetPerceptionComponent");
static_assert(sizeof(GbxAIController_GetPerceptionComponent) == 0x000008, "Wrong size on GbxAIController_GetPerceptionComponent");
static_assert(offsetof(GbxAIController_GetPerceptionComponent, ReturnValue) == 0x000000, "Member 'GbxAIController_GetPerceptionComponent::ReturnValue' has a wrong offset!");

// Function GbxAI.GbxAIController.GetSpawner
// 0x0008 (0x0008 - 0x0000)
struct GbxAIController_GetSpawner final
{
public:
	class ASpawner*                               ReturnValue;                                       // 0x0000(0x0008)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(GbxAIController_GetSpawner) == 0x000008, "Wrong alignment on GbxAIController_GetSpawner");
static_assert(sizeof(GbxAIController_GetSpawner) == 0x000008, "Wrong size on GbxAIController_GetSpawner");
static_assert(offsetof(GbxAIController_GetSpawner, ReturnValue) == 0x000000, "Member 'GbxAIController_GetSpawner::ReturnValue' has a wrong offset!");

// Function GbxAI.GbxAIController.GetSpawnerComponent
// 0x0008 (0x0008 - 0x0000)
struct GbxAIController_GetSpawnerComponent final
{
public:
	class USpawnerComponent*                      ReturnValue;                                       // 0x0000(0x0008)(ExportObject, Parm, OutParm, ZeroConstructor, ReturnParm, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(GbxAIController_GetSpawnerComponent) == 0x000008, "Wrong alignment on GbxAIController_GetSpawnerComponent");
static_assert(sizeof(GbxAIController_GetSpawnerComponent) == 0x000008, "Wrong size on GbxAIController_GetSpawnerComponent");
static_assert(offsetof(GbxAIController_GetSpawnerComponent, ReturnValue) == 0x000000, "Member 'GbxAIController_GetSpawnerComponent::ReturnValue' has a wrong offset!");

// Function GbxAI.GbxAIController.GetTargetableComponent
// 0x0008 (0x0008 - 0x0000)
struct GbxAIController_GetTargetableComponent final
{
public:
	class UTargetableComponent*                   ReturnValue;                                       // 0x0000(0x0008)(ExportObject, Parm, OutParm, ZeroConstructor, ReturnParm, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(GbxAIController_GetTargetableComponent) == 0x000008, "Wrong alignment on GbxAIController_GetTargetableComponent");
static_assert(sizeof(GbxAIController_GetTargetableComponent) == 0x000008, "Wrong size on GbxAIController_GetTargetableComponent");
static_assert(offsetof(GbxAIController_GetTargetableComponent, ReturnValue) == 0x000000, "Member 'GbxAIController_GetTargetableComponent::ReturnValue' has a wrong offset!");

// Function GbxAI.GbxAIController.GetTargetingComponent
// 0x0008 (0x0008 - 0x0000)
struct GbxAIController_GetTargetingComponent final
{
public:
	class UTargetingComponent*                    ReturnValue;                                       // 0x0000(0x0008)(ExportObject, Parm, OutParm, ZeroConstructor, ReturnParm, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(GbxAIController_GetTargetingComponent) == 0x000008, "Wrong alignment on GbxAIController_GetTargetingComponent");
static_assert(sizeof(GbxAIController_GetTargetingComponent) == 0x000008, "Wrong size on GbxAIController_GetTargetingComponent");
static_assert(offsetof(GbxAIController_GetTargetingComponent, ReturnValue) == 0x000000, "Member 'GbxAIController_GetTargetingComponent::ReturnValue' has a wrong offset!");

// Function GbxAI.GbxAIController.GetTeam
// 0x0008 (0x0008 - 0x0000)
struct GbxAIController_GetTeam final
{
public:
	class UTeam*                                  ReturnValue;                                       // 0x0000(0x0008)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(GbxAIController_GetTeam) == 0x000008, "Wrong alignment on GbxAIController_GetTeam");
static_assert(sizeof(GbxAIController_GetTeam) == 0x000008, "Wrong size on GbxAIController_GetTeam");
static_assert(offsetof(GbxAIController_GetTeam, ReturnValue) == 0x000000, "Member 'GbxAIController_GetTeam::ReturnValue' has a wrong offset!");

// Function GbxAI.GbxAIController.GetTeamComponent
// 0x0008 (0x0008 - 0x0000)
struct GbxAIController_GetTeamComponent final
{
public:
	class UTeamComponent*                         ReturnValue;                                       // 0x0000(0x0008)(ExportObject, Parm, OutParm, ZeroConstructor, ReturnParm, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(GbxAIController_GetTeamComponent) == 0x000008, "Wrong alignment on GbxAIController_GetTeamComponent");
static_assert(sizeof(GbxAIController_GetTeamComponent) == 0x000008, "Wrong size on GbxAIController_GetTeamComponent");
static_assert(offsetof(GbxAIController_GetTeamComponent, ReturnValue) == 0x000000, "Member 'GbxAIController_GetTeamComponent::ReturnValue' has a wrong offset!");

// Function GbxAI.GbxAIController.GetTerritory
// 0x0008 (0x0008 - 0x0000)
struct GbxAIController_GetTerritory final
{
public:
	class UTerritoryComponent*                    ReturnValue;                                       // 0x0000(0x0008)(ExportObject, Parm, OutParm, ZeroConstructor, ReturnParm, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(GbxAIController_GetTerritory) == 0x000008, "Wrong alignment on GbxAIController_GetTerritory");
static_assert(sizeof(GbxAIController_GetTerritory) == 0x000008, "Wrong size on GbxAIController_GetTerritory");
static_assert(offsetof(GbxAIController_GetTerritory, ReturnValue) == 0x000000, "Member 'GbxAIController_GetTerritory::ReturnValue' has a wrong offset!");

// Function GbxAI.GbxAIController.GetUseComponent
// 0x0008 (0x0008 - 0x0000)
struct GbxAIController_GetUseComponent final
{
public:
	class UAIUseComponent*                        ReturnValue;                                       // 0x0000(0x0008)(ExportObject, Parm, OutParm, ZeroConstructor, ReturnParm, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(GbxAIController_GetUseComponent) == 0x000008, "Wrong alignment on GbxAIController_GetUseComponent");
static_assert(sizeof(GbxAIController_GetUseComponent) == 0x000008, "Wrong size on GbxAIController_GetUseComponent");
static_assert(offsetof(GbxAIController_GetUseComponent, ReturnValue) == 0x000000, "Member 'GbxAIController_GetUseComponent::ReturnValue' has a wrong offset!");

// Function GbxAI.GbxAIController.GetWeaponUserComponent
// 0x0008 (0x0008 - 0x0000)
struct GbxAIController_GetWeaponUserComponent final
{
public:
	class UAIWeaponUserComponent*                 ReturnValue;                                       // 0x0000(0x0008)(ExportObject, Parm, OutParm, ZeroConstructor, ReturnParm, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(GbxAIController_GetWeaponUserComponent) == 0x000008, "Wrong alignment on GbxAIController_GetWeaponUserComponent");
static_assert(sizeof(GbxAIController_GetWeaponUserComponent) == 0x000008, "Wrong size on GbxAIController_GetWeaponUserComponent");
static_assert(offsetof(GbxAIController_GetWeaponUserComponent, ReturnValue) == 0x000000, "Member 'GbxAIController_GetWeaponUserComponent::ReturnValue' has a wrong offset!");

// Function GbxAI.GbxAIController.SetTeam
// 0x0008 (0x0008 - 0x0000)
struct GbxAIController_SetTeam final
{
public:
	class UTeam*                                  Team;                                              // 0x0000(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(GbxAIController_SetTeam) == 0x000008, "Wrong alignment on GbxAIController_SetTeam");
static_assert(sizeof(GbxAIController_SetTeam) == 0x000008, "Wrong size on GbxAIController_SetTeam");
static_assert(offsetof(GbxAIController_SetTeam, Team) == 0x000000, "Member 'GbxAIController_SetTeam::Team' has a wrong offset!");

// Function GbxAI.SmartObject.GetGbxActionComponent
// 0x0008 (0x0008 - 0x0000)
struct SmartObject_GetGbxActionComponent final
{
public:
	class UGbxActionComponent*                    ReturnValue;                                       // 0x0000(0x0008)(ExportObject, Parm, OutParm, ZeroConstructor, ReturnParm, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(SmartObject_GetGbxActionComponent) == 0x000008, "Wrong alignment on SmartObject_GetGbxActionComponent");
static_assert(sizeof(SmartObject_GetGbxActionComponent) == 0x000008, "Wrong size on SmartObject_GetGbxActionComponent");
static_assert(offsetof(SmartObject_GetGbxActionComponent, ReturnValue) == 0x000000, "Member 'SmartObject_GetGbxActionComponent::ReturnValue' has a wrong offset!");

// Function GbxAI.SmartObject.GetSmartObjectComponent
// 0x0008 (0x0008 - 0x0000)
struct SmartObject_GetSmartObjectComponent final
{
public:
	class USmartObjectComponent*                  ReturnValue;                                       // 0x0000(0x0008)(ExportObject, Parm, OutParm, ZeroConstructor, ReturnParm, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(SmartObject_GetSmartObjectComponent) == 0x000008, "Wrong alignment on SmartObject_GetSmartObjectComponent");
static_assert(sizeof(SmartObject_GetSmartObjectComponent) == 0x000008, "Wrong size on SmartObject_GetSmartObjectComponent");
static_assert(offsetof(SmartObject_GetSmartObjectComponent, ReturnValue) == 0x000000, "Member 'SmartObject_GetSmartObjectComponent::ReturnValue' has a wrong offset!");

// Function GbxAI.GbxSpawner.DEPRECATED_IsThreatened
// 0x0001 (0x0001 - 0x0000)
struct GbxSpawner_DEPRECATED_IsThreatened final
{
public:
	bool                                          ReturnValue;                                       // 0x0000(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(GbxSpawner_DEPRECATED_IsThreatened) == 0x000001, "Wrong alignment on GbxSpawner_DEPRECATED_IsThreatened");
static_assert(sizeof(GbxSpawner_DEPRECATED_IsThreatened) == 0x000001, "Wrong size on GbxSpawner_DEPRECATED_IsThreatened");
static_assert(offsetof(GbxSpawner_DEPRECATED_IsThreatened, ReturnValue) == 0x000000, "Member 'GbxSpawner_DEPRECATED_IsThreatened::ReturnValue' has a wrong offset!");

// Function GbxAI.GbxSpawner.GetAIGroupState
// 0x0008 (0x0008 - 0x0000)
struct GbxSpawner_GetAIGroupState final
{
public:
	class UAIGroupState*                          ReturnValue;                                       // 0x0000(0x0008)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(GbxSpawner_GetAIGroupState) == 0x000008, "Wrong alignment on GbxSpawner_GetAIGroupState");
static_assert(sizeof(GbxSpawner_GetAIGroupState) == 0x000008, "Wrong size on GbxSpawner_GetAIGroupState");
static_assert(offsetof(GbxSpawner_GetAIGroupState, ReturnValue) == 0x000000, "Member 'GbxSpawner_GetAIGroupState::ReturnValue' has a wrong offset!");

// Function GbxAI.GbxSpawner.GetAINodeComponent
// 0x0008 (0x0008 - 0x0000)
struct GbxSpawner_GetAINodeComponent final
{
public:
	class UAINodeComponent*                       ReturnValue;                                       // 0x0000(0x0008)(ExportObject, Parm, OutParm, ZeroConstructor, ReturnParm, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(GbxSpawner_GetAINodeComponent) == 0x000008, "Wrong alignment on GbxSpawner_GetAINodeComponent");
static_assert(sizeof(GbxSpawner_GetAINodeComponent) == 0x000008, "Wrong size on GbxSpawner_GetAINodeComponent");
static_assert(offsetof(GbxSpawner_GetAINodeComponent, ReturnValue) == 0x000000, "Member 'GbxSpawner_GetAINodeComponent::ReturnValue' has a wrong offset!");

// Function GbxAI.GbxSpawner.GetGameplayTasksComponent
// 0x0008 (0x0008 - 0x0000)
struct GbxSpawner_GetGameplayTasksComponent final
{
public:
	class UGameplayTasksComponent*                ReturnValue;                                       // 0x0000(0x0008)(ExportObject, Parm, OutParm, ZeroConstructor, ReturnParm, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(GbxSpawner_GetGameplayTasksComponent) == 0x000008, "Wrong alignment on GbxSpawner_GetGameplayTasksComponent");
static_assert(sizeof(GbxSpawner_GetGameplayTasksComponent) == 0x000008, "Wrong size on GbxSpawner_GetGameplayTasksComponent");
static_assert(offsetof(GbxSpawner_GetGameplayTasksComponent, ReturnValue) == 0x000000, "Member 'GbxSpawner_GetGameplayTasksComponent::ReturnValue' has a wrong offset!");

// Function GbxAI.GbxSpawnPoint.HasNavNearSpawnPointFor
// 0x0018 (0x0018 - 0x0000)
struct GbxSpawnPoint_HasNavNearSpawnPointFor final
{
public:
	class USpawnPointComponent*                   SpawnPointComp;                                    // 0x0000(0x0008)(Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class USpawnOptionData*                       SpawnOptions;                                      // 0x0008(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          ReturnValue;                                       // 0x0010(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_11[0x7];                                       // 0x0011(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(GbxSpawnPoint_HasNavNearSpawnPointFor) == 0x000008, "Wrong alignment on GbxSpawnPoint_HasNavNearSpawnPointFor");
static_assert(sizeof(GbxSpawnPoint_HasNavNearSpawnPointFor) == 0x000018, "Wrong size on GbxSpawnPoint_HasNavNearSpawnPointFor");
static_assert(offsetof(GbxSpawnPoint_HasNavNearSpawnPointFor, SpawnPointComp) == 0x000000, "Member 'GbxSpawnPoint_HasNavNearSpawnPointFor::SpawnPointComp' has a wrong offset!");
static_assert(offsetof(GbxSpawnPoint_HasNavNearSpawnPointFor, SpawnOptions) == 0x000008, "Member 'GbxSpawnPoint_HasNavNearSpawnPointFor::SpawnOptions' has a wrong offset!");
static_assert(offsetof(GbxSpawnPoint_HasNavNearSpawnPointFor, ReturnValue) == 0x000010, "Member 'GbxSpawnPoint_HasNavNearSpawnPointFor::ReturnValue' has a wrong offset!");

// Function GbxAI.ScriptedBehaviorTreeLibrary.BeginScriptedLook
// 0x0020 (0x0020 - 0x0000)
struct ScriptedBehaviorTreeLibrary_BeginScriptedLook final
{
public:
	class AActor*                                 Target;                                            // 0x0000(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class AActor*                                 LookAtActor;                                       // 0x0008(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bAimAtActor;                                       // 0x0010(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bFireWeaponAtActor;                                // 0x0011(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_12[0x6];                                       // 0x0012(0x0006)(Fixing Size After Last Property [ Dumper-7 ])
	class UStanceDataProvider*                    OptionalStance;                                    // 0x0018(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, AdvancedDisplay, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(ScriptedBehaviorTreeLibrary_BeginScriptedLook) == 0x000008, "Wrong alignment on ScriptedBehaviorTreeLibrary_BeginScriptedLook");
static_assert(sizeof(ScriptedBehaviorTreeLibrary_BeginScriptedLook) == 0x000020, "Wrong size on ScriptedBehaviorTreeLibrary_BeginScriptedLook");
static_assert(offsetof(ScriptedBehaviorTreeLibrary_BeginScriptedLook, Target) == 0x000000, "Member 'ScriptedBehaviorTreeLibrary_BeginScriptedLook::Target' has a wrong offset!");
static_assert(offsetof(ScriptedBehaviorTreeLibrary_BeginScriptedLook, LookAtActor) == 0x000008, "Member 'ScriptedBehaviorTreeLibrary_BeginScriptedLook::LookAtActor' has a wrong offset!");
static_assert(offsetof(ScriptedBehaviorTreeLibrary_BeginScriptedLook, bAimAtActor) == 0x000010, "Member 'ScriptedBehaviorTreeLibrary_BeginScriptedLook::bAimAtActor' has a wrong offset!");
static_assert(offsetof(ScriptedBehaviorTreeLibrary_BeginScriptedLook, bFireWeaponAtActor) == 0x000011, "Member 'ScriptedBehaviorTreeLibrary_BeginScriptedLook::bFireWeaponAtActor' has a wrong offset!");
static_assert(offsetof(ScriptedBehaviorTreeLibrary_BeginScriptedLook, OptionalStance) == 0x000018, "Member 'ScriptedBehaviorTreeLibrary_BeginScriptedLook::OptionalStance' has a wrong offset!");

// Function GbxAI.ScriptedBehaviorTreeLibrary.BeginScriptedWait
// 0x0010 (0x0010 - 0x0000)
struct ScriptedBehaviorTreeLibrary_BeginScriptedWait final
{
public:
	class AActor*                                 Target;                                            // 0x0000(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UStanceDataProvider*                    OptionalStance;                                    // 0x0008(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, AdvancedDisplay, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(ScriptedBehaviorTreeLibrary_BeginScriptedWait) == 0x000008, "Wrong alignment on ScriptedBehaviorTreeLibrary_BeginScriptedWait");
static_assert(sizeof(ScriptedBehaviorTreeLibrary_BeginScriptedWait) == 0x000010, "Wrong size on ScriptedBehaviorTreeLibrary_BeginScriptedWait");
static_assert(offsetof(ScriptedBehaviorTreeLibrary_BeginScriptedWait, Target) == 0x000000, "Member 'ScriptedBehaviorTreeLibrary_BeginScriptedWait::Target' has a wrong offset!");
static_assert(offsetof(ScriptedBehaviorTreeLibrary_BeginScriptedWait, OptionalStance) == 0x000008, "Member 'ScriptedBehaviorTreeLibrary_BeginScriptedWait::OptionalStance' has a wrong offset!");

// Function GbxAI.ScriptedBehaviorTreeLibrary.PerformScriptedAbort
// 0x0010 (0x0010 - 0x0000)
struct ScriptedBehaviorTreeLibrary_PerformScriptedAbort final
{
public:
	class AActor*                                 Target;                                            // 0x0000(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bStopImmediately;                                  // 0x0008(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_9[0x7];                                        // 0x0009(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(ScriptedBehaviorTreeLibrary_PerformScriptedAbort) == 0x000008, "Wrong alignment on ScriptedBehaviorTreeLibrary_PerformScriptedAbort");
static_assert(sizeof(ScriptedBehaviorTreeLibrary_PerformScriptedAbort) == 0x000010, "Wrong size on ScriptedBehaviorTreeLibrary_PerformScriptedAbort");
static_assert(offsetof(ScriptedBehaviorTreeLibrary_PerformScriptedAbort, Target) == 0x000000, "Member 'ScriptedBehaviorTreeLibrary_PerformScriptedAbort::Target' has a wrong offset!");
static_assert(offsetof(ScriptedBehaviorTreeLibrary_PerformScriptedAbort, bStopImmediately) == 0x000008, "Member 'ScriptedBehaviorTreeLibrary_PerformScriptedAbort::bStopImmediately' has a wrong offset!");

// Function GbxAI.SmartObjectBlueprintLibrary.AbortSmartObjectUse
// 0x0008 (0x0008 - 0x0000)
struct SmartObjectBlueprintLibrary_AbortSmartObjectUse final
{
public:
	class AActor*                                 User;                                              // 0x0000(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(SmartObjectBlueprintLibrary_AbortSmartObjectUse) == 0x000008, "Wrong alignment on SmartObjectBlueprintLibrary_AbortSmartObjectUse");
static_assert(sizeof(SmartObjectBlueprintLibrary_AbortSmartObjectUse) == 0x000008, "Wrong size on SmartObjectBlueprintLibrary_AbortSmartObjectUse");
static_assert(offsetof(SmartObjectBlueprintLibrary_AbortSmartObjectUse, User) == 0x000000, "Member 'SmartObjectBlueprintLibrary_AbortSmartObjectUse::User' has a wrong offset!");

// Function GbxAI.SmartObjectBlueprintLibrary.UseSmartObject
// 0x0020 (0x0020 - 0x0000)
struct SmartObjectBlueprintLibrary_UseSmartObject final
{
public:
	class AActor*                                 User;                                              // 0x0000(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class AActor*                                 SmartObject;                                       // 0x0008(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FGameplayTag                           ActionTag;                                         // 0x0010(0x0008)(Parm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bAbortExisting;                                    // 0x0018(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bUntilInterrupted;                                 // 0x0019(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          ReturnValue;                                       // 0x001A(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1B[0x5];                                       // 0x001B(0x0005)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(SmartObjectBlueprintLibrary_UseSmartObject) == 0x000008, "Wrong alignment on SmartObjectBlueprintLibrary_UseSmartObject");
static_assert(sizeof(SmartObjectBlueprintLibrary_UseSmartObject) == 0x000020, "Wrong size on SmartObjectBlueprintLibrary_UseSmartObject");
static_assert(offsetof(SmartObjectBlueprintLibrary_UseSmartObject, User) == 0x000000, "Member 'SmartObjectBlueprintLibrary_UseSmartObject::User' has a wrong offset!");
static_assert(offsetof(SmartObjectBlueprintLibrary_UseSmartObject, SmartObject) == 0x000008, "Member 'SmartObjectBlueprintLibrary_UseSmartObject::SmartObject' has a wrong offset!");
static_assert(offsetof(SmartObjectBlueprintLibrary_UseSmartObject, ActionTag) == 0x000010, "Member 'SmartObjectBlueprintLibrary_UseSmartObject::ActionTag' has a wrong offset!");
static_assert(offsetof(SmartObjectBlueprintLibrary_UseSmartObject, bAbortExisting) == 0x000018, "Member 'SmartObjectBlueprintLibrary_UseSmartObject::bAbortExisting' has a wrong offset!");
static_assert(offsetof(SmartObjectBlueprintLibrary_UseSmartObject, bUntilInterrupted) == 0x000019, "Member 'SmartObjectBlueprintLibrary_UseSmartObject::bUntilInterrupted' has a wrong offset!");
static_assert(offsetof(SmartObjectBlueprintLibrary_UseSmartObject, ReturnValue) == 0x00001A, "Member 'SmartObjectBlueprintLibrary_UseSmartObject::ReturnValue' has a wrong offset!");

// Function GbxAI.SmartObjectComponent.BeginEventSignature
// 0x0008 (0x0008 - 0x0000)
struct SmartObjectComponent_BeginEventSignature final
{
public:
	class APawn*                                  User;                                              // 0x0000(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(SmartObjectComponent_BeginEventSignature) == 0x000008, "Wrong alignment on SmartObjectComponent_BeginEventSignature");
static_assert(sizeof(SmartObjectComponent_BeginEventSignature) == 0x000008, "Wrong size on SmartObjectComponent_BeginEventSignature");
static_assert(offsetof(SmartObjectComponent_BeginEventSignature, User) == 0x000000, "Member 'SmartObjectComponent_BeginEventSignature::User' has a wrong offset!");

// Function GbxAI.SmartObjectComponent.DisableAction
// 0x0008 (0x0008 - 0x0000)
struct SmartObjectComponent_DisableAction final
{
public:
	struct FGameplayTag                           ActionTag;                                         // 0x0000(0x0008)(Parm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(SmartObjectComponent_DisableAction) == 0x000008, "Wrong alignment on SmartObjectComponent_DisableAction");
static_assert(sizeof(SmartObjectComponent_DisableAction) == 0x000008, "Wrong size on SmartObjectComponent_DisableAction");
static_assert(offsetof(SmartObjectComponent_DisableAction, ActionTag) == 0x000000, "Member 'SmartObjectComponent_DisableAction::ActionTag' has a wrong offset!");

// Function GbxAI.SmartObjectComponent.EnableAction
// 0x0008 (0x0008 - 0x0000)
struct SmartObjectComponent_EnableAction final
{
public:
	struct FGameplayTag                           ActionTag;                                         // 0x0000(0x0008)(Parm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(SmartObjectComponent_EnableAction) == 0x000008, "Wrong alignment on SmartObjectComponent_EnableAction");
static_assert(sizeof(SmartObjectComponent_EnableAction) == 0x000008, "Wrong size on SmartObjectComponent_EnableAction");
static_assert(offsetof(SmartObjectComponent_EnableAction, ActionTag) == 0x000000, "Member 'SmartObjectComponent_EnableAction::ActionTag' has a wrong offset!");

// Function GbxAI.SmartObjectComponent.InterruptEventSignature
// 0x0008 (0x0008 - 0x0000)
struct SmartObjectComponent_InterruptEventSignature final
{
public:
	class APawn*                                  User;                                              // 0x0000(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(SmartObjectComponent_InterruptEventSignature) == 0x000008, "Wrong alignment on SmartObjectComponent_InterruptEventSignature");
static_assert(sizeof(SmartObjectComponent_InterruptEventSignature) == 0x000008, "Wrong size on SmartObjectComponent_InterruptEventSignature");
static_assert(offsetof(SmartObjectComponent_InterruptEventSignature, User) == 0x000000, "Member 'SmartObjectComponent_InterruptEventSignature::User' has a wrong offset!");

// Function GbxAI.SmartObjectComponent.OnActionEnded
// 0x0018 (0x0018 - 0x0000)
struct SmartObjectComponent_OnActionEnded final
{
public:
	EGbxActionEndState                            EndState;                                          // 0x0000(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1[0x7];                                        // 0x0001(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	struct FGameplayTag                           ActionName;                                        // 0x0008(0x0008)(Parm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class AController*                            User;                                              // 0x0010(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(SmartObjectComponent_OnActionEnded) == 0x000008, "Wrong alignment on SmartObjectComponent_OnActionEnded");
static_assert(sizeof(SmartObjectComponent_OnActionEnded) == 0x000018, "Wrong size on SmartObjectComponent_OnActionEnded");
static_assert(offsetof(SmartObjectComponent_OnActionEnded, EndState) == 0x000000, "Member 'SmartObjectComponent_OnActionEnded::EndState' has a wrong offset!");
static_assert(offsetof(SmartObjectComponent_OnActionEnded, ActionName) == 0x000008, "Member 'SmartObjectComponent_OnActionEnded::ActionName' has a wrong offset!");
static_assert(offsetof(SmartObjectComponent_OnActionEnded, User) == 0x000010, "Member 'SmartObjectComponent_OnActionEnded::User' has a wrong offset!");

// Function GbxAI.SmartObjectComponent.ReserveEventSignature
// 0x0008 (0x0008 - 0x0000)
struct SmartObjectComponent_ReserveEventSignature final
{
public:
	class APawn*                                  User;                                              // 0x0000(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(SmartObjectComponent_ReserveEventSignature) == 0x000008, "Wrong alignment on SmartObjectComponent_ReserveEventSignature");
static_assert(sizeof(SmartObjectComponent_ReserveEventSignature) == 0x000008, "Wrong size on SmartObjectComponent_ReserveEventSignature");
static_assert(offsetof(SmartObjectComponent_ReserveEventSignature, User) == 0x000000, "Member 'SmartObjectComponent_ReserveEventSignature::User' has a wrong offset!");

// Function GbxAI.SmartObjectComponent.SuccessEventSignature
// 0x0008 (0x0008 - 0x0000)
struct SmartObjectComponent_SuccessEventSignature final
{
public:
	class APawn*                                  User;                                              // 0x0000(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(SmartObjectComponent_SuccessEventSignature) == 0x000008, "Wrong alignment on SmartObjectComponent_SuccessEventSignature");
static_assert(sizeof(SmartObjectComponent_SuccessEventSignature) == 0x000008, "Wrong size on SmartObjectComponent_SuccessEventSignature");
static_assert(offsetof(SmartObjectComponent_SuccessEventSignature, User) == 0x000000, "Member 'SmartObjectComponent_SuccessEventSignature::User' has a wrong offset!");

// Function GbxAI.SmartObjectComponent.ToggleActionSet
// 0x0020 (0x0020 - 0x0000)
struct SmartObjectComponent_ToggleActionSet final
{
public:
	struct FSmartObjectActionSet                  ActionSet;                                         // 0x0000(0x0020)(Parm, NativeAccessSpecifierPublic)
};
static_assert(alignof(SmartObjectComponent_ToggleActionSet) == 0x000008, "Wrong alignment on SmartObjectComponent_ToggleActionSet");
static_assert(sizeof(SmartObjectComponent_ToggleActionSet) == 0x000020, "Wrong size on SmartObjectComponent_ToggleActionSet");
static_assert(offsetof(SmartObjectComponent_ToggleActionSet, ActionSet) == 0x000000, "Member 'SmartObjectComponent_ToggleActionSet::ActionSet' has a wrong offset!");

// Function GbxAI.SmartObjectComponent.UnreserveEventSignature
// 0x0008 (0x0008 - 0x0000)
struct SmartObjectComponent_UnreserveEventSignature final
{
public:
	class APawn*                                  User;                                              // 0x0000(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(SmartObjectComponent_UnreserveEventSignature) == 0x000008, "Wrong alignment on SmartObjectComponent_UnreserveEventSignature");
static_assert(sizeof(SmartObjectComponent_UnreserveEventSignature) == 0x000008, "Wrong size on SmartObjectComponent_UnreserveEventSignature");
static_assert(offsetof(SmartObjectComponent_UnreserveEventSignature, User) == 0x000000, "Member 'SmartObjectComponent_UnreserveEventSignature::User' has a wrong offset!");

// Function GbxAI.SmartObjectComponent.GetActionUsers
// 0x0018 (0x0018 - 0x0000)
struct SmartObjectComponent_GetActionUsers final
{
public:
	struct FGameplayTag                           ActionTag;                                         // 0x0000(0x0008)(Parm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TArray<class APawn*>                          OutUsers;                                          // 0x0008(0x0010)(Parm, OutParm, ZeroConstructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(SmartObjectComponent_GetActionUsers) == 0x000008, "Wrong alignment on SmartObjectComponent_GetActionUsers");
static_assert(sizeof(SmartObjectComponent_GetActionUsers) == 0x000018, "Wrong size on SmartObjectComponent_GetActionUsers");
static_assert(offsetof(SmartObjectComponent_GetActionUsers, ActionTag) == 0x000000, "Member 'SmartObjectComponent_GetActionUsers::ActionTag' has a wrong offset!");
static_assert(offsetof(SmartObjectComponent_GetActionUsers, OutUsers) == 0x000008, "Member 'SmartObjectComponent_GetActionUsers::OutUsers' has a wrong offset!");

// Function GbxAI.SmartObjectComponent.GetAvailableSocketNames
// 0x0010 (0x0010 - 0x0000)
struct SmartObjectComponent_GetAvailableSocketNames final
{
public:
	TArray<class FName>                           Array;                                             // 0x0000(0x0010)(Parm, OutParm, ZeroConstructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(SmartObjectComponent_GetAvailableSocketNames) == 0x000008, "Wrong alignment on SmartObjectComponent_GetAvailableSocketNames");
static_assert(sizeof(SmartObjectComponent_GetAvailableSocketNames) == 0x000010, "Wrong size on SmartObjectComponent_GetAvailableSocketNames");
static_assert(offsetof(SmartObjectComponent_GetAvailableSocketNames, Array) == 0x000000, "Member 'SmartObjectComponent_GetAvailableSocketNames::Array' has a wrong offset!");

// Function GbxAI.SpawnBlueprintLibrary.GenerateSpawnerByOwningSpawner
// 0x0018 (0x0018 - 0x0000)
struct SpawnBlueprintLibrary_GenerateSpawnerByOwningSpawner final
{
public:
	class AActor*                                 Instigator;                                        // 0x0000(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class USpawnerStyle*                          Style;                                             // 0x0008(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class ASpawner*                               ReturnValue;                                       // 0x0010(0x0008)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(SpawnBlueprintLibrary_GenerateSpawnerByOwningSpawner) == 0x000008, "Wrong alignment on SpawnBlueprintLibrary_GenerateSpawnerByOwningSpawner");
static_assert(sizeof(SpawnBlueprintLibrary_GenerateSpawnerByOwningSpawner) == 0x000018, "Wrong size on SpawnBlueprintLibrary_GenerateSpawnerByOwningSpawner");
static_assert(offsetof(SpawnBlueprintLibrary_GenerateSpawnerByOwningSpawner, Instigator) == 0x000000, "Member 'SpawnBlueprintLibrary_GenerateSpawnerByOwningSpawner::Instigator' has a wrong offset!");
static_assert(offsetof(SpawnBlueprintLibrary_GenerateSpawnerByOwningSpawner, Style) == 0x000008, "Member 'SpawnBlueprintLibrary_GenerateSpawnerByOwningSpawner::Style' has a wrong offset!");
static_assert(offsetof(SpawnBlueprintLibrary_GenerateSpawnerByOwningSpawner, ReturnValue) == 0x000010, "Member 'SpawnBlueprintLibrary_GenerateSpawnerByOwningSpawner::ReturnValue' has a wrong offset!");

// Function GbxAI.SpawnBlueprintLibrary.GenerateSpawnerByRadius
// 0x0020 (0x0020 - 0x0000)
struct SpawnBlueprintLibrary_GenerateSpawnerByRadius final
{
public:
	class AActor*                                 Instigator;                                        // 0x0000(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class USpawnerStyle*                          Style;                                             // 0x0008(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         Radius;                                            // 0x0010(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	ETeamAttitude                                 MinRequiredAttitude;                               // 0x0014(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_15[0x3];                                       // 0x0015(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	class ASpawner*                               ReturnValue;                                       // 0x0018(0x0008)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(SpawnBlueprintLibrary_GenerateSpawnerByRadius) == 0x000008, "Wrong alignment on SpawnBlueprintLibrary_GenerateSpawnerByRadius");
static_assert(sizeof(SpawnBlueprintLibrary_GenerateSpawnerByRadius) == 0x000020, "Wrong size on SpawnBlueprintLibrary_GenerateSpawnerByRadius");
static_assert(offsetof(SpawnBlueprintLibrary_GenerateSpawnerByRadius, Instigator) == 0x000000, "Member 'SpawnBlueprintLibrary_GenerateSpawnerByRadius::Instigator' has a wrong offset!");
static_assert(offsetof(SpawnBlueprintLibrary_GenerateSpawnerByRadius, Style) == 0x000008, "Member 'SpawnBlueprintLibrary_GenerateSpawnerByRadius::Style' has a wrong offset!");
static_assert(offsetof(SpawnBlueprintLibrary_GenerateSpawnerByRadius, Radius) == 0x000010, "Member 'SpawnBlueprintLibrary_GenerateSpawnerByRadius::Radius' has a wrong offset!");
static_assert(offsetof(SpawnBlueprintLibrary_GenerateSpawnerByRadius, MinRequiredAttitude) == 0x000014, "Member 'SpawnBlueprintLibrary_GenerateSpawnerByRadius::MinRequiredAttitude' has a wrong offset!");
static_assert(offsetof(SpawnBlueprintLibrary_GenerateSpawnerByRadius, ReturnValue) == 0x000018, "Member 'SpawnBlueprintLibrary_GenerateSpawnerByRadius::ReturnValue' has a wrong offset!");

// Function GbxAI.SpawnBlueprintLibrary.SetSpawnOptions
// 0x0010 (0x0010 - 0x0000)
struct SpawnBlueprintLibrary_SetSpawnOptions final
{
public:
	class AActor*                                 SpawnerActor;                                      // 0x0000(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class USpawnOptionData*                       SpawnOptions;                                      // 0x0008(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(SpawnBlueprintLibrary_SetSpawnOptions) == 0x000008, "Wrong alignment on SpawnBlueprintLibrary_SetSpawnOptions");
static_assert(sizeof(SpawnBlueprintLibrary_SetSpawnOptions) == 0x000010, "Wrong size on SpawnBlueprintLibrary_SetSpawnOptions");
static_assert(offsetof(SpawnBlueprintLibrary_SetSpawnOptions, SpawnerActor) == 0x000000, "Member 'SpawnBlueprintLibrary_SetSpawnOptions::SpawnerActor' has a wrong offset!");
static_assert(offsetof(SpawnBlueprintLibrary_SetSpawnOptions, SpawnOptions) == 0x000008, "Member 'SpawnBlueprintLibrary_SetSpawnOptions::SpawnOptions' has a wrong offset!");

}

