#pragma once

/*
* SDK generated by Dumper-7
*
* https://github.com/Encryqed/Dumper-7
*/

// Package: GbxMission

#include "Basic.hpp"

#include "CoreUObject_structs.hpp"
#include "GbxDialog_structs.hpp"


namespace SDK
{

// Enum GbxMission.EMissionEvent
// NumValues: 0x0007
enum class EMissionEvent : uint8
{
	NotStarted_Load                          = 0,
	Active_Load                              = 1,
	Complete_Load                            = 2,
	Activated                                = 3,
	Completed                                = 4,
	Failed                                   = 5,
	EMissionEvent_MAX                        = 6,
};

// Enum GbxMission.EMissionObjectiveEvent
// NumValues: 0x000C
enum class EMissionObjectiveEvent : uint8
{
	Inactive_Load                            = 0,
	Active_Load                              = 1,
	Dormant_Load                             = 2,
	Complete_Load                            = 3,
	Activated                                = 4,
	Deactivated                              = 5,
	Dormant                                  = 6,
	Cleared                                  = 7,
	Updated                                  = 8,
	Thwarted                                 = 9,
	Completed                                = 10,
	EMissionObjectiveEvent_MAX               = 11,
};

// Enum GbxMission.EMissionObjectiveSetEvent
// NumValues: 0x0008
enum class EMissionObjectiveSetEvent : uint8
{
	NotStarted_Load                          = 0,
	Active_Load                              = 1,
	Complete_Load                            = 2,
	Activated                                = 3,
	ObjectivesChanged                        = 4,
	Completed                                = 5,
	Advanced                                 = 6,
	EMissionObjectiveSetEvent_MAX            = 7,
};

// Enum GbxMission.EMissionValueType
// NumValues: 0x0002
enum class EMissionValueType : uint8
{
	Level                                    = 0,
	EMissionValueType_MAX                    = 1,
};

// Enum GbxMission.EMissionDebugStatus
// NumValues: 0x0007
enum class EMissionDebugStatus : uint8
{
	MDS_Ineligible                           = 0,
	MDS_Eligible                             = 1,
	MDS_DevMission                           = 2,
	MDS_Active                               = 3,
	MDS_Complete                             = 4,
	MDS_Failed                               = 5,
	MDS_MAX                                  = 6,
};

// Enum GbxMission.EMissionActiveResult
// NumValues: 0x0003
enum class EMissionActiveResult : uint8
{
	MissionActive                            = 0,
	NoMissionsActive                         = 1,
	EMissionActiveResult_MAX                 = 2,
};

// Enum GbxMission.EMissionAvailableResult
// NumValues: 0x0003
enum class EMissionAvailableResult : uint8
{
	MissionAvailable                         = 0,
	NoMissionsAvailable                      = 1,
	EMissionAvailableResult_MAX              = 2,
};

// Enum GbxMission.EObjectiveCountComparisonOperatorType
// NumValues: 0x0007
enum class EObjectiveCountComparisonOperatorType : uint8
{
	EqualTo                                  = 0,
	NotEqualTo                               = 1,
	LessThan                                 = 2,
	LessThanOrEqualTo                        = 3,
	GreaterThan                              = 4,
	GreaterThanOrEqualTo                     = 5,
	EObjectiveCountComparisonOperatorType_MAX = 6,
};

// Enum GbxMission.EMissionEnableConditionObjectiveSetObjectiveStatus
// NumValues: 0x0004
enum class EMissionEnableConditionObjectiveSetObjectiveStatus : uint8
{
	MECOSOS_Ignored                          = 0,
	MECOSOS_AllCompleteStatusMatters         = 1,
	MECOSOS_AllCompleteStatusIgnored         = 2,
	MECOSOS_MAX                              = 3,
};

// Enum GbxMission.EIconRadiusDrawStyle
// NumValues: 0x0005
enum class EIconRadiusDrawStyle : uint8
{
	None                                     = 0,
	Wire                                     = 1,
	Solid                                    = 2,
	SolidAndWire                             = 3,
	EIconRadiusDrawStyle_MAX                 = 4,
};

// Enum GbxMission.EMissionIconState
// NumValues: 0x0004
enum class EMissionIconState : uint8
{
	IconState_Default                        = 0,
	IconState_ForceDisabled                  = 1,
	IconState_ForceEnabled                   = 2,
	IconState_MAX                            = 3,
};

// Enum GbxMission.EMissionObjectiveDependencyStatus
// NumValues: 0x0003
enum class EMissionObjectiveDependencyStatus : uint8
{
	MODS_Active                              = 0,
	MODS_Complete                            = 1,
	MODS_MAX                                 = 2,
};

// Enum GbxMission.EMissionTimerEvent
// NumValues: 0x0005
enum class EMissionTimerEvent : uint8
{
	TimerStarted                             = 0,
	TimerStopped                             = 1,
	TimeAdded                                = 2,
	TimeExpired                              = 3,
	EMissionTimerEvent_MAX                   = 4,
};

// Enum GbxMission.EMissionObjectiveSetStatus
// NumValues: 0x0004
enum class EMissionObjectiveSetStatus : uint8
{
	MOSS_NotActive                           = 0,
	MOSS_Active                              = 1,
	MOSS_Unknown                             = 2,
	MOSS_MAX                                 = 3,
};

// Enum GbxMission.EMissionObjectiveStatus
// NumValues: 0x0006
enum class EMissionObjectiveStatus : uint8
{
	MOS_NotStarted                           = 0,
	MOS_Active                               = 1,
	MOS_Dormant                              = 2,
	MOS_Complete                             = 3,
	MOS_Unknown                              = 4,
	MOS_MAX                                  = 5,
};

// Enum GbxMission.EMissionStatus
// NumValues: 0x0006
enum class EMissionStatus : uint8
{
	MS_NotStarted                            = 0,
	MS_Active                                = 1,
	MS_Complete                              = 2,
	MS_Failed                                = 3,
	MS_Unknown                               = 4,
	MS_MAX                                   = 5,
};

// ScriptStruct GbxMission.MissionObjectiveReferenceBase
// 0x0028 (0x0028 - 0x0000)
struct alignas(0x08) FMissionObjectiveReferenceBase
{
public:
	uint8                                         Pad_0[0x8];                                        // 0x0000(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	class FName                                   ObjectiveName;                                     // 0x0008(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FGuid                                  ObjectiveGuid;                                     // 0x0010(0x0010)(Edit, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TWeakObjectPtr<class UMissionObjective>       Objective;                                         // 0x0020(0x0008)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
};
static_assert(alignof(FMissionObjectiveReferenceBase) == 0x000008, "Wrong alignment on FMissionObjectiveReferenceBase");
static_assert(sizeof(FMissionObjectiveReferenceBase) == 0x000028, "Wrong size on FMissionObjectiveReferenceBase");
static_assert(offsetof(FMissionObjectiveReferenceBase, ObjectiveName) == 0x000008, "Member 'FMissionObjectiveReferenceBase::ObjectiveName' has a wrong offset!");
static_assert(offsetof(FMissionObjectiveReferenceBase, ObjectiveGuid) == 0x000010, "Member 'FMissionObjectiveReferenceBase::ObjectiveGuid' has a wrong offset!");
static_assert(offsetof(FMissionObjectiveReferenceBase, Objective) == 0x000020, "Member 'FMissionObjectiveReferenceBase::Objective' has a wrong offset!");

// ScriptStruct GbxMission.MissionObjectiveReferenceWeak
// 0x0028 (0x0050 - 0x0028)
struct FMissionObjectiveReferenceWeak final : public FMissionObjectiveReferenceBase
{
public:
	TSoftClassPtr<class UClass>                   Mission;                                           // 0x0028(0x0028)(Edit, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
};
static_assert(alignof(FMissionObjectiveReferenceWeak) == 0x000008, "Wrong alignment on FMissionObjectiveReferenceWeak");
static_assert(sizeof(FMissionObjectiveReferenceWeak) == 0x000050, "Wrong size on FMissionObjectiveReferenceWeak");
static_assert(offsetof(FMissionObjectiveReferenceWeak, Mission) == 0x000028, "Member 'FMissionObjectiveReferenceWeak::Mission' has a wrong offset!");

// ScriptStruct GbxMission.MissionObjectiveDependency
// 0x0058 (0x0058 - 0x0000)
struct FMissionObjectiveDependency final
{
public:
	struct FMissionObjectiveReferenceWeak         ObjectiveRef;                                      // 0x0000(0x0050)(Edit, NativeAccessSpecifierPublic)
	EMissionObjectiveDependencyStatus             ObjectiveStatus;                                   // 0x0050(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_51[0x7];                                       // 0x0051(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FMissionObjectiveDependency) == 0x000008, "Wrong alignment on FMissionObjectiveDependency");
static_assert(sizeof(FMissionObjectiveDependency) == 0x000058, "Wrong size on FMissionObjectiveDependency");
static_assert(offsetof(FMissionObjectiveDependency, ObjectiveRef) == 0x000000, "Member 'FMissionObjectiveDependency::ObjectiveRef' has a wrong offset!");
static_assert(offsetof(FMissionObjectiveDependency, ObjectiveStatus) == 0x000050, "Member 'FMissionObjectiveDependency::ObjectiveStatus' has a wrong offset!");

// ScriptStruct GbxMission.MissionObjectiveReference
// 0x0008 (0x0030 - 0x0028)
struct FMissionObjectiveReference final : public FMissionObjectiveReferenceBase
{
public:
	TSubclassOf<class UMission>                   Mission;                                           // 0x0028(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FMissionObjectiveReference) == 0x000008, "Wrong alignment on FMissionObjectiveReference");
static_assert(sizeof(FMissionObjectiveReference) == 0x000030, "Wrong size on FMissionObjectiveReference");
static_assert(offsetof(FMissionObjectiveReference, Mission) == 0x000028, "Member 'FMissionObjectiveReference::Mission' has a wrong offset!");

// ScriptStruct GbxMission.MissionLocation
// 0x0030 (0x0030 - 0x0000)
struct FMissionLocation final
{
public:
	TSoftObjectPtr<class UTravelStationData>      TravelStation;                                     // 0x0000(0x0028)(Edit, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UGbxCondition*                          StationCondition;                                  // 0x0028(0x0008)(Edit, ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, PersistentInstance, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FMissionLocation) == 0x000008, "Wrong alignment on FMissionLocation");
static_assert(sizeof(FMissionLocation) == 0x000030, "Wrong size on FMissionLocation");
static_assert(offsetof(FMissionLocation, TravelStation) == 0x000000, "Member 'FMissionLocation::TravelStation' has a wrong offset!");
static_assert(offsetof(FMissionLocation, StationCondition) == 0x000028, "Member 'FMissionLocation::StationCondition' has a wrong offset!");

// ScriptStruct GbxMission.MissionObjectiveSetReference
// 0x0048 (0x0048 - 0x0000)
struct FMissionObjectiveSetReference final
{
public:
	TSoftClassPtr<class UClass>                   Mission;                                           // 0x0000(0x0028)(Edit, BlueprintVisible, BlueprintReadOnly, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class FName                                   ObjectiveSetName;                                  // 0x0028(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FGuid                                  ObjectiveSetGuid;                                  // 0x0030(0x0010)(Edit, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TWeakObjectPtr<class UMissionObjectiveSet>    ObjectiveSet;                                      // 0x0040(0x0008)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
};
static_assert(alignof(FMissionObjectiveSetReference) == 0x000008, "Wrong alignment on FMissionObjectiveSetReference");
static_assert(sizeof(FMissionObjectiveSetReference) == 0x000048, "Wrong size on FMissionObjectiveSetReference");
static_assert(offsetof(FMissionObjectiveSetReference, Mission) == 0x000000, "Member 'FMissionObjectiveSetReference::Mission' has a wrong offset!");
static_assert(offsetof(FMissionObjectiveSetReference, ObjectiveSetName) == 0x000028, "Member 'FMissionObjectiveSetReference::ObjectiveSetName' has a wrong offset!");
static_assert(offsetof(FMissionObjectiveSetReference, ObjectiveSetGuid) == 0x000030, "Member 'FMissionObjectiveSetReference::ObjectiveSetGuid' has a wrong offset!");
static_assert(offsetof(FMissionObjectiveSetReference, ObjectiveSet) == 0x000040, "Member 'FMissionObjectiveSetReference::ObjectiveSet' has a wrong offset!");

// ScriptStruct GbxMission.MissionObjectiveChain
// 0x0010 (0x0010 - 0x0000)
struct FMissionObjectiveChain final
{
public:
	TArray<class UMissionObjective*>              ObjectiveChain;                                    // 0x0000(0x0010)(Edit, ZeroConstructor, EditConst, NativeAccessSpecifierPublic)
};
static_assert(alignof(FMissionObjectiveChain) == 0x000008, "Wrong alignment on FMissionObjectiveChain");
static_assert(sizeof(FMissionObjectiveChain) == 0x000010, "Wrong size on FMissionObjectiveChain");
static_assert(offsetof(FMissionObjectiveChain, ObjectiveChain) == 0x000000, "Member 'FMissionObjectiveChain::ObjectiveChain' has a wrong offset!");

// ScriptStruct GbxMission.MissionEventReference
// 0x0010 (0x0010 - 0x0000)
struct FMissionEventReference final
{
public:
	TSubclassOf<class UMission>                   Mission;                                           // 0x0000(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   EventName;                                         // 0x0008(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FMissionEventReference) == 0x000008, "Wrong alignment on FMissionEventReference");
static_assert(sizeof(FMissionEventReference) == 0x000010, "Wrong size on FMissionEventReference");
static_assert(offsetof(FMissionEventReference, Mission) == 0x000000, "Member 'FMissionEventReference::Mission' has a wrong offset!");
static_assert(offsetof(FMissionEventReference, EventName) == 0x000008, "Member 'FMissionEventReference::EventName' has a wrong offset!");

// ScriptStruct GbxMission.MissionEnableConditionEvent
// 0x0020 (0x0020 - 0x0000)
struct FMissionEnableConditionEvent final
{
public:
	class FName                                   EventName;                                         // 0x0000(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UMissionEnableCondition*                EnableCondition;                                   // 0x0008(0x0008)(Edit, BlueprintVisible, ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, PersistentInstance, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	UMulticastDelegateProperty_                   OnLoad;                                            // 0x0010(0x0010)(ZeroConstructor, Transient, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
};
static_assert(alignof(FMissionEnableConditionEvent) == 0x000008, "Wrong alignment on FMissionEnableConditionEvent");
static_assert(sizeof(FMissionEnableConditionEvent) == 0x000020, "Wrong size on FMissionEnableConditionEvent");
static_assert(offsetof(FMissionEnableConditionEvent, EventName) == 0x000000, "Member 'FMissionEnableConditionEvent::EventName' has a wrong offset!");
static_assert(offsetof(FMissionEnableConditionEvent, EnableCondition) == 0x000008, "Member 'FMissionEnableConditionEvent::EnableCondition' has a wrong offset!");
static_assert(offsetof(FMissionEnableConditionEvent, OnLoad) == 0x000010, "Member 'FMissionEnableConditionEvent::OnLoad' has a wrong offset!");

// ScriptStruct GbxMission.MissionObjectiveData
// 0x0010 (0x0010 - 0x0000)
struct FMissionObjectiveData final
{
public:
	TSubclassOf<class UMission>                   MissionClass;                                      // 0x0000(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UMissionObjective*                      Objective;                                         // 0x0008(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FMissionObjectiveData) == 0x000008, "Wrong alignment on FMissionObjectiveData");
static_assert(sizeof(FMissionObjectiveData) == 0x000010, "Wrong size on FMissionObjectiveData");
static_assert(offsetof(FMissionObjectiveData, MissionClass) == 0x000000, "Member 'FMissionObjectiveData::MissionClass' has a wrong offset!");
static_assert(offsetof(FMissionObjectiveData, Objective) == 0x000008, "Member 'FMissionObjectiveData::Objective' has a wrong offset!");

// ScriptStruct GbxMission.ActiveMissionIconData
// 0x0070 (0x0070 - 0x0000)
struct FActiveMissionIconData final
{
public:
	TScriptInterface<class IMissionIconInterface> Icon;                                              // 0x0000(0x0010)(ZeroConstructor, IsPlainOldData, NoDestructor, UObjectWrapper, NativeAccessSpecifierPublic)
	struct FGuid                                  IconGuid;                                          // 0x0010(0x0010)(IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TWeakObjectPtr<class USceneComponent>         IconLocationComponent;                             // 0x0020(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                IconLocation;                                      // 0x0028(0x000C)(IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint32                                        WaypointRadius;                                    // 0x0034(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UDataAsset*                             IconData;                                          // 0x0038(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TSubclassOf<class UMission>                   MissionClass;                                      // 0x0040(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TArray<class UMissionObjective*>              MissionObjectives;                                 // 0x0048(0x0010)(ZeroConstructor, NativeAccessSpecifierPublic)
	float                                         VisibleDistanceOverride;                           // 0x0058(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         HiddenDistanceOverride;                            // 0x005C(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bHideAreaWaypoint;                                 // 0x0060(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_61[0x7];                                       // 0x0061(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	TSubclassOf<class UPrimitiveComponent>        AreaComponentClassOverride;                        // 0x0068(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FActiveMissionIconData) == 0x000008, "Wrong alignment on FActiveMissionIconData");
static_assert(sizeof(FActiveMissionIconData) == 0x000070, "Wrong size on FActiveMissionIconData");
static_assert(offsetof(FActiveMissionIconData, Icon) == 0x000000, "Member 'FActiveMissionIconData::Icon' has a wrong offset!");
static_assert(offsetof(FActiveMissionIconData, IconGuid) == 0x000010, "Member 'FActiveMissionIconData::IconGuid' has a wrong offset!");
static_assert(offsetof(FActiveMissionIconData, IconLocationComponent) == 0x000020, "Member 'FActiveMissionIconData::IconLocationComponent' has a wrong offset!");
static_assert(offsetof(FActiveMissionIconData, IconLocation) == 0x000028, "Member 'FActiveMissionIconData::IconLocation' has a wrong offset!");
static_assert(offsetof(FActiveMissionIconData, WaypointRadius) == 0x000034, "Member 'FActiveMissionIconData::WaypointRadius' has a wrong offset!");
static_assert(offsetof(FActiveMissionIconData, IconData) == 0x000038, "Member 'FActiveMissionIconData::IconData' has a wrong offset!");
static_assert(offsetof(FActiveMissionIconData, MissionClass) == 0x000040, "Member 'FActiveMissionIconData::MissionClass' has a wrong offset!");
static_assert(offsetof(FActiveMissionIconData, MissionObjectives) == 0x000048, "Member 'FActiveMissionIconData::MissionObjectives' has a wrong offset!");
static_assert(offsetof(FActiveMissionIconData, VisibleDistanceOverride) == 0x000058, "Member 'FActiveMissionIconData::VisibleDistanceOverride' has a wrong offset!");
static_assert(offsetof(FActiveMissionIconData, HiddenDistanceOverride) == 0x00005C, "Member 'FActiveMissionIconData::HiddenDistanceOverride' has a wrong offset!");
static_assert(offsetof(FActiveMissionIconData, bHideAreaWaypoint) == 0x000060, "Member 'FActiveMissionIconData::bHideAreaWaypoint' has a wrong offset!");
static_assert(offsetof(FActiveMissionIconData, AreaComponentClassOverride) == 0x000068, "Member 'FActiveMissionIconData::AreaComponentClassOverride' has a wrong offset!");

// ScriptStruct GbxMission.MissionObserverEvent
// 0x0038 (0x0038 - 0x0000)
struct FMissionObserverEvent final
{
public:
	class FName                                   EventName;                                         // 0x0000(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bLastConditionValue;                               // 0x0008(0x0001)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_9[0x7];                                        // 0x0009(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	class UGbxCondition*                          EnabledCondition;                                  // 0x0010(0x0008)(Edit, BlueprintVisible, ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, PersistentInstance, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	UMulticastDelegateProperty_                   OnConditionTrue;                                   // 0x0018(0x0010)(ZeroConstructor, Transient, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	UMulticastDelegateProperty_                   OnConditionFalse;                                  // 0x0028(0x0010)(ZeroConstructor, Transient, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
};
static_assert(alignof(FMissionObserverEvent) == 0x000008, "Wrong alignment on FMissionObserverEvent");
static_assert(sizeof(FMissionObserverEvent) == 0x000038, "Wrong size on FMissionObserverEvent");
static_assert(offsetof(FMissionObserverEvent, EventName) == 0x000000, "Member 'FMissionObserverEvent::EventName' has a wrong offset!");
static_assert(offsetof(FMissionObserverEvent, bLastConditionValue) == 0x000008, "Member 'FMissionObserverEvent::bLastConditionValue' has a wrong offset!");
static_assert(offsetof(FMissionObserverEvent, EnabledCondition) == 0x000010, "Member 'FMissionObserverEvent::EnabledCondition' has a wrong offset!");
static_assert(offsetof(FMissionObserverEvent, OnConditionTrue) == 0x000018, "Member 'FMissionObserverEvent::OnConditionTrue' has a wrong offset!");
static_assert(offsetof(FMissionObserverEvent, OnConditionFalse) == 0x000028, "Member 'FMissionObserverEvent::OnConditionFalse' has a wrong offset!");

// ScriptStruct GbxMission.DefendMissionTargetData
// 0x0010 (0x0010 - 0x0000)
struct FDefendMissionTargetData final
{
public:
	class UMissionObjective*                      Objective;                                         // 0x0000(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint32                                        PercentHealth;                                     // 0x0008(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_C[0x4];                                        // 0x000C(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FDefendMissionTargetData) == 0x000008, "Wrong alignment on FDefendMissionTargetData");
static_assert(sizeof(FDefendMissionTargetData) == 0x000010, "Wrong size on FDefendMissionTargetData");
static_assert(offsetof(FDefendMissionTargetData, Objective) == 0x000000, "Member 'FDefendMissionTargetData::Objective' has a wrong offset!");
static_assert(offsetof(FDefendMissionTargetData, PercentHealth) == 0x000008, "Member 'FDefendMissionTargetData::PercentHealth' has a wrong offset!");

// ScriptStruct GbxMission.DefendMissionData
// 0x0018 (0x0018 - 0x0000)
struct alignas(0x08) FDefendMissionData final
{
public:
	uint8                                         Pad_0[0x18];                                       // 0x0000(0x0018)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FDefendMissionData) == 0x000008, "Wrong alignment on FDefendMissionData");
static_assert(sizeof(FDefendMissionData) == 0x000018, "Wrong size on FDefendMissionData");

// ScriptStruct GbxMission.MissionStatusPlayerData
// 0x0030 (0x0030 - 0x0000)
struct FMissionStatusPlayerData final
{
public:
	TSubclassOf<class UMission>                   MissionClass;                                      // 0x0000(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EMissionStatus                                Status;                                            // 0x0008(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_9[0x7];                                        // 0x0009(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<uint32>                                ObjectivesProgress;                                // 0x0010(0x0010)(ZeroConstructor, NativeAccessSpecifierPublic)
	class UMissionObjectiveSet*                   ActiveObjectiveSet;                                // 0x0020(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bHasBeenViewedInLog;                               // 0x0028(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bKickoffPlayed;                                    // 0x0029(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         LeagueInstance;                                    // 0x002A(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2B[0x5];                                       // 0x002B(0x0005)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FMissionStatusPlayerData) == 0x000008, "Wrong alignment on FMissionStatusPlayerData");
static_assert(sizeof(FMissionStatusPlayerData) == 0x000030, "Wrong size on FMissionStatusPlayerData");
static_assert(offsetof(FMissionStatusPlayerData, MissionClass) == 0x000000, "Member 'FMissionStatusPlayerData::MissionClass' has a wrong offset!");
static_assert(offsetof(FMissionStatusPlayerData, Status) == 0x000008, "Member 'FMissionStatusPlayerData::Status' has a wrong offset!");
static_assert(offsetof(FMissionStatusPlayerData, ObjectivesProgress) == 0x000010, "Member 'FMissionStatusPlayerData::ObjectivesProgress' has a wrong offset!");
static_assert(offsetof(FMissionStatusPlayerData, ActiveObjectiveSet) == 0x000020, "Member 'FMissionStatusPlayerData::ActiveObjectiveSet' has a wrong offset!");
static_assert(offsetof(FMissionStatusPlayerData, bHasBeenViewedInLog) == 0x000028, "Member 'FMissionStatusPlayerData::bHasBeenViewedInLog' has a wrong offset!");
static_assert(offsetof(FMissionStatusPlayerData, bKickoffPlayed) == 0x000029, "Member 'FMissionStatusPlayerData::bKickoffPlayed' has a wrong offset!");
static_assert(offsetof(FMissionStatusPlayerData, LeagueInstance) == 0x00002A, "Member 'FMissionStatusPlayerData::LeagueInstance' has a wrong offset!");

// ScriptStruct GbxMission.MissionPlaythroughData
// 0x0018 (0x0018 - 0x0000)
struct FMissionPlaythroughData final
{
public:
	TArray<struct FMissionStatusPlayerData>       MissionList;                                       // 0x0000(0x0010)(ZeroConstructor, NativeAccessSpecifierPublic)
	TSubclassOf<class UMission>                   TrackedMission;                                    // 0x0010(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FMissionPlaythroughData) == 0x000008, "Wrong alignment on FMissionPlaythroughData");
static_assert(sizeof(FMissionPlaythroughData) == 0x000018, "Wrong size on FMissionPlaythroughData");
static_assert(offsetof(FMissionPlaythroughData, MissionList) == 0x000000, "Member 'FMissionPlaythroughData::MissionList' has a wrong offset!");
static_assert(offsetof(FMissionPlaythroughData, TrackedMission) == 0x000010, "Member 'FMissionPlaythroughData::TrackedMission' has a wrong offset!");

// ScriptStruct GbxMission.ReplicatedMissionProgress
// 0x0078 (0x0078 - 0x0000)
struct alignas(0x08) FReplicatedMissionProgress final
{
public:
	uint8                                         Pad_0[0x78];                                       // 0x0000(0x0078)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FReplicatedMissionProgress) == 0x000008, "Wrong alignment on FReplicatedMissionProgress");
static_assert(sizeof(FReplicatedMissionProgress) == 0x000078, "Wrong size on FReplicatedMissionProgress");

// ScriptStruct GbxMission.TimedMissionData
// 0x0018 (0x0018 - 0x0000)
struct FTimedMissionData final
{
public:
	TSubclassOf<class UMission>                   MissionClass;                                      // 0x0000(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         SecondsLeft;                                       // 0x0008(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         StartingSeconds;                                   // 0x000C(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bTimerRunning;                                     // 0x0010(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bFailOnTimerExpiration;                            // 0x0011(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bTimerExpired;                                     // 0x0012(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_13[0x5];                                       // 0x0013(0x0005)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FTimedMissionData) == 0x000008, "Wrong alignment on FTimedMissionData");
static_assert(sizeof(FTimedMissionData) == 0x000018, "Wrong size on FTimedMissionData");
static_assert(offsetof(FTimedMissionData, MissionClass) == 0x000000, "Member 'FTimedMissionData::MissionClass' has a wrong offset!");
static_assert(offsetof(FTimedMissionData, SecondsLeft) == 0x000008, "Member 'FTimedMissionData::SecondsLeft' has a wrong offset!");
static_assert(offsetof(FTimedMissionData, StartingSeconds) == 0x00000C, "Member 'FTimedMissionData::StartingSeconds' has a wrong offset!");
static_assert(offsetof(FTimedMissionData, bTimerRunning) == 0x000010, "Member 'FTimedMissionData::bTimerRunning' has a wrong offset!");
static_assert(offsetof(FTimedMissionData, bFailOnTimerExpiration) == 0x000011, "Member 'FTimedMissionData::bFailOnTimerExpiration' has a wrong offset!");
static_assert(offsetof(FTimedMissionData, bTimerExpired) == 0x000012, "Member 'FTimedMissionData::bTimerExpired' has a wrong offset!");

// ScriptStruct GbxMission.ReplicatedMissionData
// 0x0028 (0x0028 - 0x0000)
struct FReplicatedMissionData final
{
public:
	TArray<struct FReplicatedMissionProgress>     Progress;                                          // 0x0000(0x0010)(ZeroConstructor, NativeAccessSpecifierPublic)
	TSubclassOf<class UMission>                   TrackedMission;                                    // 0x0010(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TArray<struct FTimedMissionData>              ActiveTimedMissions;                               // 0x0018(0x0010)(ZeroConstructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(FReplicatedMissionData) == 0x000008, "Wrong alignment on FReplicatedMissionData");
static_assert(sizeof(FReplicatedMissionData) == 0x000028, "Wrong size on FReplicatedMissionData");
static_assert(offsetof(FReplicatedMissionData, Progress) == 0x000000, "Member 'FReplicatedMissionData::Progress' has a wrong offset!");
static_assert(offsetof(FReplicatedMissionData, TrackedMission) == 0x000010, "Member 'FReplicatedMissionData::TrackedMission' has a wrong offset!");
static_assert(offsetof(FReplicatedMissionData, ActiveTimedMissions) == 0x000018, "Member 'FReplicatedMissionData::ActiveTimedMissions' has a wrong offset!");

// ScriptStruct GbxMission.MissionProgress
// 0x0080 (0x0080 - 0x0000)
struct FMissionProgress final
{
public:
	class UMission*                               Mission;                                           // 0x0000(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TSubclassOf<class UMission>                   MissionClass;                                      // 0x0008(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EMissionStatus                                Status;                                            // 0x0010(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_11[0x7];                                       // 0x0011(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<uint32>                                ObjectivesProgress;                                // 0x0018(0x0010)(ZeroConstructor, NativeAccessSpecifierPublic)
	class UMissionObjectiveSet*                   ActiveObjectiveSet;                                // 0x0028(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TArray<class UMissionObjective*>              DormantObjectives;                                 // 0x0030(0x0010)(ZeroConstructor, NativeAccessSpecifierPublic)
	TArray<class UMissionObjective*>              PausedObjectiveChains;                             // 0x0040(0x0010)(ZeroConstructor, NativeAccessSpecifierPublic)
	bool                                          bActivateScriptWhenDependenciesMet;                // 0x0050(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_51[0x7];                                       // 0x0051(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	struct FDialogScriptPinnedRef                 ActivatedDialogScript;                             // 0x0058(0x0010)(NativeAccessSpecifierPublic)
	bool                                          bKickoffPlayed;                                    // 0x0068(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bHasMissionFailed;                                 // 0x0069(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bReplicationError;                                 // 0x006A(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_6B[0x15];                                      // 0x006B(0x0015)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FMissionProgress) == 0x000008, "Wrong alignment on FMissionProgress");
static_assert(sizeof(FMissionProgress) == 0x000080, "Wrong size on FMissionProgress");
static_assert(offsetof(FMissionProgress, Mission) == 0x000000, "Member 'FMissionProgress::Mission' has a wrong offset!");
static_assert(offsetof(FMissionProgress, MissionClass) == 0x000008, "Member 'FMissionProgress::MissionClass' has a wrong offset!");
static_assert(offsetof(FMissionProgress, Status) == 0x000010, "Member 'FMissionProgress::Status' has a wrong offset!");
static_assert(offsetof(FMissionProgress, ObjectivesProgress) == 0x000018, "Member 'FMissionProgress::ObjectivesProgress' has a wrong offset!");
static_assert(offsetof(FMissionProgress, ActiveObjectiveSet) == 0x000028, "Member 'FMissionProgress::ActiveObjectiveSet' has a wrong offset!");
static_assert(offsetof(FMissionProgress, DormantObjectives) == 0x000030, "Member 'FMissionProgress::DormantObjectives' has a wrong offset!");
static_assert(offsetof(FMissionProgress, PausedObjectiveChains) == 0x000040, "Member 'FMissionProgress::PausedObjectiveChains' has a wrong offset!");
static_assert(offsetof(FMissionProgress, bActivateScriptWhenDependenciesMet) == 0x000050, "Member 'FMissionProgress::bActivateScriptWhenDependenciesMet' has a wrong offset!");
static_assert(offsetof(FMissionProgress, ActivatedDialogScript) == 0x000058, "Member 'FMissionProgress::ActivatedDialogScript' has a wrong offset!");
static_assert(offsetof(FMissionProgress, bKickoffPlayed) == 0x000068, "Member 'FMissionProgress::bKickoffPlayed' has a wrong offset!");
static_assert(offsetof(FMissionProgress, bHasMissionFailed) == 0x000069, "Member 'FMissionProgress::bHasMissionFailed' has a wrong offset!");
static_assert(offsetof(FMissionProgress, bReplicationError) == 0x00006A, "Member 'FMissionProgress::bReplicationError' has a wrong offset!");

}

