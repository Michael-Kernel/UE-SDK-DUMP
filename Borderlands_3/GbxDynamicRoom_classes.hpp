#pragma once

/*
* SDK generated by Dumper-7
*
* https://github.com/Encryqed/Dumper-7
*/

// Package: GbxDynamicRoom

#include "Basic.hpp"

#include "GbxDynamicRoom_structs.hpp"
#include "Engine_classes.hpp"
#include "GbxRuntime_classes.hpp"
#include "CoreUObject_structs.hpp"
#include "CoreUObject_classes.hpp"


namespace SDK
{

// Class GbxDynamicRoom.DynamicRoomBase
// 0x0098 (0x04F0 - 0x0458)
class ADynamicRoomBase : public AActor
{
public:
	TArray<class UDynamicRoomBaseData*>           SelectableLevels;                                  // 0x0458(0x0010)(Edit, ZeroConstructor, NativeAccessSpecifierPublic)
	bool                                          bShowRandomRoomOnStartup;                          // 0x0468(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_469[0x7];                                      // 0x0469(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	UMulticastDelegateProperty_                   OnRoomLoaded;                                      // 0x0470(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	UMulticastDelegateProperty_                   OnRoomUnloaded;                                    // 0x0480(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	UMulticastDelegateProperty_                   OnRoomVisible;                                     // 0x0490(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	UMulticastDelegateProperty_                   OnRoomVisibleForAllPlayers;                        // 0x04A0(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	struct FDynamicRoomReplicationInfo            RoomInfoToLoad;                                    // 0x04B0(0x0010)(Net, IsPlainOldData, RepNotify, NoDestructor, NativeAccessSpecifierPublic)
	struct FDynamicRoomInstanceInfo               InstanceInfo;                                      // 0x04C0(0x0018)(NoDestructor, NativeAccessSpecifierPublic)
	class UBillboardComponent*                    SpriteComponent;                                   // 0x04D8(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UDynamicRoomBaseData*                   CachedRoomDataReference;                           // 0x04E0(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_4E8[0x8];                                      // 0x04E8(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void AllPlayerVisibilityTest();
	void GetAvailableRoomData(TArray<class UDynamicRoomBaseData*>* AvailableRooms);
	class UDynamicRoomBaseData* GetCurrentRoomData();
	void GetPlayersInLevel(TArray<class AGbxCharacter*>* Players);
	void InstanceRandomRoom();
	void InstanceRoom(class UDynamicRoomBaseData* RoomToLoad);
	void OnRep_RoomInfoToLoad(struct FDynamicRoomReplicationInfo* OldRoomInfoToLoad);
	void SelectedRoomClassLoaded();
	void SelectedRoomLoaded();
	void SelectedRoomVisible();
	void UnloadRoom();
	bool VisibleForAllPlayers();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"DynamicRoomBase">();
	}
	static class ADynamicRoomBase* GetDefaultObj()
	{
		return GetDefaultObjImpl<ADynamicRoomBase>();
	}
};
static_assert(alignof(ADynamicRoomBase) == 0x000008, "Wrong alignment on ADynamicRoomBase");
static_assert(sizeof(ADynamicRoomBase) == 0x0004F0, "Wrong size on ADynamicRoomBase");
static_assert(offsetof(ADynamicRoomBase, SelectableLevels) == 0x000458, "Member 'ADynamicRoomBase::SelectableLevels' has a wrong offset!");
static_assert(offsetof(ADynamicRoomBase, bShowRandomRoomOnStartup) == 0x000468, "Member 'ADynamicRoomBase::bShowRandomRoomOnStartup' has a wrong offset!");
static_assert(offsetof(ADynamicRoomBase, OnRoomLoaded) == 0x000470, "Member 'ADynamicRoomBase::OnRoomLoaded' has a wrong offset!");
static_assert(offsetof(ADynamicRoomBase, OnRoomUnloaded) == 0x000480, "Member 'ADynamicRoomBase::OnRoomUnloaded' has a wrong offset!");
static_assert(offsetof(ADynamicRoomBase, OnRoomVisible) == 0x000490, "Member 'ADynamicRoomBase::OnRoomVisible' has a wrong offset!");
static_assert(offsetof(ADynamicRoomBase, OnRoomVisibleForAllPlayers) == 0x0004A0, "Member 'ADynamicRoomBase::OnRoomVisibleForAllPlayers' has a wrong offset!");
static_assert(offsetof(ADynamicRoomBase, RoomInfoToLoad) == 0x0004B0, "Member 'ADynamicRoomBase::RoomInfoToLoad' has a wrong offset!");
static_assert(offsetof(ADynamicRoomBase, InstanceInfo) == 0x0004C0, "Member 'ADynamicRoomBase::InstanceInfo' has a wrong offset!");
static_assert(offsetof(ADynamicRoomBase, SpriteComponent) == 0x0004D8, "Member 'ADynamicRoomBase::SpriteComponent' has a wrong offset!");
static_assert(offsetof(ADynamicRoomBase, CachedRoomDataReference) == 0x0004E0, "Member 'ADynamicRoomBase::CachedRoomDataReference' has a wrong offset!");

// Class GbxDynamicRoom.DynamicRoomBaseData
// 0x0058 (0x0088 - 0x0030)
class UDynamicRoomBaseData : public UGbxDataAsset
{
public:
	class FText                                   DisplayName;                                       // 0x0030(0x0018)(Edit, NativeAccessSpecifierPublic)
	class FText                                   Description;                                       // 0x0048(0x0018)(Edit, NativeAccessSpecifierPublic)
	TSoftObjectPtr<class UTexture>                PreviewPicture;                                    // 0x0060(0x0028)(Edit, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"DynamicRoomBaseData">();
	}
	static class UDynamicRoomBaseData* GetDefaultObj()
	{
		return GetDefaultObjImpl<UDynamicRoomBaseData>();
	}
};
static_assert(alignof(UDynamicRoomBaseData) == 0x000008, "Wrong alignment on UDynamicRoomBaseData");
static_assert(sizeof(UDynamicRoomBaseData) == 0x000088, "Wrong size on UDynamicRoomBaseData");
static_assert(offsetof(UDynamicRoomBaseData, DisplayName) == 0x000030, "Member 'UDynamicRoomBaseData::DisplayName' has a wrong offset!");
static_assert(offsetof(UDynamicRoomBaseData, Description) == 0x000048, "Member 'UDynamicRoomBaseData::Description' has a wrong offset!");
static_assert(offsetof(UDynamicRoomBaseData, PreviewPicture) == 0x000060, "Member 'UDynamicRoomBaseData::PreviewPicture' has a wrong offset!");

// Class GbxDynamicRoom.DynamicRoomModuleSettings
// 0x0000 (0x0028 - 0x0028)
class UDynamicRoomModuleSettings final : public UObject
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"DynamicRoomModuleSettings">();
	}
	static class UDynamicRoomModuleSettings* GetDefaultObj()
	{
		return GetDefaultObjImpl<UDynamicRoomModuleSettings>();
	}
};
static_assert(alignof(UDynamicRoomModuleSettings) == 0x000008, "Wrong alignment on UDynamicRoomModuleSettings");
static_assert(sizeof(UDynamicRoomModuleSettings) == 0x000028, "Wrong size on UDynamicRoomModuleSettings");

// Class GbxDynamicRoom.DynamicRoomLevelData
// 0x0018 (0x00A0 - 0x0088)
class UDynamicRoomLevelData : public UDynamicRoomBaseData
{
public:
	struct FSoftObjectPath                        DynamicRoomAssetName;                              // 0x0088(0x0018)(Edit, EditConst, HasGetValueTypeHash, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"DynamicRoomLevelData">();
	}
	static class UDynamicRoomLevelData* GetDefaultObj()
	{
		return GetDefaultObjImpl<UDynamicRoomLevelData>();
	}
};
static_assert(alignof(UDynamicRoomLevelData) == 0x000008, "Wrong alignment on UDynamicRoomLevelData");
static_assert(sizeof(UDynamicRoomLevelData) == 0x0000A0, "Wrong size on UDynamicRoomLevelData");
static_assert(offsetof(UDynamicRoomLevelData, DynamicRoomAssetName) == 0x000088, "Member 'UDynamicRoomLevelData::DynamicRoomAssetName' has a wrong offset!");

// Class GbxDynamicRoom.DynamicRoomActor
// 0x0000 (0x0458 - 0x0458)
class ADynamicRoomActor : public AActor
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"DynamicRoomActor">();
	}
	static class ADynamicRoomActor* GetDefaultObj()
	{
		return GetDefaultObjImpl<ADynamicRoomActor>();
	}
};
static_assert(alignof(ADynamicRoomActor) == 0x000008, "Wrong alignment on ADynamicRoomActor");
static_assert(sizeof(ADynamicRoomActor) == 0x000458, "Wrong size on ADynamicRoomActor");

// Class GbxDynamicRoom.DynamicRoomActorData
// 0x0018 (0x00A0 - 0x0088)
class UDynamicRoomActorData final : public UDynamicRoomBaseData
{
public:
	struct FSoftClassPath                         DynamicRoomAssetName;                              // 0x0088(0x0018)(Edit, HasGetValueTypeHash, NativeAccessSpecifierPublic)

public:
	void HandleDynamicRoomActorSpawned(class AActor* SpawnedActor, int32 InstanceIndex);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"DynamicRoomActorData">();
	}
	static class UDynamicRoomActorData* GetDefaultObj()
	{
		return GetDefaultObjImpl<UDynamicRoomActorData>();
	}
};
static_assert(alignof(UDynamicRoomActorData) == 0x000008, "Wrong alignment on UDynamicRoomActorData");
static_assert(sizeof(UDynamicRoomActorData) == 0x0000A0, "Wrong size on UDynamicRoomActorData");
static_assert(offsetof(UDynamicRoomActorData, DynamicRoomAssetName) == 0x000088, "Member 'UDynamicRoomActorData::DynamicRoomAssetName' has a wrong offset!");

}

