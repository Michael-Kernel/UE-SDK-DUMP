#pragma once

/*
* SDK generated by Dumper-7
*
* https://github.com/Encryqed/Dumper-7
*/

// Package: GbxVehicle

#include "Basic.hpp"

#include "GbxGameSystemCore_structs.hpp"
#include "GbxGameSystemCore_classes.hpp"
#include "GbxVehicle_structs.hpp"
#include "WwiseAudio_structs.hpp"
#include "CoreUObject_structs.hpp"
#include "CoreUObject_classes.hpp"
#include "PhysXVehicles_classes.hpp"
#include "Engine_structs.hpp"
#include "Engine_classes.hpp"
#include "GbxRuntime_classes.hpp"
#include "GbxInventory_classes.hpp"


namespace SDK
{

// Class GbxVehicle.TurretMovementComponent
// 0x00F0 (0x0300 - 0x0210)
class UTurretMovementComponent : public UPawnMovementComponent
{
public:
	struct FRotator                               TurretRelativeRotation;                            // 0x0210(0x000C)(Transient, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
	float                                         MovementThresholdTolerance;                        // 0x021C(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         DurationBeforeStop;                                // 0x0220(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_224[0x4];                                      // 0x0224(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class UWwiseEvent*                            MovementStartEvent;                                // 0x0228(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UWwiseEvent*                            MovementStopEvent;                                 // 0x0230(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UWwiseRtpc*                             MovementSpeedRTPC;                                 // 0x0238(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FWwisePlaybackInstance                 MovementAudioPlaybackInst;                         // 0x0240(0x0018)(Transient, NativeAccessSpecifierPublic)
	float                                         TimeSinceStop;                                     // 0x0258(0x0004)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_25C[0x1];                                      // 0x025C(0x0001)(Fixing Size After Last Property [ Dumper-7 ])
	bool                                          bReturnToZeroRotation;                             // 0x025D(0x0001)(BlueprintVisible, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bUsePlayersView;                                   // 0x025E(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bAimTowardsPlayersViewLocation;                    // 0x025F(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector2D                              RotationInputs;                                    // 0x0260(0x0008)(BlueprintVisible, BlueprintReadOnly, Net, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector2D                              RotationMaxSpeed;                                  // 0x0268(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector2D                              RotationDamping;                                   // 0x0270(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bEnableReturnToZeroRotationRate;                   // 0x0278(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_279[0x3];                                      // 0x0279(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	struct FVector2D                              ReturnToZeroRotationRate;                          // 0x027C(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bControlYawMovement;                               // 0x0284(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bControlPitchMovement;                             // 0x0285(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bEnableMovementCollision;                          // 0x0286(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_287[0x1];                                      // 0x0287(0x0001)(Fixing Size After Last Property [ Dumper-7 ])
	class FName                                   PivotSocket;                                       // 0x0288(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bUpdatedComponentRequired;                         // 0x0290(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bUsePitchConstraints;                              // 0x0291(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_292[0x2];                                      // 0x0292(0x0002)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         PitchMinConstraint;                                // 0x0294(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         PitchMaxConstraint;                                // 0x0298(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bUseYawConstraints;                                // 0x029C(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_29D[0x3];                                      // 0x029D(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         YawMinConstraint;                                  // 0x02A0(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         YawMaxConstraint;                                  // 0x02A4(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2A8[0x18];                                     // 0x02A8(0x0018)(Fixing Size After Last Property [ Dumper-7 ])
	struct FRotator                               RemoteTurretRelativeRotation;                      // 0x02C0(0x000C)(Net, Transient, IsPlainOldData, NoDestructor, Protected, NativeAccessSpecifierProtected)
	uint8                                         Pad_2CC[0x24];                                     // 0x02CC(0x0024)(Fixing Size After Last Property [ Dumper-7 ])
	class APawn*                                  TurretControlOwner;                                // 0x02F0(0x0008)(ZeroConstructor, Transient, DuplicateTransient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_2F8[0x8];                                      // 0x02F8(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void ServerSetRotationInputs(const struct FVector2D& InRotationInputs);
	void SetRotationInputs(float XValue, float YValue);
	void UpdateParentInitialOffset();
	void UpdateTurretControlDependency();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"TurretMovementComponent">();
	}
	static class UTurretMovementComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UTurretMovementComponent>();
	}
};
static_assert(alignof(UTurretMovementComponent) == 0x000008, "Wrong alignment on UTurretMovementComponent");
static_assert(sizeof(UTurretMovementComponent) == 0x000300, "Wrong size on UTurretMovementComponent");
static_assert(offsetof(UTurretMovementComponent, TurretRelativeRotation) == 0x000210, "Member 'UTurretMovementComponent::TurretRelativeRotation' has a wrong offset!");
static_assert(offsetof(UTurretMovementComponent, MovementThresholdTolerance) == 0x00021C, "Member 'UTurretMovementComponent::MovementThresholdTolerance' has a wrong offset!");
static_assert(offsetof(UTurretMovementComponent, DurationBeforeStop) == 0x000220, "Member 'UTurretMovementComponent::DurationBeforeStop' has a wrong offset!");
static_assert(offsetof(UTurretMovementComponent, MovementStartEvent) == 0x000228, "Member 'UTurretMovementComponent::MovementStartEvent' has a wrong offset!");
static_assert(offsetof(UTurretMovementComponent, MovementStopEvent) == 0x000230, "Member 'UTurretMovementComponent::MovementStopEvent' has a wrong offset!");
static_assert(offsetof(UTurretMovementComponent, MovementSpeedRTPC) == 0x000238, "Member 'UTurretMovementComponent::MovementSpeedRTPC' has a wrong offset!");
static_assert(offsetof(UTurretMovementComponent, MovementAudioPlaybackInst) == 0x000240, "Member 'UTurretMovementComponent::MovementAudioPlaybackInst' has a wrong offset!");
static_assert(offsetof(UTurretMovementComponent, TimeSinceStop) == 0x000258, "Member 'UTurretMovementComponent::TimeSinceStop' has a wrong offset!");
static_assert(offsetof(UTurretMovementComponent, bReturnToZeroRotation) == 0x00025D, "Member 'UTurretMovementComponent::bReturnToZeroRotation' has a wrong offset!");
static_assert(offsetof(UTurretMovementComponent, bUsePlayersView) == 0x00025E, "Member 'UTurretMovementComponent::bUsePlayersView' has a wrong offset!");
static_assert(offsetof(UTurretMovementComponent, bAimTowardsPlayersViewLocation) == 0x00025F, "Member 'UTurretMovementComponent::bAimTowardsPlayersViewLocation' has a wrong offset!");
static_assert(offsetof(UTurretMovementComponent, RotationInputs) == 0x000260, "Member 'UTurretMovementComponent::RotationInputs' has a wrong offset!");
static_assert(offsetof(UTurretMovementComponent, RotationMaxSpeed) == 0x000268, "Member 'UTurretMovementComponent::RotationMaxSpeed' has a wrong offset!");
static_assert(offsetof(UTurretMovementComponent, RotationDamping) == 0x000270, "Member 'UTurretMovementComponent::RotationDamping' has a wrong offset!");
static_assert(offsetof(UTurretMovementComponent, bEnableReturnToZeroRotationRate) == 0x000278, "Member 'UTurretMovementComponent::bEnableReturnToZeroRotationRate' has a wrong offset!");
static_assert(offsetof(UTurretMovementComponent, ReturnToZeroRotationRate) == 0x00027C, "Member 'UTurretMovementComponent::ReturnToZeroRotationRate' has a wrong offset!");
static_assert(offsetof(UTurretMovementComponent, bControlYawMovement) == 0x000284, "Member 'UTurretMovementComponent::bControlYawMovement' has a wrong offset!");
static_assert(offsetof(UTurretMovementComponent, bControlPitchMovement) == 0x000285, "Member 'UTurretMovementComponent::bControlPitchMovement' has a wrong offset!");
static_assert(offsetof(UTurretMovementComponent, bEnableMovementCollision) == 0x000286, "Member 'UTurretMovementComponent::bEnableMovementCollision' has a wrong offset!");
static_assert(offsetof(UTurretMovementComponent, PivotSocket) == 0x000288, "Member 'UTurretMovementComponent::PivotSocket' has a wrong offset!");
static_assert(offsetof(UTurretMovementComponent, bUpdatedComponentRequired) == 0x000290, "Member 'UTurretMovementComponent::bUpdatedComponentRequired' has a wrong offset!");
static_assert(offsetof(UTurretMovementComponent, bUsePitchConstraints) == 0x000291, "Member 'UTurretMovementComponent::bUsePitchConstraints' has a wrong offset!");
static_assert(offsetof(UTurretMovementComponent, PitchMinConstraint) == 0x000294, "Member 'UTurretMovementComponent::PitchMinConstraint' has a wrong offset!");
static_assert(offsetof(UTurretMovementComponent, PitchMaxConstraint) == 0x000298, "Member 'UTurretMovementComponent::PitchMaxConstraint' has a wrong offset!");
static_assert(offsetof(UTurretMovementComponent, bUseYawConstraints) == 0x00029C, "Member 'UTurretMovementComponent::bUseYawConstraints' has a wrong offset!");
static_assert(offsetof(UTurretMovementComponent, YawMinConstraint) == 0x0002A0, "Member 'UTurretMovementComponent::YawMinConstraint' has a wrong offset!");
static_assert(offsetof(UTurretMovementComponent, YawMaxConstraint) == 0x0002A4, "Member 'UTurretMovementComponent::YawMaxConstraint' has a wrong offset!");
static_assert(offsetof(UTurretMovementComponent, RemoteTurretRelativeRotation) == 0x0002C0, "Member 'UTurretMovementComponent::RemoteTurretRelativeRotation' has a wrong offset!");
static_assert(offsetof(UTurretMovementComponent, TurretControlOwner) == 0x0002F0, "Member 'UTurretMovementComponent::TurretControlOwner' has a wrong offset!");

// Class GbxVehicle.VehicleBoostComponent
// 0x00A0 (0x0218 - 0x0178)
class UVehicleBoostComponent : public UActorComponent
{
public:
	UMulticastDelegateProperty_                   OnBoostStarted;                                    // 0x0178(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	UMulticastDelegateProperty_                   OnBoostStopped;                                    // 0x0188(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	uint8                                         Pad_198[0x18];                                     // 0x0198(0x0018)(Fixing Size After Last Property [ Dumper-7 ])
	class UVehicleBoostData*                      BoostData;                                         // 0x01B0(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class AVehicle*                               Vehicle;                                           // 0x01B8(0x0008)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_1C0[0x1];                                      // 0x01C0(0x0001)(Fixing Size After Last Property [ Dumper-7 ])
	bool                                          bIsBoosting;                                       // 0x01C1(0x0001)(Net, ZeroConstructor, Transient, IsPlainOldData, RepNotify, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_1C2[0x16];                                     // 0x01C2(0x0016)(Fixing Size After Last Property [ Dumper-7 ])
	struct FGameResourcePoolReference             BoostPool;                                         // 0x01D8(0x0018)(Net, Transient, NoDestructor, ContainsInstancedReference, NativeAccessSpecifierPrivate)
	uint8                                         Pad_1F0[0x28];                                     // 0x01F0(0x0028)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void K2_BoostStarted();
	void K2_BoostStopped();
	void OnRep_IsBoosting(bool bWasBoosting);
	void PauseBoost();
	void RegisterBoostRegenerateEvent(float BoostTarget, const TDelegate<void()>& BoostValueReachedDelegate);
	void ResumeBoost();
	void StartBoost();
	void StopBoost(bool bForce);
	void VehicleBoostEvent__DelegateSignature();

	struct FVector GetBoostDirection() const;
	bool GetBoostEnabled() const;
	int32 GetCurrentBoostChargesCount() const;
	float GetCurrentBoostPoolValue() const;
	float GetMaxBoostPoolValue() const;
	float GetRelativeBoostSpeed() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"VehicleBoostComponent">();
	}
	static class UVehicleBoostComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UVehicleBoostComponent>();
	}
};
static_assert(alignof(UVehicleBoostComponent) == 0x000008, "Wrong alignment on UVehicleBoostComponent");
static_assert(sizeof(UVehicleBoostComponent) == 0x000218, "Wrong size on UVehicleBoostComponent");
static_assert(offsetof(UVehicleBoostComponent, OnBoostStarted) == 0x000178, "Member 'UVehicleBoostComponent::OnBoostStarted' has a wrong offset!");
static_assert(offsetof(UVehicleBoostComponent, OnBoostStopped) == 0x000188, "Member 'UVehicleBoostComponent::OnBoostStopped' has a wrong offset!");
static_assert(offsetof(UVehicleBoostComponent, BoostData) == 0x0001B0, "Member 'UVehicleBoostComponent::BoostData' has a wrong offset!");
static_assert(offsetof(UVehicleBoostComponent, Vehicle) == 0x0001B8, "Member 'UVehicleBoostComponent::Vehicle' has a wrong offset!");
static_assert(offsetof(UVehicleBoostComponent, bIsBoosting) == 0x0001C1, "Member 'UVehicleBoostComponent::bIsBoosting' has a wrong offset!");
static_assert(offsetof(UVehicleBoostComponent, BoostPool) == 0x0001D8, "Member 'UVehicleBoostComponent::BoostPool' has a wrong offset!");

// Class GbxVehicle.Vehicle
// 0x00B8 (0x0578 - 0x04C0)
class AVehicle : public APawn
{
public:
	uint8                                         Pad_4C0[0x10];                                     // 0x04C0(0x0010)(Fixing Size After Last Property [ Dumper-7 ])
	class USkeletalMeshComponent*                 Mesh;                                              // 0x04D0(0x0008)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, EditConst, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TScriptInterface<class IVehicleMovementInterface> VehicleMovement;                                   // 0x04D8(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, EditConst, IsPlainOldData, NoDestructor, UObjectWrapper, NativeAccessSpecifierPublic)
	uint8                                         Pad_4E8[0x18];                                     // 0x04E8(0x0018)(Fixing Size After Last Property [ Dumper-7 ])
	bool                                          bUnpushable;                                       // 0x0500(0x0001)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_501[0x7];                                      // 0x0501(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	UMulticastDelegateProperty_                   OnActorComponentAppliedFromAspectData;             // 0x0508(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	class UTargetableComponent*                   CachedTargetableComponent;                         // 0x0518(0x0008)(ExportObject, ZeroConstructor, Transient, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UDamageComponent*                       CachedDamageComponent;                             // 0x0520(0x0008)(ExportObject, ZeroConstructor, Transient, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UDamageCauserComponent*                 CachedDamageCauserComponent;                       // 0x0528(0x0008)(ExportObject, ZeroConstructor, Transient, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UTargetingComponent*                    CachedTargetingComponent;                          // 0x0530(0x0008)(ExportObject, ZeroConstructor, Transient, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UVehiclePartSelectionData*              VehiclePartSelectionData;                          // 0x0538(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, ExposeOnSpawn, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TArray<class UVehiclePartData*>               VehicleParts;                                      // 0x0540(0x0010)(Net, ZeroConstructor, Transient, RepNotify, Protected, NativeAccessSpecifierProtected)
	float                                         CharacterCollidingResistance;                      // 0x0550(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_554[0x24];                                     // 0x0554(0x0024)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void AddVehiclePart(class UVehiclePartData* CharacterPart);
	void OnRep_VehicleParts();
	void RemoveVehiclePart(class UVehiclePartData* CharacterPart);

	const TArray<class UVehiclePartData*> GetEquipedParts() const;
	int32 GetNumWheelsInAir() const;
	class UTargetableComponent* GetTargetableComponent() const;
	class UTargetingComponent* GetTargetingComponent() const;
	class UTeam* GetTeam() const;
	class UTeamComponent* GetTeamComponent() const;
	bool IsInAir() const;
	bool IsPowerSliding() const;
	void SetTeam(class UTeam* Team) const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"Vehicle">();
	}
	static class AVehicle* GetDefaultObj()
	{
		return GetDefaultObjImpl<AVehicle>();
	}
};
static_assert(alignof(AVehicle) == 0x000008, "Wrong alignment on AVehicle");
static_assert(sizeof(AVehicle) == 0x000578, "Wrong size on AVehicle");
static_assert(offsetof(AVehicle, Mesh) == 0x0004D0, "Member 'AVehicle::Mesh' has a wrong offset!");
static_assert(offsetof(AVehicle, VehicleMovement) == 0x0004D8, "Member 'AVehicle::VehicleMovement' has a wrong offset!");
static_assert(offsetof(AVehicle, bUnpushable) == 0x000500, "Member 'AVehicle::bUnpushable' has a wrong offset!");
static_assert(offsetof(AVehicle, OnActorComponentAppliedFromAspectData) == 0x000508, "Member 'AVehicle::OnActorComponentAppliedFromAspectData' has a wrong offset!");
static_assert(offsetof(AVehicle, CachedTargetableComponent) == 0x000518, "Member 'AVehicle::CachedTargetableComponent' has a wrong offset!");
static_assert(offsetof(AVehicle, CachedDamageComponent) == 0x000520, "Member 'AVehicle::CachedDamageComponent' has a wrong offset!");
static_assert(offsetof(AVehicle, CachedDamageCauserComponent) == 0x000528, "Member 'AVehicle::CachedDamageCauserComponent' has a wrong offset!");
static_assert(offsetof(AVehicle, CachedTargetingComponent) == 0x000530, "Member 'AVehicle::CachedTargetingComponent' has a wrong offset!");
static_assert(offsetof(AVehicle, VehiclePartSelectionData) == 0x000538, "Member 'AVehicle::VehiclePartSelectionData' has a wrong offset!");
static_assert(offsetof(AVehicle, VehicleParts) == 0x000540, "Member 'AVehicle::VehicleParts' has a wrong offset!");
static_assert(offsetof(AVehicle, CharacterCollidingResistance) == 0x000550, "Member 'AVehicle::CharacterCollidingResistance' has a wrong offset!");

// Class GbxVehicle.GbxVehicleWheel
// 0x0020 (0x0130 - 0x0110)
class UGbxVehicleWheel final : public UVehicleWheel
{
public:
	float                                         SuspensionForceXOffset;                            // 0x0110(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         SuspensionForceYOffset;                            // 0x0114(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                SuspensionTravelDirection;                         // 0x0118(0x000C)(Edit, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         MaxAllowedLongitudinalSlipPerRotation;             // 0x0124(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_128[0x8];                                      // 0x0128(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"GbxVehicleWheel">();
	}
	static class UGbxVehicleWheel* GetDefaultObj()
	{
		return GetDefaultObjImpl<UGbxVehicleWheel>();
	}
};
static_assert(alignof(UGbxVehicleWheel) == 0x000008, "Wrong alignment on UGbxVehicleWheel");
static_assert(sizeof(UGbxVehicleWheel) == 0x000130, "Wrong size on UGbxVehicleWheel");
static_assert(offsetof(UGbxVehicleWheel, SuspensionForceXOffset) == 0x000110, "Member 'UGbxVehicleWheel::SuspensionForceXOffset' has a wrong offset!");
static_assert(offsetof(UGbxVehicleWheel, SuspensionForceYOffset) == 0x000114, "Member 'UGbxVehicleWheel::SuspensionForceYOffset' has a wrong offset!");
static_assert(offsetof(UGbxVehicleWheel, SuspensionTravelDirection) == 0x000118, "Member 'UGbxVehicleWheel::SuspensionTravelDirection' has a wrong offset!");
static_assert(offsetof(UGbxVehicleWheel, MaxAllowedLongitudinalSlipPerRotation) == 0x000124, "Member 'UGbxVehicleWheel::MaxAllowedLongitudinalSlipPerRotation' has a wrong offset!");

// Class GbxVehicle.VehicleInventoryBalanceStateComponent
// 0x0000 (0x0348 - 0x0348)
class UVehicleInventoryBalanceStateComponent : public UInventoryBalanceStateComponent
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"VehicleInventoryBalanceStateComponent">();
	}
	static class UVehicleInventoryBalanceStateComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UVehicleInventoryBalanceStateComponent>();
	}
};
static_assert(alignof(UVehicleInventoryBalanceStateComponent) == 0x000008, "Wrong alignment on UVehicleInventoryBalanceStateComponent");
static_assert(sizeof(UVehicleInventoryBalanceStateComponent) == 0x000348, "Wrong size on UVehicleInventoryBalanceStateComponent");

// Class GbxVehicle.VehicleContactPtModifierInterface
// 0x0000 (0x0028 - 0x0028)
class IVehicleContactPtModifierInterface final : public IInterface
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"VehicleContactPtModifierInterface">();
	}
	static class IVehicleContactPtModifierInterface* GetDefaultObj()
	{
		return GetDefaultObjImpl<IVehicleContactPtModifierInterface>();
	}
};
static_assert(alignof(IVehicleContactPtModifierInterface) == 0x000008, "Wrong alignment on IVehicleContactPtModifierInterface");
static_assert(sizeof(IVehicleContactPtModifierInterface) == 0x000028, "Wrong size on IVehicleContactPtModifierInterface");

// Class GbxVehicle.VehicleBoostData
// 0x0368 (0x0398 - 0x0030)
class UVehicleBoostData : public UGbxDataAsset
{
public:
	bool                                          bApplyFullThrottleWhenBoosting;                    // 0x0030(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_31[0x3];                                       // 0x0031(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         MinBoostDuration;                                  // 0x0034(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FBoostPhysicsParams                    GroundBoostParams;                                 // 0x0038(0x0150)(Edit, NativeAccessSpecifierPublic)
	struct FBoostPhysicsParams                    AirBoostParams;                                    // 0x0188(0x0150)(Edit, NativeAccessSpecifierPublic)
	class UGameResourcePoolData*                  BoostPoolData;                                     // 0x02D8(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bContinuousStartCheck;                             // 0x02E0(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2E1[0x7];                                      // 0x02E1(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	class UGbxCondition*                          StartBoostCondition;                               // 0x02E8(0x0008)(Edit, ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, PersistentInstance, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UGbxCondition*                          StopBoostCondition;                                // 0x02F0(0x0008)(Edit, ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, PersistentInstance, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bStopConditionCanOverrideMinBoostDuration;         // 0x02F8(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bPauseWhenInAir;                                   // 0x02F9(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2FA[0x2];                                      // 0x02FA(0x0002)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         MinStartBoostSpeed;                                // 0x02FC(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         MinStartBoostAngle;                                // 0x0300(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         BoostCooldownTime;                                 // 0x0304(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bInstantBoost;                                     // 0x0308(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_309[0x3];                                      // 0x0309(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	int32                                         InstantBoostCharges;                               // 0x030C(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         InstantBoostDuration;                              // 0x0310(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bModifySteering;                                   // 0x0314(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_315[0x3];                                      // 0x0315(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	struct FRuntimeFloatCurve                     SteeringRatioCurve;                                // 0x0318(0x0078)(Edit, NativeAccessSpecifierPublic)
	float                                         SteeringRatioInterpSpeed;                          // 0x0390(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_394[0x4];                                      // 0x0394(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"VehicleBoostData">();
	}
	static class UVehicleBoostData* GetDefaultObj()
	{
		return GetDefaultObjImpl<UVehicleBoostData>();
	}
};
static_assert(alignof(UVehicleBoostData) == 0x000008, "Wrong alignment on UVehicleBoostData");
static_assert(sizeof(UVehicleBoostData) == 0x000398, "Wrong size on UVehicleBoostData");
static_assert(offsetof(UVehicleBoostData, bApplyFullThrottleWhenBoosting) == 0x000030, "Member 'UVehicleBoostData::bApplyFullThrottleWhenBoosting' has a wrong offset!");
static_assert(offsetof(UVehicleBoostData, MinBoostDuration) == 0x000034, "Member 'UVehicleBoostData::MinBoostDuration' has a wrong offset!");
static_assert(offsetof(UVehicleBoostData, GroundBoostParams) == 0x000038, "Member 'UVehicleBoostData::GroundBoostParams' has a wrong offset!");
static_assert(offsetof(UVehicleBoostData, AirBoostParams) == 0x000188, "Member 'UVehicleBoostData::AirBoostParams' has a wrong offset!");
static_assert(offsetof(UVehicleBoostData, BoostPoolData) == 0x0002D8, "Member 'UVehicleBoostData::BoostPoolData' has a wrong offset!");
static_assert(offsetof(UVehicleBoostData, bContinuousStartCheck) == 0x0002E0, "Member 'UVehicleBoostData::bContinuousStartCheck' has a wrong offset!");
static_assert(offsetof(UVehicleBoostData, StartBoostCondition) == 0x0002E8, "Member 'UVehicleBoostData::StartBoostCondition' has a wrong offset!");
static_assert(offsetof(UVehicleBoostData, StopBoostCondition) == 0x0002F0, "Member 'UVehicleBoostData::StopBoostCondition' has a wrong offset!");
static_assert(offsetof(UVehicleBoostData, bStopConditionCanOverrideMinBoostDuration) == 0x0002F8, "Member 'UVehicleBoostData::bStopConditionCanOverrideMinBoostDuration' has a wrong offset!");
static_assert(offsetof(UVehicleBoostData, bPauseWhenInAir) == 0x0002F9, "Member 'UVehicleBoostData::bPauseWhenInAir' has a wrong offset!");
static_assert(offsetof(UVehicleBoostData, MinStartBoostSpeed) == 0x0002FC, "Member 'UVehicleBoostData::MinStartBoostSpeed' has a wrong offset!");
static_assert(offsetof(UVehicleBoostData, MinStartBoostAngle) == 0x000300, "Member 'UVehicleBoostData::MinStartBoostAngle' has a wrong offset!");
static_assert(offsetof(UVehicleBoostData, BoostCooldownTime) == 0x000304, "Member 'UVehicleBoostData::BoostCooldownTime' has a wrong offset!");
static_assert(offsetof(UVehicleBoostData, bInstantBoost) == 0x000308, "Member 'UVehicleBoostData::bInstantBoost' has a wrong offset!");
static_assert(offsetof(UVehicleBoostData, InstantBoostCharges) == 0x00030C, "Member 'UVehicleBoostData::InstantBoostCharges' has a wrong offset!");
static_assert(offsetof(UVehicleBoostData, InstantBoostDuration) == 0x000310, "Member 'UVehicleBoostData::InstantBoostDuration' has a wrong offset!");
static_assert(offsetof(UVehicleBoostData, bModifySteering) == 0x000314, "Member 'UVehicleBoostData::bModifySteering' has a wrong offset!");
static_assert(offsetof(UVehicleBoostData, SteeringRatioCurve) == 0x000318, "Member 'UVehicleBoostData::SteeringRatioCurve' has a wrong offset!");
static_assert(offsetof(UVehicleBoostData, SteeringRatioInterpSpeed) == 0x000390, "Member 'UVehicleBoostData::SteeringRatioInterpSpeed' has a wrong offset!");

// Class GbxVehicle.VehiclePartData
// 0x0010 (0x0260 - 0x0250)
class UVehiclePartData : public UInventoryPartData
{
public:
	class FName                                   VehicleArchetype;                                  // 0x0250(0x0008)(ZeroConstructor, Deprecated, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bIsAShield;                                        // 0x0258(0x0001)(Edit, ZeroConstructor, DisableEditOnTemplate, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_259[0x7];                                      // 0x0259(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"VehiclePartData">();
	}
	static class UVehiclePartData* GetDefaultObj()
	{
		return GetDefaultObjImpl<UVehiclePartData>();
	}
};
static_assert(alignof(UVehiclePartData) == 0x000008, "Wrong alignment on UVehiclePartData");
static_assert(sizeof(UVehiclePartData) == 0x000260, "Wrong size on UVehiclePartData");
static_assert(offsetof(UVehiclePartData, VehicleArchetype) == 0x000250, "Member 'UVehiclePartData::VehicleArchetype' has a wrong offset!");
static_assert(offsetof(UVehiclePartData, bIsAShield) == 0x000258, "Member 'UVehiclePartData::bIsAShield' has a wrong offset!");

// Class GbxVehicle.VehicleAirControlComponent
// 0x0098 (0x0210 - 0x0178)
class UVehicleAirControlComponent final : public UActorComponent
{
public:
	float                                         YawControlForce;                                   // 0x0178(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	float                                         PitchControlForce;                                 // 0x017C(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	struct FRuntimeFloatCurve                     ForceRatio;                                        // 0x0180(0x0078)(Edit, NativeAccessSpecifierPrivate)
	uint8                                         Pad_1F8[0x8];                                      // 0x01F8(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	class AVehicle*                               Vehicle;                                           // 0x0200(0x0008)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_208[0x8];                                      // 0x0208(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"VehicleAirControlComponent">();
	}
	static class UVehicleAirControlComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UVehicleAirControlComponent>();
	}
};
static_assert(alignof(UVehicleAirControlComponent) == 0x000008, "Wrong alignment on UVehicleAirControlComponent");
static_assert(sizeof(UVehicleAirControlComponent) == 0x000210, "Wrong size on UVehicleAirControlComponent");
static_assert(offsetof(UVehicleAirControlComponent, YawControlForce) == 0x000178, "Member 'UVehicleAirControlComponent::YawControlForce' has a wrong offset!");
static_assert(offsetof(UVehicleAirControlComponent, PitchControlForce) == 0x00017C, "Member 'UVehicleAirControlComponent::PitchControlForce' has a wrong offset!");
static_assert(offsetof(UVehicleAirControlComponent, ForceRatio) == 0x000180, "Member 'UVehicleAirControlComponent::ForceRatio' has a wrong offset!");
static_assert(offsetof(UVehicleAirControlComponent, Vehicle) == 0x000200, "Member 'UVehicleAirControlComponent::Vehicle' has a wrong offset!");

// Class GbxVehicle.VehicleDigiThrustComponent
// 0x0160 (0x02D8 - 0x0178)
class UVehicleDigiThrustComponent final : public UActorComponent
{
public:
	UMulticastDelegateProperty_                   OnDigiThrustStarted;                               // 0x0178(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	UMulticastDelegateProperty_                   OnDigiThrustCollision;                             // 0x0188(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	UMulticastDelegateProperty_                   OnDigiThrustEnd;                                   // 0x0198(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	UMulticastDelegateProperty_                   OnDigiThrustEndFinished;                           // 0x01A8(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	float                                         TeleportMaxDist;                                   // 0x01B8(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         TeleportDuration;                                  // 0x01BC(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bUseTeleportDirection;                             // 0x01C0(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bReorientOnTeleport;                               // 0x01C1(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1C2[0x2];                                      // 0x01C2(0x0002)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         ReorientationRatio;                                // 0x01C4(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UGbxCondition*                          TeleportCondition;                                 // 0x01C8(0x0008)(Edit, ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, PersistentInstance, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UGameResourcePoolData*                  BoostPoolData;                                     // 0x01D0(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         NumChargesOnFullResource;                          // 0x01D8(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1DC[0x1C];                                     // 0x01DC(0x001C)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         TraceStepLength;                                   // 0x01F8(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, AdvancedDisplay, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	float                                         GroundDetectionTraceLength;                        // 0x01FC(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, AdvancedDisplay, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	float                                         GroundTraceRadius;                                 // 0x0200(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, AdvancedDisplay, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	float                                         PathPtGroundHeight;                                // 0x0204(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, AdvancedDisplay, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	float                                         ValidFloorAngle;                                   // 0x0208(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, AdvancedDisplay, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	float                                         FloorMaxAngleDiffBetweenGroundTraces;              // 0x020C(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, AdvancedDisplay, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	float                                         FloorMaxHeightDiffBetweenGroundTraces;             // 0x0210(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, AdvancedDisplay, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	float                                         RefUpBlendWeight;                                  // 0x0214(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, AdvancedDisplay, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	bool                                          bKeepLastValidGroundUpWhenInAir;                   // 0x0218(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, AdvancedDisplay, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_219[0x7];                                      // 0x0219(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	class AVehicle*                               Vehicle;                                           // 0x0220(0x0008)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	struct FGameResourcePoolReference             BoostPool;                                         // 0x0228(0x0018)(Net, Transient, NoDestructor, ContainsInstancedReference, NativeAccessSpecifierPrivate)
	bool                                          bTeleportRequested;                                // 0x0240(0x0001)(Net, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_241[0x7F];                                     // 0x0241(0x007F)(Fixing Size After Last Property [ Dumper-7 ])
	TSubclassOf<class UGbxAction>                 DigithrustInAction;                                // 0x02C0(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	TSubclassOf<class UGbxAction>                 DigithrustOutAction;                               // 0x02C8(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	float                                         DigithrustOutActionDuration;                       // 0x02D0(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_2D4[0x4];                                      // 0x02D4(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void DigiThrustEvent__DelegateSignature();
	void NetMulticast_OnDigiThrustCollision();
	void NetMulticast_OnDigiThrustEnd();
	void NetMulticast_OnDigiThrustEndFinished();
	void NetMulticast_OnDigiThrustStarted();
	void RequestTeleport();
	void SetTeleportDirection(const struct FVector& WantedDirection);

	float GetCurrentBoostPoolValue() const;
	float GetMaxBoostPoolValue() const;
	bool IsTeleporting() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"VehicleDigiThrustComponent">();
	}
	static class UVehicleDigiThrustComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UVehicleDigiThrustComponent>();
	}
};
static_assert(alignof(UVehicleDigiThrustComponent) == 0x000008, "Wrong alignment on UVehicleDigiThrustComponent");
static_assert(sizeof(UVehicleDigiThrustComponent) == 0x0002D8, "Wrong size on UVehicleDigiThrustComponent");
static_assert(offsetof(UVehicleDigiThrustComponent, OnDigiThrustStarted) == 0x000178, "Member 'UVehicleDigiThrustComponent::OnDigiThrustStarted' has a wrong offset!");
static_assert(offsetof(UVehicleDigiThrustComponent, OnDigiThrustCollision) == 0x000188, "Member 'UVehicleDigiThrustComponent::OnDigiThrustCollision' has a wrong offset!");
static_assert(offsetof(UVehicleDigiThrustComponent, OnDigiThrustEnd) == 0x000198, "Member 'UVehicleDigiThrustComponent::OnDigiThrustEnd' has a wrong offset!");
static_assert(offsetof(UVehicleDigiThrustComponent, OnDigiThrustEndFinished) == 0x0001A8, "Member 'UVehicleDigiThrustComponent::OnDigiThrustEndFinished' has a wrong offset!");
static_assert(offsetof(UVehicleDigiThrustComponent, TeleportMaxDist) == 0x0001B8, "Member 'UVehicleDigiThrustComponent::TeleportMaxDist' has a wrong offset!");
static_assert(offsetof(UVehicleDigiThrustComponent, TeleportDuration) == 0x0001BC, "Member 'UVehicleDigiThrustComponent::TeleportDuration' has a wrong offset!");
static_assert(offsetof(UVehicleDigiThrustComponent, bUseTeleportDirection) == 0x0001C0, "Member 'UVehicleDigiThrustComponent::bUseTeleportDirection' has a wrong offset!");
static_assert(offsetof(UVehicleDigiThrustComponent, bReorientOnTeleport) == 0x0001C1, "Member 'UVehicleDigiThrustComponent::bReorientOnTeleport' has a wrong offset!");
static_assert(offsetof(UVehicleDigiThrustComponent, ReorientationRatio) == 0x0001C4, "Member 'UVehicleDigiThrustComponent::ReorientationRatio' has a wrong offset!");
static_assert(offsetof(UVehicleDigiThrustComponent, TeleportCondition) == 0x0001C8, "Member 'UVehicleDigiThrustComponent::TeleportCondition' has a wrong offset!");
static_assert(offsetof(UVehicleDigiThrustComponent, BoostPoolData) == 0x0001D0, "Member 'UVehicleDigiThrustComponent::BoostPoolData' has a wrong offset!");
static_assert(offsetof(UVehicleDigiThrustComponent, NumChargesOnFullResource) == 0x0001D8, "Member 'UVehicleDigiThrustComponent::NumChargesOnFullResource' has a wrong offset!");
static_assert(offsetof(UVehicleDigiThrustComponent, TraceStepLength) == 0x0001F8, "Member 'UVehicleDigiThrustComponent::TraceStepLength' has a wrong offset!");
static_assert(offsetof(UVehicleDigiThrustComponent, GroundDetectionTraceLength) == 0x0001FC, "Member 'UVehicleDigiThrustComponent::GroundDetectionTraceLength' has a wrong offset!");
static_assert(offsetof(UVehicleDigiThrustComponent, GroundTraceRadius) == 0x000200, "Member 'UVehicleDigiThrustComponent::GroundTraceRadius' has a wrong offset!");
static_assert(offsetof(UVehicleDigiThrustComponent, PathPtGroundHeight) == 0x000204, "Member 'UVehicleDigiThrustComponent::PathPtGroundHeight' has a wrong offset!");
static_assert(offsetof(UVehicleDigiThrustComponent, ValidFloorAngle) == 0x000208, "Member 'UVehicleDigiThrustComponent::ValidFloorAngle' has a wrong offset!");
static_assert(offsetof(UVehicleDigiThrustComponent, FloorMaxAngleDiffBetweenGroundTraces) == 0x00020C, "Member 'UVehicleDigiThrustComponent::FloorMaxAngleDiffBetweenGroundTraces' has a wrong offset!");
static_assert(offsetof(UVehicleDigiThrustComponent, FloorMaxHeightDiffBetweenGroundTraces) == 0x000210, "Member 'UVehicleDigiThrustComponent::FloorMaxHeightDiffBetweenGroundTraces' has a wrong offset!");
static_assert(offsetof(UVehicleDigiThrustComponent, RefUpBlendWeight) == 0x000214, "Member 'UVehicleDigiThrustComponent::RefUpBlendWeight' has a wrong offset!");
static_assert(offsetof(UVehicleDigiThrustComponent, bKeepLastValidGroundUpWhenInAir) == 0x000218, "Member 'UVehicleDigiThrustComponent::bKeepLastValidGroundUpWhenInAir' has a wrong offset!");
static_assert(offsetof(UVehicleDigiThrustComponent, Vehicle) == 0x000220, "Member 'UVehicleDigiThrustComponent::Vehicle' has a wrong offset!");
static_assert(offsetof(UVehicleDigiThrustComponent, BoostPool) == 0x000228, "Member 'UVehicleDigiThrustComponent::BoostPool' has a wrong offset!");
static_assert(offsetof(UVehicleDigiThrustComponent, bTeleportRequested) == 0x000240, "Member 'UVehicleDigiThrustComponent::bTeleportRequested' has a wrong offset!");
static_assert(offsetof(UVehicleDigiThrustComponent, DigithrustInAction) == 0x0002C0, "Member 'UVehicleDigiThrustComponent::DigithrustInAction' has a wrong offset!");
static_assert(offsetof(UVehicleDigiThrustComponent, DigithrustOutAction) == 0x0002C8, "Member 'UVehicleDigiThrustComponent::DigithrustOutAction' has a wrong offset!");
static_assert(offsetof(UVehicleDigiThrustComponent, DigithrustOutActionDuration) == 0x0002D0, "Member 'UVehicleDigiThrustComponent::DigithrustOutActionDuration' has a wrong offset!");

// Class GbxVehicle.VehicleFlightComponent
// 0x0000 (0x0230 - 0x0230)
class UVehicleFlightComponent final : public UFloatingPawnMovement
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"VehicleFlightComponent">();
	}
	static class UVehicleFlightComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UVehicleFlightComponent>();
	}
};
static_assert(alignof(UVehicleFlightComponent) == 0x000008, "Wrong alignment on UVehicleFlightComponent");
static_assert(sizeof(UVehicleFlightComponent) == 0x000230, "Wrong size on UVehicleFlightComponent");

// Class GbxVehicle.VehicleHitchAttachPtComponent
// 0x0078 (0x0790 - 0x0718)
class UVehicleHitchAttachPtComponent final : public USphereComponent
{
public:
	class UPrimitiveComponent*                    UpdatedPrimitive;                                  // 0x0718(0x0008)(ExportObject, ZeroConstructor, Transient, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         AttachTransitionLength;                            // 0x0720(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         AttachTransitionTolerance;                         // 0x0724(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_728[0x18];                                     // 0x0728(0x0018)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         BrakeTorque;                                       // 0x0740(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_744[0x4];                                      // 0x0744(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	UMulticastDelegateProperty_                   OnStartAttachTransition;                           // 0x0748(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPrivate)
	UMulticastDelegateProperty_                   OnAttached;                                        // 0x0758(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPrivate)
	UMulticastDelegateProperty_                   OnDetached;                                        // 0x0768(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPrivate)
	class UWheeledVehicleMovementComponentNW*     CachedAttachedVehicleMovementComp;                 // 0x0778(0x0008)(ExportObject, ZeroConstructor, Transient, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UWheeledVehicleMovementComponentNW*     CachedMovementComponent;                           // 0x0780(0x0008)(ExportObject, ZeroConstructor, Transient, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_788[0x8];                                      // 0x0788(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void HitchAttachAction__DelegateSignature(class AVehicle* FromVehicle);

	bool IsAttached() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"VehicleHitchAttachPtComponent">();
	}
	static class UVehicleHitchAttachPtComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UVehicleHitchAttachPtComponent>();
	}
};
static_assert(alignof(UVehicleHitchAttachPtComponent) == 0x000008, "Wrong alignment on UVehicleHitchAttachPtComponent");
static_assert(sizeof(UVehicleHitchAttachPtComponent) == 0x000790, "Wrong size on UVehicleHitchAttachPtComponent");
static_assert(offsetof(UVehicleHitchAttachPtComponent, UpdatedPrimitive) == 0x000718, "Member 'UVehicleHitchAttachPtComponent::UpdatedPrimitive' has a wrong offset!");
static_assert(offsetof(UVehicleHitchAttachPtComponent, AttachTransitionLength) == 0x000720, "Member 'UVehicleHitchAttachPtComponent::AttachTransitionLength' has a wrong offset!");
static_assert(offsetof(UVehicleHitchAttachPtComponent, AttachTransitionTolerance) == 0x000724, "Member 'UVehicleHitchAttachPtComponent::AttachTransitionTolerance' has a wrong offset!");
static_assert(offsetof(UVehicleHitchAttachPtComponent, BrakeTorque) == 0x000740, "Member 'UVehicleHitchAttachPtComponent::BrakeTorque' has a wrong offset!");
static_assert(offsetof(UVehicleHitchAttachPtComponent, OnStartAttachTransition) == 0x000748, "Member 'UVehicleHitchAttachPtComponent::OnStartAttachTransition' has a wrong offset!");
static_assert(offsetof(UVehicleHitchAttachPtComponent, OnAttached) == 0x000758, "Member 'UVehicleHitchAttachPtComponent::OnAttached' has a wrong offset!");
static_assert(offsetof(UVehicleHitchAttachPtComponent, OnDetached) == 0x000768, "Member 'UVehicleHitchAttachPtComponent::OnDetached' has a wrong offset!");
static_assert(offsetof(UVehicleHitchAttachPtComponent, CachedAttachedVehicleMovementComp) == 0x000778, "Member 'UVehicleHitchAttachPtComponent::CachedAttachedVehicleMovementComp' has a wrong offset!");
static_assert(offsetof(UVehicleHitchAttachPtComponent, CachedMovementComponent) == 0x000780, "Member 'UVehicleHitchAttachPtComponent::CachedMovementComponent' has a wrong offset!");

// Class GbxVehicle.VehicleHitchComponent
// 0x0070 (0x0540 - 0x04D0)
class UVehicleHitchComponent final : public UPhysicsConstraintComponent
{
public:
	bool                                          bCheckAutoAttach;                                  // 0x04D0(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_4D1[0x7];                                      // 0x04D1(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	UMulticastDelegateProperty_                   OnStartAttachTransition;                           // 0x04D8(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPrivate)
	UMulticastDelegateProperty_                   OnAttached;                                        // 0x04E8(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPrivate)
	UMulticastDelegateProperty_                   OnDetached;                                        // 0x04F8(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPrivate)
	float                                         HitchAttachCheckRadius;                            // 0x0508(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	float                                         YawLimit;                                          // 0x050C(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	float                                         PitchLimit;                                        // 0x0510(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	float                                         HitchConstraintStiffness;                          // 0x0514(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	float                                         HitchConstraintDamping;                            // 0x0518(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_51C[0x4];                                      // 0x051C(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class UVehicleHitchAttachPtComponent*         AttachedPoint;                                     // 0x0520(0x0008)(ExportObject, ZeroConstructor, Transient, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class AVehicle*                               OwningVehicle;                                     // 0x0528(0x0008)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UWheeledVehicleMovementComponent*       OwningVehicleMovementComp;                         // 0x0530(0x0008)(ExportObject, ZeroConstructor, Transient, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_538[0x8];                                      // 0x0538(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void AttachToHitch(class UVehicleHitchAttachPtComponent* AttachPtToAttach);
	void DetachFromHitch();
	void HitchAttachAction__DelegateSignature(class AVehicle* FromVehicle);
	void TeleportTrailerAndAttachToHitch(class AActor* TrailerToAttach);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"VehicleHitchComponent">();
	}
	static class UVehicleHitchComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UVehicleHitchComponent>();
	}
};
static_assert(alignof(UVehicleHitchComponent) == 0x000008, "Wrong alignment on UVehicleHitchComponent");
static_assert(sizeof(UVehicleHitchComponent) == 0x000540, "Wrong size on UVehicleHitchComponent");
static_assert(offsetof(UVehicleHitchComponent, bCheckAutoAttach) == 0x0004D0, "Member 'UVehicleHitchComponent::bCheckAutoAttach' has a wrong offset!");
static_assert(offsetof(UVehicleHitchComponent, OnStartAttachTransition) == 0x0004D8, "Member 'UVehicleHitchComponent::OnStartAttachTransition' has a wrong offset!");
static_assert(offsetof(UVehicleHitchComponent, OnAttached) == 0x0004E8, "Member 'UVehicleHitchComponent::OnAttached' has a wrong offset!");
static_assert(offsetof(UVehicleHitchComponent, OnDetached) == 0x0004F8, "Member 'UVehicleHitchComponent::OnDetached' has a wrong offset!");
static_assert(offsetof(UVehicleHitchComponent, HitchAttachCheckRadius) == 0x000508, "Member 'UVehicleHitchComponent::HitchAttachCheckRadius' has a wrong offset!");
static_assert(offsetof(UVehicleHitchComponent, YawLimit) == 0x00050C, "Member 'UVehicleHitchComponent::YawLimit' has a wrong offset!");
static_assert(offsetof(UVehicleHitchComponent, PitchLimit) == 0x000510, "Member 'UVehicleHitchComponent::PitchLimit' has a wrong offset!");
static_assert(offsetof(UVehicleHitchComponent, HitchConstraintStiffness) == 0x000514, "Member 'UVehicleHitchComponent::HitchConstraintStiffness' has a wrong offset!");
static_assert(offsetof(UVehicleHitchComponent, HitchConstraintDamping) == 0x000518, "Member 'UVehicleHitchComponent::HitchConstraintDamping' has a wrong offset!");
static_assert(offsetof(UVehicleHitchComponent, AttachedPoint) == 0x000520, "Member 'UVehicleHitchComponent::AttachedPoint' has a wrong offset!");
static_assert(offsetof(UVehicleHitchComponent, OwningVehicle) == 0x000528, "Member 'UVehicleHitchComponent::OwningVehicle' has a wrong offset!");
static_assert(offsetof(UVehicleHitchComponent, OwningVehicleMovementComp) == 0x000530, "Member 'UVehicleHitchComponent::OwningVehicleMovementComp' has a wrong offset!");

// Class GbxVehicle.VehicleHoverComponent
// 0x0110 (0x0288 - 0x0178)
class UVehicleHoverComponent final : public UActorComponent
{
public:
	UMulticastDelegateProperty_                   OnHoverEnabled;                                    // 0x0178(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	UMulticastDelegateProperty_                   OnHoverDisabled;                                   // 0x0188(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	float                                         RawStrafeInput;                                    // 0x0198(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         RawForwardInput;                                   // 0x019C(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FReplicatedHoverComponentState         ReplicatedState;                                   // 0x01A0(0x0018)(Net, Transient, NoDestructor, NativeAccessSpecifierPrivate)
	uint8                                         Pad_1B8[0x1C];                                     // 0x01B8(0x001C)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         ForceRefVel;                                       // 0x01D4(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	struct FRuntimeFloatCurve                     ForceCurve;                                        // 0x01D8(0x0078)(Edit, NativeAccessSpecifierPrivate)
	float                                         DampingForce;                                      // 0x0250(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	float                                         BrakingDampingForce;                               // 0x0254(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UTireConfig*                            TireConfigWhenStrafing;                            // 0x0258(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	float                                         CustomGravityModifier;                             // 0x0260(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	bool                                          bFaceControlRotation;                              // 0x0264(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_265[0x3];                                      // 0x0265(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         TimeToFaceControlRotation;                         // 0x0268(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_26C[0x4];                                      // 0x026C(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class AVehicle*                               Vehicle;                                           // 0x0270(0x0008)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UWheeledVehicleMovementComponentNW*     MovementComponentNW;                               // 0x0278(0x0008)(ExportObject, ZeroConstructor, Transient, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_280[0x8];                                      // 0x0280(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void EnableHover(bool bEnable);
	void ServerUpdateState(bool InbIsEnabled, float InStrafeInput, float InForwardInput, const struct FRotator& InTargetRotation);
	void VehicleHoverEvent__DelegateSignature();

	bool IsHoverEnabled() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"VehicleHoverComponent">();
	}
	static class UVehicleHoverComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UVehicleHoverComponent>();
	}
};
static_assert(alignof(UVehicleHoverComponent) == 0x000008, "Wrong alignment on UVehicleHoverComponent");
static_assert(sizeof(UVehicleHoverComponent) == 0x000288, "Wrong size on UVehicleHoverComponent");
static_assert(offsetof(UVehicleHoverComponent, OnHoverEnabled) == 0x000178, "Member 'UVehicleHoverComponent::OnHoverEnabled' has a wrong offset!");
static_assert(offsetof(UVehicleHoverComponent, OnHoverDisabled) == 0x000188, "Member 'UVehicleHoverComponent::OnHoverDisabled' has a wrong offset!");
static_assert(offsetof(UVehicleHoverComponent, RawStrafeInput) == 0x000198, "Member 'UVehicleHoverComponent::RawStrafeInput' has a wrong offset!");
static_assert(offsetof(UVehicleHoverComponent, RawForwardInput) == 0x00019C, "Member 'UVehicleHoverComponent::RawForwardInput' has a wrong offset!");
static_assert(offsetof(UVehicleHoverComponent, ReplicatedState) == 0x0001A0, "Member 'UVehicleHoverComponent::ReplicatedState' has a wrong offset!");
static_assert(offsetof(UVehicleHoverComponent, ForceRefVel) == 0x0001D4, "Member 'UVehicleHoverComponent::ForceRefVel' has a wrong offset!");
static_assert(offsetof(UVehicleHoverComponent, ForceCurve) == 0x0001D8, "Member 'UVehicleHoverComponent::ForceCurve' has a wrong offset!");
static_assert(offsetof(UVehicleHoverComponent, DampingForce) == 0x000250, "Member 'UVehicleHoverComponent::DampingForce' has a wrong offset!");
static_assert(offsetof(UVehicleHoverComponent, BrakingDampingForce) == 0x000254, "Member 'UVehicleHoverComponent::BrakingDampingForce' has a wrong offset!");
static_assert(offsetof(UVehicleHoverComponent, TireConfigWhenStrafing) == 0x000258, "Member 'UVehicleHoverComponent::TireConfigWhenStrafing' has a wrong offset!");
static_assert(offsetof(UVehicleHoverComponent, CustomGravityModifier) == 0x000260, "Member 'UVehicleHoverComponent::CustomGravityModifier' has a wrong offset!");
static_assert(offsetof(UVehicleHoverComponent, bFaceControlRotation) == 0x000264, "Member 'UVehicleHoverComponent::bFaceControlRotation' has a wrong offset!");
static_assert(offsetof(UVehicleHoverComponent, TimeToFaceControlRotation) == 0x000268, "Member 'UVehicleHoverComponent::TimeToFaceControlRotation' has a wrong offset!");
static_assert(offsetof(UVehicleHoverComponent, Vehicle) == 0x000270, "Member 'UVehicleHoverComponent::Vehicle' has a wrong offset!");
static_assert(offsetof(UVehicleHoverComponent, MovementComponentNW) == 0x000278, "Member 'UVehicleHoverComponent::MovementComponentNW' has a wrong offset!");

// Class GbxVehicle.VehicleMovementInterface
// 0x0000 (0x0028 - 0x0028)
class IVehicleMovementInterface final : public IInterface
{
public:
	struct FVector2D GetDirectionBasedThrottleAndSteer(const struct FVector2D& StickInput);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"VehicleMovementInterface">();
	}
	static class IVehicleMovementInterface* GetDefaultObj()
	{
		return GetDefaultObjImpl<IVehicleMovementInterface>();
	}
};
static_assert(alignof(IVehicleMovementInterface) == 0x000008, "Wrong alignment on IVehicleMovementInterface");
static_assert(sizeof(IVehicleMovementInterface) == 0x000028, "Wrong size on IVehicleMovementInterface");

// Class GbxVehicle.VehiclePartActor
// 0x0020 (0x0478 - 0x0458)
class AVehiclePartActor final : public AActor
{
public:
	bool                                          bWeldSimulatedBodies;                              // 0x0458(0x0001)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	bool                                          bWeldedBodiesShouldModifyPhysicalProperties;       // 0x0459(0x0001)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	bool                                          bForwardDamageToParent;                            // 0x045A(0x0001)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_45B[0x5];                                      // 0x045B(0x0005)(Fixing Size After Last Property [ Dumper-7 ])
	class AVehicle*                               OwningVehicle;                                     // 0x0460(0x0008)(BlueprintVisible, BlueprintReadOnly, Net, ZeroConstructor, IsPlainOldData, RepNotify, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class FName                                   ParentSocket;                                      // 0x0468(0x0008)(Net, ZeroConstructor, IsPlainOldData, RepNotify, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_470[0x8];                                      // 0x0470(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void OnRep_OwningVehicle();
	void OnRep_ParentSocket();
	void ReceiveParentVehicleBeginPlay();
	void WeldActorToVehicle(class AActor* SpawnedPart);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"VehiclePartActor">();
	}
	static class AVehiclePartActor* GetDefaultObj()
	{
		return GetDefaultObjImpl<AVehiclePartActor>();
	}
};
static_assert(alignof(AVehiclePartActor) == 0x000008, "Wrong alignment on AVehiclePartActor");
static_assert(sizeof(AVehiclePartActor) == 0x000478, "Wrong size on AVehiclePartActor");
static_assert(offsetof(AVehiclePartActor, bWeldSimulatedBodies) == 0x000458, "Member 'AVehiclePartActor::bWeldSimulatedBodies' has a wrong offset!");
static_assert(offsetof(AVehiclePartActor, bWeldedBodiesShouldModifyPhysicalProperties) == 0x000459, "Member 'AVehiclePartActor::bWeldedBodiesShouldModifyPhysicalProperties' has a wrong offset!");
static_assert(offsetof(AVehiclePartActor, bForwardDamageToParent) == 0x00045A, "Member 'AVehiclePartActor::bForwardDamageToParent' has a wrong offset!");
static_assert(offsetof(AVehiclePartActor, OwningVehicle) == 0x000460, "Member 'AVehiclePartActor::OwningVehicle' has a wrong offset!");
static_assert(offsetof(AVehiclePartActor, ParentSocket) == 0x000468, "Member 'AVehiclePartActor::ParentSocket' has a wrong offset!");

// Class GbxVehicle.VehiclePartSelectionData
// 0x0000 (0x0098 - 0x0098)
class UVehiclePartSelectionData final : public UActorPartSelectionData
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"VehiclePartSelectionData">();
	}
	static class UVehiclePartSelectionData* GetDefaultObj()
	{
		return GetDefaultObjImpl<UVehiclePartSelectionData>();
	}
};
static_assert(alignof(UVehiclePartSelectionData) == 0x000008, "Wrong alignment on UVehiclePartSelectionData");
static_assert(sizeof(UVehiclePartSelectionData) == 0x000098, "Wrong size on UVehiclePartSelectionData");

// Class GbxVehicle.VehiclePowerSlideComponent
// 0x01F0 (0x0368 - 0x0178)
class UVehiclePowerSlideComponent final : public UActorComponent
{
public:
	bool                                          bApplyHandbrake;                                   // 0x0178(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EInAirBehavior                                InAirBehavior;                                     // 0x0179(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_17A[0x2];                                      // 0x017A(0x0002)(Fixing Size After Last Property [ Dumper-7 ])
	int32                                         MaxNumWheelsInAir;                                 // 0x017C(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	UMulticastDelegateProperty_                   OnStartPowerSlide;                                 // 0x0180(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	UMulticastDelegateProperty_                   OnEndPowerSlide;                                   // 0x0190(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	UMulticastDelegateProperty_                   OnStartPowerSlideBoost;                            // 0x01A0(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	UMulticastDelegateProperty_                   OnEndPowerSlideBoost;                              // 0x01B0(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	bool                                          bIsPowerSliding;                                   // 0x01C0(0x0001)(Net, ZeroConstructor, Transient, IsPlainOldData, RepNotify, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_1C1[0xB7];                                     // 0x01C1(0x00B7)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         AngleToConsiderDrift;                              // 0x0278(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	float                                         MinDriftVelThreshold;                              // 0x027C(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	float                                         TimeInDriftDecayRate;                              // 0x0280(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	float                                         MinDriftDurationForBoost;                          // 0x0284(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	float                                         MaxDriftDurationForBoost;                          // 0x0288(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_28C[0x4];                                      // 0x028C(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	struct FRuntimeFloatCurve                     BoostCurve;                                        // 0x0290(0x0078)(Edit, NativeAccessSpecifierPrivate)
	float                                         MaxBoostForce;                                     // 0x0308(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	float                                         PostDriftBoostDurationMin;                         // 0x030C(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	float                                         PostDriftBoostDurationMax;                         // 0x0310(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	float                                         MinVelForPostDriftBoost;                           // 0x0314(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	struct FRelativeDirectionData                 BoostDirection;                                    // 0x0318(0x0050)(Edit, NoDestructor, NativeAccessSpecifierPrivate)

public:
	void CancelPowerSlide();
	bool GetPowerSlideEnabled();
	bool IsPowerSlidePaused();
	void OnRep_IsPowerSliding(bool bWasPowerSliding);
	void PausePowerSlide(class FName Reason);
	void ResumePowerSlide(class FName Reason);
	void SetPowerSlideEnabled(bool bEnable);

	float GetCurrentBoostRatio() const;
	bool IsInPowerSlideBoost() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"VehiclePowerSlideComponent">();
	}
	static class UVehiclePowerSlideComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UVehiclePowerSlideComponent>();
	}
};
static_assert(alignof(UVehiclePowerSlideComponent) == 0x000008, "Wrong alignment on UVehiclePowerSlideComponent");
static_assert(sizeof(UVehiclePowerSlideComponent) == 0x000368, "Wrong size on UVehiclePowerSlideComponent");
static_assert(offsetof(UVehiclePowerSlideComponent, bApplyHandbrake) == 0x000178, "Member 'UVehiclePowerSlideComponent::bApplyHandbrake' has a wrong offset!");
static_assert(offsetof(UVehiclePowerSlideComponent, InAirBehavior) == 0x000179, "Member 'UVehiclePowerSlideComponent::InAirBehavior' has a wrong offset!");
static_assert(offsetof(UVehiclePowerSlideComponent, MaxNumWheelsInAir) == 0x00017C, "Member 'UVehiclePowerSlideComponent::MaxNumWheelsInAir' has a wrong offset!");
static_assert(offsetof(UVehiclePowerSlideComponent, OnStartPowerSlide) == 0x000180, "Member 'UVehiclePowerSlideComponent::OnStartPowerSlide' has a wrong offset!");
static_assert(offsetof(UVehiclePowerSlideComponent, OnEndPowerSlide) == 0x000190, "Member 'UVehiclePowerSlideComponent::OnEndPowerSlide' has a wrong offset!");
static_assert(offsetof(UVehiclePowerSlideComponent, OnStartPowerSlideBoost) == 0x0001A0, "Member 'UVehiclePowerSlideComponent::OnStartPowerSlideBoost' has a wrong offset!");
static_assert(offsetof(UVehiclePowerSlideComponent, OnEndPowerSlideBoost) == 0x0001B0, "Member 'UVehiclePowerSlideComponent::OnEndPowerSlideBoost' has a wrong offset!");
static_assert(offsetof(UVehiclePowerSlideComponent, bIsPowerSliding) == 0x0001C0, "Member 'UVehiclePowerSlideComponent::bIsPowerSliding' has a wrong offset!");
static_assert(offsetof(UVehiclePowerSlideComponent, AngleToConsiderDrift) == 0x000278, "Member 'UVehiclePowerSlideComponent::AngleToConsiderDrift' has a wrong offset!");
static_assert(offsetof(UVehiclePowerSlideComponent, MinDriftVelThreshold) == 0x00027C, "Member 'UVehiclePowerSlideComponent::MinDriftVelThreshold' has a wrong offset!");
static_assert(offsetof(UVehiclePowerSlideComponent, TimeInDriftDecayRate) == 0x000280, "Member 'UVehiclePowerSlideComponent::TimeInDriftDecayRate' has a wrong offset!");
static_assert(offsetof(UVehiclePowerSlideComponent, MinDriftDurationForBoost) == 0x000284, "Member 'UVehiclePowerSlideComponent::MinDriftDurationForBoost' has a wrong offset!");
static_assert(offsetof(UVehiclePowerSlideComponent, MaxDriftDurationForBoost) == 0x000288, "Member 'UVehiclePowerSlideComponent::MaxDriftDurationForBoost' has a wrong offset!");
static_assert(offsetof(UVehiclePowerSlideComponent, BoostCurve) == 0x000290, "Member 'UVehiclePowerSlideComponent::BoostCurve' has a wrong offset!");
static_assert(offsetof(UVehiclePowerSlideComponent, MaxBoostForce) == 0x000308, "Member 'UVehiclePowerSlideComponent::MaxBoostForce' has a wrong offset!");
static_assert(offsetof(UVehiclePowerSlideComponent, PostDriftBoostDurationMin) == 0x00030C, "Member 'UVehiclePowerSlideComponent::PostDriftBoostDurationMin' has a wrong offset!");
static_assert(offsetof(UVehiclePowerSlideComponent, PostDriftBoostDurationMax) == 0x000310, "Member 'UVehiclePowerSlideComponent::PostDriftBoostDurationMax' has a wrong offset!");
static_assert(offsetof(UVehiclePowerSlideComponent, MinVelForPostDriftBoost) == 0x000314, "Member 'UVehiclePowerSlideComponent::MinVelForPostDriftBoost' has a wrong offset!");
static_assert(offsetof(UVehiclePowerSlideComponent, BoostDirection) == 0x000318, "Member 'UVehiclePowerSlideComponent::BoostDirection' has a wrong offset!");

// Class GbxVehicle.VehicleCollisionResponseModificationContext
// 0x0010 (0x0038 - 0x0028)
class UVehicleCollisionResponseModificationContext final : public UObject
{
public:
	class AVehicle*                               Collider;                                          // 0x0028(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class AVehicle*                               Collidee;                                          // 0x0030(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"VehicleCollisionResponseModificationContext">();
	}
	static class UVehicleCollisionResponseModificationContext* GetDefaultObj()
	{
		return GetDefaultObjImpl<UVehicleCollisionResponseModificationContext>();
	}
};
static_assert(alignof(UVehicleCollisionResponseModificationContext) == 0x000008, "Wrong alignment on UVehicleCollisionResponseModificationContext");
static_assert(sizeof(UVehicleCollisionResponseModificationContext) == 0x000038, "Wrong size on UVehicleCollisionResponseModificationContext");
static_assert(offsetof(UVehicleCollisionResponseModificationContext, Collider) == 0x000028, "Member 'UVehicleCollisionResponseModificationContext::Collider' has a wrong offset!");
static_assert(offsetof(UVehicleCollisionResponseModificationContext, Collidee) == 0x000030, "Member 'UVehicleCollisionResponseModificationContext::Collidee' has a wrong offset!");

// Class GbxVehicle.WheeledVehicleMovementComponentNW
// 0x0788 (0x0D40 - 0x05B8)
class UWheeledVehicleMovementComponentNW final : public UWheeledVehicleMovementComponent4W
{
public:
	uint8                                         Pad_5B8[0x8];                                      // 0x05B8(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<int8>                                  DrivenWheels;                                      // 0x05C0(0x0010)(Edit, ZeroConstructor, NativeAccessSpecifierPublic)
	EVehicleDriveType                             VehicleDriveType;                                  // 0x05D0(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_5D1[0x3];                                      // 0x05D1(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         ForwardMarginOfError;                              // 0x05D4(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         ContiguousMovementDirectionThreshold;              // 0x05D8(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         ContiguousMovementDirectionSpeedThreshold;         // 0x05DC(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bContiguousMovementAppliesToReverse;               // 0x05E0(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bOversteerFixupEnabled;                            // 0x05E1(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_5E2[0x6];                                      // 0x05E2(0x0006)(Fixing Size After Last Property [ Dumper-7 ])
	struct FRuntimeFloatCurve                     OversteerFixupCurve;                               // 0x05E8(0x0078)(Edit, NativeAccessSpecifierPublic)
	uint8                                         Pad_660[0x4];                                      // 0x0660(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	bool                                          bAerialRotationalDampingEnabled;                   // 0x0664(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_665[0x3];                                      // 0x0665(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         RisingAerialRotationDampingFactor;                 // 0x0668(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         AerialRotationalDamping;                           // 0x066C(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         AerialRotationalDeviationAngle;                    // 0x0670(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bAerialAutoStabilizationEnabled;                   // 0x0674(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_675[0x3];                                      // 0x0675(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         RisingAerialAutoStabilizationFactor;               // 0x0678(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         AerialAutoStabilization;                           // 0x067C(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bUseAutoUnflip;                                    // 0x0680(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_681[0x3];                                      // 0x0681(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	struct FVector2D                              AutoUnflipAngleRange;                              // 0x0684(0x0008)(Edit, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         AutoUnflipEaseInZone;                              // 0x068C(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FRuntimeFloatCurve                     AutoUnflipCurve;                                   // 0x0690(0x0078)(Edit, NativeAccessSpecifierPublic)
	float                                         AutoUnflipForce;                                   // 0x0708(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_70C[0x4];                                      // 0x070C(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	struct FRuntimeFloatCurve                     TankTreadInputDifferenceCurve;                     // 0x0710(0x0078)(Edit, NativeAccessSpecifierPublic)
	float                                         MaxTreadThrustOvershootValue;                      // 0x0788(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_78C[0x4];                                      // 0x078C(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	struct FRuntimeFloatCurve                     BrakeWhenTurningRatioCurve;                        // 0x0790(0x0078)(Edit, NativeAccessSpecifierPublic)
	float                                         OppositeThreadSpeedWhenTurningInPlace;             // 0x0808(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         CustomGravityModifier;                             // 0x080C(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         GroundedCustomGravityModifier;                     // 0x0810(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bEnableSteeringCurve;                              // 0x0814(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_815[0xB];                                      // 0x0815(0x000B)(Fixing Size After Last Property [ Dumper-7 ])
	UMulticastDelegateProperty_                   OnBecameAirborn;                                   // 0x0820(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	UMulticastDelegateProperty_                   OnLanded;                                          // 0x0830(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	uint8                                         Pad_840[0x4];                                      // 0x0840(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	bool                                          bLateralToLongitudinalVelocityShiftEnabled;        // 0x0844(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_845[0x3];                                      // 0x0845(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	struct FRuntimeFloatCurve                     LateralToLongitudinalVelocityShiftCurve;           // 0x0848(0x0078)(Edit, NativeAccessSpecifierPublic)
	struct FRuntimeFloatCurve                     TireForcesRatioToSlopeAngleCurve;                  // 0x08C0(0x0078)(Edit, NativeAccessSpecifierPublic)
	float                                         BalanceAssistMaxSpeed;                             // 0x0938(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bUseSagittalBalanceCurve;                          // 0x093C(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_93D[0x3];                                      // 0x093D(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	struct FRuntimeFloatCurve                     SagittalBalanceCurve;                              // 0x0940(0x0078)(Edit, NativeAccessSpecifierPublic)
	struct FRuntimeFloatCurve                     SagittalBalanceSpeedCurve;                         // 0x09B8(0x0078)(Edit, NativeAccessSpecifierPublic)
	float                                         SagitalBlendSpeed;                                 // 0x0A30(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         EBrakingSagitalBlendSpeed;                         // 0x0A34(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         EBrakingSagittalAngleRefSpeedKmH;                  // 0x0A38(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         EBrakingSagitalLeanAngle;                          // 0x0A3C(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bUseCoronalBalanceCurve;                           // 0x0A40(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_A41[0x7];                                      // 0x0A41(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	struct FRuntimeFloatCurve                     CoronalBalanceCurve;                               // 0x0A48(0x0078)(Edit, NativeAccessSpecifierPublic)
	bool                                          bUseBrakeAssist;                                   // 0x0AC0(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bUseHandBrakeAssist;                               // 0x0AC1(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bApplyBrakeAssistOnLatForces;                      // 0x0AC2(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_AC3[0x1];                                      // 0x0AC3(0x0001)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         BrakeAssistForceScale;                             // 0x0AC4(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FRuntimeFloatCurve                     BrakeAssistCurve;                                  // 0x0AC8(0x0078)(Edit, NativeAccessSpecifierPublic)
	bool                                          bCanHandbrake;                                     // 0x0B40(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bUseUTurnAssist;                                   // 0x0B41(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bActivateUTurnAssistOnHandbrake;                   // 0x0B42(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_B43[0x5];                                      // 0x0B43(0x0005)(Fixing Size After Last Property [ Dumper-7 ])
	class UGbxCondition*                          ActivateUTurnAssistCondition;                      // 0x0B48(0x0008)(Edit, ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, PersistentInstance, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bApplyUTurnAssistInAir;                            // 0x0B50(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_B51[0x3];                                      // 0x0B51(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         UTurnAssistForce;                                  // 0x0B54(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         UTurnAssistForceInterpSpeed;                       // 0x0B58(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         UTurnAssistForceReturnToZeroInterpSpeed;           // 0x0B5C(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         UTurnAssistRefSpeed;                               // 0x0B60(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         UTurnAssistMaxAngularVelInfluence;                 // 0x0B64(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FRuntimeFloatCurve                     UTurnAssistCurve;                                  // 0x0B68(0x0078)(Edit, NativeAccessSpecifierPublic)
	struct FRuntimeFloatCurve                     LiquidBodyWheelDepthToForceCurve;                  // 0x0BE0(0x0078)(Edit, NativeAccessSpecifierPublic)
	float                                         LiquidBodyDampingCoefficient;                      // 0x0C58(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_C5C[0x4];                                      // 0x0C5C(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	struct FAttributeInitializationData           CollisionResponseFormula;                          // 0x0C60(0x0038)(Edit, NoDestructor, NativeAccessSpecifierPublic)
	float                                         AngleToUpsideDown;                                 // 0x0C98(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_C9C[0x4];                                      // 0x0C9C(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class UPhysicalMaterial*                      DefaultPhysicalMaterial;                           // 0x0CA0(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UPhysicalMaterial*                      UpsideDownPhysicalMaterial;                        // 0x0CA8(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bDontMoveWhenCollided;                             // 0x0CB0(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_CB1[0x7];                                      // 0x0CB1(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	class UCurveFloat*                            CryoPenaltyCurve;                                  // 0x0CB8(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TArray<struct FAntiRollBarData>               AntiRollBars;                                      // 0x0CC0(0x0010)(Edit, ZeroConstructor, NativeAccessSpecifierPrivate)
	uint8                                         Pad_CD0[0x28];                                     // 0x0CD0(0x0028)(Fixing Size After Last Property [ Dumper-7 ])
	class UVehicleCollisionResponseModificationContext* CollisionResponseContext;                          // 0x0CF8(0x0008)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_D00[0x40];                                     // 0x0D00(0x0040)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void ApplyAngularVelocityInfluence(float DeltaTime, float MaxInfluence, float Pitch, float Roll, float Yaw);
	bool GetAerialRotationalDampingEnabled();
	struct FVector2D GetCameraRelativeThrottleAndSteer(const struct FVector2D& StickInput, float* WantedDirAngle, EVehicleCameraRelativeDrivingMode Mode, class UCurveFloat* AngleToSteeringCurve);
	bool GetCoronalBalancingEnabled();
	struct FVector2D GetDirectionBasedThrottleAndSteer(const struct FVector2D& StickInput);
	bool GetLateralToLongitudinalVelocityShiftEnabled();
	bool GetOversteerFixupEnabled();
	bool GetSagittalBalancingEnabled();
	void ResetCustomGravityModifer();
	void SetAerialRotationalDampingEnabled(bool bEnable);
	void SetCoronalBalancingEnabled(bool bEnable);
	void SetCustomGravityModifier(float NewModifier);
	void SetLateralToLongitudinalVelocityShiftEnabled(bool bEnable);
	void SetNoDriveBrakeTorque(float BrakeTorque, int32 WheelIndex);
	void SetNoDriveDriveTorque(float DriveTorque, int32 WheelIndex);
	void SetNoDriveSteerAngle(float SteerAngle, int32 WheelIndex);
	void SetOversteerFixupEnabled(bool bEnable);
	void SetSagittalBalancingEnabled(bool bEnable);
	void SetSteerAngle(float SteerAngle, int32 WheelIndex);
	void SetToRestState();

	float GetCustomGravityModifier() const;
	int32 GetNumWheelsInAir() const;
	bool IsInAir() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"WheeledVehicleMovementComponentNW">();
	}
	static class UWheeledVehicleMovementComponentNW* GetDefaultObj()
	{
		return GetDefaultObjImpl<UWheeledVehicleMovementComponentNW>();
	}
};
static_assert(alignof(UWheeledVehicleMovementComponentNW) == 0x000008, "Wrong alignment on UWheeledVehicleMovementComponentNW");
static_assert(sizeof(UWheeledVehicleMovementComponentNW) == 0x000D40, "Wrong size on UWheeledVehicleMovementComponentNW");
static_assert(offsetof(UWheeledVehicleMovementComponentNW, DrivenWheels) == 0x0005C0, "Member 'UWheeledVehicleMovementComponentNW::DrivenWheels' has a wrong offset!");
static_assert(offsetof(UWheeledVehicleMovementComponentNW, VehicleDriveType) == 0x0005D0, "Member 'UWheeledVehicleMovementComponentNW::VehicleDriveType' has a wrong offset!");
static_assert(offsetof(UWheeledVehicleMovementComponentNW, ForwardMarginOfError) == 0x0005D4, "Member 'UWheeledVehicleMovementComponentNW::ForwardMarginOfError' has a wrong offset!");
static_assert(offsetof(UWheeledVehicleMovementComponentNW, ContiguousMovementDirectionThreshold) == 0x0005D8, "Member 'UWheeledVehicleMovementComponentNW::ContiguousMovementDirectionThreshold' has a wrong offset!");
static_assert(offsetof(UWheeledVehicleMovementComponentNW, ContiguousMovementDirectionSpeedThreshold) == 0x0005DC, "Member 'UWheeledVehicleMovementComponentNW::ContiguousMovementDirectionSpeedThreshold' has a wrong offset!");
static_assert(offsetof(UWheeledVehicleMovementComponentNW, bContiguousMovementAppliesToReverse) == 0x0005E0, "Member 'UWheeledVehicleMovementComponentNW::bContiguousMovementAppliesToReverse' has a wrong offset!");
static_assert(offsetof(UWheeledVehicleMovementComponentNW, bOversteerFixupEnabled) == 0x0005E1, "Member 'UWheeledVehicleMovementComponentNW::bOversteerFixupEnabled' has a wrong offset!");
static_assert(offsetof(UWheeledVehicleMovementComponentNW, OversteerFixupCurve) == 0x0005E8, "Member 'UWheeledVehicleMovementComponentNW::OversteerFixupCurve' has a wrong offset!");
static_assert(offsetof(UWheeledVehicleMovementComponentNW, bAerialRotationalDampingEnabled) == 0x000664, "Member 'UWheeledVehicleMovementComponentNW::bAerialRotationalDampingEnabled' has a wrong offset!");
static_assert(offsetof(UWheeledVehicleMovementComponentNW, RisingAerialRotationDampingFactor) == 0x000668, "Member 'UWheeledVehicleMovementComponentNW::RisingAerialRotationDampingFactor' has a wrong offset!");
static_assert(offsetof(UWheeledVehicleMovementComponentNW, AerialRotationalDamping) == 0x00066C, "Member 'UWheeledVehicleMovementComponentNW::AerialRotationalDamping' has a wrong offset!");
static_assert(offsetof(UWheeledVehicleMovementComponentNW, AerialRotationalDeviationAngle) == 0x000670, "Member 'UWheeledVehicleMovementComponentNW::AerialRotationalDeviationAngle' has a wrong offset!");
static_assert(offsetof(UWheeledVehicleMovementComponentNW, bAerialAutoStabilizationEnabled) == 0x000674, "Member 'UWheeledVehicleMovementComponentNW::bAerialAutoStabilizationEnabled' has a wrong offset!");
static_assert(offsetof(UWheeledVehicleMovementComponentNW, RisingAerialAutoStabilizationFactor) == 0x000678, "Member 'UWheeledVehicleMovementComponentNW::RisingAerialAutoStabilizationFactor' has a wrong offset!");
static_assert(offsetof(UWheeledVehicleMovementComponentNW, AerialAutoStabilization) == 0x00067C, "Member 'UWheeledVehicleMovementComponentNW::AerialAutoStabilization' has a wrong offset!");
static_assert(offsetof(UWheeledVehicleMovementComponentNW, bUseAutoUnflip) == 0x000680, "Member 'UWheeledVehicleMovementComponentNW::bUseAutoUnflip' has a wrong offset!");
static_assert(offsetof(UWheeledVehicleMovementComponentNW, AutoUnflipAngleRange) == 0x000684, "Member 'UWheeledVehicleMovementComponentNW::AutoUnflipAngleRange' has a wrong offset!");
static_assert(offsetof(UWheeledVehicleMovementComponentNW, AutoUnflipEaseInZone) == 0x00068C, "Member 'UWheeledVehicleMovementComponentNW::AutoUnflipEaseInZone' has a wrong offset!");
static_assert(offsetof(UWheeledVehicleMovementComponentNW, AutoUnflipCurve) == 0x000690, "Member 'UWheeledVehicleMovementComponentNW::AutoUnflipCurve' has a wrong offset!");
static_assert(offsetof(UWheeledVehicleMovementComponentNW, AutoUnflipForce) == 0x000708, "Member 'UWheeledVehicleMovementComponentNW::AutoUnflipForce' has a wrong offset!");
static_assert(offsetof(UWheeledVehicleMovementComponentNW, TankTreadInputDifferenceCurve) == 0x000710, "Member 'UWheeledVehicleMovementComponentNW::TankTreadInputDifferenceCurve' has a wrong offset!");
static_assert(offsetof(UWheeledVehicleMovementComponentNW, MaxTreadThrustOvershootValue) == 0x000788, "Member 'UWheeledVehicleMovementComponentNW::MaxTreadThrustOvershootValue' has a wrong offset!");
static_assert(offsetof(UWheeledVehicleMovementComponentNW, BrakeWhenTurningRatioCurve) == 0x000790, "Member 'UWheeledVehicleMovementComponentNW::BrakeWhenTurningRatioCurve' has a wrong offset!");
static_assert(offsetof(UWheeledVehicleMovementComponentNW, OppositeThreadSpeedWhenTurningInPlace) == 0x000808, "Member 'UWheeledVehicleMovementComponentNW::OppositeThreadSpeedWhenTurningInPlace' has a wrong offset!");
static_assert(offsetof(UWheeledVehicleMovementComponentNW, CustomGravityModifier) == 0x00080C, "Member 'UWheeledVehicleMovementComponentNW::CustomGravityModifier' has a wrong offset!");
static_assert(offsetof(UWheeledVehicleMovementComponentNW, GroundedCustomGravityModifier) == 0x000810, "Member 'UWheeledVehicleMovementComponentNW::GroundedCustomGravityModifier' has a wrong offset!");
static_assert(offsetof(UWheeledVehicleMovementComponentNW, bEnableSteeringCurve) == 0x000814, "Member 'UWheeledVehicleMovementComponentNW::bEnableSteeringCurve' has a wrong offset!");
static_assert(offsetof(UWheeledVehicleMovementComponentNW, OnBecameAirborn) == 0x000820, "Member 'UWheeledVehicleMovementComponentNW::OnBecameAirborn' has a wrong offset!");
static_assert(offsetof(UWheeledVehicleMovementComponentNW, OnLanded) == 0x000830, "Member 'UWheeledVehicleMovementComponentNW::OnLanded' has a wrong offset!");
static_assert(offsetof(UWheeledVehicleMovementComponentNW, bLateralToLongitudinalVelocityShiftEnabled) == 0x000844, "Member 'UWheeledVehicleMovementComponentNW::bLateralToLongitudinalVelocityShiftEnabled' has a wrong offset!");
static_assert(offsetof(UWheeledVehicleMovementComponentNW, LateralToLongitudinalVelocityShiftCurve) == 0x000848, "Member 'UWheeledVehicleMovementComponentNW::LateralToLongitudinalVelocityShiftCurve' has a wrong offset!");
static_assert(offsetof(UWheeledVehicleMovementComponentNW, TireForcesRatioToSlopeAngleCurve) == 0x0008C0, "Member 'UWheeledVehicleMovementComponentNW::TireForcesRatioToSlopeAngleCurve' has a wrong offset!");
static_assert(offsetof(UWheeledVehicleMovementComponentNW, BalanceAssistMaxSpeed) == 0x000938, "Member 'UWheeledVehicleMovementComponentNW::BalanceAssistMaxSpeed' has a wrong offset!");
static_assert(offsetof(UWheeledVehicleMovementComponentNW, bUseSagittalBalanceCurve) == 0x00093C, "Member 'UWheeledVehicleMovementComponentNW::bUseSagittalBalanceCurve' has a wrong offset!");
static_assert(offsetof(UWheeledVehicleMovementComponentNW, SagittalBalanceCurve) == 0x000940, "Member 'UWheeledVehicleMovementComponentNW::SagittalBalanceCurve' has a wrong offset!");
static_assert(offsetof(UWheeledVehicleMovementComponentNW, SagittalBalanceSpeedCurve) == 0x0009B8, "Member 'UWheeledVehicleMovementComponentNW::SagittalBalanceSpeedCurve' has a wrong offset!");
static_assert(offsetof(UWheeledVehicleMovementComponentNW, SagitalBlendSpeed) == 0x000A30, "Member 'UWheeledVehicleMovementComponentNW::SagitalBlendSpeed' has a wrong offset!");
static_assert(offsetof(UWheeledVehicleMovementComponentNW, EBrakingSagitalBlendSpeed) == 0x000A34, "Member 'UWheeledVehicleMovementComponentNW::EBrakingSagitalBlendSpeed' has a wrong offset!");
static_assert(offsetof(UWheeledVehicleMovementComponentNW, EBrakingSagittalAngleRefSpeedKmH) == 0x000A38, "Member 'UWheeledVehicleMovementComponentNW::EBrakingSagittalAngleRefSpeedKmH' has a wrong offset!");
static_assert(offsetof(UWheeledVehicleMovementComponentNW, EBrakingSagitalLeanAngle) == 0x000A3C, "Member 'UWheeledVehicleMovementComponentNW::EBrakingSagitalLeanAngle' has a wrong offset!");
static_assert(offsetof(UWheeledVehicleMovementComponentNW, bUseCoronalBalanceCurve) == 0x000A40, "Member 'UWheeledVehicleMovementComponentNW::bUseCoronalBalanceCurve' has a wrong offset!");
static_assert(offsetof(UWheeledVehicleMovementComponentNW, CoronalBalanceCurve) == 0x000A48, "Member 'UWheeledVehicleMovementComponentNW::CoronalBalanceCurve' has a wrong offset!");
static_assert(offsetof(UWheeledVehicleMovementComponentNW, bUseBrakeAssist) == 0x000AC0, "Member 'UWheeledVehicleMovementComponentNW::bUseBrakeAssist' has a wrong offset!");
static_assert(offsetof(UWheeledVehicleMovementComponentNW, bUseHandBrakeAssist) == 0x000AC1, "Member 'UWheeledVehicleMovementComponentNW::bUseHandBrakeAssist' has a wrong offset!");
static_assert(offsetof(UWheeledVehicleMovementComponentNW, bApplyBrakeAssistOnLatForces) == 0x000AC2, "Member 'UWheeledVehicleMovementComponentNW::bApplyBrakeAssistOnLatForces' has a wrong offset!");
static_assert(offsetof(UWheeledVehicleMovementComponentNW, BrakeAssistForceScale) == 0x000AC4, "Member 'UWheeledVehicleMovementComponentNW::BrakeAssistForceScale' has a wrong offset!");
static_assert(offsetof(UWheeledVehicleMovementComponentNW, BrakeAssistCurve) == 0x000AC8, "Member 'UWheeledVehicleMovementComponentNW::BrakeAssistCurve' has a wrong offset!");
static_assert(offsetof(UWheeledVehicleMovementComponentNW, bCanHandbrake) == 0x000B40, "Member 'UWheeledVehicleMovementComponentNW::bCanHandbrake' has a wrong offset!");
static_assert(offsetof(UWheeledVehicleMovementComponentNW, bUseUTurnAssist) == 0x000B41, "Member 'UWheeledVehicleMovementComponentNW::bUseUTurnAssist' has a wrong offset!");
static_assert(offsetof(UWheeledVehicleMovementComponentNW, bActivateUTurnAssistOnHandbrake) == 0x000B42, "Member 'UWheeledVehicleMovementComponentNW::bActivateUTurnAssistOnHandbrake' has a wrong offset!");
static_assert(offsetof(UWheeledVehicleMovementComponentNW, ActivateUTurnAssistCondition) == 0x000B48, "Member 'UWheeledVehicleMovementComponentNW::ActivateUTurnAssistCondition' has a wrong offset!");
static_assert(offsetof(UWheeledVehicleMovementComponentNW, bApplyUTurnAssistInAir) == 0x000B50, "Member 'UWheeledVehicleMovementComponentNW::bApplyUTurnAssistInAir' has a wrong offset!");
static_assert(offsetof(UWheeledVehicleMovementComponentNW, UTurnAssistForce) == 0x000B54, "Member 'UWheeledVehicleMovementComponentNW::UTurnAssistForce' has a wrong offset!");
static_assert(offsetof(UWheeledVehicleMovementComponentNW, UTurnAssistForceInterpSpeed) == 0x000B58, "Member 'UWheeledVehicleMovementComponentNW::UTurnAssistForceInterpSpeed' has a wrong offset!");
static_assert(offsetof(UWheeledVehicleMovementComponentNW, UTurnAssistForceReturnToZeroInterpSpeed) == 0x000B5C, "Member 'UWheeledVehicleMovementComponentNW::UTurnAssistForceReturnToZeroInterpSpeed' has a wrong offset!");
static_assert(offsetof(UWheeledVehicleMovementComponentNW, UTurnAssistRefSpeed) == 0x000B60, "Member 'UWheeledVehicleMovementComponentNW::UTurnAssistRefSpeed' has a wrong offset!");
static_assert(offsetof(UWheeledVehicleMovementComponentNW, UTurnAssistMaxAngularVelInfluence) == 0x000B64, "Member 'UWheeledVehicleMovementComponentNW::UTurnAssistMaxAngularVelInfluence' has a wrong offset!");
static_assert(offsetof(UWheeledVehicleMovementComponentNW, UTurnAssistCurve) == 0x000B68, "Member 'UWheeledVehicleMovementComponentNW::UTurnAssistCurve' has a wrong offset!");
static_assert(offsetof(UWheeledVehicleMovementComponentNW, LiquidBodyWheelDepthToForceCurve) == 0x000BE0, "Member 'UWheeledVehicleMovementComponentNW::LiquidBodyWheelDepthToForceCurve' has a wrong offset!");
static_assert(offsetof(UWheeledVehicleMovementComponentNW, LiquidBodyDampingCoefficient) == 0x000C58, "Member 'UWheeledVehicleMovementComponentNW::LiquidBodyDampingCoefficient' has a wrong offset!");
static_assert(offsetof(UWheeledVehicleMovementComponentNW, CollisionResponseFormula) == 0x000C60, "Member 'UWheeledVehicleMovementComponentNW::CollisionResponseFormula' has a wrong offset!");
static_assert(offsetof(UWheeledVehicleMovementComponentNW, AngleToUpsideDown) == 0x000C98, "Member 'UWheeledVehicleMovementComponentNW::AngleToUpsideDown' has a wrong offset!");
static_assert(offsetof(UWheeledVehicleMovementComponentNW, DefaultPhysicalMaterial) == 0x000CA0, "Member 'UWheeledVehicleMovementComponentNW::DefaultPhysicalMaterial' has a wrong offset!");
static_assert(offsetof(UWheeledVehicleMovementComponentNW, UpsideDownPhysicalMaterial) == 0x000CA8, "Member 'UWheeledVehicleMovementComponentNW::UpsideDownPhysicalMaterial' has a wrong offset!");
static_assert(offsetof(UWheeledVehicleMovementComponentNW, bDontMoveWhenCollided) == 0x000CB0, "Member 'UWheeledVehicleMovementComponentNW::bDontMoveWhenCollided' has a wrong offset!");
static_assert(offsetof(UWheeledVehicleMovementComponentNW, CryoPenaltyCurve) == 0x000CB8, "Member 'UWheeledVehicleMovementComponentNW::CryoPenaltyCurve' has a wrong offset!");
static_assert(offsetof(UWheeledVehicleMovementComponentNW, AntiRollBars) == 0x000CC0, "Member 'UWheeledVehicleMovementComponentNW::AntiRollBars' has a wrong offset!");
static_assert(offsetof(UWheeledVehicleMovementComponentNW, CollisionResponseContext) == 0x000CF8, "Member 'UWheeledVehicleMovementComponentNW::CollisionResponseContext' has a wrong offset!");

}

