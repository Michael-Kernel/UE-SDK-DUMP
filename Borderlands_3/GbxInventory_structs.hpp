#pragma once

/*
* SDK generated by Dumper-7
*
* https://github.com/Encryqed/Dumper-7
*/

// Package: GbxInventory

#include "Basic.hpp"

#include "CoreUObject_structs.hpp"
#include "GbxGameSystemCore_structs.hpp"
#include "Engine_structs.hpp"


namespace SDK
{

// Enum GbxInventory.EPickupLootAttachmentMode
// NumValues: 0x0006
enum class EPickupLootAttachmentMode : uint8
{
	Origin                                   = 0,
	Center                                   = 1,
	CenterAndScale                           = 2,
	CenterAndScaleUpOrDown                   = 3,
	ScaleDown                                = 4,
	EPickupLootAttachmentMode_MAX            = 5,
};

// Enum GbxInventory.EPlayerDroppability
// NumValues: 0x0004
enum class EPlayerDroppability : uint8
{
	EPD_CanDropAndSell                       = 0,
	EPD_NoDrop                               = 1,
	EPD_NoDropOrSell                         = 2,
	EPD_MAX                                  = 3,
};

// Enum GbxInventory.EPickupActionType
// NumValues: 0x0004
enum class EPickupActionType : uint8
{
	OnUseOrTouch                             = 0,
	OnUseOnly                                = 1,
	OnTouchOnly                              = 2,
	EPickupActionType_MAX                    = 3,
};

// Enum GbxInventory.EInventoryAspectUsagePriority
// NumValues: 0x0007
enum class EInventoryAspectUsagePriority : uint8
{
	Default                                  = 0,
	Low                                      = 1,
	Medium                                   = 2,
	High                                     = 3,
	Ultra                                    = 4,
	Legendary                                = 5,
	EInventoryAspectUsagePriority_MAX        = 6,
};

// Enum GbxInventory.EInventoryConditionalDamageApplicationTarget
// NumValues: 0x0004
enum class EInventoryConditionalDamageApplicationTarget : uint8
{
	Inventory                                = 0,
	InstigatorDamageCaused                   = 1,
	InstigatorDamageReceived                 = 2,
	EInventoryConditionalDamageApplicationTarget_MAX = 3,
};

// Enum GbxInventory.EAddInventoryItemFlags
// NumValues: 0x0005
enum class EAddInventoryItemFlags : uint8
{
	AutoEquip                                = 0,
	AddedByPickup                            = 1,
	AddedBySave                              = 2,
	MissionReward                            = 3,
	EAddInventoryItemFlags_MAX               = 4,
};

// Enum GbxInventory.EDropLifeSpanType
// NumValues: 0x0006
enum class EDropLifeSpanType : uint8
{
	DROP_VeryShortLived                      = 0,
	DROP_ShortLived                          = 1,
	DROP_LongLived                           = 2,
	DROP_LiveForever                         = 3,
	DROP_LiveAsLongAsLevel                   = 4,
	DROP_MAX                                 = 5,
};

// Enum GbxInventory.EInventorySerialNumberState
// NumValues: 0x0006
enum class EInventorySerialNumberState : uint8
{
	Empty                                    = 0,
	Writing                                  = 1,
	Full                                     = 2,
	Reading                                  = 3,
	Encrypted                                = 4,
	EInventorySerialNumberState_MAX          = 5,
};

// Enum GbxInventory.EPickupFlyToAlignmentType
// NumValues: 0x0003
enum class EPickupFlyToAlignmentType : uint32
{
	Spin                                     = 0,
	TargetFacing                             = 1,
	EPickupFlyToAlignmentType_MAX            = 2,
};

// ScriptStruct GbxInventory.PoolSocketAttachmentInfo
// 0x0048 (0x0048 - 0x0000)
struct FPoolSocketAttachmentInfo final
{
public:
	class UItemPoolData*                          ItemPool;                                          // 0x0000(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class FName                                   AttachmentPointName;                               // 0x0008(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FAttributeInitializationData           Weight;                                            // 0x0010(0x0038)(Edit, NoDestructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(FPoolSocketAttachmentInfo) == 0x000008, "Wrong alignment on FPoolSocketAttachmentInfo");
static_assert(sizeof(FPoolSocketAttachmentInfo) == 0x000048, "Wrong size on FPoolSocketAttachmentInfo");
static_assert(offsetof(FPoolSocketAttachmentInfo, ItemPool) == 0x000000, "Member 'FPoolSocketAttachmentInfo::ItemPool' has a wrong offset!");
static_assert(offsetof(FPoolSocketAttachmentInfo, AttachmentPointName) == 0x000008, "Member 'FPoolSocketAttachmentInfo::AttachmentPointName' has a wrong offset!");
static_assert(offsetof(FPoolSocketAttachmentInfo, Weight) == 0x000010, "Member 'FPoolSocketAttachmentInfo::Weight' has a wrong offset!");

// ScriptStruct GbxInventory.LootAttachmentInfo
// 0x0058 (0x0058 - 0x0000)
struct FLootAttachmentInfo final
{
public:
	class UItemPoolData*                          ItemPool;                                          // 0x0000(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class FName                                   AttachmentPointName;                               // 0x0008(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FAttributeInitializationData           Probability;                                       // 0x0010(0x0038)(Edit, NoDestructor, NativeAccessSpecifierPublic)
	TArray<struct FPoolSocketAttachmentInfo>      OverrideAttachmentList;                            // 0x0048(0x0010)(Edit, ZeroConstructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(FLootAttachmentInfo) == 0x000008, "Wrong alignment on FLootAttachmentInfo");
static_assert(sizeof(FLootAttachmentInfo) == 0x000058, "Wrong size on FLootAttachmentInfo");
static_assert(offsetof(FLootAttachmentInfo, ItemPool) == 0x000000, "Member 'FLootAttachmentInfo::ItemPool' has a wrong offset!");
static_assert(offsetof(FLootAttachmentInfo, AttachmentPointName) == 0x000008, "Member 'FLootAttachmentInfo::AttachmentPointName' has a wrong offset!");
static_assert(offsetof(FLootAttachmentInfo, Probability) == 0x000010, "Member 'FLootAttachmentInfo::Probability' has a wrong offset!");
static_assert(offsetof(FLootAttachmentInfo, OverrideAttachmentList) == 0x000048, "Member 'FLootAttachmentInfo::OverrideAttachmentList' has a wrong offset!");

// ScriptStruct GbxInventory.InventoryReplicationData
// 0x0010 (0x0010 - 0x0000)
struct alignas(0x08) FInventoryReplicationData final
{
public:
	uint8                                         Pad_0[0x10];                                       // 0x0000(0x0010)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FInventoryReplicationData) == 0x000008, "Wrong alignment on FInventoryReplicationData");
static_assert(sizeof(FInventoryReplicationData) == 0x000010, "Wrong size on FInventoryReplicationData");

// ScriptStruct GbxInventory.InventoryListEntryHandle
// 0x0004 (0x0004 - 0x0000)
struct FInventoryListEntryHandle final
{
public:
	int32                                         Handle;                                            // 0x0000(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
};
static_assert(alignof(FInventoryListEntryHandle) == 0x000004, "Wrong alignment on FInventoryListEntryHandle");
static_assert(sizeof(FInventoryListEntryHandle) == 0x000004, "Wrong size on FInventoryListEntryHandle");
static_assert(offsetof(FInventoryListEntryHandle, Handle) == 0x000000, "Member 'FInventoryListEntryHandle::Handle' has a wrong offset!");

// ScriptStruct GbxInventory.MaterialParameterData
// 0x0008 (0x0008 - 0x0000)
struct alignas(0x08) FMaterialParameterData
{
public:
	class FName                                   Name;                                              // 0x0000(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FMaterialParameterData) == 0x000008, "Wrong alignment on FMaterialParameterData");
static_assert(sizeof(FMaterialParameterData) == 0x000008, "Wrong size on FMaterialParameterData");
static_assert(offsetof(FMaterialParameterData, Name) == 0x000000, "Member 'FMaterialParameterData::Name' has a wrong offset!");

// ScriptStruct GbxInventory.MaterialTextureAssetParameterData
// 0x0028 (0x0030 - 0x0008)
struct FMaterialTextureAssetParameterData final : public FMaterialParameterData
{
public:
	TSoftObjectPtr<class UTexture>                Texture;                                           // 0x0008(0x0028)(Edit, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FMaterialTextureAssetParameterData) == 0x000008, "Wrong alignment on FMaterialTextureAssetParameterData");
static_assert(sizeof(FMaterialTextureAssetParameterData) == 0x000030, "Wrong size on FMaterialTextureAssetParameterData");
static_assert(offsetof(FMaterialTextureAssetParameterData, Texture) == 0x000008, "Member 'FMaterialTextureAssetParameterData::Texture' has a wrong offset!");

// ScriptStruct GbxInventory.InventoryBalanceStateInitializationData
// 0x0068 (0x0068 - 0x0000)
struct FInventoryBalanceStateInitializationData final
{
public:
	int32                                         GameStage;                                         // 0x0000(0x0004)(Edit, BlueprintVisible, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_4[0x4];                                        // 0x0004(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class UInventoryData*                         InventoryData;                                     // 0x0008(0x0008)(Edit, BlueprintVisible, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UInventoryBalanceData*                  InventoryBalanceData;                              // 0x0010(0x0008)(Edit, BlueprintVisible, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UManufacturerData*                      ManufacturerData;                                  // 0x0018(0x0008)(Edit, BlueprintVisible, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TArray<class UInventoryPartData*>             PartList;                                          // 0x0020(0x0010)(Edit, BlueprintVisible, ZeroConstructor, EditConst, NativeAccessSpecifierPublic)
	TArray<class UInventoryGenericPartData*>      GenericPartList;                                   // 0x0030(0x0010)(Edit, BlueprintVisible, ZeroConstructor, EditConst, NativeAccessSpecifierPublic)
	TArray<uint8>                                 AdditionalData;                                    // 0x0040(0x0010)(ZeroConstructor, NativeAccessSpecifierPublic)
	TArray<class UInventoryCustomizationPartData*> CustomizationPartList;                             // 0x0050(0x0010)(ZeroConstructor, NativeAccessSpecifierPublic)
	uint8                                         ReRollCount;                                       // 0x0060(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bDroppedFromAI;                                    // 0x0061(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_62[0x6];                                       // 0x0062(0x0006)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FInventoryBalanceStateInitializationData) == 0x000008, "Wrong alignment on FInventoryBalanceStateInitializationData");
static_assert(sizeof(FInventoryBalanceStateInitializationData) == 0x000068, "Wrong size on FInventoryBalanceStateInitializationData");
static_assert(offsetof(FInventoryBalanceStateInitializationData, GameStage) == 0x000000, "Member 'FInventoryBalanceStateInitializationData::GameStage' has a wrong offset!");
static_assert(offsetof(FInventoryBalanceStateInitializationData, InventoryData) == 0x000008, "Member 'FInventoryBalanceStateInitializationData::InventoryData' has a wrong offset!");
static_assert(offsetof(FInventoryBalanceStateInitializationData, InventoryBalanceData) == 0x000010, "Member 'FInventoryBalanceStateInitializationData::InventoryBalanceData' has a wrong offset!");
static_assert(offsetof(FInventoryBalanceStateInitializationData, ManufacturerData) == 0x000018, "Member 'FInventoryBalanceStateInitializationData::ManufacturerData' has a wrong offset!");
static_assert(offsetof(FInventoryBalanceStateInitializationData, PartList) == 0x000020, "Member 'FInventoryBalanceStateInitializationData::PartList' has a wrong offset!");
static_assert(offsetof(FInventoryBalanceStateInitializationData, GenericPartList) == 0x000030, "Member 'FInventoryBalanceStateInitializationData::GenericPartList' has a wrong offset!");
static_assert(offsetof(FInventoryBalanceStateInitializationData, AdditionalData) == 0x000040, "Member 'FInventoryBalanceStateInitializationData::AdditionalData' has a wrong offset!");
static_assert(offsetof(FInventoryBalanceStateInitializationData, CustomizationPartList) == 0x000050, "Member 'FInventoryBalanceStateInitializationData::CustomizationPartList' has a wrong offset!");
static_assert(offsetof(FInventoryBalanceStateInitializationData, ReRollCount) == 0x000060, "Member 'FInventoryBalanceStateInitializationData::ReRollCount' has a wrong offset!");
static_assert(offsetof(FInventoryBalanceStateInitializationData, bDroppedFromAI) == 0x000061, "Member 'FInventoryBalanceStateInitializationData::bDroppedFromAI' has a wrong offset!");

// ScriptStruct GbxInventory.ItemPoolInfo
// 0x0088 (0x0088 - 0x0000)
struct FItemPoolInfo final
{
public:
	class UItemPoolData*                          ItemPool;                                          // 0x0000(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	struct FAttributeInitializationData           PoolProbability;                                   // 0x0008(0x0038)(Edit, BlueprintVisible, NoDestructor, Protected, NativeAccessSpecifierProtected)
	struct FAttributeInitializationData           NumberOfTimesToSelectFromThisPool;                 // 0x0040(0x0038)(Edit, BlueprintVisible, NoDestructor, Protected, NativeAccessSpecifierProtected)
	TArray<class UItemPoolPartSelectionOverrideData*> PartSelectionOverrides;                            // 0x0078(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Protected, NativeAccessSpecifierProtected)
};
static_assert(alignof(FItemPoolInfo) == 0x000008, "Wrong alignment on FItemPoolInfo");
static_assert(sizeof(FItemPoolInfo) == 0x000088, "Wrong size on FItemPoolInfo");
static_assert(offsetof(FItemPoolInfo, ItemPool) == 0x000000, "Member 'FItemPoolInfo::ItemPool' has a wrong offset!");
static_assert(offsetof(FItemPoolInfo, PoolProbability) == 0x000008, "Member 'FItemPoolInfo::PoolProbability' has a wrong offset!");
static_assert(offsetof(FItemPoolInfo, NumberOfTimesToSelectFromThisPool) == 0x000040, "Member 'FItemPoolInfo::NumberOfTimesToSelectFromThisPool' has a wrong offset!");
static_assert(offsetof(FItemPoolInfo, PartSelectionOverrides) == 0x000078, "Member 'FItemPoolInfo::PartSelectionOverrides' has a wrong offset!");

// ScriptStruct GbxInventory.SelectedInventoryInfo
// 0x0060 (0x0060 - 0x0000)
struct FSelectedInventoryInfo final
{
public:
	class UInventoryData*                         InventoryData;                                     // 0x0000(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UInventoryBalanceData*                  InventoryBalanceData;                              // 0x0008(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UManufacturerData*                      ManufacturerData;                                  // 0x0010(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         GameStage;                                         // 0x0018(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1C[0x4];                                       // 0x001C(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	struct FActorPartSelectionOverrideData        PartSelectionOverrideData;                         // 0x0020(0x0010)(NativeAccessSpecifierPublic)
	struct FActorPartList                         GenericPartSelectionOverrideData;                  // 0x0030(0x0018)(NativeAccessSpecifierPublic)
	TArray<class UInventoryGenericPartData*>      GenericPartsToInject;                              // 0x0048(0x0010)(ZeroConstructor, NativeAccessSpecifierPublic)
	bool                                          bCompileUIStats;                                   // 0x0058(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bDroppedFromAI;                                    // 0x0059(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_5A[0x6];                                       // 0x005A(0x0006)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FSelectedInventoryInfo) == 0x000008, "Wrong alignment on FSelectedInventoryInfo");
static_assert(sizeof(FSelectedInventoryInfo) == 0x000060, "Wrong size on FSelectedInventoryInfo");
static_assert(offsetof(FSelectedInventoryInfo, InventoryData) == 0x000000, "Member 'FSelectedInventoryInfo::InventoryData' has a wrong offset!");
static_assert(offsetof(FSelectedInventoryInfo, InventoryBalanceData) == 0x000008, "Member 'FSelectedInventoryInfo::InventoryBalanceData' has a wrong offset!");
static_assert(offsetof(FSelectedInventoryInfo, ManufacturerData) == 0x000010, "Member 'FSelectedInventoryInfo::ManufacturerData' has a wrong offset!");
static_assert(offsetof(FSelectedInventoryInfo, GameStage) == 0x000018, "Member 'FSelectedInventoryInfo::GameStage' has a wrong offset!");
static_assert(offsetof(FSelectedInventoryInfo, PartSelectionOverrideData) == 0x000020, "Member 'FSelectedInventoryInfo::PartSelectionOverrideData' has a wrong offset!");
static_assert(offsetof(FSelectedInventoryInfo, GenericPartSelectionOverrideData) == 0x000030, "Member 'FSelectedInventoryInfo::GenericPartSelectionOverrideData' has a wrong offset!");
static_assert(offsetof(FSelectedInventoryInfo, GenericPartsToInject) == 0x000048, "Member 'FSelectedInventoryInfo::GenericPartsToInject' has a wrong offset!");
static_assert(offsetof(FSelectedInventoryInfo, bCompileUIStats) == 0x000058, "Member 'FSelectedInventoryInfo::bCompileUIStats' has a wrong offset!");
static_assert(offsetof(FSelectedInventoryInfo, bDroppedFromAI) == 0x000059, "Member 'FSelectedInventoryInfo::bDroppedFromAI' has a wrong offset!");

// ScriptStruct GbxInventory.RuntimeGenericPartListData
// 0x0020 (0x0020 - 0x0000)
struct FRuntimeGenericPartListData final
{
public:
	bool                                          bEnabled;                                          // 0x0000(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_1[0x7];                                        // 0x0001(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<struct FWeightedActorPartData>         PartList;                                          // 0x0008(0x0010)(ZeroConstructor, NativeAccessSpecifierPrivate)
	uint8                                         Pad_18[0x8];                                       // 0x0018(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FRuntimeGenericPartListData) == 0x000008, "Wrong alignment on FRuntimeGenericPartListData");
static_assert(sizeof(FRuntimeGenericPartListData) == 0x000020, "Wrong size on FRuntimeGenericPartListData");
static_assert(offsetof(FRuntimeGenericPartListData, bEnabled) == 0x000000, "Member 'FRuntimeGenericPartListData::bEnabled' has a wrong offset!");
static_assert(offsetof(FRuntimeGenericPartListData, PartList) == 0x000008, "Member 'FRuntimeGenericPartListData::PartList' has a wrong offset!");

// ScriptStruct GbxInventory.InventorySaveGameData
// 0x0080 (0x0080 - 0x0000)
struct FInventorySaveGameData final
{
public:
	TArray<uint8>                                 EncryptedSerialNumber;                             // 0x0000(0x0010)(Edit, ZeroConstructor, EditConst, NativeAccessSpecifierPublic)
	struct FInventoryBalanceStateInitializationData DevelopmentSaveData;                               // 0x0010(0x0068)(Edit, EditConst, NativeAccessSpecifierPublic)
	uint8                                         Pad_78[0x8];                                       // 0x0078(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FInventorySaveGameData) == 0x000008, "Wrong alignment on FInventorySaveGameData");
static_assert(sizeof(FInventorySaveGameData) == 0x000080, "Wrong size on FInventorySaveGameData");
static_assert(offsetof(FInventorySaveGameData, EncryptedSerialNumber) == 0x000000, "Member 'FInventorySaveGameData::EncryptedSerialNumber' has a wrong offset!");
static_assert(offsetof(FInventorySaveGameData, DevelopmentSaveData) == 0x000010, "Member 'FInventorySaveGameData::DevelopmentSaveData' has a wrong offset!");

// ScriptStruct GbxInventory.InventoryListEntry
// 0x0034 (0x0040 - 0x000C)
struct FInventoryListEntry final : public FFastArraySerializerItem
{
public:
	struct FInventoryListEntryHandle              Handle;                                            // 0x000C(0x0004)(BlueprintVisible, BlueprintReadOnly, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UInventoryCategoryData*                 BaseCategoryDefinition;                            // 0x0010(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         Quantity;                                          // 0x0018(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1C[0x4];                                       // 0x001C(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class AActor*                                 StoredActor;                                       // 0x0020(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EPlayerDroppability                           PlayerDroppability;                                // 0x0028(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_29[0x17];                                      // 0x0029(0x0017)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FInventoryListEntry) == 0x000008, "Wrong alignment on FInventoryListEntry");
static_assert(sizeof(FInventoryListEntry) == 0x000040, "Wrong size on FInventoryListEntry");
static_assert(offsetof(FInventoryListEntry, Handle) == 0x00000C, "Member 'FInventoryListEntry::Handle' has a wrong offset!");
static_assert(offsetof(FInventoryListEntry, BaseCategoryDefinition) == 0x000010, "Member 'FInventoryListEntry::BaseCategoryDefinition' has a wrong offset!");
static_assert(offsetof(FInventoryListEntry, Quantity) == 0x000018, "Member 'FInventoryListEntry::Quantity' has a wrong offset!");
static_assert(offsetof(FInventoryListEntry, StoredActor) == 0x000020, "Member 'FInventoryListEntry::StoredActor' has a wrong offset!");
static_assert(offsetof(FInventoryListEntry, PlayerDroppability) == 0x000028, "Member 'FInventoryListEntry::PlayerDroppability' has a wrong offset!");

// ScriptStruct GbxInventory.ItemPoolCollection
// 0x0020 (0x0020 - 0x0000)
struct FItemPoolCollection final
{
public:
	TArray<struct FItemPoolInfo>                  ItemPools;                                         // 0x0000(0x0010)(Edit, ZeroConstructor, Protected, NativeAccessSpecifierProtected)
	TArray<class UItemPoolListData*>              ItemPoolLists;                                     // 0x0010(0x0010)(Edit, ZeroConstructor, Protected, NativeAccessSpecifierProtected)
};
static_assert(alignof(FItemPoolCollection) == 0x000008, "Wrong alignment on FItemPoolCollection");
static_assert(sizeof(FItemPoolCollection) == 0x000020, "Wrong size on FItemPoolCollection");
static_assert(offsetof(FItemPoolCollection, ItemPools) == 0x000000, "Member 'FItemPoolCollection::ItemPools' has a wrong offset!");
static_assert(offsetof(FItemPoolCollection, ItemPoolLists) == 0x000010, "Member 'FItemPoolCollection::ItemPoolLists' has a wrong offset!");

// ScriptStruct GbxInventory.InventoryManufacturerBalanceData
// 0x0080 (0x0080 - 0x0000)
struct FInventoryManufacturerBalanceData final
{
public:
	class UManufacturerData*                      ManufacturerData;                                  // 0x0000(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	struct FGameStageGradeWeightData              GameStageWeight;                                   // 0x0008(0x0070)(Edit, NoDestructor, NativeAccessSpecifierPrivate)
	class UItemPoolPartSelectionOverrideData*     PartSelectionOverrideData;                         // 0x0078(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
};
static_assert(alignof(FInventoryManufacturerBalanceData) == 0x000008, "Wrong alignment on FInventoryManufacturerBalanceData");
static_assert(sizeof(FInventoryManufacturerBalanceData) == 0x000080, "Wrong size on FInventoryManufacturerBalanceData");
static_assert(offsetof(FInventoryManufacturerBalanceData, ManufacturerData) == 0x000000, "Member 'FInventoryManufacturerBalanceData::ManufacturerData' has a wrong offset!");
static_assert(offsetof(FInventoryManufacturerBalanceData, GameStageWeight) == 0x000008, "Member 'FInventoryManufacturerBalanceData::GameStageWeight' has a wrong offset!");
static_assert(offsetof(FInventoryManufacturerBalanceData, PartSelectionOverrideData) == 0x000078, "Member 'FInventoryManufacturerBalanceData::PartSelectionOverrideData' has a wrong offset!");

// ScriptStruct GbxInventory.InventoryPrimitiveSectionAspectSetData
// 0x0018 (0x0018 - 0x0000)
struct FInventoryPrimitiveSectionAspectSetData final
{
public:
	class UInventoryMaterialAspectData*           PrimaryMaterialAspect;                             // 0x0000(0x0008)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TArray<class UInventoryMaterialAspectData*>   MaterialAspects;                                   // 0x0008(0x0010)(ZeroConstructor, Transient, NativeAccessSpecifierPublic)
};
static_assert(alignof(FInventoryPrimitiveSectionAspectSetData) == 0x000008, "Wrong alignment on FInventoryPrimitiveSectionAspectSetData");
static_assert(sizeof(FInventoryPrimitiveSectionAspectSetData) == 0x000018, "Wrong size on FInventoryPrimitiveSectionAspectSetData");
static_assert(offsetof(FInventoryPrimitiveSectionAspectSetData, PrimaryMaterialAspect) == 0x000000, "Member 'FInventoryPrimitiveSectionAspectSetData::PrimaryMaterialAspect' has a wrong offset!");
static_assert(offsetof(FInventoryPrimitiveSectionAspectSetData, MaterialAspects) == 0x000008, "Member 'FInventoryPrimitiveSectionAspectSetData::MaterialAspects' has a wrong offset!");

// ScriptStruct GbxInventory.InventoryPrimitiveAspectSetData
// 0x0020 (0x0020 - 0x0000)
struct FInventoryPrimitiveAspectSetData final
{
public:
	class FName                                   PrimitiveComponentName;                            // 0x0000(0x0008)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   PrimitiveComponentTag;                             // 0x0008(0x0008)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TArray<struct FInventoryPrimitiveSectionAspectSetData> SectionAspectSetList;                              // 0x0010(0x0010)(ZeroConstructor, Transient, NativeAccessSpecifierPublic)
};
static_assert(alignof(FInventoryPrimitiveAspectSetData) == 0x000008, "Wrong alignment on FInventoryPrimitiveAspectSetData");
static_assert(sizeof(FInventoryPrimitiveAspectSetData) == 0x000020, "Wrong size on FInventoryPrimitiveAspectSetData");
static_assert(offsetof(FInventoryPrimitiveAspectSetData, PrimitiveComponentName) == 0x000000, "Member 'FInventoryPrimitiveAspectSetData::PrimitiveComponentName' has a wrong offset!");
static_assert(offsetof(FInventoryPrimitiveAspectSetData, PrimitiveComponentTag) == 0x000008, "Member 'FInventoryPrimitiveAspectSetData::PrimitiveComponentTag' has a wrong offset!");
static_assert(offsetof(FInventoryPrimitiveAspectSetData, SectionAspectSetList) == 0x000010, "Member 'FInventoryPrimitiveAspectSetData::SectionAspectSetList' has a wrong offset!");

// ScriptStruct GbxInventory.InventoryConditionalDamageAspectInfo
// 0x0010 (0x0010 - 0x0000)
struct FInventoryConditionalDamageAspectInfo final
{
public:
	class UConditionalDamageModifier*             ConditionalModifier;                               // 0x0000(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bUseInventoryForDamageValueContext;                // 0x0008(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EInventoryConditionalDamageApplicationTarget  ApplicationTarget;                                 // 0x0009(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_A[0x6];                                        // 0x000A(0x0006)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FInventoryConditionalDamageAspectInfo) == 0x000008, "Wrong alignment on FInventoryConditionalDamageAspectInfo");
static_assert(sizeof(FInventoryConditionalDamageAspectInfo) == 0x000010, "Wrong size on FInventoryConditionalDamageAspectInfo");
static_assert(offsetof(FInventoryConditionalDamageAspectInfo, ConditionalModifier) == 0x000000, "Member 'FInventoryConditionalDamageAspectInfo::ConditionalModifier' has a wrong offset!");
static_assert(offsetof(FInventoryConditionalDamageAspectInfo, bUseInventoryForDamageValueContext) == 0x000008, "Member 'FInventoryConditionalDamageAspectInfo::bUseInventoryForDamageValueContext' has a wrong offset!");
static_assert(offsetof(FInventoryConditionalDamageAspectInfo, ApplicationTarget) == 0x000009, "Member 'FInventoryConditionalDamageAspectInfo::ApplicationTarget' has a wrong offset!");

// ScriptStruct GbxInventory.InventoryGenericPartExpansionListData
// 0x0000 (0x0028 - 0x0028)
struct FInventoryGenericPartExpansionListData final : public FActorPartListData
{
};
static_assert(alignof(FInventoryGenericPartExpansionListData) == 0x000008, "Wrong alignment on FInventoryGenericPartExpansionListData");
static_assert(sizeof(FInventoryGenericPartExpansionListData) == 0x000028, "Wrong size on FInventoryGenericPartExpansionListData");

// ScriptStruct GbxInventory.InventoryItemPickupClientSpawnData
// 0x0030 (0x0030 - 0x0000)
struct FInventoryItemPickupClientSpawnData final
{
public:
	bool                                          bSpawnDefaultPickupActor;                          // 0x0000(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1[0x7];                                        // 0x0001(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	struct FInventoryReplicationData              BalanceData;                                       // 0x0008(0x0010)(NativeAccessSpecifierPublic)
	struct FReplicatedUIStatCollectionData        UIStats;                                           // 0x0018(0x0010)(NativeAccessSpecifierPublic)
	int32                                         MonetaryValue;                                     // 0x0028(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         InventoryScoreValue;                               // 0x002C(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FInventoryItemPickupClientSpawnData) == 0x000008, "Wrong alignment on FInventoryItemPickupClientSpawnData");
static_assert(sizeof(FInventoryItemPickupClientSpawnData) == 0x000030, "Wrong size on FInventoryItemPickupClientSpawnData");
static_assert(offsetof(FInventoryItemPickupClientSpawnData, bSpawnDefaultPickupActor) == 0x000000, "Member 'FInventoryItemPickupClientSpawnData::bSpawnDefaultPickupActor' has a wrong offset!");
static_assert(offsetof(FInventoryItemPickupClientSpawnData, BalanceData) == 0x000008, "Member 'FInventoryItemPickupClientSpawnData::BalanceData' has a wrong offset!");
static_assert(offsetof(FInventoryItemPickupClientSpawnData, UIStats) == 0x000018, "Member 'FInventoryItemPickupClientSpawnData::UIStats' has a wrong offset!");
static_assert(offsetof(FInventoryItemPickupClientSpawnData, MonetaryValue) == 0x000028, "Member 'FInventoryItemPickupClientSpawnData::MonetaryValue' has a wrong offset!");
static_assert(offsetof(FInventoryItemPickupClientSpawnData, InventoryScoreValue) == 0x00002C, "Member 'FInventoryItemPickupClientSpawnData::InventoryScoreValue' has a wrong offset!");

// ScriptStruct GbxInventory.InventorySelectionTracker
// 0x000C (0x000C - 0x0000)
struct FInventorySelectionTracker final
{
public:
	int32                                         SelectedIndex;                                     // 0x0000(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          TrackQuantity;                                     // 0x0004(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_5[0x3];                                        // 0x0005(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	struct FInventoryListEntryHandle              SelectedHandle;                                    // 0x0008(0x0004)(NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FInventorySelectionTracker) == 0x000004, "Wrong alignment on FInventorySelectionTracker");
static_assert(sizeof(FInventorySelectionTracker) == 0x00000C, "Wrong size on FInventorySelectionTracker");
static_assert(offsetof(FInventorySelectionTracker, SelectedIndex) == 0x000000, "Member 'FInventorySelectionTracker::SelectedIndex' has a wrong offset!");
static_assert(offsetof(FInventorySelectionTracker, TrackQuantity) == 0x000004, "Member 'FInventorySelectionTracker::TrackQuantity' has a wrong offset!");
static_assert(offsetof(FInventorySelectionTracker, SelectedHandle) == 0x000008, "Member 'FInventorySelectionTracker::SelectedHandle' has a wrong offset!");

// ScriptStruct GbxInventory.InventoryListContainer
// 0x0018 (0x00C8 - 0x00B0)
struct FInventoryListContainer final : public FFastArraySerializer
{
public:
	TArray<struct FInventoryListEntry>            Items;                                             // 0x00B0(0x0010)(ZeroConstructor, NativeAccessSpecifierPublic)
	uint8                                         Pad_C0[0x8];                                       // 0x00C0(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FInventoryListContainer) == 0x000008, "Wrong alignment on FInventoryListContainer");
static_assert(sizeof(FInventoryListContainer) == 0x0000C8, "Wrong size on FInventoryListContainer");
static_assert(offsetof(FInventoryListContainer, Items) == 0x0000B0, "Member 'FInventoryListContainer::Items' has a wrong offset!");

// ScriptStruct GbxInventory.InventoryListEntryUIData
// 0x0008 (0x0008 - 0x0000)
struct alignas(0x04) FInventoryListEntryUIData final
{
public:
	uint8                                         Pad_0[0x8];                                        // 0x0000(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FInventoryListEntryUIData) == 0x000004, "Wrong alignment on FInventoryListEntryUIData");
static_assert(sizeof(FInventoryListEntryUIData) == 0x000008, "Wrong size on FInventoryListEntryUIData");

// ScriptStruct GbxInventory.InventoryCategorySaveData
// 0x0010 (0x0010 - 0x0000)
struct FInventoryCategorySaveData final
{
public:
	class UInventoryCategoryData*                 BaseCategoryDefinition;                            // 0x0000(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         Quantity;                                          // 0x0008(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_C[0x4];                                        // 0x000C(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FInventoryCategorySaveData) == 0x000008, "Wrong alignment on FInventoryCategorySaveData");
static_assert(sizeof(FInventoryCategorySaveData) == 0x000010, "Wrong size on FInventoryCategorySaveData");
static_assert(offsetof(FInventoryCategorySaveData, BaseCategoryDefinition) == 0x000000, "Member 'FInventoryCategorySaveData::BaseCategoryDefinition' has a wrong offset!");
static_assert(offsetof(FInventoryCategorySaveData, Quantity) == 0x000008, "Member 'FInventoryCategorySaveData::Quantity' has a wrong offset!");

// ScriptStruct GbxInventory.RarityMaterialData
// 0x0010 (0x0010 - 0x0000)
struct FRarityMaterialData final
{
public:
	class UInventoryRarityData*                   Rarity;                                            // 0x0000(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UMaterialInterface*                     Material;                                          // 0x0008(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FRarityMaterialData) == 0x000008, "Wrong alignment on FRarityMaterialData");
static_assert(sizeof(FRarityMaterialData) == 0x000010, "Wrong size on FRarityMaterialData");
static_assert(offsetof(FRarityMaterialData, Rarity) == 0x000000, "Member 'FRarityMaterialData::Rarity' has a wrong offset!");
static_assert(offsetof(FRarityMaterialData, Material) == 0x000008, "Member 'FRarityMaterialData::Material' has a wrong offset!");

// ScriptStruct GbxInventory.MaterialFontParameterData
// 0x0010 (0x0018 - 0x0008)
struct FMaterialFontParameterData final : public FMaterialParameterData
{
public:
	class UFont*                                  Font;                                              // 0x0008(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         FontPage;                                          // 0x0010(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_14[0x4];                                       // 0x0014(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FMaterialFontParameterData) == 0x000008, "Wrong alignment on FMaterialFontParameterData");
static_assert(sizeof(FMaterialFontParameterData) == 0x000018, "Wrong size on FMaterialFontParameterData");
static_assert(offsetof(FMaterialFontParameterData, Font) == 0x000008, "Member 'FMaterialFontParameterData::Font' has a wrong offset!");
static_assert(offsetof(FMaterialFontParameterData, FontPage) == 0x000010, "Member 'FMaterialFontParameterData::FontPage' has a wrong offset!");

// ScriptStruct GbxInventory.MaterialTextureParameterData
// 0x0008 (0x0010 - 0x0008)
struct FMaterialTextureParameterData final : public FMaterialParameterData
{
public:
	class UTexture*                               Texture;                                           // 0x0008(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FMaterialTextureParameterData) == 0x000008, "Wrong alignment on FMaterialTextureParameterData");
static_assert(sizeof(FMaterialTextureParameterData) == 0x000010, "Wrong size on FMaterialTextureParameterData");
static_assert(offsetof(FMaterialTextureParameterData, Texture) == 0x000008, "Member 'FMaterialTextureParameterData::Texture' has a wrong offset!");

// ScriptStruct GbxInventory.MaterialScalarParameterData
// 0x0008 (0x0010 - 0x0008)
struct FMaterialScalarParameterData final : public FMaterialParameterData
{
public:
	float                                         Scalar;                                            // 0x0008(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_C[0x4];                                        // 0x000C(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FMaterialScalarParameterData) == 0x000008, "Wrong alignment on FMaterialScalarParameterData");
static_assert(sizeof(FMaterialScalarParameterData) == 0x000010, "Wrong size on FMaterialScalarParameterData");
static_assert(offsetof(FMaterialScalarParameterData, Scalar) == 0x000008, "Member 'FMaterialScalarParameterData::Scalar' has a wrong offset!");

// ScriptStruct GbxInventory.MaterialVectorParameterData
// 0x0010 (0x0018 - 0x0008)
struct FMaterialVectorParameterData final : public FMaterialParameterData
{
public:
	struct FLinearColor                           Vector;                                            // 0x0008(0x0010)(Edit, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FMaterialVectorParameterData) == 0x000008, "Wrong alignment on FMaterialVectorParameterData");
static_assert(sizeof(FMaterialVectorParameterData) == 0x000018, "Wrong size on FMaterialVectorParameterData");
static_assert(offsetof(FMaterialVectorParameterData, Vector) == 0x000008, "Member 'FMaterialVectorParameterData::Vector' has a wrong offset!");

// ScriptStruct GbxInventory.ConditionalInventoryParticleEmitter
// 0x0018 (0x0018 - 0x0000)
struct FConditionalInventoryParticleEmitter final
{
public:
	class UGbxCondition*                          EnableCondition;                                   // 0x0000(0x0008)(Edit, ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, PersistentInstance, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TArray<class FName>                           EmitterNames;                                      // 0x0008(0x0010)(Edit, ZeroConstructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(FConditionalInventoryParticleEmitter) == 0x000008, "Wrong alignment on FConditionalInventoryParticleEmitter");
static_assert(sizeof(FConditionalInventoryParticleEmitter) == 0x000018, "Wrong size on FConditionalInventoryParticleEmitter");
static_assert(offsetof(FConditionalInventoryParticleEmitter, EnableCondition) == 0x000000, "Member 'FConditionalInventoryParticleEmitter::EnableCondition' has a wrong offset!");
static_assert(offsetof(FConditionalInventoryParticleEmitter, EmitterNames) == 0x000008, "Member 'FConditionalInventoryParticleEmitter::EmitterNames' has a wrong offset!");

// ScriptStruct GbxInventory.InventoryGenericPartListData
// 0x0000 (0x0028 - 0x0028)
struct FInventoryGenericPartListData final : public FActorPartListData
{
};
static_assert(alignof(FInventoryGenericPartListData) == 0x000008, "Wrong alignment on FInventoryGenericPartListData");
static_assert(sizeof(FInventoryGenericPartListData) == 0x000028, "Wrong size on FInventoryGenericPartListData");

// ScriptStruct GbxInventory.InventorySerialNumber
// 0x0020 (0x0020 - 0x0000)
struct FInventorySerialNumber final
{
public:
	EInventorySerialNumberState                   State;                                             // 0x0000(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_1[0x7];                                        // 0x0001(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<uint8>                                 Buffer;                                            // 0x0008(0x0010)(ZeroConstructor, NativeAccessSpecifierPrivate)
	uint32                                        RunningCounter;                                    // 0x0018(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_1C[0x4];                                       // 0x001C(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FInventorySerialNumber) == 0x000008, "Wrong alignment on FInventorySerialNumber");
static_assert(sizeof(FInventorySerialNumber) == 0x000020, "Wrong size on FInventorySerialNumber");
static_assert(offsetof(FInventorySerialNumber, State) == 0x000000, "Member 'FInventorySerialNumber::State' has a wrong offset!");
static_assert(offsetof(FInventorySerialNumber, Buffer) == 0x000008, "Member 'FInventorySerialNumber::Buffer' has a wrong offset!");
static_assert(offsetof(FInventorySerialNumber, RunningCounter) == 0x000018, "Member 'FInventorySerialNumber::RunningCounter' has a wrong offset!");

// ScriptStruct GbxInventory.BalancedInventoryInfo
// 0x0070 (0x0070 - 0x0000)
struct FBalancedInventoryInfo final
{
public:
	class UItemPoolData*                          ItemPoolData;                                      // 0x0000(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TSoftObjectPtr<class UInventoryBalanceData>   InventoryBalanceData;                              // 0x0008(0x0028)(Edit, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UInventoryBalanceData*                  ResolvedInventoryBalanceData;                      // 0x0030(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	struct FAttributeInitializationData           Weight;                                            // 0x0038(0x0038)(Edit, NoDestructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(FBalancedInventoryInfo) == 0x000008, "Wrong alignment on FBalancedInventoryInfo");
static_assert(sizeof(FBalancedInventoryInfo) == 0x000070, "Wrong size on FBalancedInventoryInfo");
static_assert(offsetof(FBalancedInventoryInfo, ItemPoolData) == 0x000000, "Member 'FBalancedInventoryInfo::ItemPoolData' has a wrong offset!");
static_assert(offsetof(FBalancedInventoryInfo, InventoryBalanceData) == 0x000008, "Member 'FBalancedInventoryInfo::InventoryBalanceData' has a wrong offset!");
static_assert(offsetof(FBalancedInventoryInfo, ResolvedInventoryBalanceData) == 0x000030, "Member 'FBalancedInventoryInfo::ResolvedInventoryBalanceData' has a wrong offset!");
static_assert(offsetof(FBalancedInventoryInfo, Weight) == 0x000038, "Member 'FBalancedInventoryInfo::Weight' has a wrong offset!");

// ScriptStruct GbxInventory.ItemPoolPartSelectionPartTypeOverrideData
// 0x0018 (0x0018 - 0x0000)
struct FItemPoolPartSelectionPartTypeOverrideData final
{
public:
	uint8                                         PartType;                                          // 0x0000(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_1[0x7];                                        // 0x0001(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<class UActorPartData*>                 PreferredParts;                                    // 0x0008(0x0010)(Edit, ZeroConstructor, Protected, NativeAccessSpecifierProtected)
};
static_assert(alignof(FItemPoolPartSelectionPartTypeOverrideData) == 0x000008, "Wrong alignment on FItemPoolPartSelectionPartTypeOverrideData");
static_assert(sizeof(FItemPoolPartSelectionPartTypeOverrideData) == 0x000018, "Wrong size on FItemPoolPartSelectionPartTypeOverrideData");
static_assert(offsetof(FItemPoolPartSelectionPartTypeOverrideData, PartType) == 0x000000, "Member 'FItemPoolPartSelectionPartTypeOverrideData::PartType' has a wrong offset!");
static_assert(offsetof(FItemPoolPartSelectionPartTypeOverrideData, PreferredParts) == 0x000008, "Member 'FItemPoolPartSelectionPartTypeOverrideData::PreferredParts' has a wrong offset!");

// ScriptStruct GbxInventory.LootConfigurationInfo
// 0x0058 (0x0058 - 0x0000)
struct FLootConfigurationInfo final
{
public:
	class FName                                   ConfigurationName;                                 // 0x0000(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TSubclassOf<class UAttributeInitializer>      LootGameStageVarianceFormula;                      // 0x0008(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FAttributeInitializationData           Weight;                                            // 0x0010(0x0038)(Edit, NoDestructor, NativeAccessSpecifierPublic)
	TArray<struct FLootAttachmentInfo>            ItemAttachments;                                   // 0x0048(0x0010)(Edit, ZeroConstructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(FLootConfigurationInfo) == 0x000008, "Wrong alignment on FLootConfigurationInfo");
static_assert(sizeof(FLootConfigurationInfo) == 0x000058, "Wrong size on FLootConfigurationInfo");
static_assert(offsetof(FLootConfigurationInfo, ConfigurationName) == 0x000000, "Member 'FLootConfigurationInfo::ConfigurationName' has a wrong offset!");
static_assert(offsetof(FLootConfigurationInfo, LootGameStageVarianceFormula) == 0x000008, "Member 'FLootConfigurationInfo::LootGameStageVarianceFormula' has a wrong offset!");
static_assert(offsetof(FLootConfigurationInfo, Weight) == 0x000010, "Member 'FLootConfigurationInfo::Weight' has a wrong offset!");
static_assert(offsetof(FLootConfigurationInfo, ItemAttachments) == 0x000048, "Member 'FLootConfigurationInfo::ItemAttachments' has a wrong offset!");

// ScriptStruct GbxInventory.ManufacturerGradeData
// 0x0010 (0x0010 - 0x0000)
struct FManufacturerGradeData final
{
public:
	class FString                                 DisplayName;                                       // 0x0000(0x0010)(Edit, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FManufacturerGradeData) == 0x000008, "Wrong alignment on FManufacturerGradeData");
static_assert(sizeof(FManufacturerGradeData) == 0x000010, "Wrong size on FManufacturerGradeData");
static_assert(offsetof(FManufacturerGradeData, DisplayName) == 0x000000, "Member 'FManufacturerGradeData::DisplayName' has a wrong offset!");

}

