#pragma once

/*
* SDK generated by Dumper-7
*
* https://github.com/Encryqed/Dumper-7
*/

// Package: GbxCameraModes

#include "Basic.hpp"

#include "GbxGameSystemCore_structs.hpp"
#include "GbxGameSystemCore_classes.hpp"
#include "CoreUObject_structs.hpp"
#include "CoreUObject_classes.hpp"
#include "GbxCameraModes_structs.hpp"
#include "GbxRuntime_classes.hpp"
#include "Engine_structs.hpp"
#include "Engine_classes.hpp"


namespace SDK
{

// Class GbxCameraModes.CameraBehavior
// 0x0008 (0x0030 - 0x0028)
class UCameraBehavior : public UObject
{
public:
	uint8                                         bEnabled : 1;                                      // 0x0028(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (Edit, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected))
	uint8                                         bUpdatePreViewTarget : 1;                          // 0x0028(0x0001)(BitIndex: 0x01, PropSize: 0x0001 (Edit, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected))
	uint8                                         bUpdateForRemoteClient : 1;                        // 0x0028(0x0001)(BitIndex: 0x02, PropSize: 0x0001 (Edit, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected))
	uint8                                         Pad_29[0x7];                                       // 0x0029(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void End(class UCameraState* State);
	void Start(class UCameraState* State);
	void Update(float DeltaTime, class UCameraState* State);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"CameraBehavior">();
	}
	static class UCameraBehavior* GetDefaultObj()
	{
		return GetDefaultObjImpl<UCameraBehavior>();
	}
};
static_assert(alignof(UCameraBehavior) == 0x000008, "Wrong alignment on UCameraBehavior");
static_assert(sizeof(UCameraBehavior) == 0x000030, "Wrong size on UCameraBehavior");

// Class GbxCameraModes.CameraInputs
// 0x0090 (0x00B8 - 0x0028)
class UCameraInputs : public UObject
{
public:
	float                                         CurrentTime;                                       // 0x0028(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FRotator                               RotationInput;                                     // 0x002C(0x000C)(BlueprintVisible, BlueprintReadOnly, Transient, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
	struct FVector                                AdditionalInput;                                   // 0x0038(0x000C)(BlueprintVisible, BlueprintReadOnly, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         AdditionalRoll;                                    // 0x0044(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         DefaultFOV;                                        // 0x0048(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         DefaultForegroundFOV;                              // 0x004C(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                EyeLocation;                                       // 0x0050(0x000C)(BlueprintVisible, BlueprintReadOnly, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_5C[0xC];                                       // 0x005C(0x000C)(Fixing Size After Last Property [ Dumper-7 ])
	struct FRotator                               EyeRotation;                                       // 0x0068(0x000C)(BlueprintVisible, BlueprintReadOnly, Transient, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
	uint8                                         Pad_74[0xC];                                       // 0x0074(0x000C)(Fixing Size After Last Property [ Dumper-7 ])
	struct FRotator                               FacingRotation;                                    // 0x0080(0x000C)(BlueprintVisible, BlueprintReadOnly, Transient, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
	struct FVector                                CollisionSafeLocation;                             // 0x008C(0x000C)(BlueprintVisible, BlueprintReadOnly, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class AActor*                                 ViewTarget;                                        // 0x0098(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class APlayerController*                      Controller;                                        // 0x00A0(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class USceneComponent*                        AttachComponent;                                   // 0x00A8(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, Transient, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   AttachSocket;                                      // 0x00B0(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"CameraInputs">();
	}
	static class UCameraInputs* GetDefaultObj()
	{
		return GetDefaultObjImpl<UCameraInputs>();
	}
};
static_assert(alignof(UCameraInputs) == 0x000008, "Wrong alignment on UCameraInputs");
static_assert(sizeof(UCameraInputs) == 0x0000B8, "Wrong size on UCameraInputs");
static_assert(offsetof(UCameraInputs, CurrentTime) == 0x000028, "Member 'UCameraInputs::CurrentTime' has a wrong offset!");
static_assert(offsetof(UCameraInputs, RotationInput) == 0x00002C, "Member 'UCameraInputs::RotationInput' has a wrong offset!");
static_assert(offsetof(UCameraInputs, AdditionalInput) == 0x000038, "Member 'UCameraInputs::AdditionalInput' has a wrong offset!");
static_assert(offsetof(UCameraInputs, AdditionalRoll) == 0x000044, "Member 'UCameraInputs::AdditionalRoll' has a wrong offset!");
static_assert(offsetof(UCameraInputs, DefaultFOV) == 0x000048, "Member 'UCameraInputs::DefaultFOV' has a wrong offset!");
static_assert(offsetof(UCameraInputs, DefaultForegroundFOV) == 0x00004C, "Member 'UCameraInputs::DefaultForegroundFOV' has a wrong offset!");
static_assert(offsetof(UCameraInputs, EyeLocation) == 0x000050, "Member 'UCameraInputs::EyeLocation' has a wrong offset!");
static_assert(offsetof(UCameraInputs, EyeRotation) == 0x000068, "Member 'UCameraInputs::EyeRotation' has a wrong offset!");
static_assert(offsetof(UCameraInputs, FacingRotation) == 0x000080, "Member 'UCameraInputs::FacingRotation' has a wrong offset!");
static_assert(offsetof(UCameraInputs, CollisionSafeLocation) == 0x00008C, "Member 'UCameraInputs::CollisionSafeLocation' has a wrong offset!");
static_assert(offsetof(UCameraInputs, ViewTarget) == 0x000098, "Member 'UCameraInputs::ViewTarget' has a wrong offset!");
static_assert(offsetof(UCameraInputs, Controller) == 0x0000A0, "Member 'UCameraInputs::Controller' has a wrong offset!");
static_assert(offsetof(UCameraInputs, AttachComponent) == 0x0000A8, "Member 'UCameraInputs::AttachComponent' has a wrong offset!");
static_assert(offsetof(UCameraInputs, AttachSocket) == 0x0000B0, "Member 'UCameraInputs::AttachSocket' has a wrong offset!");

// Class GbxCameraModes.CameraBehavior_AnchorToSocket
// 0x0010 (0x0040 - 0x0030)
class UCameraBehavior_AnchorToSocket final : public UCameraBehavior
{
public:
	uint8                                         bSetLocation : 1;                                  // 0x0030(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (Edit, BlueprintVisible, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         bSetRotation : 1;                                  // 0x0030(0x0001)(BitIndex: 0x01, PropSize: 0x0001 (Edit, BlueprintVisible, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         Pad_31[0x7];                                       // 0x0031(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	class FName                                   SocketName;                                        // 0x0038(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"CameraBehavior_AnchorToSocket">();
	}
	static class UCameraBehavior_AnchorToSocket* GetDefaultObj()
	{
		return GetDefaultObjImpl<UCameraBehavior_AnchorToSocket>();
	}
};
static_assert(alignof(UCameraBehavior_AnchorToSocket) == 0x000008, "Wrong alignment on UCameraBehavior_AnchorToSocket");
static_assert(sizeof(UCameraBehavior_AnchorToSocket) == 0x000040, "Wrong size on UCameraBehavior_AnchorToSocket");
static_assert(offsetof(UCameraBehavior_AnchorToSocket, SocketName) == 0x000038, "Member 'UCameraBehavior_AnchorToSocket::SocketName' has a wrong offset!");

// Class GbxCameraModes.CameraBehavior_Look
// 0x0070 (0x00A0 - 0x0030)
class UCameraBehavior_Look : public UCameraBehavior
{
public:
	ECameraLookSpaces                             UpAxis;                                            // 0x0030(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_31[0x3];                                       // 0x0031(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         YawSpeedScale;                                     // 0x0034(0x0004)(ZeroConstructor, Deprecated, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         PitchSpeedScale;                                   // 0x0038(0x0004)(ZeroConstructor, Deprecated, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         RollSpeedScale;                                    // 0x003C(0x0004)(ZeroConstructor, Deprecated, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         bSnapOnStart : 1;                                  // 0x0040(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (Edit, BlueprintVisible, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         Pad_41[0x3];                                       // 0x0041(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	struct FCameraBehaviorLookAxis                AXIS[0x3];                                         // 0x0044(0x0018)(Edit, NoDestructor, NativeAccessSpecifierPublic)
	struct FGbxEasingFunc                         FeatheringFunction;                                // 0x008C(0x000C)(Edit, NoDestructor, NativeAccessSpecifierPublic)
	uint8                                         Pad_98[0x8];                                       // 0x0098(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"CameraBehavior_Look">();
	}
	static class UCameraBehavior_Look* GetDefaultObj()
	{
		return GetDefaultObjImpl<UCameraBehavior_Look>();
	}
};
static_assert(alignof(UCameraBehavior_Look) == 0x000008, "Wrong alignment on UCameraBehavior_Look");
static_assert(sizeof(UCameraBehavior_Look) == 0x0000A0, "Wrong size on UCameraBehavior_Look");
static_assert(offsetof(UCameraBehavior_Look, UpAxis) == 0x000030, "Member 'UCameraBehavior_Look::UpAxis' has a wrong offset!");
static_assert(offsetof(UCameraBehavior_Look, YawSpeedScale) == 0x000034, "Member 'UCameraBehavior_Look::YawSpeedScale' has a wrong offset!");
static_assert(offsetof(UCameraBehavior_Look, PitchSpeedScale) == 0x000038, "Member 'UCameraBehavior_Look::PitchSpeedScale' has a wrong offset!");
static_assert(offsetof(UCameraBehavior_Look, RollSpeedScale) == 0x00003C, "Member 'UCameraBehavior_Look::RollSpeedScale' has a wrong offset!");
static_assert(offsetof(UCameraBehavior_Look, AXIS) == 0x000044, "Member 'UCameraBehavior_Look::AXIS' has a wrong offset!");
static_assert(offsetof(UCameraBehavior_Look, FeatheringFunction) == 0x00008C, "Member 'UCameraBehavior_Look::FeatheringFunction' has a wrong offset!");

// Class GbxCameraModes.CameraBehavior_InitialRotation
// 0x0078 (0x00A8 - 0x0030)
class UCameraBehavior_InitialRotation : public UCameraBehavior
{
public:
	uint8                                         bControlPitch : 1;                                 // 0x0030(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (Edit, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         bControlYaw : 1;                                   // 0x0030(0x0001)(BitIndex: 0x01, PropSize: 0x0001 (Edit, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         bInterruptedByInput : 1;                           // 0x0030(0x0001)(BitIndex: 0x02, PropSize: 0x0001 (Edit, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         bDisableInput : 1;                                 // 0x0030(0x0001)(BitIndex: 0x03, PropSize: 0x0001 (Edit, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         Pad_31[0x7];                                       // 0x0031(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	struct FInitialRotationAxisParams             Pitch;                                             // 0x0038(0x0030)(Edit, NoDestructor, NativeAccessSpecifierPublic)
	struct FInitialRotationAxisParams             Yaw;                                               // 0x0068(0x0030)(Edit, NoDestructor, NativeAccessSpecifierPublic)
	class UGbxCondition*                          InitialCondition;                                  // 0x0098(0x0008)(Edit, ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, PersistentInstance, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_A0[0x8];                                       // 0x00A0(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"CameraBehavior_InitialRotation">();
	}
	static class UCameraBehavior_InitialRotation* GetDefaultObj()
	{
		return GetDefaultObjImpl<UCameraBehavior_InitialRotation>();
	}
};
static_assert(alignof(UCameraBehavior_InitialRotation) == 0x000008, "Wrong alignment on UCameraBehavior_InitialRotation");
static_assert(sizeof(UCameraBehavior_InitialRotation) == 0x0000A8, "Wrong size on UCameraBehavior_InitialRotation");
static_assert(offsetof(UCameraBehavior_InitialRotation, Pitch) == 0x000038, "Member 'UCameraBehavior_InitialRotation::Pitch' has a wrong offset!");
static_assert(offsetof(UCameraBehavior_InitialRotation, Yaw) == 0x000068, "Member 'UCameraBehavior_InitialRotation::Yaw' has a wrong offset!");
static_assert(offsetof(UCameraBehavior_InitialRotation, InitialCondition) == 0x000098, "Member 'UCameraBehavior_InitialRotation::InitialCondition' has a wrong offset!");

// Class GbxCameraModes.CameraBehavior_BlendToFOV
// 0x0048 (0x0078 - 0x0030)
class UCameraBehavior_BlendToFOV : public UCameraBehavior
{
public:
	class UCurveFloat*                            FOVCurve;                                          // 0x0030(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bAddModifierToBaseFOV;                             // 0x0038(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_39[0x3];                                       // 0x0039(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         FOVModifier;                                       // 0x003C(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         MaxFOV;                                            // 0x0040(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         BlendInTime;                                       // 0x0044(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         BlendOutTime;                                      // 0x0048(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         BlendInDelay;                                      // 0x004C(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UGbxCondition*                          BlendInCondition;                                  // 0x0050(0x0008)(Edit, BlueprintVisible, ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, PersistentInstance, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bBlendOutWhenBlendInFails;                         // 0x0058(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_59[0x7];                                       // 0x0059(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	class UGbxCondition*                          BlendOutCondition;                                 // 0x0060(0x0008)(Edit, BlueprintVisible, ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, PersistentInstance, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         CurrentDelay;                                      // 0x0068(0x0004)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         MaxFOVModifier;                                    // 0x006C(0x0004)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         BlendPct;                                          // 0x0070(0x0004)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bTransitioningToTargetFoV;                         // 0x0074(0x0001)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_75[0x3];                                       // 0x0075(0x0003)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"CameraBehavior_BlendToFOV">();
	}
	static class UCameraBehavior_BlendToFOV* GetDefaultObj()
	{
		return GetDefaultObjImpl<UCameraBehavior_BlendToFOV>();
	}
};
static_assert(alignof(UCameraBehavior_BlendToFOV) == 0x000008, "Wrong alignment on UCameraBehavior_BlendToFOV");
static_assert(sizeof(UCameraBehavior_BlendToFOV) == 0x000078, "Wrong size on UCameraBehavior_BlendToFOV");
static_assert(offsetof(UCameraBehavior_BlendToFOV, FOVCurve) == 0x000030, "Member 'UCameraBehavior_BlendToFOV::FOVCurve' has a wrong offset!");
static_assert(offsetof(UCameraBehavior_BlendToFOV, bAddModifierToBaseFOV) == 0x000038, "Member 'UCameraBehavior_BlendToFOV::bAddModifierToBaseFOV' has a wrong offset!");
static_assert(offsetof(UCameraBehavior_BlendToFOV, FOVModifier) == 0x00003C, "Member 'UCameraBehavior_BlendToFOV::FOVModifier' has a wrong offset!");
static_assert(offsetof(UCameraBehavior_BlendToFOV, MaxFOV) == 0x000040, "Member 'UCameraBehavior_BlendToFOV::MaxFOV' has a wrong offset!");
static_assert(offsetof(UCameraBehavior_BlendToFOV, BlendInTime) == 0x000044, "Member 'UCameraBehavior_BlendToFOV::BlendInTime' has a wrong offset!");
static_assert(offsetof(UCameraBehavior_BlendToFOV, BlendOutTime) == 0x000048, "Member 'UCameraBehavior_BlendToFOV::BlendOutTime' has a wrong offset!");
static_assert(offsetof(UCameraBehavior_BlendToFOV, BlendInDelay) == 0x00004C, "Member 'UCameraBehavior_BlendToFOV::BlendInDelay' has a wrong offset!");
static_assert(offsetof(UCameraBehavior_BlendToFOV, BlendInCondition) == 0x000050, "Member 'UCameraBehavior_BlendToFOV::BlendInCondition' has a wrong offset!");
static_assert(offsetof(UCameraBehavior_BlendToFOV, bBlendOutWhenBlendInFails) == 0x000058, "Member 'UCameraBehavior_BlendToFOV::bBlendOutWhenBlendInFails' has a wrong offset!");
static_assert(offsetof(UCameraBehavior_BlendToFOV, BlendOutCondition) == 0x000060, "Member 'UCameraBehavior_BlendToFOV::BlendOutCondition' has a wrong offset!");
static_assert(offsetof(UCameraBehavior_BlendToFOV, CurrentDelay) == 0x000068, "Member 'UCameraBehavior_BlendToFOV::CurrentDelay' has a wrong offset!");
static_assert(offsetof(UCameraBehavior_BlendToFOV, MaxFOVModifier) == 0x00006C, "Member 'UCameraBehavior_BlendToFOV::MaxFOVModifier' has a wrong offset!");
static_assert(offsetof(UCameraBehavior_BlendToFOV, BlendPct) == 0x000070, "Member 'UCameraBehavior_BlendToFOV::BlendPct' has a wrong offset!");
static_assert(offsetof(UCameraBehavior_BlendToFOV, bTransitioningToTargetFoV) == 0x000074, "Member 'UCameraBehavior_BlendToFOV::bTransitioningToTargetFoV' has a wrong offset!");

// Class GbxCameraModes.CameraBehavior_OffsetViewModel
// 0x0040 (0x0070 - 0x0030)
class UCameraBehavior_OffsetViewModel : public UCameraBehavior
{
public:
	struct FVector                                LocationOffset;                                    // 0x0030(0x000C)(Edit, BlueprintVisible, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FRotator                               RotationOffset;                                    // 0x003C(0x000C)(Edit, BlueprintVisible, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
	struct FVector                                SplitScreenLocationOffset;                         // 0x0048(0x000C)(Edit, BlueprintVisible, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                VerticalSplitScreenLocationOffset;                 // 0x0054(0x000C)(Edit, BlueprintVisible, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                QuadSplitScreenLocationOffset;                     // 0x0060(0x000C)(Edit, BlueprintVisible, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_6C[0x4];                                       // 0x006C(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"CameraBehavior_OffsetViewModel">();
	}
	static class UCameraBehavior_OffsetViewModel* GetDefaultObj()
	{
		return GetDefaultObjImpl<UCameraBehavior_OffsetViewModel>();
	}
};
static_assert(alignof(UCameraBehavior_OffsetViewModel) == 0x000008, "Wrong alignment on UCameraBehavior_OffsetViewModel");
static_assert(sizeof(UCameraBehavior_OffsetViewModel) == 0x000070, "Wrong size on UCameraBehavior_OffsetViewModel");
static_assert(offsetof(UCameraBehavior_OffsetViewModel, LocationOffset) == 0x000030, "Member 'UCameraBehavior_OffsetViewModel::LocationOffset' has a wrong offset!");
static_assert(offsetof(UCameraBehavior_OffsetViewModel, RotationOffset) == 0x00003C, "Member 'UCameraBehavior_OffsetViewModel::RotationOffset' has a wrong offset!");
static_assert(offsetof(UCameraBehavior_OffsetViewModel, SplitScreenLocationOffset) == 0x000048, "Member 'UCameraBehavior_OffsetViewModel::SplitScreenLocationOffset' has a wrong offset!");
static_assert(offsetof(UCameraBehavior_OffsetViewModel, VerticalSplitScreenLocationOffset) == 0x000054, "Member 'UCameraBehavior_OffsetViewModel::VerticalSplitScreenLocationOffset' has a wrong offset!");
static_assert(offsetof(UCameraBehavior_OffsetViewModel, QuadSplitScreenLocationOffset) == 0x000060, "Member 'UCameraBehavior_OffsetViewModel::QuadSplitScreenLocationOffset' has a wrong offset!");

// Class GbxCameraModes.CameraBehavior_FOV
// 0x0008 (0x0038 - 0x0030)
class UCameraBehavior_FOV : public UCameraBehavior
{
public:
	float                                         FOV;                                               // 0x0030(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_34[0x4];                                       // 0x0034(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"CameraBehavior_FOV">();
	}
	static class UCameraBehavior_FOV* GetDefaultObj()
	{
		return GetDefaultObjImpl<UCameraBehavior_FOV>();
	}
};
static_assert(alignof(UCameraBehavior_FOV) == 0x000008, "Wrong alignment on UCameraBehavior_FOV");
static_assert(sizeof(UCameraBehavior_FOV) == 0x000038, "Wrong size on UCameraBehavior_FOV");
static_assert(offsetof(UCameraBehavior_FOV, FOV) == 0x000030, "Member 'UCameraBehavior_FOV::FOV' has a wrong offset!");

// Class GbxCameraModes.PlayerCameraModesManager
// 0x0040 (0x2CC0 - 0x2C80)
#pragma pack(push, 0x1)
class alignas(0x10) APlayerCameraModesManager : public AGbxPlayerCameraManager
{
public:
	uint8                                         Pad_2C80[0x18];                                    // 0x2C80(0x0018)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         ViewTargetClippingRadius;                          // 0x2C98(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2C9C[0x4];                                     // 0x2C9C(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class UCameraModesManager*                    CameraModesManager;                                // 0x2CA0(0x0008)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class AActor*                                 LastViewTarget;                                    // 0x2CA8(0x0008)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	int32                                         ViewTargetFlags;                                   // 0x2CB0(0x0004)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_2CB4[0x4];                                     // 0x2CB4(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void UpdateCameraShakeFromFeedback(struct FActiveTrackedFeedback* TrackedFeedback);
	void UpdateCameraShakeFromGbxFeedback(const struct FActiveGbxFeedbackEffect& TrackedFeedback);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"PlayerCameraModesManager">();
	}
	static class APlayerCameraModesManager* GetDefaultObj()
	{
		return GetDefaultObjImpl<APlayerCameraModesManager>();
	}
};
#pragma pack(pop)
static_assert(alignof(APlayerCameraModesManager) == 0x000010, "Wrong alignment on APlayerCameraModesManager");
static_assert(sizeof(APlayerCameraModesManager) == 0x002CC0, "Wrong size on APlayerCameraModesManager");
static_assert(offsetof(APlayerCameraModesManager, ViewTargetClippingRadius) == 0x002C98, "Member 'APlayerCameraModesManager::ViewTargetClippingRadius' has a wrong offset!");
static_assert(offsetof(APlayerCameraModesManager, CameraModesManager) == 0x002CA0, "Member 'APlayerCameraModesManager::CameraModesManager' has a wrong offset!");
static_assert(offsetof(APlayerCameraModesManager, LastViewTarget) == 0x002CA8, "Member 'APlayerCameraModesManager::LastViewTarget' has a wrong offset!");
static_assert(offsetof(APlayerCameraModesManager, ViewTargetFlags) == 0x002CB0, "Member 'APlayerCameraModesManager::ViewTargetFlags' has a wrong offset!");

// Class GbxCameraModes.CameraBehavior_AnchorToEyeLocation
// 0x0008 (0x0038 - 0x0030)
class UCameraBehavior_AnchorToEyeLocation final : public UCameraBehavior
{
public:
	uint8                                         bSetRotation : 1;                                  // 0x0030(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (Edit, BlueprintVisible, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         Pad_31[0x7];                                       // 0x0031(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"CameraBehavior_AnchorToEyeLocation">();
	}
	static class UCameraBehavior_AnchorToEyeLocation* GetDefaultObj()
	{
		return GetDefaultObjImpl<UCameraBehavior_AnchorToEyeLocation>();
	}
};
static_assert(alignof(UCameraBehavior_AnchorToEyeLocation) == 0x000008, "Wrong alignment on UCameraBehavior_AnchorToEyeLocation");
static_assert(sizeof(UCameraBehavior_AnchorToEyeLocation) == 0x000038, "Wrong size on UCameraBehavior_AnchorToEyeLocation");

// Class GbxCameraModes.CameraBehavior_AutoFollowRotation
// 0x0020 (0x0050 - 0x0030)
class UCameraBehavior_AutoFollowRotation final : public UCameraBehavior
{
public:
	uint8                                         bKeepRelativeRotation : 1;                         // 0x0030(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (Edit, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected))
	uint8                                         bRelativeToBase : 1;                               // 0x0030(0x0001)(BitIndex: 0x01, PropSize: 0x0001 (Edit, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected))
	uint8                                         bFollowPitch : 1;                                  // 0x0030(0x0001)(BitIndex: 0x02, PropSize: 0x0001 (Edit, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected))
	uint8                                         bFollowYaw : 1;                                    // 0x0030(0x0001)(BitIndex: 0x03, PropSize: 0x0001 (Edit, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected))
	uint8                                         bFollowRoll : 1;                                   // 0x0030(0x0001)(BitIndex: 0x04, PropSize: 0x0001 (Edit, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected))
	uint8                                         Pad_31[0x3];                                       // 0x0031(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         RotationRate;                                      // 0x0034(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_38[0x18];                                      // 0x0038(0x0018)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"CameraBehavior_AutoFollowRotation">();
	}
	static class UCameraBehavior_AutoFollowRotation* GetDefaultObj()
	{
		return GetDefaultObjImpl<UCameraBehavior_AutoFollowRotation>();
	}
};
static_assert(alignof(UCameraBehavior_AutoFollowRotation) == 0x000008, "Wrong alignment on UCameraBehavior_AutoFollowRotation");
static_assert(sizeof(UCameraBehavior_AutoFollowRotation) == 0x000050, "Wrong size on UCameraBehavior_AutoFollowRotation");
static_assert(offsetof(UCameraBehavior_AutoFollowRotation, RotationRate) == 0x000034, "Member 'UCameraBehavior_AutoFollowRotation::RotationRate' has a wrong offset!");

// Class GbxCameraModes.CameraBehavior_CollisionOffsetTrace
// 0x0010 (0x0040 - 0x0030)
class UCameraBehavior_CollisionOffsetTrace final : public UCameraBehavior
{
public:
	float                                         CollisionRadius;                                   // 0x0030(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         TraceOffsetZ;                                      // 0x0034(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bUseAnchorAsStartLocation;                         // 0x0038(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bIgnoreChildToViewTarget;                          // 0x0039(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bIgnoreViewTargetAttachParent;                     // 0x003A(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_3B[0x5];                                       // 0x003B(0x0005)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"CameraBehavior_CollisionOffsetTrace">();
	}
	static class UCameraBehavior_CollisionOffsetTrace* GetDefaultObj()
	{
		return GetDefaultObjImpl<UCameraBehavior_CollisionOffsetTrace>();
	}
};
static_assert(alignof(UCameraBehavior_CollisionOffsetTrace) == 0x000008, "Wrong alignment on UCameraBehavior_CollisionOffsetTrace");
static_assert(sizeof(UCameraBehavior_CollisionOffsetTrace) == 0x000040, "Wrong size on UCameraBehavior_CollisionOffsetTrace");
static_assert(offsetof(UCameraBehavior_CollisionOffsetTrace, CollisionRadius) == 0x000030, "Member 'UCameraBehavior_CollisionOffsetTrace::CollisionRadius' has a wrong offset!");
static_assert(offsetof(UCameraBehavior_CollisionOffsetTrace, TraceOffsetZ) == 0x000034, "Member 'UCameraBehavior_CollisionOffsetTrace::TraceOffsetZ' has a wrong offset!");
static_assert(offsetof(UCameraBehavior_CollisionOffsetTrace, bUseAnchorAsStartLocation) == 0x000038, "Member 'UCameraBehavior_CollisionOffsetTrace::bUseAnchorAsStartLocation' has a wrong offset!");
static_assert(offsetof(UCameraBehavior_CollisionOffsetTrace, bIgnoreChildToViewTarget) == 0x000039, "Member 'UCameraBehavior_CollisionOffsetTrace::bIgnoreChildToViewTarget' has a wrong offset!");
static_assert(offsetof(UCameraBehavior_CollisionOffsetTrace, bIgnoreViewTargetAttachParent) == 0x00003A, "Member 'UCameraBehavior_CollisionOffsetTrace::bIgnoreViewTargetAttachParent' has a wrong offset!");

// Class GbxCameraModes.CameraBehavior_DefaultFOV
// 0x0018 (0x0048 - 0x0030)
class UCameraBehavior_DefaultFOV final : public UCameraBehavior
{
public:
	float                                         Scale;                                             // 0x0030(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         ScaleSplitScreenHorizontal;                        // 0x0034(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         ScaleSplitScreenVertical;                          // 0x0038(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         ScaleSplitScreenQuad;                              // 0x003C(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         MaxFOV;                                            // 0x0040(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_44[0x4];                                       // 0x0044(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"CameraBehavior_DefaultFOV">();
	}
	static class UCameraBehavior_DefaultFOV* GetDefaultObj()
	{
		return GetDefaultObjImpl<UCameraBehavior_DefaultFOV>();
	}
};
static_assert(alignof(UCameraBehavior_DefaultFOV) == 0x000008, "Wrong alignment on UCameraBehavior_DefaultFOV");
static_assert(sizeof(UCameraBehavior_DefaultFOV) == 0x000048, "Wrong size on UCameraBehavior_DefaultFOV");
static_assert(offsetof(UCameraBehavior_DefaultFOV, Scale) == 0x000030, "Member 'UCameraBehavior_DefaultFOV::Scale' has a wrong offset!");
static_assert(offsetof(UCameraBehavior_DefaultFOV, ScaleSplitScreenHorizontal) == 0x000034, "Member 'UCameraBehavior_DefaultFOV::ScaleSplitScreenHorizontal' has a wrong offset!");
static_assert(offsetof(UCameraBehavior_DefaultFOV, ScaleSplitScreenVertical) == 0x000038, "Member 'UCameraBehavior_DefaultFOV::ScaleSplitScreenVertical' has a wrong offset!");
static_assert(offsetof(UCameraBehavior_DefaultFOV, ScaleSplitScreenQuad) == 0x00003C, "Member 'UCameraBehavior_DefaultFOV::ScaleSplitScreenQuad' has a wrong offset!");
static_assert(offsetof(UCameraBehavior_DefaultFOV, MaxFOV) == 0x000040, "Member 'UCameraBehavior_DefaultFOV::MaxFOV' has a wrong offset!");

// Class GbxCameraModes.CameraBehavior_FromAnimation
// 0x0010 (0x0040 - 0x0030)
class UCameraBehavior_FromAnimation final : public UCameraBehavior
{
public:
	uint8                                         bSetLocation : 1;                                  // 0x0030(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (Edit, BlueprintVisible, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         bSetRotation : 1;                                  // 0x0030(0x0001)(BitIndex: 0x01, PropSize: 0x0001 (Edit, BlueprintVisible, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         Pad_31[0x7];                                       // 0x0031(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	class FName                                   SocketName;                                        // 0x0038(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"CameraBehavior_FromAnimation">();
	}
	static class UCameraBehavior_FromAnimation* GetDefaultObj()
	{
		return GetDefaultObjImpl<UCameraBehavior_FromAnimation>();
	}
};
static_assert(alignof(UCameraBehavior_FromAnimation) == 0x000008, "Wrong alignment on UCameraBehavior_FromAnimation");
static_assert(sizeof(UCameraBehavior_FromAnimation) == 0x000040, "Wrong size on UCameraBehavior_FromAnimation");
static_assert(offsetof(UCameraBehavior_FromAnimation, SocketName) == 0x000038, "Member 'UCameraBehavior_FromAnimation::SocketName' has a wrong offset!");

// Class GbxCameraModes.CameraBehavior_LimitLook
// 0x0020 (0x0050 - 0x0030)
class UCameraBehavior_LimitLook final : public UCameraBehavior
{
public:
	struct FRotator                               Min;                                               // 0x0030(0x000C)(Edit, BlueprintVisible, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
	struct FRotator                               Max;                                               // 0x003C(0x000C)(Edit, BlueprintVisible, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
	uint8                                         bYawRelativeToBase : 1;                            // 0x0048(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (Edit, BlueprintVisible, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         bPitchRelativeToBase : 1;                          // 0x0048(0x0001)(BitIndex: 0x01, PropSize: 0x0001 (Edit, BlueprintVisible, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         bRollRelativeToBase : 1;                           // 0x0048(0x0001)(BitIndex: 0x02, PropSize: 0x0001 (Edit, BlueprintVisible, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         bSnapOnStart : 1;                                  // 0x0048(0x0001)(BitIndex: 0x03, PropSize: 0x0001 (Edit, BlueprintVisible, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         Pad_49[0x7];                                       // 0x0049(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"CameraBehavior_LimitLook">();
	}
	static class UCameraBehavior_LimitLook* GetDefaultObj()
	{
		return GetDefaultObjImpl<UCameraBehavior_LimitLook>();
	}
};
static_assert(alignof(UCameraBehavior_LimitLook) == 0x000008, "Wrong alignment on UCameraBehavior_LimitLook");
static_assert(sizeof(UCameraBehavior_LimitLook) == 0x000050, "Wrong size on UCameraBehavior_LimitLook");
static_assert(offsetof(UCameraBehavior_LimitLook, Min) == 0x000030, "Member 'UCameraBehavior_LimitLook::Min' has a wrong offset!");
static_assert(offsetof(UCameraBehavior_LimitLook, Max) == 0x00003C, "Member 'UCameraBehavior_LimitLook::Max' has a wrong offset!");

// Class GbxCameraModes.CameraBehavior_LimitPitch
// 0x0010 (0x0040 - 0x0030)
class UCameraBehavior_LimitPitch final : public UCameraBehavior
{
public:
	float                                         MinPitch;                                          // 0x0030(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         MaxPitch;                                          // 0x0034(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bUseInitialPitch;                                  // 0x0038(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_39[0x3];                                       // 0x0039(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         InitialPitch;                                      // 0x003C(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"CameraBehavior_LimitPitch">();
	}
	static class UCameraBehavior_LimitPitch* GetDefaultObj()
	{
		return GetDefaultObjImpl<UCameraBehavior_LimitPitch>();
	}
};
static_assert(alignof(UCameraBehavior_LimitPitch) == 0x000008, "Wrong alignment on UCameraBehavior_LimitPitch");
static_assert(sizeof(UCameraBehavior_LimitPitch) == 0x000040, "Wrong size on UCameraBehavior_LimitPitch");
static_assert(offsetof(UCameraBehavior_LimitPitch, MinPitch) == 0x000030, "Member 'UCameraBehavior_LimitPitch::MinPitch' has a wrong offset!");
static_assert(offsetof(UCameraBehavior_LimitPitch, MaxPitch) == 0x000034, "Member 'UCameraBehavior_LimitPitch::MaxPitch' has a wrong offset!");
static_assert(offsetof(UCameraBehavior_LimitPitch, bUseInitialPitch) == 0x000038, "Member 'UCameraBehavior_LimitPitch::bUseInitialPitch' has a wrong offset!");
static_assert(offsetof(UCameraBehavior_LimitPitch, InitialPitch) == 0x00003C, "Member 'UCameraBehavior_LimitPitch::InitialPitch' has a wrong offset!");

// Class GbxCameraModes.CameraBehavior_OffsetAbsolute
// 0x0010 (0x0040 - 0x0030)
class UCameraBehavior_OffsetAbsolute final : public UCameraBehavior
{
public:
	struct FVector                                LocationOffset;                                    // 0x0030(0x000C)(Edit, BlueprintVisible, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_3C[0x4];                                       // 0x003C(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"CameraBehavior_OffsetAbsolute">();
	}
	static class UCameraBehavior_OffsetAbsolute* GetDefaultObj()
	{
		return GetDefaultObjImpl<UCameraBehavior_OffsetAbsolute>();
	}
};
static_assert(alignof(UCameraBehavior_OffsetAbsolute) == 0x000008, "Wrong alignment on UCameraBehavior_OffsetAbsolute");
static_assert(sizeof(UCameraBehavior_OffsetAbsolute) == 0x000040, "Wrong size on UCameraBehavior_OffsetAbsolute");
static_assert(offsetof(UCameraBehavior_OffsetAbsolute, LocationOffset) == 0x000030, "Member 'UCameraBehavior_OffsetAbsolute::LocationOffset' has a wrong offset!");

// Class GbxCameraModes.CameraBehavior_OffsetCameraRelative
// 0x0018 (0x0048 - 0x0030)
class UCameraBehavior_OffsetCameraRelative final : public UCameraBehavior
{
public:
	struct FVector                                LocationOffset;                                    // 0x0030(0x000C)(Edit, BlueprintVisible, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FRotator                               RotationOffset;                                    // 0x003C(0x000C)(Edit, BlueprintVisible, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"CameraBehavior_OffsetCameraRelative">();
	}
	static class UCameraBehavior_OffsetCameraRelative* GetDefaultObj()
	{
		return GetDefaultObjImpl<UCameraBehavior_OffsetCameraRelative>();
	}
};
static_assert(alignof(UCameraBehavior_OffsetCameraRelative) == 0x000008, "Wrong alignment on UCameraBehavior_OffsetCameraRelative");
static_assert(sizeof(UCameraBehavior_OffsetCameraRelative) == 0x000048, "Wrong size on UCameraBehavior_OffsetCameraRelative");
static_assert(offsetof(UCameraBehavior_OffsetCameraRelative, LocationOffset) == 0x000030, "Member 'UCameraBehavior_OffsetCameraRelative::LocationOffset' has a wrong offset!");
static_assert(offsetof(UCameraBehavior_OffsetCameraRelative, RotationOffset) == 0x00003C, "Member 'UCameraBehavior_OffsetCameraRelative::RotationOffset' has a wrong offset!");

// Class GbxCameraModes.CameraBehavior_OffsetCameraRelativeFromInputs
// 0x0070 (0x00A0 - 0x0030)
class UCameraBehavior_OffsetCameraRelativeFromInputs final : public UCameraBehavior
{
public:
	bool                                          bHackForDayOnePatch;                               // 0x0030(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_31[0x3];                                       // 0x0031(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         LimitPitch;                                        // 0x0034(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         CollisionRadius;                                   // 0x0038(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         MoveSpeed;                                         // 0x003C(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FBox                                   MoveLimit;                                         // 0x0040(0x001C)(Edit, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
	uint8                                         Pad_5C[0x44];                                      // 0x005C(0x0044)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"CameraBehavior_OffsetCameraRelativeFromInputs">();
	}
	static class UCameraBehavior_OffsetCameraRelativeFromInputs* GetDefaultObj()
	{
		return GetDefaultObjImpl<UCameraBehavior_OffsetCameraRelativeFromInputs>();
	}
};
static_assert(alignof(UCameraBehavior_OffsetCameraRelativeFromInputs) == 0x000008, "Wrong alignment on UCameraBehavior_OffsetCameraRelativeFromInputs");
static_assert(sizeof(UCameraBehavior_OffsetCameraRelativeFromInputs) == 0x0000A0, "Wrong size on UCameraBehavior_OffsetCameraRelativeFromInputs");
static_assert(offsetof(UCameraBehavior_OffsetCameraRelativeFromInputs, bHackForDayOnePatch) == 0x000030, "Member 'UCameraBehavior_OffsetCameraRelativeFromInputs::bHackForDayOnePatch' has a wrong offset!");
static_assert(offsetof(UCameraBehavior_OffsetCameraRelativeFromInputs, LimitPitch) == 0x000034, "Member 'UCameraBehavior_OffsetCameraRelativeFromInputs::LimitPitch' has a wrong offset!");
static_assert(offsetof(UCameraBehavior_OffsetCameraRelativeFromInputs, CollisionRadius) == 0x000038, "Member 'UCameraBehavior_OffsetCameraRelativeFromInputs::CollisionRadius' has a wrong offset!");
static_assert(offsetof(UCameraBehavior_OffsetCameraRelativeFromInputs, MoveSpeed) == 0x00003C, "Member 'UCameraBehavior_OffsetCameraRelativeFromInputs::MoveSpeed' has a wrong offset!");
static_assert(offsetof(UCameraBehavior_OffsetCameraRelativeFromInputs, MoveLimit) == 0x000040, "Member 'UCameraBehavior_OffsetCameraRelativeFromInputs::MoveLimit' has a wrong offset!");

// Class GbxCameraModes.CameraBehavior_RestoreControllerRotation
// 0x0000 (0x0030 - 0x0030)
class UCameraBehavior_RestoreControllerRotation final : public UCameraBehavior
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"CameraBehavior_RestoreControllerRotation">();
	}
	static class UCameraBehavior_RestoreControllerRotation* GetDefaultObj()
	{
		return GetDefaultObjImpl<UCameraBehavior_RestoreControllerRotation>();
	}
};
static_assert(alignof(UCameraBehavior_RestoreControllerRotation) == 0x000008, "Wrong alignment on UCameraBehavior_RestoreControllerRotation");
static_assert(sizeof(UCameraBehavior_RestoreControllerRotation) == 0x000030, "Wrong size on UCameraBehavior_RestoreControllerRotation");

// Class GbxCameraModes.CameraBehavior_RestoreStartRotation
// 0x0010 (0x0040 - 0x0030)
class UCameraBehavior_RestoreStartRotation final : public UCameraBehavior
{
public:
	struct FRotator                               Rotation;                                          // 0x0030(0x000C)(Edit, BlueprintVisible, IsPlainOldData, NoDestructor, Protected, NativeAccessSpecifierProtected)
	uint8                                         Pad_3C[0x4];                                       // 0x003C(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"CameraBehavior_RestoreStartRotation">();
	}
	static class UCameraBehavior_RestoreStartRotation* GetDefaultObj()
	{
		return GetDefaultObjImpl<UCameraBehavior_RestoreStartRotation>();
	}
};
static_assert(alignof(UCameraBehavior_RestoreStartRotation) == 0x000008, "Wrong alignment on UCameraBehavior_RestoreStartRotation");
static_assert(sizeof(UCameraBehavior_RestoreStartRotation) == 0x000040, "Wrong size on UCameraBehavior_RestoreStartRotation");
static_assert(offsetof(UCameraBehavior_RestoreStartRotation, Rotation) == 0x000030, "Member 'UCameraBehavior_RestoreStartRotation::Rotation' has a wrong offset!");

// Class GbxCameraModes.CameraMode
// 0x0060 (0x0088 - 0x0028)
class UCameraMode final : public UObject
{
public:
	class UCameraModeData*                        Data;                                              // 0x0028(0x0008)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TArray<class UCameraBehavior*>                Behaviors;                                         // 0x0030(0x0010)(ZeroConstructor, Transient, Protected, NativeAccessSpecifierProtected)
	uint8                                         Pad_40[0x48];                                      // 0x0040(0x0048)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"CameraMode">();
	}
	static class UCameraMode* GetDefaultObj()
	{
		return GetDefaultObjImpl<UCameraMode>();
	}
};
static_assert(alignof(UCameraMode) == 0x000008, "Wrong alignment on UCameraMode");
static_assert(sizeof(UCameraMode) == 0x000088, "Wrong size on UCameraMode");
static_assert(offsetof(UCameraMode, Data) == 0x000028, "Member 'UCameraMode::Data' has a wrong offset!");
static_assert(offsetof(UCameraMode, Behaviors) == 0x000030, "Member 'UCameraMode::Behaviors' has a wrong offset!");

// Class GbxCameraModes.CameraModeData
// 0x0030 (0x0060 - 0x0030)
class UCameraModeData final : public UGbxDataAsset
{
public:
	class FName                                   ModeName;                                          // 0x0030(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         BlendInTime;                                       // 0x0038(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         bBlendOut : 1;                                     // 0x003C(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (Edit, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         bIsFirstPerson : 1;                                // 0x003C(0x0001)(BitIndex: 0x01, PropSize: 0x0001 (Edit, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         bShowViewModel : 1;                                // 0x003C(0x0001)(BitIndex: 0x02, PropSize: 0x0001 (Edit, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         bAllowPitchInversion : 1;                          // 0x003C(0x0001)(BitIndex: 0x03, PropSize: 0x0001 (Edit, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         bAutoPerspectiveOverride : 1;                      // 0x003C(0x0001)(BitIndex: 0x04, PropSize: 0x0001 (Edit, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         bResetCameraRollOnStart : 1;                       // 0x003C(0x0001)(BitIndex: 0x05, PropSize: 0x0001 (Edit, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         bAllowIntentionalClipping : 1;                     // 0x003C(0x0001)(BitIndex: 0x06, PropSize: 0x0001 (Edit, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         bInterruptTransitionWhenClipping : 1;              // 0x003C(0x0001)(BitIndex: 0x07, PropSize: 0x0001 (Edit, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         bIncludeInDebugRotation : 1;                       // 0x003D(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (Edit, DuplicateTransient, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         Pad_3E[0x2];                                       // 0x003E(0x0002)(Fixing Size After Last Property [ Dumper-7 ])
	EViewTargetRotationUpdateMethod               ViewTargetRotationUpdateMethod;                    // 0x0040(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	ECameraModeTransitionBlendType                FirstPersonBlendType;                              // 0x0044(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	ECameraModeTransitionBlendType                ThirdPersonBlendType;                              // 0x0045(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_46[0x2];                                       // 0x0046(0x0002)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<class UCameraBehavior*>                Behaviors;                                         // 0x0048(0x0010)(Edit, ExportObject, ZeroConstructor, ContainsInstancedReference, NativeAccessSpecifierPublic)
	uint8                                         bDisableSeparateTranslucency : 1;                  // 0x0058(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (Edit, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         Pad_59[0x7];                                       // 0x0059(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"CameraModeData">();
	}
	static class UCameraModeData* GetDefaultObj()
	{
		return GetDefaultObjImpl<UCameraModeData>();
	}
};
static_assert(alignof(UCameraModeData) == 0x000008, "Wrong alignment on UCameraModeData");
static_assert(sizeof(UCameraModeData) == 0x000060, "Wrong size on UCameraModeData");
static_assert(offsetof(UCameraModeData, ModeName) == 0x000030, "Member 'UCameraModeData::ModeName' has a wrong offset!");
static_assert(offsetof(UCameraModeData, BlendInTime) == 0x000038, "Member 'UCameraModeData::BlendInTime' has a wrong offset!");
static_assert(offsetof(UCameraModeData, ViewTargetRotationUpdateMethod) == 0x000040, "Member 'UCameraModeData::ViewTargetRotationUpdateMethod' has a wrong offset!");
static_assert(offsetof(UCameraModeData, FirstPersonBlendType) == 0x000044, "Member 'UCameraModeData::FirstPersonBlendType' has a wrong offset!");
static_assert(offsetof(UCameraModeData, ThirdPersonBlendType) == 0x000045, "Member 'UCameraModeData::ThirdPersonBlendType' has a wrong offset!");
static_assert(offsetof(UCameraModeData, Behaviors) == 0x000048, "Member 'UCameraModeData::Behaviors' has a wrong offset!");

// Class GbxCameraModes.CameraModeSet
// 0x0018 (0x0040 - 0x0028)
class UCameraModeSet final : public UObject
{
public:
	class UCameraModeSetData*                     Data;                                              // 0x0028(0x0008)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TArray<class UCameraMode*>                    Modes;                                             // 0x0030(0x0010)(ZeroConstructor, Transient, Protected, NativeAccessSpecifierProtected)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"CameraModeSet">();
	}
	static class UCameraModeSet* GetDefaultObj()
	{
		return GetDefaultObjImpl<UCameraModeSet>();
	}
};
static_assert(alignof(UCameraModeSet) == 0x000008, "Wrong alignment on UCameraModeSet");
static_assert(sizeof(UCameraModeSet) == 0x000040, "Wrong size on UCameraModeSet");
static_assert(offsetof(UCameraModeSet, Data) == 0x000028, "Member 'UCameraModeSet::Data' has a wrong offset!");
static_assert(offsetof(UCameraModeSet, Modes) == 0x000030, "Member 'UCameraModeSet::Modes' has a wrong offset!");

// Class GbxCameraModes.CameraModeSetData
// 0x0010 (0x0040 - 0x0030)
class UCameraModeSetData final : public UGbxDataAsset
{
public:
	TArray<class UCameraModeData*>                Modes;                                             // 0x0030(0x0010)(Edit, ZeroConstructor, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"CameraModeSetData">();
	}
	static class UCameraModeSetData* GetDefaultObj()
	{
		return GetDefaultObjImpl<UCameraModeSetData>();
	}
};
static_assert(alignof(UCameraModeSetData) == 0x000008, "Wrong alignment on UCameraModeSetData");
static_assert(sizeof(UCameraModeSetData) == 0x000040, "Wrong size on UCameraModeSetData");
static_assert(offsetof(UCameraModeSetData, Modes) == 0x000030, "Member 'UCameraModeSetData::Modes' has a wrong offset!");

// Class GbxCameraModes.CameraModesFunctionLibrary
// 0x0000 (0x0028 - 0x0028)
class UCameraModesFunctionLibrary final : public UBlueprintFunctionLibrary
{
public:
	static void AddCameraModeSet(class APlayerController* Controller, class UCameraModeSetData* ModeSet);
	static void ApplyCameraRotation(class APlayerController* Controller, const struct FRotator& DeltaRotation);
	static void PopCameraMode(class APlayerController* Controller, class FName ModeName, float BlendTimeOverride, bool bTeleport);
	static void PushCameraMode(class APlayerController* Controller, class FName ModeName, float BlendTimeOverride, bool bTeleport);
	static void RemoveCameraModeSet(class APlayerController* Controller, class UCameraModeSetData* ModeSet);
	static void ResetCameraRotation(class APlayerController* Controller, const struct FRotator& NewRotation);
	static void SetCameraMode(class APlayerController* Controller, class FName ModeName, float BlendTimeOverride, bool bTeleport, bool bForceResetMode);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"CameraModesFunctionLibrary">();
	}
	static class UCameraModesFunctionLibrary* GetDefaultObj()
	{
		return GetDefaultObjImpl<UCameraModesFunctionLibrary>();
	}
};
static_assert(alignof(UCameraModesFunctionLibrary) == 0x000008, "Wrong alignment on UCameraModesFunctionLibrary");
static_assert(sizeof(UCameraModesFunctionLibrary) == 0x000028, "Wrong size on UCameraModesFunctionLibrary");

// Class GbxCameraModes.CameraModesManager
// 0x0130 (0x0158 - 0x0028)
class UCameraModesManager final : public UObject
{
public:
	bool                                          bIsClient;                                         // 0x0028(0x0001)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bIsRemote;                                         // 0x0029(0x0001)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2A[0x36];                                      // 0x002A(0x0036)(Fixing Size After Last Property [ Dumper-7 ])
	struct FReplicatedCameraModeState             ReplicatedModeState;                               // 0x0060(0x0010)(Transient, NoDestructor, Protected, NativeAccessSpecifierProtected)
	bool                                          bRemoteIsFirstPerson;                              // 0x0070(0x0001)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_71[0x7];                                       // 0x0071(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<class FName>                           ModeNameStack;                                     // 0x0078(0x0010)(ZeroConstructor, Transient, Protected, NativeAccessSpecifierProtected)
	class UCameraMode*                            CurrentMode;                                       // 0x0088(0x0008)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TArray<class UCameraModeSet*>                 ModeSets;                                          // 0x0090(0x0010)(ZeroConstructor, Transient, Protected, NativeAccessSpecifierProtected)
	class UCameraInputs*                          Inputs;                                            // 0x00A0(0x0008)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UCameraState*                           State;                                             // 0x00A8(0x0008)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_B0[0x78];                                      // 0x00B0(0x0078)(Fixing Size After Last Property [ Dumper-7 ])
	struct FSoftClassPath                         CameraStateClassName;                              // 0x0128(0x0018)(Config, GlobalConfig, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	struct FSoftClassPath                         CameraInputsClassName;                             // 0x0140(0x0018)(Config, GlobalConfig, HasGetValueTypeHash, NativeAccessSpecifierPrivate)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"CameraModesManager">();
	}
	static class UCameraModesManager* GetDefaultObj()
	{
		return GetDefaultObjImpl<UCameraModesManager>();
	}
};
static_assert(alignof(UCameraModesManager) == 0x000008, "Wrong alignment on UCameraModesManager");
static_assert(sizeof(UCameraModesManager) == 0x000158, "Wrong size on UCameraModesManager");
static_assert(offsetof(UCameraModesManager, bIsClient) == 0x000028, "Member 'UCameraModesManager::bIsClient' has a wrong offset!");
static_assert(offsetof(UCameraModesManager, bIsRemote) == 0x000029, "Member 'UCameraModesManager::bIsRemote' has a wrong offset!");
static_assert(offsetof(UCameraModesManager, ReplicatedModeState) == 0x000060, "Member 'UCameraModesManager::ReplicatedModeState' has a wrong offset!");
static_assert(offsetof(UCameraModesManager, bRemoteIsFirstPerson) == 0x000070, "Member 'UCameraModesManager::bRemoteIsFirstPerson' has a wrong offset!");
static_assert(offsetof(UCameraModesManager, ModeNameStack) == 0x000078, "Member 'UCameraModesManager::ModeNameStack' has a wrong offset!");
static_assert(offsetof(UCameraModesManager, CurrentMode) == 0x000088, "Member 'UCameraModesManager::CurrentMode' has a wrong offset!");
static_assert(offsetof(UCameraModesManager, ModeSets) == 0x000090, "Member 'UCameraModesManager::ModeSets' has a wrong offset!");
static_assert(offsetof(UCameraModesManager, Inputs) == 0x0000A0, "Member 'UCameraModesManager::Inputs' has a wrong offset!");
static_assert(offsetof(UCameraModesManager, State) == 0x0000A8, "Member 'UCameraModesManager::State' has a wrong offset!");
static_assert(offsetof(UCameraModesManager, CameraStateClassName) == 0x000128, "Member 'UCameraModesManager::CameraStateClassName' has a wrong offset!");
static_assert(offsetof(UCameraModesManager, CameraInputsClassName) == 0x000140, "Member 'UCameraModesManager::CameraInputsClassName' has a wrong offset!");

// Class GbxCameraModes.CameraState
// 0x06D8 (0x0700 - 0x0028)
class UCameraState final : public UObject
{
public:
	class UCameraInputs*                          Inputs;                                            // 0x0028(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FPOV                                   POV;                                               // 0x0030(0x001C)(BlueprintVisible, Transient, NoDestructor, NativeAccessSpecifierPublic)
	float                                         DefaultFOV;                                        // 0x004C(0x0004)(BlueprintVisible, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                AbsoluteLocationOffset;                            // 0x0050(0x000C)(BlueprintVisible, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                BaseLocationOffset;                                // 0x005C(0x000C)(BlueprintVisible, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FRotator                               BaseRotationOffset;                                // 0x0068(0x000C)(BlueprintVisible, Transient, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
	float                                         BaseFOVOffset;                                     // 0x0074(0x0004)(BlueprintVisible, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                CameraLocationOffset;                              // 0x0078(0x000C)(BlueprintVisible, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FRotator                               CameraRotationOffset;                              // 0x0084(0x000C)(BlueprintVisible, Transient, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
	struct FVector                                ViewModelLocationOffset;                           // 0x0090(0x000C)(BlueprintVisible, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FRotator                               ViewModelRotationOffset;                           // 0x009C(0x000C)(BlueprintVisible, Transient, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
	float                                         ViewModelFOV;                                      // 0x00A8(0x0004)(BlueprintVisible, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         DefaultViewModelFOV;                               // 0x00AC(0x0004)(BlueprintVisible, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         AspectRatio;                                       // 0x00B0(0x0004)(BlueprintVisible, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         bConstrainAspectRatio : 1;                         // 0x00B4(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (BlueprintVisible, Transient, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         bIsTransitioning : 1;                              // 0x00B4(0x0001)(BitIndex: 0x01, PropSize: 0x0001 (BlueprintVisible, BlueprintReadOnly, Transient, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         bIsColliding : 1;                                  // 0x00B4(0x0001)(BitIndex: 0x02, PropSize: 0x0001 (BlueprintVisible, BlueprintReadOnly, Transient, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         bShowViewModel : 1;                                // 0x00B4(0x0001)(BitIndex: 0x03, PropSize: 0x0001 (BlueprintVisible, BlueprintReadOnly, Transient, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         bDisableSeparateTranslucency : 1;                  // 0x00B4(0x0001)(BitIndex: 0x04, PropSize: 0x0001 (BlueprintVisible, Transient, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         BitPad_B4_5 : 1;                                   // 0x00B4(0x0001)(Fixing Bit-Field Size Between Bits [ Dumper-7 ])
	uint8                                         bUpdatingInitialPitchRotation : 1;                 // 0x00B4(0x0001)(BitIndex: 0x06, PropSize: 0x0001 (BlueprintVisible, BlueprintReadOnly, Transient, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         bUpdatingInitialYawRotation : 1;                   // 0x00B4(0x0001)(BitIndex: 0x07, PropSize: 0x0001 (BlueprintVisible, BlueprintReadOnly, Transient, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         Pad_B5[0x3];                                       // 0x00B5(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	struct FRotator                               ClampedLookRotationRemainder;                      // 0x00B8(0x000C)(BlueprintVisible, BlueprintReadOnly, Transient, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
	uint8                                         Pad_C4[0x4];                                       // 0x00C4(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<struct FCameraStatePostProcessBlend>   PostProcessBlends;                                 // 0x00C8(0x0010)(ZeroConstructor, Transient, NativeAccessSpecifierPublic)
	float                                         FocusDistance;                                     // 0x00D8(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_DC[0x624];                                     // 0x00DC(0x0624)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void AddPostProcessBlend(const struct FPostProcessSettings& Settings, float BlendWeight);
	bool CameraTrace(const struct FVector& Start, const struct FVector& End, float Radius, ECollisionChannel TraceChannel, uint8 IgnoreMask, struct FHitResult* OutHit);
	void SetBaseFOV(float NewFOV, bool bDefault);
	void SetBaseLocation(const struct FVector& NewLocation);
	void SetBaseRotation(const struct FRotator& NewRotation);
	void SetViewModelFOV(float NewFOV, bool bDefault);

	float GetBaseFOV() const;
	const struct FVector GetBaseLocation() const;
	const struct FRotator GetBaseRotation() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"CameraState">();
	}
	static class UCameraState* GetDefaultObj()
	{
		return GetDefaultObjImpl<UCameraState>();
	}
};
static_assert(alignof(UCameraState) == 0x000008, "Wrong alignment on UCameraState");
static_assert(sizeof(UCameraState) == 0x000700, "Wrong size on UCameraState");
static_assert(offsetof(UCameraState, Inputs) == 0x000028, "Member 'UCameraState::Inputs' has a wrong offset!");
static_assert(offsetof(UCameraState, POV) == 0x000030, "Member 'UCameraState::POV' has a wrong offset!");
static_assert(offsetof(UCameraState, DefaultFOV) == 0x00004C, "Member 'UCameraState::DefaultFOV' has a wrong offset!");
static_assert(offsetof(UCameraState, AbsoluteLocationOffset) == 0x000050, "Member 'UCameraState::AbsoluteLocationOffset' has a wrong offset!");
static_assert(offsetof(UCameraState, BaseLocationOffset) == 0x00005C, "Member 'UCameraState::BaseLocationOffset' has a wrong offset!");
static_assert(offsetof(UCameraState, BaseRotationOffset) == 0x000068, "Member 'UCameraState::BaseRotationOffset' has a wrong offset!");
static_assert(offsetof(UCameraState, BaseFOVOffset) == 0x000074, "Member 'UCameraState::BaseFOVOffset' has a wrong offset!");
static_assert(offsetof(UCameraState, CameraLocationOffset) == 0x000078, "Member 'UCameraState::CameraLocationOffset' has a wrong offset!");
static_assert(offsetof(UCameraState, CameraRotationOffset) == 0x000084, "Member 'UCameraState::CameraRotationOffset' has a wrong offset!");
static_assert(offsetof(UCameraState, ViewModelLocationOffset) == 0x000090, "Member 'UCameraState::ViewModelLocationOffset' has a wrong offset!");
static_assert(offsetof(UCameraState, ViewModelRotationOffset) == 0x00009C, "Member 'UCameraState::ViewModelRotationOffset' has a wrong offset!");
static_assert(offsetof(UCameraState, ViewModelFOV) == 0x0000A8, "Member 'UCameraState::ViewModelFOV' has a wrong offset!");
static_assert(offsetof(UCameraState, DefaultViewModelFOV) == 0x0000AC, "Member 'UCameraState::DefaultViewModelFOV' has a wrong offset!");
static_assert(offsetof(UCameraState, AspectRatio) == 0x0000B0, "Member 'UCameraState::AspectRatio' has a wrong offset!");
static_assert(offsetof(UCameraState, ClampedLookRotationRemainder) == 0x0000B8, "Member 'UCameraState::ClampedLookRotationRemainder' has a wrong offset!");
static_assert(offsetof(UCameraState, PostProcessBlends) == 0x0000C8, "Member 'UCameraState::PostProcessBlends' has a wrong offset!");
static_assert(offsetof(UCameraState, FocusDistance) == 0x0000D8, "Member 'UCameraState::FocusDistance' has a wrong offset!");

// Class GbxCameraModes.CameraViewTargetInterface
// 0x0000 (0x0028 - 0x0028)
class ICameraViewTargetInterface final : public IInterface
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"CameraViewTargetInterface">();
	}
	static class ICameraViewTargetInterface* GetDefaultObj()
	{
		return GetDefaultObjImpl<ICameraViewTargetInterface>();
	}
};
static_assert(alignof(ICameraViewTargetInterface) == 0x000008, "Wrong alignment on ICameraViewTargetInterface");
static_assert(sizeof(ICameraViewTargetInterface) == 0x000028, "Wrong size on ICameraViewTargetInterface");

}

