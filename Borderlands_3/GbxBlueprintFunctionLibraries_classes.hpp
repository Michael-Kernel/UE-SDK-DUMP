#pragma once

/*
* SDK generated by Dumper-7
*
* https://github.com/Encryqed/Dumper-7
*/

// Package: GbxBlueprintFunctionLibraries

#include "Basic.hpp"

#include "Engine_classes.hpp"
#include "GbxBlueprintFunctionLibraries_structs.hpp"


namespace SDK
{

// Class GbxBlueprintFunctionLibraries.GbxBlueprintFunctionLibrariesBPLibrary
// 0x0000 (0x0028 - 0x0028)
class UGbxBlueprintFunctionLibrariesBPLibrary final : public UBlueprintFunctionLibrary
{
public:
	static void BroadcastRemoteEvent(class UObject* WorldContextObject, class FName EventName);
	static class UObject* EditorLoadAsset(const TSoftObjectPtr<class UObject>& Asset);
	static void FindClosestActor(const TArray<int32>& ActorArray, const struct FVector& RefLocation, int32* ClosestActor);
	static class ACharacter* FindClosestPlayerCharacter(class UObject* WorldContextObject, const struct FVector& RefLocation);
	static float FloatDamp(float Current, float Target, float& CurrentVelocity, float SmoothDuration, float MaxSpeed, float DeltaTime);
	static float GbxBlueprintFunctionLibrariesSampleFunction(float Param);
	static bool IsInEditorMode();
	static bool IsWithinRangeAndAngle(const struct FTransform& Source, class AActor* Target, float Range, float Angle);
	static float PerlinNoise1D(float X, int32 Octaves, float Persistence, float Amplitude);
	static float PerlinNoise2D(const struct FVector2D& Location, int32 Octaves, float Persistence, float Amplitude);
	static void SetForceMipLevelsToBeResidentForMaterialArray(const TArray<class UMaterialInterface*>& MaterialArray, bool OverrideForceMiplevelsToBeResident, bool bForceMiplevelsToBeResidentValue, float ForceDuration, int32 CinematicTextureGroups);
	static float SimplexNoise1D(float Location);
	static float SimplexNoise2D(const struct FVector2D& Location);
	static float SimplexNoise3D(const struct FVector& Location);
	static float SimplexNoise4D(const struct FVector4& Location);
	static void SortActorListByDistance(class AActor* TargetActor, TArray<class AActor*>& ActorList);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"GbxBlueprintFunctionLibrariesBPLibrary">();
	}
	static class UGbxBlueprintFunctionLibrariesBPLibrary* GetDefaultObj()
	{
		return GetDefaultObjImpl<UGbxBlueprintFunctionLibrariesBPLibrary>();
	}
};
static_assert(alignof(UGbxBlueprintFunctionLibrariesBPLibrary) == 0x000008, "Wrong alignment on UGbxBlueprintFunctionLibrariesBPLibrary");
static_assert(sizeof(UGbxBlueprintFunctionLibrariesBPLibrary) == 0x000028, "Wrong size on UGbxBlueprintFunctionLibrariesBPLibrary");

// Class GbxBlueprintFunctionLibraries.HitResultFunctionLibrary
// 0x0000 (0x0028 - 0x0028)
class UHitResultFunctionLibrary final : public UBlueprintFunctionLibrary
{
public:
	static class FName GetBoneName(const struct FHitResult& HitResult);
	static class AActor* GetHitActor(const struct FHitResult& HitResult);
	static class UPrimitiveComponent* GetHitComponent(const struct FHitResult& HitResult);
	static float GetHitDistance(const struct FHitResult& HitResult);
	static struct FVector GetHitLocation(const struct FHitResult& HitResult);
	static struct FVector GetHitNormal(const struct FHitResult& HitResult);
	static class UPhysicalMaterial* GetPhysMaterial(const struct FHitResult& HitResult);
	static bool IsBlockingHit(const struct FHitResult& HitResult);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"HitResultFunctionLibrary">();
	}
	static class UHitResultFunctionLibrary* GetDefaultObj()
	{
		return GetDefaultObjImpl<UHitResultFunctionLibrary>();
	}
};
static_assert(alignof(UHitResultFunctionLibrary) == 0x000008, "Wrong alignment on UHitResultFunctionLibrary");
static_assert(sizeof(UHitResultFunctionLibrary) == 0x000028, "Wrong size on UHitResultFunctionLibrary");

// Class GbxBlueprintFunctionLibraries.TagsFunctionLibrary
// 0x0000 (0x0028 - 0x0028)
class UTagsFunctionLibrary final : public UBlueprintFunctionLibrary
{
public:
	static bool ActorContainsTag(const class AActor* Target, class FName Tag);
	static void AddTagToActor(class AActor* Target, class FName Tag);
	static void AddTagToComponent(class UActorComponent* Target, class FName Tag);
	static TArray<class FName> CompareActorTags(const class AActor* FirstActor, const class AActor* SecondActor, ECompareTag* Branches);
	static TArray<class FName> CompareActorTagsWithComponent(const class AActor* Actor, const class UActorComponent* Component, ECompareTag* Branches);
	static TArray<class FName> CompareComponentTags(const class UActorComponent* FirstComponent, const class UActorComponent* SecondComponent, ECompareTag* Branches);
	static bool ComponentContainsTag(const class UActorComponent* Target, class FName Tag);
	static void RemoveTagFromActor(class AActor* Target, class FName Tag);
	static void RemoveTagFromComponent(class UActorComponent* Target, class FName Tag);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"TagsFunctionLibrary">();
	}
	static class UTagsFunctionLibrary* GetDefaultObj()
	{
		return GetDefaultObjImpl<UTagsFunctionLibrary>();
	}
};
static_assert(alignof(UTagsFunctionLibrary) == 0x000008, "Wrong alignment on UTagsFunctionLibrary");
static_assert(sizeof(UTagsFunctionLibrary) == 0x000028, "Wrong size on UTagsFunctionLibrary");

}

