#pragma once

/*
* SDK generated by Dumper-7
*
* https://github.com/Encryqed/Dumper-7
*/

// Package: IO_Combat_PipeValve

#include "Basic.hpp"

#include "IO_Combat_PipeValve_classes.hpp"
#include "IO_Combat_PipeValve_parameters.hpp"


namespace SDK
{

// Function IO_Combat_PipeValve.IO_Combat_PipeValve_C.GetPipeFlowState
// (Public, HasOutParams, BlueprintCallable, BlueprintEvent)
// Parameters:
// bool                                    HasFlow                                                (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor)

void AIO_Combat_PipeValve_C::GetPipeFlowState(bool* HasFlow)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("IO_Combat_PipeValve_C", "GetPipeFlowState");

	Params::IO_Combat_PipeValve_C_GetPipeFlowState Parms{};

	UObject::ProcessEvent(Func, &Parms);

	if (HasFlow != nullptr)
		*HasFlow = Parms.HasFlow;
}


// Function IO_Combat_PipeValve.IO_Combat_PipeValve_C.GetPipeDestroyedState
// (Public, HasOutParams, BlueprintCallable, BlueprintEvent)
// Parameters:
// bool                                    Destroyed                                              (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor)

void AIO_Combat_PipeValve_C::GetPipeDestroyedState(bool* Destroyed)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("IO_Combat_PipeValve_C", "GetPipeDestroyedState");

	Params::IO_Combat_PipeValve_C_GetPipeDestroyedState Parms{};

	UObject::ProcessEvent(Func, &Parms);

	if (Destroyed != nullptr)
		*Destroyed = Parms.Destroyed;
}


// Function IO_Combat_PipeValve.IO_Combat_PipeValve_C.SprayTrace
// (Public, HasOutParams, HasDefaults, BlueprintCallable, BlueprintEvent)
// Parameters:
// float                                   ProjectileRadius                                       (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// EObjectTypeQuery                        ObjectTypeToTestAgainst                                (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// ECollisionChannel                       CollissionTraceChannel                                 (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// class AActor*                           OutHitActor                                            (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// struct FVector                          OutHitLocation                                         (Parm, OutParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// struct FVector                          OutHitNormal                                           (Parm, OutParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash)

void AIO_Combat_PipeValve_C::SprayTrace(float ProjectileRadius, EObjectTypeQuery ObjectTypeToTestAgainst, ECollisionChannel CollissionTraceChannel, class AActor** OutHitActor, struct FVector* OutHitLocation, struct FVector* OutHitNormal)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("IO_Combat_PipeValve_C", "SprayTrace");

	Params::IO_Combat_PipeValve_C_SprayTrace Parms{};

	Parms.ProjectileRadius = ProjectileRadius;
	Parms.ObjectTypeToTestAgainst = ObjectTypeToTestAgainst;
	Parms.CollissionTraceChannel = CollissionTraceChannel;

	UObject::ProcessEvent(Func, &Parms);

	if (OutHitActor != nullptr)
		*OutHitActor = Parms.OutHitActor;

	if (OutHitLocation != nullptr)
		*OutHitLocation = std::move(Parms.OutHitLocation);

	if (OutHitNormal != nullptr)
		*OutHitNormal = std::move(Parms.OutHitNormal);
}


// Function IO_Combat_PipeValve.IO_Combat_PipeValve_C.CheckForSprayDamage
// (Public, HasDefaults, BlueprintCallable, BlueprintEvent)

void AIO_Combat_PipeValve_C::CheckForSprayDamage()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("IO_Combat_PipeValve_C", "CheckForSprayDamage");

	UObject::ProcessEvent(Func, nullptr);
}


// Function IO_Combat_PipeValve.IO_Combat_PipeValve_C.SetupDestroyedPipes
// (Public, BlueprintCallable, BlueprintEvent)

void AIO_Combat_PipeValve_C::SetupDestroyedPipes()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("IO_Combat_PipeValve_C", "SetupDestroyedPipes");

	UObject::ProcessEvent(Func, nullptr);
}


// Function IO_Combat_PipeValve.IO_Combat_PipeValve_C.SpawnAPuddle
// (Public, BlueprintCallable, BlueprintEvent)

void AIO_Combat_PipeValve_C::SpawnAPuddle()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("IO_Combat_PipeValve_C", "SpawnAPuddle");

	UObject::ProcessEvent(Func, nullptr);
}


// Function IO_Combat_PipeValve.IO_Combat_PipeValve_C.TurnOnFlowFeedback
// (Public, HasDefaults, BlueprintCallable, BlueprintEvent)

void AIO_Combat_PipeValve_C::TurnOnFlowFeedback()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("IO_Combat_PipeValve_C", "TurnOnFlowFeedback");

	UObject::ProcessEvent(Func, nullptr);
}


// Function IO_Combat_PipeValve.IO_Combat_PipeValve_C.TurnOffFlowFeedback
// (Public, BlueprintCallable, BlueprintEvent)

void AIO_Combat_PipeValve_C::TurnOffFlowFeedback()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("IO_Combat_PipeValve_C", "TurnOffFlowFeedback");

	UObject::ProcessEvent(Func, nullptr);
}


// Function IO_Combat_PipeValve.IO_Combat_PipeValve_C.TurnFlowOff
// (Public, BlueprintCallable, BlueprintEvent)

void AIO_Combat_PipeValve_C::TurnFlowOff()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("IO_Combat_PipeValve_C", "TurnFlowOff");

	UObject::ProcessEvent(Func, nullptr);
}


// Function IO_Combat_PipeValve.IO_Combat_PipeValve_C.TurnFlowOn
// (Public, BlueprintCallable, BlueprintEvent)

void AIO_Combat_PipeValve_C::TurnFlowOn()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("IO_Combat_PipeValve_C", "TurnFlowOn");

	UObject::ProcessEvent(Func, nullptr);
}


// Function IO_Combat_PipeValve.IO_Combat_PipeValve_C.CheckChangeFlowState
// (Public, BlueprintCallable, BlueprintEvent)

void AIO_Combat_PipeValve_C::CheckChangeFlowState()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("IO_Combat_PipeValve_C", "CheckChangeFlowState");

	UObject::ProcessEvent(Func, nullptr);
}


// Function IO_Combat_PipeValve.IO_Combat_PipeValve_C.InitialSetup
// (Public, HasDefaults, BlueprintCallable, BlueprintEvent)

void AIO_Combat_PipeValve_C::InitialSetup()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("IO_Combat_PipeValve_C", "InitialSetup");

	UObject::ProcessEvent(Func, nullptr);
}


// Function IO_Combat_PipeValve.IO_Combat_PipeValve_C.SetUpPipeValveMaterialParameters
// (Public, HasDefaults, BlueprintCallable, BlueprintEvent)
// Parameters:
// class UStaticMeshComponent*             StaticMeshIn                                           (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash)

void AIO_Combat_PipeValve_C::SetUpPipeValveMaterialParameters(class UStaticMeshComponent* StaticMeshIn)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("IO_Combat_PipeValve_C", "SetUpPipeValveMaterialParameters");

	Params::IO_Combat_PipeValve_C_SetUpPipeValveMaterialParameters Parms{};

	Parms.StaticMeshIn = StaticMeshIn;

	UObject::ProcessEvent(Func, &Parms);
}


// Function IO_Combat_PipeValve.IO_Combat_PipeValve_C.UserConstructionScript
// (Event, Public, BlueprintCallable, BlueprintEvent)

void AIO_Combat_PipeValve_C::UserConstructionScript()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("IO_Combat_PipeValve_C", "UserConstructionScript");

	UObject::ProcessEvent(Func, nullptr);
}


// Function IO_Combat_PipeValve.IO_Combat_PipeValve_C.ReceiveBeginPlay
// (Event, Protected, BlueprintEvent)

void AIO_Combat_PipeValve_C::ReceiveBeginPlay()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("IO_Combat_PipeValve_C", "ReceiveBeginPlay");

	UObject::ProcessEvent(Func, nullptr);
}


// Function IO_Combat_PipeValve.IO_Combat_PipeValve_C.OnEnabled
// (Event, Protected, BlueprintEvent)

void AIO_Combat_PipeValve_C::OnEnabled()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("IO_Combat_PipeValve_C", "OnEnabled");

	UObject::ProcessEvent(Func, nullptr);
}


// Function IO_Combat_PipeValve.IO_Combat_PipeValve_C.OnLStateUnlocked
// (Event, Protected, BlueprintEvent)

void AIO_Combat_PipeValve_C::OnLStateUnlocked()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("IO_Combat_PipeValve_C", "OnLStateUnlocked");

	UObject::ProcessEvent(Func, nullptr);
}


// Function IO_Combat_PipeValve.IO_Combat_PipeValve_C.SwitchIsOn
// (BlueprintCallable, BlueprintEvent)
// Parameters:
// class AActor*                           LastActorToUseSwitch                                   (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)

void AIO_Combat_PipeValve_C::SwitchIsOn(class AActor* LastActorToUseSwitch)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("IO_Combat_PipeValve_C", "SwitchIsOn");

	Params::IO_Combat_PipeValve_C_SwitchIsOn Parms{};

	Parms.LastActorToUseSwitch = LastActorToUseSwitch;

	UObject::ProcessEvent(Func, &Parms);
}


// Function IO_Combat_PipeValve.IO_Combat_PipeValve_C.SwitchIsOff
// (BlueprintCallable, BlueprintEvent)
// Parameters:
// class AActor*                           LastActorToUseSwitch                                   (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)

void AIO_Combat_PipeValve_C::SwitchIsOff(class AActor* LastActorToUseSwitch)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("IO_Combat_PipeValve_C", "SwitchIsOff");

	Params::IO_Combat_PipeValve_C_SwitchIsOff Parms{};

	Parms.LastActorToUseSwitch = LastActorToUseSwitch;

	UObject::ProcessEvent(Func, &Parms);
}


// Function IO_Combat_PipeValve.IO_Combat_PipeValve_C.OnEnabling
// (Event, Protected, BlueprintEvent)

void AIO_Combat_PipeValve_C::OnEnabling()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("IO_Combat_PipeValve_C", "OnEnabling");

	UObject::ProcessEvent(Func, nullptr);
}


// Function IO_Combat_PipeValve.IO_Combat_PipeValve_C.OnLStateLocked
// (Event, Protected, BlueprintEvent)

void AIO_Combat_PipeValve_C::OnLStateLocked()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("IO_Combat_PipeValve_C", "OnLStateLocked");

	UObject::ProcessEvent(Func, nullptr);
}


// Function IO_Combat_PipeValve.IO_Combat_PipeValve_C.SetPipeState
// (Public, BlueprintCallable, BlueprintEvent)
// Parameters:
// Enum_IO_ExplodingPipe_DestroyedState    PipeState                                              (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)

void AIO_Combat_PipeValve_C::SetPipeState(Enum_IO_ExplodingPipe_DestroyedState PipeState)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("IO_Combat_PipeValve_C", "SetPipeState");

	Params::IO_Combat_PipeValve_C_SetPipeState Parms{};

	Parms.PipeState = PipeState;

	UObject::ProcessEvent(Func, &Parms);
}


// Function IO_Combat_PipeValve.IO_Combat_PipeValve_C.DestroyPipe
// (Public, BlueprintCallable, BlueprintEvent)

void AIO_Combat_PipeValve_C::DestroyPipe()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("IO_Combat_PipeValve_C", "DestroyPipe");

	UObject::ProcessEvent(Func, nullptr);
}


// Function IO_Combat_PipeValve.IO_Combat_PipeValve_C.SetPipeFlowState
// (Public, BlueprintCallable, BlueprintEvent)
// Parameters:
// bool                                    HasFlow                                                (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor)

void AIO_Combat_PipeValve_C::SetPipeFlowState(bool HasFlow)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("IO_Combat_PipeValve_C", "SetPipeFlowState");

	Params::IO_Combat_PipeValve_C_SetPipeFlowState Parms{};

	Parms.HasFlow = HasFlow;

	UObject::ProcessEvent(Func, &Parms);
}


// Function IO_Combat_PipeValve.IO_Combat_PipeValve_C.BndEvt__OakDamage_K2Node_ComponentBoundEvent_0_DamageCompHealthDepletedDelegate__DelegateSignature_IO_Combat_PipeValve
// (BlueprintEvent)
// Parameters:
// class UDamageComponent*                 DamageReceiver                                         (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// class UDamageCauserComponent*           DamageCauser                                           (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash)

void AIO_Combat_PipeValve_C::BndEvt__OakDamage_K2Node_ComponentBoundEvent_0_DamageCompHealthDepletedDelegate__DelegateSignature_IO_Combat_PipeValve(class UDamageComponent* DamageReceiver, class UDamageCauserComponent* DamageCauser)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("IO_Combat_PipeValve_C", "BndEvt__OakDamage_K2Node_ComponentBoundEvent_0_DamageCompHealthDepletedDelegate__DelegateSignature_IO_Combat_PipeValve");

	Params::IO_Combat_PipeValve_C_BndEvt__OakDamage_K2Node_ComponentBoundEvent_0_DamageCompHealthDepletedDelegate__DelegateSignature_IO_Combat_PipeValve Parms{};

	Parms.DamageReceiver = DamageReceiver;
	Parms.DamageCauser = DamageCauser;

	UObject::ProcessEvent(Func, &Parms);
}


// Function IO_Combat_PipeValve.IO_Combat_PipeValve_C.AttemptToSpawnPudle
// (BlueprintCallable, BlueprintEvent)

void AIO_Combat_PipeValve_C::AttemptToSpawnPudle()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("IO_Combat_PipeValve_C", "AttemptToSpawnPudle");

	UObject::ProcessEvent(Func, nullptr);
}


// Function IO_Combat_PipeValve.IO_Combat_PipeValve_C.ExecuteUbergraph_IO_Combat_PipeValve
// (HasDefaults)
// Parameters:
// int32                                   EntryPoint                                             (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)

void AIO_Combat_PipeValve_C::ExecuteUbergraph_IO_Combat_PipeValve(int32 EntryPoint)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("IO_Combat_PipeValve_C", "ExecuteUbergraph_IO_Combat_PipeValve");

	Params::IO_Combat_PipeValve_C_ExecuteUbergraph_IO_Combat_PipeValve Parms{};

	Parms.EntryPoint = EntryPoint;

	UObject::ProcessEvent(Func, &Parms);
}


// Function IO_Combat_PipeValve.IO_Combat_PipeValve_C.On_PipeFlow_Off__DelegateSignature
// (Public, Delegate, BlueprintCallable, BlueprintEvent)

void AIO_Combat_PipeValve_C::On_PipeFlow_Off__DelegateSignature()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("IO_Combat_PipeValve_C", "On_PipeFlow_Off__DelegateSignature");

	UObject::ProcessEvent(Func, nullptr);
}


// Function IO_Combat_PipeValve.IO_Combat_PipeValve_C.On_PipeFlow_On__DelegateSignature
// (Public, Delegate, BlueprintCallable, BlueprintEvent)

void AIO_Combat_PipeValve_C::On_PipeFlow_On__DelegateSignature()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("IO_Combat_PipeValve_C", "On_PipeFlow_On__DelegateSignature");

	UObject::ProcessEvent(Func, nullptr);
}


// Function IO_Combat_PipeValve.IO_Combat_PipeValve_C.On_PipeDestroyed__DelegateSignature
// (Public, Delegate, BlueprintCallable, BlueprintEvent)

void AIO_Combat_PipeValve_C::On_PipeDestroyed__DelegateSignature()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("IO_Combat_PipeValve_C", "On_PipeDestroyed__DelegateSignature");

	UObject::ProcessEvent(Func, nullptr);
}

}

