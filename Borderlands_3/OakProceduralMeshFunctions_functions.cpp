#pragma once

/*
* SDK generated by Dumper-7
*
* https://github.com/Encryqed/Dumper-7
*/

// Package: OakProceduralMeshFunctions

#include "Basic.hpp"

#include "OakProceduralMeshFunctions_classes.hpp"
#include "OakProceduralMeshFunctions_parameters.hpp"


namespace SDK
{

// Function OakProceduralMeshFunctions.OakProceduralMeshFunctions_C.GetCatenaryPoints
// (Static, Public, HasOutParams, HasDefaults, BlueprintCallable, BlueprintEvent)
// Parameters:
// struct FVector                          P1                                                     (BlueprintVisible, BlueprintReadOnly, Parm, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// struct FVector                          P2                                                     (BlueprintVisible, BlueprintReadOnly, Parm, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// float                                   Wire_Catenary                                          (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// float                                   Wire_Resolution                                        (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// class UObject*                          __WorldContext                                         (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// TArray<struct FVector>                  Points                                                 (Parm, OutParm, ZeroConstructor)

void UOakProceduralMeshFunctions_C::GetCatenaryPoints(const struct FVector& P1, const struct FVector& P2, float Wire_Catenary, float Wire_Resolution, class UObject* __WorldContext, TArray<struct FVector>* Points)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("OakProceduralMeshFunctions_C", "GetCatenaryPoints");

	Params::OakProceduralMeshFunctions_C_GetCatenaryPoints Parms{};

	Parms.P1 = std::move(P1);
	Parms.P2 = std::move(P2);
	Parms.Wire_Catenary = Wire_Catenary;
	Parms.Wire_Resolution = Wire_Resolution;
	Parms.__WorldContext = __WorldContext;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	if (Points != nullptr)
		*Points = std::move(Parms.Points);
}


// Function OakProceduralMeshFunctions.OakProceduralMeshFunctions_C.CalculateCatenary
// (Static, Public, HasOutParams, BlueprintCallable, BlueprintEvent, BlueprintPure)
// Parameters:
// float                                   A                                                      (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// float                                   X                                                      (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// class UObject*                          __WorldContext                                         (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// float                                   Result                                                 (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)

void UOakProceduralMeshFunctions_C::CalculateCatenary(float A, float X, class UObject* __WorldContext, float* Result)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("OakProceduralMeshFunctions_C", "CalculateCatenary");

	Params::OakProceduralMeshFunctions_C_CalculateCatenary Parms{};

	Parms.A = A;
	Parms.X = X;
	Parms.__WorldContext = __WorldContext;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	if (Result != nullptr)
		*Result = Parms.Result;
}


// Function OakProceduralMeshFunctions.OakProceduralMeshFunctions_C.Sphere Strip
// (Static, Public, HasOutParams, HasDefaults, BlueprintCallable, BlueprintEvent)
// Parameters:
// float                                   Width                                                  (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// float                                   Radius                                                 (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// int32                                   Sides                                                  (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// struct FRotator                         Orientation                                            (BlueprintVisible, BlueprintReadOnly, Parm, IsPlainOldData, NoDestructor)
// float                                   Sphere_Angle                                           (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// struct FTransform                       Transform                                              (BlueprintVisible, BlueprintReadOnly, Parm, IsPlainOldData, NoDestructor)
// struct FVector2D                        UV_Tile                                                (BlueprintVisible, BlueprintReadOnly, Parm, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// int32                                   Sub_UV_Index                                           (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// struct FLinearColor                     Color                                                  (BlueprintVisible, BlueprintReadOnly, Parm, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// bool                                    bFlat                                                  (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
// class UObject*                          __WorldContext                                         (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// TArray<struct FVector>                  Out_Verts                                              (Parm, OutParm, ZeroConstructor)
// TArray<int32>                           Out_Faces                                              (Parm, OutParm, ZeroConstructor)
// TArray<struct FVector>                  Out_Normals                                            (Parm, OutParm, ZeroConstructor)
// TArray<struct FVector2D>                Out_UVs                                                (Parm, OutParm, ZeroConstructor)
// TArray<struct FLinearColor>             Out_Vertex_Color                                       (Parm, OutParm, ZeroConstructor)

void UOakProceduralMeshFunctions_C::Sphere_Strip(float Width, float Radius, int32 Sides, const struct FRotator& Orientation, float Sphere_Angle, const struct FTransform& Transform, const struct FVector2D& UV_Tile, int32 Sub_UV_Index, const struct FLinearColor& Color, bool bFlat, class UObject* __WorldContext, TArray<struct FVector>* Out_Verts, TArray<int32>* Out_Faces, TArray<struct FVector>* Out_Normals, TArray<struct FVector2D>* Out_UVs, TArray<struct FLinearColor>* Out_Vertex_Color)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("OakProceduralMeshFunctions_C", "Sphere Strip");

	Params::OakProceduralMeshFunctions_C_Sphere_Strip Parms{};

	Parms.Width = Width;
	Parms.Radius = Radius;
	Parms.Sides = Sides;
	Parms.Orientation = std::move(Orientation);
	Parms.Sphere_Angle = Sphere_Angle;
	Parms.Transform = std::move(Transform);
	Parms.UV_Tile = std::move(UV_Tile);
	Parms.Sub_UV_Index = Sub_UV_Index;
	Parms.Color = std::move(Color);
	Parms.bFlat = bFlat;
	Parms.__WorldContext = __WorldContext;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	if (Out_Verts != nullptr)
		*Out_Verts = std::move(Parms.Out_Verts);

	if (Out_Faces != nullptr)
		*Out_Faces = std::move(Parms.Out_Faces);

	if (Out_Normals != nullptr)
		*Out_Normals = std::move(Parms.Out_Normals);

	if (Out_UVs != nullptr)
		*Out_UVs = std::move(Parms.Out_UVs);

	if (Out_Vertex_Color != nullptr)
		*Out_Vertex_Color = std::move(Parms.Out_Vertex_Color);
}


// Function OakProceduralMeshFunctions.OakProceduralMeshFunctions_C.Make Quad
// (Static, Public, HasOutParams, HasDefaults, BlueprintCallable, BlueprintEvent, BlueprintPure)
// Parameters:
// float                                   Length_                                                (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// float                                   Width                                                  (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// struct FTransform                       Transform                                              (BlueprintVisible, BlueprintReadOnly, Parm, IsPlainOldData, NoDestructor)
// class UObject*                          __WorldContext                                         (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// TArray<struct FVector>                  Verticies                                              (Parm, OutParm, ZeroConstructor)
// TArray<int32>                           Faces                                                  (Parm, OutParm, ZeroConstructor)
// TArray<struct FVector>                  Normals                                                (Parm, OutParm, ZeroConstructor)

void UOakProceduralMeshFunctions_C::Make_Quad(float Length_, float Width, const struct FTransform& Transform, class UObject* __WorldContext, TArray<struct FVector>* Verticies, TArray<int32>* Faces, TArray<struct FVector>* Normals)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("OakProceduralMeshFunctions_C", "Make Quad");

	Params::OakProceduralMeshFunctions_C_Make_Quad Parms{};

	Parms.Length_ = Length_;
	Parms.Width = Width;
	Parms.Transform = std::move(Transform);
	Parms.__WorldContext = __WorldContext;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	if (Verticies != nullptr)
		*Verticies = std::move(Parms.Verticies);

	if (Faces != nullptr)
		*Faces = std::move(Parms.Faces);

	if (Normals != nullptr)
		*Normals = std::move(Parms.Normals);
}


// Function OakProceduralMeshFunctions.OakProceduralMeshFunctions_C.Loft Spline
// (Static, Public, HasOutParams, HasDefaults, BlueprintCallable, BlueprintEvent, BlueprintPure)
// Parameters:
// class USplineComponent*                 Spline                                                 (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// float                                   Twist                                                  (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// float                                   Base_Thickness                                         (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// int32                                   Edge_Loops                                             (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// int32                                   Sides                                                  (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// struct FVector2D                        UVScale                                                (BlueprintVisible, BlueprintReadOnly, Parm, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// bool                                    Taper_                                                 (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
// class UObject*                          __WorldContext                                         (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// TArray<struct FVector>                  Verticies                                              (Parm, OutParm, ZeroConstructor)
// TArray<int32>                           Triangles                                              (Parm, OutParm, ZeroConstructor)
// TArray<struct FVector>                  Normals                                                (Parm, OutParm, ZeroConstructor)
// TArray<struct FVector2D>                UVs                                                    (Parm, OutParm, ZeroConstructor)

void UOakProceduralMeshFunctions_C::Loft_Spline(class USplineComponent* Spline, float Twist, float Base_Thickness, int32 Edge_Loops, int32 Sides, const struct FVector2D& UVScale, bool Taper_, class UObject* __WorldContext, TArray<struct FVector>* Verticies, TArray<int32>* Triangles, TArray<struct FVector>* Normals, TArray<struct FVector2D>* UVs)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("OakProceduralMeshFunctions_C", "Loft Spline");

	Params::OakProceduralMeshFunctions_C_Loft_Spline Parms{};

	Parms.Spline = Spline;
	Parms.Twist = Twist;
	Parms.Base_Thickness = Base_Thickness;
	Parms.Edge_Loops = Edge_Loops;
	Parms.Sides = Sides;
	Parms.UVScale = std::move(UVScale);
	Parms.Taper_ = Taper_;
	Parms.__WorldContext = __WorldContext;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	if (Verticies != nullptr)
		*Verticies = std::move(Parms.Verticies);

	if (Triangles != nullptr)
		*Triangles = std::move(Parms.Triangles);

	if (Normals != nullptr)
		*Normals = std::move(Parms.Normals);

	if (UVs != nullptr)
		*UVs = std::move(Parms.UVs);
}


// Function OakProceduralMeshFunctions.OakProceduralMeshFunctions_C.Make Circular Vertex Array
// (Static, Public, HasOutParams, HasDefaults, BlueprintCallable, BlueprintEvent, BlueprintPure)
// Parameters:
// float                                   Radius                                                 (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// int32                                   Sides                                                  (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// class UObject*                          __WorldContext                                         (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// TArray<struct FVector>                  Circle_Verts                                           (Parm, OutParm, ZeroConstructor)

void UOakProceduralMeshFunctions_C::Make_Circular_Vertex_Array(float Radius, int32 Sides, class UObject* __WorldContext, TArray<struct FVector>* Circle_Verts)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("OakProceduralMeshFunctions_C", "Make Circular Vertex Array");

	Params::OakProceduralMeshFunctions_C_Make_Circular_Vertex_Array Parms{};

	Parms.Radius = Radius;
	Parms.Sides = Sides;
	Parms.__WorldContext = __WorldContext;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	if (Circle_Verts != nullptr)
		*Circle_Verts = std::move(Parms.Circle_Verts);
}


// Function OakProceduralMeshFunctions.OakProceduralMeshFunctions_C.FlatTube
// (Static, Public, HasOutParams, HasDefaults, BlueprintCallable, BlueprintEvent, BlueprintPure)
// Parameters:
// float                                   Inner_Radius                                           (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// float                                   Outer_Radius                                           (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// int32                                   Sides                                                  (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// int32                                   Radial_Segments                                        (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// struct FVector2D                        UV_Scale                                               (BlueprintVisible, BlueprintReadOnly, Parm, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// class UObject*                          __WorldContext                                         (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// TArray<struct FVector>                  Vertices                                               (Parm, OutParm, ZeroConstructor)
// TArray<int32>                           Triangles                                              (Parm, OutParm, ZeroConstructor)
// TArray<struct FVector>                  Normals                                                (Parm, OutParm, ZeroConstructor)
// TArray<struct FVector2D>                UV0                                                    (Parm, OutParm, ZeroConstructor)
// TArray<struct FLinearColor>             Vertex_Colors                                          (Parm, OutParm, ZeroConstructor)

void UOakProceduralMeshFunctions_C::FlatTube(float Inner_Radius, float Outer_Radius, int32 Sides, int32 Radial_Segments, const struct FVector2D& UV_Scale, class UObject* __WorldContext, TArray<struct FVector>* Vertices, TArray<int32>* Triangles, TArray<struct FVector>* Normals, TArray<struct FVector2D>* UV0, TArray<struct FLinearColor>* Vertex_Colors)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("OakProceduralMeshFunctions_C", "FlatTube");

	Params::OakProceduralMeshFunctions_C_FlatTube Parms{};

	Parms.Inner_Radius = Inner_Radius;
	Parms.Outer_Radius = Outer_Radius;
	Parms.Sides = Sides;
	Parms.Radial_Segments = Radial_Segments;
	Parms.UV_Scale = std::move(UV_Scale);
	Parms.__WorldContext = __WorldContext;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	if (Vertices != nullptr)
		*Vertices = std::move(Parms.Vertices);

	if (Triangles != nullptr)
		*Triangles = std::move(Parms.Triangles);

	if (Normals != nullptr)
		*Normals = std::move(Parms.Normals);

	if (UV0 != nullptr)
		*UV0 = std::move(Parms.UV0);

	if (Vertex_Colors != nullptr)
		*Vertex_Colors = std::move(Parms.Vertex_Colors);
}

}

