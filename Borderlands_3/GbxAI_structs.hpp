#pragma once

/*
* SDK generated by Dumper-7
*
* https://github.com/Encryqed/Dumper-7
*/

// Package: GbxAI

#include "Basic.hpp"

#include "GbxGameSystemCore_structs.hpp"
#include "CoreUObject_structs.hpp"
#include "GameplayTags_structs.hpp"
#include "GbxRuntime_structs.hpp"
#include "GbxNav_structs.hpp"
#include "AIModule_structs.hpp"


namespace SDK
{

// Enum GbxAI.EAIActionResult
// NumValues: 0x0007
enum class EAIActionResult : uint8
{
	None                                     = 0,
	Succeeded                                = 1,
	Failed                                   = 2,
	Interrupted                              = 3,
	Aborted                                  = 4,
	Count                                    = 5,
	EAIActionResult_MAX                      = 6,
};

// Enum GbxAI.ECoverUserAnimState
// NumValues: 0x000A
enum class ECoverUserAnimState : uint8
{
	None                                     = 0,
	Idle                                     = 1,
	Exit                                     = 2,
	FireIdle                                 = 3,
	FireEnter                                = 4,
	FireExit                                 = 5,
	FireToIdle                               = 6,
	Transition                               = 7,
	ViewSwitch                               = 8,
	ECoverUserAnimState_MAX                  = 9,
};

// Enum GbxAI.EScriptedActionRule
// NumValues: 0x0003
enum class EScriptedActionRule : uint8
{
	Any                                      = 0,
	All                                      = 1,
	EScriptedActionRule_MAX                  = 2,
};

// Enum GbxAI.ESmartActionResult
// NumValues: 0x0004
enum class ESmartActionResult : uint8
{
	Success                                  = 0,
	Interrupt                                = 1,
	Unreserve                                = 2,
	ESmartActionResult_MAX                   = 3,
};

// Enum GbxAI.EMeleeRotationOption
// NumValues: 0x0004
enum class EMeleeRotationOption : uint8
{
	HoldStill                                = 0,
	AlignToTarget                            = 1,
	FollowTarget                             = 2,
	EMeleeRotationOption_MAX                 = 3,
};

// Enum GbxAI.EAIActionSequenceCanStartCheck
// NumValues: 0x0003
enum class EAIActionSequenceCanStartCheck : uint8
{
	FirstChild                               = 0,
	EachChild                                = 1,
	EAIActionSequenceCanStartCheck_MAX       = 2,
};

// Enum GbxAI.EAIActionCreationMethod
// NumValues: 0x0005
enum class EAIActionCreationMethod : uint8
{
	Unknown                                  = 0,
	Composition                              = 1,
	PropertyPanel                            = 2,
	Graph                                    = 3,
	EAIActionCreationMethod_MAX              = 4,
};

// Enum GbxAI.EAIActionResultTransition
// NumValues: 0x0004
enum class EAIActionResultTransition : uint8
{
	Stop                                     = 0,
	Continue                                 = 1,
	Restart                                  = 2,
	EAIActionResultTransition_MAX            = 3,
};

// Enum GbxAI.EAIActionResultDirective
// NumValues: 0x0004
enum class EAIActionResultDirective : uint8
{
	Continue                                 = 0,
	Succeed                                  = 1,
	Fail                                     = 2,
	EAIActionResultDirective_MAX             = 3,
};

// Enum GbxAI.EAIActionExecutionStage
// NumValues: 0x0006
enum class EAIActionExecutionStage : uint8
{
	Starting                                 = 0,
	Running                                  = 1,
	Stopping                                 = 2,
	Stopped                                  = 3,
	CleaningUp                               = 4,
	EAIActionExecutionStage_MAX              = 5,
};

// Enum GbxAI.EAIActionState
// NumValues: 0x0005
enum class EAIActionState : uint8
{
	Idle                                     = 0,
	Starting                                 = 1,
	Running                                  = 2,
	Stopped                                  = 3,
	EAIActionState_MAX                       = 4,
};

// Enum GbxAI.EAIActionLayer
// NumValues: 0x0004
enum class EAIActionLayer : uint8
{
	Default                                  = 0,
	Script                                   = 1,
	Count                                    = 2,
	EAIActionLayer_MAX                       = 3,
};

// Enum GbxAI.EAIGroupConditionType
// NumValues: 0x0005
enum class EAIGroupConditionType : uint8
{
	AllFalse                                 = 0,
	AllTrue                                  = 1,
	SomeFalse                                = 2,
	SomeTrue                                 = 3,
	EAIGroupConditionType_MAX                = 4,
};

// Enum GbxAI.ECircleDirection
// NumValues: 0x0004
enum class ECircleDirection : uint8
{
	Left                                     = 0,
	Right                                    = 1,
	Random                                   = 2,
	ECircleDirection_MAX                     = 3,
};

// Enum GbxAI.EGbxQueryPreset
// NumValues: 0x0006
enum class EGbxQueryPreset : uint8
{
	UseBestLocation                          = 0,
	TryCurrentLocation                       = 1,
	OnlyCurrentLocation                      = 2,
	QueryFrequencyLow                        = 3,
	QueryOnStart                             = 4,
	EGbxQueryPreset_MAX                      = 5,
};

// Enum GbxAI.ECompareMethod
// NumValues: 0x0007
enum class ECompareMethod : uint8
{
	Equals                                   = 0,
	NotEquals                                = 1,
	Smaller                                  = 2,
	SmallerOrEqual                           = 3,
	Greater                                  = 4,
	GreaterOrEqual                           = 5,
	ECompareMethod_MAX                       = 6,
};

// Enum GbxAI.EIsInRangeAspectDistanceTest
// NumValues: 0x0006
enum class EIsInRangeAspectDistanceTest : uint8
{
	Direct                                   = 0,
	Horizontal                               = 1,
	Vertical                                 = 2,
	VerticalOffset                           = 3,
	Count                                    = 4,
	EIsInRangeAspectDistanceTest_MAX         = 5,
};

// Enum GbxAI.EOrbitDirection
// NumValues: 0x0004
enum class EOrbitDirection : uint8
{
	Left                                     = 0,
	Right                                    = 1,
	Random                                   = 2,
	EOrbitDirection_MAX                      = 3,
};

// Enum GbxAI.EAIAspectSettingsDefaults_Rotation
// NumValues: 0x0007
enum class EAIAspectSettingsDefaults_Rotation : uint8
{
	Custom                                   = 0,
	None                                     = 1,
	NoBodyRotationAllowed                    = 2,
	FullBody                                 = 3,
	AimOffsetsOnly                           = 4,
	FullBodyWithAim                          = 5,
	EAIAspectSettingsDefaults_MAX            = 6,
};

// Enum GbxAI.EAIAspectSettingsDefaults_Rotation_BodyHeadingOffset
// NumValues: 0x0006
enum class EAIAspectSettingsDefaults_Rotation_BodyHeadingOffset : uint8
{
	Front                                    = 0,
	Back                                     = 1,
	Left                                     = 2,
	Right                                    = 3,
	Custom                                   = 4,
	EAIAspectSettingsDefaults_Rotation_MAX   = 5,
};

// Enum GbxAI.ESweepDirection
// NumValues: 0x0004
enum class ESweepDirection : uint8
{
	Left                                     = 0,
	Right                                    = 1,
	Random                                   = 2,
	ESweepDirection_MAX                      = 3,
};

// Enum GbxAI.ECloakAction
// NumValues: 0x0003
enum class ECloakAction : uint8
{
	OnStart                                  = 0,
	OnStop                                   = 1,
	ECloakAction_MAX                         = 2,
};

// Enum GbxAI.EPlanMemberReplacement
// NumValues: 0x0004
enum class EPlanMemberReplacement : uint8
{
	AbandonPlanIfKilled                      = 0,
	ReplaceMemberIfKilled                    = 1,
	DoNotReplaceAndKeepGoing                 = 2,
	EPlanMemberReplacement_MAX               = 3,
};

// Enum GbxAI.EPlanValidityCode
// NumValues: 0x000A
enum class EPlanValidityCode : uint8
{
	Unknown                                  = 0,
	PlanIsValid                              = 1,
	NoPlanData                               = 2,
	NotEnoughRoleSlots                       = 3,
	MissingRoleTag                           = 4,
	BadPlanInstanceNumber                    = 5,
	BadMinMaxRoleInstanceNumbers             = 6,
	BadDistanceValues                        = 7,
	InsufficientCandidates                   = 8,
	EPlanValidityCode_MAX                    = 9,
};

// Enum GbxAI.EPlanStage
// NumValues: 0x0007
enum class EPlanStage : uint8
{
	NeedLeader                               = 0,
	NeedFollowers                            = 1,
	HasMinimumRoster                         = 2,
	HasFullRoster                            = 3,
	EveryoneCheckedIn                        = 4,
	ShuttingDown                             = 5,
	EPlanStage_MAX                           = 6,
};

// Enum GbxAI.ESmartObjectLookAtRule
// NumValues: 0x0005
enum class ESmartObjectLookAtRule : uint8
{
	None                                     = 0,
	ActorCenter                              = 1,
	ActorEyes                                = 2,
	ActorSocket                              = 3,
	ESmartObjectLookAtRule_MAX               = 4,
};

// Enum GbxAI.ESlotAlignRule
// NumValues: 0x0004
enum class ESlotAlignRule : uint8
{
	None                                     = 0,
	Center                                   = 1,
	Align                                    = 2,
	ESlotAlignRule_MAX                       = 3,
};

// Enum GbxAI.ESmartObjectNotify
// NumValues: 0x0003
enum class ESmartObjectNotify : uint8
{
	LerpToSlot                               = 0,
	LerpToGround                             = 1,
	ESmartObjectNotify_MAX                   = 2,
};

// Enum GbxAI.ECoverFaceDirection
// NumValues: 0x0003
enum class ECoverFaceDirection : uint8
{
	Toward                                   = 0,
	Away                                     = 1,
	ECoverFaceDirection_MAX                  = 2,
};

// Enum GbxAI.ECoverAdjustFailReason
// NumValues: 0x0005
enum class ECoverAdjustFailReason : uint8
{
	None                                     = 0,
	NoRoom                                   = 1,
	NoView                                   = 2,
	Invalid                                  = 3,
	ECoverAdjustFailReason_MAX               = 4,
};

// Enum GbxAI.ECoverSlotHeight
// NumValues: 0x0003
enum class ECoverSlotHeight : uint8
{
	Low                                      = 0,
	High                                     = 1,
	ECoverSlotHeight_MAX                     = 2,
};

// Enum GbxAI.ECoverStyleAnimType
// NumValues: 0x0004
enum class ECoverStyleAnimType : uint8
{
	TimedMoveOut                             = 0,
	TimedStayIn                              = 1,
	SingleAnim                               = 2,
	ECoverStyleAnimType_MAX                  = 3,
};

// Enum GbxAI.ECoverUserState
// NumValues: 0x0004
enum class ECoverUserState : uint8
{
	NotInCover                               = 0,
	Idling                                   = 1,
	Firing                                   = 2,
	ECoverUserState_MAX                      = 3,
};

// Enum GbxAI.ETerritoryMovementType
// NumValues: 0x0004
enum class ETerritoryMovementType : uint8
{
	Ground                                   = 0,
	Flight                                   = 1,
	Dynamic                                  = 2,
	ETerritoryMovementType_MAX               = 3,
};

// Enum GbxAI.EUberTraceMultiTraceRequirement
// NumValues: 0x0003
enum class EUberTraceMultiTraceRequirement : uint8
{
	AtLeastOneMustPassTest                   = 0,
	AllMustPassTest                          = 1,
	EUberTraceMultiTraceRequirement_MAX      = 2,
};

// Enum GbxAI.ENavJumpStage
// NumValues: 0x0006
enum class ENavJumpStage : uint8
{
	None                                     = 0,
	Enter                                    = 1,
	Idle                                     = 2,
	Exit                                     = 3,
	End                                      = 4,
	ENavJumpStage_MAX                        = 5,
};

// Enum GbxAI.ENavJumpRotation
// NumValues: 0x0005
enum class ENavJumpRotation : uint8
{
	None                                     = 0,
	FaceJumpOrigin                           = 1,
	FaceJumpTarget                           = 2,
	FaceJumpTargetFaceDir                    = 3,
	ENavJumpRotation_MAX                     = 4,
};

// Enum GbxAI.ELookAtPointType
// NumValues: 0x0004
enum class ELookAtPointType : uint8
{
	Interrupt                                = 0,
	Persist                                  = 1,
	Any                                      = 2,
	ELookAtPointType_MAX                     = 3,
};

// Enum GbxAI.ESmartObjectTaskState
// NumValues: 0x0006
enum class ESmartObjectTaskState : uint8
{
	Uninitialized                            = 0,
	Movement                                 = 1,
	Alignment                                = 2,
	Usage                                    = 3,
	Complete                                 = 4,
	ESmartObjectTaskState_MAX                = 5,
};

// Enum GbxAI.ESmartObjectTaskResult
// NumValues: 0x0004
enum class ESmartObjectTaskResult : uint8
{
	Aborted                                  = 0,
	Failed                                   = 1,
	Succeeded                                = 2,
	ESmartObjectTaskResult_MAX               = 3,
};

// Enum GbxAI.ESmartObjectUseResult
// NumValues: 0x0005
enum class ESmartObjectUseResult : uint8
{
	Failure                                  = 0,
	Running                                  = 1,
	Blocking                                 = 2,
	Success                                  = 3,
	ESmartObjectUseResult_MAX                = 4,
};

// Enum GbxAI.EInitialPathAction
// NumValues: 0x0006
enum class EInitialPathAction : uint8
{
	None                                     = 0,
	PatrolPath                               = 1,
	ScriptedPath                             = 2,
	ScriptedRoute                            = 3,
	ScriptedWait                             = 4,
	EInitialPathAction_MAX                   = 5,
};

// ScriptStruct GbxAI.AIAspectSettings_FindClosestPlayer
// 0x0020 (0x0020 - 0x0000)
struct FAIAspectSettings_FindClosestPlayer final
{
public:
	struct FGbxBlackboardKeySelector              BlackboardKey;                                     // 0x0000(0x0010)(Edit, BlueprintVisible, NoDestructor, NativeAccessSpecifierPublic)
	bool                                          bOnlyRunIfKeyIsValid;                              // 0x0010(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bClearKeyOnStop;                                   // 0x0011(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_12[0x2];                                       // 0x0012(0x0002)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         UpdatePeriod;                                      // 0x0014(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bIsInternal;                                       // 0x0018(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_19[0x7];                                       // 0x0019(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FAIAspectSettings_FindClosestPlayer) == 0x000008, "Wrong alignment on FAIAspectSettings_FindClosestPlayer");
static_assert(sizeof(FAIAspectSettings_FindClosestPlayer) == 0x000020, "Wrong size on FAIAspectSettings_FindClosestPlayer");
static_assert(offsetof(FAIAspectSettings_FindClosestPlayer, BlackboardKey) == 0x000000, "Member 'FAIAspectSettings_FindClosestPlayer::BlackboardKey' has a wrong offset!");
static_assert(offsetof(FAIAspectSettings_FindClosestPlayer, bOnlyRunIfKeyIsValid) == 0x000010, "Member 'FAIAspectSettings_FindClosestPlayer::bOnlyRunIfKeyIsValid' has a wrong offset!");
static_assert(offsetof(FAIAspectSettings_FindClosestPlayer, bClearKeyOnStop) == 0x000011, "Member 'FAIAspectSettings_FindClosestPlayer::bClearKeyOnStop' has a wrong offset!");
static_assert(offsetof(FAIAspectSettings_FindClosestPlayer, UpdatePeriod) == 0x000014, "Member 'FAIAspectSettings_FindClosestPlayer::UpdatePeriod' has a wrong offset!");
static_assert(offsetof(FAIAspectSettings_FindClosestPlayer, bIsInternal) == 0x000018, "Member 'FAIAspectSettings_FindClosestPlayer::bIsInternal' has a wrong offset!");

// ScriptStruct GbxAI.SmartActionUseInfo
// 0x0018 (0x0018 - 0x0000)
struct FSmartActionUseInfo final
{
public:
	struct FGameplayTag                           ActionTag;                                         // 0x0000(0x0008)(NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bInterrupting;                                     // 0x0008(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_9[0x3];                                        // 0x0009(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         UseDuration;                                       // 0x000C(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         CooldownTime;                                      // 0x0010(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bPassiveAction;                                    // 0x0014(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bCombatAction;                                     // 0x0015(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_16[0x2];                                       // 0x0016(0x0002)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FSmartActionUseInfo) == 0x000008, "Wrong alignment on FSmartActionUseInfo");
static_assert(sizeof(FSmartActionUseInfo) == 0x000018, "Wrong size on FSmartActionUseInfo");
static_assert(offsetof(FSmartActionUseInfo, ActionTag) == 0x000000, "Member 'FSmartActionUseInfo::ActionTag' has a wrong offset!");
static_assert(offsetof(FSmartActionUseInfo, bInterrupting) == 0x000008, "Member 'FSmartActionUseInfo::bInterrupting' has a wrong offset!");
static_assert(offsetof(FSmartActionUseInfo, UseDuration) == 0x00000C, "Member 'FSmartActionUseInfo::UseDuration' has a wrong offset!");
static_assert(offsetof(FSmartActionUseInfo, CooldownTime) == 0x000010, "Member 'FSmartActionUseInfo::CooldownTime' has a wrong offset!");
static_assert(offsetof(FSmartActionUseInfo, bPassiveAction) == 0x000014, "Member 'FSmartActionUseInfo::bPassiveAction' has a wrong offset!");
static_assert(offsetof(FSmartActionUseInfo, bCombatAction) == 0x000015, "Member 'FSmartActionUseInfo::bCombatAction' has a wrong offset!");

// ScriptStruct GbxAI.SmartActionInfoContext
// 0x0030 (0x0030 - 0x0000)
struct FSmartActionInfoContext final
{
public:
	TWeakObjectPtr<class AActor>                  SmartObject;                                       // 0x0000(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FSmartActionUseInfo                    UseInfo;                                           // 0x0008(0x0018)(NoDestructor, NativeAccessSpecifierPublic)
	struct FVector                                ContextLoc;                                        // 0x0020(0x000C)(IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2C[0x4];                                       // 0x002C(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FSmartActionInfoContext) == 0x000008, "Wrong alignment on FSmartActionInfoContext");
static_assert(sizeof(FSmartActionInfoContext) == 0x000030, "Wrong size on FSmartActionInfoContext");
static_assert(offsetof(FSmartActionInfoContext, SmartObject) == 0x000000, "Member 'FSmartActionInfoContext::SmartObject' has a wrong offset!");
static_assert(offsetof(FSmartActionInfoContext, UseInfo) == 0x000008, "Member 'FSmartActionInfoContext::UseInfo' has a wrong offset!");
static_assert(offsetof(FSmartActionInfoContext, ContextLoc) == 0x000020, "Member 'FSmartActionInfoContext::ContextLoc' has a wrong offset!");

// ScriptStruct GbxAI.CoverLineOfSightBlockData
// 0x0004 (0x0004 - 0x0000)
struct FCoverLineOfSightBlockData final
{
public:
	float                                         Distance;                                          // 0x0000(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FCoverLineOfSightBlockData) == 0x000004, "Wrong alignment on FCoverLineOfSightBlockData");
static_assert(sizeof(FCoverLineOfSightBlockData) == 0x000004, "Wrong size on FCoverLineOfSightBlockData");
static_assert(offsetof(FCoverLineOfSightBlockData, Distance) == 0x000000, "Member 'FCoverLineOfSightBlockData::Distance' has a wrong offset!");

// ScriptStruct GbxAI.CoverLineOfSightSectionData
// 0x0010 (0x0010 - 0x0000)
struct FCoverLineOfSightSectionData final
{
public:
	TArray<struct FCoverLineOfSightBlockData>     Blocks;                                            // 0x0000(0x0010)(ZeroConstructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(FCoverLineOfSightSectionData) == 0x000008, "Wrong alignment on FCoverLineOfSightSectionData");
static_assert(sizeof(FCoverLineOfSightSectionData) == 0x000010, "Wrong size on FCoverLineOfSightSectionData");
static_assert(offsetof(FCoverLineOfSightSectionData, Blocks) == 0x000000, "Member 'FCoverLineOfSightSectionData::Blocks' has a wrong offset!");

// ScriptStruct GbxAI.AIActionBlueprintContext
// 0x0018 (0x0018 - 0x0000)
struct FAIActionBlueprintContext final
{
public:
	class AGbxAIController*                       Controller;                                        // 0x0000(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_8[0x10];                                       // 0x0008(0x0010)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FAIActionBlueprintContext) == 0x000008, "Wrong alignment on FAIActionBlueprintContext");
static_assert(sizeof(FAIActionBlueprintContext) == 0x000018, "Wrong size on FAIActionBlueprintContext");
static_assert(offsetof(FAIActionBlueprintContext, Controller) == 0x000000, "Member 'FAIActionBlueprintContext::Controller' has a wrong offset!");

// ScriptStruct GbxAI.AIAspectSettings_Ticket
// 0x0128 (0x0128 - 0x0000)
struct FAIAspectSettings_Ticket final
{
public:
	bool                                          bPriority;                                         // 0x0000(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bInterruptible;                                    // 0x0001(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2[0x6];                                        // 0x0002(0x0006)(Fixing Size After Last Property [ Dumper-7 ])
	struct FGbxParam                              Value;                                             // 0x0008(0x0080)(Edit, NoDestructor, ContainsInstancedReference, NativeAccessSpecifierPublic)
	struct FGbxParam                              HoldDuration;                                      // 0x0088(0x0080)(Edit, NoDestructor, ContainsInstancedReference, NativeAccessSpecifierPublic)
	class UAITicketDataAsset*                     AITicket;                                          // 0x0108(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FGbxBlackboardKeySelector              ActorBlackboardKey;                                // 0x0110(0x0010)(Edit, NoDestructor, NativeAccessSpecifierPublic)
	bool                                          bOverrideActorBlackboardKey;                       // 0x0120(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bApplyHoldOnSuccess;                               // 0x0121(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bApplyHoldOnFailure;                               // 0x0122(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bApplyHoldOnAbort;                                 // 0x0123(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bAcquireTicket;                                    // 0x0124(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, AdvancedDisplay, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_125[0x3];                                      // 0x0125(0x0003)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FAIAspectSettings_Ticket) == 0x000008, "Wrong alignment on FAIAspectSettings_Ticket");
static_assert(sizeof(FAIAspectSettings_Ticket) == 0x000128, "Wrong size on FAIAspectSettings_Ticket");
static_assert(offsetof(FAIAspectSettings_Ticket, bPriority) == 0x000000, "Member 'FAIAspectSettings_Ticket::bPriority' has a wrong offset!");
static_assert(offsetof(FAIAspectSettings_Ticket, bInterruptible) == 0x000001, "Member 'FAIAspectSettings_Ticket::bInterruptible' has a wrong offset!");
static_assert(offsetof(FAIAspectSettings_Ticket, Value) == 0x000008, "Member 'FAIAspectSettings_Ticket::Value' has a wrong offset!");
static_assert(offsetof(FAIAspectSettings_Ticket, HoldDuration) == 0x000088, "Member 'FAIAspectSettings_Ticket::HoldDuration' has a wrong offset!");
static_assert(offsetof(FAIAspectSettings_Ticket, AITicket) == 0x000108, "Member 'FAIAspectSettings_Ticket::AITicket' has a wrong offset!");
static_assert(offsetof(FAIAspectSettings_Ticket, ActorBlackboardKey) == 0x000110, "Member 'FAIAspectSettings_Ticket::ActorBlackboardKey' has a wrong offset!");
static_assert(offsetof(FAIAspectSettings_Ticket, bOverrideActorBlackboardKey) == 0x000120, "Member 'FAIAspectSettings_Ticket::bOverrideActorBlackboardKey' has a wrong offset!");
static_assert(offsetof(FAIAspectSettings_Ticket, bApplyHoldOnSuccess) == 0x000121, "Member 'FAIAspectSettings_Ticket::bApplyHoldOnSuccess' has a wrong offset!");
static_assert(offsetof(FAIAspectSettings_Ticket, bApplyHoldOnFailure) == 0x000122, "Member 'FAIAspectSettings_Ticket::bApplyHoldOnFailure' has a wrong offset!");
static_assert(offsetof(FAIAspectSettings_Ticket, bApplyHoldOnAbort) == 0x000123, "Member 'FAIAspectSettings_Ticket::bApplyHoldOnAbort' has a wrong offset!");
static_assert(offsetof(FAIAspectSettings_Ticket, bAcquireTicket) == 0x000124, "Member 'FAIAspectSettings_Ticket::bAcquireTicket' has a wrong offset!");

// ScriptStruct GbxAI.AIAspectSettings_EnvQuery
// 0x03A0 (0x03A0 - 0x0000)
struct FAIAspectSettings_EnvQuery final
{
public:
	struct FEnvQueryParams                        Query;                                             // 0x0000(0x00B8)(Edit, ContainsInstancedReference, NativeAccessSpecifierPublic)
	struct FGbxBlackboardKeySelector              QueryBlackboardKey;                                // 0x00B8(0x0010)(Edit, NoDestructor, NativeAccessSpecifierPublic)
	bool                                          bRefreshAITreeOnQuerySuccess;                      // 0x00C8(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bForceRequeryOnSuccess;                            // 0x00C9(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bClearQueryOnSuccess;                              // 0x00CA(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_CB[0x5];                                       // 0x00CB(0x0005)(Fixing Size After Last Property [ Dumper-7 ])
	struct FGbxQueryOptions                       Options;                                           // 0x00D0(0x0238)(Edit, NoDestructor, ContainsInstancedReference, NativeAccessSpecifierPublic)
	EGbxQueryPreset                               Preset;                                            // 0x0308(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bUsePreset;                                        // 0x0309(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_30A[0x6];                                      // 0x030A(0x0006)(Fixing Size After Last Property [ Dumper-7 ])
	struct FGbxParam                              QueryPeriod;                                       // 0x0310(0x0080)(NoDestructor, ContainsInstancedReference, NativeAccessSpecifierPublic)
	bool                                          bQueryContinuously;                                // 0x0390(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bUpdateValueWhileRunning;                          // 0x0391(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bKeepValidValues;                                  // 0x0392(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bCanUseSelf;                                       // 0x0393(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         UseSelfDistance;                                   // 0x0394(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bSucceedIfHasValue;                                // 0x0398(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bMigrated;                                         // 0x0399(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_39A[0x6];                                      // 0x039A(0x0006)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FAIAspectSettings_EnvQuery) == 0x000008, "Wrong alignment on FAIAspectSettings_EnvQuery");
static_assert(sizeof(FAIAspectSettings_EnvQuery) == 0x0003A0, "Wrong size on FAIAspectSettings_EnvQuery");
static_assert(offsetof(FAIAspectSettings_EnvQuery, Query) == 0x000000, "Member 'FAIAspectSettings_EnvQuery::Query' has a wrong offset!");
static_assert(offsetof(FAIAspectSettings_EnvQuery, QueryBlackboardKey) == 0x0000B8, "Member 'FAIAspectSettings_EnvQuery::QueryBlackboardKey' has a wrong offset!");
static_assert(offsetof(FAIAspectSettings_EnvQuery, bRefreshAITreeOnQuerySuccess) == 0x0000C8, "Member 'FAIAspectSettings_EnvQuery::bRefreshAITreeOnQuerySuccess' has a wrong offset!");
static_assert(offsetof(FAIAspectSettings_EnvQuery, bForceRequeryOnSuccess) == 0x0000C9, "Member 'FAIAspectSettings_EnvQuery::bForceRequeryOnSuccess' has a wrong offset!");
static_assert(offsetof(FAIAspectSettings_EnvQuery, bClearQueryOnSuccess) == 0x0000CA, "Member 'FAIAspectSettings_EnvQuery::bClearQueryOnSuccess' has a wrong offset!");
static_assert(offsetof(FAIAspectSettings_EnvQuery, Options) == 0x0000D0, "Member 'FAIAspectSettings_EnvQuery::Options' has a wrong offset!");
static_assert(offsetof(FAIAspectSettings_EnvQuery, Preset) == 0x000308, "Member 'FAIAspectSettings_EnvQuery::Preset' has a wrong offset!");
static_assert(offsetof(FAIAspectSettings_EnvQuery, bUsePreset) == 0x000309, "Member 'FAIAspectSettings_EnvQuery::bUsePreset' has a wrong offset!");
static_assert(offsetof(FAIAspectSettings_EnvQuery, QueryPeriod) == 0x000310, "Member 'FAIAspectSettings_EnvQuery::QueryPeriod' has a wrong offset!");
static_assert(offsetof(FAIAspectSettings_EnvQuery, bQueryContinuously) == 0x000390, "Member 'FAIAspectSettings_EnvQuery::bQueryContinuously' has a wrong offset!");
static_assert(offsetof(FAIAspectSettings_EnvQuery, bUpdateValueWhileRunning) == 0x000391, "Member 'FAIAspectSettings_EnvQuery::bUpdateValueWhileRunning' has a wrong offset!");
static_assert(offsetof(FAIAspectSettings_EnvQuery, bKeepValidValues) == 0x000392, "Member 'FAIAspectSettings_EnvQuery::bKeepValidValues' has a wrong offset!");
static_assert(offsetof(FAIAspectSettings_EnvQuery, bCanUseSelf) == 0x000393, "Member 'FAIAspectSettings_EnvQuery::bCanUseSelf' has a wrong offset!");
static_assert(offsetof(FAIAspectSettings_EnvQuery, UseSelfDistance) == 0x000394, "Member 'FAIAspectSettings_EnvQuery::UseSelfDistance' has a wrong offset!");
static_assert(offsetof(FAIAspectSettings_EnvQuery, bSucceedIfHasValue) == 0x000398, "Member 'FAIAspectSettings_EnvQuery::bSucceedIfHasValue' has a wrong offset!");
static_assert(offsetof(FAIAspectSettings_EnvQuery, bMigrated) == 0x000399, "Member 'FAIAspectSettings_EnvQuery::bMigrated' has a wrong offset!");

// ScriptStruct GbxAI.AIAspectSettings_UseSmartObject
// 0x0478 (0x0478 - 0x0000)
struct FAIAspectSettings_UseSmartObject final
{
public:
	struct FGbxBlackboardKeySelector              SmartAction;                                       // 0x0000(0x0010)(Edit, NoDestructor, NativeAccessSpecifierPublic)
	bool                                          bAbortExisting;                                    // 0x0010(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bUntilInterrupted;                                 // 0x0011(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bCanBeInterrupted;                                 // 0x0012(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_13[0x5];                                       // 0x0013(0x0005)(Fixing Size After Last Property [ Dumper-7 ])
	struct FEnvQueryParams                        SmartObjectQuery;                                  // 0x0018(0x00B8)(ContainsInstancedReference, NativeAccessSpecifierPublic)
	bool                                          bUseQuery;                                         // 0x00D0(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_D1[0x7];                                       // 0x00D1(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	struct FAIAspectSettings_EnvQuery             QuerySettings;                                     // 0x00D8(0x03A0)(ContainsInstancedReference, NativeAccessSpecifierPublic)
};
static_assert(alignof(FAIAspectSettings_UseSmartObject) == 0x000008, "Wrong alignment on FAIAspectSettings_UseSmartObject");
static_assert(sizeof(FAIAspectSettings_UseSmartObject) == 0x000478, "Wrong size on FAIAspectSettings_UseSmartObject");
static_assert(offsetof(FAIAspectSettings_UseSmartObject, SmartAction) == 0x000000, "Member 'FAIAspectSettings_UseSmartObject::SmartAction' has a wrong offset!");
static_assert(offsetof(FAIAspectSettings_UseSmartObject, bAbortExisting) == 0x000010, "Member 'FAIAspectSettings_UseSmartObject::bAbortExisting' has a wrong offset!");
static_assert(offsetof(FAIAspectSettings_UseSmartObject, bUntilInterrupted) == 0x000011, "Member 'FAIAspectSettings_UseSmartObject::bUntilInterrupted' has a wrong offset!");
static_assert(offsetof(FAIAspectSettings_UseSmartObject, bCanBeInterrupted) == 0x000012, "Member 'FAIAspectSettings_UseSmartObject::bCanBeInterrupted' has a wrong offset!");
static_assert(offsetof(FAIAspectSettings_UseSmartObject, SmartObjectQuery) == 0x000018, "Member 'FAIAspectSettings_UseSmartObject::SmartObjectQuery' has a wrong offset!");
static_assert(offsetof(FAIAspectSettings_UseSmartObject, bUseQuery) == 0x0000D0, "Member 'FAIAspectSettings_UseSmartObject::bUseQuery' has a wrong offset!");
static_assert(offsetof(FAIAspectSettings_UseSmartObject, QuerySettings) == 0x0000D8, "Member 'FAIAspectSettings_UseSmartObject::QuerySettings' has a wrong offset!");

// ScriptStruct GbxAI.AIAspectSettings_Charge
// 0x0018 (0x0018 - 0x0000)
struct FAIAspectSettings_Charge final
{
public:
	class UAIChargeData*                          ChargeData;                                        // 0x0000(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FGbxBlackboardKeySelector              Target;                                            // 0x0008(0x0010)(Edit, BlueprintVisible, EditConst, NoDestructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(FAIAspectSettings_Charge) == 0x000008, "Wrong alignment on FAIAspectSettings_Charge");
static_assert(sizeof(FAIAspectSettings_Charge) == 0x000018, "Wrong size on FAIAspectSettings_Charge");
static_assert(offsetof(FAIAspectSettings_Charge, ChargeData) == 0x000000, "Member 'FAIAspectSettings_Charge::ChargeData' has a wrong offset!");
static_assert(offsetof(FAIAspectSettings_Charge, Target) == 0x000008, "Member 'FAIAspectSettings_Charge::Target' has a wrong offset!");

// ScriptStruct GbxAI.AINodeSmartObjectData
// 0x0010 (0x0010 - 0x0000)
struct FAINodeSmartObjectData final
{
public:
	class AActor*                                 Object;                                            // 0x0000(0x0008)(Edit, ZeroConstructor, DisableEditOnTemplate, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         Distance;                                          // 0x0008(0x0004)(Edit, ZeroConstructor, DisableEditOnTemplate, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         Offset;                                            // 0x000C(0x0004)(Edit, ZeroConstructor, DisableEditOnTemplate, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FAINodeSmartObjectData) == 0x000008, "Wrong alignment on FAINodeSmartObjectData");
static_assert(sizeof(FAINodeSmartObjectData) == 0x000010, "Wrong size on FAINodeSmartObjectData");
static_assert(offsetof(FAINodeSmartObjectData, Object) == 0x000000, "Member 'FAINodeSmartObjectData::Object' has a wrong offset!");
static_assert(offsetof(FAINodeSmartObjectData, Distance) == 0x000008, "Member 'FAINodeSmartObjectData::Distance' has a wrong offset!");
static_assert(offsetof(FAINodeSmartObjectData, Offset) == 0x00000C, "Member 'FAINodeSmartObjectData::Offset' has a wrong offset!");

// ScriptStruct GbxAI.AINodeLink
// 0x0020 (0x0020 - 0x0000)
struct FAINodeLink final
{
public:
	float                                         Weight;                                            // 0x0000(0x0004)(Edit, ZeroConstructor, DisableEditOnTemplate, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         PrevWeight;                                        // 0x0004(0x0004)(Edit, ZeroConstructor, DisableEditOnTemplate, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class AActor*                                 Actor;                                             // 0x0008(0x0008)(Edit, ZeroConstructor, DisableEditOnTemplate, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TArray<struct FAINodeSmartObjectData>         SmartObjects;                                      // 0x0010(0x0010)(Edit, ZeroConstructor, DisableEditOnTemplate, EditConst, NativeAccessSpecifierPublic)
};
static_assert(alignof(FAINodeLink) == 0x000008, "Wrong alignment on FAINodeLink");
static_assert(sizeof(FAINodeLink) == 0x000020, "Wrong size on FAINodeLink");
static_assert(offsetof(FAINodeLink, Weight) == 0x000000, "Member 'FAINodeLink::Weight' has a wrong offset!");
static_assert(offsetof(FAINodeLink, PrevWeight) == 0x000004, "Member 'FAINodeLink::PrevWeight' has a wrong offset!");
static_assert(offsetof(FAINodeLink, Actor) == 0x000008, "Member 'FAINodeLink::Actor' has a wrong offset!");
static_assert(offsetof(FAINodeLink, SmartObjects) == 0x000010, "Member 'FAINodeLink::SmartObjects' has a wrong offset!");

// ScriptStruct GbxAI.CoverTransitionTableRow
// 0x0070 (0x0090 - 0x0020)
struct FCoverTransitionTableRow final : public FGbxAnimTableRow
{
public:
	struct FNumericRange                          Angle;                                             // 0x0020(0x0008)(Edit, NoDestructor, NativeAccessSpecifierPublic)
	struct FNumericRange                          Distance;                                          // 0x0028(0x0008)(Edit, NoDestructor, NativeAccessSpecifierPublic)
	float                                         Height;                                            // 0x0030(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	ECoverFaceDirection                           FaceDirection;                                     // 0x0034(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	ECoverSlotHeight                              SlotHeight;                                        // 0x0035(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_36[0x2];                                       // 0x0036(0x0002)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<class UCoverStyleData*>                CoverStyles;                                       // 0x0038(0x0010)(Edit, ZeroConstructor, NativeAccessSpecifierPublic)
	TArray<class UCoverViewData*>                 ViewsFrom;                                         // 0x0048(0x0010)(Edit, ZeroConstructor, NativeAccessSpecifierPublic)
	TArray<class UCoverViewData*>                 ViewsTo;                                           // 0x0058(0x0010)(Edit, ZeroConstructor, NativeAccessSpecifierPublic)
	bool                                          bCornerTransition;                                 // 0x0068(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_69[0x7];                                       // 0x0069(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	class UStanceDataProvider*                    Stance;                                            // 0x0070(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bAutoFill;                                         // 0x0078(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_79[0x3];                                       // 0x0079(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	struct FNumericRange                          AutoFillAngle;                                     // 0x007C(0x0008)(Edit, NoDestructor, NativeAccessSpecifierPublic)
	struct FNumericRange                          AutoFillDistance;                                  // 0x0084(0x0008)(Edit, NoDestructor, NativeAccessSpecifierPublic)
	uint8                                         Pad_8C[0x4];                                       // 0x008C(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FCoverTransitionTableRow) == 0x000008, "Wrong alignment on FCoverTransitionTableRow");
static_assert(sizeof(FCoverTransitionTableRow) == 0x000090, "Wrong size on FCoverTransitionTableRow");
static_assert(offsetof(FCoverTransitionTableRow, Angle) == 0x000020, "Member 'FCoverTransitionTableRow::Angle' has a wrong offset!");
static_assert(offsetof(FCoverTransitionTableRow, Distance) == 0x000028, "Member 'FCoverTransitionTableRow::Distance' has a wrong offset!");
static_assert(offsetof(FCoverTransitionTableRow, Height) == 0x000030, "Member 'FCoverTransitionTableRow::Height' has a wrong offset!");
static_assert(offsetof(FCoverTransitionTableRow, FaceDirection) == 0x000034, "Member 'FCoverTransitionTableRow::FaceDirection' has a wrong offset!");
static_assert(offsetof(FCoverTransitionTableRow, SlotHeight) == 0x000035, "Member 'FCoverTransitionTableRow::SlotHeight' has a wrong offset!");
static_assert(offsetof(FCoverTransitionTableRow, CoverStyles) == 0x000038, "Member 'FCoverTransitionTableRow::CoverStyles' has a wrong offset!");
static_assert(offsetof(FCoverTransitionTableRow, ViewsFrom) == 0x000048, "Member 'FCoverTransitionTableRow::ViewsFrom' has a wrong offset!");
static_assert(offsetof(FCoverTransitionTableRow, ViewsTo) == 0x000058, "Member 'FCoverTransitionTableRow::ViewsTo' has a wrong offset!");
static_assert(offsetof(FCoverTransitionTableRow, bCornerTransition) == 0x000068, "Member 'FCoverTransitionTableRow::bCornerTransition' has a wrong offset!");
static_assert(offsetof(FCoverTransitionTableRow, Stance) == 0x000070, "Member 'FCoverTransitionTableRow::Stance' has a wrong offset!");
static_assert(offsetof(FCoverTransitionTableRow, bAutoFill) == 0x000078, "Member 'FCoverTransitionTableRow::bAutoFill' has a wrong offset!");
static_assert(offsetof(FCoverTransitionTableRow, AutoFillAngle) == 0x00007C, "Member 'FCoverTransitionTableRow::AutoFillAngle' has a wrong offset!");
static_assert(offsetof(FCoverTransitionTableRow, AutoFillDistance) == 0x000084, "Member 'FCoverTransitionTableRow::AutoFillDistance' has a wrong offset!");

// ScriptStruct GbxAI.AIAspectExecutionSettings
// 0x0005 (0x0005 - 0x0000)
struct FAIAspectExecutionSettings final
{
public:
	bool                                          bCanPreventActionFromStarting;                     // 0x0000(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bCanCauseActionToSucceed;                          // 0x0001(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bCanForceActionToSucceed;                          // 0x0002(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bCanCauseActionToFail;                             // 0x0003(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bMustFinish;                                       // 0x0004(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FAIAspectExecutionSettings) == 0x000001, "Wrong alignment on FAIAspectExecutionSettings");
static_assert(sizeof(FAIAspectExecutionSettings) == 0x000005, "Wrong size on FAIAspectExecutionSettings");
static_assert(offsetof(FAIAspectExecutionSettings, bCanPreventActionFromStarting) == 0x000000, "Member 'FAIAspectExecutionSettings::bCanPreventActionFromStarting' has a wrong offset!");
static_assert(offsetof(FAIAspectExecutionSettings, bCanCauseActionToSucceed) == 0x000001, "Member 'FAIAspectExecutionSettings::bCanCauseActionToSucceed' has a wrong offset!");
static_assert(offsetof(FAIAspectExecutionSettings, bCanForceActionToSucceed) == 0x000002, "Member 'FAIAspectExecutionSettings::bCanForceActionToSucceed' has a wrong offset!");
static_assert(offsetof(FAIAspectExecutionSettings, bCanCauseActionToFail) == 0x000003, "Member 'FAIAspectExecutionSettings::bCanCauseActionToFail' has a wrong offset!");
static_assert(offsetof(FAIAspectExecutionSettings, bMustFinish) == 0x000004, "Member 'FAIAspectExecutionSettings::bMustFinish' has a wrong offset!");

// ScriptStruct GbxAI.AIAspectSettings_Route
// 0x0028 (0x0028 - 0x0000)
struct FAIAspectSettings_Route final
{
public:
	struct FGbxBlackboardKeySelector              NodeKey;                                           // 0x0000(0x0010)(Edit, NoDestructor, NativeAccessSpecifierPublic)
	float                                         SegmentDistance;                                   // 0x0010(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         MaxWanderingOffset;                                // 0x0014(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         ArrivalDistance;                                   // 0x0018(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         PerchCooldown;                                     // 0x001C(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bPassiveAction;                                    // 0x0020(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bCombatAction;                                     // 0x0021(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_22[0x6];                                       // 0x0022(0x0006)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FAIAspectSettings_Route) == 0x000008, "Wrong alignment on FAIAspectSettings_Route");
static_assert(sizeof(FAIAspectSettings_Route) == 0x000028, "Wrong size on FAIAspectSettings_Route");
static_assert(offsetof(FAIAspectSettings_Route, NodeKey) == 0x000000, "Member 'FAIAspectSettings_Route::NodeKey' has a wrong offset!");
static_assert(offsetof(FAIAspectSettings_Route, SegmentDistance) == 0x000010, "Member 'FAIAspectSettings_Route::SegmentDistance' has a wrong offset!");
static_assert(offsetof(FAIAspectSettings_Route, MaxWanderingOffset) == 0x000014, "Member 'FAIAspectSettings_Route::MaxWanderingOffset' has a wrong offset!");
static_assert(offsetof(FAIAspectSettings_Route, ArrivalDistance) == 0x000018, "Member 'FAIAspectSettings_Route::ArrivalDistance' has a wrong offset!");
static_assert(offsetof(FAIAspectSettings_Route, PerchCooldown) == 0x00001C, "Member 'FAIAspectSettings_Route::PerchCooldown' has a wrong offset!");
static_assert(offsetof(FAIAspectSettings_Route, bPassiveAction) == 0x000020, "Member 'FAIAspectSettings_Route::bPassiveAction' has a wrong offset!");
static_assert(offsetof(FAIAspectSettings_Route, bCombatAction) == 0x000021, "Member 'FAIAspectSettings_Route::bCombatAction' has a wrong offset!");

// ScriptStruct GbxAI.AIActionSettings_Plan
// 0x0020 (0x0020 - 0x0000)
struct FAIActionSettings_Plan final
{
public:
	TArray<class UAIPlanData*>                    PlansAlwaysAvailableToMe;                          // 0x0000(0x0010)(Edit, ZeroConstructor, NativeAccessSpecifierPublic)
	TArray<struct FGameplayTag>                   RoleTags;                                          // 0x0010(0x0010)(Edit, ZeroConstructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(FAIActionSettings_Plan) == 0x000008, "Wrong alignment on FAIActionSettings_Plan");
static_assert(sizeof(FAIActionSettings_Plan) == 0x000020, "Wrong size on FAIActionSettings_Plan");
static_assert(offsetof(FAIActionSettings_Plan, PlansAlwaysAvailableToMe) == 0x000000, "Member 'FAIActionSettings_Plan::PlansAlwaysAvailableToMe' has a wrong offset!");
static_assert(offsetof(FAIActionSettings_Plan, RoleTags) == 0x000010, "Member 'FAIActionSettings_Plan::RoleTags' has a wrong offset!");

// ScriptStruct GbxAI.AIActionInstance
// 0x0030 (0x0030 - 0x0000)
struct FAIActionInstance final
{
public:
	class UGameplayTask*                          ScriptedGameplayTask;                              // 0x0000(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UAIAction*                              Action;                                            // 0x0008(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_10[0x20];                                      // 0x0010(0x0020)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FAIActionInstance) == 0x000008, "Wrong alignment on FAIActionInstance");
static_assert(sizeof(FAIActionInstance) == 0x000030, "Wrong size on FAIActionInstance");
static_assert(offsetof(FAIActionInstance, ScriptedGameplayTask) == 0x000000, "Member 'FAIActionInstance::ScriptedGameplayTask' has a wrong offset!");
static_assert(offsetof(FAIActionInstance, Action) == 0x000008, "Member 'FAIActionInstance::Action' has a wrong offset!");

// ScriptStruct GbxAI.AITicketHandle
// 0x0010 (0x0010 - 0x0000)
struct FAITicketHandle final
{
public:
	class UAITicketDataAsset*                     Ticket;                                            // 0x0000(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class AGbxAIController*                       AIController;                                      // 0x0008(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FAITicketHandle) == 0x000008, "Wrong alignment on FAITicketHandle");
static_assert(sizeof(FAITicketHandle) == 0x000010, "Wrong size on FAITicketHandle");
static_assert(offsetof(FAITicketHandle, Ticket) == 0x000000, "Member 'FAITicketHandle::Ticket' has a wrong offset!");
static_assert(offsetof(FAITicketHandle, AIController) == 0x000008, "Member 'FAITicketHandle::AIController' has a wrong offset!");

// ScriptStruct GbxAI.AIAspectSettings_Loop
// 0x0198 (0x0198 - 0x0000)
struct FAIAspectSettings_Loop final
{
public:
	struct FGbxParam                              LoopCondition;                                     // 0x0000(0x0080)(Edit, BlueprintVisible, NoDestructor, ContainsInstancedReference, NativeAccessSpecifierPublic)
	bool                                          bUseLoopCondition;                                 // 0x0080(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_81[0x7];                                       // 0x0081(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	struct FGbxParam                              LoopCount;                                         // 0x0088(0x0080)(Edit, BlueprintVisible, NoDestructor, ContainsInstancedReference, NativeAccessSpecifierPublic)
	bool                                          bUseLoopCount;                                     // 0x0108(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_109[0x7];                                      // 0x0109(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	struct FGbxParam                              LoopDuration;                                      // 0x0110(0x0080)(Edit, BlueprintVisible, NoDestructor, ContainsInstancedReference, NativeAccessSpecifierPublic)
	bool                                          bUseLoopDuration;                                  // 0x0190(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bStopImmediately;                                  // 0x0191(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bIgnoreFailure;                                    // 0x0192(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_193[0x5];                                      // 0x0193(0x0005)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FAIAspectSettings_Loop) == 0x000008, "Wrong alignment on FAIAspectSettings_Loop");
static_assert(sizeof(FAIAspectSettings_Loop) == 0x000198, "Wrong size on FAIAspectSettings_Loop");
static_assert(offsetof(FAIAspectSettings_Loop, LoopCondition) == 0x000000, "Member 'FAIAspectSettings_Loop::LoopCondition' has a wrong offset!");
static_assert(offsetof(FAIAspectSettings_Loop, bUseLoopCondition) == 0x000080, "Member 'FAIAspectSettings_Loop::bUseLoopCondition' has a wrong offset!");
static_assert(offsetof(FAIAspectSettings_Loop, LoopCount) == 0x000088, "Member 'FAIAspectSettings_Loop::LoopCount' has a wrong offset!");
static_assert(offsetof(FAIAspectSettings_Loop, bUseLoopCount) == 0x000108, "Member 'FAIAspectSettings_Loop::bUseLoopCount' has a wrong offset!");
static_assert(offsetof(FAIAspectSettings_Loop, LoopDuration) == 0x000110, "Member 'FAIAspectSettings_Loop::LoopDuration' has a wrong offset!");
static_assert(offsetof(FAIAspectSettings_Loop, bUseLoopDuration) == 0x000190, "Member 'FAIAspectSettings_Loop::bUseLoopDuration' has a wrong offset!");
static_assert(offsetof(FAIAspectSettings_Loop, bStopImmediately) == 0x000191, "Member 'FAIAspectSettings_Loop::bStopImmediately' has a wrong offset!");
static_assert(offsetof(FAIAspectSettings_Loop, bIgnoreFailure) == 0x000192, "Member 'FAIAspectSettings_Loop::bIgnoreFailure' has a wrong offset!");

// ScriptStruct GbxAI.AIActionExecutionSettings
// 0x0008 (0x0008 - 0x0000)
struct FAIActionExecutionSettings final
{
public:
	bool                                          bEnabled;                                          // 0x0000(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EAIActionResultTransition                     SuccessTransition;                                 // 0x0001(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EAIActionResultTransition                     FailureTransition;                                 // 0x0002(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bAlwaysReportSuccess;                              // 0x0003(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         CheckCanStartPeriod;                               // 0x0004(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FAIActionExecutionSettings) == 0x000004, "Wrong alignment on FAIActionExecutionSettings");
static_assert(sizeof(FAIActionExecutionSettings) == 0x000008, "Wrong size on FAIActionExecutionSettings");
static_assert(offsetof(FAIActionExecutionSettings, bEnabled) == 0x000000, "Member 'FAIActionExecutionSettings::bEnabled' has a wrong offset!");
static_assert(offsetof(FAIActionExecutionSettings, SuccessTransition) == 0x000001, "Member 'FAIActionExecutionSettings::SuccessTransition' has a wrong offset!");
static_assert(offsetof(FAIActionExecutionSettings, FailureTransition) == 0x000002, "Member 'FAIActionExecutionSettings::FailureTransition' has a wrong offset!");
static_assert(offsetof(FAIActionExecutionSettings, bAlwaysReportSuccess) == 0x000003, "Member 'FAIActionExecutionSettings::bAlwaysReportSuccess' has a wrong offset!");
static_assert(offsetof(FAIActionExecutionSettings, CheckCanStartPeriod) == 0x000004, "Member 'FAIActionExecutionSettings::CheckCanStartPeriod' has a wrong offset!");

// ScriptStruct GbxAI.AIAspectSettings_Move
// 0x0008 (0x0008 - 0x0000)
struct FAIAspectSettings_Move final
{
public:
	float                                         PathUpdateThreshold;                               // 0x0000(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bStopWhenInPosition;                               // 0x0004(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bAllowStrafe;                                      // 0x0005(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bAllowPartialPath;                                 // 0x0006(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bRequireDirectPath;                                // 0x0007(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FAIAspectSettings_Move) == 0x000004, "Wrong alignment on FAIAspectSettings_Move");
static_assert(sizeof(FAIAspectSettings_Move) == 0x000008, "Wrong size on FAIAspectSettings_Move");
static_assert(offsetof(FAIAspectSettings_Move, PathUpdateThreshold) == 0x000000, "Member 'FAIAspectSettings_Move::PathUpdateThreshold' has a wrong offset!");
static_assert(offsetof(FAIAspectSettings_Move, bStopWhenInPosition) == 0x000004, "Member 'FAIAspectSettings_Move::bStopWhenInPosition' has a wrong offset!");
static_assert(offsetof(FAIAspectSettings_Move, bAllowStrafe) == 0x000005, "Member 'FAIAspectSettings_Move::bAllowStrafe' has a wrong offset!");
static_assert(offsetof(FAIAspectSettings_Move, bAllowPartialPath) == 0x000006, "Member 'FAIAspectSettings_Move::bAllowPartialPath' has a wrong offset!");
static_assert(offsetof(FAIAspectSettings_Move, bRequireDirectPath) == 0x000007, "Member 'FAIAspectSettings_Move::bRequireDirectPath' has a wrong offset!");

// ScriptStruct GbxAI.AIAspectSettings_ConditionData
// 0x0090 (0x0090 - 0x0000)
struct FAIAspectSettings_ConditionData final
{
public:
	struct FGbxParam                              Condition;                                         // 0x0000(0x0080)(Edit, BlueprintVisible, NoDestructor, ContainsInstancedReference, NativeAccessSpecifierPublic)
	class UAttributeContextResolver*              ContextResolver;                                   // 0x0080(0x0008)(Edit, BlueprintVisible, ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, PersistentInstance, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bInvertCondition;                                  // 0x0088(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_89[0x7];                                       // 0x0089(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FAIAspectSettings_ConditionData) == 0x000008, "Wrong alignment on FAIAspectSettings_ConditionData");
static_assert(sizeof(FAIAspectSettings_ConditionData) == 0x000090, "Wrong size on FAIAspectSettings_ConditionData");
static_assert(offsetof(FAIAspectSettings_ConditionData, Condition) == 0x000000, "Member 'FAIAspectSettings_ConditionData::Condition' has a wrong offset!");
static_assert(offsetof(FAIAspectSettings_ConditionData, ContextResolver) == 0x000080, "Member 'FAIAspectSettings_ConditionData::ContextResolver' has a wrong offset!");
static_assert(offsetof(FAIAspectSettings_ConditionData, bInvertCondition) == 0x000088, "Member 'FAIAspectSettings_ConditionData::bInvertCondition' has a wrong offset!");

// ScriptStruct GbxAI.ProximitySource
// 0x000C (0x000C - 0x0000)
struct alignas(0x04) FProximitySource final
{
public:
	uint8                                         Pad_0[0xC];                                        // 0x0000(0x000C)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FProximitySource) == 0x000004, "Wrong alignment on FProximitySource");
static_assert(sizeof(FProximitySource) == 0x00000C, "Wrong size on FProximitySource");

// ScriptStruct GbxAI.AIAspectSettings_ActorCollision
// 0x0018 (0x0018 - 0x0000)
struct FAIAspectSettings_ActorCollision final
{
public:
	struct FGbxBlackboardKeySelector              Target;                                            // 0x0000(0x0010)(Edit, BlueprintVisible, NoDestructor, NativeAccessSpecifierPublic)
	EAIActionResultDirective                      OnCollision;                                       // 0x0010(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_11[0x7];                                       // 0x0011(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FAIAspectSettings_ActorCollision) == 0x000008, "Wrong alignment on FAIAspectSettings_ActorCollision");
static_assert(sizeof(FAIAspectSettings_ActorCollision) == 0x000018, "Wrong size on FAIAspectSettings_ActorCollision");
static_assert(offsetof(FAIAspectSettings_ActorCollision, Target) == 0x000000, "Member 'FAIAspectSettings_ActorCollision::Target' has a wrong offset!");
static_assert(offsetof(FAIAspectSettings_ActorCollision, OnCollision) == 0x000010, "Member 'FAIAspectSettings_ActorCollision::OnCollision' has a wrong offset!");

// ScriptStruct GbxAI.AIAspectSettings_AIGroupCondition
// 0x0008 (0x0008 - 0x0000)
struct FAIAspectSettings_AIGroupCondition final
{
public:
	int32                                         FullfillmentQuantity;                              // 0x0000(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bPartialFullfillment;                              // 0x0004(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_5[0x3];                                        // 0x0005(0x0003)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FAIAspectSettings_AIGroupCondition) == 0x000004, "Wrong alignment on FAIAspectSettings_AIGroupCondition");
static_assert(sizeof(FAIAspectSettings_AIGroupCondition) == 0x000008, "Wrong size on FAIAspectSettings_AIGroupCondition");
static_assert(offsetof(FAIAspectSettings_AIGroupCondition, FullfillmentQuantity) == 0x000000, "Member 'FAIAspectSettings_AIGroupCondition::FullfillmentQuantity' has a wrong offset!");
static_assert(offsetof(FAIAspectSettings_AIGroupCondition, bPartialFullfillment) == 0x000004, "Member 'FAIAspectSettings_AIGroupCondition::bPartialFullfillment' has a wrong offset!");

// ScriptStruct GbxAI.AIAspectSettings_BlackboardKey
// 0x0018 (0x0018 - 0x0000)
struct FAIAspectSettings_BlackboardKey final
{
public:
	struct FGbxBlackboardKeySelector              Key;                                               // 0x0000(0x0010)(Edit, BlueprintVisible, NoDestructor, NativeAccessSpecifierPublic)
	bool                                          bInvertResult;                                     // 0x0010(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EAIActionResultDirective                      WhenConditionFails;                                // 0x0011(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EAIActionResult                               OnBecomeFalse;                                     // 0x0012(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bAbortOnChange;                                    // 0x0013(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bRefreshImmediatelyOnChange;                       // 0x0014(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_15[0x3];                                       // 0x0015(0x0003)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FAIAspectSettings_BlackboardKey) == 0x000008, "Wrong alignment on FAIAspectSettings_BlackboardKey");
static_assert(sizeof(FAIAspectSettings_BlackboardKey) == 0x000018, "Wrong size on FAIAspectSettings_BlackboardKey");
static_assert(offsetof(FAIAspectSettings_BlackboardKey, Key) == 0x000000, "Member 'FAIAspectSettings_BlackboardKey::Key' has a wrong offset!");
static_assert(offsetof(FAIAspectSettings_BlackboardKey, bInvertResult) == 0x000010, "Member 'FAIAspectSettings_BlackboardKey::bInvertResult' has a wrong offset!");
static_assert(offsetof(FAIAspectSettings_BlackboardKey, WhenConditionFails) == 0x000011, "Member 'FAIAspectSettings_BlackboardKey::WhenConditionFails' has a wrong offset!");
static_assert(offsetof(FAIAspectSettings_BlackboardKey, OnBecomeFalse) == 0x000012, "Member 'FAIAspectSettings_BlackboardKey::OnBecomeFalse' has a wrong offset!");
static_assert(offsetof(FAIAspectSettings_BlackboardKey, bAbortOnChange) == 0x000013, "Member 'FAIAspectSettings_BlackboardKey::bAbortOnChange' has a wrong offset!");
static_assert(offsetof(FAIAspectSettings_BlackboardKey, bRefreshImmediatelyOnChange) == 0x000014, "Member 'FAIAspectSettings_BlackboardKey::bRefreshImmediatelyOnChange' has a wrong offset!");

// ScriptStruct GbxAI.AIAspectSettings_Condition
// 0x0248 (0x0248 - 0x0000)
struct FAIAspectSettings_Condition final
{
public:
	struct FAIAspectSettings_ConditionData        CanStartCondition;                                 // 0x0000(0x0090)(Edit, BlueprintVisible, NoDestructor, ContainsInstancedReference, NativeAccessSpecifierPublic)
	struct FAIAspectSettings_ConditionData        SucceedCondition;                                  // 0x0090(0x0090)(Edit, BlueprintVisible, NoDestructor, ContainsInstancedReference, NativeAccessSpecifierPublic)
	struct FAIAspectSettings_ConditionData        FailCondition;                                     // 0x0120(0x0090)(Edit, BlueprintVisible, NoDestructor, ContainsInstancedReference, NativeAccessSpecifierPublic)
	struct FAIAspectSettings_ConditionData        CanAbortCondition;                                 // 0x01B0(0x0090)(Edit, BlueprintVisible, NoDestructor, ContainsInstancedReference, NativeAccessSpecifierPublic)
	bool                                          bUseCanStartCondition;                             // 0x0240(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bUseSucceedCondition;                              // 0x0241(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bUseFailCondition;                                 // 0x0242(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bUseCanAbortCondition;                             // 0x0243(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_244[0x4];                                      // 0x0244(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FAIAspectSettings_Condition) == 0x000008, "Wrong alignment on FAIAspectSettings_Condition");
static_assert(sizeof(FAIAspectSettings_Condition) == 0x000248, "Wrong size on FAIAspectSettings_Condition");
static_assert(offsetof(FAIAspectSettings_Condition, CanStartCondition) == 0x000000, "Member 'FAIAspectSettings_Condition::CanStartCondition' has a wrong offset!");
static_assert(offsetof(FAIAspectSettings_Condition, SucceedCondition) == 0x000090, "Member 'FAIAspectSettings_Condition::SucceedCondition' has a wrong offset!");
static_assert(offsetof(FAIAspectSettings_Condition, FailCondition) == 0x000120, "Member 'FAIAspectSettings_Condition::FailCondition' has a wrong offset!");
static_assert(offsetof(FAIAspectSettings_Condition, CanAbortCondition) == 0x0001B0, "Member 'FAIAspectSettings_Condition::CanAbortCondition' has a wrong offset!");
static_assert(offsetof(FAIAspectSettings_Condition, bUseCanStartCondition) == 0x000240, "Member 'FAIAspectSettings_Condition::bUseCanStartCondition' has a wrong offset!");
static_assert(offsetof(FAIAspectSettings_Condition, bUseSucceedCondition) == 0x000241, "Member 'FAIAspectSettings_Condition::bUseSucceedCondition' has a wrong offset!");
static_assert(offsetof(FAIAspectSettings_Condition, bUseFailCondition) == 0x000242, "Member 'FAIAspectSettings_Condition::bUseFailCondition' has a wrong offset!");
static_assert(offsetof(FAIAspectSettings_Condition, bUseCanAbortCondition) == 0x000243, "Member 'FAIAspectSettings_Condition::bUseCanAbortCondition' has a wrong offset!");

// ScriptStruct GbxAI.AIAspectSettings_Sweep
// 0x00A8 (0x00A8 - 0x0000)
struct FAIAspectSettings_Sweep final
{
public:
	struct FGbxBlackboardKeySelector              CenterKey;                                         // 0x0000(0x0010)(Edit, NoDestructor, NativeAccessSpecifierPublic)
	struct FGbxParam                              HeightOffset;                                      // 0x0010(0x0080)(Edit, NoDestructor, ContainsInstancedReference, NativeAccessSpecifierPublic)
	float                                         SweepRadius;                                       // 0x0090(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         SweepAngle;                                        // 0x0094(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         SweepAngleInterval;                                // 0x0098(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	ESweepDirection                               Direction;                                         // 0x009C(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_9D[0x3];                                       // 0x009D(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         SearchRadius;                                      // 0x00A0(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_A4[0x4];                                       // 0x00A4(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FAIAspectSettings_Sweep) == 0x000008, "Wrong alignment on FAIAspectSettings_Sweep");
static_assert(sizeof(FAIAspectSettings_Sweep) == 0x0000A8, "Wrong size on FAIAspectSettings_Sweep");
static_assert(offsetof(FAIAspectSettings_Sweep, CenterKey) == 0x000000, "Member 'FAIAspectSettings_Sweep::CenterKey' has a wrong offset!");
static_assert(offsetof(FAIAspectSettings_Sweep, HeightOffset) == 0x000010, "Member 'FAIAspectSettings_Sweep::HeightOffset' has a wrong offset!");
static_assert(offsetof(FAIAspectSettings_Sweep, SweepRadius) == 0x000090, "Member 'FAIAspectSettings_Sweep::SweepRadius' has a wrong offset!");
static_assert(offsetof(FAIAspectSettings_Sweep, SweepAngle) == 0x000094, "Member 'FAIAspectSettings_Sweep::SweepAngle' has a wrong offset!");
static_assert(offsetof(FAIAspectSettings_Sweep, SweepAngleInterval) == 0x000098, "Member 'FAIAspectSettings_Sweep::SweepAngleInterval' has a wrong offset!");
static_assert(offsetof(FAIAspectSettings_Sweep, Direction) == 0x00009C, "Member 'FAIAspectSettings_Sweep::Direction' has a wrong offset!");
static_assert(offsetof(FAIAspectSettings_Sweep, SearchRadius) == 0x0000A0, "Member 'FAIAspectSettings_Sweep::SearchRadius' has a wrong offset!");

// ScriptStruct GbxAI.AIAspectSettings_IsInRangeData
// 0x0088 (0x0088 - 0x0000)
struct FAIAspectSettings_IsInRangeData final
{
public:
	struct FGbxParam                              Range;                                             // 0x0000(0x0080)(Edit, BlueprintVisible, NoDestructor, ContainsInstancedReference, NativeAccessSpecifierPublic)
	bool                                          bInvertRange;                                      // 0x0080(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_81[0x7];                                       // 0x0081(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FAIAspectSettings_IsInRangeData) == 0x000008, "Wrong alignment on FAIAspectSettings_IsInRangeData");
static_assert(sizeof(FAIAspectSettings_IsInRangeData) == 0x000088, "Wrong size on FAIAspectSettings_IsInRangeData");
static_assert(offsetof(FAIAspectSettings_IsInRangeData, Range) == 0x000000, "Member 'FAIAspectSettings_IsInRangeData::Range' has a wrong offset!");
static_assert(offsetof(FAIAspectSettings_IsInRangeData, bInvertRange) == 0x000080, "Member 'FAIAspectSettings_IsInRangeData::bInvertRange' has a wrong offset!");

// ScriptStruct GbxAI.AIAspectIsInRangeAdvancedData
// 0x01A0 (0x01A0 - 0x0000)
struct FAIAspectIsInRangeAdvancedData final
{
public:
	struct FAIAspectSettings_IsInRangeData        CanStartRange;                                     // 0x0000(0x0088)(Edit, BlueprintVisible, NoDestructor, ContainsInstancedReference, NativeAccessSpecifierPublic)
	struct FAIAspectSettings_IsInRangeData        SucceedRange;                                      // 0x0088(0x0088)(Edit, BlueprintVisible, NoDestructor, ContainsInstancedReference, NativeAccessSpecifierPublic)
	struct FAIAspectSettings_IsInRangeData        FailRange;                                         // 0x0110(0x0088)(Edit, BlueprintVisible, NoDestructor, ContainsInstancedReference, NativeAccessSpecifierPublic)
	bool                                          bUseCanStartRange;                                 // 0x0198(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bUseSucceedRange;                                  // 0x0199(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bUseFailRange;                                     // 0x019A(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_19B[0x5];                                      // 0x019B(0x0005)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FAIAspectIsInRangeAdvancedData) == 0x000008, "Wrong alignment on FAIAspectIsInRangeAdvancedData");
static_assert(sizeof(FAIAspectIsInRangeAdvancedData) == 0x0001A0, "Wrong size on FAIAspectIsInRangeAdvancedData");
static_assert(offsetof(FAIAspectIsInRangeAdvancedData, CanStartRange) == 0x000000, "Member 'FAIAspectIsInRangeAdvancedData::CanStartRange' has a wrong offset!");
static_assert(offsetof(FAIAspectIsInRangeAdvancedData, SucceedRange) == 0x000088, "Member 'FAIAspectIsInRangeAdvancedData::SucceedRange' has a wrong offset!");
static_assert(offsetof(FAIAspectIsInRangeAdvancedData, FailRange) == 0x000110, "Member 'FAIAspectIsInRangeAdvancedData::FailRange' has a wrong offset!");
static_assert(offsetof(FAIAspectIsInRangeAdvancedData, bUseCanStartRange) == 0x000198, "Member 'FAIAspectIsInRangeAdvancedData::bUseCanStartRange' has a wrong offset!");
static_assert(offsetof(FAIAspectIsInRangeAdvancedData, bUseSucceedRange) == 0x000199, "Member 'FAIAspectIsInRangeAdvancedData::bUseSucceedRange' has a wrong offset!");
static_assert(offsetof(FAIAspectIsInRangeAdvancedData, bUseFailRange) == 0x00019A, "Member 'FAIAspectIsInRangeAdvancedData::bUseFailRange' has a wrong offset!");

// ScriptStruct GbxAI.AIAspectSettings_IsInRange
// 0x0248 (0x0248 - 0x0000)
struct FAIAspectSettings_IsInRange final
{
public:
	struct FGbxBlackboardKeySelector              Target;                                            // 0x0000(0x0010)(Edit, BlueprintVisible, NoDestructor, NativeAccessSpecifierPublic)
	EIsInRangeAspectDistanceTest                  DistanceTest;                                      // 0x0010(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_11[0x7];                                       // 0x0011(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	struct FAIAspectSettings_IsInRangeData        CanRunRange;                                       // 0x0018(0x0088)(Edit, BlueprintVisible, NoDestructor, ContainsInstancedReference, NativeAccessSpecifierPublic)
	struct FAIAspectIsInRangeAdvancedData         AdvancedRanges;                                    // 0x00A0(0x01A0)(Edit, BlueprintVisible, NoDestructor, ContainsInstancedReference, NativeAccessSpecifierPublic)
	bool                                          bUseAdvancedRanges;                                // 0x0240(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_241[0x7];                                      // 0x0241(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FAIAspectSettings_IsInRange) == 0x000008, "Wrong alignment on FAIAspectSettings_IsInRange");
static_assert(sizeof(FAIAspectSettings_IsInRange) == 0x000248, "Wrong size on FAIAspectSettings_IsInRange");
static_assert(offsetof(FAIAspectSettings_IsInRange, Target) == 0x000000, "Member 'FAIAspectSettings_IsInRange::Target' has a wrong offset!");
static_assert(offsetof(FAIAspectSettings_IsInRange, DistanceTest) == 0x000010, "Member 'FAIAspectSettings_IsInRange::DistanceTest' has a wrong offset!");
static_assert(offsetof(FAIAspectSettings_IsInRange, CanRunRange) == 0x000018, "Member 'FAIAspectSettings_IsInRange::CanRunRange' has a wrong offset!");
static_assert(offsetof(FAIAspectSettings_IsInRange, AdvancedRanges) == 0x0000A0, "Member 'FAIAspectSettings_IsInRange::AdvancedRanges' has a wrong offset!");
static_assert(offsetof(FAIAspectSettings_IsInRange, bUseAdvancedRanges) == 0x000240, "Member 'FAIAspectSettings_IsInRange::bUseAdvancedRanges' has a wrong offset!");

// ScriptStruct GbxAI.AIAspectSettings_Cooldown
// 0x0220 (0x0220 - 0x0000)
struct FAIAspectSettings_Cooldown final
{
public:
	struct FGbxParam                              SucceedTimer;                                      // 0x0000(0x0080)(Edit, BlueprintVisible, NoDestructor, ContainsInstancedReference, NativeAccessSpecifierPublic)
	bool                                          bUseSucceedTimer;                                  // 0x0080(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_81[0x7];                                       // 0x0081(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	struct FGbxParam                              FailTimer;                                         // 0x0088(0x0080)(Edit, BlueprintVisible, NoDestructor, ContainsInstancedReference, NativeAccessSpecifierPublic)
	bool                                          bUseFailTimer;                                     // 0x0108(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_109[0x7];                                      // 0x0109(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	struct FGbxParam                              AbortTimer;                                        // 0x0110(0x0080)(Edit, BlueprintVisible, NoDestructor, ContainsInstancedReference, NativeAccessSpecifierPublic)
	bool                                          bUseAbortTimer;                                    // 0x0190(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_191[0x7];                                      // 0x0191(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	struct FGbxParam                              InitialTimer;                                      // 0x0198(0x0080)(Edit, BlueprintVisible, NoDestructor, ContainsInstancedReference, NativeAccessSpecifierPublic)
	bool                                          bUseInitialTimer;                                  // 0x0218(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_219[0x7];                                      // 0x0219(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FAIAspectSettings_Cooldown) == 0x000008, "Wrong alignment on FAIAspectSettings_Cooldown");
static_assert(sizeof(FAIAspectSettings_Cooldown) == 0x000220, "Wrong size on FAIAspectSettings_Cooldown");
static_assert(offsetof(FAIAspectSettings_Cooldown, SucceedTimer) == 0x000000, "Member 'FAIAspectSettings_Cooldown::SucceedTimer' has a wrong offset!");
static_assert(offsetof(FAIAspectSettings_Cooldown, bUseSucceedTimer) == 0x000080, "Member 'FAIAspectSettings_Cooldown::bUseSucceedTimer' has a wrong offset!");
static_assert(offsetof(FAIAspectSettings_Cooldown, FailTimer) == 0x000088, "Member 'FAIAspectSettings_Cooldown::FailTimer' has a wrong offset!");
static_assert(offsetof(FAIAspectSettings_Cooldown, bUseFailTimer) == 0x000108, "Member 'FAIAspectSettings_Cooldown::bUseFailTimer' has a wrong offset!");
static_assert(offsetof(FAIAspectSettings_Cooldown, AbortTimer) == 0x000110, "Member 'FAIAspectSettings_Cooldown::AbortTimer' has a wrong offset!");
static_assert(offsetof(FAIAspectSettings_Cooldown, bUseAbortTimer) == 0x000190, "Member 'FAIAspectSettings_Cooldown::bUseAbortTimer' has a wrong offset!");
static_assert(offsetof(FAIAspectSettings_Cooldown, InitialTimer) == 0x000198, "Member 'FAIAspectSettings_Cooldown::InitialTimer' has a wrong offset!");
static_assert(offsetof(FAIAspectSettings_Cooldown, bUseInitialTimer) == 0x000218, "Member 'FAIAspectSettings_Cooldown::bUseInitialTimer' has a wrong offset!");

// ScriptStruct GbxAI.AIAspectSettings_Crouch
// 0x0108 (0x0108 - 0x0000)
struct FAIAspectSettings_Crouch final
{
public:
	struct FGbxParam                              CanCrouchWhileIdle;                                // 0x0000(0x0080)(Edit, BlueprintVisible, NoDestructor, ContainsInstancedReference, NativeAccessSpecifierPublic)
	bool                                          bUseCanCrouchWhileMoving;                          // 0x0080(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_81[0x7];                                       // 0x0081(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	struct FGbxParam                              CanCrouchWhileMoving;                              // 0x0088(0x0080)(Edit, BlueprintVisible, NoDestructor, ContainsInstancedReference, NativeAccessSpecifierPublic)
};
static_assert(alignof(FAIAspectSettings_Crouch) == 0x000008, "Wrong alignment on FAIAspectSettings_Crouch");
static_assert(sizeof(FAIAspectSettings_Crouch) == 0x000108, "Wrong size on FAIAspectSettings_Crouch");
static_assert(offsetof(FAIAspectSettings_Crouch, CanCrouchWhileIdle) == 0x000000, "Member 'FAIAspectSettings_Crouch::CanCrouchWhileIdle' has a wrong offset!");
static_assert(offsetof(FAIAspectSettings_Crouch, bUseCanCrouchWhileMoving) == 0x000080, "Member 'FAIAspectSettings_Crouch::bUseCanCrouchWhileMoving' has a wrong offset!");
static_assert(offsetof(FAIAspectSettings_Crouch, CanCrouchWhileMoving) == 0x000088, "Member 'FAIAspectSettings_Crouch::CanCrouchWhileMoving' has a wrong offset!");

// ScriptStruct GbxAI.AIAspectSettings_DropshipSpawn
// 0x0010 (0x0010 - 0x0000)
struct FAIAspectSettings_DropshipSpawn final
{
public:
	TSubclassOf<class UGbxAction>                 StartAction;                                       // 0x0000(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TSubclassOf<class UGbxAction>                 StopAction;                                        // 0x0008(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FAIAspectSettings_DropshipSpawn) == 0x000008, "Wrong alignment on FAIAspectSettings_DropshipSpawn");
static_assert(sizeof(FAIAspectSettings_DropshipSpawn) == 0x000010, "Wrong size on FAIAspectSettings_DropshipSpawn");
static_assert(offsetof(FAIAspectSettings_DropshipSpawn, StartAction) == 0x000000, "Member 'FAIAspectSettings_DropshipSpawn::StartAction' has a wrong offset!");
static_assert(offsetof(FAIAspectSettings_DropshipSpawn, StopAction) == 0x000008, "Member 'FAIAspectSettings_DropshipSpawn::StopAction' has a wrong offset!");

// ScriptStruct GbxAI.AIAspectSettings_Land
// 0x000C (0x000C - 0x0000)
struct FAIAspectSettings_Land final
{
public:
	float                                         GroundSearchDistance;                              // 0x0000(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         FlySearchDistance;                                 // 0x0004(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         UpdatePeriod;                                      // 0x0008(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FAIAspectSettings_Land) == 0x000004, "Wrong alignment on FAIAspectSettings_Land");
static_assert(sizeof(FAIAspectSettings_Land) == 0x00000C, "Wrong size on FAIAspectSettings_Land");
static_assert(offsetof(FAIAspectSettings_Land, GroundSearchDistance) == 0x000000, "Member 'FAIAspectSettings_Land::GroundSearchDistance' has a wrong offset!");
static_assert(offsetof(FAIAspectSettings_Land, FlySearchDistance) == 0x000004, "Member 'FAIAspectSettings_Land::FlySearchDistance' has a wrong offset!");
static_assert(offsetof(FAIAspectSettings_Land, UpdatePeriod) == 0x000008, "Member 'FAIAspectSettings_Land::UpdatePeriod' has a wrong offset!");

// ScriptStruct GbxAI.AIAspectSettings_Orbit
// 0x0220 (0x0220 - 0x0000)
struct FAIAspectSettings_Orbit final
{
public:
	struct FGbxBlackboardKeySelector              CenterKey;                                         // 0x0000(0x0010)(Edit, NoDestructor, NativeAccessSpecifierPublic)
	struct FGbxParam                              HeightOffset;                                      // 0x0010(0x0080)(Edit, NoDestructor, ContainsInstancedReference, NativeAccessSpecifierPublic)
	struct FGbxParam                              OrbitRadius;                                       // 0x0090(0x0080)(Edit, NoDestructor, ContainsInstancedReference, NativeAccessSpecifierPublic)
	struct FGbxParam                              OrbitAngle;                                        // 0x0110(0x0080)(Edit, NoDestructor, ContainsInstancedReference, NativeAccessSpecifierPublic)
	struct FGbxParam                              OrbitAngleInterval;                                // 0x0190(0x0080)(Edit, NoDestructor, ContainsInstancedReference, NativeAccessSpecifierPublic)
	EOrbitDirection                               Direction;                                         // 0x0210(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_211[0x3];                                      // 0x0211(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         SearchRadius;                                      // 0x0214(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bRespectCombatTerritory;                           // 0x0218(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_219[0x7];                                      // 0x0219(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FAIAspectSettings_Orbit) == 0x000008, "Wrong alignment on FAIAspectSettings_Orbit");
static_assert(sizeof(FAIAspectSettings_Orbit) == 0x000220, "Wrong size on FAIAspectSettings_Orbit");
static_assert(offsetof(FAIAspectSettings_Orbit, CenterKey) == 0x000000, "Member 'FAIAspectSettings_Orbit::CenterKey' has a wrong offset!");
static_assert(offsetof(FAIAspectSettings_Orbit, HeightOffset) == 0x000010, "Member 'FAIAspectSettings_Orbit::HeightOffset' has a wrong offset!");
static_assert(offsetof(FAIAspectSettings_Orbit, OrbitRadius) == 0x000090, "Member 'FAIAspectSettings_Orbit::OrbitRadius' has a wrong offset!");
static_assert(offsetof(FAIAspectSettings_Orbit, OrbitAngle) == 0x000110, "Member 'FAIAspectSettings_Orbit::OrbitAngle' has a wrong offset!");
static_assert(offsetof(FAIAspectSettings_Orbit, OrbitAngleInterval) == 0x000190, "Member 'FAIAspectSettings_Orbit::OrbitAngleInterval' has a wrong offset!");
static_assert(offsetof(FAIAspectSettings_Orbit, Direction) == 0x000210, "Member 'FAIAspectSettings_Orbit::Direction' has a wrong offset!");
static_assert(offsetof(FAIAspectSettings_Orbit, SearchRadius) == 0x000214, "Member 'FAIAspectSettings_Orbit::SearchRadius' has a wrong offset!");
static_assert(offsetof(FAIAspectSettings_Orbit, bRespectCombatTerritory) == 0x000218, "Member 'FAIAspectSettings_Orbit::bRespectCombatTerritory' has a wrong offset!");

// ScriptStruct GbxAI.AIAspectSettings_FlyToNavMesh
// 0x0010 (0x0010 - 0x0000)
struct FAIAspectSettings_FlyToNavMesh final
{
public:
	float                                         GroundSearchDistance;                              // 0x0000(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         LookAheadDistance;                                 // 0x0004(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         FlySearchDistance;                                 // 0x0008(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         UpdatePeriod;                                      // 0x000C(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FAIAspectSettings_FlyToNavMesh) == 0x000004, "Wrong alignment on FAIAspectSettings_FlyToNavMesh");
static_assert(sizeof(FAIAspectSettings_FlyToNavMesh) == 0x000010, "Wrong size on FAIAspectSettings_FlyToNavMesh");
static_assert(offsetof(FAIAspectSettings_FlyToNavMesh, GroundSearchDistance) == 0x000000, "Member 'FAIAspectSettings_FlyToNavMesh::GroundSearchDistance' has a wrong offset!");
static_assert(offsetof(FAIAspectSettings_FlyToNavMesh, LookAheadDistance) == 0x000004, "Member 'FAIAspectSettings_FlyToNavMesh::LookAheadDistance' has a wrong offset!");
static_assert(offsetof(FAIAspectSettings_FlyToNavMesh, FlySearchDistance) == 0x000008, "Member 'FAIAspectSettings_FlyToNavMesh::FlySearchDistance' has a wrong offset!");
static_assert(offsetof(FAIAspectSettings_FlyToNavMesh, UpdatePeriod) == 0x00000C, "Member 'FAIAspectSettings_FlyToNavMesh::UpdatePeriod' has a wrong offset!");

// ScriptStruct GbxAI.AIAspectSettings_RotationChannel
// 0x01B8 (0x01B8 - 0x0000)
struct FAIAspectSettings_RotationChannel final
{
public:
	struct FGbxBlackboardKeySelector              Target;                                            // 0x0000(0x0010)(Edit, BlueprintVisible, NoDestructor, NativeAccessSpecifierPublic)
	struct FVector                                TargetOffset;                                      // 0x0010(0x000C)(Edit, BlueprintVisible, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1C[0x4];                                       // 0x001C(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	struct FGbxParam                              Angle;                                             // 0x0020(0x0080)(Edit, BlueprintVisible, NoDestructor, ContainsInstancedReference, NativeAccessSpecifierPublic)
	bool                                          bUseAngle;                                         // 0x00A0(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_A1[0x7];                                       // 0x00A1(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	struct FGbxParam                              MaxRotateAngle;                                    // 0x00A8(0x0080)(Edit, BlueprintVisible, NoDestructor, ContainsInstancedReference, NativeAccessSpecifierPublic)
	bool                                          bUseMaxRotateAngle;                                // 0x0128(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_129[0x7];                                      // 0x0129(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	struct FGbxParam                              ConditionalEnable;                                 // 0x0130(0x0080)(Edit, BlueprintVisible, NoDestructor, ContainsInstancedReference, NativeAccessSpecifierPublic)
	bool                                          bUseConditionalEnable;                             // 0x01B0(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1B1[0x7];                                      // 0x01B1(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FAIAspectSettings_RotationChannel) == 0x000008, "Wrong alignment on FAIAspectSettings_RotationChannel");
static_assert(sizeof(FAIAspectSettings_RotationChannel) == 0x0001B8, "Wrong size on FAIAspectSettings_RotationChannel");
static_assert(offsetof(FAIAspectSettings_RotationChannel, Target) == 0x000000, "Member 'FAIAspectSettings_RotationChannel::Target' has a wrong offset!");
static_assert(offsetof(FAIAspectSettings_RotationChannel, TargetOffset) == 0x000010, "Member 'FAIAspectSettings_RotationChannel::TargetOffset' has a wrong offset!");
static_assert(offsetof(FAIAspectSettings_RotationChannel, Angle) == 0x000020, "Member 'FAIAspectSettings_RotationChannel::Angle' has a wrong offset!");
static_assert(offsetof(FAIAspectSettings_RotationChannel, bUseAngle) == 0x0000A0, "Member 'FAIAspectSettings_RotationChannel::bUseAngle' has a wrong offset!");
static_assert(offsetof(FAIAspectSettings_RotationChannel, MaxRotateAngle) == 0x0000A8, "Member 'FAIAspectSettings_RotationChannel::MaxRotateAngle' has a wrong offset!");
static_assert(offsetof(FAIAspectSettings_RotationChannel, bUseMaxRotateAngle) == 0x000128, "Member 'FAIAspectSettings_RotationChannel::bUseMaxRotateAngle' has a wrong offset!");
static_assert(offsetof(FAIAspectSettings_RotationChannel, ConditionalEnable) == 0x000130, "Member 'FAIAspectSettings_RotationChannel::ConditionalEnable' has a wrong offset!");
static_assert(offsetof(FAIAspectSettings_RotationChannel, bUseConditionalEnable) == 0x0001B0, "Member 'FAIAspectSettings_RotationChannel::bUseConditionalEnable' has a wrong offset!");

// ScriptStruct GbxAI.AIAspectSettings_Follow
// 0x0038 (0x0038 - 0x0000)
struct FAIAspectSettings_Follow final
{
public:
	struct FGbxBlackboardKeySelector              FollowActorKey;                                    // 0x0000(0x0010)(Edit, NoDestructor, NativeAccessSpecifierPublic)
	struct FNumericRange                          TargetDistance;                                    // 0x0010(0x0008)(Edit, NoDestructor, NativeAccessSpecifierPublic)
	float                                         MaxSpeedScale;                                     // 0x0018(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         MinSpeedScale;                                     // 0x001C(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         GoalUpdatePeriod;                                  // 0x0020(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         InvalidWaitPeriod;                                 // 0x0024(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         TeleportWaitPeriod;                                // 0x0028(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bAllowTeleport;                                    // 0x002C(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2D[0x3];                                       // 0x002D(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         TeleportDistance;                                  // 0x0030(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bTeleportWhenFar;                                  // 0x0034(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bContinueWhileClose;                               // 0x0035(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_36[0x2];                                       // 0x0036(0x0002)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FAIAspectSettings_Follow) == 0x000008, "Wrong alignment on FAIAspectSettings_Follow");
static_assert(sizeof(FAIAspectSettings_Follow) == 0x000038, "Wrong size on FAIAspectSettings_Follow");
static_assert(offsetof(FAIAspectSettings_Follow, FollowActorKey) == 0x000000, "Member 'FAIAspectSettings_Follow::FollowActorKey' has a wrong offset!");
static_assert(offsetof(FAIAspectSettings_Follow, TargetDistance) == 0x000010, "Member 'FAIAspectSettings_Follow::TargetDistance' has a wrong offset!");
static_assert(offsetof(FAIAspectSettings_Follow, MaxSpeedScale) == 0x000018, "Member 'FAIAspectSettings_Follow::MaxSpeedScale' has a wrong offset!");
static_assert(offsetof(FAIAspectSettings_Follow, MinSpeedScale) == 0x00001C, "Member 'FAIAspectSettings_Follow::MinSpeedScale' has a wrong offset!");
static_assert(offsetof(FAIAspectSettings_Follow, GoalUpdatePeriod) == 0x000020, "Member 'FAIAspectSettings_Follow::GoalUpdatePeriod' has a wrong offset!");
static_assert(offsetof(FAIAspectSettings_Follow, InvalidWaitPeriod) == 0x000024, "Member 'FAIAspectSettings_Follow::InvalidWaitPeriod' has a wrong offset!");
static_assert(offsetof(FAIAspectSettings_Follow, TeleportWaitPeriod) == 0x000028, "Member 'FAIAspectSettings_Follow::TeleportWaitPeriod' has a wrong offset!");
static_assert(offsetof(FAIAspectSettings_Follow, bAllowTeleport) == 0x00002C, "Member 'FAIAspectSettings_Follow::bAllowTeleport' has a wrong offset!");
static_assert(offsetof(FAIAspectSettings_Follow, TeleportDistance) == 0x000030, "Member 'FAIAspectSettings_Follow::TeleportDistance' has a wrong offset!");
static_assert(offsetof(FAIAspectSettings_Follow, bTeleportWhenFar) == 0x000034, "Member 'FAIAspectSettings_Follow::bTeleportWhenFar' has a wrong offset!");
static_assert(offsetof(FAIAspectSettings_Follow, bContinueWhileClose) == 0x000035, "Member 'FAIAspectSettings_Follow::bContinueWhileClose' has a wrong offset!");

// ScriptStruct GbxAI.AIAspectSettings_ZeroRotationChannel
// 0x0003 (0x0003 - 0x0000)
struct FAIAspectSettings_ZeroRotationChannel final
{
public:
	bool                                          bZeroPitch;                                        // 0x0000(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bZeroYaw;                                          // 0x0001(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bZeroRoll;                                         // 0x0002(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FAIAspectSettings_ZeroRotationChannel) == 0x000001, "Wrong alignment on FAIAspectSettings_ZeroRotationChannel");
static_assert(sizeof(FAIAspectSettings_ZeroRotationChannel) == 0x000003, "Wrong size on FAIAspectSettings_ZeroRotationChannel");
static_assert(offsetof(FAIAspectSettings_ZeroRotationChannel, bZeroPitch) == 0x000000, "Member 'FAIAspectSettings_ZeroRotationChannel::bZeroPitch' has a wrong offset!");
static_assert(offsetof(FAIAspectSettings_ZeroRotationChannel, bZeroYaw) == 0x000001, "Member 'FAIAspectSettings_ZeroRotationChannel::bZeroYaw' has a wrong offset!");
static_assert(offsetof(FAIAspectSettings_ZeroRotationChannel, bZeroRoll) == 0x000002, "Member 'FAIAspectSettings_ZeroRotationChannel::bZeroRoll' has a wrong offset!");

// ScriptStruct GbxAI.AIAspectSettings_ZeroRotation
// 0x000C (0x000C - 0x0000)
struct FAIAspectSettings_ZeroRotation final
{
public:
	struct FAIAspectSettings_ZeroRotationChannel  Body;                                              // 0x0000(0x0003)(Edit, NoDestructor, NativeAccessSpecifierPublic)
	bool                                          bUseBody;                                          // 0x0003(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FAIAspectSettings_ZeroRotationChannel  Aim;                                               // 0x0004(0x0003)(Edit, NoDestructor, NativeAccessSpecifierPublic)
	bool                                          bUseAim;                                           // 0x0007(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FAIAspectSettings_ZeroRotationChannel  Look;                                              // 0x0008(0x0003)(Edit, NoDestructor, NativeAccessSpecifierPublic)
	bool                                          bUseLook;                                          // 0x000B(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FAIAspectSettings_ZeroRotation) == 0x000001, "Wrong alignment on FAIAspectSettings_ZeroRotation");
static_assert(sizeof(FAIAspectSettings_ZeroRotation) == 0x00000C, "Wrong size on FAIAspectSettings_ZeroRotation");
static_assert(offsetof(FAIAspectSettings_ZeroRotation, Body) == 0x000000, "Member 'FAIAspectSettings_ZeroRotation::Body' has a wrong offset!");
static_assert(offsetof(FAIAspectSettings_ZeroRotation, bUseBody) == 0x000003, "Member 'FAIAspectSettings_ZeroRotation::bUseBody' has a wrong offset!");
static_assert(offsetof(FAIAspectSettings_ZeroRotation, Aim) == 0x000004, "Member 'FAIAspectSettings_ZeroRotation::Aim' has a wrong offset!");
static_assert(offsetof(FAIAspectSettings_ZeroRotation, bUseAim) == 0x000007, "Member 'FAIAspectSettings_ZeroRotation::bUseAim' has a wrong offset!");
static_assert(offsetof(FAIAspectSettings_ZeroRotation, Look) == 0x000008, "Member 'FAIAspectSettings_ZeroRotation::Look' has a wrong offset!");
static_assert(offsetof(FAIAspectSettings_ZeroRotation, bUseLook) == 0x00000B, "Member 'FAIAspectSettings_ZeroRotation::bUseLook' has a wrong offset!");

// ScriptStruct GbxAI.AIAspectSettings_Leap
// 0x0058 (0x0058 - 0x0000)
struct FAIAspectSettings_Leap final
{
public:
	TSubclassOf<class UGbxAction>                 Action;                                            // 0x0000(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FGbxBlackboardKeySelector              Target;                                            // 0x0008(0x0010)(Edit, BlueprintVisible, NoDestructor, NativeAccessSpecifierPublic)
	struct FVector                                LocalOffset;                                       // 0x0018(0x000C)(Edit, BlueprintVisible, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                TargetOffset;                                      // 0x0024(0x000C)(Edit, BlueprintVisible, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   TargetSocket;                                      // 0x0030(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         Speed;                                             // 0x0038(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         AnglePercent;                                      // 0x003C(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         MaxPrediction;                                     // 0x0040(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bDoNavigationTest;                                 // 0x0044(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bDoCollisionTest;                                  // 0x0045(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bAddTargetRadius;                                  // 0x0046(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_47[0x1];                                       // 0x0047(0x0001)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         UseExactLocationDistance;                          // 0x0048(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         TestPeriod;                                        // 0x004C(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bCanStartWhileFalling;                             // 0x0050(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_51[0x7];                                       // 0x0051(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FAIAspectSettings_Leap) == 0x000008, "Wrong alignment on FAIAspectSettings_Leap");
static_assert(sizeof(FAIAspectSettings_Leap) == 0x000058, "Wrong size on FAIAspectSettings_Leap");
static_assert(offsetof(FAIAspectSettings_Leap, Action) == 0x000000, "Member 'FAIAspectSettings_Leap::Action' has a wrong offset!");
static_assert(offsetof(FAIAspectSettings_Leap, Target) == 0x000008, "Member 'FAIAspectSettings_Leap::Target' has a wrong offset!");
static_assert(offsetof(FAIAspectSettings_Leap, LocalOffset) == 0x000018, "Member 'FAIAspectSettings_Leap::LocalOffset' has a wrong offset!");
static_assert(offsetof(FAIAspectSettings_Leap, TargetOffset) == 0x000024, "Member 'FAIAspectSettings_Leap::TargetOffset' has a wrong offset!");
static_assert(offsetof(FAIAspectSettings_Leap, TargetSocket) == 0x000030, "Member 'FAIAspectSettings_Leap::TargetSocket' has a wrong offset!");
static_assert(offsetof(FAIAspectSettings_Leap, Speed) == 0x000038, "Member 'FAIAspectSettings_Leap::Speed' has a wrong offset!");
static_assert(offsetof(FAIAspectSettings_Leap, AnglePercent) == 0x00003C, "Member 'FAIAspectSettings_Leap::AnglePercent' has a wrong offset!");
static_assert(offsetof(FAIAspectSettings_Leap, MaxPrediction) == 0x000040, "Member 'FAIAspectSettings_Leap::MaxPrediction' has a wrong offset!");
static_assert(offsetof(FAIAspectSettings_Leap, bDoNavigationTest) == 0x000044, "Member 'FAIAspectSettings_Leap::bDoNavigationTest' has a wrong offset!");
static_assert(offsetof(FAIAspectSettings_Leap, bDoCollisionTest) == 0x000045, "Member 'FAIAspectSettings_Leap::bDoCollisionTest' has a wrong offset!");
static_assert(offsetof(FAIAspectSettings_Leap, bAddTargetRadius) == 0x000046, "Member 'FAIAspectSettings_Leap::bAddTargetRadius' has a wrong offset!");
static_assert(offsetof(FAIAspectSettings_Leap, UseExactLocationDistance) == 0x000048, "Member 'FAIAspectSettings_Leap::UseExactLocationDistance' has a wrong offset!");
static_assert(offsetof(FAIAspectSettings_Leap, TestPeriod) == 0x00004C, "Member 'FAIAspectSettings_Leap::TestPeriod' has a wrong offset!");
static_assert(offsetof(FAIAspectSettings_Leap, bCanStartWhileFalling) == 0x000050, "Member 'FAIAspectSettings_Leap::bCanStartWhileFalling' has a wrong offset!");

// ScriptStruct GbxAI.AIAspectSettings_GbxAction
// 0x0238 (0x0238 - 0x0000)
struct FAIAspectSettings_GbxAction final
{
public:
	TSubclassOf<class UGbxAction>                 ActionType;                                        // 0x0000(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bUseActionType;                                    // 0x0008(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_9[0x7];                                        // 0x0009(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	struct FGameplayTag                           ActionKey;                                         // 0x0010(0x0008)(Edit, BlueprintVisible, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bUseActionKey;                                     // 0x0018(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_19[0x7];                                       // 0x0019(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	struct FGbxBlackboardKeySelector              ActionBlackboardKey;                               // 0x0020(0x0010)(Edit, BlueprintVisible, NoDestructor, NativeAccessSpecifierPublic)
	bool                                          bUseActionBlackboardKey;                           // 0x0030(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_31[0x7];                                       // 0x0031(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	struct FGbxParam                              Count;                                             // 0x0038(0x0080)(Edit, BlueprintVisible, NoDestructor, ContainsInstancedReference, NativeAccessSpecifierPublic)
	struct FGbxParam                              CanBeInterrupted;                                  // 0x00B8(0x0080)(Edit, BlueprintVisible, NoDestructor, ContainsInstancedReference, NativeAccessSpecifierPublic)
	struct FGbxParam                              CanBeInterruptedOnFailure;                         // 0x0138(0x0080)(Edit, BlueprintVisible, NoDestructor, ContainsInstancedReference, NativeAccessSpecifierPublic)
	struct FGbxParam                              PlayRate;                                          // 0x01B8(0x0080)(Edit, BlueprintVisible, NoDestructor, ContainsInstancedReference, NativeAccessSpecifierPublic)
};
static_assert(alignof(FAIAspectSettings_GbxAction) == 0x000008, "Wrong alignment on FAIAspectSettings_GbxAction");
static_assert(sizeof(FAIAspectSettings_GbxAction) == 0x000238, "Wrong size on FAIAspectSettings_GbxAction");
static_assert(offsetof(FAIAspectSettings_GbxAction, ActionType) == 0x000000, "Member 'FAIAspectSettings_GbxAction::ActionType' has a wrong offset!");
static_assert(offsetof(FAIAspectSettings_GbxAction, bUseActionType) == 0x000008, "Member 'FAIAspectSettings_GbxAction::bUseActionType' has a wrong offset!");
static_assert(offsetof(FAIAspectSettings_GbxAction, ActionKey) == 0x000010, "Member 'FAIAspectSettings_GbxAction::ActionKey' has a wrong offset!");
static_assert(offsetof(FAIAspectSettings_GbxAction, bUseActionKey) == 0x000018, "Member 'FAIAspectSettings_GbxAction::bUseActionKey' has a wrong offset!");
static_assert(offsetof(FAIAspectSettings_GbxAction, ActionBlackboardKey) == 0x000020, "Member 'FAIAspectSettings_GbxAction::ActionBlackboardKey' has a wrong offset!");
static_assert(offsetof(FAIAspectSettings_GbxAction, bUseActionBlackboardKey) == 0x000030, "Member 'FAIAspectSettings_GbxAction::bUseActionBlackboardKey' has a wrong offset!");
static_assert(offsetof(FAIAspectSettings_GbxAction, Count) == 0x000038, "Member 'FAIAspectSettings_GbxAction::Count' has a wrong offset!");
static_assert(offsetof(FAIAspectSettings_GbxAction, CanBeInterrupted) == 0x0000B8, "Member 'FAIAspectSettings_GbxAction::CanBeInterrupted' has a wrong offset!");
static_assert(offsetof(FAIAspectSettings_GbxAction, CanBeInterruptedOnFailure) == 0x000138, "Member 'FAIAspectSettings_GbxAction::CanBeInterruptedOnFailure' has a wrong offset!");
static_assert(offsetof(FAIAspectSettings_GbxAction, PlayRate) == 0x0001B8, "Member 'FAIAspectSettings_GbxAction::PlayRate' has a wrong offset!");

// ScriptStruct GbxAI.AIAspectSettings_GroupLocation
// 0x0098 (0x0098 - 0x0000)
struct FAIAspectSettings_GroupLocation final
{
public:
	struct FGbxBlackboardKeySelector              GroupLocationKey;                                  // 0x0000(0x0010)(Edit, BlueprintVisible, NoDestructor, NativeAccessSpecifierPublic)
	struct FGbxParam                              GroupDistance;                                     // 0x0010(0x0080)(Edit, BlueprintVisible, NoDestructor, ContainsInstancedReference, NativeAccessSpecifierPublic)
	float                                         UpdatePeriod;                                      // 0x0090(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bUpdateWhileActive;                                // 0x0094(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_95[0x3];                                       // 0x0095(0x0003)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FAIAspectSettings_GroupLocation) == 0x000008, "Wrong alignment on FAIAspectSettings_GroupLocation");
static_assert(sizeof(FAIAspectSettings_GroupLocation) == 0x000098, "Wrong size on FAIAspectSettings_GroupLocation");
static_assert(offsetof(FAIAspectSettings_GroupLocation, GroupLocationKey) == 0x000000, "Member 'FAIAspectSettings_GroupLocation::GroupLocationKey' has a wrong offset!");
static_assert(offsetof(FAIAspectSettings_GroupLocation, GroupDistance) == 0x000010, "Member 'FAIAspectSettings_GroupLocation::GroupDistance' has a wrong offset!");
static_assert(offsetof(FAIAspectSettings_GroupLocation, UpdatePeriod) == 0x000090, "Member 'FAIAspectSettings_GroupLocation::UpdatePeriod' has a wrong offset!");
static_assert(offsetof(FAIAspectSettings_GroupLocation, bUpdateWhileActive) == 0x000094, "Member 'FAIAspectSettings_GroupLocation::bUpdateWhileActive' has a wrong offset!");

// ScriptStruct GbxAI.AIAspectSettings_Stance
// 0x0010 (0x0010 - 0x0000)
struct FAIAspectSettings_Stance final
{
public:
	class UStanceDataProvider*                    Stance;                                            // 0x0000(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bOverrideBlueprint;                                // 0x0008(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_9[0x7];                                        // 0x0009(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FAIAspectSettings_Stance) == 0x000008, "Wrong alignment on FAIAspectSettings_Stance");
static_assert(sizeof(FAIAspectSettings_Stance) == 0x000010, "Wrong size on FAIAspectSettings_Stance");
static_assert(offsetof(FAIAspectSettings_Stance, Stance) == 0x000000, "Member 'FAIAspectSettings_Stance::Stance' has a wrong offset!");
static_assert(offsetof(FAIAspectSettings_Stance, bOverrideBlueprint) == 0x000008, "Member 'FAIAspectSettings_Stance::bOverrideBlueprint' has a wrong offset!");

// ScriptStruct GbxAI.AIAspectSettings_IntCompare
// 0x00A0 (0x00A0 - 0x0000)
struct FAIAspectSettings_IntCompare final
{
public:
	struct FGbxBlackboardKeySelector              Key;                                               // 0x0000(0x0010)(Edit, BlueprintVisible, NoDestructor, NativeAccessSpecifierPublic)
	EAIActionResultDirective                      WhenConditionFails;                                // 0x0010(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	ECompareMethod                                CompareMethod;                                     // 0x0011(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_12[0x6];                                       // 0x0012(0x0006)(Fixing Size After Last Property [ Dumper-7 ])
	struct FGbxParam                              CompareAgainst;                                    // 0x0018(0x0080)(Edit, BlueprintVisible, NoDestructor, ContainsInstancedReference, NativeAccessSpecifierPublic)
	bool                                          bAbortOnChange;                                    // 0x0098(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bRefreshImmediatelyOnChange;                       // 0x0099(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_9A[0x6];                                       // 0x009A(0x0006)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FAIAspectSettings_IntCompare) == 0x000008, "Wrong alignment on FAIAspectSettings_IntCompare");
static_assert(sizeof(FAIAspectSettings_IntCompare) == 0x0000A0, "Wrong size on FAIAspectSettings_IntCompare");
static_assert(offsetof(FAIAspectSettings_IntCompare, Key) == 0x000000, "Member 'FAIAspectSettings_IntCompare::Key' has a wrong offset!");
static_assert(offsetof(FAIAspectSettings_IntCompare, WhenConditionFails) == 0x000010, "Member 'FAIAspectSettings_IntCompare::WhenConditionFails' has a wrong offset!");
static_assert(offsetof(FAIAspectSettings_IntCompare, CompareMethod) == 0x000011, "Member 'FAIAspectSettings_IntCompare::CompareMethod' has a wrong offset!");
static_assert(offsetof(FAIAspectSettings_IntCompare, CompareAgainst) == 0x000018, "Member 'FAIAspectSettings_IntCompare::CompareAgainst' has a wrong offset!");
static_assert(offsetof(FAIAspectSettings_IntCompare, bAbortOnChange) == 0x000098, "Member 'FAIAspectSettings_IntCompare::bAbortOnChange' has a wrong offset!");
static_assert(offsetof(FAIAspectSettings_IntCompare, bRefreshImmediatelyOnChange) == 0x000099, "Member 'FAIAspectSettings_IntCompare::bRefreshImmediatelyOnChange' has a wrong offset!");

// ScriptStruct GbxAI.AIAspectSettings_Swoop
// 0x0320 (0x0320 - 0x0000)
struct FAIAspectSettings_Swoop final
{
public:
	struct FGbxBlackboardKeySelector              CenterKey;                                         // 0x0000(0x0010)(Edit, NoDestructor, NativeAccessSpecifierPublic)
	struct FGbxParam                              FarDistance;                                       // 0x0010(0x0080)(Edit, NoDestructor, ContainsInstancedReference, NativeAccessSpecifierPublic)
	struct FGbxParam                              FarHeight;                                         // 0x0090(0x0080)(Edit, NoDestructor, ContainsInstancedReference, NativeAccessSpecifierPublic)
	struct FGbxParam                              NearDistance;                                      // 0x0110(0x0080)(Edit, NoDestructor, ContainsInstancedReference, NativeAccessSpecifierPublic)
	struct FGbxParam                              NearHeight;                                        // 0x0190(0x0080)(Edit, NoDestructor, ContainsInstancedReference, NativeAccessSpecifierPublic)
	struct FGbxParam                              PassDistance;                                      // 0x0210(0x0080)(Edit, NoDestructor, ContainsInstancedReference, NativeAccessSpecifierPublic)
	struct FGbxParam                              PassHeight;                                        // 0x0290(0x0080)(Edit, NoDestructor, ContainsInstancedReference, NativeAccessSpecifierPublic)
	float                                         SearchRadius;                                      // 0x0310(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bLimitSearchRadius;                                // 0x0314(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_315[0x3];                                      // 0x0315(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         UpdatePeriod;                                      // 0x0318(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_31C[0x4];                                      // 0x031C(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FAIAspectSettings_Swoop) == 0x000008, "Wrong alignment on FAIAspectSettings_Swoop");
static_assert(sizeof(FAIAspectSettings_Swoop) == 0x000320, "Wrong size on FAIAspectSettings_Swoop");
static_assert(offsetof(FAIAspectSettings_Swoop, CenterKey) == 0x000000, "Member 'FAIAspectSettings_Swoop::CenterKey' has a wrong offset!");
static_assert(offsetof(FAIAspectSettings_Swoop, FarDistance) == 0x000010, "Member 'FAIAspectSettings_Swoop::FarDistance' has a wrong offset!");
static_assert(offsetof(FAIAspectSettings_Swoop, FarHeight) == 0x000090, "Member 'FAIAspectSettings_Swoop::FarHeight' has a wrong offset!");
static_assert(offsetof(FAIAspectSettings_Swoop, NearDistance) == 0x000110, "Member 'FAIAspectSettings_Swoop::NearDistance' has a wrong offset!");
static_assert(offsetof(FAIAspectSettings_Swoop, NearHeight) == 0x000190, "Member 'FAIAspectSettings_Swoop::NearHeight' has a wrong offset!");
static_assert(offsetof(FAIAspectSettings_Swoop, PassDistance) == 0x000210, "Member 'FAIAspectSettings_Swoop::PassDistance' has a wrong offset!");
static_assert(offsetof(FAIAspectSettings_Swoop, PassHeight) == 0x000290, "Member 'FAIAspectSettings_Swoop::PassHeight' has a wrong offset!");
static_assert(offsetof(FAIAspectSettings_Swoop, SearchRadius) == 0x000310, "Member 'FAIAspectSettings_Swoop::SearchRadius' has a wrong offset!");
static_assert(offsetof(FAIAspectSettings_Swoop, bLimitSearchRadius) == 0x000314, "Member 'FAIAspectSettings_Swoop::bLimitSearchRadius' has a wrong offset!");
static_assert(offsetof(FAIAspectSettings_Swoop, UpdatePeriod) == 0x000318, "Member 'FAIAspectSettings_Swoop::UpdatePeriod' has a wrong offset!");

// ScriptStruct GbxAI.AIAspectSettings_IsInTerritory
// 0x0018 (0x0018 - 0x0000)
struct FAIAspectSettings_IsInTerritory final
{
public:
	struct FGbxBlackboardKeySelector              GoalKey;                                           // 0x0000(0x0010)(Edit, NoDestructor, NativeAccessSpecifierPublic)
	ETerritoryType                                TerritoryArea;                                     // 0x0010(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_11[0x3];                                       // 0x0011(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         TimeThreshold;                                     // 0x0014(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FAIAspectSettings_IsInTerritory) == 0x000008, "Wrong alignment on FAIAspectSettings_IsInTerritory");
static_assert(sizeof(FAIAspectSettings_IsInTerritory) == 0x000018, "Wrong size on FAIAspectSettings_IsInTerritory");
static_assert(offsetof(FAIAspectSettings_IsInTerritory, GoalKey) == 0x000000, "Member 'FAIAspectSettings_IsInTerritory::GoalKey' has a wrong offset!");
static_assert(offsetof(FAIAspectSettings_IsInTerritory, TerritoryArea) == 0x000010, "Member 'FAIAspectSettings_IsInTerritory::TerritoryArea' has a wrong offset!");
static_assert(offsetof(FAIAspectSettings_IsInTerritory, TimeThreshold) == 0x000014, "Member 'FAIAspectSettings_IsInTerritory::TimeThreshold' has a wrong offset!");

// ScriptStruct GbxAI.AIAspectSettings_LeadRoute
// 0x0050 (0x0050 - 0x0000)
struct FAIAspectSettings_LeadRoute final
{
public:
	struct FGbxBlackboardKeySelector              LeadActorKey;                                      // 0x0000(0x0010)(Edit, NoDestructor, NativeAccessSpecifierPublic)
	struct FGbxBlackboardKeySelector              DestinationNodeKey;                                // 0x0010(0x0010)(Edit, NoDestructor, NativeAccessSpecifierPublic)
	float                                         SegmentDistance;                                   // 0x0020(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         MaxWanderingOffset;                                // 0x0024(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         ArrivalDistance;                                   // 0x0028(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FNumericRange                          TargetRouteDistance;                               // 0x002C(0x0008)(Edit, NoDestructor, NativeAccessSpecifierPublic)
	struct FNumericRange                          SpeedScaleRange;                                   // 0x0034(0x0008)(Edit, NoDestructor, NativeAccessSpecifierPublic)
	float                                         RouteOffsetFromTarget;                             // 0x003C(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         TeleportDist;                                      // 0x0040(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bAllowBackwards;                                   // 0x0044(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bAllowTeleport;                                    // 0x0045(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_46[0x2];                                       // 0x0046(0x0002)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         FindNavRadius;                                     // 0x0048(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_4C[0x4];                                       // 0x004C(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FAIAspectSettings_LeadRoute) == 0x000008, "Wrong alignment on FAIAspectSettings_LeadRoute");
static_assert(sizeof(FAIAspectSettings_LeadRoute) == 0x000050, "Wrong size on FAIAspectSettings_LeadRoute");
static_assert(offsetof(FAIAspectSettings_LeadRoute, LeadActorKey) == 0x000000, "Member 'FAIAspectSettings_LeadRoute::LeadActorKey' has a wrong offset!");
static_assert(offsetof(FAIAspectSettings_LeadRoute, DestinationNodeKey) == 0x000010, "Member 'FAIAspectSettings_LeadRoute::DestinationNodeKey' has a wrong offset!");
static_assert(offsetof(FAIAspectSettings_LeadRoute, SegmentDistance) == 0x000020, "Member 'FAIAspectSettings_LeadRoute::SegmentDistance' has a wrong offset!");
static_assert(offsetof(FAIAspectSettings_LeadRoute, MaxWanderingOffset) == 0x000024, "Member 'FAIAspectSettings_LeadRoute::MaxWanderingOffset' has a wrong offset!");
static_assert(offsetof(FAIAspectSettings_LeadRoute, ArrivalDistance) == 0x000028, "Member 'FAIAspectSettings_LeadRoute::ArrivalDistance' has a wrong offset!");
static_assert(offsetof(FAIAspectSettings_LeadRoute, TargetRouteDistance) == 0x00002C, "Member 'FAIAspectSettings_LeadRoute::TargetRouteDistance' has a wrong offset!");
static_assert(offsetof(FAIAspectSettings_LeadRoute, SpeedScaleRange) == 0x000034, "Member 'FAIAspectSettings_LeadRoute::SpeedScaleRange' has a wrong offset!");
static_assert(offsetof(FAIAspectSettings_LeadRoute, RouteOffsetFromTarget) == 0x00003C, "Member 'FAIAspectSettings_LeadRoute::RouteOffsetFromTarget' has a wrong offset!");
static_assert(offsetof(FAIAspectSettings_LeadRoute, TeleportDist) == 0x000040, "Member 'FAIAspectSettings_LeadRoute::TeleportDist' has a wrong offset!");
static_assert(offsetof(FAIAspectSettings_LeadRoute, bAllowBackwards) == 0x000044, "Member 'FAIAspectSettings_LeadRoute::bAllowBackwards' has a wrong offset!");
static_assert(offsetof(FAIAspectSettings_LeadRoute, bAllowTeleport) == 0x000045, "Member 'FAIAspectSettings_LeadRoute::bAllowTeleport' has a wrong offset!");
static_assert(offsetof(FAIAspectSettings_LeadRoute, FindNavRadius) == 0x000048, "Member 'FAIAspectSettings_LeadRoute::FindNavRadius' has a wrong offset!");

// ScriptStruct GbxAI.AIAspectSettings_Location
// 0x01E0 (0x01E0 - 0x0000)
struct FAIAspectSettings_Location final
{
public:
	struct FGbxBlackboardKeySelector              Target;                                            // 0x0000(0x0010)(Edit, BlueprintVisible, NoDestructor, NativeAccessSpecifierPublic)
	EAIActionResultTransition                     TargetChangeTransition;                            // 0x0010(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_11[0x7];                                       // 0x0011(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	struct FGbxParam                              Distance;                                          // 0x0018(0x0080)(Edit, BlueprintVisible, NoDestructor, ContainsInstancedReference, NativeAccessSpecifierPublic)
	struct FEnvQueryParams                        TargetQuery;                                       // 0x0098(0x00B8)(Edit, BlueprintVisible, ContainsInstancedReference, NativeAccessSpecifierPublic)
	struct FGbxParam                              TargetQueryPeriod;                                 // 0x0150(0x0080)(Edit, BlueprintVisible, NoDestructor, ContainsInstancedReference, NativeAccessSpecifierPublic)
	bool                                          bUseTargetQuery;                                   // 0x01D0(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1D1[0x3];                                      // 0x01D1(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	struct FAIAspectSettings_Move                 MoveSettings;                                      // 0x01D4(0x0008)(Edit, BlueprintVisible, NoDestructor, NativeAccessSpecifierPublic)
	bool                                          bCanMove;                                          // 0x01DC(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1DD[0x3];                                      // 0x01DD(0x0003)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FAIAspectSettings_Location) == 0x000008, "Wrong alignment on FAIAspectSettings_Location");
static_assert(sizeof(FAIAspectSettings_Location) == 0x0001E0, "Wrong size on FAIAspectSettings_Location");
static_assert(offsetof(FAIAspectSettings_Location, Target) == 0x000000, "Member 'FAIAspectSettings_Location::Target' has a wrong offset!");
static_assert(offsetof(FAIAspectSettings_Location, TargetChangeTransition) == 0x000010, "Member 'FAIAspectSettings_Location::TargetChangeTransition' has a wrong offset!");
static_assert(offsetof(FAIAspectSettings_Location, Distance) == 0x000018, "Member 'FAIAspectSettings_Location::Distance' has a wrong offset!");
static_assert(offsetof(FAIAspectSettings_Location, TargetQuery) == 0x000098, "Member 'FAIAspectSettings_Location::TargetQuery' has a wrong offset!");
static_assert(offsetof(FAIAspectSettings_Location, TargetQueryPeriod) == 0x000150, "Member 'FAIAspectSettings_Location::TargetQueryPeriod' has a wrong offset!");
static_assert(offsetof(FAIAspectSettings_Location, bUseTargetQuery) == 0x0001D0, "Member 'FAIAspectSettings_Location::bUseTargetQuery' has a wrong offset!");
static_assert(offsetof(FAIAspectSettings_Location, MoveSettings) == 0x0001D4, "Member 'FAIAspectSettings_Location::MoveSettings' has a wrong offset!");
static_assert(offsetof(FAIAspectSettings_Location, bCanMove) == 0x0001DC, "Member 'FAIAspectSettings_Location::bCanMove' has a wrong offset!");

// ScriptStruct GbxAI.CloakCondition
// 0x0010 (0x0010 - 0x0000)
struct FCloakCondition final
{
public:
	class UGbxCondition*                          Condition;                                         // 0x0000(0x0008)(Edit, ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, PersistentInstance, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bCloaked;                                          // 0x0008(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_9[0x7];                                        // 0x0009(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FCloakCondition) == 0x000008, "Wrong alignment on FCloakCondition");
static_assert(sizeof(FCloakCondition) == 0x000010, "Wrong size on FCloakCondition");
static_assert(offsetof(FCloakCondition, Condition) == 0x000000, "Member 'FCloakCondition::Condition' has a wrong offset!");
static_assert(offsetof(FCloakCondition, bCloaked) == 0x000008, "Member 'FCloakCondition::bCloaked' has a wrong offset!");

// ScriptStruct GbxAI.LookAroundRandomlySettings
// 0x000C (0x000C - 0x0000)
struct FLookAroundRandomlySettings final
{
public:
	float                                         MinAngleChangeEachIterationDeg;                    // 0x0000(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         MaxAngleChangeEachIterationDeg;                    // 0x0004(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         MaxTimeSpentEachScan;                              // 0x0008(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FLookAroundRandomlySettings) == 0x000004, "Wrong alignment on FLookAroundRandomlySettings");
static_assert(sizeof(FLookAroundRandomlySettings) == 0x00000C, "Wrong size on FLookAroundRandomlySettings");
static_assert(offsetof(FLookAroundRandomlySettings, MinAngleChangeEachIterationDeg) == 0x000000, "Member 'FLookAroundRandomlySettings::MinAngleChangeEachIterationDeg' has a wrong offset!");
static_assert(offsetof(FLookAroundRandomlySettings, MaxAngleChangeEachIterationDeg) == 0x000004, "Member 'FLookAroundRandomlySettings::MaxAngleChangeEachIterationDeg' has a wrong offset!");
static_assert(offsetof(FLookAroundRandomlySettings, MaxTimeSpentEachScan) == 0x000008, "Member 'FLookAroundRandomlySettings::MaxTimeSpentEachScan' has a wrong offset!");

// ScriptStruct GbxAI.AIAspectSettings_MoveSpline
// 0x0050 (0x0050 - 0x0000)
struct FAIAspectSettings_MoveSpline final
{
public:
	struct FGbxBlackboardKeySelector              SplineKey;                                         // 0x0000(0x0010)(Edit, NoDestructor, NativeAccessSpecifierPublic)
	struct FGbxBlackboardKeySelector              OffsetKey;                                         // 0x0010(0x0010)(Edit, NoDestructor, NativeAccessSpecifierPublic)
	struct FGbxBlackboardKeySelector              ReverseKey;                                        // 0x0020(0x0010)(Edit, NoDestructor, NativeAccessSpecifierPublic)
	float                                         LookDistance;                                      // 0x0030(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         MissNavigationStep;                                // 0x0034(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         MissNavigationStepDistance;                        // 0x0038(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         AdditionnalLookDistanceSpeedFactor;                // 0x003C(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         SnapToNavigation;                                  // 0x0040(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bSnapToNavigation;                                 // 0x0044(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_45[0x3];                                       // 0x0045(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         GoalUpdateDistance;                                // 0x0048(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EGbxNavGoalReach                              Reach;                                             // 0x004C(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_4D[0x3];                                       // 0x004D(0x0003)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FAIAspectSettings_MoveSpline) == 0x000008, "Wrong alignment on FAIAspectSettings_MoveSpline");
static_assert(sizeof(FAIAspectSettings_MoveSpline) == 0x000050, "Wrong size on FAIAspectSettings_MoveSpline");
static_assert(offsetof(FAIAspectSettings_MoveSpline, SplineKey) == 0x000000, "Member 'FAIAspectSettings_MoveSpline::SplineKey' has a wrong offset!");
static_assert(offsetof(FAIAspectSettings_MoveSpline, OffsetKey) == 0x000010, "Member 'FAIAspectSettings_MoveSpline::OffsetKey' has a wrong offset!");
static_assert(offsetof(FAIAspectSettings_MoveSpline, ReverseKey) == 0x000020, "Member 'FAIAspectSettings_MoveSpline::ReverseKey' has a wrong offset!");
static_assert(offsetof(FAIAspectSettings_MoveSpline, LookDistance) == 0x000030, "Member 'FAIAspectSettings_MoveSpline::LookDistance' has a wrong offset!");
static_assert(offsetof(FAIAspectSettings_MoveSpline, MissNavigationStep) == 0x000034, "Member 'FAIAspectSettings_MoveSpline::MissNavigationStep' has a wrong offset!");
static_assert(offsetof(FAIAspectSettings_MoveSpline, MissNavigationStepDistance) == 0x000038, "Member 'FAIAspectSettings_MoveSpline::MissNavigationStepDistance' has a wrong offset!");
static_assert(offsetof(FAIAspectSettings_MoveSpline, AdditionnalLookDistanceSpeedFactor) == 0x00003C, "Member 'FAIAspectSettings_MoveSpline::AdditionnalLookDistanceSpeedFactor' has a wrong offset!");
static_assert(offsetof(FAIAspectSettings_MoveSpline, SnapToNavigation) == 0x000040, "Member 'FAIAspectSettings_MoveSpline::SnapToNavigation' has a wrong offset!");
static_assert(offsetof(FAIAspectSettings_MoveSpline, bSnapToNavigation) == 0x000044, "Member 'FAIAspectSettings_MoveSpline::bSnapToNavigation' has a wrong offset!");
static_assert(offsetof(FAIAspectSettings_MoveSpline, GoalUpdateDistance) == 0x000048, "Member 'FAIAspectSettings_MoveSpline::GoalUpdateDistance' has a wrong offset!");
static_assert(offsetof(FAIAspectSettings_MoveSpline, Reach) == 0x00004C, "Member 'FAIAspectSettings_MoveSpline::Reach' has a wrong offset!");

// ScriptStruct GbxAI.AIAspectSettings_NavFlyOffset
// 0x0120 (0x0120 - 0x0000)
struct FAIAspectSettings_NavFlyOffset final
{
public:
	struct FGbxBlackboardKeySelector              CenterKey;                                         // 0x0000(0x0010)(Edit, NoDestructor, NativeAccessSpecifierPublic)
	struct FGbxParam                              Distance;                                          // 0x0010(0x0080)(Edit, NoDestructor, ContainsInstancedReference, NativeAccessSpecifierPublic)
	struct FGbxParam                              Height;                                            // 0x0090(0x0080)(Edit, NoDestructor, ContainsInstancedReference, NativeAccessSpecifierPublic)
	float                                         SearchRadius;                                      // 0x0110(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bLimitSearchRadius;                                // 0x0114(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_115[0x3];                                      // 0x0115(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         UpdatePeriod;                                      // 0x0118(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         bForward;                                          // 0x011C(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FAIAspectSettings_NavFlyOffset) == 0x000008, "Wrong alignment on FAIAspectSettings_NavFlyOffset");
static_assert(sizeof(FAIAspectSettings_NavFlyOffset) == 0x000120, "Wrong size on FAIAspectSettings_NavFlyOffset");
static_assert(offsetof(FAIAspectSettings_NavFlyOffset, CenterKey) == 0x000000, "Member 'FAIAspectSettings_NavFlyOffset::CenterKey' has a wrong offset!");
static_assert(offsetof(FAIAspectSettings_NavFlyOffset, Distance) == 0x000010, "Member 'FAIAspectSettings_NavFlyOffset::Distance' has a wrong offset!");
static_assert(offsetof(FAIAspectSettings_NavFlyOffset, Height) == 0x000090, "Member 'FAIAspectSettings_NavFlyOffset::Height' has a wrong offset!");
static_assert(offsetof(FAIAspectSettings_NavFlyOffset, SearchRadius) == 0x000110, "Member 'FAIAspectSettings_NavFlyOffset::SearchRadius' has a wrong offset!");
static_assert(offsetof(FAIAspectSettings_NavFlyOffset, bLimitSearchRadius) == 0x000114, "Member 'FAIAspectSettings_NavFlyOffset::bLimitSearchRadius' has a wrong offset!");
static_assert(offsetof(FAIAspectSettings_NavFlyOffset, UpdatePeriod) == 0x000118, "Member 'FAIAspectSettings_NavFlyOffset::UpdatePeriod' has a wrong offset!");
static_assert(offsetof(FAIAspectSettings_NavFlyOffset, bForward) == 0x00011C, "Member 'FAIAspectSettings_NavFlyOffset::bForward' has a wrong offset!");

// ScriptStruct GbxAI.AIAspectSettings_NavigationAdvanced
// 0x0038 (0x0038 - 0x0000)
struct FAIAspectSettings_NavigationAdvanced final
{
public:
	bool                                          bCanMove;                                          // 0x0000(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bReachedRequiresDirect;                            // 0x0001(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EGbxStrafeType                                StrafeType;                                        // 0x0002(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EGbxPathType                                  PathType;                                          // 0x0003(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bStopWhenReached;                                  // 0x0004(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bCanRunWhenAtGoal;                                 // 0x0005(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bUpdateGoalWhileRunning;                           // 0x0006(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_7[0x1];                                        // 0x0007(0x0001)(Fixing Size After Last Property [ Dumper-7 ])
	EGbxNavGoalCheats                             Cheats;                                            // 0x0008(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FGbxNavGoalModifiers                   GoalModifiers;                                     // 0x000C(0x0028)(Edit, BlueprintVisible, NoDestructor, NativeAccessSpecifierPublic)
	bool                                          bCanStartWhenGoalIsUncertain;                      // 0x0034(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bMoveEvenIfUnreachable;                            // 0x0035(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_36[0x2];                                       // 0x0036(0x0002)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FAIAspectSettings_NavigationAdvanced) == 0x000004, "Wrong alignment on FAIAspectSettings_NavigationAdvanced");
static_assert(sizeof(FAIAspectSettings_NavigationAdvanced) == 0x000038, "Wrong size on FAIAspectSettings_NavigationAdvanced");
static_assert(offsetof(FAIAspectSettings_NavigationAdvanced, bCanMove) == 0x000000, "Member 'FAIAspectSettings_NavigationAdvanced::bCanMove' has a wrong offset!");
static_assert(offsetof(FAIAspectSettings_NavigationAdvanced, bReachedRequiresDirect) == 0x000001, "Member 'FAIAspectSettings_NavigationAdvanced::bReachedRequiresDirect' has a wrong offset!");
static_assert(offsetof(FAIAspectSettings_NavigationAdvanced, StrafeType) == 0x000002, "Member 'FAIAspectSettings_NavigationAdvanced::StrafeType' has a wrong offset!");
static_assert(offsetof(FAIAspectSettings_NavigationAdvanced, PathType) == 0x000003, "Member 'FAIAspectSettings_NavigationAdvanced::PathType' has a wrong offset!");
static_assert(offsetof(FAIAspectSettings_NavigationAdvanced, bStopWhenReached) == 0x000004, "Member 'FAIAspectSettings_NavigationAdvanced::bStopWhenReached' has a wrong offset!");
static_assert(offsetof(FAIAspectSettings_NavigationAdvanced, bCanRunWhenAtGoal) == 0x000005, "Member 'FAIAspectSettings_NavigationAdvanced::bCanRunWhenAtGoal' has a wrong offset!");
static_assert(offsetof(FAIAspectSettings_NavigationAdvanced, bUpdateGoalWhileRunning) == 0x000006, "Member 'FAIAspectSettings_NavigationAdvanced::bUpdateGoalWhileRunning' has a wrong offset!");
static_assert(offsetof(FAIAspectSettings_NavigationAdvanced, Cheats) == 0x000008, "Member 'FAIAspectSettings_NavigationAdvanced::Cheats' has a wrong offset!");
static_assert(offsetof(FAIAspectSettings_NavigationAdvanced, GoalModifiers) == 0x00000C, "Member 'FAIAspectSettings_NavigationAdvanced::GoalModifiers' has a wrong offset!");
static_assert(offsetof(FAIAspectSettings_NavigationAdvanced, bCanStartWhenGoalIsUncertain) == 0x000034, "Member 'FAIAspectSettings_NavigationAdvanced::bCanStartWhenGoalIsUncertain' has a wrong offset!");
static_assert(offsetof(FAIAspectSettings_NavigationAdvanced, bMoveEvenIfUnreachable) == 0x000035, "Member 'FAIAspectSettings_NavigationAdvanced::bMoveEvenIfUnreachable' has a wrong offset!");

// ScriptStruct GbxAI.AIAspectSettings_Navigation
// 0x0140 (0x0140 - 0x0000)
struct FAIAspectSettings_Navigation final
{
public:
	struct FGbxParam                              ReachedHeight;                                     // 0x0000(0x0080)(Edit, BlueprintVisible, NoDestructor, ContainsInstancedReference, NativeAccessSpecifierPublic)
	struct FGbxParam                              ReachedDistance;                                   // 0x0080(0x0080)(Edit, BlueprintVisible, NoDestructor, ContainsInstancedReference, NativeAccessSpecifierPublic)
	struct FAIAspectSettings_NavigationAdvanced   Advanced;                                          // 0x0100(0x0038)(Edit, BlueprintVisible, NoDestructor, NativeAccessSpecifierPublic)
	bool                                          bCanMove;                                          // 0x0138(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	bool                                          bReachedRequiresDirect;                            // 0x0139(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	EGbxStrafeType                                StrafeType;                                        // 0x013A(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	EGbxPathType                                  PathType;                                          // 0x013B(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	bool                                          bStopWhenReached;                                  // 0x013C(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	bool                                          bCanRunWhenAtGoal;                                 // 0x013D(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	bool                                          bUpdateGoalWhileRunning;                           // 0x013E(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_13F[0x1];                                      // 0x013F(0x0001)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FAIAspectSettings_Navigation) == 0x000008, "Wrong alignment on FAIAspectSettings_Navigation");
static_assert(sizeof(FAIAspectSettings_Navigation) == 0x000140, "Wrong size on FAIAspectSettings_Navigation");
static_assert(offsetof(FAIAspectSettings_Navigation, ReachedHeight) == 0x000000, "Member 'FAIAspectSettings_Navigation::ReachedHeight' has a wrong offset!");
static_assert(offsetof(FAIAspectSettings_Navigation, ReachedDistance) == 0x000080, "Member 'FAIAspectSettings_Navigation::ReachedDistance' has a wrong offset!");
static_assert(offsetof(FAIAspectSettings_Navigation, Advanced) == 0x000100, "Member 'FAIAspectSettings_Navigation::Advanced' has a wrong offset!");
static_assert(offsetof(FAIAspectSettings_Navigation, bCanMove) == 0x000138, "Member 'FAIAspectSettings_Navigation::bCanMove' has a wrong offset!");
static_assert(offsetof(FAIAspectSettings_Navigation, bReachedRequiresDirect) == 0x000139, "Member 'FAIAspectSettings_Navigation::bReachedRequiresDirect' has a wrong offset!");
static_assert(offsetof(FAIAspectSettings_Navigation, StrafeType) == 0x00013A, "Member 'FAIAspectSettings_Navigation::StrafeType' has a wrong offset!");
static_assert(offsetof(FAIAspectSettings_Navigation, PathType) == 0x00013B, "Member 'FAIAspectSettings_Navigation::PathType' has a wrong offset!");
static_assert(offsetof(FAIAspectSettings_Navigation, bStopWhenReached) == 0x00013C, "Member 'FAIAspectSettings_Navigation::bStopWhenReached' has a wrong offset!");
static_assert(offsetof(FAIAspectSettings_Navigation, bCanRunWhenAtGoal) == 0x00013D, "Member 'FAIAspectSettings_Navigation::bCanRunWhenAtGoal' has a wrong offset!");
static_assert(offsetof(FAIAspectSettings_Navigation, bUpdateGoalWhileRunning) == 0x00013E, "Member 'FAIAspectSettings_Navigation::bUpdateGoalWhileRunning' has a wrong offset!");

// ScriptStruct GbxAI.AIAspectSettings_Plan
// 0x0020 (0x0020 - 0x0000)
struct FAIAspectSettings_Plan final
{
public:
	TArray<class UAIPlanData*>                    PlansAlwaysAvailableToMe;                          // 0x0000(0x0010)(Edit, ZeroConstructor, NativeAccessSpecifierPublic)
	TArray<struct FGameplayTag>                   RoleTags;                                          // 0x0010(0x0010)(Edit, ZeroConstructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(FAIAspectSettings_Plan) == 0x000008, "Wrong alignment on FAIAspectSettings_Plan");
static_assert(sizeof(FAIAspectSettings_Plan) == 0x000020, "Wrong size on FAIAspectSettings_Plan");
static_assert(offsetof(FAIAspectSettings_Plan, PlansAlwaysAvailableToMe) == 0x000000, "Member 'FAIAspectSettings_Plan::PlansAlwaysAvailableToMe' has a wrong offset!");
static_assert(offsetof(FAIAspectSettings_Plan, RoleTags) == 0x000010, "Member 'FAIAspectSettings_Plan::RoleTags' has a wrong offset!");

// ScriptStruct GbxAI.AIAspectSettings_Rotation
// 0x0550 (0x0550 - 0x0000)
struct FAIAspectSettings_Rotation final
{
public:
	bool                                          bCanRotate;                                        // 0x0000(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bTrackTargetOverTime;                              // 0x0001(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EAIAspectSettingsDefaults_Rotation_BodyHeadingOffset BodyHeadingOffsetPresets;                          // 0x0002(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_3[0x1];                                        // 0x0003(0x0001)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         BodyHeadingOffset;                                 // 0x0004(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EAIAspectSettingsDefaults_Rotation            PremadeSettings;                                   // 0x0008(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_9[0x7];                                        // 0x0009(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	struct FAIAspectSettings_RotationChannel      Body;                                              // 0x0010(0x01B8)(Edit, BlueprintVisible, NoDestructor, ContainsInstancedReference, NativeAccessSpecifierPublic)
	bool                                          bUseBody;                                          // 0x01C8(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1C9[0x7];                                      // 0x01C9(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	struct FAIAspectSettings_RotationChannel      Aim;                                               // 0x01D0(0x01B8)(Edit, BlueprintVisible, NoDestructor, ContainsInstancedReference, NativeAccessSpecifierPublic)
	bool                                          bUseAim;                                           // 0x0388(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_389[0x7];                                      // 0x0389(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	struct FAIAspectSettings_RotationChannel      Look;                                              // 0x0390(0x01B8)(Edit, BlueprintVisible, NoDestructor, ContainsInstancedReference, NativeAccessSpecifierPublic)
	bool                                          bUseLook;                                          // 0x0548(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bKeepFacingTargetOnStop;                           // 0x0549(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_54A[0x6];                                      // 0x054A(0x0006)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FAIAspectSettings_Rotation) == 0x000008, "Wrong alignment on FAIAspectSettings_Rotation");
static_assert(sizeof(FAIAspectSettings_Rotation) == 0x000550, "Wrong size on FAIAspectSettings_Rotation");
static_assert(offsetof(FAIAspectSettings_Rotation, bCanRotate) == 0x000000, "Member 'FAIAspectSettings_Rotation::bCanRotate' has a wrong offset!");
static_assert(offsetof(FAIAspectSettings_Rotation, bTrackTargetOverTime) == 0x000001, "Member 'FAIAspectSettings_Rotation::bTrackTargetOverTime' has a wrong offset!");
static_assert(offsetof(FAIAspectSettings_Rotation, BodyHeadingOffsetPresets) == 0x000002, "Member 'FAIAspectSettings_Rotation::BodyHeadingOffsetPresets' has a wrong offset!");
static_assert(offsetof(FAIAspectSettings_Rotation, BodyHeadingOffset) == 0x000004, "Member 'FAIAspectSettings_Rotation::BodyHeadingOffset' has a wrong offset!");
static_assert(offsetof(FAIAspectSettings_Rotation, PremadeSettings) == 0x000008, "Member 'FAIAspectSettings_Rotation::PremadeSettings' has a wrong offset!");
static_assert(offsetof(FAIAspectSettings_Rotation, Body) == 0x000010, "Member 'FAIAspectSettings_Rotation::Body' has a wrong offset!");
static_assert(offsetof(FAIAspectSettings_Rotation, bUseBody) == 0x0001C8, "Member 'FAIAspectSettings_Rotation::bUseBody' has a wrong offset!");
static_assert(offsetof(FAIAspectSettings_Rotation, Aim) == 0x0001D0, "Member 'FAIAspectSettings_Rotation::Aim' has a wrong offset!");
static_assert(offsetof(FAIAspectSettings_Rotation, bUseAim) == 0x000388, "Member 'FAIAspectSettings_Rotation::bUseAim' has a wrong offset!");
static_assert(offsetof(FAIAspectSettings_Rotation, Look) == 0x000390, "Member 'FAIAspectSettings_Rotation::Look' has a wrong offset!");
static_assert(offsetof(FAIAspectSettings_Rotation, bUseLook) == 0x000548, "Member 'FAIAspectSettings_Rotation::bUseLook' has a wrong offset!");
static_assert(offsetof(FAIAspectSettings_Rotation, bKeepFacingTargetOnStop) == 0x000549, "Member 'FAIAspectSettings_Rotation::bKeepFacingTargetOnStop' has a wrong offset!");

// ScriptStruct GbxAI.CoverFaceDirections
// 0x0003 (0x0003 - 0x0000)
struct FCoverFaceDirections final
{
public:
	ECoverFaceDirection                           Low;                                               // 0x0000(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	ECoverFaceDirection                           HighLeft;                                          // 0x0001(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	ECoverFaceDirection                           HighRight;                                         // 0x0002(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FCoverFaceDirections) == 0x000001, "Wrong alignment on FCoverFaceDirections");
static_assert(sizeof(FCoverFaceDirections) == 0x000003, "Wrong size on FCoverFaceDirections");
static_assert(offsetof(FCoverFaceDirections, Low) == 0x000000, "Member 'FCoverFaceDirections::Low' has a wrong offset!");
static_assert(offsetof(FCoverFaceDirections, HighLeft) == 0x000001, "Member 'FCoverFaceDirections::HighLeft' has a wrong offset!");
static_assert(offsetof(FCoverFaceDirections, HighRight) == 0x000002, "Member 'FCoverFaceDirections::HighRight' has a wrong offset!");

// ScriptStruct GbxAI.AIAspectSettings_Teleport
// 0x0138 (0x0138 - 0x0000)
struct FAIAspectSettings_Teleport final
{
public:
	struct FGbxBlackboardKeySelector              GoalKey;                                           // 0x0000(0x0010)(Edit, NoDestructor, NativeAccessSpecifierPublic)
	bool                                          bCloak;                                            // 0x0010(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bTraceToGround;                                    // 0x0011(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bClearVelocity;                                    // 0x0012(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bChangeRotation;                                   // 0x0013(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bClearGoalOnStop;                                  // 0x0014(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_15[0x3];                                       // 0x0015(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	struct FGbxBlackboardKeySelector              RotationKey;                                       // 0x0018(0x0010)(Edit, NoDestructor, NativeAccessSpecifierPublic)
	struct FGbxParam                              TravelTime;                                        // 0x0028(0x0080)(Edit, NoDestructor, ContainsInstancedReference, NativeAccessSpecifierPublic)
	bool                                          bUseSpeedInsteadOfTime;                            // 0x00A8(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_A9[0x7];                                       // 0x00A9(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	struct FGbxParam                              TravelSpeed;                                       // 0x00B0(0x0080)(Edit, NoDestructor, ContainsInstancedReference, NativeAccessSpecifierPublic)
	bool                                          bUpdateGoal;                                       // 0x0130(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_131[0x7];                                      // 0x0131(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FAIAspectSettings_Teleport) == 0x000008, "Wrong alignment on FAIAspectSettings_Teleport");
static_assert(sizeof(FAIAspectSettings_Teleport) == 0x000138, "Wrong size on FAIAspectSettings_Teleport");
static_assert(offsetof(FAIAspectSettings_Teleport, GoalKey) == 0x000000, "Member 'FAIAspectSettings_Teleport::GoalKey' has a wrong offset!");
static_assert(offsetof(FAIAspectSettings_Teleport, bCloak) == 0x000010, "Member 'FAIAspectSettings_Teleport::bCloak' has a wrong offset!");
static_assert(offsetof(FAIAspectSettings_Teleport, bTraceToGround) == 0x000011, "Member 'FAIAspectSettings_Teleport::bTraceToGround' has a wrong offset!");
static_assert(offsetof(FAIAspectSettings_Teleport, bClearVelocity) == 0x000012, "Member 'FAIAspectSettings_Teleport::bClearVelocity' has a wrong offset!");
static_assert(offsetof(FAIAspectSettings_Teleport, bChangeRotation) == 0x000013, "Member 'FAIAspectSettings_Teleport::bChangeRotation' has a wrong offset!");
static_assert(offsetof(FAIAspectSettings_Teleport, bClearGoalOnStop) == 0x000014, "Member 'FAIAspectSettings_Teleport::bClearGoalOnStop' has a wrong offset!");
static_assert(offsetof(FAIAspectSettings_Teleport, RotationKey) == 0x000018, "Member 'FAIAspectSettings_Teleport::RotationKey' has a wrong offset!");
static_assert(offsetof(FAIAspectSettings_Teleport, TravelTime) == 0x000028, "Member 'FAIAspectSettings_Teleport::TravelTime' has a wrong offset!");
static_assert(offsetof(FAIAspectSettings_Teleport, bUseSpeedInsteadOfTime) == 0x0000A8, "Member 'FAIAspectSettings_Teleport::bUseSpeedInsteadOfTime' has a wrong offset!");
static_assert(offsetof(FAIAspectSettings_Teleport, TravelSpeed) == 0x0000B0, "Member 'FAIAspectSettings_Teleport::TravelSpeed' has a wrong offset!");
static_assert(offsetof(FAIAspectSettings_Teleport, bUpdateGoal) == 0x000130, "Member 'FAIAspectSettings_Teleport::bUpdateGoal' has a wrong offset!");

// ScriptStruct GbxAI.AIAspectSettings_TimedCondition
// 0x0118 (0x0118 - 0x0000)
struct FAIAspectSettings_TimedCondition final
{
public:
	struct FAIAspectSettings_ConditionData        Condition;                                         // 0x0000(0x0090)(Edit, BlueprintVisible, NoDestructor, ContainsInstancedReference, NativeAccessSpecifierPublic)
	struct FGbxParam                              Timer;                                             // 0x0090(0x0080)(Edit, BlueprintVisible, NoDestructor, ContainsInstancedReference, NativeAccessSpecifierPublic)
	EAIActionResultDirective                      WhenConditionFails;                                // 0x0110(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EAIActionResult                               FalseResult;                                       // 0x0111(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_112[0x6];                                      // 0x0112(0x0006)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FAIAspectSettings_TimedCondition) == 0x000008, "Wrong alignment on FAIAspectSettings_TimedCondition");
static_assert(sizeof(FAIAspectSettings_TimedCondition) == 0x000118, "Wrong size on FAIAspectSettings_TimedCondition");
static_assert(offsetof(FAIAspectSettings_TimedCondition, Condition) == 0x000000, "Member 'FAIAspectSettings_TimedCondition::Condition' has a wrong offset!");
static_assert(offsetof(FAIAspectSettings_TimedCondition, Timer) == 0x000090, "Member 'FAIAspectSettings_TimedCondition::Timer' has a wrong offset!");
static_assert(offsetof(FAIAspectSettings_TimedCondition, WhenConditionFails) == 0x000110, "Member 'FAIAspectSettings_TimedCondition::WhenConditionFails' has a wrong offset!");
static_assert(offsetof(FAIAspectSettings_TimedCondition, FalseResult) == 0x000111, "Member 'FAIAspectSettings_TimedCondition::FalseResult' has a wrong offset!");

// ScriptStruct GbxAI.AIAspectSettings_TimeLimit
// 0x0108 (0x0108 - 0x0000)
struct FAIAspectSettings_TimeLimit final
{
public:
	struct FGbxParam                              SucceedTime;                                       // 0x0000(0x0080)(Edit, BlueprintVisible, NoDestructor, ContainsInstancedReference, NativeAccessSpecifierPublic)
	struct FGbxParam                              FailTime;                                          // 0x0080(0x0080)(Edit, BlueprintVisible, NoDestructor, ContainsInstancedReference, NativeAccessSpecifierPublic)
	bool                                          bUseSucceedTime;                                   // 0x0100(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bUseFailTime;                                      // 0x0101(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_102[0x6];                                      // 0x0102(0x0006)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FAIAspectSettings_TimeLimit) == 0x000008, "Wrong alignment on FAIAspectSettings_TimeLimit");
static_assert(sizeof(FAIAspectSettings_TimeLimit) == 0x000108, "Wrong size on FAIAspectSettings_TimeLimit");
static_assert(offsetof(FAIAspectSettings_TimeLimit, SucceedTime) == 0x000000, "Member 'FAIAspectSettings_TimeLimit::SucceedTime' has a wrong offset!");
static_assert(offsetof(FAIAspectSettings_TimeLimit, FailTime) == 0x000080, "Member 'FAIAspectSettings_TimeLimit::FailTime' has a wrong offset!");
static_assert(offsetof(FAIAspectSettings_TimeLimit, bUseSucceedTime) == 0x000100, "Member 'FAIAspectSettings_TimeLimit::bUseSucceedTime' has a wrong offset!");
static_assert(offsetof(FAIAspectSettings_TimeLimit, bUseFailTime) == 0x000101, "Member 'FAIAspectSettings_TimeLimit::bUseFailTime' has a wrong offset!");

// ScriptStruct GbxAI.CloakRepData
// 0x0002 (0x0002 - 0x0000)
struct FCloakRepData final
{
public:
	bool                                          bCloaked;                                          // 0x0000(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bCanPlayActions;                                   // 0x0001(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FCloakRepData) == 0x000001, "Wrong alignment on FCloakRepData");
static_assert(sizeof(FCloakRepData) == 0x000002, "Wrong size on FCloakRepData");
static_assert(offsetof(FCloakRepData, bCloaked) == 0x000000, "Member 'FCloakRepData::bCloaked' has a wrong offset!");
static_assert(offsetof(FCloakRepData, bCanPlayActions) == 0x000001, "Member 'FCloakRepData::bCanPlayActions' has a wrong offset!");

// ScriptStruct GbxAI.AITicketManager
// 0x2718 (0x2718 - 0x0000)
struct alignas(0x08) FAITicketManager final
{
public:
	uint8                                         Pad_0[0x2718];                                     // 0x0000(0x2718)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FAITicketManager) == 0x000008, "Wrong alignment on FAITicketManager");
static_assert(sizeof(FAITicketManager) == 0x002718, "Wrong size on FAITicketManager");

// ScriptStruct GbxAI.AIAspectSettings_Timer
// 0x04C8 (0x04C8 - 0x0000)
struct FAIAspectSettings_Timer final
{
public:
	struct FGbxParam                              CanStartWarmup;                                    // 0x0000(0x0080)(Edit, BlueprintVisible, NoDestructor, ContainsInstancedReference, NativeAccessSpecifierPublic)
	bool                                          bUseCanStartWarmup;                                // 0x0080(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_81[0x7];                                       // 0x0081(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	struct FGbxParam                              SpawnedWarmup;                                     // 0x0088(0x0080)(Edit, BlueprintVisible, NoDestructor, ContainsInstancedReference, NativeAccessSpecifierPublic)
	bool                                          bUseSpawnedWarmup;                                 // 0x0108(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_109[0x7];                                      // 0x0109(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	struct FGbxParam                              CombatStartedWarmup;                               // 0x0110(0x0080)(Edit, BlueprintVisible, NoDestructor, ContainsInstancedReference, NativeAccessSpecifierPublic)
	bool                                          bUseCombatStartedWarmup;                           // 0x0190(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_191[0x7];                                      // 0x0191(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	struct FGbxParam                              TargetChangedWarmup;                               // 0x0198(0x0080)(Edit, BlueprintVisible, NoDestructor, ContainsInstancedReference, NativeAccessSpecifierPublic)
	bool                                          bUseTargetChangedWarmup;                           // 0x0218(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_219[0x7];                                      // 0x0219(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	struct FGbxParam                              SucceededCooldown;                                 // 0x0220(0x0080)(Edit, BlueprintVisible, NoDestructor, ContainsInstancedReference, NativeAccessSpecifierPublic)
	bool                                          bUseSucceededCooldown;                             // 0x02A0(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2A1[0x7];                                      // 0x02A1(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	struct FGbxParam                              FailedCooldown;                                    // 0x02A8(0x0080)(Edit, BlueprintVisible, NoDestructor, ContainsInstancedReference, NativeAccessSpecifierPublic)
	bool                                          bUseFailedCooldown;                                // 0x0328(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_329[0x7];                                      // 0x0329(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	struct FGbxParam                              AbortedCooldown;                                   // 0x0330(0x0080)(Edit, BlueprintVisible, NoDestructor, ContainsInstancedReference, NativeAccessSpecifierPublic)
	bool                                          bUseAbortedCooldown;                               // 0x03B0(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_3B1[0x7];                                      // 0x03B1(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	struct FGbxParam                              SucceedTimeLimit;                                  // 0x03B8(0x0080)(Edit, BlueprintVisible, NoDestructor, ContainsInstancedReference, NativeAccessSpecifierPublic)
	bool                                          bUseSucceedTimeLimit;                              // 0x0438(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_439[0x7];                                      // 0x0439(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	struct FGbxParam                              FailTimeLimit;                                     // 0x0440(0x0080)(Edit, BlueprintVisible, NoDestructor, ContainsInstancedReference, NativeAccessSpecifierPublic)
	bool                                          bUseFailTimeLimit;                                 // 0x04C0(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_4C1[0x7];                                      // 0x04C1(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FAIAspectSettings_Timer) == 0x000008, "Wrong alignment on FAIAspectSettings_Timer");
static_assert(sizeof(FAIAspectSettings_Timer) == 0x0004C8, "Wrong size on FAIAspectSettings_Timer");
static_assert(offsetof(FAIAspectSettings_Timer, CanStartWarmup) == 0x000000, "Member 'FAIAspectSettings_Timer::CanStartWarmup' has a wrong offset!");
static_assert(offsetof(FAIAspectSettings_Timer, bUseCanStartWarmup) == 0x000080, "Member 'FAIAspectSettings_Timer::bUseCanStartWarmup' has a wrong offset!");
static_assert(offsetof(FAIAspectSettings_Timer, SpawnedWarmup) == 0x000088, "Member 'FAIAspectSettings_Timer::SpawnedWarmup' has a wrong offset!");
static_assert(offsetof(FAIAspectSettings_Timer, bUseSpawnedWarmup) == 0x000108, "Member 'FAIAspectSettings_Timer::bUseSpawnedWarmup' has a wrong offset!");
static_assert(offsetof(FAIAspectSettings_Timer, CombatStartedWarmup) == 0x000110, "Member 'FAIAspectSettings_Timer::CombatStartedWarmup' has a wrong offset!");
static_assert(offsetof(FAIAspectSettings_Timer, bUseCombatStartedWarmup) == 0x000190, "Member 'FAIAspectSettings_Timer::bUseCombatStartedWarmup' has a wrong offset!");
static_assert(offsetof(FAIAspectSettings_Timer, TargetChangedWarmup) == 0x000198, "Member 'FAIAspectSettings_Timer::TargetChangedWarmup' has a wrong offset!");
static_assert(offsetof(FAIAspectSettings_Timer, bUseTargetChangedWarmup) == 0x000218, "Member 'FAIAspectSettings_Timer::bUseTargetChangedWarmup' has a wrong offset!");
static_assert(offsetof(FAIAspectSettings_Timer, SucceededCooldown) == 0x000220, "Member 'FAIAspectSettings_Timer::SucceededCooldown' has a wrong offset!");
static_assert(offsetof(FAIAspectSettings_Timer, bUseSucceededCooldown) == 0x0002A0, "Member 'FAIAspectSettings_Timer::bUseSucceededCooldown' has a wrong offset!");
static_assert(offsetof(FAIAspectSettings_Timer, FailedCooldown) == 0x0002A8, "Member 'FAIAspectSettings_Timer::FailedCooldown' has a wrong offset!");
static_assert(offsetof(FAIAspectSettings_Timer, bUseFailedCooldown) == 0x000328, "Member 'FAIAspectSettings_Timer::bUseFailedCooldown' has a wrong offset!");
static_assert(offsetof(FAIAspectSettings_Timer, AbortedCooldown) == 0x000330, "Member 'FAIAspectSettings_Timer::AbortedCooldown' has a wrong offset!");
static_assert(offsetof(FAIAspectSettings_Timer, bUseAbortedCooldown) == 0x0003B0, "Member 'FAIAspectSettings_Timer::bUseAbortedCooldown' has a wrong offset!");
static_assert(offsetof(FAIAspectSettings_Timer, SucceedTimeLimit) == 0x0003B8, "Member 'FAIAspectSettings_Timer::SucceedTimeLimit' has a wrong offset!");
static_assert(offsetof(FAIAspectSettings_Timer, bUseSucceedTimeLimit) == 0x000438, "Member 'FAIAspectSettings_Timer::bUseSucceedTimeLimit' has a wrong offset!");
static_assert(offsetof(FAIAspectSettings_Timer, FailTimeLimit) == 0x000440, "Member 'FAIAspectSettings_Timer::FailTimeLimit' has a wrong offset!");
static_assert(offsetof(FAIAspectSettings_Timer, bUseFailTimeLimit) == 0x0004C0, "Member 'FAIAspectSettings_Timer::bUseFailTimeLimit' has a wrong offset!");

// ScriptStruct GbxAI.CoverUseParams
// 0x0118 (0x0118 - 0x0000)
struct FCoverUseParams final
{
public:
	bool                                          bMustHaveViewToTarget;                             // 0x0000(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bMustBeHiddenFromThreats;                          // 0x0001(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2[0x2];                                        // 0x0002(0x0002)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         InCoverExposurePercent;                            // 0x0004(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bOverrideIdleTime;                                 // 0x0008(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_9[0x7];                                        // 0x0009(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	struct FGbxParam                              IdleTimeOverride;                                  // 0x0010(0x0080)(Edit, NoDestructor, ContainsInstancedReference, NativeAccessSpecifierPublic)
	bool                                          bOverrideFireTime;                                 // 0x0090(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_91[0x7];                                       // 0x0091(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	struct FGbxParam                              FireTimeOverride;                                  // 0x0098(0x0080)(Edit, NoDestructor, ContainsInstancedReference, NativeAccessSpecifierPublic)
};
static_assert(alignof(FCoverUseParams) == 0x000008, "Wrong alignment on FCoverUseParams");
static_assert(sizeof(FCoverUseParams) == 0x000118, "Wrong size on FCoverUseParams");
static_assert(offsetof(FCoverUseParams, bMustHaveViewToTarget) == 0x000000, "Member 'FCoverUseParams::bMustHaveViewToTarget' has a wrong offset!");
static_assert(offsetof(FCoverUseParams, bMustBeHiddenFromThreats) == 0x000001, "Member 'FCoverUseParams::bMustBeHiddenFromThreats' has a wrong offset!");
static_assert(offsetof(FCoverUseParams, InCoverExposurePercent) == 0x000004, "Member 'FCoverUseParams::InCoverExposurePercent' has a wrong offset!");
static_assert(offsetof(FCoverUseParams, bOverrideIdleTime) == 0x000008, "Member 'FCoverUseParams::bOverrideIdleTime' has a wrong offset!");
static_assert(offsetof(FCoverUseParams, IdleTimeOverride) == 0x000010, "Member 'FCoverUseParams::IdleTimeOverride' has a wrong offset!");
static_assert(offsetof(FCoverUseParams, bOverrideFireTime) == 0x000090, "Member 'FCoverUseParams::bOverrideFireTime' has a wrong offset!");
static_assert(offsetof(FCoverUseParams, FireTimeOverride) == 0x000098, "Member 'FCoverUseParams::FireTimeOverride' has a wrong offset!");

// ScriptStruct GbxAI.AIAspectSettings_UseCover
// 0x0138 (0x0138 - 0x0000)
struct FAIAspectSettings_UseCover final
{
public:
	struct FGbxBlackboardKeySelector              Target;                                            // 0x0000(0x0010)(Edit, NoDestructor, NativeAccessSpecifierPublic)
	struct FGbxBlackboardKeySelector              Cover;                                             // 0x0010(0x0010)(Edit, NoDestructor, NativeAccessSpecifierPublic)
	struct FCoverUseParams                        UseParams;                                         // 0x0020(0x0118)(Edit, NoDestructor, ContainsInstancedReference, NativeAccessSpecifierPublic)
};
static_assert(alignof(FAIAspectSettings_UseCover) == 0x000008, "Wrong alignment on FAIAspectSettings_UseCover");
static_assert(sizeof(FAIAspectSettings_UseCover) == 0x000138, "Wrong size on FAIAspectSettings_UseCover");
static_assert(offsetof(FAIAspectSettings_UseCover, Target) == 0x000000, "Member 'FAIAspectSettings_UseCover::Target' has a wrong offset!");
static_assert(offsetof(FAIAspectSettings_UseCover, Cover) == 0x000010, "Member 'FAIAspectSettings_UseCover::Cover' has a wrong offset!");
static_assert(offsetof(FAIAspectSettings_UseCover, UseParams) == 0x000020, "Member 'FAIAspectSettings_UseCover::UseParams' has a wrong offset!");

// ScriptStruct GbxAI.AIWeaponUseSettings
// 0x0238 (0x0238 - 0x0000)
struct FAIWeaponUseSettings
{
public:
	float                                         FireConeAngle;                                     // 0x0000(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bOverrideFireConeAngle;                            // 0x0004(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_5[0x3];                                        // 0x0005(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	struct FGbxParam                              BurstCountOverride;                                // 0x0008(0x0080)(Edit, NoDestructor, ContainsInstancedReference, NativeAccessSpecifierPublic)
	bool                                          bOverrideBurstCount;                               // 0x0088(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_89[0x7];                                       // 0x0089(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	struct FGbxParam                              BurstDelayOverride;                                // 0x0090(0x0080)(Edit, NoDestructor, ContainsInstancedReference, NativeAccessSpecifierPublic)
	bool                                          bOverrideBurstDelay;                               // 0x0110(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_111[0x7];                                      // 0x0111(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	struct FGbxParam                              AccuracyOverride;                                  // 0x0118(0x0080)(Edit, NoDestructor, ContainsInstancedReference, NativeAccessSpecifierPublic)
	bool                                          bOverrideAccuracy;                                 // 0x0198(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_199[0x7];                                      // 0x0199(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	struct FGbxParam                              SuppressingFireTime;                               // 0x01A0(0x0080)(Edit, NoDestructor, ContainsInstancedReference, NativeAccessSpecifierPublic)
	bool                                          bUseSuppressingFireTime;                           // 0x0220(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_221[0x3];                                      // 0x0221(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	struct FNumericRange                          DesiredRangeOverride;                              // 0x0224(0x0008)(Edit, NoDestructor, NativeAccessSpecifierPublic)
	bool                                          bOverrideDesiredRange;                             // 0x022C(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_22D[0x3];                                      // 0x022D(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         MaxWeaponLeadingDistance;                          // 0x0230(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_234[0x4];                                      // 0x0234(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FAIWeaponUseSettings) == 0x000008, "Wrong alignment on FAIWeaponUseSettings");
static_assert(sizeof(FAIWeaponUseSettings) == 0x000238, "Wrong size on FAIWeaponUseSettings");
static_assert(offsetof(FAIWeaponUseSettings, FireConeAngle) == 0x000000, "Member 'FAIWeaponUseSettings::FireConeAngle' has a wrong offset!");
static_assert(offsetof(FAIWeaponUseSettings, bOverrideFireConeAngle) == 0x000004, "Member 'FAIWeaponUseSettings::bOverrideFireConeAngle' has a wrong offset!");
static_assert(offsetof(FAIWeaponUseSettings, BurstCountOverride) == 0x000008, "Member 'FAIWeaponUseSettings::BurstCountOverride' has a wrong offset!");
static_assert(offsetof(FAIWeaponUseSettings, bOverrideBurstCount) == 0x000088, "Member 'FAIWeaponUseSettings::bOverrideBurstCount' has a wrong offset!");
static_assert(offsetof(FAIWeaponUseSettings, BurstDelayOverride) == 0x000090, "Member 'FAIWeaponUseSettings::BurstDelayOverride' has a wrong offset!");
static_assert(offsetof(FAIWeaponUseSettings, bOverrideBurstDelay) == 0x000110, "Member 'FAIWeaponUseSettings::bOverrideBurstDelay' has a wrong offset!");
static_assert(offsetof(FAIWeaponUseSettings, AccuracyOverride) == 0x000118, "Member 'FAIWeaponUseSettings::AccuracyOverride' has a wrong offset!");
static_assert(offsetof(FAIWeaponUseSettings, bOverrideAccuracy) == 0x000198, "Member 'FAIWeaponUseSettings::bOverrideAccuracy' has a wrong offset!");
static_assert(offsetof(FAIWeaponUseSettings, SuppressingFireTime) == 0x0001A0, "Member 'FAIWeaponUseSettings::SuppressingFireTime' has a wrong offset!");
static_assert(offsetof(FAIWeaponUseSettings, bUseSuppressingFireTime) == 0x000220, "Member 'FAIWeaponUseSettings::bUseSuppressingFireTime' has a wrong offset!");
static_assert(offsetof(FAIWeaponUseSettings, DesiredRangeOverride) == 0x000224, "Member 'FAIWeaponUseSettings::DesiredRangeOverride' has a wrong offset!");
static_assert(offsetof(FAIWeaponUseSettings, bOverrideDesiredRange) == 0x00022C, "Member 'FAIWeaponUseSettings::bOverrideDesiredRange' has a wrong offset!");
static_assert(offsetof(FAIWeaponUseSettings, MaxWeaponLeadingDistance) == 0x000230, "Member 'FAIWeaponUseSettings::MaxWeaponLeadingDistance' has a wrong offset!");

// ScriptStruct GbxAI.AIAspectSettings_Weapon
// 0x0198 (0x03D0 - 0x0238)
struct FAIAspectSettings_Weapon final : public FAIWeaponUseSettings
{
public:
	TArray<class UGbxWeaponSlotData*>             WeaponSlots;                                       // 0x0238(0x0010)(Edit, BlueprintVisible, ZeroConstructor, NativeAccessSpecifierPublic)
	struct FGbxParam                              WeaponUseModeIndex;                                // 0x0248(0x0080)(Edit, BlueprintVisible, NoDestructor, ContainsInstancedReference, NativeAccessSpecifierPublic)
	struct FGbxParam                              CanUseWeapon;                                      // 0x02C8(0x0080)(Edit, BlueprintVisible, NoDestructor, ContainsInstancedReference, NativeAccessSpecifierPublic)
	struct FGbxParam                              CanUseWeaponWhileMoving;                           // 0x0348(0x0080)(Edit, BlueprintVisible, NoDestructor, ContainsInstancedReference, NativeAccessSpecifierPublic)
	bool                                          bUseCanUseWeaponWhileMoving;                       // 0x03C8(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bOnlyShootWhenTargetIsKnown;                       // 0x03C9(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_3CA[0x6];                                      // 0x03CA(0x0006)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FAIAspectSettings_Weapon) == 0x000008, "Wrong alignment on FAIAspectSettings_Weapon");
static_assert(sizeof(FAIAspectSettings_Weapon) == 0x0003D0, "Wrong size on FAIAspectSettings_Weapon");
static_assert(offsetof(FAIAspectSettings_Weapon, WeaponSlots) == 0x000238, "Member 'FAIAspectSettings_Weapon::WeaponSlots' has a wrong offset!");
static_assert(offsetof(FAIAspectSettings_Weapon, WeaponUseModeIndex) == 0x000248, "Member 'FAIAspectSettings_Weapon::WeaponUseModeIndex' has a wrong offset!");
static_assert(offsetof(FAIAspectSettings_Weapon, CanUseWeapon) == 0x0002C8, "Member 'FAIAspectSettings_Weapon::CanUseWeapon' has a wrong offset!");
static_assert(offsetof(FAIAspectSettings_Weapon, CanUseWeaponWhileMoving) == 0x000348, "Member 'FAIAspectSettings_Weapon::CanUseWeaponWhileMoving' has a wrong offset!");
static_assert(offsetof(FAIAspectSettings_Weapon, bUseCanUseWeaponWhileMoving) == 0x0003C8, "Member 'FAIAspectSettings_Weapon::bUseCanUseWeaponWhileMoving' has a wrong offset!");
static_assert(offsetof(FAIAspectSettings_Weapon, bOnlyShootWhenTargetIsKnown) == 0x0003C9, "Member 'FAIAspectSettings_Weapon::bOnlyShootWhenTargetIsKnown' has a wrong offset!");

// ScriptStruct GbxAI.CloakPrimData
// 0x0010 (0x0010 - 0x0000)
struct FCloakPrimData final
{
public:
	bool                                          bWasHidden;                                        // 0x0000(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1[0x7];                                        // 0x0001(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	class UPrimitiveComponent*                    PrimComp;                                          // 0x0008(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FCloakPrimData) == 0x000008, "Wrong alignment on FCloakPrimData");
static_assert(sizeof(FCloakPrimData) == 0x000010, "Wrong size on FCloakPrimData");
static_assert(offsetof(FCloakPrimData, bWasHidden) == 0x000000, "Member 'FCloakPrimData::bWasHidden' has a wrong offset!");
static_assert(offsetof(FCloakPrimData, PrimComp) == 0x000008, "Member 'FCloakPrimData::PrimComp' has a wrong offset!");

// ScriptStruct GbxAI.AICommunicationManager
// 0x0048 (0x0048 - 0x0000)
struct alignas(0x08) FAICommunicationManager final
{
public:
	uint8                                         Pad_0[0x48];                                       // 0x0000(0x0048)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FAICommunicationManager) == 0x000008, "Wrong alignment on FAICommunicationManager");
static_assert(sizeof(FAICommunicationManager) == 0x000048, "Wrong size on FAICommunicationManager");

// ScriptStruct GbxAI.PlanRoleRequirements
// 0x0130 (0x0130 - 0x0000)
struct FPlanRoleRequirements final
{
public:
	struct FGameplayTag                           RoleTag;                                           // 0x0000(0x0008)(Edit, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         MinInstancesOfRole;                                // 0x0008(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         MaxInstancesOfRole;                                // 0x0009(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_A[0x6];                                        // 0x000A(0x0006)(Fixing Size After Last Property [ Dumper-7 ])
	struct FGbxParam                              DistanceToLeaderForParticipation;                  // 0x0010(0x0080)(Edit, BlueprintVisible, BlueprintReadOnly, NoDestructor, ContainsInstancedReference, NativeAccessSpecifierPublic)
	struct FGbxParam                              DistanceToLeaderToRemove;                          // 0x0090(0x0080)(Edit, BlueprintVisible, BlueprintReadOnly, NoDestructor, ContainsInstancedReference, NativeAccessSpecifierPublic)
	class UGbxCondition*                          AdditionalStartCondition;                          // 0x0110(0x0008)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, PersistentInstance, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bAlsoUseStartConditionAsStopCondition;             // 0x0118(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_119[0x7];                                      // 0x0119(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	class UGbxCondition*                          AdditionalStopCondition;                           // 0x0120(0x0008)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, PersistentInstance, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EPlanMemberReplacement                        MemberReplacementStrategy;                         // 0x0128(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_129[0x7];                                      // 0x0129(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FPlanRoleRequirements) == 0x000008, "Wrong alignment on FPlanRoleRequirements");
static_assert(sizeof(FPlanRoleRequirements) == 0x000130, "Wrong size on FPlanRoleRequirements");
static_assert(offsetof(FPlanRoleRequirements, RoleTag) == 0x000000, "Member 'FPlanRoleRequirements::RoleTag' has a wrong offset!");
static_assert(offsetof(FPlanRoleRequirements, MinInstancesOfRole) == 0x000008, "Member 'FPlanRoleRequirements::MinInstancesOfRole' has a wrong offset!");
static_assert(offsetof(FPlanRoleRequirements, MaxInstancesOfRole) == 0x000009, "Member 'FPlanRoleRequirements::MaxInstancesOfRole' has a wrong offset!");
static_assert(offsetof(FPlanRoleRequirements, DistanceToLeaderForParticipation) == 0x000010, "Member 'FPlanRoleRequirements::DistanceToLeaderForParticipation' has a wrong offset!");
static_assert(offsetof(FPlanRoleRequirements, DistanceToLeaderToRemove) == 0x000090, "Member 'FPlanRoleRequirements::DistanceToLeaderToRemove' has a wrong offset!");
static_assert(offsetof(FPlanRoleRequirements, AdditionalStartCondition) == 0x000110, "Member 'FPlanRoleRequirements::AdditionalStartCondition' has a wrong offset!");
static_assert(offsetof(FPlanRoleRequirements, bAlsoUseStartConditionAsStopCondition) == 0x000118, "Member 'FPlanRoleRequirements::bAlsoUseStartConditionAsStopCondition' has a wrong offset!");
static_assert(offsetof(FPlanRoleRequirements, AdditionalStopCondition) == 0x000120, "Member 'FPlanRoleRequirements::AdditionalStopCondition' has a wrong offset!");
static_assert(offsetof(FPlanRoleRequirements, MemberReplacementStrategy) == 0x000128, "Member 'FPlanRoleRequirements::MemberReplacementStrategy' has a wrong offset!");

// ScriptStruct GbxAI.PlanState
// 0x0038 (0x0038 - 0x0000)
struct alignas(0x08) FPlanState final
{
public:
	uint8                                         Pad_0[0x38];                                       // 0x0000(0x0038)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FPlanState) == 0x000008, "Wrong alignment on FPlanState");
static_assert(sizeof(FPlanState) == 0x000038, "Wrong size on FPlanState");

// ScriptStruct GbxAI.RoleCandidates
// 0x0018 (0x0018 - 0x0000)
struct alignas(0x08) FRoleCandidates final
{
public:
	uint8                                         Pad_0[0x18];                                       // 0x0000(0x0018)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FRoleCandidates) == 0x000008, "Wrong alignment on FRoleCandidates");
static_assert(sizeof(FRoleCandidates) == 0x000018, "Wrong size on FRoleCandidates");

// ScriptStruct GbxAI.AIPlanManager
// 0x0080 (0x0080 - 0x0000)
struct FAIPlanManager final
{
public:
	TArray<TWeakObjectPtr<class UAIPlanData>>     AvailablePlans;                                    // 0x0000(0x0010)(ZeroConstructor, Transient, UObjectWrapper, NativeAccessSpecifierPrivate)
	TArray<struct FPlanState>                     ActivePlans;                                       // 0x0010(0x0010)(ZeroConstructor, Transient, NativeAccessSpecifierPrivate)
	uint8                                         Pad_20[0x8];                                       // 0x0020(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	TMap<class FName, struct FRoleCandidates>     PotentialCandidatesByRole;                         // 0x0028(0x0050)(ZeroConstructor, Transient, NativeAccessSpecifierPrivate)
	uint8                                         Pad_78[0x8];                                       // 0x0078(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FAIPlanManager) == 0x000008, "Wrong alignment on FAIPlanManager");
static_assert(sizeof(FAIPlanManager) == 0x000080, "Wrong size on FAIPlanManager");
static_assert(offsetof(FAIPlanManager, AvailablePlans) == 0x000000, "Member 'FAIPlanManager::AvailablePlans' has a wrong offset!");
static_assert(offsetof(FAIPlanManager, ActivePlans) == 0x000010, "Member 'FAIPlanManager::ActivePlans' has a wrong offset!");
static_assert(offsetof(FAIPlanManager, PotentialCandidatesByRole) == 0x000028, "Member 'FAIPlanManager::PotentialCandidatesByRole' has a wrong offset!");

// ScriptStruct GbxAI.PlanRoleMapping
// 0x0018 (0x0018 - 0x0000)
struct alignas(0x08) FPlanRoleMapping final
{
public:
	uint8                                         Pad_0[0x18];                                       // 0x0000(0x0018)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FPlanRoleMapping) == 0x000008, "Wrong alignment on FPlanRoleMapping");
static_assert(sizeof(FPlanRoleMapping) == 0x000018, "Wrong size on FPlanRoleMapping");

// ScriptStruct GbxAI.RoleController
// 0x000C (0x000C - 0x0000)
struct alignas(0x04) FRoleController final
{
public:
	uint8                                         Pad_0[0xC];                                        // 0x0000(0x000C)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FRoleController) == 0x000004, "Wrong alignment on FRoleController");
static_assert(sizeof(FRoleController) == 0x00000C, "Wrong size on FRoleController");

// ScriptStruct GbxAI.ThreatSource
// 0x000C (0x000C - 0x0000)
struct alignas(0x04) FThreatSource final
{
public:
	uint8                                         Pad_0[0xC];                                        // 0x0000(0x000C)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FThreatSource) == 0x000004, "Wrong alignment on FThreatSource");
static_assert(sizeof(FThreatSource) == 0x00000C, "Wrong size on FThreatSource");

// ScriptStruct GbxAI.ThreatTerritory
// 0x0018 (0x0018 - 0x0000)
struct alignas(0x08) FThreatTerritory final
{
public:
	uint8                                         Pad_0[0x18];                                       // 0x0000(0x0018)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FThreatTerritory) == 0x000008, "Wrong alignment on FThreatTerritory");
static_assert(sizeof(FThreatTerritory) == 0x000018, "Wrong size on FThreatTerritory");

// ScriptStruct GbxAI.AITicketUseData
// 0x0108 (0x0108 - 0x0000)
struct FAITicketUseData final
{
public:
	struct FGbxParam                              Value;                                             // 0x0000(0x0080)(Edit, NoDestructor, ContainsInstancedReference, NativeAccessSpecifierPublic)
	struct FGbxParam                              HoldDuration;                                      // 0x0080(0x0080)(Edit, NoDestructor, ContainsInstancedReference, NativeAccessSpecifierPublic)
	class UAITicketDataAsset*                     Ticket;                                            // 0x0100(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FAITicketUseData) == 0x000008, "Wrong alignment on FAITicketUseData");
static_assert(sizeof(FAITicketUseData) == 0x000108, "Wrong size on FAITicketUseData");
static_assert(offsetof(FAITicketUseData, Value) == 0x000000, "Member 'FAITicketUseData::Value' has a wrong offset!");
static_assert(offsetof(FAITicketUseData, HoldDuration) == 0x000080, "Member 'FAITicketUseData::HoldDuration' has a wrong offset!");
static_assert(offsetof(FAITicketUseData, Ticket) == 0x000100, "Member 'FAITicketUseData::Ticket' has a wrong offset!");

// ScriptStruct GbxAI.ActionUseState
// 0x00C0 (0x00C0 - 0x0000)
struct FActionUseState final
{
public:
	class AGbxAIController*                       Controller;                                        // 0x0000(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class USmartObjectComponent*                  SmartObjectComponent;                              // 0x0008(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UAIUseSlotComponent*                    AIUseSlotComponent;                                // 0x0010(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	struct FSmartActionUseInfo                    UseInfo;                                           // 0x0018(0x0018)(NoDestructor, NativeAccessSpecifierPrivate)
	ESmartObjectTaskState                         State;                                             // 0x0030(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_31[0x8F];                                      // 0x0031(0x008F)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FActionUseState) == 0x000008, "Wrong alignment on FActionUseState");
static_assert(sizeof(FActionUseState) == 0x0000C0, "Wrong size on FActionUseState");
static_assert(offsetof(FActionUseState, Controller) == 0x000000, "Member 'FActionUseState::Controller' has a wrong offset!");
static_assert(offsetof(FActionUseState, SmartObjectComponent) == 0x000008, "Member 'FActionUseState::SmartObjectComponent' has a wrong offset!");
static_assert(offsetof(FActionUseState, AIUseSlotComponent) == 0x000010, "Member 'FActionUseState::AIUseSlotComponent' has a wrong offset!");
static_assert(offsetof(FActionUseState, UseInfo) == 0x000018, "Member 'FActionUseState::UseInfo' has a wrong offset!");
static_assert(offsetof(FActionUseState, State) == 0x000030, "Member 'FActionUseState::State' has a wrong offset!");

// ScriptStruct GbxAI.ActionCooldownInfo
// 0x0018 (0x0018 - 0x0000)
struct FActionCooldownInfo final
{
public:
	TSubclassOf<class AActor>                     ActorClass;                                        // 0x0000(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FGameplayTag                           ActionTag;                                         // 0x0008(0x0008)(NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         CooldownTime;                                      // 0x0010(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_14[0x4];                                       // 0x0014(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FActionCooldownInfo) == 0x000008, "Wrong alignment on FActionCooldownInfo");
static_assert(sizeof(FActionCooldownInfo) == 0x000018, "Wrong size on FActionCooldownInfo");
static_assert(offsetof(FActionCooldownInfo, ActorClass) == 0x000000, "Member 'FActionCooldownInfo::ActorClass' has a wrong offset!");
static_assert(offsetof(FActionCooldownInfo, ActionTag) == 0x000008, "Member 'FActionCooldownInfo::ActionTag' has a wrong offset!");
static_assert(offsetof(FActionCooldownInfo, CooldownTime) == 0x000010, "Member 'FActionCooldownInfo::CooldownTime' has a wrong offset!");

// ScriptStruct GbxAI.BTRandomEntrySettings
// 0x0110 (0x0110 - 0x0000)
struct FBTRandomEntrySettings final
{
public:
	class FName                                   Name;                                              // 0x0000(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FGbxParam                              Weight;                                            // 0x0008(0x0080)(Edit, NoDestructor, ContainsInstancedReference, NativeAccessSpecifierPublic)
	struct FGbxParam                              LoopCountMax;                                      // 0x0088(0x0080)(Edit, NoDestructor, ContainsInstancedReference, NativeAccessSpecifierPublic)
	bool                                          bUseLoopCountMax;                                  // 0x0108(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_109[0x7];                                      // 0x0109(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FBTRandomEntrySettings) == 0x000008, "Wrong alignment on FBTRandomEntrySettings");
static_assert(sizeof(FBTRandomEntrySettings) == 0x000110, "Wrong size on FBTRandomEntrySettings");
static_assert(offsetof(FBTRandomEntrySettings, Name) == 0x000000, "Member 'FBTRandomEntrySettings::Name' has a wrong offset!");
static_assert(offsetof(FBTRandomEntrySettings, Weight) == 0x000008, "Member 'FBTRandomEntrySettings::Weight' has a wrong offset!");
static_assert(offsetof(FBTRandomEntrySettings, LoopCountMax) == 0x000088, "Member 'FBTRandomEntrySettings::LoopCountMax' has a wrong offset!");
static_assert(offsetof(FBTRandomEntrySettings, bUseLoopCountMax) == 0x000108, "Member 'FBTRandomEntrySettings::bUseLoopCountMax' has a wrong offset!");

// ScriptStruct GbxAI.BTGbxLoopConditionData
// 0x0010 (0x0010 - 0x0000)
struct FBTGbxLoopConditionData final
{
public:
	class UGbxCondition*                          Condition;                                         // 0x0000(0x0008)(Edit, ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, PersistentInstance, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bInvert;                                           // 0x0008(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_9[0x7];                                        // 0x0009(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FBTGbxLoopConditionData) == 0x000008, "Wrong alignment on FBTGbxLoopConditionData");
static_assert(sizeof(FBTGbxLoopConditionData) == 0x000010, "Wrong size on FBTGbxLoopConditionData");
static_assert(offsetof(FBTGbxLoopConditionData, Condition) == 0x000000, "Member 'FBTGbxLoopConditionData::Condition' has a wrong offset!");
static_assert(offsetof(FBTGbxLoopConditionData, bInvert) == 0x000008, "Member 'FBTGbxLoopConditionData::bInvert' has a wrong offset!");

// ScriptStruct GbxAI.CoverLineOfSightParams
// 0x0028 (0x0028 - 0x0000)
struct FCoverLineOfSightParams final
{
public:
	int32                                         NumVerticalSections;                               // 0x0000(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         NumHorizontalSections;                             // 0x0004(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         VerticalAngleUp;                                   // 0x0008(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         VerticalAngleDown;                                 // 0x000C(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         HorizontalAngle;                                   // 0x0010(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         MaxDistance;                                       // 0x0014(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         NumBlockSubdivisions;                              // 0x0018(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FRotator                               RotationOffset;                                    // 0x001C(0x000C)(Edit, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(FCoverLineOfSightParams) == 0x000004, "Wrong alignment on FCoverLineOfSightParams");
static_assert(sizeof(FCoverLineOfSightParams) == 0x000028, "Wrong size on FCoverLineOfSightParams");
static_assert(offsetof(FCoverLineOfSightParams, NumVerticalSections) == 0x000000, "Member 'FCoverLineOfSightParams::NumVerticalSections' has a wrong offset!");
static_assert(offsetof(FCoverLineOfSightParams, NumHorizontalSections) == 0x000004, "Member 'FCoverLineOfSightParams::NumHorizontalSections' has a wrong offset!");
static_assert(offsetof(FCoverLineOfSightParams, VerticalAngleUp) == 0x000008, "Member 'FCoverLineOfSightParams::VerticalAngleUp' has a wrong offset!");
static_assert(offsetof(FCoverLineOfSightParams, VerticalAngleDown) == 0x00000C, "Member 'FCoverLineOfSightParams::VerticalAngleDown' has a wrong offset!");
static_assert(offsetof(FCoverLineOfSightParams, HorizontalAngle) == 0x000010, "Member 'FCoverLineOfSightParams::HorizontalAngle' has a wrong offset!");
static_assert(offsetof(FCoverLineOfSightParams, MaxDistance) == 0x000014, "Member 'FCoverLineOfSightParams::MaxDistance' has a wrong offset!");
static_assert(offsetof(FCoverLineOfSightParams, NumBlockSubdivisions) == 0x000018, "Member 'FCoverLineOfSightParams::NumBlockSubdivisions' has a wrong offset!");
static_assert(offsetof(FCoverLineOfSightParams, RotationOffset) == 0x00001C, "Member 'FCoverLineOfSightParams::RotationOffset' has a wrong offset!");

// ScriptStruct GbxAI.CoverLineOfSightData
// 0x00B0 (0x00B0 - 0x0000)
struct FCoverLineOfSightData final
{
public:
	struct FTransform                             LocalToWorld;                                      // 0x0000(0x0030)(IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
	struct FMatrix                                WorldToLocal;                                      // 0x0030(0x0040)(IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
	TArray<struct FCoverLineOfSightSectionData>   Sections;                                          // 0x0070(0x0010)(ZeroConstructor, NativeAccessSpecifierPublic)
	struct FCoverLineOfSightParams                Params;                                            // 0x0080(0x0028)(NoDestructor, NativeAccessSpecifierPublic)
	uint8                                         Pad_A8[0x8];                                       // 0x00A8(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FCoverLineOfSightData) == 0x000010, "Wrong alignment on FCoverLineOfSightData");
static_assert(sizeof(FCoverLineOfSightData) == 0x0000B0, "Wrong size on FCoverLineOfSightData");
static_assert(offsetof(FCoverLineOfSightData, LocalToWorld) == 0x000000, "Member 'FCoverLineOfSightData::LocalToWorld' has a wrong offset!");
static_assert(offsetof(FCoverLineOfSightData, WorldToLocal) == 0x000030, "Member 'FCoverLineOfSightData::WorldToLocal' has a wrong offset!");
static_assert(offsetof(FCoverLineOfSightData, Sections) == 0x000070, "Member 'FCoverLineOfSightData::Sections' has a wrong offset!");
static_assert(offsetof(FCoverLineOfSightData, Params) == 0x000080, "Member 'FCoverLineOfSightData::Params' has a wrong offset!");

// ScriptStruct GbxAI.CoverAdjustParams
// 0x0040 (0x0040 - 0x0000)
struct FCoverAdjustParams final
{
public:
	float                                         AdjustDistanceDown;                                // 0x0000(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bDoDownAdjustment;                                 // 0x0004(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_5[0x3];                                        // 0x0005(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         AdjustDistanceUp;                                  // 0x0008(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bDoUpAdjustment;                                   // 0x000C(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_D[0x3];                                        // 0x000D(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         AdjustDistanceForward;                             // 0x0010(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bDoForwardAdjustment;                              // 0x0014(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bEdgeTestLeft;                                     // 0x0015(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bEdgeTestRight;                                    // 0x0016(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_17[0x1];                                       // 0x0017(0x0001)(Fixing Size After Last Property [ Dumper-7 ])
	int32                                         EdgeTestSections;                                  // 0x0018(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         EdgeTestHeightPct;                                 // 0x001C(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         EdgeTestDistancePct;                               // 0x0020(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         EdgeTestWalkBackDistance;                          // 0x0024(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         EdgeTestAngleThreshold;                            // 0x0028(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         BlockTestHitPct;                                   // 0x002C(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         BlockTestDistancePct;                              // 0x0030(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         BlockTestHorizontalSections;                       // 0x0034(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         BlockTestVerticalSections;                         // 0x0038(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         BlockTestAngleThreshold;                           // 0x003C(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FCoverAdjustParams) == 0x000004, "Wrong alignment on FCoverAdjustParams");
static_assert(sizeof(FCoverAdjustParams) == 0x000040, "Wrong size on FCoverAdjustParams");
static_assert(offsetof(FCoverAdjustParams, AdjustDistanceDown) == 0x000000, "Member 'FCoverAdjustParams::AdjustDistanceDown' has a wrong offset!");
static_assert(offsetof(FCoverAdjustParams, bDoDownAdjustment) == 0x000004, "Member 'FCoverAdjustParams::bDoDownAdjustment' has a wrong offset!");
static_assert(offsetof(FCoverAdjustParams, AdjustDistanceUp) == 0x000008, "Member 'FCoverAdjustParams::AdjustDistanceUp' has a wrong offset!");
static_assert(offsetof(FCoverAdjustParams, bDoUpAdjustment) == 0x00000C, "Member 'FCoverAdjustParams::bDoUpAdjustment' has a wrong offset!");
static_assert(offsetof(FCoverAdjustParams, AdjustDistanceForward) == 0x000010, "Member 'FCoverAdjustParams::AdjustDistanceForward' has a wrong offset!");
static_assert(offsetof(FCoverAdjustParams, bDoForwardAdjustment) == 0x000014, "Member 'FCoverAdjustParams::bDoForwardAdjustment' has a wrong offset!");
static_assert(offsetof(FCoverAdjustParams, bEdgeTestLeft) == 0x000015, "Member 'FCoverAdjustParams::bEdgeTestLeft' has a wrong offset!");
static_assert(offsetof(FCoverAdjustParams, bEdgeTestRight) == 0x000016, "Member 'FCoverAdjustParams::bEdgeTestRight' has a wrong offset!");
static_assert(offsetof(FCoverAdjustParams, EdgeTestSections) == 0x000018, "Member 'FCoverAdjustParams::EdgeTestSections' has a wrong offset!");
static_assert(offsetof(FCoverAdjustParams, EdgeTestHeightPct) == 0x00001C, "Member 'FCoverAdjustParams::EdgeTestHeightPct' has a wrong offset!");
static_assert(offsetof(FCoverAdjustParams, EdgeTestDistancePct) == 0x000020, "Member 'FCoverAdjustParams::EdgeTestDistancePct' has a wrong offset!");
static_assert(offsetof(FCoverAdjustParams, EdgeTestWalkBackDistance) == 0x000024, "Member 'FCoverAdjustParams::EdgeTestWalkBackDistance' has a wrong offset!");
static_assert(offsetof(FCoverAdjustParams, EdgeTestAngleThreshold) == 0x000028, "Member 'FCoverAdjustParams::EdgeTestAngleThreshold' has a wrong offset!");
static_assert(offsetof(FCoverAdjustParams, BlockTestHitPct) == 0x00002C, "Member 'FCoverAdjustParams::BlockTestHitPct' has a wrong offset!");
static_assert(offsetof(FCoverAdjustParams, BlockTestDistancePct) == 0x000030, "Member 'FCoverAdjustParams::BlockTestDistancePct' has a wrong offset!");
static_assert(offsetof(FCoverAdjustParams, BlockTestHorizontalSections) == 0x000034, "Member 'FCoverAdjustParams::BlockTestHorizontalSections' has a wrong offset!");
static_assert(offsetof(FCoverAdjustParams, BlockTestVerticalSections) == 0x000038, "Member 'FCoverAdjustParams::BlockTestVerticalSections' has a wrong offset!");
static_assert(offsetof(FCoverAdjustParams, BlockTestAngleThreshold) == 0x00003C, "Member 'FCoverAdjustParams::BlockTestAngleThreshold' has a wrong offset!");

// ScriptStruct GbxAI.CoverSlotViewFailData
// 0x0020 (0x0020 - 0x0000)
struct FCoverSlotViewFailData final
{
public:
	class UCoverViewData*                         View;                                              // 0x0000(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	ECoverAdjustFailReason                        FailReason;                                        // 0x0008(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_9[0x7];                                        // 0x0009(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	class FString                                 FailDescription;                                   // 0x0010(0x0010)(ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FCoverSlotViewFailData) == 0x000008, "Wrong alignment on FCoverSlotViewFailData");
static_assert(sizeof(FCoverSlotViewFailData) == 0x000020, "Wrong size on FCoverSlotViewFailData");
static_assert(offsetof(FCoverSlotViewFailData, View) == 0x000000, "Member 'FCoverSlotViewFailData::View' has a wrong offset!");
static_assert(offsetof(FCoverSlotViewFailData, FailReason) == 0x000008, "Member 'FCoverSlotViewFailData::FailReason' has a wrong offset!");
static_assert(offsetof(FCoverSlotViewFailData, FailDescription) == 0x000010, "Member 'FCoverSlotViewFailData::FailDescription' has a wrong offset!");

// ScriptStruct GbxAI.CoverSlotViewData
// 0x00C0 (0x00C0 - 0x0000)
struct FCoverSlotViewData final
{
public:
	class UCoverViewData*                         View;                                              // 0x0000(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_8[0x8];                                        // 0x0008(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	struct FCoverLineOfSightData                  LosData;                                           // 0x0010(0x00B0)(NativeAccessSpecifierPublic)
};
static_assert(alignof(FCoverSlotViewData) == 0x000010, "Wrong alignment on FCoverSlotViewData");
static_assert(sizeof(FCoverSlotViewData) == 0x0000C0, "Wrong size on FCoverSlotViewData");
static_assert(offsetof(FCoverSlotViewData, View) == 0x000000, "Member 'FCoverSlotViewData::View' has a wrong offset!");
static_assert(offsetof(FCoverSlotViewData, LosData) == 0x000010, "Member 'FCoverSlotViewData::LosData' has a wrong offset!");

// ScriptStruct GbxAI.CoverTransitionStanceFilter
// 0x0018 (0x0018 - 0x0000)
struct FCoverTransitionStanceFilter final
{
public:
	class FString                                 Filter;                                            // 0x0000(0x0010)(Edit, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UStanceDataProvider*                    Stance;                                            // 0x0010(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FCoverTransitionStanceFilter) == 0x000008, "Wrong alignment on FCoverTransitionStanceFilter");
static_assert(sizeof(FCoverTransitionStanceFilter) == 0x000018, "Wrong size on FCoverTransitionStanceFilter");
static_assert(offsetof(FCoverTransitionStanceFilter, Filter) == 0x000000, "Member 'FCoverTransitionStanceFilter::Filter' has a wrong offset!");
static_assert(offsetof(FCoverTransitionStanceFilter, Stance) == 0x000010, "Member 'FCoverTransitionStanceFilter::Stance' has a wrong offset!");

// ScriptStruct GbxAI.CoverTransitionFilters
// 0x0050 (0x0050 - 0x0000)
struct FCoverTransitionFilters final
{
public:
	TArray<class FString>                         Use;                                               // 0x0000(0x0010)(Edit, ZeroConstructor, NativeAccessSpecifierPublic)
	TArray<class FString>                         Corner;                                            // 0x0010(0x0010)(Edit, ZeroConstructor, NativeAccessSpecifierPublic)
	TArray<class FString>                         High;                                              // 0x0020(0x0010)(Edit, ZeroConstructor, NativeAccessSpecifierPublic)
	TArray<class FString>                         Away;                                              // 0x0030(0x0010)(Edit, ZeroConstructor, NativeAccessSpecifierPublic)
	TArray<struct FCoverTransitionStanceFilter>   Stances;                                           // 0x0040(0x0010)(Edit, ZeroConstructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(FCoverTransitionFilters) == 0x000008, "Wrong alignment on FCoverTransitionFilters");
static_assert(sizeof(FCoverTransitionFilters) == 0x000050, "Wrong size on FCoverTransitionFilters");
static_assert(offsetof(FCoverTransitionFilters, Use) == 0x000000, "Member 'FCoverTransitionFilters::Use' has a wrong offset!");
static_assert(offsetof(FCoverTransitionFilters, Corner) == 0x000010, "Member 'FCoverTransitionFilters::Corner' has a wrong offset!");
static_assert(offsetof(FCoverTransitionFilters, High) == 0x000020, "Member 'FCoverTransitionFilters::High' has a wrong offset!");
static_assert(offsetof(FCoverTransitionFilters, Away) == 0x000030, "Member 'FCoverTransitionFilters::Away' has a wrong offset!");
static_assert(offsetof(FCoverTransitionFilters, Stances) == 0x000040, "Member 'FCoverTransitionFilters::Stances' has a wrong offset!");

// ScriptStruct GbxAI.CoverTransitionData
// 0x0060 (0x0060 - 0x0000)
struct FCoverTransitionData final
{
public:
	class UDataTable*                             DataTable;                                         // 0x0000(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UGbxAnimSet*                            AnimSet;                                           // 0x0008(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	struct FCoverTransitionFilters                Filters;                                           // 0x0010(0x0050)(Edit, NativeAccessSpecifierPrivate)
};
static_assert(alignof(FCoverTransitionData) == 0x000008, "Wrong alignment on FCoverTransitionData");
static_assert(sizeof(FCoverTransitionData) == 0x000060, "Wrong size on FCoverTransitionData");
static_assert(offsetof(FCoverTransitionData, DataTable) == 0x000000, "Member 'FCoverTransitionData::DataTable' has a wrong offset!");
static_assert(offsetof(FCoverTransitionData, AnimSet) == 0x000008, "Member 'FCoverTransitionData::AnimSet' has a wrong offset!");
static_assert(offsetof(FCoverTransitionData, Filters) == 0x000010, "Member 'FCoverTransitionData::Filters' has a wrong offset!");

// ScriptStruct GbxAI.CoverTransitionInput
// 0x0040 (0x0040 - 0x0000)
struct alignas(0x08) FCoverTransitionInput final
{
public:
	uint8                                         Pad_0[0x40];                                       // 0x0000(0x0040)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FCoverTransitionInput) == 0x000008, "Wrong alignment on FCoverTransitionInput");
static_assert(sizeof(FCoverTransitionInput) == 0x000040, "Wrong size on FCoverTransitionInput");

// ScriptStruct GbxAI.CoverClientData
// 0x0028 (0x0028 - 0x0000)
struct FCoverClientData final
{
public:
	class UCoverStyleData*                        Style;                                             // 0x0000(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UCoverSlotComponent*                    Slot;                                              // 0x0008(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	ECoverUserState                               DesiredState;                                      // 0x0010(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_11[0x7];                                       // 0x0011(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	class FName                                   TransitionName;                                    // 0x0018(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bFlanked;                                          // 0x0020(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_21[0x7];                                       // 0x0021(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FCoverClientData) == 0x000008, "Wrong alignment on FCoverClientData");
static_assert(sizeof(FCoverClientData) == 0x000028, "Wrong size on FCoverClientData");
static_assert(offsetof(FCoverClientData, Style) == 0x000000, "Member 'FCoverClientData::Style' has a wrong offset!");
static_assert(offsetof(FCoverClientData, Slot) == 0x000008, "Member 'FCoverClientData::Slot' has a wrong offset!");
static_assert(offsetof(FCoverClientData, DesiredState) == 0x000010, "Member 'FCoverClientData::DesiredState' has a wrong offset!");
static_assert(offsetof(FCoverClientData, TransitionName) == 0x000018, "Member 'FCoverClientData::TransitionName' has a wrong offset!");
static_assert(offsetof(FCoverClientData, bFlanked) == 0x000020, "Member 'FCoverClientData::bFlanked' has a wrong offset!");

// ScriptStruct GbxAI.CoverAction
// 0x0130 (0x0130 - 0x0000)
struct FCoverAction final
{
public:
	class UCoverSlotComponent*                    Slot;                                              // 0x0000(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UCoverStyleData*                        Style;                                             // 0x0008(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class AActor*                                 Target;                                            // 0x0010(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FCoverUseParams                        Params;                                            // 0x0018(0x0118)(NoDestructor, ContainsInstancedReference, NativeAccessSpecifierPublic)
};
static_assert(alignof(FCoverAction) == 0x000008, "Wrong alignment on FCoverAction");
static_assert(sizeof(FCoverAction) == 0x000130, "Wrong size on FCoverAction");
static_assert(offsetof(FCoverAction, Slot) == 0x000000, "Member 'FCoverAction::Slot' has a wrong offset!");
static_assert(offsetof(FCoverAction, Style) == 0x000008, "Member 'FCoverAction::Style' has a wrong offset!");
static_assert(offsetof(FCoverAction, Target) == 0x000010, "Member 'FCoverAction::Target' has a wrong offset!");
static_assert(offsetof(FCoverAction, Params) == 0x000018, "Member 'FCoverAction::Params' has a wrong offset!");

// ScriptStruct GbxAI.CoverStyleUserData
// 0x02A8 (0x02A8 - 0x0000)
struct FCoverStyleUserData final
{
public:
	class UCoverStyleData*                        Style;                                             // 0x0000(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FGbxParam                              Weight;                                            // 0x0008(0x0080)(Edit, NoDestructor, ContainsInstancedReference, NativeAccessSpecifierPublic)
	bool                                          bOverrideIdleTime;                                 // 0x0088(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_89[0x7];                                       // 0x0089(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	struct FGbxParam                              IdleTimeOverride;                                  // 0x0090(0x0080)(Edit, NoDestructor, ContainsInstancedReference, NativeAccessSpecifierPublic)
	bool                                          bOverrideFireTime;                                 // 0x0110(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_111[0x7];                                      // 0x0111(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	struct FGbxParam                              FireTimeOverride;                                  // 0x0118(0x0080)(Edit, NoDestructor, ContainsInstancedReference, NativeAccessSpecifierPublic)
	struct FAITicketUseData                       TicketData;                                        // 0x0198(0x0108)(Edit, NoDestructor, ContainsInstancedReference, NativeAccessSpecifierPublic)
	class UGbxCondition*                          ForceUseCondition;                                 // 0x02A0(0x0008)(Edit, ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, PersistentInstance, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FCoverStyleUserData) == 0x000008, "Wrong alignment on FCoverStyleUserData");
static_assert(sizeof(FCoverStyleUserData) == 0x0002A8, "Wrong size on FCoverStyleUserData");
static_assert(offsetof(FCoverStyleUserData, Style) == 0x000000, "Member 'FCoverStyleUserData::Style' has a wrong offset!");
static_assert(offsetof(FCoverStyleUserData, Weight) == 0x000008, "Member 'FCoverStyleUserData::Weight' has a wrong offset!");
static_assert(offsetof(FCoverStyleUserData, bOverrideIdleTime) == 0x000088, "Member 'FCoverStyleUserData::bOverrideIdleTime' has a wrong offset!");
static_assert(offsetof(FCoverStyleUserData, IdleTimeOverride) == 0x000090, "Member 'FCoverStyleUserData::IdleTimeOverride' has a wrong offset!");
static_assert(offsetof(FCoverStyleUserData, bOverrideFireTime) == 0x000110, "Member 'FCoverStyleUserData::bOverrideFireTime' has a wrong offset!");
static_assert(offsetof(FCoverStyleUserData, FireTimeOverride) == 0x000118, "Member 'FCoverStyleUserData::FireTimeOverride' has a wrong offset!");
static_assert(offsetof(FCoverStyleUserData, TicketData) == 0x000198, "Member 'FCoverStyleUserData::TicketData' has a wrong offset!");
static_assert(offsetof(FCoverStyleUserData, ForceUseCondition) == 0x0002A0, "Member 'FCoverStyleUserData::ForceUseCondition' has a wrong offset!");

// ScriptStruct GbxAI.CoverWalk
// 0x00E0 (0x00E0 - 0x0000)
struct alignas(0x08) FCoverWalk final
{
public:
	uint8                                         Pad_0[0xE0];                                       // 0x0000(0x00E0)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FCoverWalk) == 0x000008, "Wrong alignment on FCoverWalk");
static_assert(sizeof(FCoverWalk) == 0x0000E0, "Wrong size on FCoverWalk");

// ScriptStruct GbxAI.EQSDynamicPointRange
// 0x0010 (0x0010 - 0x0000)
struct FEQSDynamicPointRange final
{
public:
	int32                                         MinPoints;                                         // 0x0000(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         MaxPoints;                                         // 0x0004(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         IdealSpacing;                                      // 0x0008(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         MinSpacing;                                        // 0x000C(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FEQSDynamicPointRange) == 0x000004, "Wrong alignment on FEQSDynamicPointRange");
static_assert(sizeof(FEQSDynamicPointRange) == 0x000010, "Wrong size on FEQSDynamicPointRange");
static_assert(offsetof(FEQSDynamicPointRange, MinPoints) == 0x000000, "Member 'FEQSDynamicPointRange::MinPoints' has a wrong offset!");
static_assert(offsetof(FEQSDynamicPointRange, MaxPoints) == 0x000004, "Member 'FEQSDynamicPointRange::MaxPoints' has a wrong offset!");
static_assert(offsetof(FEQSDynamicPointRange, IdealSpacing) == 0x000008, "Member 'FEQSDynamicPointRange::IdealSpacing' has a wrong offset!");
static_assert(offsetof(FEQSDynamicPointRange, MinSpacing) == 0x00000C, "Member 'FEQSDynamicPointRange::MinSpacing' has a wrong offset!");

// ScriptStruct GbxAI.SmartGridSearchSet
// 0x00F0 (0x00F0 - 0x0000)
struct FSmartGridSearchSet final
{
public:
	class FName                                   SetName;                                           // 0x0000(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         MaxPoints;                                         // 0x0008(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_C[0x4];                                        // 0x000C(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	TSubclassOf<class UEnvQueryContext>           Center;                                            // 0x0010(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bOnlyGenerateDensePoints;                          // 0x0018(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_19[0x7];                                       // 0x0019(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	struct FAIDataProviderFloatValue              InnerRadius;                                       // 0x0020(0x0030)(Edit, ContainsInstancedReference, NativeAccessSpecifierPublic)
	struct FAIDataProviderFloatValue              OuterRadius;                                       // 0x0050(0x0030)(Edit, ContainsInstancedReference, NativeAccessSpecifierPublic)
	uint8                                         bDefineArc : 1;                                    // 0x0080(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (Edit, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         Pad_81[0x7];                                       // 0x0081(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	struct FEnvDirection                          ArcDirection;                                      // 0x0088(0x0020)(Edit, NoDestructor, NativeAccessSpecifierPublic)
	struct FAIDataProviderFloatValue              ArcAngle;                                          // 0x00A8(0x0030)(Edit, ContainsInstancedReference, NativeAccessSpecifierPublic)
	float                                         PointSeparationDistanceNormal;                     // 0x00D8(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         PointSeparationDistanceDenseSpots;                 // 0x00DC(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         RadiusApplyDenserSeparation;                       // 0x00E0(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_E4[0x4];                                       // 0x00E4(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	TSubclassOf<class UEnvQueryContext>           DenseSpotProvider;                                 // 0x00E8(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FSmartGridSearchSet) == 0x000008, "Wrong alignment on FSmartGridSearchSet");
static_assert(sizeof(FSmartGridSearchSet) == 0x0000F0, "Wrong size on FSmartGridSearchSet");
static_assert(offsetof(FSmartGridSearchSet, SetName) == 0x000000, "Member 'FSmartGridSearchSet::SetName' has a wrong offset!");
static_assert(offsetof(FSmartGridSearchSet, MaxPoints) == 0x000008, "Member 'FSmartGridSearchSet::MaxPoints' has a wrong offset!");
static_assert(offsetof(FSmartGridSearchSet, Center) == 0x000010, "Member 'FSmartGridSearchSet::Center' has a wrong offset!");
static_assert(offsetof(FSmartGridSearchSet, bOnlyGenerateDensePoints) == 0x000018, "Member 'FSmartGridSearchSet::bOnlyGenerateDensePoints' has a wrong offset!");
static_assert(offsetof(FSmartGridSearchSet, InnerRadius) == 0x000020, "Member 'FSmartGridSearchSet::InnerRadius' has a wrong offset!");
static_assert(offsetof(FSmartGridSearchSet, OuterRadius) == 0x000050, "Member 'FSmartGridSearchSet::OuterRadius' has a wrong offset!");
static_assert(offsetof(FSmartGridSearchSet, ArcDirection) == 0x000088, "Member 'FSmartGridSearchSet::ArcDirection' has a wrong offset!");
static_assert(offsetof(FSmartGridSearchSet, ArcAngle) == 0x0000A8, "Member 'FSmartGridSearchSet::ArcAngle' has a wrong offset!");
static_assert(offsetof(FSmartGridSearchSet, PointSeparationDistanceNormal) == 0x0000D8, "Member 'FSmartGridSearchSet::PointSeparationDistanceNormal' has a wrong offset!");
static_assert(offsetof(FSmartGridSearchSet, PointSeparationDistanceDenseSpots) == 0x0000DC, "Member 'FSmartGridSearchSet::PointSeparationDistanceDenseSpots' has a wrong offset!");
static_assert(offsetof(FSmartGridSearchSet, RadiusApplyDenserSeparation) == 0x0000E0, "Member 'FSmartGridSearchSet::RadiusApplyDenserSeparation' has a wrong offset!");
static_assert(offsetof(FSmartGridSearchSet, DenseSpotProvider) == 0x0000E8, "Member 'FSmartGridSearchSet::DenseSpotProvider' has a wrong offset!");

// ScriptStruct GbxAI.ExtendedTraceInfo
// 0x01D8 (0x01D8 - 0x0000)
struct FExtendedTraceInfo final
{
public:
	class FString                                 ReadableName;                                      // 0x0000(0x0010)(Edit, ZeroConstructor, DisableEditOnInstance, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FString                                 TestComment;                                       // 0x0010(0x0010)(Edit, ZeroConstructor, DisableEditOnInstance, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bDoArcTrace;                                       // 0x0020(0x0001)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_21[0x7];                                       // 0x0021(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	struct FAIDataProviderFloatValue              ArcSpeed;                                          // 0x0028(0x0030)(Edit, DisableEditOnInstance, ContainsInstancedReference, NativeAccessSpecifierPublic)
	struct FAIDataProviderFloatValue              ArcAnglePercent;                                   // 0x0058(0x0030)(Edit, DisableEditOnInstance, ContainsInstancedReference, NativeAccessSpecifierPublic)
	int32                                         NumSegments;                                       // 0x0088(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_8C[0x4];                                       // 0x008C(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	struct FEnvTraceData                          TraceData;                                         // 0x0090(0x0030)(Edit, DisableEditOnInstance, NoDestructor, NativeAccessSpecifierPublic)
	TSubclassOf<class UEnvQueryContext>           Context;                                           // 0x00C0(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EUberTraceMultiTraceRequirement               MultipleContextRequirement;                        // 0x00C8(0x0001)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_C9[0x3];                                       // 0x00C9(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         MaxScoreIfFails;                                   // 0x00CC(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         MinScoreIfSucceeds;                                // 0x00D0(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bStopIfSucceeds;                                   // 0x00D4(0x0001)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bStopIfFails;                                      // 0x00D5(0x0001)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_D6[0x2];                                       // 0x00D6(0x0002)(Fixing Size After Last Property [ Dumper-7 ])
	struct FGbxParam                              PassTestIfTrue;                                    // 0x00D8(0x0080)(Edit, DisableEditOnInstance, NoDestructor, ContainsInstancedReference, NativeAccessSpecifierPublic)
	struct FGbxParam                              FailTestIfTrue;                                    // 0x0158(0x0080)(Edit, DisableEditOnInstance, NoDestructor, ContainsInstancedReference, NativeAccessSpecifierPublic)
};
static_assert(alignof(FExtendedTraceInfo) == 0x000008, "Wrong alignment on FExtendedTraceInfo");
static_assert(sizeof(FExtendedTraceInfo) == 0x0001D8, "Wrong size on FExtendedTraceInfo");
static_assert(offsetof(FExtendedTraceInfo, ReadableName) == 0x000000, "Member 'FExtendedTraceInfo::ReadableName' has a wrong offset!");
static_assert(offsetof(FExtendedTraceInfo, TestComment) == 0x000010, "Member 'FExtendedTraceInfo::TestComment' has a wrong offset!");
static_assert(offsetof(FExtendedTraceInfo, bDoArcTrace) == 0x000020, "Member 'FExtendedTraceInfo::bDoArcTrace' has a wrong offset!");
static_assert(offsetof(FExtendedTraceInfo, ArcSpeed) == 0x000028, "Member 'FExtendedTraceInfo::ArcSpeed' has a wrong offset!");
static_assert(offsetof(FExtendedTraceInfo, ArcAnglePercent) == 0x000058, "Member 'FExtendedTraceInfo::ArcAnglePercent' has a wrong offset!");
static_assert(offsetof(FExtendedTraceInfo, NumSegments) == 0x000088, "Member 'FExtendedTraceInfo::NumSegments' has a wrong offset!");
static_assert(offsetof(FExtendedTraceInfo, TraceData) == 0x000090, "Member 'FExtendedTraceInfo::TraceData' has a wrong offset!");
static_assert(offsetof(FExtendedTraceInfo, Context) == 0x0000C0, "Member 'FExtendedTraceInfo::Context' has a wrong offset!");
static_assert(offsetof(FExtendedTraceInfo, MultipleContextRequirement) == 0x0000C8, "Member 'FExtendedTraceInfo::MultipleContextRequirement' has a wrong offset!");
static_assert(offsetof(FExtendedTraceInfo, MaxScoreIfFails) == 0x0000CC, "Member 'FExtendedTraceInfo::MaxScoreIfFails' has a wrong offset!");
static_assert(offsetof(FExtendedTraceInfo, MinScoreIfSucceeds) == 0x0000D0, "Member 'FExtendedTraceInfo::MinScoreIfSucceeds' has a wrong offset!");
static_assert(offsetof(FExtendedTraceInfo, bStopIfSucceeds) == 0x0000D4, "Member 'FExtendedTraceInfo::bStopIfSucceeds' has a wrong offset!");
static_assert(offsetof(FExtendedTraceInfo, bStopIfFails) == 0x0000D5, "Member 'FExtendedTraceInfo::bStopIfFails' has a wrong offset!");
static_assert(offsetof(FExtendedTraceInfo, PassTestIfTrue) == 0x0000D8, "Member 'FExtendedTraceInfo::PassTestIfTrue' has a wrong offset!");
static_assert(offsetof(FExtendedTraceInfo, FailTestIfTrue) == 0x000158, "Member 'FExtendedTraceInfo::FailTestIfTrue' has a wrong offset!");

// ScriptStruct GbxAI.ActionState_CoverHitReaction
// 0x0000 (0x0468 - 0x0468)
struct FActionState_CoverHitReaction final : public FActionState_SimpleAnim
{
};
static_assert(alignof(FActionState_CoverHitReaction) == 0x000008, "Wrong alignment on FActionState_CoverHitReaction");
static_assert(sizeof(FActionState_CoverHitReaction) == 0x000468, "Wrong size on FActionState_CoverHitReaction");

// ScriptStruct GbxAI.CoverHitReactionItem
// 0x0088 (0x0088 - 0x0000)
struct FCoverHitReactionItem final
{
public:
	struct FAnimMeshList                          Anims;                                             // 0x0000(0x0078)(Edit, NativeAccessSpecifierPublic)
	TArray<class UCoverStyleData*>                Styles;                                            // 0x0078(0x0010)(Edit, ZeroConstructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(FCoverHitReactionItem) == 0x000008, "Wrong alignment on FCoverHitReactionItem");
static_assert(sizeof(FCoverHitReactionItem) == 0x000088, "Wrong size on FCoverHitReactionItem");
static_assert(offsetof(FCoverHitReactionItem, Anims) == 0x000000, "Member 'FCoverHitReactionItem::Anims' has a wrong offset!");
static_assert(offsetof(FCoverHitReactionItem, Styles) == 0x000078, "Member 'FCoverHitReactionItem::Styles' has a wrong offset!");

// ScriptStruct GbxAI.ActionState_CoverTransition
// 0x0008 (0x00D0 - 0x00C8)
struct FActionState_CoverTransition final : public FActionState_Base
{
public:
	uint8                                         Pad_C8[0x8];                                       // 0x00C8(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FActionState_CoverTransition) == 0x000008, "Wrong alignment on FActionState_CoverTransition");
static_assert(sizeof(FActionState_CoverTransition) == 0x0000D0, "Wrong size on FActionState_CoverTransition");

// ScriptStruct GbxAI.ActionState_Navigation
// 0x0008 (0x0470 - 0x0468)
struct FActionState_Navigation : public FActionState_SimpleAnim
{
public:
	uint8                                         Pad_468[0x8];                                      // 0x0468(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FActionState_Navigation) == 0x000008, "Wrong alignment on FActionState_Navigation");
static_assert(sizeof(FActionState_Navigation) == 0x000470, "Wrong size on FActionState_Navigation");

// ScriptStruct GbxAI.ActionState_NavAnim
// 0x0000 (0x0470 - 0x0470)
struct FActionState_NavAnim final : public FActionState_Navigation
{
};
static_assert(alignof(FActionState_NavAnim) == 0x000008, "Wrong alignment on FActionState_NavAnim");
static_assert(sizeof(FActionState_NavAnim) == 0x000470, "Wrong size on FActionState_NavAnim");

// ScriptStruct GbxAI.ActionState_NavJump
// 0x00B0 (0x0520 - 0x0470)
struct FActionState_NavJump : public FActionState_Navigation
{
public:
	uint8                                         Pad_470[0xB0];                                     // 0x0470(0x00B0)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FActionState_NavJump) == 0x000008, "Wrong alignment on FActionState_NavJump");
static_assert(sizeof(FActionState_NavJump) == 0x000520, "Wrong size on FActionState_NavJump");

// ScriptStruct GbxAI.ActionState_NavHomingJump
// 0x0040 (0x0560 - 0x0520)
struct FActionState_NavHomingJump : public FActionState_NavJump
{
public:
	uint8                                         Pad_520[0x40];                                     // 0x0520(0x0040)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FActionState_NavHomingJump) == 0x000008, "Wrong alignment on FActionState_NavHomingJump");
static_assert(sizeof(FActionState_NavHomingJump) == 0x000560, "Wrong size on FActionState_NavHomingJump");

// ScriptStruct GbxAI.ReplicatedJumpParams
// 0x001C (0x001C - 0x0000)
struct FReplicatedJumpParams final
{
public:
	bool                                          bStarted;                                          // 0x0000(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1[0x3];                                        // 0x0001(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	struct FVector                                EndLoc;                                            // 0x0004(0x000C)(IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                TargetVel;                                         // 0x0010(0x000C)(IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FReplicatedJumpParams) == 0x000004, "Wrong alignment on FReplicatedJumpParams");
static_assert(sizeof(FReplicatedJumpParams) == 0x00001C, "Wrong size on FReplicatedJumpParams");
static_assert(offsetof(FReplicatedJumpParams, bStarted) == 0x000000, "Member 'FReplicatedJumpParams::bStarted' has a wrong offset!");
static_assert(offsetof(FReplicatedJumpParams, EndLoc) == 0x000004, "Member 'FReplicatedJumpParams::EndLoc' has a wrong offset!");
static_assert(offsetof(FReplicatedJumpParams, TargetVel) == 0x000010, "Member 'FReplicatedJumpParams::TargetVel' has a wrong offset!");

// ScriptStruct GbxAI.ActionState_NavLerp
// 0x00C8 (0x0538 - 0x0470)
struct FActionState_NavLerp final : public FActionState_Navigation
{
public:
	uint8                                         Pad_470[0xC8];                                     // 0x0470(0x00C8)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FActionState_NavLerp) == 0x000008, "Wrong alignment on FActionState_NavLerp");
static_assert(sizeof(FActionState_NavLerp) == 0x000538, "Wrong size on FActionState_NavLerp");

// ScriptStruct GbxAI.SmartActionUser
// 0x0010 (0x0010 - 0x0000)
struct FSmartActionUser final
{
public:
	class AController*                            Controller;                                        // 0x0000(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         UseDuration;                                       // 0x0008(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	ESmartObjectTaskState                         State;                                             // 0x000C(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_D[0x3];                                        // 0x000D(0x0003)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FSmartActionUser) == 0x000008, "Wrong alignment on FSmartActionUser");
static_assert(sizeof(FSmartActionUser) == 0x000010, "Wrong size on FSmartActionUser");
static_assert(offsetof(FSmartActionUser, Controller) == 0x000000, "Member 'FSmartActionUser::Controller' has a wrong offset!");
static_assert(offsetof(FSmartActionUser, UseDuration) == 0x000008, "Member 'FSmartActionUser::UseDuration' has a wrong offset!");
static_assert(offsetof(FSmartActionUser, State) == 0x00000C, "Member 'FSmartActionUser::State' has a wrong offset!");

// ScriptStruct GbxAI.SmartObjectActionState
// 0x0080 (0x0080 - 0x0000)
struct FSmartObjectActionState final
{
public:
	bool                                          bEnabled;                                          // 0x0000(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1[0x7];                                        // 0x0001(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	struct FGameplayTag                           ActionTag;                                         // 0x0008(0x0008)(Edit, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class USmartObjectAction*                     ActionDefinition;                                  // 0x0010(0x0008)(Edit, ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, PersistentInstance, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FColor                                 DebugColor;                                        // 0x0018(0x0004)(Edit, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         CooldownTime;                                      // 0x001C(0x0004)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	TArray<struct FSmartActionUser>               Users;                                             // 0x0020(0x0010)(ZeroConstructor, Transient, NativeAccessSpecifierPrivate)
	TMap<class AController*, float>               CooldownMap;                                       // 0x0030(0x0050)(ZeroConstructor, Transient, NativeAccessSpecifierPrivate)
};
static_assert(alignof(FSmartObjectActionState) == 0x000008, "Wrong alignment on FSmartObjectActionState");
static_assert(sizeof(FSmartObjectActionState) == 0x000080, "Wrong size on FSmartObjectActionState");
static_assert(offsetof(FSmartObjectActionState, bEnabled) == 0x000000, "Member 'FSmartObjectActionState::bEnabled' has a wrong offset!");
static_assert(offsetof(FSmartObjectActionState, ActionTag) == 0x000008, "Member 'FSmartObjectActionState::ActionTag' has a wrong offset!");
static_assert(offsetof(FSmartObjectActionState, ActionDefinition) == 0x000010, "Member 'FSmartObjectActionState::ActionDefinition' has a wrong offset!");
static_assert(offsetof(FSmartObjectActionState, DebugColor) == 0x000018, "Member 'FSmartObjectActionState::DebugColor' has a wrong offset!");
static_assert(offsetof(FSmartObjectActionState, CooldownTime) == 0x00001C, "Member 'FSmartObjectActionState::CooldownTime' has a wrong offset!");
static_assert(offsetof(FSmartObjectActionState, Users) == 0x000020, "Member 'FSmartObjectActionState::Users' has a wrong offset!");
static_assert(offsetof(FSmartObjectActionState, CooldownMap) == 0x000030, "Member 'FSmartObjectActionState::CooldownMap' has a wrong offset!");

// ScriptStruct GbxAI.RouteSection
// 0x0010 (0x0010 - 0x0000)
struct FRouteSection final
{
public:
	class AActor*                                 Start;                                             // 0x0000(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class AActor*                                 End;                                               // 0x0008(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FRouteSection) == 0x000008, "Wrong alignment on FRouteSection");
static_assert(sizeof(FRouteSection) == 0x000010, "Wrong size on FRouteSection");
static_assert(offsetof(FRouteSection, Start) == 0x000000, "Member 'FRouteSection::Start' has a wrong offset!");
static_assert(offsetof(FRouteSection, End) == 0x000008, "Member 'FRouteSection::End' has a wrong offset!");

// ScriptStruct GbxAI.SmartObjectPreviewState
// 0x0018 (0x00F0 - 0x00D8)
struct FSmartObjectPreviewState final : public FPreviewState
{
public:
	class UAIUseSlotComponent*                    AIUseSlotComponent;                                // 0x00D8(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	TArray<class USpawnFactory*>                  PreviewFactories;                                  // 0x00E0(0x0010)(ZeroConstructor, NativeAccessSpecifierPrivate)
};
static_assert(alignof(FSmartObjectPreviewState) == 0x000008, "Wrong alignment on FSmartObjectPreviewState");
static_assert(sizeof(FSmartObjectPreviewState) == 0x0000F0, "Wrong size on FSmartObjectPreviewState");
static_assert(offsetof(FSmartObjectPreviewState, AIUseSlotComponent) == 0x0000D8, "Member 'FSmartObjectPreviewState::AIUseSlotComponent' has a wrong offset!");
static_assert(offsetof(FSmartObjectPreviewState, PreviewFactories) == 0x0000E0, "Member 'FSmartObjectPreviewState::PreviewFactories' has a wrong offset!");

// ScriptStruct GbxAI.SmartAction
// 0x0010 (0x0010 - 0x0000)
struct FSmartAction final
{
public:
	TWeakObjectPtr<class AActor>                  SmartObject;                                       // 0x0000(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FGameplayTag                           ActionTag;                                         // 0x0008(0x0008)(NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FSmartAction) == 0x000008, "Wrong alignment on FSmartAction");
static_assert(sizeof(FSmartAction) == 0x000010, "Wrong size on FSmartAction");
static_assert(offsetof(FSmartAction, SmartObject) == 0x000000, "Member 'FSmartAction::SmartObject' has a wrong offset!");
static_assert(offsetof(FSmartAction, ActionTag) == 0x000008, "Member 'FSmartAction::ActionTag' has a wrong offset!");

// ScriptStruct GbxAI.SmartObjectUseRequest
// 0x0028 (0x0028 - 0x0000)
struct alignas(0x08) FSmartObjectUseRequest final
{
public:
	uint8                                         Pad_0[0x28];                                       // 0x0000(0x0028)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FSmartObjectUseRequest) == 0x000008, "Wrong alignment on FSmartObjectUseRequest");
static_assert(sizeof(FSmartObjectUseRequest) == 0x000028, "Wrong size on FSmartObjectUseRequest");

// ScriptStruct GbxAI.SmartObjectActionSet
// 0x0020 (0x0020 - 0x0000)
struct FSmartObjectActionSet final
{
public:
	struct FGameplayTagContainer                  Actions;                                           // 0x0000(0x0020)(Edit, BlueprintVisible, NativeAccessSpecifierPublic)
};
static_assert(alignof(FSmartObjectActionSet) == 0x000008, "Wrong alignment on FSmartObjectActionSet");
static_assert(sizeof(FSmartObjectActionSet) == 0x000020, "Wrong size on FSmartObjectActionSet");
static_assert(offsetof(FSmartObjectActionSet, Actions) == 0x000000, "Member 'FSmartObjectActionSet::Actions' has a wrong offset!");

}

