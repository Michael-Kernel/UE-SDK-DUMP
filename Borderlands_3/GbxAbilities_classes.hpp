#pragma once

/*
* SDK generated by Dumper-7
*
* https://github.com/Encryqed/Dumper-7
*/

// Package: GbxAbilities

#include "Basic.hpp"

#include "GbxGameSystemCore_classes.hpp"
#include "CoreUObject_classes.hpp"
#include "GbxAbilities_structs.hpp"
#include "GbxRuntime_classes.hpp"
#include "Engine_classes.hpp"


namespace SDK
{

// Class GbxAbilities.GbxAbilityEffectTargetResolutionData
// 0x0000 (0x0030 - 0x0030)
class UGbxAbilityEffectTargetResolutionData : public UGbxDataAsset
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"GbxAbilityEffectTargetResolutionData">();
	}
	static class UGbxAbilityEffectTargetResolutionData* GetDefaultObj()
	{
		return GetDefaultObjImpl<UGbxAbilityEffectTargetResolutionData>();
	}
};
static_assert(alignof(UGbxAbilityEffectTargetResolutionData) == 0x000008, "Wrong alignment on UGbxAbilityEffectTargetResolutionData");
static_assert(sizeof(UGbxAbilityEffectTargetResolutionData) == 0x000030, "Wrong size on UGbxAbilityEffectTargetResolutionData");

// Class GbxAbilities.GbxAbilityEffectTargetResolutionData_Self
// 0x0000 (0x0030 - 0x0030)
class UGbxAbilityEffectTargetResolutionData_Self final : public UGbxAbilityEffectTargetResolutionData
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"GbxAbilityEffectTargetResolutionData_Self">();
	}
	static class UGbxAbilityEffectTargetResolutionData_Self* GetDefaultObj()
	{
		return GetDefaultObjImpl<UGbxAbilityEffectTargetResolutionData_Self>();
	}
};
static_assert(alignof(UGbxAbilityEffectTargetResolutionData_Self) == 0x000008, "Wrong alignment on UGbxAbilityEffectTargetResolutionData_Self");
static_assert(sizeof(UGbxAbilityEffectTargetResolutionData_Self) == 0x000030, "Wrong size on UGbxAbilityEffectTargetResolutionData_Self");

// Class GbxAbilities.GbxAbility
// 0x00C0 (0x00E8 - 0x0028)
class UGbxAbility : public UObject
{
public:
	uint8                                         Pad_28[0x18];                                      // 0x0028(0x0018)(Fixing Size After Last Property [ Dumper-7 ])
	class FText                                   AbilityName;                                       // 0x0040(0x0018)(Edit, BlueprintVisible, BlueprintReadOnly, DisableEditOnInstance, Protected, NativeAccessSpecifierProtected)
	class FText                                   AbilityDescription;                                // 0x0058(0x0018)(Edit, BlueprintVisible, BlueprintReadOnly, DisableEditOnInstance, Protected, NativeAccessSpecifierProtected)
	TArray<struct FGbxAbilityEffect>              AbilityEffects;                                    // 0x0070(0x0010)(Edit, ZeroConstructor, DisableEditOnInstance, ContainsInstancedReference, Protected, NativeAccessSpecifierProtected)
	uint8                                         Pad_80[0x10];                                      // 0x0080(0x0010)(Fixing Size After Last Property [ Dumper-7 ])
	class UGbxAbilityManagerComponent*            Manager;                                           // 0x0090(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, Net, ZeroConstructor, Transient, InstancedReference, IsPlainOldData, RepNotify, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	EGbxAbilityDurationType                       DurationType;                                      // 0x0098(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_99[0x3];                                       // 0x0099(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         Duration;                                          // 0x009C(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	EGbxAbilityState                              DesiredAbilityState;                               // 0x00A0(0x0001)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	EGbxAbilityState                              AbilityState;                                      // 0x00A1(0x0001)(BlueprintVisible, BlueprintReadOnly, Net, ZeroConstructor, Transient, IsPlainOldData, RepNotify, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_A2[0x6];                                       // 0x00A2(0x0006)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<struct FGbxAbilityEffectInstance>      AbilityEffectInstances;                            // 0x00A8(0x0010)(ZeroConstructor, Transient, ContainsInstancedReference, NativeAccessSpecifierPrivate)
	uint8                                         Pad_B8[0x10];                                      // 0x00B8(0x0010)(Fixing Size After Last Property [ Dumper-7 ])
	class UGbxAbilityManagerComponent*            PendingManager;                                    // 0x00C8(0x0008)(ExportObject, ZeroConstructor, Transient, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_D0[0x18];                                      // 0x00D0(0x0018)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	EGbxAbilityState CalculateAbilityState();
	void Client_Deactivate();
	void OnActivated();
	void OnDeactivated();
	void OnForcedRefresh();
	void OnPaused();
	void OnRegistered();
	void OnRep_AbilityState();
	void OnRep_Manager();
	void OnResumed();
	void OnUnregistered();

	class AActor* GetAbilityOwner() const;
	bool IsReplicated() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"GbxAbility">();
	}
	static class UGbxAbility* GetDefaultObj()
	{
		return GetDefaultObjImpl<UGbxAbility>();
	}
};
static_assert(alignof(UGbxAbility) == 0x000008, "Wrong alignment on UGbxAbility");
static_assert(sizeof(UGbxAbility) == 0x0000E8, "Wrong size on UGbxAbility");
static_assert(offsetof(UGbxAbility, AbilityName) == 0x000040, "Member 'UGbxAbility::AbilityName' has a wrong offset!");
static_assert(offsetof(UGbxAbility, AbilityDescription) == 0x000058, "Member 'UGbxAbility::AbilityDescription' has a wrong offset!");
static_assert(offsetof(UGbxAbility, AbilityEffects) == 0x000070, "Member 'UGbxAbility::AbilityEffects' has a wrong offset!");
static_assert(offsetof(UGbxAbility, Manager) == 0x000090, "Member 'UGbxAbility::Manager' has a wrong offset!");
static_assert(offsetof(UGbxAbility, DurationType) == 0x000098, "Member 'UGbxAbility::DurationType' has a wrong offset!");
static_assert(offsetof(UGbxAbility, Duration) == 0x00009C, "Member 'UGbxAbility::Duration' has a wrong offset!");
static_assert(offsetof(UGbxAbility, DesiredAbilityState) == 0x0000A0, "Member 'UGbxAbility::DesiredAbilityState' has a wrong offset!");
static_assert(offsetof(UGbxAbility, AbilityState) == 0x0000A1, "Member 'UGbxAbility::AbilityState' has a wrong offset!");
static_assert(offsetof(UGbxAbility, AbilityEffectInstances) == 0x0000A8, "Member 'UGbxAbility::AbilityEffectInstances' has a wrong offset!");
static_assert(offsetof(UGbxAbility, PendingManager) == 0x0000C8, "Member 'UGbxAbility::PendingManager' has a wrong offset!");

// Class GbxAbilities.GbxAbilityManagerComponent
// 0x00D0 (0x0248 - 0x0178)
class UGbxAbilityManagerComponent : public UActorComponent
{
public:
	uint8                                         Pad_178[0x30];                                     // 0x0178(0x0030)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<class UGbxAbility*>                    Abilities;                                         // 0x01A8(0x0010)(ZeroConstructor, Transient, NativeAccessSpecifierPrivate)
	TArray<class UGbxAbility*>                    ReplicatedAbilities;                               // 0x01B8(0x0010)(ZeroConstructor, Transient, NativeAccessSpecifierPrivate)
	TArray<class UGbxAbility*>                    PendingReplicatedAbilities;                        // 0x01C8(0x0010)(ZeroConstructor, Transient, NativeAccessSpecifierPrivate)
	TMap<TSubclassOf<class UGbxAbility>, class UGbxAbility*> RegisteredAbilities;                               // 0x01D8(0x0050)(ZeroConstructor, Transient, NativeAccessSpecifierPrivate)
	struct FGbxAbilityManagerComponentListLock    ListLock;                                          // 0x0228(0x0020)(Transient, ContainsInstancedReference, NativeAccessSpecifierPrivate)

public:
	class UGbxAbility* AddAbility(const struct FGbxAbilitySpec& Spec);
	bool RemoveAbility(TSubclassOf<class UGbxAbility> AbilityClass);

	class UGbxAbility* FindAbility(TSubclassOf<class UGbxAbility> AbilityClass) const;
	bool HasAbility(TSubclassOf<class UGbxAbility> AbilityClass) const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"GbxAbilityManagerComponent">();
	}
	static class UGbxAbilityManagerComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UGbxAbilityManagerComponent>();
	}
};
static_assert(alignof(UGbxAbilityManagerComponent) == 0x000008, "Wrong alignment on UGbxAbilityManagerComponent");
static_assert(sizeof(UGbxAbilityManagerComponent) == 0x000248, "Wrong size on UGbxAbilityManagerComponent");
static_assert(offsetof(UGbxAbilityManagerComponent, Abilities) == 0x0001A8, "Member 'UGbxAbilityManagerComponent::Abilities' has a wrong offset!");
static_assert(offsetof(UGbxAbilityManagerComponent, ReplicatedAbilities) == 0x0001B8, "Member 'UGbxAbilityManagerComponent::ReplicatedAbilities' has a wrong offset!");
static_assert(offsetof(UGbxAbilityManagerComponent, PendingReplicatedAbilities) == 0x0001C8, "Member 'UGbxAbilityManagerComponent::PendingReplicatedAbilities' has a wrong offset!");
static_assert(offsetof(UGbxAbilityManagerComponent, RegisteredAbilities) == 0x0001D8, "Member 'UGbxAbilityManagerComponent::RegisteredAbilities' has a wrong offset!");
static_assert(offsetof(UGbxAbilityManagerComponent, ListLock) == 0x000228, "Member 'UGbxAbilityManagerComponent::ListLock' has a wrong offset!");

// Class GbxAbilities.GbxAbilityAttributePropertyValueResolver
// 0x0028 (0x00D8 - 0x00B0)
class UGbxAbilityAttributePropertyValueResolver final : public UAttributePropertyValueResolver
{
public:
	TSoftClassPtr<class UClass>                   GbxAbilityClass;                                   // 0x00B0(0x0028)(Edit, DisableEditOnInstance, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"GbxAbilityAttributePropertyValueResolver">();
	}
	static class UGbxAbilityAttributePropertyValueResolver* GetDefaultObj()
	{
		return GetDefaultObjImpl<UGbxAbilityAttributePropertyValueResolver>();
	}
};
static_assert(alignof(UGbxAbilityAttributePropertyValueResolver) == 0x000008, "Wrong alignment on UGbxAbilityAttributePropertyValueResolver");
static_assert(sizeof(UGbxAbilityAttributePropertyValueResolver) == 0x0000D8, "Wrong size on UGbxAbilityAttributePropertyValueResolver");
static_assert(offsetof(UGbxAbilityAttributePropertyValueResolver, GbxAbilityClass) == 0x0000B0, "Member 'UGbxAbilityAttributePropertyValueResolver::GbxAbilityClass' has a wrong offset!");

// Class GbxAbilities.GbxAbilityEffectTargetResolutionData_Owner
// 0x0000 (0x0030 - 0x0030)
class UGbxAbilityEffectTargetResolutionData_Owner final : public UGbxAbilityEffectTargetResolutionData
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"GbxAbilityEffectTargetResolutionData_Owner">();
	}
	static class UGbxAbilityEffectTargetResolutionData_Owner* GetDefaultObj()
	{
		return GetDefaultObjImpl<UGbxAbilityEffectTargetResolutionData_Owner>();
	}
};
static_assert(alignof(UGbxAbilityEffectTargetResolutionData_Owner) == 0x000008, "Wrong alignment on UGbxAbilityEffectTargetResolutionData_Owner");
static_assert(sizeof(UGbxAbilityEffectTargetResolutionData_Owner) == 0x000030, "Wrong size on UGbxAbilityEffectTargetResolutionData_Owner");

// Class GbxAbilities.GbxAbilityResourceControllerBlueprintFunctionLibrary
// 0x0000 (0x0028 - 0x0028)
class UGbxAbilityResourceControllerBlueprintFunctionLibrary final : public UBlueprintFunctionLibrary
{
public:
	static void RegisterAbilityDelegate(struct FGbxAbilityResourceController_ScriptDelegate& Controller, const struct FGbxAbilityResourceSpec_ScriptDelegate& Spec);
	static void RegisterConditionalDamageModifier(struct FGbxAbilityResourceController_ConditionalDamageModifier& Controller, const struct FGbxAbilityResourceSpec_ConditionalDamageModifier& Spec);
	static void RegisterResourcePoolDelegate(struct FGbxAbilityResourceController_ResourcePoolDelegate& Controller, const struct FGbxAbilityResourceSpec_ResourcePoolDelegate& Spec);
	static void UnregisterAbilityDelegate(struct FGbxAbilityResourceController_ScriptDelegate& Controller, const struct FGbxAbilityResourceSpec_ScriptDelegate& Spec);
	static void UnregisterConditionalDamageModifier(struct FGbxAbilityResourceController_ConditionalDamageModifier& Controller, const struct FGbxAbilityResourceSpec_ConditionalDamageModifier& Spec);
	static void UnregisterResourcePoolDelegate(struct FGbxAbilityResourceController_ResourcePoolDelegate& Controller, const struct FGbxAbilityResourceSpec_ResourcePoolDelegate& Spec);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"GbxAbilityResourceControllerBlueprintFunctionLibrary">();
	}
	static class UGbxAbilityResourceControllerBlueprintFunctionLibrary* GetDefaultObj()
	{
		return GetDefaultObjImpl<UGbxAbilityResourceControllerBlueprintFunctionLibrary>();
	}
};
static_assert(alignof(UGbxAbilityResourceControllerBlueprintFunctionLibrary) == 0x000008, "Wrong alignment on UGbxAbilityResourceControllerBlueprintFunctionLibrary");
static_assert(sizeof(UGbxAbilityResourceControllerBlueprintFunctionLibrary) == 0x000028, "Wrong size on UGbxAbilityResourceControllerBlueprintFunctionLibrary");

// Class GbxAbilities.GbxCondition_HasAbility
// 0x0008 (0x0090 - 0x0088)
class UGbxCondition_HasAbility final : public UGbxCondition
{
public:
	TSubclassOf<class UGbxAbility>                AbilityClass;                                      // 0x0088(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"GbxCondition_HasAbility">();
	}
	static class UGbxCondition_HasAbility* GetDefaultObj()
	{
		return GetDefaultObjImpl<UGbxCondition_HasAbility>();
	}
};
static_assert(alignof(UGbxCondition_HasAbility) == 0x000008, "Wrong alignment on UGbxCondition_HasAbility");
static_assert(sizeof(UGbxCondition_HasAbility) == 0x000090, "Wrong size on UGbxCondition_HasAbility");
static_assert(offsetof(UGbxCondition_HasAbility, AbilityClass) == 0x000088, "Member 'UGbxCondition_HasAbility::AbilityClass' has a wrong offset!");

}

