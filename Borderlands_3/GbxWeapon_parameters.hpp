#pragma once

/*
* SDK generated by Dumper-7
*
* https://github.com/Encryqed/Dumper-7
*/

// Package: GbxWeapon

#include "Basic.hpp"

#include "Engine_structs.hpp"
#include "GbxWeapon_structs.hpp"
#include "GbxGameSystemCore_structs.hpp"
#include "CoreUObject_structs.hpp"
#include "AIModule_structs.hpp"


namespace SDK::Params
{

// Function GbxWeapon.Weapon.Activate
// 0x0010 (0x0010 - 0x0000)
struct Weapon_Activate final
{
public:
	class APawn*                                  WeaponOwner;                                       // 0x0000(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         InSlot;                                            // 0x0008(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EWeaponEquipType                              InEquipType;                                       // 0x0009(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_A[0x6];                                        // 0x000A(0x0006)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(Weapon_Activate) == 0x000008, "Wrong alignment on Weapon_Activate");
static_assert(sizeof(Weapon_Activate) == 0x000010, "Wrong size on Weapon_Activate");
static_assert(offsetof(Weapon_Activate, WeaponOwner) == 0x000000, "Member 'Weapon_Activate::WeaponOwner' has a wrong offset!");
static_assert(offsetof(Weapon_Activate, InSlot) == 0x000008, "Member 'Weapon_Activate::InSlot' has a wrong offset!");
static_assert(offsetof(Weapon_Activate, InEquipType) == 0x000009, "Member 'Weapon_Activate::InEquipType' has a wrong offset!");

// Function GbxWeapon.Weapon.AddUseMode
// 0x0020 (0x0020 - 0x0000)
struct Weapon_AddUseMode final
{
public:
	class UWeaponUseComponent*                    UseComponent;                                      // 0x0000(0x0008)(Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TArray<class UActorComponent*>                OtherComponents;                                   // 0x0008(0x0010)(ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, ContainsInstancedReference, NativeAccessSpecifierPublic)
	int32                                         InputChannels;                                     // 0x0018(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         ReturnValue;                                       // 0x001C(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1D[0x3];                                       // 0x001D(0x0003)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(Weapon_AddUseMode) == 0x000008, "Wrong alignment on Weapon_AddUseMode");
static_assert(sizeof(Weapon_AddUseMode) == 0x000020, "Wrong size on Weapon_AddUseMode");
static_assert(offsetof(Weapon_AddUseMode, UseComponent) == 0x000000, "Member 'Weapon_AddUseMode::UseComponent' has a wrong offset!");
static_assert(offsetof(Weapon_AddUseMode, OtherComponents) == 0x000008, "Member 'Weapon_AddUseMode::OtherComponents' has a wrong offset!");
static_assert(offsetof(Weapon_AddUseMode, InputChannels) == 0x000018, "Member 'Weapon_AddUseMode::InputChannels' has a wrong offset!");
static_assert(offsetof(Weapon_AddUseMode, ReturnValue) == 0x00001C, "Member 'Weapon_AddUseMode::ReturnValue' has a wrong offset!");

// Function GbxWeapon.Weapon.ClientLock
// 0x0004 (0x0004 - 0x0000)
struct Weapon_ClientLock final
{
public:
	float                                         Duration;                                          // 0x0000(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(Weapon_ClientLock) == 0x000004, "Wrong alignment on Weapon_ClientLock");
static_assert(sizeof(Weapon_ClientLock) == 0x000004, "Wrong size on Weapon_ClientLock");
static_assert(offsetof(Weapon_ClientLock, Duration) == 0x000000, "Member 'Weapon_ClientLock::Duration' has a wrong offset!");

// Function GbxWeapon.Weapon.GivenTo
// 0x0008 (0x0008 - 0x0000)
struct Weapon_GivenTo final
{
public:
	class APawn*                                  NewOwner;                                          // 0x0000(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(Weapon_GivenTo) == 0x000008, "Wrong alignment on Weapon_GivenTo");
static_assert(sizeof(Weapon_GivenTo) == 0x000008, "Wrong size on Weapon_GivenTo");
static_assert(offsetof(Weapon_GivenTo, NewOwner) == 0x000000, "Member 'Weapon_GivenTo::NewOwner' has a wrong offset!");

// Function GbxWeapon.Weapon.K2_PlayWeaponAction
// 0x0018 (0x0018 - 0x0000)
struct Weapon_K2_PlayWeaponAction final
{
public:
	EWeaponActionType                             WeaponAction;                                      // 0x0000(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1[0x3];                                        // 0x0001(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         PlayRate;                                          // 0x0004(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         Duration;                                          // 0x0008(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bCheckForRelevancy;                                // 0x000C(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_D[0x3];                                        // 0x000D(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	class UGbxAction*                             ReturnValue;                                       // 0x0010(0x0008)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(Weapon_K2_PlayWeaponAction) == 0x000008, "Wrong alignment on Weapon_K2_PlayWeaponAction");
static_assert(sizeof(Weapon_K2_PlayWeaponAction) == 0x000018, "Wrong size on Weapon_K2_PlayWeaponAction");
static_assert(offsetof(Weapon_K2_PlayWeaponAction, WeaponAction) == 0x000000, "Member 'Weapon_K2_PlayWeaponAction::WeaponAction' has a wrong offset!");
static_assert(offsetof(Weapon_K2_PlayWeaponAction, PlayRate) == 0x000004, "Member 'Weapon_K2_PlayWeaponAction::PlayRate' has a wrong offset!");
static_assert(offsetof(Weapon_K2_PlayWeaponAction, Duration) == 0x000008, "Member 'Weapon_K2_PlayWeaponAction::Duration' has a wrong offset!");
static_assert(offsetof(Weapon_K2_PlayWeaponAction, bCheckForRelevancy) == 0x00000C, "Member 'Weapon_K2_PlayWeaponAction::bCheckForRelevancy' has a wrong offset!");
static_assert(offsetof(Weapon_K2_PlayWeaponAction, ReturnValue) == 0x000010, "Member 'Weapon_K2_PlayWeaponAction::ReturnValue' has a wrong offset!");

// Function GbxWeapon.Weapon.K2_PlayWeaponActionEx
// 0x00E0 (0x00E0 - 0x0000)
struct Weapon_K2_PlayWeaponActionEx final
{
public:
	EWeaponActionType                             WeaponAction;                                      // 0x0000(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1[0x7];                                        // 0x0001(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	struct FActionState_Base                      ActionParams;                                      // 0x0008(0x00C8)(Parm, NativeAccessSpecifierPublic)
	bool                                          bCheckForRelevancy;                                // 0x00D0(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_D1[0x7];                                       // 0x00D1(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	class UGbxAction*                             ReturnValue;                                       // 0x00D8(0x0008)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(Weapon_K2_PlayWeaponActionEx) == 0x000008, "Wrong alignment on Weapon_K2_PlayWeaponActionEx");
static_assert(sizeof(Weapon_K2_PlayWeaponActionEx) == 0x0000E0, "Wrong size on Weapon_K2_PlayWeaponActionEx");
static_assert(offsetof(Weapon_K2_PlayWeaponActionEx, WeaponAction) == 0x000000, "Member 'Weapon_K2_PlayWeaponActionEx::WeaponAction' has a wrong offset!");
static_assert(offsetof(Weapon_K2_PlayWeaponActionEx, ActionParams) == 0x000008, "Member 'Weapon_K2_PlayWeaponActionEx::ActionParams' has a wrong offset!");
static_assert(offsetof(Weapon_K2_PlayWeaponActionEx, bCheckForRelevancy) == 0x0000D0, "Member 'Weapon_K2_PlayWeaponActionEx::bCheckForRelevancy' has a wrong offset!");
static_assert(offsetof(Weapon_K2_PlayWeaponActionEx, ReturnValue) == 0x0000D8, "Member 'Weapon_K2_PlayWeaponActionEx::ReturnValue' has a wrong offset!");

// Function GbxWeapon.Weapon.K2_StopWeaponActionObj
// 0x0008 (0x0008 - 0x0000)
struct Weapon_K2_StopWeaponActionObj final
{
public:
	class UGbxAction*                             WeaponAction;                                      // 0x0000(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(Weapon_K2_StopWeaponActionObj) == 0x000008, "Wrong alignment on Weapon_K2_StopWeaponActionObj");
static_assert(sizeof(Weapon_K2_StopWeaponActionObj) == 0x000008, "Wrong size on Weapon_K2_StopWeaponActionObj");
static_assert(offsetof(Weapon_K2_StopWeaponActionObj, WeaponAction) == 0x000000, "Member 'Weapon_K2_StopWeaponActionObj::WeaponAction' has a wrong offset!");

// Function GbxWeapon.Weapon.Lock
// 0x0008 (0x0008 - 0x0000)
struct Weapon_Lock final
{
public:
	float                                         Duration;                                          // 0x0000(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bReplicate;                                        // 0x0004(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_5[0x3];                                        // 0x0005(0x0003)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(Weapon_Lock) == 0x000004, "Wrong alignment on Weapon_Lock");
static_assert(sizeof(Weapon_Lock) == 0x000008, "Wrong size on Weapon_Lock");
static_assert(offsetof(Weapon_Lock, Duration) == 0x000000, "Member 'Weapon_Lock::Duration' has a wrong offset!");
static_assert(offsetof(Weapon_Lock, bReplicate) == 0x000004, "Member 'Weapon_Lock::bReplicate' has a wrong offset!");

// Function GbxWeapon.Weapon.NotifySkeletalControl
// 0x0018 (0x0018 - 0x0000)
struct Weapon_NotifySkeletalControl final
{
public:
	EWeaponEffectType                             ControlType;                                       // 0x0000(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1[0x7];                                        // 0x0001(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	class FName                                   ControlName;                                       // 0x0008(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EWeaponSkeletalControlEvent                   Event;                                             // 0x0010(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_11[0x3];                                       // 0x0011(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         EventValue;                                        // 0x0014(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(Weapon_NotifySkeletalControl) == 0x000004, "Wrong alignment on Weapon_NotifySkeletalControl");
static_assert(sizeof(Weapon_NotifySkeletalControl) == 0x000018, "Wrong size on Weapon_NotifySkeletalControl");
static_assert(offsetof(Weapon_NotifySkeletalControl, ControlType) == 0x000000, "Member 'Weapon_NotifySkeletalControl::ControlType' has a wrong offset!");
static_assert(offsetof(Weapon_NotifySkeletalControl, ControlName) == 0x000008, "Member 'Weapon_NotifySkeletalControl::ControlName' has a wrong offset!");
static_assert(offsetof(Weapon_NotifySkeletalControl, Event) == 0x000010, "Member 'Weapon_NotifySkeletalControl::Event' has a wrong offset!");
static_assert(offsetof(Weapon_NotifySkeletalControl, EventValue) == 0x000014, "Member 'Weapon_NotifySkeletalControl::EventValue' has a wrong offset!");

// Function GbxWeapon.Weapon.OnReloadEnded
// 0x0001 (0x0001 - 0x0000)
struct Weapon_OnReloadEnded final
{
public:
	bool                                          bCompleted;                                        // 0x0000(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(Weapon_OnReloadEnded) == 0x000001, "Wrong alignment on Weapon_OnReloadEnded");
static_assert(sizeof(Weapon_OnReloadEnded) == 0x000001, "Wrong size on Weapon_OnReloadEnded");
static_assert(offsetof(Weapon_OnReloadEnded, bCompleted) == 0x000000, "Member 'Weapon_OnReloadEnded::bCompleted' has a wrong offset!");

// Function GbxWeapon.Weapon.OnRep_CurrentUseModeIndex
// 0x0001 (0x0001 - 0x0000)
struct Weapon_OnRep_CurrentUseModeIndex final
{
public:
	uint8                                         PreviousUseModeIndex;                              // 0x0000(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(Weapon_OnRep_CurrentUseModeIndex) == 0x000001, "Wrong alignment on Weapon_OnRep_CurrentUseModeIndex");
static_assert(sizeof(Weapon_OnRep_CurrentUseModeIndex) == 0x000001, "Wrong size on Weapon_OnRep_CurrentUseModeIndex");
static_assert(offsetof(Weapon_OnRep_CurrentUseModeIndex, PreviousUseModeIndex) == 0x000000, "Member 'Weapon_OnRep_CurrentUseModeIndex::PreviousUseModeIndex' has a wrong offset!");

// Function GbxWeapon.Weapon.PlayAnimation
// 0x0018 (0x0018 - 0x0000)
struct Weapon_PlayAnimation final
{
public:
	class UAnimMontage*                           Anim;                                              // 0x0000(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bFirstPerson;                                      // 0x0008(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_9[0x3];                                        // 0x0009(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         PlayRate;                                          // 0x000C(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         Duration;                                          // 0x0010(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         ReturnValue;                                       // 0x0014(0x0004)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(Weapon_PlayAnimation) == 0x000008, "Wrong alignment on Weapon_PlayAnimation");
static_assert(sizeof(Weapon_PlayAnimation) == 0x000018, "Wrong size on Weapon_PlayAnimation");
static_assert(offsetof(Weapon_PlayAnimation, Anim) == 0x000000, "Member 'Weapon_PlayAnimation::Anim' has a wrong offset!");
static_assert(offsetof(Weapon_PlayAnimation, bFirstPerson) == 0x000008, "Member 'Weapon_PlayAnimation::bFirstPerson' has a wrong offset!");
static_assert(offsetof(Weapon_PlayAnimation, PlayRate) == 0x00000C, "Member 'Weapon_PlayAnimation::PlayRate' has a wrong offset!");
static_assert(offsetof(Weapon_PlayAnimation, Duration) == 0x000010, "Member 'Weapon_PlayAnimation::Duration' has a wrong offset!");
static_assert(offsetof(Weapon_PlayAnimation, ReturnValue) == 0x000014, "Member 'Weapon_PlayAnimation::ReturnValue' has a wrong offset!");

// Function GbxWeapon.Weapon.PlayDynamicMaterialEffect
// 0x0068 (0x0068 - 0x0000)
struct Weapon_PlayDynamicMaterialEffect final
{
public:
	struct FWeaponMaterialEffectData              Data;                                              // 0x0000(0x0060)(ConstParm, Parm, OutParm, ReferenceParm, NoDestructor, NativeAccessSpecifierPublic)
	int32                                         ReturnValue;                                       // 0x0060(0x0004)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_64[0x4];                                       // 0x0064(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(Weapon_PlayDynamicMaterialEffect) == 0x000008, "Wrong alignment on Weapon_PlayDynamicMaterialEffect");
static_assert(sizeof(Weapon_PlayDynamicMaterialEffect) == 0x000068, "Wrong size on Weapon_PlayDynamicMaterialEffect");
static_assert(offsetof(Weapon_PlayDynamicMaterialEffect, Data) == 0x000000, "Member 'Weapon_PlayDynamicMaterialEffect::Data' has a wrong offset!");
static_assert(offsetof(Weapon_PlayDynamicMaterialEffect, ReturnValue) == 0x000060, "Member 'Weapon_PlayDynamicMaterialEffect::ReturnValue' has a wrong offset!");

// Function GbxWeapon.Weapon.PlayEffects
// 0x0008 (0x0008 - 0x0000)
struct Weapon_PlayEffects final
{
public:
	EWeaponEffectType                             EffectType;                                        // 0x0000(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         UseModeIndex;                                      // 0x0001(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2[0x2];                                        // 0x0002(0x0002)(Fixing Size After Last Property [ Dumper-7 ])
	int32                                         EffectID;                                          // 0x0004(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(Weapon_PlayEffects) == 0x000004, "Wrong alignment on Weapon_PlayEffects");
static_assert(sizeof(Weapon_PlayEffects) == 0x000008, "Wrong size on Weapon_PlayEffects");
static_assert(offsetof(Weapon_PlayEffects, EffectType) == 0x000000, "Member 'Weapon_PlayEffects::EffectType' has a wrong offset!");
static_assert(offsetof(Weapon_PlayEffects, UseModeIndex) == 0x000001, "Member 'Weapon_PlayEffects::UseModeIndex' has a wrong offset!");
static_assert(offsetof(Weapon_PlayEffects, EffectID) == 0x000004, "Member 'Weapon_PlayEffects::EffectID' has a wrong offset!");

// Function GbxWeapon.Weapon.RegisterEffect
// 0x0060 (0x0060 - 0x0000)
struct Weapon_RegisterEffect final
{
public:
	struct FWeaponRegisterAttachmentEffectData    Data;                                              // 0x0000(0x0060)(ConstParm, Parm, OutParm, ReferenceParm, NoDestructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(Weapon_RegisterEffect) == 0x000008, "Wrong alignment on Weapon_RegisterEffect");
static_assert(sizeof(Weapon_RegisterEffect) == 0x000060, "Wrong size on Weapon_RegisterEffect");
static_assert(offsetof(Weapon_RegisterEffect, Data) == 0x000000, "Member 'Weapon_RegisterEffect::Data' has a wrong offset!");

// Function GbxWeapon.Weapon.RegisterMaterialEffect
// 0x00A8 (0x00A8 - 0x0000)
struct Weapon_RegisterMaterialEffect final
{
public:
	struct FWeaponRegisterMaterialEffectData      Data;                                              // 0x0000(0x00A8)(ConstParm, Parm, OutParm, ReferenceParm, NoDestructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(Weapon_RegisterMaterialEffect) == 0x000008, "Wrong alignment on Weapon_RegisterMaterialEffect");
static_assert(sizeof(Weapon_RegisterMaterialEffect) == 0x0000A8, "Wrong size on Weapon_RegisterMaterialEffect");
static_assert(offsetof(Weapon_RegisterMaterialEffect, Data) == 0x000000, "Member 'Weapon_RegisterMaterialEffect::Data' has a wrong offset!");

// Function GbxWeapon.Weapon.RegisterSimpleEffect
// 0x0018 (0x0018 - 0x0000)
struct Weapon_RegisterSimpleEffect final
{
public:
	EWeaponEffectType                             EffectType;                                        // 0x0000(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1[0x7];                                        // 0x0001(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	class UParticleSystem*                        Effect;                                            // 0x0008(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   EffectSocket;                                      // 0x0010(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(Weapon_RegisterSimpleEffect) == 0x000008, "Wrong alignment on Weapon_RegisterSimpleEffect");
static_assert(sizeof(Weapon_RegisterSimpleEffect) == 0x000018, "Wrong size on Weapon_RegisterSimpleEffect");
static_assert(offsetof(Weapon_RegisterSimpleEffect, EffectType) == 0x000000, "Member 'Weapon_RegisterSimpleEffect::EffectType' has a wrong offset!");
static_assert(offsetof(Weapon_RegisterSimpleEffect, Effect) == 0x000008, "Member 'Weapon_RegisterSimpleEffect::Effect' has a wrong offset!");
static_assert(offsetof(Weapon_RegisterSimpleEffect, EffectSocket) == 0x000010, "Member 'Weapon_RegisterSimpleEffect::EffectSocket' has a wrong offset!");

// Function GbxWeapon.Weapon.RegisterSkeletalControl
// 0x0010 (0x0010 - 0x0000)
struct Weapon_RegisterSkeletalControl final
{
public:
	struct FWeaponRegisterSkeletalControlData     Data;                                              // 0x0000(0x0010)(ConstParm, Parm, OutParm, ReferenceParm, NoDestructor, ContainsInstancedReference, NativeAccessSpecifierPublic)
};
static_assert(alignof(Weapon_RegisterSkeletalControl) == 0x000008, "Wrong alignment on Weapon_RegisterSkeletalControl");
static_assert(sizeof(Weapon_RegisterSkeletalControl) == 0x000010, "Wrong size on Weapon_RegisterSkeletalControl");
static_assert(offsetof(Weapon_RegisterSkeletalControl, Data) == 0x000000, "Member 'Weapon_RegisterSkeletalControl::Data' has a wrong offset!");

// Function GbxWeapon.Weapon.RegisterTrinketAttachment
// 0x0038 (0x0038 - 0x0000)
struct Weapon_RegisterTrinketAttachment final
{
public:
	struct FWeaponRegisterTrinketAttachmentData   Data;                                              // 0x0000(0x0038)(ConstParm, Parm, OutParm, ReferenceParm, NoDestructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(Weapon_RegisterTrinketAttachment) == 0x000008, "Wrong alignment on Weapon_RegisterTrinketAttachment");
static_assert(sizeof(Weapon_RegisterTrinketAttachment) == 0x000038, "Wrong size on Weapon_RegisterTrinketAttachment");
static_assert(offsetof(Weapon_RegisterTrinketAttachment, Data) == 0x000000, "Member 'Weapon_RegisterTrinketAttachment::Data' has a wrong offset!");

// Function GbxWeapon.Weapon.ServerInterruptReloadToUse
// 0x0004 (0x0004 - 0x0000)
struct Weapon_ServerInterruptReloadToUse final
{
public:
	int32                                         ClientLoadedAmmo;                                  // 0x0000(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(Weapon_ServerInterruptReloadToUse) == 0x000004, "Wrong alignment on Weapon_ServerInterruptReloadToUse");
static_assert(sizeof(Weapon_ServerInterruptReloadToUse) == 0x000004, "Wrong size on Weapon_ServerInterruptReloadToUse");
static_assert(offsetof(Weapon_ServerInterruptReloadToUse, ClientLoadedAmmo) == 0x000000, "Member 'Weapon_ServerInterruptReloadToUse::ClientLoadedAmmo' has a wrong offset!");

// Function GbxWeapon.Weapon.ServerLock
// 0x0004 (0x0004 - 0x0000)
struct Weapon_ServerLock final
{
public:
	float                                         Duration;                                          // 0x0000(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(Weapon_ServerLock) == 0x000004, "Wrong alignment on Weapon_ServerLock");
static_assert(sizeof(Weapon_ServerLock) == 0x000004, "Wrong size on Weapon_ServerLock");
static_assert(offsetof(Weapon_ServerLock, Duration) == 0x000000, "Member 'Weapon_ServerLock::Duration' has a wrong offset!");

// Function GbxWeapon.Weapon.ServerSetPatternSeed
// 0x0001 (0x0001 - 0x0000)
struct Weapon_ServerSetPatternSeed final
{
public:
	uint8                                         ClientPatternSeed;                                 // 0x0000(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(Weapon_ServerSetPatternSeed) == 0x000001, "Wrong alignment on Weapon_ServerSetPatternSeed");
static_assert(sizeof(Weapon_ServerSetPatternSeed) == 0x000001, "Wrong size on Weapon_ServerSetPatternSeed");
static_assert(offsetof(Weapon_ServerSetPatternSeed, ClientPatternSeed) == 0x000000, "Member 'Weapon_ServerSetPatternSeed::ClientPatternSeed' has a wrong offset!");

// Function GbxWeapon.Weapon.ServerSetZoomState
// 0x0008 (0x0008 - 0x0000)
struct Weapon_ServerSetZoomState final
{
public:
	uint8                                         UseModeIndex;                                      // 0x0000(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FWeaponZoomState                       NewState;                                          // 0x0001(0x0002)(ConstParm, Parm, ReferenceParm, NoDestructor, NativeAccessSpecifierPublic)
	uint8                                         Pad_3[0x1];                                        // 0x0003(0x0001)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         ZoomStartOffset;                                   // 0x0004(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(Weapon_ServerSetZoomState) == 0x000004, "Wrong alignment on Weapon_ServerSetZoomState");
static_assert(sizeof(Weapon_ServerSetZoomState) == 0x000008, "Wrong size on Weapon_ServerSetZoomState");
static_assert(offsetof(Weapon_ServerSetZoomState, UseModeIndex) == 0x000000, "Member 'Weapon_ServerSetZoomState::UseModeIndex' has a wrong offset!");
static_assert(offsetof(Weapon_ServerSetZoomState, NewState) == 0x000001, "Member 'Weapon_ServerSetZoomState::NewState' has a wrong offset!");
static_assert(offsetof(Weapon_ServerSetZoomState, ZoomStartOffset) == 0x000004, "Member 'Weapon_ServerSetZoomState::ZoomStartOffset' has a wrong offset!");

// Function GbxWeapon.Weapon.ServerStartReloading
// 0x0002 (0x0002 - 0x0000)
struct Weapon_ServerStartReloading final
{
public:
	uint8                                         UseModeIndex;                                      // 0x0000(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bAuto;                                             // 0x0001(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(Weapon_ServerStartReloading) == 0x000001, "Wrong alignment on Weapon_ServerStartReloading");
static_assert(sizeof(Weapon_ServerStartReloading) == 0x000002, "Wrong size on Weapon_ServerStartReloading");
static_assert(offsetof(Weapon_ServerStartReloading, UseModeIndex) == 0x000000, "Member 'Weapon_ServerStartReloading::UseModeIndex' has a wrong offset!");
static_assert(offsetof(Weapon_ServerStartReloading, bAuto) == 0x000001, "Member 'Weapon_ServerStartReloading::bAuto' has a wrong offset!");

// Function GbxWeapon.Weapon.ServerStartUsing
// 0x0002 (0x0002 - 0x0000)
struct Weapon_ServerStartUsing final
{
public:
	uint8                                         InputChannel;                                      // 0x0000(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         ClientPatternSeed;                                 // 0x0001(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(Weapon_ServerStartUsing) == 0x000001, "Wrong alignment on Weapon_ServerStartUsing");
static_assert(sizeof(Weapon_ServerStartUsing) == 0x000002, "Wrong size on Weapon_ServerStartUsing");
static_assert(offsetof(Weapon_ServerStartUsing, InputChannel) == 0x000000, "Member 'Weapon_ServerStartUsing::InputChannel' has a wrong offset!");
static_assert(offsetof(Weapon_ServerStartUsing, ClientPatternSeed) == 0x000001, "Member 'Weapon_ServerStartUsing::ClientPatternSeed' has a wrong offset!");

// Function GbxWeapon.Weapon.ServerStopModeSwitch
// 0x0002 (0x0002 - 0x0000)
struct Weapon_ServerStopModeSwitch final
{
public:
	uint8                                         InputChannel;                                      // 0x0000(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         ClientUseModeIndex;                                // 0x0001(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(Weapon_ServerStopModeSwitch) == 0x000001, "Wrong alignment on Weapon_ServerStopModeSwitch");
static_assert(sizeof(Weapon_ServerStopModeSwitch) == 0x000002, "Wrong size on Weapon_ServerStopModeSwitch");
static_assert(offsetof(Weapon_ServerStopModeSwitch, InputChannel) == 0x000000, "Member 'Weapon_ServerStopModeSwitch::InputChannel' has a wrong offset!");
static_assert(offsetof(Weapon_ServerStopModeSwitch, ClientUseModeIndex) == 0x000001, "Member 'Weapon_ServerStopModeSwitch::ClientUseModeIndex' has a wrong offset!");

// Function GbxWeapon.Weapon.ServerStopUsing
// 0x0002 (0x0002 - 0x0000)
struct Weapon_ServerStopUsing final
{
public:
	uint8                                         InputChannel;                                      // 0x0000(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bForced;                                           // 0x0001(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(Weapon_ServerStopUsing) == 0x000001, "Wrong alignment on Weapon_ServerStopUsing");
static_assert(sizeof(Weapon_ServerStopUsing) == 0x000002, "Wrong size on Weapon_ServerStopUsing");
static_assert(offsetof(Weapon_ServerStopUsing, InputChannel) == 0x000000, "Member 'Weapon_ServerStopUsing::InputChannel' has a wrong offset!");
static_assert(offsetof(Weapon_ServerStopUsing, bForced) == 0x000001, "Member 'Weapon_ServerStopUsing::bForced' has a wrong offset!");

// Function GbxWeapon.Weapon.ServerSwitchMode
// 0x0003 (0x0003 - 0x0000)
struct Weapon_ServerSwitchMode final
{
public:
	uint8                                         InputChannel;                                      // 0x0000(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         NextUseModeIndex;                                  // 0x0001(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bForced;                                           // 0x0002(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(Weapon_ServerSwitchMode) == 0x000001, "Wrong alignment on Weapon_ServerSwitchMode");
static_assert(sizeof(Weapon_ServerSwitchMode) == 0x000003, "Wrong size on Weapon_ServerSwitchMode");
static_assert(offsetof(Weapon_ServerSwitchMode, InputChannel) == 0x000000, "Member 'Weapon_ServerSwitchMode::InputChannel' has a wrong offset!");
static_assert(offsetof(Weapon_ServerSwitchMode, NextUseModeIndex) == 0x000001, "Member 'Weapon_ServerSwitchMode::NextUseModeIndex' has a wrong offset!");
static_assert(offsetof(Weapon_ServerSwitchMode, bForced) == 0x000002, "Member 'Weapon_ServerSwitchMode::bForced' has a wrong offset!");

// Function GbxWeapon.Weapon.SetBoneVisibility
// 0x0010 (0x0010 - 0x0000)
struct Weapon_SetBoneVisibility final
{
public:
	class FName                                   BoneName;                                          // 0x0000(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bVisible;                                          // 0x0008(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EWeaponAttachmentVisibilityType               AttachmentType;                                    // 0x0009(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_A[0x6];                                        // 0x000A(0x0006)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(Weapon_SetBoneVisibility) == 0x000004, "Wrong alignment on Weapon_SetBoneVisibility");
static_assert(sizeof(Weapon_SetBoneVisibility) == 0x000010, "Wrong size on Weapon_SetBoneVisibility");
static_assert(offsetof(Weapon_SetBoneVisibility, BoneName) == 0x000000, "Member 'Weapon_SetBoneVisibility::BoneName' has a wrong offset!");
static_assert(offsetof(Weapon_SetBoneVisibility, bVisible) == 0x000008, "Member 'Weapon_SetBoneVisibility::bVisible' has a wrong offset!");
static_assert(offsetof(Weapon_SetBoneVisibility, AttachmentType) == 0x000009, "Member 'Weapon_SetBoneVisibility::AttachmentType' has a wrong offset!");

// Function GbxWeapon.Weapon.SetEffectColorParameter
// 0x0028 (0x0028 - 0x0000)
struct Weapon_SetEffectColorParameter final
{
public:
	class FName                                   ParamName;                                         // 0x0000(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FLinearColor                           ParamValue;                                        // 0x0008(0x0010)(ConstParm, Parm, OutParm, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FWeaponEffectQueryData                 QueryData;                                         // 0x0018(0x0010)(ConstParm, Parm, OutParm, ReferenceParm, NoDestructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(Weapon_SetEffectColorParameter) == 0x000004, "Wrong alignment on Weapon_SetEffectColorParameter");
static_assert(sizeof(Weapon_SetEffectColorParameter) == 0x000028, "Wrong size on Weapon_SetEffectColorParameter");
static_assert(offsetof(Weapon_SetEffectColorParameter, ParamName) == 0x000000, "Member 'Weapon_SetEffectColorParameter::ParamName' has a wrong offset!");
static_assert(offsetof(Weapon_SetEffectColorParameter, ParamValue) == 0x000008, "Member 'Weapon_SetEffectColorParameter::ParamValue' has a wrong offset!");
static_assert(offsetof(Weapon_SetEffectColorParameter, QueryData) == 0x000018, "Member 'Weapon_SetEffectColorParameter::QueryData' has a wrong offset!");

// Function GbxWeapon.Weapon.SetEffectEmitterState
// 0x0020 (0x0020 - 0x0000)
struct Weapon_SetEffectEmitterState final
{
public:
	class FName                                   EmitterName;                                       // 0x0000(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bEnabled;                                          // 0x0008(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_9[0x3];                                        // 0x0009(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	struct FWeaponEffectQueryData                 QueryData;                                         // 0x000C(0x0010)(ConstParm, Parm, OutParm, ReferenceParm, NoDestructor, NativeAccessSpecifierPublic)
	uint8                                         Pad_1C[0x4];                                       // 0x001C(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(Weapon_SetEffectEmitterState) == 0x000004, "Wrong alignment on Weapon_SetEffectEmitterState");
static_assert(sizeof(Weapon_SetEffectEmitterState) == 0x000020, "Wrong size on Weapon_SetEffectEmitterState");
static_assert(offsetof(Weapon_SetEffectEmitterState, EmitterName) == 0x000000, "Member 'Weapon_SetEffectEmitterState::EmitterName' has a wrong offset!");
static_assert(offsetof(Weapon_SetEffectEmitterState, bEnabled) == 0x000008, "Member 'Weapon_SetEffectEmitterState::bEnabled' has a wrong offset!");
static_assert(offsetof(Weapon_SetEffectEmitterState, QueryData) == 0x00000C, "Member 'Weapon_SetEffectEmitterState::QueryData' has a wrong offset!");

// Function GbxWeapon.Weapon.SetEffectFloatParameter
// 0x0020 (0x0020 - 0x0000)
struct Weapon_SetEffectFloatParameter final
{
public:
	class FName                                   ParamName;                                         // 0x0000(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         ParamValue;                                        // 0x0008(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FWeaponEffectQueryData                 QueryData;                                         // 0x000C(0x0010)(ConstParm, Parm, OutParm, ReferenceParm, NoDestructor, NativeAccessSpecifierPublic)
	uint8                                         Pad_1C[0x4];                                       // 0x001C(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(Weapon_SetEffectFloatParameter) == 0x000004, "Wrong alignment on Weapon_SetEffectFloatParameter");
static_assert(sizeof(Weapon_SetEffectFloatParameter) == 0x000020, "Wrong size on Weapon_SetEffectFloatParameter");
static_assert(offsetof(Weapon_SetEffectFloatParameter, ParamName) == 0x000000, "Member 'Weapon_SetEffectFloatParameter::ParamName' has a wrong offset!");
static_assert(offsetof(Weapon_SetEffectFloatParameter, ParamValue) == 0x000008, "Member 'Weapon_SetEffectFloatParameter::ParamValue' has a wrong offset!");
static_assert(offsetof(Weapon_SetEffectFloatParameter, QueryData) == 0x00000C, "Member 'Weapon_SetEffectFloatParameter::QueryData' has a wrong offset!");

// Function GbxWeapon.Weapon.SetEffectMaterialParameter
// 0x0020 (0x0020 - 0x0000)
struct Weapon_SetEffectMaterialParameter final
{
public:
	class FName                                   ParamName;                                         // 0x0000(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UMaterialInterface*                     ParamValue;                                        // 0x0008(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FWeaponEffectQueryData                 QueryData;                                         // 0x0010(0x0010)(ConstParm, Parm, OutParm, ReferenceParm, NoDestructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(Weapon_SetEffectMaterialParameter) == 0x000008, "Wrong alignment on Weapon_SetEffectMaterialParameter");
static_assert(sizeof(Weapon_SetEffectMaterialParameter) == 0x000020, "Wrong size on Weapon_SetEffectMaterialParameter");
static_assert(offsetof(Weapon_SetEffectMaterialParameter, ParamName) == 0x000000, "Member 'Weapon_SetEffectMaterialParameter::ParamName' has a wrong offset!");
static_assert(offsetof(Weapon_SetEffectMaterialParameter, ParamValue) == 0x000008, "Member 'Weapon_SetEffectMaterialParameter::ParamValue' has a wrong offset!");
static_assert(offsetof(Weapon_SetEffectMaterialParameter, QueryData) == 0x000010, "Member 'Weapon_SetEffectMaterialParameter::QueryData' has a wrong offset!");

// Function GbxWeapon.Weapon.SetEffectVectorParameter
// 0x0028 (0x0028 - 0x0000)
struct Weapon_SetEffectVectorParameter final
{
public:
	class FName                                   ParamName;                                         // 0x0000(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                ParamValue;                                        // 0x0008(0x000C)(ConstParm, Parm, OutParm, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FWeaponEffectQueryData                 QueryData;                                         // 0x0014(0x0010)(ConstParm, Parm, OutParm, ReferenceParm, NoDestructor, NativeAccessSpecifierPublic)
	uint8                                         Pad_24[0x4];                                       // 0x0024(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(Weapon_SetEffectVectorParameter) == 0x000004, "Wrong alignment on Weapon_SetEffectVectorParameter");
static_assert(sizeof(Weapon_SetEffectVectorParameter) == 0x000028, "Wrong size on Weapon_SetEffectVectorParameter");
static_assert(offsetof(Weapon_SetEffectVectorParameter, ParamName) == 0x000000, "Member 'Weapon_SetEffectVectorParameter::ParamName' has a wrong offset!");
static_assert(offsetof(Weapon_SetEffectVectorParameter, ParamValue) == 0x000008, "Member 'Weapon_SetEffectVectorParameter::ParamValue' has a wrong offset!");
static_assert(offsetof(Weapon_SetEffectVectorParameter, QueryData) == 0x000014, "Member 'Weapon_SetEffectVectorParameter::QueryData' has a wrong offset!");

// Function GbxWeapon.Weapon.SetMaterialScalarParameterValue
// 0x0010 (0x0010 - 0x0000)
struct Weapon_SetMaterialScalarParameterValue final
{
public:
	class FName                                   ParamName;                                         // 0x0000(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         ParamValue;                                        // 0x0008(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_C[0x4];                                        // 0x000C(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(Weapon_SetMaterialScalarParameterValue) == 0x000004, "Wrong alignment on Weapon_SetMaterialScalarParameterValue");
static_assert(sizeof(Weapon_SetMaterialScalarParameterValue) == 0x000010, "Wrong size on Weapon_SetMaterialScalarParameterValue");
static_assert(offsetof(Weapon_SetMaterialScalarParameterValue, ParamName) == 0x000000, "Member 'Weapon_SetMaterialScalarParameterValue::ParamName' has a wrong offset!");
static_assert(offsetof(Weapon_SetMaterialScalarParameterValue, ParamValue) == 0x000008, "Member 'Weapon_SetMaterialScalarParameterValue::ParamValue' has a wrong offset!");

// Function GbxWeapon.Weapon.SetMaterialVectorParameterValue
// 0x0018 (0x0018 - 0x0000)
struct Weapon_SetMaterialVectorParameterValue final
{
public:
	class FName                                   ParamName;                                         // 0x0000(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FLinearColor                           ParamValue;                                        // 0x0008(0x0010)(Parm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(Weapon_SetMaterialVectorParameterValue) == 0x000004, "Wrong alignment on Weapon_SetMaterialVectorParameterValue");
static_assert(sizeof(Weapon_SetMaterialVectorParameterValue) == 0x000018, "Wrong size on Weapon_SetMaterialVectorParameterValue");
static_assert(offsetof(Weapon_SetMaterialVectorParameterValue, ParamName) == 0x000000, "Member 'Weapon_SetMaterialVectorParameterValue::ParamName' has a wrong offset!");
static_assert(offsetof(Weapon_SetMaterialVectorParameterValue, ParamValue) == 0x000008, "Member 'Weapon_SetMaterialVectorParameterValue::ParamValue' has a wrong offset!");

// Function GbxWeapon.Weapon.SetPreUseState
// 0x0002 (0x0002 - 0x0000)
struct Weapon_SetPreUseState final
{
public:
	uint8                                         UseModeIndex;                                      // 0x0000(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bEnabled;                                          // 0x0001(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(Weapon_SetPreUseState) == 0x000001, "Wrong alignment on Weapon_SetPreUseState");
static_assert(sizeof(Weapon_SetPreUseState) == 0x000002, "Wrong size on Weapon_SetPreUseState");
static_assert(offsetof(Weapon_SetPreUseState, UseModeIndex) == 0x000000, "Member 'Weapon_SetPreUseState::UseModeIndex' has a wrong offset!");
static_assert(offsetof(Weapon_SetPreUseState, bEnabled) == 0x000001, "Member 'Weapon_SetPreUseState::bEnabled' has a wrong offset!");

// Function GbxWeapon.Weapon.SetTargetLocked
// 0x0001 (0x0001 - 0x0000)
struct Weapon_SetTargetLocked final
{
public:
	bool                                          bIsLocked;                                         // 0x0000(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(Weapon_SetTargetLocked) == 0x000001, "Wrong alignment on Weapon_SetTargetLocked");
static_assert(sizeof(Weapon_SetTargetLocked) == 0x000001, "Wrong size on Weapon_SetTargetLocked");
static_assert(offsetof(Weapon_SetTargetLocked, bIsLocked) == 0x000000, "Member 'Weapon_SetTargetLocked::bIsLocked' has a wrong offset!");

// Function GbxWeapon.Weapon.StartReloading
// 0x0001 (0x0001 - 0x0000)
struct Weapon_StartReloading final
{
public:
	bool                                          bAuto;                                             // 0x0000(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(Weapon_StartReloading) == 0x000001, "Wrong alignment on Weapon_StartReloading");
static_assert(sizeof(Weapon_StartReloading) == 0x000001, "Wrong size on Weapon_StartReloading");
static_assert(offsetof(Weapon_StartReloading, bAuto) == 0x000000, "Member 'Weapon_StartReloading::bAuto' has a wrong offset!");

// Function GbxWeapon.Weapon.StartUsing
// 0x0001 (0x0001 - 0x0000)
struct Weapon_StartUsing final
{
public:
	uint8                                         InputChannel;                                      // 0x0000(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(Weapon_StartUsing) == 0x000001, "Wrong alignment on Weapon_StartUsing");
static_assert(sizeof(Weapon_StartUsing) == 0x000001, "Wrong size on Weapon_StartUsing");
static_assert(offsetof(Weapon_StartUsing, InputChannel) == 0x000000, "Member 'Weapon_StartUsing::InputChannel' has a wrong offset!");

// Function GbxWeapon.Weapon.StopAnimation
// 0x0010 (0x0010 - 0x0000)
struct Weapon_StopAnimation final
{
public:
	class UAnimMontage*                           Anim;                                              // 0x0000(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bFirstPerson;                                      // 0x0008(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_9[0x7];                                        // 0x0009(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(Weapon_StopAnimation) == 0x000008, "Wrong alignment on Weapon_StopAnimation");
static_assert(sizeof(Weapon_StopAnimation) == 0x000010, "Wrong size on Weapon_StopAnimation");
static_assert(offsetof(Weapon_StopAnimation, Anim) == 0x000000, "Member 'Weapon_StopAnimation::Anim' has a wrong offset!");
static_assert(offsetof(Weapon_StopAnimation, bFirstPerson) == 0x000008, "Member 'Weapon_StopAnimation::bFirstPerson' has a wrong offset!");

// Function GbxWeapon.Weapon.StopDynamicMaterialEffect
// 0x0004 (0x0004 - 0x0000)
struct Weapon_StopDynamicMaterialEffect final
{
public:
	int32                                         EffectID;                                          // 0x0000(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(Weapon_StopDynamicMaterialEffect) == 0x000004, "Wrong alignment on Weapon_StopDynamicMaterialEffect");
static_assert(sizeof(Weapon_StopDynamicMaterialEffect) == 0x000004, "Wrong size on Weapon_StopDynamicMaterialEffect");
static_assert(offsetof(Weapon_StopDynamicMaterialEffect, EffectID) == 0x000000, "Member 'Weapon_StopDynamicMaterialEffect::EffectID' has a wrong offset!");

// Function GbxWeapon.Weapon.StopEffects
// 0x0002 (0x0002 - 0x0000)
struct Weapon_StopEffects final
{
public:
	EWeaponEffectType                             EffectType;                                        // 0x0000(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         UseModeIndex;                                      // 0x0001(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(Weapon_StopEffects) == 0x000001, "Wrong alignment on Weapon_StopEffects");
static_assert(sizeof(Weapon_StopEffects) == 0x000002, "Wrong size on Weapon_StopEffects");
static_assert(offsetof(Weapon_StopEffects, EffectType) == 0x000000, "Member 'Weapon_StopEffects::EffectType' has a wrong offset!");
static_assert(offsetof(Weapon_StopEffects, UseModeIndex) == 0x000001, "Member 'Weapon_StopEffects::UseModeIndex' has a wrong offset!");

// Function GbxWeapon.Weapon.StopUsing
// 0x0002 (0x0002 - 0x0000)
struct Weapon_StopUsing final
{
public:
	uint8                                         InputChannel;                                      // 0x0000(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bForced;                                           // 0x0001(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(Weapon_StopUsing) == 0x000001, "Wrong alignment on Weapon_StopUsing");
static_assert(sizeof(Weapon_StopUsing) == 0x000002, "Wrong size on Weapon_StopUsing");
static_assert(offsetof(Weapon_StopUsing, InputChannel) == 0x000000, "Member 'Weapon_StopUsing::InputChannel' has a wrong offset!");
static_assert(offsetof(Weapon_StopUsing, bForced) == 0x000001, "Member 'Weapon_StopUsing::bForced' has a wrong offset!");

// Function GbxWeapon.Weapon.StopWeaponAction
// 0x0001 (0x0001 - 0x0000)
struct Weapon_StopWeaponAction final
{
public:
	EWeaponActionType                             WeaponAction;                                      // 0x0000(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(Weapon_StopWeaponAction) == 0x000001, "Wrong alignment on Weapon_StopWeaponAction");
static_assert(sizeof(Weapon_StopWeaponAction) == 0x000001, "Wrong size on Weapon_StopWeaponAction");
static_assert(offsetof(Weapon_StopWeaponAction, WeaponAction) == 0x000000, "Member 'Weapon_StopWeaponAction::WeaponAction' has a wrong offset!");

// Function GbxWeapon.Weapon.StopZooming
// 0x0002 (0x0002 - 0x0000)
struct Weapon_StopZooming final
{
public:
	bool                                          bSkipTransitions;                                  // 0x0000(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bClearInput;                                       // 0x0001(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(Weapon_StopZooming) == 0x000001, "Wrong alignment on Weapon_StopZooming");
static_assert(sizeof(Weapon_StopZooming) == 0x000002, "Wrong size on Weapon_StopZooming");
static_assert(offsetof(Weapon_StopZooming, bSkipTransitions) == 0x000000, "Member 'Weapon_StopZooming::bSkipTransitions' has a wrong offset!");
static_assert(offsetof(Weapon_StopZooming, bClearInput) == 0x000001, "Member 'Weapon_StopZooming::bClearInput' has a wrong offset!");

// Function GbxWeapon.Weapon.SwitchMode
// 0x0003 (0x0003 - 0x0000)
struct Weapon_SwitchMode final
{
public:
	uint8                                         InputChannel;                                      // 0x0000(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         NextUseModeIndex;                                  // 0x0001(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bForced;                                           // 0x0002(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(Weapon_SwitchMode) == 0x000001, "Wrong alignment on Weapon_SwitchMode");
static_assert(sizeof(Weapon_SwitchMode) == 0x000003, "Wrong size on Weapon_SwitchMode");
static_assert(offsetof(Weapon_SwitchMode, InputChannel) == 0x000000, "Member 'Weapon_SwitchMode::InputChannel' has a wrong offset!");
static_assert(offsetof(Weapon_SwitchMode, NextUseModeIndex) == 0x000001, "Member 'Weapon_SwitchMode::NextUseModeIndex' has a wrong offset!");
static_assert(offsetof(Weapon_SwitchMode, bForced) == 0x000002, "Member 'Weapon_SwitchMode::bForced' has a wrong offset!");

// Function GbxWeapon.Weapon.ToggleMode
// 0x0001 (0x0001 - 0x0000)
struct Weapon_ToggleMode final
{
public:
	uint8                                         InputChannel;                                      // 0x0000(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(Weapon_ToggleMode) == 0x000001, "Wrong alignment on Weapon_ToggleMode");
static_assert(sizeof(Weapon_ToggleMode) == 0x000001, "Wrong size on Weapon_ToggleMode");
static_assert(offsetof(Weapon_ToggleMode, InputChannel) == 0x000000, "Member 'Weapon_ToggleMode::InputChannel' has a wrong offset!");

// Function GbxWeapon.Weapon.Unlock
// 0x0001 (0x0001 - 0x0000)
struct Weapon_Unlock final
{
public:
	bool                                          bReplicate;                                        // 0x0000(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(Weapon_Unlock) == 0x000001, "Wrong alignment on Weapon_Unlock");
static_assert(sizeof(Weapon_Unlock) == 0x000001, "Wrong size on Weapon_Unlock");
static_assert(offsetof(Weapon_Unlock, bReplicate) == 0x000000, "Member 'Weapon_Unlock::bReplicate' has a wrong offset!");

// Function GbxWeapon.Weapon.GetAimAssistParameters
// 0x0008 (0x0008 - 0x0000)
struct Weapon_GetAimAssistParameters final
{
public:
	class UAimAssistParameters*                   ReturnValue;                                       // 0x0000(0x0008)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(Weapon_GetAimAssistParameters) == 0x000008, "Wrong alignment on Weapon_GetAimAssistParameters");
static_assert(sizeof(Weapon_GetAimAssistParameters) == 0x000008, "Wrong size on Weapon_GetAimAssistParameters");
static_assert(offsetof(Weapon_GetAimAssistParameters, ReturnValue) == 0x000000, "Member 'Weapon_GetAimAssistParameters::ReturnValue' has a wrong offset!");

// Function GbxWeapon.Weapon.GetAssociatedUseModeComponentByClass
// 0x0018 (0x0018 - 0x0000)
struct Weapon_GetAssociatedUseModeComponentByClass final
{
public:
	TSubclassOf<class UActorComponent>            ComponentClass;                                    // 0x0000(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UActorComponent*                        ReferenceComponent;                                // 0x0008(0x0008)(Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UActorComponent*                        ReturnValue;                                       // 0x0010(0x0008)(ExportObject, Parm, OutParm, ZeroConstructor, ReturnParm, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(Weapon_GetAssociatedUseModeComponentByClass) == 0x000008, "Wrong alignment on Weapon_GetAssociatedUseModeComponentByClass");
static_assert(sizeof(Weapon_GetAssociatedUseModeComponentByClass) == 0x000018, "Wrong size on Weapon_GetAssociatedUseModeComponentByClass");
static_assert(offsetof(Weapon_GetAssociatedUseModeComponentByClass, ComponentClass) == 0x000000, "Member 'Weapon_GetAssociatedUseModeComponentByClass::ComponentClass' has a wrong offset!");
static_assert(offsetof(Weapon_GetAssociatedUseModeComponentByClass, ReferenceComponent) == 0x000008, "Member 'Weapon_GetAssociatedUseModeComponentByClass::ReferenceComponent' has a wrong offset!");
static_assert(offsetof(Weapon_GetAssociatedUseModeComponentByClass, ReturnValue) == 0x000010, "Member 'Weapon_GetAssociatedUseModeComponentByClass::ReturnValue' has a wrong offset!");

// Function GbxWeapon.Weapon.GetAttachmentMesh
// 0x0010 (0x0010 - 0x0000)
struct Weapon_GetAttachmentMesh final
{
public:
	bool                                          bFirstPerson;                                      // 0x0000(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         SlotIndex;                                         // 0x0001(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2[0x6];                                        // 0x0002(0x0006)(Fixing Size After Last Property [ Dumper-7 ])
	class UMeshComponent*                         ReturnValue;                                       // 0x0008(0x0008)(ExportObject, Parm, OutParm, ZeroConstructor, ReturnParm, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(Weapon_GetAttachmentMesh) == 0x000008, "Wrong alignment on Weapon_GetAttachmentMesh");
static_assert(sizeof(Weapon_GetAttachmentMesh) == 0x000010, "Wrong size on Weapon_GetAttachmentMesh");
static_assert(offsetof(Weapon_GetAttachmentMesh, bFirstPerson) == 0x000000, "Member 'Weapon_GetAttachmentMesh::bFirstPerson' has a wrong offset!");
static_assert(offsetof(Weapon_GetAttachmentMesh, SlotIndex) == 0x000001, "Member 'Weapon_GetAttachmentMesh::SlotIndex' has a wrong offset!");
static_assert(offsetof(Weapon_GetAttachmentMesh, ReturnValue) == 0x000008, "Member 'Weapon_GetAttachmentMesh::ReturnValue' has a wrong offset!");

// Function GbxWeapon.Weapon.GetCurrentReloadPartType
// 0x0001 (0x0001 - 0x0000)
struct Weapon_GetCurrentReloadPartType final
{
public:
	uint8                                         ReturnValue;                                       // 0x0000(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(Weapon_GetCurrentReloadPartType) == 0x000001, "Wrong alignment on Weapon_GetCurrentReloadPartType");
static_assert(sizeof(Weapon_GetCurrentReloadPartType) == 0x000001, "Wrong size on Weapon_GetCurrentReloadPartType");
static_assert(offsetof(Weapon_GetCurrentReloadPartType, ReturnValue) == 0x000000, "Member 'Weapon_GetCurrentReloadPartType::ReturnValue' has a wrong offset!");

// Function GbxWeapon.Weapon.GetLastInputChannel
// 0x0001 (0x0001 - 0x0000)
struct Weapon_GetLastInputChannel final
{
public:
	uint8                                         ReturnValue;                                       // 0x0000(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(Weapon_GetLastInputChannel) == 0x000001, "Wrong alignment on Weapon_GetLastInputChannel");
static_assert(sizeof(Weapon_GetLastInputChannel) == 0x000001, "Wrong size on Weapon_GetLastInputChannel");
static_assert(offsetof(Weapon_GetLastInputChannel, ReturnValue) == 0x000000, "Member 'Weapon_GetLastInputChannel::ReturnValue' has a wrong offset!");

// Function GbxWeapon.Weapon.GetMaxZoomFOVScale
// 0x0004 (0x0004 - 0x0000)
struct Weapon_GetMaxZoomFOVScale final
{
public:
	float                                         ReturnValue;                                       // 0x0000(0x0004)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(Weapon_GetMaxZoomFOVScale) == 0x000004, "Wrong alignment on Weapon_GetMaxZoomFOVScale");
static_assert(sizeof(Weapon_GetMaxZoomFOVScale) == 0x000004, "Wrong size on Weapon_GetMaxZoomFOVScale");
static_assert(offsetof(Weapon_GetMaxZoomFOVScale, ReturnValue) == 0x000000, "Member 'Weapon_GetMaxZoomFOVScale::ReturnValue' has a wrong offset!");

// Function GbxWeapon.Weapon.GetMuteADSAlpha
// 0x0004 (0x0004 - 0x0000)
struct Weapon_GetMuteADSAlpha final
{
public:
	float                                         ReturnValue;                                       // 0x0000(0x0004)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(Weapon_GetMuteADSAlpha) == 0x000004, "Wrong alignment on Weapon_GetMuteADSAlpha");
static_assert(sizeof(Weapon_GetMuteADSAlpha) == 0x000004, "Wrong size on Weapon_GetMuteADSAlpha");
static_assert(offsetof(Weapon_GetMuteADSAlpha, ReturnValue) == 0x000000, "Member 'Weapon_GetMuteADSAlpha::ReturnValue' has a wrong offset!");

// Function GbxWeapon.Weapon.GetUseModeComponentByClass
// 0x0018 (0x0018 - 0x0000)
struct Weapon_GetUseModeComponentByClass final
{
public:
	TSubclassOf<class UActorComponent>            ComponentClass;                                    // 0x0000(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         UseModeIndex;                                      // 0x0008(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_9[0x7];                                        // 0x0009(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	class UActorComponent*                        ReturnValue;                                       // 0x0010(0x0008)(ExportObject, Parm, OutParm, ZeroConstructor, ReturnParm, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(Weapon_GetUseModeComponentByClass) == 0x000008, "Wrong alignment on Weapon_GetUseModeComponentByClass");
static_assert(sizeof(Weapon_GetUseModeComponentByClass) == 0x000018, "Wrong size on Weapon_GetUseModeComponentByClass");
static_assert(offsetof(Weapon_GetUseModeComponentByClass, ComponentClass) == 0x000000, "Member 'Weapon_GetUseModeComponentByClass::ComponentClass' has a wrong offset!");
static_assert(offsetof(Weapon_GetUseModeComponentByClass, UseModeIndex) == 0x000008, "Member 'Weapon_GetUseModeComponentByClass::UseModeIndex' has a wrong offset!");
static_assert(offsetof(Weapon_GetUseModeComponentByClass, ReturnValue) == 0x000010, "Member 'Weapon_GetUseModeComponentByClass::ReturnValue' has a wrong offset!");

// Function GbxWeapon.Weapon.GetZoomDuration
// 0x0004 (0x0004 - 0x0000)
struct Weapon_GetZoomDuration final
{
public:
	float                                         ReturnValue;                                       // 0x0000(0x0004)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(Weapon_GetZoomDuration) == 0x000004, "Wrong alignment on Weapon_GetZoomDuration");
static_assert(sizeof(Weapon_GetZoomDuration) == 0x000004, "Wrong size on Weapon_GetZoomDuration");
static_assert(offsetof(Weapon_GetZoomDuration, ReturnValue) == 0x000000, "Member 'Weapon_GetZoomDuration::ReturnValue' has a wrong offset!");

// Function GbxWeapon.Weapon.GetZoomEffect
// 0x0004 (0x0004 - 0x0000)
struct Weapon_GetZoomEffect final
{
public:
	float                                         ReturnValue;                                       // 0x0000(0x0004)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(Weapon_GetZoomEffect) == 0x000004, "Wrong alignment on Weapon_GetZoomEffect");
static_assert(sizeof(Weapon_GetZoomEffect) == 0x000004, "Wrong size on Weapon_GetZoomEffect");
static_assert(offsetof(Weapon_GetZoomEffect, ReturnValue) == 0x000000, "Member 'Weapon_GetZoomEffect::ReturnValue' has a wrong offset!");

// Function GbxWeapon.Weapon.GetZoomFOVScale
// 0x0004 (0x0004 - 0x0000)
struct Weapon_GetZoomFOVScale final
{
public:
	float                                         ReturnValue;                                       // 0x0000(0x0004)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(Weapon_GetZoomFOVScale) == 0x000004, "Wrong alignment on Weapon_GetZoomFOVScale");
static_assert(sizeof(Weapon_GetZoomFOVScale) == 0x000004, "Wrong size on Weapon_GetZoomFOVScale");
static_assert(offsetof(Weapon_GetZoomFOVScale, ReturnValue) == 0x000000, "Member 'Weapon_GetZoomFOVScale::ReturnValue' has a wrong offset!");

// Function GbxWeapon.Weapon.IsActive
// 0x0001 (0x0001 - 0x0000)
struct Weapon_IsActive final
{
public:
	bool                                          ReturnValue;                                       // 0x0000(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(Weapon_IsActive) == 0x000001, "Wrong alignment on Weapon_IsActive");
static_assert(sizeof(Weapon_IsActive) == 0x000001, "Wrong size on Weapon_IsActive");
static_assert(offsetof(Weapon_IsActive, ReturnValue) == 0x000000, "Member 'Weapon_IsActive::ReturnValue' has a wrong offset!");

// Function GbxWeapon.Weapon.IsAuthorityEquipping
// 0x0001 (0x0001 - 0x0000)
struct Weapon_IsAuthorityEquipping final
{
public:
	bool                                          ReturnValue;                                       // 0x0000(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(Weapon_IsAuthorityEquipping) == 0x000001, "Wrong alignment on Weapon_IsAuthorityEquipping");
static_assert(sizeof(Weapon_IsAuthorityEquipping) == 0x000001, "Wrong size on Weapon_IsAuthorityEquipping");
static_assert(offsetof(Weapon_IsAuthorityEquipping, ReturnValue) == 0x000000, "Member 'Weapon_IsAuthorityEquipping::ReturnValue' has a wrong offset!");

// Function GbxWeapon.Weapon.IsAuthorityPuttingDown
// 0x0001 (0x0001 - 0x0000)
struct Weapon_IsAuthorityPuttingDown final
{
public:
	bool                                          ReturnValue;                                       // 0x0000(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(Weapon_IsAuthorityPuttingDown) == 0x000001, "Wrong alignment on Weapon_IsAuthorityPuttingDown");
static_assert(sizeof(Weapon_IsAuthorityPuttingDown) == 0x000001, "Wrong size on Weapon_IsAuthorityPuttingDown");
static_assert(offsetof(Weapon_IsAuthorityPuttingDown, ReturnValue) == 0x000000, "Member 'Weapon_IsAuthorityPuttingDown::ReturnValue' has a wrong offset!");

// Function GbxWeapon.Weapon.IsAuthorityReloading
// 0x0001 (0x0001 - 0x0000)
struct Weapon_IsAuthorityReloading final
{
public:
	bool                                          ReturnValue;                                       // 0x0000(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(Weapon_IsAuthorityReloading) == 0x000001, "Wrong alignment on Weapon_IsAuthorityReloading");
static_assert(sizeof(Weapon_IsAuthorityReloading) == 0x000001, "Wrong size on Weapon_IsAuthorityReloading");
static_assert(offsetof(Weapon_IsAuthorityReloading, ReturnValue) == 0x000000, "Member 'Weapon_IsAuthorityReloading::ReturnValue' has a wrong offset!");

// Function GbxWeapon.Weapon.IsAuthoritySwitchingModes
// 0x0001 (0x0001 - 0x0000)
struct Weapon_IsAuthoritySwitchingModes final
{
public:
	bool                                          ReturnValue;                                       // 0x0000(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(Weapon_IsAuthoritySwitchingModes) == 0x000001, "Wrong alignment on Weapon_IsAuthoritySwitchingModes");
static_assert(sizeof(Weapon_IsAuthoritySwitchingModes) == 0x000001, "Wrong size on Weapon_IsAuthoritySwitchingModes");
static_assert(offsetof(Weapon_IsAuthoritySwitchingModes, ReturnValue) == 0x000000, "Member 'Weapon_IsAuthoritySwitchingModes::ReturnValue' has a wrong offset!");

// Function GbxWeapon.Weapon.IsAuthorityUsing
// 0x0001 (0x0001 - 0x0000)
struct Weapon_IsAuthorityUsing final
{
public:
	bool                                          ReturnValue;                                       // 0x0000(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(Weapon_IsAuthorityUsing) == 0x000001, "Wrong alignment on Weapon_IsAuthorityUsing");
static_assert(sizeof(Weapon_IsAuthorityUsing) == 0x000001, "Wrong size on Weapon_IsAuthorityUsing");
static_assert(offsetof(Weapon_IsAuthorityUsing, ReturnValue) == 0x000000, "Member 'Weapon_IsAuthorityUsing::ReturnValue' has a wrong offset!");

// Function GbxWeapon.Weapon.IsEquipping
// 0x0001 (0x0001 - 0x0000)
struct Weapon_IsEquipping final
{
public:
	bool                                          ReturnValue;                                       // 0x0000(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(Weapon_IsEquipping) == 0x000001, "Wrong alignment on Weapon_IsEquipping");
static_assert(sizeof(Weapon_IsEquipping) == 0x000001, "Wrong size on Weapon_IsEquipping");
static_assert(offsetof(Weapon_IsEquipping, ReturnValue) == 0x000000, "Member 'Weapon_IsEquipping::ReturnValue' has a wrong offset!");

// Function GbxWeapon.Weapon.IsInactive
// 0x0001 (0x0001 - 0x0000)
struct Weapon_IsInactive final
{
public:
	bool                                          ReturnValue;                                       // 0x0000(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(Weapon_IsInactive) == 0x000001, "Wrong alignment on Weapon_IsInactive");
static_assert(sizeof(Weapon_IsInactive) == 0x000001, "Wrong size on Weapon_IsInactive");
static_assert(offsetof(Weapon_IsInactive, ReturnValue) == 0x000000, "Member 'Weapon_IsInactive::ReturnValue' has a wrong offset!");

// Function GbxWeapon.Weapon.IsLocalAuthority
// 0x0001 (0x0001 - 0x0000)
struct Weapon_IsLocalAuthority final
{
public:
	bool                                          ReturnValue;                                       // 0x0000(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(Weapon_IsLocalAuthority) == 0x000001, "Wrong alignment on Weapon_IsLocalAuthority");
static_assert(sizeof(Weapon_IsLocalAuthority) == 0x000001, "Wrong size on Weapon_IsLocalAuthority");
static_assert(offsetof(Weapon_IsLocalAuthority, ReturnValue) == 0x000000, "Member 'Weapon_IsLocalAuthority::ReturnValue' has a wrong offset!");

// Function GbxWeapon.Weapon.IsLocked
// 0x0001 (0x0001 - 0x0000)
struct Weapon_IsLocked final
{
public:
	bool                                          ReturnValue;                                       // 0x0000(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(Weapon_IsLocked) == 0x000001, "Wrong alignment on Weapon_IsLocked");
static_assert(sizeof(Weapon_IsLocked) == 0x000001, "Wrong size on Weapon_IsLocked");
static_assert(offsetof(Weapon_IsLocked, ReturnValue) == 0x000000, "Member 'Weapon_IsLocked::ReturnValue' has a wrong offset!");

// Function GbxWeapon.Weapon.IsPendingUse
// 0x0002 (0x0002 - 0x0000)
struct Weapon_IsPendingUse final
{
public:
	uint8                                         InputChannel;                                      // 0x0000(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          ReturnValue;                                       // 0x0001(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(Weapon_IsPendingUse) == 0x000001, "Wrong alignment on Weapon_IsPendingUse");
static_assert(sizeof(Weapon_IsPendingUse) == 0x000002, "Wrong size on Weapon_IsPendingUse");
static_assert(offsetof(Weapon_IsPendingUse, InputChannel) == 0x000000, "Member 'Weapon_IsPendingUse::InputChannel' has a wrong offset!");
static_assert(offsetof(Weapon_IsPendingUse, ReturnValue) == 0x000001, "Member 'Weapon_IsPendingUse::ReturnValue' has a wrong offset!");

// Function GbxWeapon.Weapon.IsPuttingDown
// 0x0001 (0x0001 - 0x0000)
struct Weapon_IsPuttingDown final
{
public:
	bool                                          ReturnValue;                                       // 0x0000(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(Weapon_IsPuttingDown) == 0x000001, "Wrong alignment on Weapon_IsPuttingDown");
static_assert(sizeof(Weapon_IsPuttingDown) == 0x000001, "Wrong size on Weapon_IsPuttingDown");
static_assert(offsetof(Weapon_IsPuttingDown, ReturnValue) == 0x000000, "Member 'Weapon_IsPuttingDown::ReturnValue' has a wrong offset!");

// Function GbxWeapon.Weapon.IsReloading
// 0x0001 (0x0001 - 0x0000)
struct Weapon_IsReloading final
{
public:
	bool                                          ReturnValue;                                       // 0x0000(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(Weapon_IsReloading) == 0x000001, "Wrong alignment on Weapon_IsReloading");
static_assert(sizeof(Weapon_IsReloading) == 0x000001, "Wrong size on Weapon_IsReloading");
static_assert(offsetof(Weapon_IsReloading, ReturnValue) == 0x000000, "Member 'Weapon_IsReloading::ReturnValue' has a wrong offset!");

// Function GbxWeapon.Weapon.IsSwitchingModes
// 0x0001 (0x0001 - 0x0000)
struct Weapon_IsSwitchingModes final
{
public:
	bool                                          ReturnValue;                                       // 0x0000(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(Weapon_IsSwitchingModes) == 0x000001, "Wrong alignment on Weapon_IsSwitchingModes");
static_assert(sizeof(Weapon_IsSwitchingModes) == 0x000001, "Wrong size on Weapon_IsSwitchingModes");
static_assert(offsetof(Weapon_IsSwitchingModes, ReturnValue) == 0x000000, "Member 'Weapon_IsSwitchingModes::ReturnValue' has a wrong offset!");

// Function GbxWeapon.Weapon.IsTargetLocked
// 0x0001 (0x0001 - 0x0000)
struct Weapon_IsTargetLocked final
{
public:
	bool                                          ReturnValue;                                       // 0x0000(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(Weapon_IsTargetLocked) == 0x000001, "Wrong alignment on Weapon_IsTargetLocked");
static_assert(sizeof(Weapon_IsTargetLocked) == 0x000001, "Wrong size on Weapon_IsTargetLocked");
static_assert(offsetof(Weapon_IsTargetLocked, ReturnValue) == 0x000000, "Member 'Weapon_IsTargetLocked::ReturnValue' has a wrong offset!");

// Function GbxWeapon.Weapon.IsUsing
// 0x0001 (0x0001 - 0x0000)
struct Weapon_IsUsing final
{
public:
	bool                                          ReturnValue;                                       // 0x0000(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(Weapon_IsUsing) == 0x000001, "Wrong alignment on Weapon_IsUsing");
static_assert(sizeof(Weapon_IsUsing) == 0x000001, "Wrong size on Weapon_IsUsing");
static_assert(offsetof(Weapon_IsUsing, ReturnValue) == 0x000000, "Member 'Weapon_IsUsing::ReturnValue' has a wrong offset!");

// Function GbxWeapon.Weapon.IsZoomed
// 0x0001 (0x0001 - 0x0000)
struct Weapon_IsZoomed final
{
public:
	bool                                          ReturnValue;                                       // 0x0000(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(Weapon_IsZoomed) == 0x000001, "Wrong alignment on Weapon_IsZoomed");
static_assert(sizeof(Weapon_IsZoomed) == 0x000001, "Wrong size on Weapon_IsZoomed");
static_assert(offsetof(Weapon_IsZoomed, ReturnValue) == 0x000000, "Member 'Weapon_IsZoomed::ReturnValue' has a wrong offset!");

// Function GbxWeapon.Weapon.IsZoomedIn
// 0x0002 (0x0002 - 0x0000)
struct Weapon_IsZoomedIn final
{
public:
	bool                                          bIncludeTransitions;                               // 0x0000(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          ReturnValue;                                       // 0x0001(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(Weapon_IsZoomedIn) == 0x000001, "Wrong alignment on Weapon_IsZoomedIn");
static_assert(sizeof(Weapon_IsZoomedIn) == 0x000002, "Wrong size on Weapon_IsZoomedIn");
static_assert(offsetof(Weapon_IsZoomedIn, bIncludeTransitions) == 0x000000, "Member 'Weapon_IsZoomedIn::bIncludeTransitions' has a wrong offset!");
static_assert(offsetof(Weapon_IsZoomedIn, ReturnValue) == 0x000001, "Member 'Weapon_IsZoomedIn::ReturnValue' has a wrong offset!");

// Function GbxWeapon.WeaponUseComponent.OnPreUseFinished
// 0x0001 (0x0001 - 0x0000)
struct WeaponUseComponent_OnPreUseFinished final
{
public:
	bool                                          bInterrupted;                                      // 0x0000(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(WeaponUseComponent_OnPreUseFinished) == 0x000001, "Wrong alignment on WeaponUseComponent_OnPreUseFinished");
static_assert(sizeof(WeaponUseComponent_OnPreUseFinished) == 0x000001, "Wrong size on WeaponUseComponent_OnPreUseFinished");
static_assert(offsetof(WeaponUseComponent_OnPreUseFinished, bInterrupted) == 0x000000, "Member 'WeaponUseComponent_OnPreUseFinished::bInterrupted' has a wrong offset!");

// Function GbxWeapon.WeaponUseComponent.SwitchFromZoomedMode
// 0x0001 (0x0001 - 0x0000)
struct WeaponUseComponent_SwitchFromZoomedMode final
{
public:
	uint8                                         ZoomLevel;                                         // 0x0000(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(WeaponUseComponent_SwitchFromZoomedMode) == 0x000001, "Wrong alignment on WeaponUseComponent_SwitchFromZoomedMode");
static_assert(sizeof(WeaponUseComponent_SwitchFromZoomedMode) == 0x000001, "Wrong size on WeaponUseComponent_SwitchFromZoomedMode");
static_assert(offsetof(WeaponUseComponent_SwitchFromZoomedMode, ZoomLevel) == 0x000000, "Member 'WeaponUseComponent_SwitchFromZoomedMode::ZoomLevel' has a wrong offset!");

// Function GbxWeapon.WeaponUseComponent.SwitchToZoomedMode
// 0x0001 (0x0001 - 0x0000)
struct WeaponUseComponent_SwitchToZoomedMode final
{
public:
	uint8                                         ZoomLevel;                                         // 0x0000(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(WeaponUseComponent_SwitchToZoomedMode) == 0x000001, "Wrong alignment on WeaponUseComponent_SwitchToZoomedMode");
static_assert(sizeof(WeaponUseComponent_SwitchToZoomedMode) == 0x000001, "Wrong size on WeaponUseComponent_SwitchToZoomedMode");
static_assert(offsetof(WeaponUseComponent_SwitchToZoomedMode, ZoomLevel) == 0x000000, "Member 'WeaponUseComponent_SwitchToZoomedMode::ZoomLevel' has a wrong offset!");

// Function GbxWeapon.WeaponUseComponent.ToggleMode
// 0x0001 (0x0001 - 0x0000)
struct WeaponUseComponent_ToggleMode final
{
public:
	bool                                          ReturnValue;                                       // 0x0000(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(WeaponUseComponent_ToggleMode) == 0x000001, "Wrong alignment on WeaponUseComponent_ToggleMode");
static_assert(sizeof(WeaponUseComponent_ToggleMode) == 0x000001, "Wrong size on WeaponUseComponent_ToggleMode");
static_assert(offsetof(WeaponUseComponent_ToggleMode, ReturnValue) == 0x000000, "Member 'WeaponUseComponent_ToggleMode::ReturnValue' has a wrong offset!");

// Function GbxWeapon.WeaponUseComponent.CanActivateMode
// 0x0001 (0x0001 - 0x0000)
struct WeaponUseComponent_CanActivateMode final
{
public:
	bool                                          ReturnValue;                                       // 0x0000(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(WeaponUseComponent_CanActivateMode) == 0x000001, "Wrong alignment on WeaponUseComponent_CanActivateMode");
static_assert(sizeof(WeaponUseComponent_CanActivateMode) == 0x000001, "Wrong size on WeaponUseComponent_CanActivateMode");
static_assert(offsetof(WeaponUseComponent_CanActivateMode, ReturnValue) == 0x000000, "Member 'WeaponUseComponent_CanActivateMode::ReturnValue' has a wrong offset!");

// Function GbxWeapon.WeaponFireComponent.GetLockedTarget
// 0x0008 (0x0008 - 0x0000)
struct WeaponFireComponent_GetLockedTarget final
{
public:
	class AActor*                                 ReturnValue;                                       // 0x0000(0x0008)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(WeaponFireComponent_GetLockedTarget) == 0x000008, "Wrong alignment on WeaponFireComponent_GetLockedTarget");
static_assert(sizeof(WeaponFireComponent_GetLockedTarget) == 0x000008, "Wrong size on WeaponFireComponent_GetLockedTarget");
static_assert(offsetof(WeaponFireComponent_GetLockedTarget, ReturnValue) == 0x000000, "Member 'WeaponFireComponent_GetLockedTarget::ReturnValue' has a wrong offset!");

// Function GbxWeapon.WeaponFireComponent.OnLoopingFireActionEnd
// 0x0001 (0x0001 - 0x0000)
struct WeaponFireComponent_OnLoopingFireActionEnd final
{
public:
	EGbxActionEndState                            EndState;                                          // 0x0000(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(WeaponFireComponent_OnLoopingFireActionEnd) == 0x000001, "Wrong alignment on WeaponFireComponent_OnLoopingFireActionEnd");
static_assert(sizeof(WeaponFireComponent_OnLoopingFireActionEnd) == 0x000001, "Wrong size on WeaponFireComponent_OnLoopingFireActionEnd");
static_assert(offsetof(WeaponFireComponent_OnLoopingFireActionEnd, EndState) == 0x000000, "Member 'WeaponFireComponent_OnLoopingFireActionEnd::EndState' has a wrong offset!");

// Function GbxWeapon.WeaponFireComponent.GetFireRatePercent
// 0x0004 (0x0004 - 0x0000)
struct WeaponFireComponent_GetFireRatePercent final
{
public:
	float                                         ReturnValue;                                       // 0x0000(0x0004)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(WeaponFireComponent_GetFireRatePercent) == 0x000004, "Wrong alignment on WeaponFireComponent_GetFireRatePercent");
static_assert(sizeof(WeaponFireComponent_GetFireRatePercent) == 0x000004, "Wrong size on WeaponFireComponent_GetFireRatePercent");
static_assert(offsetof(WeaponFireComponent_GetFireRatePercent, ReturnValue) == 0x000000, "Member 'WeaponFireComponent_GetFireRatePercent::ReturnValue' has a wrong offset!");

// Function GbxWeapon.WeaponFireComponent.IsFireRateAccelEnabled
// 0x0001 (0x0001 - 0x0000)
struct WeaponFireComponent_IsFireRateAccelEnabled final
{
public:
	bool                                          ReturnValue;                                       // 0x0000(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(WeaponFireComponent_IsFireRateAccelEnabled) == 0x000001, "Wrong alignment on WeaponFireComponent_IsFireRateAccelEnabled");
static_assert(sizeof(WeaponFireComponent_IsFireRateAccelEnabled) == 0x000001, "Wrong size on WeaponFireComponent_IsFireRateAccelEnabled");
static_assert(offsetof(WeaponFireComponent_IsFireRateAccelEnabled, ReturnValue) == 0x000000, "Member 'WeaponFireComponent_IsFireRateAccelEnabled::ReturnValue' has a wrong offset!");

// Function GbxWeapon.WeaponFireProjectileComponent.GetShotLightProjectileData
// 0x0008 (0x0008 - 0x0000)
struct WeaponFireProjectileComponent_GetShotLightProjectileData final
{
public:
	TSubclassOf<class ULightProjectileData>       ReturnValue;                                       // 0x0000(0x0008)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(WeaponFireProjectileComponent_GetShotLightProjectileData) == 0x000008, "Wrong alignment on WeaponFireProjectileComponent_GetShotLightProjectileData");
static_assert(sizeof(WeaponFireProjectileComponent_GetShotLightProjectileData) == 0x000008, "Wrong size on WeaponFireProjectileComponent_GetShotLightProjectileData");
static_assert(offsetof(WeaponFireProjectileComponent_GetShotLightProjectileData, ReturnValue) == 0x000000, "Member 'WeaponFireProjectileComponent_GetShotLightProjectileData::ReturnValue' has a wrong offset!");

// Function GbxWeapon.WeaponFireProjectileComponent.GetShotProjectileData
// 0x0008 (0x0008 - 0x0000)
struct WeaponFireProjectileComponent_GetShotProjectileData final
{
public:
	TSubclassOf<class AActor>                     ReturnValue;                                       // 0x0000(0x0008)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(WeaponFireProjectileComponent_GetShotProjectileData) == 0x000008, "Wrong alignment on WeaponFireProjectileComponent_GetShotProjectileData");
static_assert(sizeof(WeaponFireProjectileComponent_GetShotProjectileData) == 0x000008, "Wrong size on WeaponFireProjectileComponent_GetShotProjectileData");
static_assert(offsetof(WeaponFireProjectileComponent_GetShotProjectileData, ReturnValue) == 0x000000, "Member 'WeaponFireProjectileComponent_GetShotProjectileData::ReturnValue' has a wrong offset!");

// Function GbxWeapon.GbxProjectileMovementComponent.OnBounce
// 0x00A0 (0x00A0 - 0x0000)
struct GbxProjectileMovementComponent_OnBounce final
{
public:
	struct FHitResult                             ImpactResult;                                      // 0x0000(0x0090)(ConstParm, Parm, OutParm, ReferenceParm, IsPlainOldData, NoDestructor, ContainsInstancedReference, NativeAccessSpecifierPublic)
	struct FVector                                ImpactVelocity;                                    // 0x0090(0x000C)(ConstParm, Parm, OutParm, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_9C[0x4];                                       // 0x009C(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(GbxProjectileMovementComponent_OnBounce) == 0x000008, "Wrong alignment on GbxProjectileMovementComponent_OnBounce");
static_assert(sizeof(GbxProjectileMovementComponent_OnBounce) == 0x0000A0, "Wrong size on GbxProjectileMovementComponent_OnBounce");
static_assert(offsetof(GbxProjectileMovementComponent_OnBounce, ImpactResult) == 0x000000, "Member 'GbxProjectileMovementComponent_OnBounce::ImpactResult' has a wrong offset!");
static_assert(offsetof(GbxProjectileMovementComponent_OnBounce, ImpactVelocity) == 0x000090, "Member 'GbxProjectileMovementComponent_OnBounce::ImpactVelocity' has a wrong offset!");

// Function GbxWeapon.GbxProjectileMovementComponent.OnHit
// 0x00B0 (0x00B0 - 0x0000)
struct GbxProjectileMovementComponent_OnHit final
{
public:
	class AActor*                                 SelfActor;                                         // 0x0000(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class AActor*                                 OtherActor;                                        // 0x0008(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                NormalImpulse;                                     // 0x0010(0x000C)(Parm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1C[0x4];                                       // 0x001C(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	struct FHitResult                             Hit;                                               // 0x0020(0x0090)(ConstParm, Parm, OutParm, ReferenceParm, IsPlainOldData, NoDestructor, ContainsInstancedReference, NativeAccessSpecifierPublic)
};
static_assert(alignof(GbxProjectileMovementComponent_OnHit) == 0x000008, "Wrong alignment on GbxProjectileMovementComponent_OnHit");
static_assert(sizeof(GbxProjectileMovementComponent_OnHit) == 0x0000B0, "Wrong size on GbxProjectileMovementComponent_OnHit");
static_assert(offsetof(GbxProjectileMovementComponent_OnHit, SelfActor) == 0x000000, "Member 'GbxProjectileMovementComponent_OnHit::SelfActor' has a wrong offset!");
static_assert(offsetof(GbxProjectileMovementComponent_OnHit, OtherActor) == 0x000008, "Member 'GbxProjectileMovementComponent_OnHit::OtherActor' has a wrong offset!");
static_assert(offsetof(GbxProjectileMovementComponent_OnHit, NormalImpulse) == 0x000010, "Member 'GbxProjectileMovementComponent_OnHit::NormalImpulse' has a wrong offset!");
static_assert(offsetof(GbxProjectileMovementComponent_OnHit, Hit) == 0x000020, "Member 'GbxProjectileMovementComponent_OnHit::Hit' has a wrong offset!");

// DelegateFunction GbxWeapon.GbxProjectileMovementComponent.OnProjectilePostLastBounceDelegate__DelegateSignature
// 0x0090 (0x0090 - 0x0000)
struct GbxProjectileMovementComponent_OnProjectilePostLastBounceDelegate__DelegateSignature final
{
public:
	struct FHitResult                             ImpactResult;                                      // 0x0000(0x0090)(ConstParm, Parm, OutParm, ReferenceParm, IsPlainOldData, NoDestructor, ContainsInstancedReference, NativeAccessSpecifierPublic)
};
static_assert(alignof(GbxProjectileMovementComponent_OnProjectilePostLastBounceDelegate__DelegateSignature) == 0x000008, "Wrong alignment on GbxProjectileMovementComponent_OnProjectilePostLastBounceDelegate__DelegateSignature");
static_assert(sizeof(GbxProjectileMovementComponent_OnProjectilePostLastBounceDelegate__DelegateSignature) == 0x000090, "Wrong size on GbxProjectileMovementComponent_OnProjectilePostLastBounceDelegate__DelegateSignature");
static_assert(offsetof(GbxProjectileMovementComponent_OnProjectilePostLastBounceDelegate__DelegateSignature, ImpactResult) == 0x000000, "Member 'GbxProjectileMovementComponent_OnProjectilePostLastBounceDelegate__DelegateSignature::ImpactResult' has a wrong offset!");

// Function GbxWeapon.GbxProjectileMovementComponent.ScaleVelocity
// 0x0004 (0x0004 - 0x0000)
struct GbxProjectileMovementComponent_ScaleVelocity final
{
public:
	float                                         InScale;                                           // 0x0000(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(GbxProjectileMovementComponent_ScaleVelocity) == 0x000004, "Wrong alignment on GbxProjectileMovementComponent_ScaleVelocity");
static_assert(sizeof(GbxProjectileMovementComponent_ScaleVelocity) == 0x000004, "Wrong size on GbxProjectileMovementComponent_ScaleVelocity");
static_assert(offsetof(GbxProjectileMovementComponent_ScaleVelocity, InScale) == 0x000000, "Member 'GbxProjectileMovementComponent_ScaleVelocity::InScale' has a wrong offset!");

// Function GbxWeapon.Projectile.BounceDelegate
// 0x00A0 (0x00A0 - 0x0000)
struct Projectile_BounceDelegate final
{
public:
	struct FHitResult                             ImpactResult;                                      // 0x0000(0x0090)(ConstParm, Parm, OutParm, ReferenceParm, IsPlainOldData, NoDestructor, ContainsInstancedReference, NativeAccessSpecifierPublic)
	struct FVector                                ImpactVelocity;                                    // 0x0090(0x000C)(ConstParm, Parm, OutParm, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_9C[0x4];                                       // 0x009C(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(Projectile_BounceDelegate) == 0x000008, "Wrong alignment on Projectile_BounceDelegate");
static_assert(sizeof(Projectile_BounceDelegate) == 0x0000A0, "Wrong size on Projectile_BounceDelegate");
static_assert(offsetof(Projectile_BounceDelegate, ImpactResult) == 0x000000, "Member 'Projectile_BounceDelegate::ImpactResult' has a wrong offset!");
static_assert(offsetof(Projectile_BounceDelegate, ImpactVelocity) == 0x000090, "Member 'Projectile_BounceDelegate::ImpactVelocity' has a wrong offset!");

// Function GbxWeapon.Projectile.GetExplosionComponent
// 0x0008 (0x0008 - 0x0000)
struct Projectile_GetExplosionComponent final
{
public:
	class UExplosionComponent*                    ReturnValue;                                       // 0x0000(0x0008)(ExportObject, Parm, OutParm, ZeroConstructor, ReturnParm, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(Projectile_GetExplosionComponent) == 0x000008, "Wrong alignment on Projectile_GetExplosionComponent");
static_assert(sizeof(Projectile_GetExplosionComponent) == 0x000008, "Wrong size on Projectile_GetExplosionComponent");
static_assert(offsetof(Projectile_GetExplosionComponent, ReturnValue) == 0x000000, "Member 'Projectile_GetExplosionComponent::ReturnValue' has a wrong offset!");

// Function GbxWeapon.Projectile.GetProjectileDamage
// 0x0004 (0x0004 - 0x0000)
struct Projectile_GetProjectileDamage final
{
public:
	float                                         ReturnValue;                                       // 0x0000(0x0004)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(Projectile_GetProjectileDamage) == 0x000004, "Wrong alignment on Projectile_GetProjectileDamage");
static_assert(sizeof(Projectile_GetProjectileDamage) == 0x000004, "Wrong size on Projectile_GetProjectileDamage");
static_assert(offsetof(Projectile_GetProjectileDamage, ReturnValue) == 0x000000, "Member 'Projectile_GetProjectileDamage::ReturnValue' has a wrong offset!");

// Function GbxWeapon.Projectile.GetProjectileDamageRadius
// 0x0004 (0x0004 - 0x0000)
struct Projectile_GetProjectileDamageRadius final
{
public:
	float                                         ReturnValue;                                       // 0x0000(0x0004)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(Projectile_GetProjectileDamageRadius) == 0x000004, "Wrong alignment on Projectile_GetProjectileDamageRadius");
static_assert(sizeof(Projectile_GetProjectileDamageRadius) == 0x000004, "Wrong size on Projectile_GetProjectileDamageRadius");
static_assert(offsetof(Projectile_GetProjectileDamageRadius, ReturnValue) == 0x000000, "Member 'Projectile_GetProjectileDamageRadius::ReturnValue' has a wrong offset!");

// Function GbxWeapon.Projectile.GetProjectileDamageSource
// 0x0008 (0x0008 - 0x0000)
struct Projectile_GetProjectileDamageSource final
{
public:
	TSubclassOf<class UDamageSource>              ReturnValue;                                       // 0x0000(0x0008)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(Projectile_GetProjectileDamageSource) == 0x000008, "Wrong alignment on Projectile_GetProjectileDamageSource");
static_assert(sizeof(Projectile_GetProjectileDamageSource) == 0x000008, "Wrong size on Projectile_GetProjectileDamageSource");
static_assert(offsetof(Projectile_GetProjectileDamageSource, ReturnValue) == 0x000000, "Member 'Projectile_GetProjectileDamageSource::ReturnValue' has a wrong offset!");

// Function GbxWeapon.Projectile.GetProjectileDamageType
// 0x0008 (0x0008 - 0x0000)
struct Projectile_GetProjectileDamageType final
{
public:
	TSubclassOf<class UGbxDamageType>             ReturnValue;                                       // 0x0000(0x0008)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(Projectile_GetProjectileDamageType) == 0x000008, "Wrong alignment on Projectile_GetProjectileDamageType");
static_assert(sizeof(Projectile_GetProjectileDamageType) == 0x000008, "Wrong size on Projectile_GetProjectileDamageType");
static_assert(offsetof(Projectile_GetProjectileDamageType, ReturnValue) == 0x000000, "Member 'Projectile_GetProjectileDamageType::ReturnValue' has a wrong offset!");

// Function GbxWeapon.Projectile.GetProjectileMovementComponent
// 0x0008 (0x0008 - 0x0000)
struct Projectile_GetProjectileMovementComponent final
{
public:
	class UGbxProjectileMovementComponent*        ReturnValue;                                       // 0x0000(0x0008)(ExportObject, Parm, OutParm, ZeroConstructor, ReturnParm, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(Projectile_GetProjectileMovementComponent) == 0x000008, "Wrong alignment on Projectile_GetProjectileMovementComponent");
static_assert(sizeof(Projectile_GetProjectileMovementComponent) == 0x000008, "Wrong size on Projectile_GetProjectileMovementComponent");
static_assert(offsetof(Projectile_GetProjectileMovementComponent, ReturnValue) == 0x000000, "Member 'Projectile_GetProjectileMovementComponent::ReturnValue' has a wrong offset!");

// Function GbxWeapon.Projectile.IgnoreCollisionWith
// 0x0008 (0x0008 - 0x0000)
struct Projectile_IgnoreCollisionWith final
{
public:
	class AActor*                                 ActorToIgnore;                                     // 0x0000(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(Projectile_IgnoreCollisionWith) == 0x000008, "Wrong alignment on Projectile_IgnoreCollisionWith");
static_assert(sizeof(Projectile_IgnoreCollisionWith) == 0x000008, "Wrong size on Projectile_IgnoreCollisionWith");
static_assert(offsetof(Projectile_IgnoreCollisionWith, ActorToIgnore) == 0x000000, "Member 'Projectile_IgnoreCollisionWith::ActorToIgnore' has a wrong offset!");

// Function GbxWeapon.Projectile.OnBounce
// 0x00A0 (0x00A0 - 0x0000)
struct Projectile_OnBounce final
{
public:
	struct FHitResult                             Hit;                                               // 0x0000(0x0090)(ConstParm, Parm, OutParm, ReferenceParm, IsPlainOldData, NoDestructor, ContainsInstancedReference, NativeAccessSpecifierPublic)
	struct FVector                                ImpactVelocity;                                    // 0x0090(0x000C)(ConstParm, Parm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_9C[0x4];                                       // 0x009C(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(Projectile_OnBounce) == 0x000008, "Wrong alignment on Projectile_OnBounce");
static_assert(sizeof(Projectile_OnBounce) == 0x0000A0, "Wrong size on Projectile_OnBounce");
static_assert(offsetof(Projectile_OnBounce, Hit) == 0x000000, "Member 'Projectile_OnBounce::Hit' has a wrong offset!");
static_assert(offsetof(Projectile_OnBounce, ImpactVelocity) == 0x000090, "Member 'Projectile_OnBounce::ImpactVelocity' has a wrong offset!");

// Function GbxWeapon.Projectile.OnComponentDetachedFromParent
// 0x0008 (0x0008 - 0x0000)
struct Projectile_OnComponentDetachedFromParent final
{
public:
	class USceneComponent*                        SceneComponent;                                    // 0x0000(0x0008)(Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(Projectile_OnComponentDetachedFromParent) == 0x000008, "Wrong alignment on Projectile_OnComponentDetachedFromParent");
static_assert(sizeof(Projectile_OnComponentDetachedFromParent) == 0x000008, "Wrong size on Projectile_OnComponentDetachedFromParent");
static_assert(offsetof(Projectile_OnComponentDetachedFromParent, SceneComponent) == 0x000000, "Member 'Projectile_OnComponentDetachedFromParent::SceneComponent' has a wrong offset!");

// Function GbxWeapon.Projectile.OnHitDamagableObject
// 0x0090 (0x0090 - 0x0000)
struct Projectile_OnHitDamagableObject final
{
public:
	struct FHitResult                             Hit;                                               // 0x0000(0x0090)(ConstParm, Parm, OutParm, ReferenceParm, IsPlainOldData, NoDestructor, ContainsInstancedReference, NativeAccessSpecifierPublic)
};
static_assert(alignof(Projectile_OnHitDamagableObject) == 0x000008, "Wrong alignment on Projectile_OnHitDamagableObject");
static_assert(sizeof(Projectile_OnHitDamagableObject) == 0x000090, "Wrong size on Projectile_OnHitDamagableObject");
static_assert(offsetof(Projectile_OnHitDamagableObject, Hit) == 0x000000, "Member 'Projectile_OnHitDamagableObject::Hit' has a wrong offset!");

// Function GbxWeapon.Projectile.OnHitEnemy
// 0x0090 (0x0090 - 0x0000)
struct Projectile_OnHitEnemy final
{
public:
	struct FHitResult                             Hit;                                               // 0x0000(0x0090)(ConstParm, Parm, OutParm, ReferenceParm, IsPlainOldData, NoDestructor, ContainsInstancedReference, NativeAccessSpecifierPublic)
};
static_assert(alignof(Projectile_OnHitEnemy) == 0x000008, "Wrong alignment on Projectile_OnHitEnemy");
static_assert(sizeof(Projectile_OnHitEnemy) == 0x000090, "Wrong size on Projectile_OnHitEnemy");
static_assert(offsetof(Projectile_OnHitEnemy, Hit) == 0x000000, "Member 'Projectile_OnHitEnemy::Hit' has a wrong offset!");

// Function GbxWeapon.Projectile.OnHitFriendly
// 0x0090 (0x0090 - 0x0000)
struct Projectile_OnHitFriendly final
{
public:
	struct FHitResult                             Hit;                                               // 0x0000(0x0090)(ConstParm, Parm, OutParm, ReferenceParm, IsPlainOldData, NoDestructor, ContainsInstancedReference, NativeAccessSpecifierPublic)
};
static_assert(alignof(Projectile_OnHitFriendly) == 0x000008, "Wrong alignment on Projectile_OnHitFriendly");
static_assert(sizeof(Projectile_OnHitFriendly) == 0x000090, "Wrong size on Projectile_OnHitFriendly");
static_assert(offsetof(Projectile_OnHitFriendly, Hit) == 0x000000, "Member 'Projectile_OnHitFriendly::Hit' has a wrong offset!");

// Function GbxWeapon.Projectile.OnHitNeutral
// 0x0090 (0x0090 - 0x0000)
struct Projectile_OnHitNeutral final
{
public:
	struct FHitResult                             Hit;                                               // 0x0000(0x0090)(ConstParm, Parm, OutParm, ReferenceParm, IsPlainOldData, NoDestructor, ContainsInstancedReference, NativeAccessSpecifierPublic)
};
static_assert(alignof(Projectile_OnHitNeutral) == 0x000008, "Wrong alignment on Projectile_OnHitNeutral");
static_assert(sizeof(Projectile_OnHitNeutral) == 0x000090, "Wrong size on Projectile_OnHitNeutral");
static_assert(offsetof(Projectile_OnHitNeutral, Hit) == 0x000000, "Member 'Projectile_OnHitNeutral::Hit' has a wrong offset!");

// Function GbxWeapon.Projectile.OnHitWorld
// 0x0090 (0x0090 - 0x0000)
struct Projectile_OnHitWorld final
{
public:
	struct FHitResult                             Hit;                                               // 0x0000(0x0090)(ConstParm, Parm, OutParm, ReferenceParm, IsPlainOldData, NoDestructor, ContainsInstancedReference, NativeAccessSpecifierPublic)
};
static_assert(alignof(Projectile_OnHitWorld) == 0x000008, "Wrong alignment on Projectile_OnHitWorld");
static_assert(sizeof(Projectile_OnHitWorld) == 0x000090, "Wrong size on Projectile_OnHitWorld");
static_assert(offsetof(Projectile_OnHitWorld, Hit) == 0x000000, "Member 'Projectile_OnHitWorld::Hit' has a wrong offset!");

// Function GbxWeapon.Projectile.OnLastBounce
// 0x0090 (0x0090 - 0x0000)
struct Projectile_OnLastBounce final
{
public:
	struct FHitResult                             ImpactResult;                                      // 0x0000(0x0090)(ConstParm, Parm, OutParm, ReferenceParm, IsPlainOldData, NoDestructor, ContainsInstancedReference, NativeAccessSpecifierPublic)
};
static_assert(alignof(Projectile_OnLastBounce) == 0x000008, "Wrong alignment on Projectile_OnLastBounce");
static_assert(sizeof(Projectile_OnLastBounce) == 0x000090, "Wrong size on Projectile_OnLastBounce");
static_assert(offsetof(Projectile_OnLastBounce, ImpactResult) == 0x000000, "Member 'Projectile_OnLastBounce::ImpactResult' has a wrong offset!");

// Function GbxWeapon.Projectile.ResetCollisionWith
// 0x0008 (0x0008 - 0x0000)
struct Projectile_ResetCollisionWith final
{
public:
	class AActor*                                 ActorToCollide;                                    // 0x0000(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(Projectile_ResetCollisionWith) == 0x000008, "Wrong alignment on Projectile_ResetCollisionWith");
static_assert(sizeof(Projectile_ResetCollisionWith) == 0x000008, "Wrong size on Projectile_ResetCollisionWith");
static_assert(offsetof(Projectile_ResetCollisionWith, ActorToCollide) == 0x000000, "Member 'Projectile_ResetCollisionWith::ActorToCollide' has a wrong offset!");

// Function GbxWeapon.Projectile.SetProjectileDamage
// 0x0004 (0x0004 - 0x0000)
struct Projectile_SetProjectileDamage final
{
public:
	float                                         Damage;                                            // 0x0000(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(Projectile_SetProjectileDamage) == 0x000004, "Wrong alignment on Projectile_SetProjectileDamage");
static_assert(sizeof(Projectile_SetProjectileDamage) == 0x000004, "Wrong size on Projectile_SetProjectileDamage");
static_assert(offsetof(Projectile_SetProjectileDamage, Damage) == 0x000000, "Member 'Projectile_SetProjectileDamage::Damage' has a wrong offset!");

// Function GbxWeapon.Projectile.SetProjectileDamageRadius
// 0x0004 (0x0004 - 0x0000)
struct Projectile_SetProjectileDamageRadius final
{
public:
	float                                         DamageRadius;                                      // 0x0000(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(Projectile_SetProjectileDamageRadius) == 0x000004, "Wrong alignment on Projectile_SetProjectileDamageRadius");
static_assert(sizeof(Projectile_SetProjectileDamageRadius) == 0x000004, "Wrong size on Projectile_SetProjectileDamageRadius");
static_assert(offsetof(Projectile_SetProjectileDamageRadius, DamageRadius) == 0x000000, "Member 'Projectile_SetProjectileDamageRadius::DamageRadius' has a wrong offset!");

// Function GbxWeapon.Projectile.SetProjectileDamageSource
// 0x0008 (0x0008 - 0x0000)
struct Projectile_SetProjectileDamageSource final
{
public:
	TSubclassOf<class UDamageSource>              DamageSource;                                      // 0x0000(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(Projectile_SetProjectileDamageSource) == 0x000008, "Wrong alignment on Projectile_SetProjectileDamageSource");
static_assert(sizeof(Projectile_SetProjectileDamageSource) == 0x000008, "Wrong size on Projectile_SetProjectileDamageSource");
static_assert(offsetof(Projectile_SetProjectileDamageSource, DamageSource) == 0x000000, "Member 'Projectile_SetProjectileDamageSource::DamageSource' has a wrong offset!");

// Function GbxWeapon.Projectile.SetProjectileDamageType
// 0x0008 (0x0008 - 0x0000)
struct Projectile_SetProjectileDamageType final
{
public:
	TSubclassOf<class UGbxDamageType>             DamageType;                                        // 0x0000(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(Projectile_SetProjectileDamageType) == 0x000008, "Wrong alignment on Projectile_SetProjectileDamageType");
static_assert(sizeof(Projectile_SetProjectileDamageType) == 0x000008, "Wrong size on Projectile_SetProjectileDamageType");
static_assert(offsetof(Projectile_SetProjectileDamageType, DamageType) == 0x000000, "Member 'Projectile_SetProjectileDamageType::DamageType' has a wrong offset!");

// Function GbxWeapon.LightProjectileManager.OnParticleSystemFinished
// 0x0008 (0x0008 - 0x0000)
struct LightProjectileManager_OnParticleSystemFinished final
{
public:
	class UParticleSystemComponent*               FinishedComponent;                                 // 0x0000(0x0008)(Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(LightProjectileManager_OnParticleSystemFinished) == 0x000008, "Wrong alignment on LightProjectileManager_OnParticleSystemFinished");
static_assert(sizeof(LightProjectileManager_OnParticleSystemFinished) == 0x000008, "Wrong size on LightProjectileManager_OnParticleSystemFinished");
static_assert(offsetof(LightProjectileManager_OnParticleSystemFinished, FinishedComponent) == 0x000000, "Member 'LightProjectileManager_OnParticleSystemFinished::FinishedComponent' has a wrong offset!");

// Function GbxWeapon.LightProjectileManager.ServerSendDebugProjectileImpact
// 0x0020 (0x0020 - 0x0000)
struct LightProjectileManager_ServerSendDebugProjectileImpact final
{
public:
	int32                                         ProjSyncID;                                        // 0x0000(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_4[0x4];                                        // 0x0004(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class AActor*                                 HitActor;                                          // 0x0008(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   BoneName;                                          // 0x0010(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint16                                        ProjFlags;                                         // 0x0018(0x0002)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1A[0x6];                                       // 0x001A(0x0006)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(LightProjectileManager_ServerSendDebugProjectileImpact) == 0x000008, "Wrong alignment on LightProjectileManager_ServerSendDebugProjectileImpact");
static_assert(sizeof(LightProjectileManager_ServerSendDebugProjectileImpact) == 0x000020, "Wrong size on LightProjectileManager_ServerSendDebugProjectileImpact");
static_assert(offsetof(LightProjectileManager_ServerSendDebugProjectileImpact, ProjSyncID) == 0x000000, "Member 'LightProjectileManager_ServerSendDebugProjectileImpact::ProjSyncID' has a wrong offset!");
static_assert(offsetof(LightProjectileManager_ServerSendDebugProjectileImpact, HitActor) == 0x000008, "Member 'LightProjectileManager_ServerSendDebugProjectileImpact::HitActor' has a wrong offset!");
static_assert(offsetof(LightProjectileManager_ServerSendDebugProjectileImpact, BoneName) == 0x000010, "Member 'LightProjectileManager_ServerSendDebugProjectileImpact::BoneName' has a wrong offset!");
static_assert(offsetof(LightProjectileManager_ServerSendDebugProjectileImpact, ProjFlags) == 0x000018, "Member 'LightProjectileManager_ServerSendDebugProjectileImpact::ProjFlags' has a wrong offset!");

// Function GbxWeapon.WeaponHeatComponent.OnRep_Overheated
// 0x0001 (0x0001 - 0x0000)
struct WeaponHeatComponent_OnRep_Overheated final
{
public:
	bool                                          bWasOverheated;                                    // 0x0000(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(WeaponHeatComponent_OnRep_Overheated) == 0x000001, "Wrong alignment on WeaponHeatComponent_OnRep_Overheated");
static_assert(sizeof(WeaponHeatComponent_OnRep_Overheated) == 0x000001, "Wrong size on WeaponHeatComponent_OnRep_Overheated");
static_assert(offsetof(WeaponHeatComponent_OnRep_Overheated, bWasOverheated) == 0x000000, "Member 'WeaponHeatComponent_OnRep_Overheated::bWasOverheated' has a wrong offset!");

// Function GbxWeapon.WeaponHeatComponent.SetCanUseWhenOverheated
// 0x0001 (0x0001 - 0x0000)
struct WeaponHeatComponent_SetCanUseWhenOverheated final
{
public:
	bool                                          bEnabled;                                          // 0x0000(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(WeaponHeatComponent_SetCanUseWhenOverheated) == 0x000001, "Wrong alignment on WeaponHeatComponent_SetCanUseWhenOverheated");
static_assert(sizeof(WeaponHeatComponent_SetCanUseWhenOverheated) == 0x000001, "Wrong size on WeaponHeatComponent_SetCanUseWhenOverheated");
static_assert(offsetof(WeaponHeatComponent_SetCanUseWhenOverheated, bEnabled) == 0x000000, "Member 'WeaponHeatComponent_SetCanUseWhenOverheated::bEnabled' has a wrong offset!");

// Function GbxWeapon.LightProjectile.ApplyAreaDamage
// 0x00A8 (0x00A8 - 0x0000)
struct LightProjectile_ApplyAreaDamage final
{
public:
	struct FVector                                Origin;                                            // 0x0000(0x000C)(ConstParm, Parm, OutParm, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_C[0x4];                                        // 0x000C(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class AActor*                                 HitActor;                                          // 0x0010(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FHitResult                             Hit;                                               // 0x0018(0x0090)(ConstParm, Parm, OutParm, ReferenceParm, IsPlainOldData, NoDestructor, ContainsInstancedReference, NativeAccessSpecifierPublic)
};
static_assert(alignof(LightProjectile_ApplyAreaDamage) == 0x000008, "Wrong alignment on LightProjectile_ApplyAreaDamage");
static_assert(sizeof(LightProjectile_ApplyAreaDamage) == 0x0000A8, "Wrong size on LightProjectile_ApplyAreaDamage");
static_assert(offsetof(LightProjectile_ApplyAreaDamage, Origin) == 0x000000, "Member 'LightProjectile_ApplyAreaDamage::Origin' has a wrong offset!");
static_assert(offsetof(LightProjectile_ApplyAreaDamage, HitActor) == 0x000010, "Member 'LightProjectile_ApplyAreaDamage::HitActor' has a wrong offset!");
static_assert(offsetof(LightProjectile_ApplyAreaDamage, Hit) == 0x000018, "Member 'LightProjectile_ApplyAreaDamage::Hit' has a wrong offset!");

// Function GbxWeapon.LightProjectile.Explode
// 0x0004 (0x0004 - 0x0000)
struct LightProjectile_Explode final
{
public:
	float                                         Delay;                                             // 0x0000(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(LightProjectile_Explode) == 0x000004, "Wrong alignment on LightProjectile_Explode");
static_assert(sizeof(LightProjectile_Explode) == 0x000004, "Wrong size on LightProjectile_Explode");
static_assert(offsetof(LightProjectile_Explode, Delay) == 0x000000, "Member 'LightProjectile_Explode::Delay' has a wrong offset!");

// Function GbxWeapon.LightProjectile.K2_ApplyImpactDamage
// 0x0098 (0x0098 - 0x0000)
struct LightProjectile_K2_ApplyImpactDamage final
{
public:
	struct FHitResult                             Hit;                                               // 0x0000(0x0090)(ConstParm, Parm, OutParm, ReferenceParm, IsPlainOldData, NoDestructor, ContainsInstancedReference, NativeAccessSpecifierPublic)
	float                                         ImpactDamage;                                      // 0x0090(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bPenetrated;                                       // 0x0094(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bCanReflect;                                       // 0x0095(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_96[0x2];                                       // 0x0096(0x0002)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(LightProjectile_K2_ApplyImpactDamage) == 0x000008, "Wrong alignment on LightProjectile_K2_ApplyImpactDamage");
static_assert(sizeof(LightProjectile_K2_ApplyImpactDamage) == 0x000098, "Wrong size on LightProjectile_K2_ApplyImpactDamage");
static_assert(offsetof(LightProjectile_K2_ApplyImpactDamage, Hit) == 0x000000, "Member 'LightProjectile_K2_ApplyImpactDamage::Hit' has a wrong offset!");
static_assert(offsetof(LightProjectile_K2_ApplyImpactDamage, ImpactDamage) == 0x000090, "Member 'LightProjectile_K2_ApplyImpactDamage::ImpactDamage' has a wrong offset!");
static_assert(offsetof(LightProjectile_K2_ApplyImpactDamage, bPenetrated) == 0x000094, "Member 'LightProjectile_K2_ApplyImpactDamage::bPenetrated' has a wrong offset!");
static_assert(offsetof(LightProjectile_K2_ApplyImpactDamage, bCanReflect) == 0x000095, "Member 'LightProjectile_K2_ApplyImpactDamage::bCanReflect' has a wrong offset!");

// Function GbxWeapon.LightProjectile.OnAttachedActorDestroyed
// 0x0008 (0x0008 - 0x0000)
struct LightProjectile_OnAttachedActorDestroyed final
{
public:
	class AActor*                                 DestroyedActor;                                    // 0x0000(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(LightProjectile_OnAttachedActorDestroyed) == 0x000008, "Wrong alignment on LightProjectile_OnAttachedActorDestroyed");
static_assert(sizeof(LightProjectile_OnAttachedActorDestroyed) == 0x000008, "Wrong size on LightProjectile_OnAttachedActorDestroyed");
static_assert(offsetof(LightProjectile_OnAttachedActorDestroyed, DestroyedActor) == 0x000000, "Member 'LightProjectile_OnAttachedActorDestroyed::DestroyedActor' has a wrong offset!");

// Function GbxWeapon.LightProjectile.OnAttachedActorFractured
// 0x0018 (0x0018 - 0x0000)
struct LightProjectile_OnAttachedActorFractured final
{
public:
	struct FVector                                HitPoint;                                          // 0x0000(0x000C)(ConstParm, Parm, OutParm, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                HitDirection;                                      // 0x000C(0x000C)(ConstParm, Parm, OutParm, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(LightProjectile_OnAttachedActorFractured) == 0x000004, "Wrong alignment on LightProjectile_OnAttachedActorFractured");
static_assert(sizeof(LightProjectile_OnAttachedActorFractured) == 0x000018, "Wrong size on LightProjectile_OnAttachedActorFractured");
static_assert(offsetof(LightProjectile_OnAttachedActorFractured, HitPoint) == 0x000000, "Member 'LightProjectile_OnAttachedActorFractured::HitPoint' has a wrong offset!");
static_assert(offsetof(LightProjectile_OnAttachedActorFractured, HitDirection) == 0x00000C, "Member 'LightProjectile_OnAttachedActorFractured::HitDirection' has a wrong offset!");

// Function GbxWeapon.LightProjectile.OnAttachedComponentCollisionChanged
// 0x0008 (0x0008 - 0x0000)
struct LightProjectile_OnAttachedComponentCollisionChanged final
{
public:
	class UPrimitiveComponent*                    ChangedComponent;                                  // 0x0000(0x0008)(Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(LightProjectile_OnAttachedComponentCollisionChanged) == 0x000008, "Wrong alignment on LightProjectile_OnAttachedComponentCollisionChanged");
static_assert(sizeof(LightProjectile_OnAttachedComponentCollisionChanged) == 0x000008, "Wrong size on LightProjectile_OnAttachedComponentCollisionChanged");
static_assert(offsetof(LightProjectile_OnAttachedComponentCollisionChanged, ChangedComponent) == 0x000000, "Member 'LightProjectile_OnAttachedComponentCollisionChanged::ChangedComponent' has a wrong offset!");

// Function GbxWeapon.LightProjectile.OnAttachedComponentUnregistered
// 0x0008 (0x0008 - 0x0000)
struct LightProjectile_OnAttachedComponentUnregistered final
{
public:
	class UActorComponent*                        UnregisteredComponent;                             // 0x0000(0x0008)(Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(LightProjectile_OnAttachedComponentUnregistered) == 0x000008, "Wrong alignment on LightProjectile_OnAttachedComponentUnregistered");
static_assert(sizeof(LightProjectile_OnAttachedComponentUnregistered) == 0x000008, "Wrong size on LightProjectile_OnAttachedComponentUnregistered");
static_assert(offsetof(LightProjectile_OnAttachedComponentUnregistered, UnregisteredComponent) == 0x000000, "Member 'LightProjectile_OnAttachedComponentUnregistered::UnregisteredComponent' has a wrong offset!");

// Function GbxWeapon.LightProjectile.OnParticleSystemFinished
// 0x0008 (0x0008 - 0x0000)
struct LightProjectile_OnParticleSystemFinished final
{
public:
	class UParticleSystemComponent*               FinishedComponent;                                 // 0x0000(0x0008)(Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(LightProjectile_OnParticleSystemFinished) == 0x000008, "Wrong alignment on LightProjectile_OnParticleSystemFinished");
static_assert(sizeof(LightProjectile_OnParticleSystemFinished) == 0x000008, "Wrong size on LightProjectile_OnParticleSystemFinished");
static_assert(offsetof(LightProjectile_OnParticleSystemFinished, FinishedComponent) == 0x000000, "Member 'LightProjectile_OnParticleSystemFinished::FinishedComponent' has a wrong offset!");

// Function GbxWeapon.LightProjectile.SetHomingTarget
// 0x0018 (0x0018 - 0x0000)
struct LightProjectile_SetHomingTarget final
{
public:
	class AActor*                                 HomingTarget;                                      // 0x0000(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                TargetOffset;                                      // 0x0008(0x000C)(Parm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_14[0x4];                                       // 0x0014(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(LightProjectile_SetHomingTarget) == 0x000008, "Wrong alignment on LightProjectile_SetHomingTarget");
static_assert(sizeof(LightProjectile_SetHomingTarget) == 0x000018, "Wrong size on LightProjectile_SetHomingTarget");
static_assert(offsetof(LightProjectile_SetHomingTarget, HomingTarget) == 0x000000, "Member 'LightProjectile_SetHomingTarget::HomingTarget' has a wrong offset!");
static_assert(offsetof(LightProjectile_SetHomingTarget, TargetOffset) == 0x000008, "Member 'LightProjectile_SetHomingTarget::TargetOffset' has a wrong offset!");

// Function GbxWeapon.LightProjectile.SetHomingTargetLocation
// 0x000C (0x000C - 0x0000)
struct LightProjectile_SetHomingTargetLocation final
{
public:
	struct FVector                                HomingLocation;                                    // 0x0000(0x000C)(Parm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(LightProjectile_SetHomingTargetLocation) == 0x000004, "Wrong alignment on LightProjectile_SetHomingTargetLocation");
static_assert(sizeof(LightProjectile_SetHomingTargetLocation) == 0x00000C, "Wrong size on LightProjectile_SetHomingTargetLocation");
static_assert(offsetof(LightProjectile_SetHomingTargetLocation, HomingLocation) == 0x000000, "Member 'LightProjectile_SetHomingTargetLocation::HomingLocation' has a wrong offset!");

// Function GbxWeapon.LightProjectile.SetLifetime
// 0x0004 (0x0004 - 0x0000)
struct LightProjectile_SetLifetime final
{
public:
	float                                         NewLifetime;                                       // 0x0000(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(LightProjectile_SetLifetime) == 0x000004, "Wrong alignment on LightProjectile_SetLifetime");
static_assert(sizeof(LightProjectile_SetLifetime) == 0x000004, "Wrong size on LightProjectile_SetLifetime");
static_assert(offsetof(LightProjectile_SetLifetime, NewLifetime) == 0x000000, "Member 'LightProjectile_SetLifetime::NewLifetime' has a wrong offset!");

// Function GbxWeapon.LightProjectile.GetAssociatedActor
// 0x0010 (0x0010 - 0x0000)
struct LightProjectile_GetAssociatedActor final
{
public:
	ELightProjectileQueryActorType                ActorType;                                         // 0x0000(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1[0x7];                                        // 0x0001(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	class AActor*                                 ReturnValue;                                       // 0x0008(0x0008)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(LightProjectile_GetAssociatedActor) == 0x000008, "Wrong alignment on LightProjectile_GetAssociatedActor");
static_assert(sizeof(LightProjectile_GetAssociatedActor) == 0x000010, "Wrong size on LightProjectile_GetAssociatedActor");
static_assert(offsetof(LightProjectile_GetAssociatedActor, ActorType) == 0x000000, "Member 'LightProjectile_GetAssociatedActor::ActorType' has a wrong offset!");
static_assert(offsetof(LightProjectile_GetAssociatedActor, ReturnValue) == 0x000008, "Member 'LightProjectile_GetAssociatedActor::ReturnValue' has a wrong offset!");

// Function GbxWeapon.LightProjectile.GetAttachedActor
// 0x0008 (0x0008 - 0x0000)
struct LightProjectile_GetAttachedActor final
{
public:
	class AActor*                                 ReturnValue;                                       // 0x0000(0x0008)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(LightProjectile_GetAttachedActor) == 0x000008, "Wrong alignment on LightProjectile_GetAttachedActor");
static_assert(sizeof(LightProjectile_GetAttachedActor) == 0x000008, "Wrong size on LightProjectile_GetAttachedActor");
static_assert(offsetof(LightProjectile_GetAttachedActor, ReturnValue) == 0x000000, "Member 'LightProjectile_GetAttachedActor::ReturnValue' has a wrong offset!");

// Function GbxWeapon.LightProjectile.GetAttachedDamageReceiverActor
// 0x0008 (0x0008 - 0x0000)
struct LightProjectile_GetAttachedDamageReceiverActor final
{
public:
	class AActor*                                 ReturnValue;                                       // 0x0000(0x0008)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(LightProjectile_GetAttachedDamageReceiverActor) == 0x000008, "Wrong alignment on LightProjectile_GetAttachedDamageReceiverActor");
static_assert(sizeof(LightProjectile_GetAttachedDamageReceiverActor) == 0x000008, "Wrong size on LightProjectile_GetAttachedDamageReceiverActor");
static_assert(offsetof(LightProjectile_GetAttachedDamageReceiverActor, ReturnValue) == 0x000000, "Member 'LightProjectile_GetAttachedDamageReceiverActor::ReturnValue' has a wrong offset!");

// Function GbxWeapon.LightProjectile.GetAttachedImpactNormal
// 0x000C (0x000C - 0x0000)
struct LightProjectile_GetAttachedImpactNormal final
{
public:
	struct FVector                                ReturnValue;                                       // 0x0000(0x000C)(Parm, OutParm, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(LightProjectile_GetAttachedImpactNormal) == 0x000004, "Wrong alignment on LightProjectile_GetAttachedImpactNormal");
static_assert(sizeof(LightProjectile_GetAttachedImpactNormal) == 0x00000C, "Wrong size on LightProjectile_GetAttachedImpactNormal");
static_assert(offsetof(LightProjectile_GetAttachedImpactNormal, ReturnValue) == 0x000000, "Member 'LightProjectile_GetAttachedImpactNormal::ReturnValue' has a wrong offset!");

// Function GbxWeapon.LightProjectile.GetAttitudeTowards
// 0x0010 (0x0010 - 0x0000)
struct LightProjectile_GetAttitudeTowards final
{
public:
	class AActor*                                 TargetActor;                                       // 0x0000(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	ETeamAttitude                                 ReturnValue;                                       // 0x0008(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_9[0x7];                                        // 0x0009(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(LightProjectile_GetAttitudeTowards) == 0x000008, "Wrong alignment on LightProjectile_GetAttitudeTowards");
static_assert(sizeof(LightProjectile_GetAttitudeTowards) == 0x000010, "Wrong size on LightProjectile_GetAttitudeTowards");
static_assert(offsetof(LightProjectile_GetAttitudeTowards, TargetActor) == 0x000000, "Member 'LightProjectile_GetAttitudeTowards::TargetActor' has a wrong offset!");
static_assert(offsetof(LightProjectile_GetAttitudeTowards, ReturnValue) == 0x000008, "Member 'LightProjectile_GetAttitudeTowards::ReturnValue' has a wrong offset!");

// Function GbxWeapon.LightProjectile.GetDamageCauser
// 0x0008 (0x0008 - 0x0000)
struct LightProjectile_GetDamageCauser final
{
public:
	class AActor*                                 ReturnValue;                                       // 0x0000(0x0008)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(LightProjectile_GetDamageCauser) == 0x000008, "Wrong alignment on LightProjectile_GetDamageCauser");
static_assert(sizeof(LightProjectile_GetDamageCauser) == 0x000008, "Wrong size on LightProjectile_GetDamageCauser");
static_assert(offsetof(LightProjectile_GetDamageCauser, ReturnValue) == 0x000000, "Member 'LightProjectile_GetDamageCauser::ReturnValue' has a wrong offset!");

// Function GbxWeapon.LightProjectile.GetDamageType
// 0x0008 (0x0008 - 0x0000)
struct LightProjectile_GetDamageType final
{
public:
	const class UGbxDamageType*                   ReturnValue;                                       // 0x0000(0x0008)(ConstParm, Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(LightProjectile_GetDamageType) == 0x000008, "Wrong alignment on LightProjectile_GetDamageType");
static_assert(sizeof(LightProjectile_GetDamageType) == 0x000008, "Wrong size on LightProjectile_GetDamageType");
static_assert(offsetof(LightProjectile_GetDamageType, ReturnValue) == 0x000000, "Member 'LightProjectile_GetDamageType::ReturnValue' has a wrong offset!");

// Function GbxWeapon.LightProjectile.GetFiringPatternID
// 0x0001 (0x0001 - 0x0000)
struct LightProjectile_GetFiringPatternID final
{
public:
	uint8                                         ReturnValue;                                       // 0x0000(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(LightProjectile_GetFiringPatternID) == 0x000001, "Wrong alignment on LightProjectile_GetFiringPatternID");
static_assert(sizeof(LightProjectile_GetFiringPatternID) == 0x000001, "Wrong size on LightProjectile_GetFiringPatternID");
static_assert(offsetof(LightProjectile_GetFiringPatternID, ReturnValue) == 0x000000, "Member 'LightProjectile_GetFiringPatternID::ReturnValue' has a wrong offset!");

// Function GbxWeapon.LightProjectile.GetHomingStartTime
// 0x0004 (0x0004 - 0x0000)
struct LightProjectile_GetHomingStartTime final
{
public:
	float                                         ReturnValue;                                       // 0x0000(0x0004)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(LightProjectile_GetHomingStartTime) == 0x000004, "Wrong alignment on LightProjectile_GetHomingStartTime");
static_assert(sizeof(LightProjectile_GetHomingStartTime) == 0x000004, "Wrong size on LightProjectile_GetHomingStartTime");
static_assert(offsetof(LightProjectile_GetHomingStartTime, ReturnValue) == 0x000000, "Member 'LightProjectile_GetHomingStartTime::ReturnValue' has a wrong offset!");

// Function GbxWeapon.LightProjectile.GetImpactData
// 0x0008 (0x0008 - 0x0000)
struct LightProjectile_GetImpactData final
{
public:
	class UImpactData*                            ReturnValue;                                       // 0x0000(0x0008)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(LightProjectile_GetImpactData) == 0x000008, "Wrong alignment on LightProjectile_GetImpactData");
static_assert(sizeof(LightProjectile_GetImpactData) == 0x000008, "Wrong size on LightProjectile_GetImpactData");
static_assert(offsetof(LightProjectile_GetImpactData, ReturnValue) == 0x000000, "Member 'LightProjectile_GetImpactData::ReturnValue' has a wrong offset!");

// Function GbxWeapon.LightProjectile.GetImpactDataOverride
// 0x0008 (0x0008 - 0x0000)
struct LightProjectile_GetImpactDataOverride final
{
public:
	class UImpactData*                            ReturnValue;                                       // 0x0000(0x0008)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(LightProjectile_GetImpactDataOverride) == 0x000008, "Wrong alignment on LightProjectile_GetImpactDataOverride");
static_assert(sizeof(LightProjectile_GetImpactDataOverride) == 0x000008, "Wrong size on LightProjectile_GetImpactDataOverride");
static_assert(offsetof(LightProjectile_GetImpactDataOverride, ReturnValue) == 0x000000, "Member 'LightProjectile_GetImpactDataOverride::ReturnValue' has a wrong offset!");

// Function GbxWeapon.LightProjectile.GetInstigator
// 0x0008 (0x0008 - 0x0000)
struct LightProjectile_GetInstigator final
{
public:
	class APawn*                                  ReturnValue;                                       // 0x0000(0x0008)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(LightProjectile_GetInstigator) == 0x000008, "Wrong alignment on LightProjectile_GetInstigator");
static_assert(sizeof(LightProjectile_GetInstigator) == 0x000008, "Wrong size on LightProjectile_GetInstigator");
static_assert(offsetof(LightProjectile_GetInstigator, ReturnValue) == 0x000000, "Member 'LightProjectile_GetInstigator::ReturnValue' has a wrong offset!");

// Function GbxWeapon.LightProjectile.GetModifierType
// 0x0001 (0x0001 - 0x0000)
struct LightProjectile_GetModifierType final
{
public:
	EWeaponShotModifierType                       ReturnValue;                                       // 0x0000(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(LightProjectile_GetModifierType) == 0x000001, "Wrong alignment on LightProjectile_GetModifierType");
static_assert(sizeof(LightProjectile_GetModifierType) == 0x000001, "Wrong size on LightProjectile_GetModifierType");
static_assert(offsetof(LightProjectile_GetModifierType, ReturnValue) == 0x000000, "Member 'LightProjectile_GetModifierType::ReturnValue' has a wrong offset!");

// Function GbxWeapon.LightProjectile.GetModifierValue
// 0x0004 (0x0004 - 0x0000)
struct LightProjectile_GetModifierValue final
{
public:
	float                                         ReturnValue;                                       // 0x0000(0x0004)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(LightProjectile_GetModifierValue) == 0x000004, "Wrong alignment on LightProjectile_GetModifierValue");
static_assert(sizeof(LightProjectile_GetModifierValue) == 0x000004, "Wrong size on LightProjectile_GetModifierValue");
static_assert(offsetof(LightProjectile_GetModifierValue, ReturnValue) == 0x000000, "Member 'LightProjectile_GetModifierValue::ReturnValue' has a wrong offset!");

// Function GbxWeapon.LightProjectile.GetSource
// 0x0008 (0x0008 - 0x0000)
struct LightProjectile_GetSource final
{
public:
	class AActor*                                 ReturnValue;                                       // 0x0000(0x0008)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(LightProjectile_GetSource) == 0x000008, "Wrong alignment on LightProjectile_GetSource");
static_assert(sizeof(LightProjectile_GetSource) == 0x000008, "Wrong size on LightProjectile_GetSource");
static_assert(offsetof(LightProjectile_GetSource, ReturnValue) == 0x000000, "Member 'LightProjectile_GetSource::ReturnValue' has a wrong offset!");

// Function GbxWeapon.LightProjectile.GetTarget
// 0x0008 (0x0008 - 0x0000)
struct LightProjectile_GetTarget final
{
public:
	class AActor*                                 ReturnValue;                                       // 0x0000(0x0008)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(LightProjectile_GetTarget) == 0x000008, "Wrong alignment on LightProjectile_GetTarget");
static_assert(sizeof(LightProjectile_GetTarget) == 0x000008, "Wrong size on LightProjectile_GetTarget");
static_assert(offsetof(LightProjectile_GetTarget, ReturnValue) == 0x000000, "Member 'LightProjectile_GetTarget::ReturnValue' has a wrong offset!");

// Function GbxWeapon.LightProjectile.InitChildData
// 0x0140 (0x0140 - 0x0000)
struct LightProjectile_InitChildData final
{
public:
	struct FLightProjectileInitializationData     InitData;                                          // 0x0000(0x0140)(Parm, OutParm, ContainsInstancedReference, NativeAccessSpecifierPublic)
};
static_assert(alignof(LightProjectile_InitChildData) == 0x000008, "Wrong alignment on LightProjectile_InitChildData");
static_assert(sizeof(LightProjectile_InitChildData) == 0x000140, "Wrong size on LightProjectile_InitChildData");
static_assert(offsetof(LightProjectile_InitChildData, InitData) == 0x000000, "Member 'LightProjectile_InitChildData::InitData' has a wrong offset!");

// Function GbxWeapon.LightProjectile.IsHoming
// 0x0001 (0x0001 - 0x0000)
struct LightProjectile_IsHoming final
{
public:
	bool                                          ReturnValue;                                       // 0x0000(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(LightProjectile_IsHoming) == 0x000001, "Wrong alignment on LightProjectile_IsHoming");
static_assert(sizeof(LightProjectile_IsHoming) == 0x000001, "Wrong size on LightProjectile_IsHoming");
static_assert(offsetof(LightProjectile_IsHoming, ReturnValue) == 0x000000, "Member 'LightProjectile_IsHoming::ReturnValue' has a wrong offset!");

// Function GbxWeapon.LightProjectile.IsHomingMovingDirectlyTowardsTarget
// 0x0001 (0x0001 - 0x0000)
struct LightProjectile_IsHomingMovingDirectlyTowardsTarget final
{
public:
	bool                                          ReturnValue;                                       // 0x0000(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(LightProjectile_IsHomingMovingDirectlyTowardsTarget) == 0x000001, "Wrong alignment on LightProjectile_IsHomingMovingDirectlyTowardsTarget");
static_assert(sizeof(LightProjectile_IsHomingMovingDirectlyTowardsTarget) == 0x000001, "Wrong size on LightProjectile_IsHomingMovingDirectlyTowardsTarget");
static_assert(offsetof(LightProjectile_IsHomingMovingDirectlyTowardsTarget, ReturnValue) == 0x000000, "Member 'LightProjectile_IsHomingMovingDirectlyTowardsTarget::ReturnValue' has a wrong offset!");

// Function GbxWeapon.LightProjectile.PlayFeedbackSoundEvent
// 0x0008 (0x0008 - 0x0000)
struct LightProjectile_PlayFeedbackSoundEvent final
{
public:
	class UWwiseEvent*                            Event;                                             // 0x0000(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(LightProjectile_PlayFeedbackSoundEvent) == 0x000008, "Wrong alignment on LightProjectile_PlayFeedbackSoundEvent");
static_assert(sizeof(LightProjectile_PlayFeedbackSoundEvent) == 0x000008, "Wrong size on LightProjectile_PlayFeedbackSoundEvent");
static_assert(offsetof(LightProjectile_PlayFeedbackSoundEvent, Event) == 0x000000, "Member 'LightProjectile_PlayFeedbackSoundEvent::Event' has a wrong offset!");

// Function GbxWeapon.LightProjectileData.GetTimedEventNameList
// 0x0010 (0x0010 - 0x0000)
struct LightProjectileData_GetTimedEventNameList final
{
public:
	TArray<class FName>                           FuncList;                                          // 0x0000(0x0010)(Parm, OutParm, ZeroConstructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(LightProjectileData_GetTimedEventNameList) == 0x000008, "Wrong alignment on LightProjectileData_GetTimedEventNameList");
static_assert(sizeof(LightProjectileData_GetTimedEventNameList) == 0x000010, "Wrong size on LightProjectileData_GetTimedEventNameList");
static_assert(offsetof(LightProjectileData_GetTimedEventNameList, FuncList) == 0x000000, "Member 'LightProjectileData_GetTimedEventNameList::FuncList' has a wrong offset!");

// Function GbxWeapon.LightProjectileData.OnAttached
// 0x0010 (0x0010 - 0x0000)
struct LightProjectileData_OnAttached final
{
public:
	class ULightProjectile*                       Projectile;                                        // 0x0000(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class AActor*                                 AttachedActor;                                     // 0x0008(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(LightProjectileData_OnAttached) == 0x000008, "Wrong alignment on LightProjectileData_OnAttached");
static_assert(sizeof(LightProjectileData_OnAttached) == 0x000010, "Wrong size on LightProjectileData_OnAttached");
static_assert(offsetof(LightProjectileData_OnAttached, Projectile) == 0x000000, "Member 'LightProjectileData_OnAttached::Projectile' has a wrong offset!");
static_assert(offsetof(LightProjectileData_OnAttached, AttachedActor) == 0x000008, "Member 'LightProjectileData_OnAttached::AttachedActor' has a wrong offset!");

// Function GbxWeapon.LightProjectileData.OnBegin
// 0x0008 (0x0008 - 0x0000)
struct LightProjectileData_OnBegin final
{
public:
	class ULightProjectile*                       Projectile;                                        // 0x0000(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(LightProjectileData_OnBegin) == 0x000008, "Wrong alignment on LightProjectileData_OnBegin");
static_assert(sizeof(LightProjectileData_OnBegin) == 0x000008, "Wrong size on LightProjectileData_OnBegin");
static_assert(offsetof(LightProjectileData_OnBegin, Projectile) == 0x000000, "Member 'LightProjectileData_OnBegin::Projectile' has a wrong offset!");

// Function GbxWeapon.LightProjectileData.OnDamage
// 0x00A0 (0x00A0 - 0x0000)
struct LightProjectileData_OnDamage final
{
public:
	class ULightProjectile*                       Projectile;                                        // 0x0000(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FHitResult                             Hit;                                               // 0x0008(0x0090)(ConstParm, Parm, OutParm, ReferenceParm, IsPlainOldData, NoDestructor, ContainsInstancedReference, NativeAccessSpecifierPublic)
	bool                                          bCritical;                                         // 0x0098(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_99[0x7];                                       // 0x0099(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(LightProjectileData_OnDamage) == 0x000008, "Wrong alignment on LightProjectileData_OnDamage");
static_assert(sizeof(LightProjectileData_OnDamage) == 0x0000A0, "Wrong size on LightProjectileData_OnDamage");
static_assert(offsetof(LightProjectileData_OnDamage, Projectile) == 0x000000, "Member 'LightProjectileData_OnDamage::Projectile' has a wrong offset!");
static_assert(offsetof(LightProjectileData_OnDamage, Hit) == 0x000008, "Member 'LightProjectileData_OnDamage::Hit' has a wrong offset!");
static_assert(offsetof(LightProjectileData_OnDamage, bCritical) == 0x000098, "Member 'LightProjectileData_OnDamage::bCritical' has a wrong offset!");

// Function GbxWeapon.LightProjectileData.OnExplode
// 0x0008 (0x0008 - 0x0000)
struct LightProjectileData_OnExplode final
{
public:
	class ULightProjectile*                       Projectile;                                        // 0x0000(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(LightProjectileData_OnExplode) == 0x000008, "Wrong alignment on LightProjectileData_OnExplode");
static_assert(sizeof(LightProjectileData_OnExplode) == 0x000008, "Wrong size on LightProjectileData_OnExplode");
static_assert(offsetof(LightProjectileData_OnExplode, Projectile) == 0x000000, "Member 'LightProjectileData_OnExplode::Projectile' has a wrong offset!");

// Function GbxWeapon.LightProjectileData.OnImpact
// 0x0098 (0x0098 - 0x0000)
struct LightProjectileData_OnImpact final
{
public:
	class ULightProjectile*                       Projectile;                                        // 0x0000(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FHitResult                             Hit;                                               // 0x0008(0x0090)(ConstParm, Parm, OutParm, ReferenceParm, IsPlainOldData, NoDestructor, ContainsInstancedReference, NativeAccessSpecifierPublic)
};
static_assert(alignof(LightProjectileData_OnImpact) == 0x000008, "Wrong alignment on LightProjectileData_OnImpact");
static_assert(sizeof(LightProjectileData_OnImpact) == 0x000098, "Wrong size on LightProjectileData_OnImpact");
static_assert(offsetof(LightProjectileData_OnImpact, Projectile) == 0x000000, "Member 'LightProjectileData_OnImpact::Projectile' has a wrong offset!");
static_assert(offsetof(LightProjectileData_OnImpact, Hit) == 0x000008, "Member 'LightProjectileData_OnImpact::Hit' has a wrong offset!");

// Function GbxWeapon.LightProjectileData.OnLifetimeExpired
// 0x0008 (0x0008 - 0x0000)
struct LightProjectileData_OnLifetimeExpired final
{
public:
	class ULightProjectile*                       Projectile;                                        // 0x0000(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(LightProjectileData_OnLifetimeExpired) == 0x000008, "Wrong alignment on LightProjectileData_OnLifetimeExpired");
static_assert(sizeof(LightProjectileData_OnLifetimeExpired) == 0x000008, "Wrong size on LightProjectileData_OnLifetimeExpired");
static_assert(offsetof(LightProjectileData_OnLifetimeExpired, Projectile) == 0x000000, "Member 'LightProjectileData_OnLifetimeExpired::Projectile' has a wrong offset!");

// Function GbxWeapon.LightProjectileData.OnProxyImpact
// 0x0098 (0x0098 - 0x0000)
struct LightProjectileData_OnProxyImpact final
{
public:
	class ULightProjectile*                       Projectile;                                        // 0x0000(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FHitResult                             Hit;                                               // 0x0008(0x0090)(ConstParm, Parm, OutParm, ReferenceParm, IsPlainOldData, NoDestructor, ContainsInstancedReference, NativeAccessSpecifierPublic)
};
static_assert(alignof(LightProjectileData_OnProxyImpact) == 0x000008, "Wrong alignment on LightProjectileData_OnProxyImpact");
static_assert(sizeof(LightProjectileData_OnProxyImpact) == 0x000098, "Wrong size on LightProjectileData_OnProxyImpact");
static_assert(offsetof(LightProjectileData_OnProxyImpact, Projectile) == 0x000000, "Member 'LightProjectileData_OnProxyImpact::Projectile' has a wrong offset!");
static_assert(offsetof(LightProjectileData_OnProxyImpact, Hit) == 0x000008, "Member 'LightProjectileData_OnProxyImpact::Hit' has a wrong offset!");

// Function GbxWeapon.LightProjectileData.OnRicochet
// 0x00A8 (0x00A8 - 0x0000)
struct LightProjectileData_OnRicochet final
{
public:
	class ULightProjectile*                       Projectile;                                        // 0x0000(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FHitResult                             Hit;                                               // 0x0008(0x0090)(ConstParm, Parm, OutParm, ReferenceParm, IsPlainOldData, NoDestructor, ContainsInstancedReference, NativeAccessSpecifierPublic)
	struct FVector                                ImpactVelocity;                                    // 0x0098(0x000C)(ConstParm, Parm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_A4[0x4];                                       // 0x00A4(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(LightProjectileData_OnRicochet) == 0x000008, "Wrong alignment on LightProjectileData_OnRicochet");
static_assert(sizeof(LightProjectileData_OnRicochet) == 0x0000A8, "Wrong size on LightProjectileData_OnRicochet");
static_assert(offsetof(LightProjectileData_OnRicochet, Projectile) == 0x000000, "Member 'LightProjectileData_OnRicochet::Projectile' has a wrong offset!");
static_assert(offsetof(LightProjectileData_OnRicochet, Hit) == 0x000008, "Member 'LightProjectileData_OnRicochet::Hit' has a wrong offset!");
static_assert(offsetof(LightProjectileData_OnRicochet, ImpactVelocity) == 0x000098, "Member 'LightProjectileData_OnRicochet::ImpactVelocity' has a wrong offset!");

// Function GbxWeapon.LightBeamManager.OnParticleSystemFinished
// 0x0008 (0x0008 - 0x0000)
struct LightBeamManager_OnParticleSystemFinished final
{
public:
	class UParticleSystemComponent*               FinishedComponent;                                 // 0x0000(0x0008)(Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(LightBeamManager_OnParticleSystemFinished) == 0x000008, "Wrong alignment on LightBeamManager_OnParticleSystemFinished");
static_assert(sizeof(LightBeamManager_OnParticleSystemFinished) == 0x000008, "Wrong size on LightBeamManager_OnParticleSystemFinished");
static_assert(offsetof(LightBeamManager_OnParticleSystemFinished, FinishedComponent) == 0x000000, "Member 'LightBeamManager_OnParticleSystemFinished::FinishedComponent' has a wrong offset!");

// Function GbxWeapon.LightBeam.LockOntoTarget
// 0x0028 (0x0028 - 0x0000)
struct LightBeam_LockOntoTarget final
{
public:
	struct FLightBeamAttachment                   Target;                                            // 0x0000(0x0028)(ConstParm, Parm, OutParm, ReferenceParm, NoDestructor, ContainsInstancedReference, NativeAccessSpecifierPublic)
};
static_assert(alignof(LightBeam_LockOntoTarget) == 0x000008, "Wrong alignment on LightBeam_LockOntoTarget");
static_assert(sizeof(LightBeam_LockOntoTarget) == 0x000028, "Wrong size on LightBeam_LockOntoTarget");
static_assert(offsetof(LightBeam_LockOntoTarget, Target) == 0x000000, "Member 'LightBeam_LockOntoTarget::Target' has a wrong offset!");

// Function GbxWeapon.LightBeam.OnTrackedImpactParticleSystemFinished
// 0x0008 (0x0008 - 0x0000)
struct LightBeam_OnTrackedImpactParticleSystemFinished final
{
public:
	class UParticleSystemComponent*               PSC;                                               // 0x0000(0x0008)(Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(LightBeam_OnTrackedImpactParticleSystemFinished) == 0x000008, "Wrong alignment on LightBeam_OnTrackedImpactParticleSystemFinished");
static_assert(sizeof(LightBeam_OnTrackedImpactParticleSystemFinished) == 0x000008, "Wrong size on LightBeam_OnTrackedImpactParticleSystemFinished");
static_assert(offsetof(LightBeam_OnTrackedImpactParticleSystemFinished, PSC) == 0x000000, "Member 'LightBeam_OnTrackedImpactParticleSystemFinished::PSC' has a wrong offset!");

// Function GbxWeapon.LightBeam.SetTargetSocket
// 0x0008 (0x0008 - 0x0000)
struct LightBeam_SetTargetSocket final
{
public:
	class FName                                   Socket;                                            // 0x0000(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(LightBeam_SetTargetSocket) == 0x000004, "Wrong alignment on LightBeam_SetTargetSocket");
static_assert(sizeof(LightBeam_SetTargetSocket) == 0x000008, "Wrong size on LightBeam_SetTargetSocket");
static_assert(offsetof(LightBeam_SetTargetSocket, Socket) == 0x000000, "Member 'LightBeam_SetTargetSocket::Socket' has a wrong offset!");

// Function GbxWeapon.LightBeam.GetAssociatedActor
// 0x0010 (0x0010 - 0x0000)
struct LightBeam_GetAssociatedActor final
{
public:
	ELightBeamQueryActorType                      ActorType;                                         // 0x0000(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1[0x7];                                        // 0x0001(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	class AActor*                                 ReturnValue;                                       // 0x0008(0x0008)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(LightBeam_GetAssociatedActor) == 0x000008, "Wrong alignment on LightBeam_GetAssociatedActor");
static_assert(sizeof(LightBeam_GetAssociatedActor) == 0x000010, "Wrong size on LightBeam_GetAssociatedActor");
static_assert(offsetof(LightBeam_GetAssociatedActor, ActorType) == 0x000000, "Member 'LightBeam_GetAssociatedActor::ActorType' has a wrong offset!");
static_assert(offsetof(LightBeam_GetAssociatedActor, ReturnValue) == 0x000008, "Member 'LightBeam_GetAssociatedActor::ReturnValue' has a wrong offset!");

// Function GbxWeapon.LightBeam.GetDamage
// 0x0004 (0x0004 - 0x0000)
struct LightBeam_GetDamage final
{
public:
	float                                         ReturnValue;                                       // 0x0000(0x0004)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(LightBeam_GetDamage) == 0x000004, "Wrong alignment on LightBeam_GetDamage");
static_assert(sizeof(LightBeam_GetDamage) == 0x000004, "Wrong size on LightBeam_GetDamage");
static_assert(offsetof(LightBeam_GetDamage, ReturnValue) == 0x000000, "Member 'LightBeam_GetDamage::ReturnValue' has a wrong offset!");

// Function GbxWeapon.LightBeam.GetDamageCauser
// 0x0008 (0x0008 - 0x0000)
struct LightBeam_GetDamageCauser final
{
public:
	class AActor*                                 ReturnValue;                                       // 0x0000(0x0008)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(LightBeam_GetDamageCauser) == 0x000008, "Wrong alignment on LightBeam_GetDamageCauser");
static_assert(sizeof(LightBeam_GetDamageCauser) == 0x000008, "Wrong size on LightBeam_GetDamageCauser");
static_assert(offsetof(LightBeam_GetDamageCauser, ReturnValue) == 0x000000, "Member 'LightBeam_GetDamageCauser::ReturnValue' has a wrong offset!");

// Function GbxWeapon.LightBeam.GetDamageType
// 0x0008 (0x0008 - 0x0000)
struct LightBeam_GetDamageType final
{
public:
	const class UGbxDamageType*                   ReturnValue;                                       // 0x0000(0x0008)(ConstParm, Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(LightBeam_GetDamageType) == 0x000008, "Wrong alignment on LightBeam_GetDamageType");
static_assert(sizeof(LightBeam_GetDamageType) == 0x000008, "Wrong size on LightBeam_GetDamageType");
static_assert(offsetof(LightBeam_GetDamageType, ReturnValue) == 0x000000, "Member 'LightBeam_GetDamageType::ReturnValue' has a wrong offset!");

// Function GbxWeapon.LightBeam.GetImpactForce
// 0x0004 (0x0004 - 0x0000)
struct LightBeam_GetImpactForce final
{
public:
	float                                         ReturnValue;                                       // 0x0000(0x0004)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(LightBeam_GetImpactForce) == 0x000004, "Wrong alignment on LightBeam_GetImpactForce");
static_assert(sizeof(LightBeam_GetImpactForce) == 0x000004, "Wrong size on LightBeam_GetImpactForce");
static_assert(offsetof(LightBeam_GetImpactForce, ReturnValue) == 0x000000, "Member 'LightBeam_GetImpactForce::ReturnValue' has a wrong offset!");

// Function GbxWeapon.LightBeam.GetInstigator
// 0x0008 (0x0008 - 0x0000)
struct LightBeam_GetInstigator final
{
public:
	class APawn*                                  ReturnValue;                                       // 0x0000(0x0008)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(LightBeam_GetInstigator) == 0x000008, "Wrong alignment on LightBeam_GetInstigator");
static_assert(sizeof(LightBeam_GetInstigator) == 0x000008, "Wrong size on LightBeam_GetInstigator");
static_assert(offsetof(LightBeam_GetInstigator, ReturnValue) == 0x000000, "Member 'LightBeam_GetInstigator::ReturnValue' has a wrong offset!");

// Function GbxWeapon.LightBeam.GetSource
// 0x0028 (0x0028 - 0x0000)
struct LightBeam_GetSource final
{
public:
	struct FLightBeamAttachment                   ReturnValue;                                       // 0x0000(0x0028)(ConstParm, Parm, OutParm, ReturnParm, ReferenceParm, NoDestructor, ContainsInstancedReference, NativeAccessSpecifierPublic)
};
static_assert(alignof(LightBeam_GetSource) == 0x000008, "Wrong alignment on LightBeam_GetSource");
static_assert(sizeof(LightBeam_GetSource) == 0x000028, "Wrong size on LightBeam_GetSource");
static_assert(offsetof(LightBeam_GetSource, ReturnValue) == 0x000000, "Member 'LightBeam_GetSource::ReturnValue' has a wrong offset!");

// Function GbxWeapon.LightBeam.GetSourceActor
// 0x0008 (0x0008 - 0x0000)
struct LightBeam_GetSourceActor final
{
public:
	class AActor*                                 ReturnValue;                                       // 0x0000(0x0008)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(LightBeam_GetSourceActor) == 0x000008, "Wrong alignment on LightBeam_GetSourceActor");
static_assert(sizeof(LightBeam_GetSourceActor) == 0x000008, "Wrong size on LightBeam_GetSourceActor");
static_assert(offsetof(LightBeam_GetSourceActor, ReturnValue) == 0x000000, "Member 'LightBeam_GetSourceActor::ReturnValue' has a wrong offset!");

// Function GbxWeapon.LightBeam.GetTarget
// 0x0028 (0x0028 - 0x0000)
struct LightBeam_GetTarget final
{
public:
	struct FLightBeamAttachment                   ReturnValue;                                       // 0x0000(0x0028)(ConstParm, Parm, OutParm, ReturnParm, ReferenceParm, NoDestructor, ContainsInstancedReference, NativeAccessSpecifierPublic)
};
static_assert(alignof(LightBeam_GetTarget) == 0x000008, "Wrong alignment on LightBeam_GetTarget");
static_assert(sizeof(LightBeam_GetTarget) == 0x000028, "Wrong size on LightBeam_GetTarget");
static_assert(offsetof(LightBeam_GetTarget, ReturnValue) == 0x000000, "Member 'LightBeam_GetTarget::ReturnValue' has a wrong offset!");

// Function GbxWeapon.LightBeam.GetTargetActor
// 0x0008 (0x0008 - 0x0000)
struct LightBeam_GetTargetActor final
{
public:
	class AActor*                                 ReturnValue;                                       // 0x0000(0x0008)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(LightBeam_GetTargetActor) == 0x000008, "Wrong alignment on LightBeam_GetTargetActor");
static_assert(sizeof(LightBeam_GetTargetActor) == 0x000008, "Wrong size on LightBeam_GetTargetActor");
static_assert(offsetof(LightBeam_GetTargetActor, ReturnValue) == 0x000000, "Member 'LightBeam_GetTargetActor::ReturnValue' has a wrong offset!");

// Function GbxWeapon.LightBeam.InitChildData
// 0x0128 (0x0128 - 0x0000)
struct LightBeam_InitChildData final
{
public:
	struct FLightBeamInitializationData           InitData;                                          // 0x0000(0x0128)(Parm, OutParm, ContainsInstancedReference, NativeAccessSpecifierPublic)
};
static_assert(alignof(LightBeam_InitChildData) == 0x000008, "Wrong alignment on LightBeam_InitChildData");
static_assert(sizeof(LightBeam_InitChildData) == 0x000128, "Wrong size on LightBeam_InitChildData");
static_assert(offsetof(LightBeam_InitChildData, InitData) == 0x000000, "Member 'LightBeam_InitChildData::InitData' has a wrong offset!");

// Function GbxWeapon.LightBeamData.CanLockOn
// 0x0018 (0x0018 - 0x0000)
struct LightBeamData_CanLockOn final
{
public:
	class ULightBeam*                             Beam;                                              // 0x0000(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class AActor*                                 TargetActor;                                       // 0x0008(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          ReturnValue;                                       // 0x0010(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_11[0x7];                                       // 0x0011(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(LightBeamData_CanLockOn) == 0x000008, "Wrong alignment on LightBeamData_CanLockOn");
static_assert(sizeof(LightBeamData_CanLockOn) == 0x000018, "Wrong size on LightBeamData_CanLockOn");
static_assert(offsetof(LightBeamData_CanLockOn, Beam) == 0x000000, "Member 'LightBeamData_CanLockOn::Beam' has a wrong offset!");
static_assert(offsetof(LightBeamData_CanLockOn, TargetActor) == 0x000008, "Member 'LightBeamData_CanLockOn::TargetActor' has a wrong offset!");
static_assert(offsetof(LightBeamData_CanLockOn, ReturnValue) == 0x000010, "Member 'LightBeamData_CanLockOn::ReturnValue' has a wrong offset!");

// Function GbxWeapon.LightBeamData.UpdateTarget
// 0x0010 (0x0010 - 0x0000)
struct LightBeamData_UpdateTarget final
{
public:
	class ULightBeam*                             Beam;                                              // 0x0000(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         ReturnValue;                                       // 0x0008(0x0004)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_C[0x4];                                        // 0x000C(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(LightBeamData_UpdateTarget) == 0x000008, "Wrong alignment on LightBeamData_UpdateTarget");
static_assert(sizeof(LightBeamData_UpdateTarget) == 0x000010, "Wrong size on LightBeamData_UpdateTarget");
static_assert(offsetof(LightBeamData_UpdateTarget, Beam) == 0x000000, "Member 'LightBeamData_UpdateTarget::Beam' has a wrong offset!");
static_assert(offsetof(LightBeamData_UpdateTarget, ReturnValue) == 0x000008, "Member 'LightBeamData_UpdateTarget::ReturnValue' has a wrong offset!");

// Function GbxWeapon.WeaponAttachmentSlot.SetMesh
// 0x0008 (0x0008 - 0x0000)
struct WeaponAttachmentSlot_SetMesh final
{
public:
	class UMeshComponent*                         InMesh;                                            // 0x0000(0x0008)(Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(WeaponAttachmentSlot_SetMesh) == 0x000008, "Wrong alignment on WeaponAttachmentSlot_SetMesh");
static_assert(sizeof(WeaponAttachmentSlot_SetMesh) == 0x000008, "Wrong size on WeaponAttachmentSlot_SetMesh");
static_assert(offsetof(WeaponAttachmentSlot_SetMesh, InMesh) == 0x000000, "Member 'WeaponAttachmentSlot_SetMesh::InMesh' has a wrong offset!");

// Function GbxWeapon.WeaponAnimInstance.BlueprintSwitchedMode
// 0x0004 (0x0004 - 0x0000)
struct WeaponAnimInstance_BlueprintSwitchedMode final
{
public:
	int32                                         NewMode;                                           // 0x0000(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(WeaponAnimInstance_BlueprintSwitchedMode) == 0x000004, "Wrong alignment on WeaponAnimInstance_BlueprintSwitchedMode");
static_assert(sizeof(WeaponAnimInstance_BlueprintSwitchedMode) == 0x000004, "Wrong size on WeaponAnimInstance_BlueprintSwitchedMode");
static_assert(offsetof(WeaponAnimInstance_BlueprintSwitchedMode, NewMode) == 0x000000, "Member 'WeaponAnimInstance_BlueprintSwitchedMode::NewMode' has a wrong offset!");

// Function GbxWeapon.WeaponAmmoComponent.ClientRefillAmmo
// 0x0004 (0x0004 - 0x0000)
struct WeaponAmmoComponent_ClientRefillAmmo final
{
public:
	int32                                         Amount;                                            // 0x0000(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(WeaponAmmoComponent_ClientRefillAmmo) == 0x000004, "Wrong alignment on WeaponAmmoComponent_ClientRefillAmmo");
static_assert(sizeof(WeaponAmmoComponent_ClientRefillAmmo) == 0x000004, "Wrong size on WeaponAmmoComponent_ClientRefillAmmo");
static_assert(offsetof(WeaponAmmoComponent_ClientRefillAmmo, Amount) == 0x000000, "Member 'WeaponAmmoComponent_ClientRefillAmmo::Amount' has a wrong offset!");

// Function GbxWeapon.WeaponZoomComponent.GetMaxZoomFOVScale
// 0x0004 (0x0004 - 0x0000)
struct WeaponZoomComponent_GetMaxZoomFOVScale final
{
public:
	float                                         ReturnValue;                                       // 0x0000(0x0004)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(WeaponZoomComponent_GetMaxZoomFOVScale) == 0x000004, "Wrong alignment on WeaponZoomComponent_GetMaxZoomFOVScale");
static_assert(sizeof(WeaponZoomComponent_GetMaxZoomFOVScale) == 0x000004, "Wrong size on WeaponZoomComponent_GetMaxZoomFOVScale");
static_assert(offsetof(WeaponZoomComponent_GetMaxZoomFOVScale, ReturnValue) == 0x000000, "Member 'WeaponZoomComponent_GetMaxZoomFOVScale::ReturnValue' has a wrong offset!");

// Function GbxWeapon.WeaponZoomComponent.GetMaxZoomFOVScaleWithMode
// 0x0008 (0x0008 - 0x0000)
struct WeaponZoomComponent_GetMaxZoomFOVScaleWithMode final
{
public:
	uint8                                         ModeIndex;                                         // 0x0000(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1[0x3];                                        // 0x0001(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         ReturnValue;                                       // 0x0004(0x0004)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(WeaponZoomComponent_GetMaxZoomFOVScaleWithMode) == 0x000004, "Wrong alignment on WeaponZoomComponent_GetMaxZoomFOVScaleWithMode");
static_assert(sizeof(WeaponZoomComponent_GetMaxZoomFOVScaleWithMode) == 0x000008, "Wrong size on WeaponZoomComponent_GetMaxZoomFOVScaleWithMode");
static_assert(offsetof(WeaponZoomComponent_GetMaxZoomFOVScaleWithMode, ModeIndex) == 0x000000, "Member 'WeaponZoomComponent_GetMaxZoomFOVScaleWithMode::ModeIndex' has a wrong offset!");
static_assert(offsetof(WeaponZoomComponent_GetMaxZoomFOVScaleWithMode, ReturnValue) == 0x000004, "Member 'WeaponZoomComponent_GetMaxZoomFOVScaleWithMode::ReturnValue' has a wrong offset!");

// Function GbxWeapon.GbxTrajectometerComponent.SetTrajectometerEnabled
// 0x0001 (0x0001 - 0x0000)
struct GbxTrajectometerComponent_SetTrajectometerEnabled final
{
public:
	bool                                          bEnabled;                                          // 0x0000(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(GbxTrajectometerComponent_SetTrajectometerEnabled) == 0x000001, "Wrong alignment on GbxTrajectometerComponent_SetTrajectometerEnabled");
static_assert(sizeof(GbxTrajectometerComponent_SetTrajectometerEnabled) == 0x000001, "Wrong size on GbxTrajectometerComponent_SetTrajectometerEnabled");
static_assert(offsetof(GbxTrajectometerComponent_SetTrajectometerEnabled, bEnabled) == 0x000000, "Member 'GbxTrajectometerComponent_SetTrajectometerEnabled::bEnabled' has a wrong offset!");

// DelegateFunction GbxWeapon.GbxTrajectometerComponent.SimulationResultEvent__DelegateSignature
// 0x0090 (0x0090 - 0x0000)
struct GbxTrajectometerComponent_SimulationResultEvent__DelegateSignature final
{
public:
	struct FHitResult                             HitResult;                                         // 0x0000(0x0090)(ConstParm, Parm, OutParm, ReferenceParm, IsPlainOldData, NoDestructor, ContainsInstancedReference, NativeAccessSpecifierPublic)
};
static_assert(alignof(GbxTrajectometerComponent_SimulationResultEvent__DelegateSignature) == 0x000008, "Wrong alignment on GbxTrajectometerComponent_SimulationResultEvent__DelegateSignature");
static_assert(sizeof(GbxTrajectometerComponent_SimulationResultEvent__DelegateSignature) == 0x000090, "Wrong size on GbxTrajectometerComponent_SimulationResultEvent__DelegateSignature");
static_assert(offsetof(GbxTrajectometerComponent_SimulationResultEvent__DelegateSignature, HitResult) == 0x000000, "Member 'GbxTrajectometerComponent_SimulationResultEvent__DelegateSignature::HitResult' has a wrong offset!");

// Function GbxWeapon.LightBeamStatics.ClearBeamFlag
// 0x0130 (0x0130 - 0x0000)
struct LightBeamStatics_ClearBeamFlag final
{
public:
	struct FLightBeamInitializationData           InitData;                                          // 0x0000(0x0128)(Parm, OutParm, ReferenceParm, ContainsInstancedReference, NativeAccessSpecifierPublic)
	ELightBeamFlag                                Flag;                                              // 0x0128(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_129[0x7];                                      // 0x0129(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(LightBeamStatics_ClearBeamFlag) == 0x000008, "Wrong alignment on LightBeamStatics_ClearBeamFlag");
static_assert(sizeof(LightBeamStatics_ClearBeamFlag) == 0x000130, "Wrong size on LightBeamStatics_ClearBeamFlag");
static_assert(offsetof(LightBeamStatics_ClearBeamFlag, InitData) == 0x000000, "Member 'LightBeamStatics_ClearBeamFlag::InitData' has a wrong offset!");
static_assert(offsetof(LightBeamStatics_ClearBeamFlag, Flag) == 0x000128, "Member 'LightBeamStatics_ClearBeamFlag::Flag' has a wrong offset!");

// Function GbxWeapon.LightBeamStatics.CreateLightBeam
// 0x00C8 (0x00C8 - 0x0000)
struct LightBeamStatics_CreateLightBeam final
{
public:
	TSubclassOf<class ULightBeamData>             Data;                                              // 0x0000(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class APawn*                                  Instigator;                                        // 0x0008(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FLightBeamAttachment                   Source;                                            // 0x0010(0x0028)(ConstParm, Parm, OutParm, ReferenceParm, NoDestructor, ContainsInstancedReference, NativeAccessSpecifierPublic)
	struct FLightBeamAttachment                   Target;                                            // 0x0038(0x0028)(Parm, NoDestructor, ContainsInstancedReference, NativeAccessSpecifierPublic)
	bool                                          bTargetLocked;                                     // 0x0060(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_61[0x7];                                       // 0x0061(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	class FName                                   NameId;                                            // 0x0068(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         Damage;                                            // 0x0070(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_74[0x4];                                       // 0x0074(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	TSubclassOf<class UGbxDamageType>             DamageType;                                        // 0x0078(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TSubclassOf<class UDamageSource>              DamageSource;                                      // 0x0080(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         DamageRadius;                                      // 0x0088(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_8C[0x4];                                       // 0x008C(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class AActor*                                 DamageCauser;                                      // 0x0090(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UImpactData*                            ImpactDataOverride;                                // 0x0098(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FForceSelection                        ImpactForce;                                       // 0x00A0(0x0020)(Parm, NoDestructor, NativeAccessSpecifierPublic)
	float                                         LifetimeOverride;                                  // 0x00C0(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bViewDependent;                                    // 0x00C4(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_C5[0x3];                                       // 0x00C5(0x0003)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(LightBeamStatics_CreateLightBeam) == 0x000008, "Wrong alignment on LightBeamStatics_CreateLightBeam");
static_assert(sizeof(LightBeamStatics_CreateLightBeam) == 0x0000C8, "Wrong size on LightBeamStatics_CreateLightBeam");
static_assert(offsetof(LightBeamStatics_CreateLightBeam, Data) == 0x000000, "Member 'LightBeamStatics_CreateLightBeam::Data' has a wrong offset!");
static_assert(offsetof(LightBeamStatics_CreateLightBeam, Instigator) == 0x000008, "Member 'LightBeamStatics_CreateLightBeam::Instigator' has a wrong offset!");
static_assert(offsetof(LightBeamStatics_CreateLightBeam, Source) == 0x000010, "Member 'LightBeamStatics_CreateLightBeam::Source' has a wrong offset!");
static_assert(offsetof(LightBeamStatics_CreateLightBeam, Target) == 0x000038, "Member 'LightBeamStatics_CreateLightBeam::Target' has a wrong offset!");
static_assert(offsetof(LightBeamStatics_CreateLightBeam, bTargetLocked) == 0x000060, "Member 'LightBeamStatics_CreateLightBeam::bTargetLocked' has a wrong offset!");
static_assert(offsetof(LightBeamStatics_CreateLightBeam, NameId) == 0x000068, "Member 'LightBeamStatics_CreateLightBeam::NameId' has a wrong offset!");
static_assert(offsetof(LightBeamStatics_CreateLightBeam, Damage) == 0x000070, "Member 'LightBeamStatics_CreateLightBeam::Damage' has a wrong offset!");
static_assert(offsetof(LightBeamStatics_CreateLightBeam, DamageType) == 0x000078, "Member 'LightBeamStatics_CreateLightBeam::DamageType' has a wrong offset!");
static_assert(offsetof(LightBeamStatics_CreateLightBeam, DamageSource) == 0x000080, "Member 'LightBeamStatics_CreateLightBeam::DamageSource' has a wrong offset!");
static_assert(offsetof(LightBeamStatics_CreateLightBeam, DamageRadius) == 0x000088, "Member 'LightBeamStatics_CreateLightBeam::DamageRadius' has a wrong offset!");
static_assert(offsetof(LightBeamStatics_CreateLightBeam, DamageCauser) == 0x000090, "Member 'LightBeamStatics_CreateLightBeam::DamageCauser' has a wrong offset!");
static_assert(offsetof(LightBeamStatics_CreateLightBeam, ImpactDataOverride) == 0x000098, "Member 'LightBeamStatics_CreateLightBeam::ImpactDataOverride' has a wrong offset!");
static_assert(offsetof(LightBeamStatics_CreateLightBeam, ImpactForce) == 0x0000A0, "Member 'LightBeamStatics_CreateLightBeam::ImpactForce' has a wrong offset!");
static_assert(offsetof(LightBeamStatics_CreateLightBeam, LifetimeOverride) == 0x0000C0, "Member 'LightBeamStatics_CreateLightBeam::LifetimeOverride' has a wrong offset!");
static_assert(offsetof(LightBeamStatics_CreateLightBeam, bViewDependent) == 0x0000C4, "Member 'LightBeamStatics_CreateLightBeam::bViewDependent' has a wrong offset!");

// Function GbxWeapon.LightBeamStatics.CreateLightBeamFromData
// 0x0128 (0x0128 - 0x0000)
struct LightBeamStatics_CreateLightBeamFromData final
{
public:
	struct FLightBeamInitializationData           InitData;                                          // 0x0000(0x0128)(ConstParm, Parm, OutParm, ReferenceParm, ContainsInstancedReference, NativeAccessSpecifierPublic)
};
static_assert(alignof(LightBeamStatics_CreateLightBeamFromData) == 0x000008, "Wrong alignment on LightBeamStatics_CreateLightBeamFromData");
static_assert(sizeof(LightBeamStatics_CreateLightBeamFromData) == 0x000128, "Wrong size on LightBeamStatics_CreateLightBeamFromData");
static_assert(offsetof(LightBeamStatics_CreateLightBeamFromData, InitData) == 0x000000, "Member 'LightBeamStatics_CreateLightBeamFromData::InitData' has a wrong offset!");

// Function GbxWeapon.LightBeamStatics.DoesLightBeamExist
// 0x0030 (0x0030 - 0x0000)
struct LightBeamStatics_DoesLightBeamExist final
{
public:
	struct FLightBeamQueryData                    Query;                                             // 0x0000(0x0028)(ConstParm, Parm, OutParm, ReferenceParm, NoDestructor, NativeAccessSpecifierPublic)
	bool                                          ReturnValue;                                       // 0x0028(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_29[0x7];                                       // 0x0029(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(LightBeamStatics_DoesLightBeamExist) == 0x000008, "Wrong alignment on LightBeamStatics_DoesLightBeamExist");
static_assert(sizeof(LightBeamStatics_DoesLightBeamExist) == 0x000030, "Wrong size on LightBeamStatics_DoesLightBeamExist");
static_assert(offsetof(LightBeamStatics_DoesLightBeamExist, Query) == 0x000000, "Member 'LightBeamStatics_DoesLightBeamExist::Query' has a wrong offset!");
static_assert(offsetof(LightBeamStatics_DoesLightBeamExist, ReturnValue) == 0x000028, "Member 'LightBeamStatics_DoesLightBeamExist::ReturnValue' has a wrong offset!");

// Function GbxWeapon.LightBeamStatics.ForEachLightBeam
// 0x0038 (0x0038 - 0x0000)
struct LightBeamStatics_ForEachLightBeam final
{
public:
	struct FLightBeamQueryData                    Query;                                             // 0x0000(0x0028)(ConstParm, Parm, OutParm, ReferenceParm, NoDestructor, NativeAccessSpecifierPublic)
	TDelegate<void(class ULightBeam* Beam)>       Callback;                                          // 0x0028(0x0010)(ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, NoDestructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(LightBeamStatics_ForEachLightBeam) == 0x000008, "Wrong alignment on LightBeamStatics_ForEachLightBeam");
static_assert(sizeof(LightBeamStatics_ForEachLightBeam) == 0x000038, "Wrong size on LightBeamStatics_ForEachLightBeam");
static_assert(offsetof(LightBeamStatics_ForEachLightBeam, Query) == 0x000000, "Member 'LightBeamStatics_ForEachLightBeam::Query' has a wrong offset!");
static_assert(offsetof(LightBeamStatics_ForEachLightBeam, Callback) == 0x000028, "Member 'LightBeamStatics_ForEachLightBeam::Callback' has a wrong offset!");

// Function GbxWeapon.LightBeamStatics.IsBeamFlagSet
// 0x0130 (0x0130 - 0x0000)
struct LightBeamStatics_IsBeamFlagSet final
{
public:
	struct FLightBeamInitializationData           InitData;                                          // 0x0000(0x0128)(ConstParm, Parm, OutParm, ReferenceParm, ContainsInstancedReference, NativeAccessSpecifierPublic)
	ELightBeamFlag                                Flag;                                              // 0x0128(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          ReturnValue;                                       // 0x0129(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_12A[0x6];                                      // 0x012A(0x0006)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(LightBeamStatics_IsBeamFlagSet) == 0x000008, "Wrong alignment on LightBeamStatics_IsBeamFlagSet");
static_assert(sizeof(LightBeamStatics_IsBeamFlagSet) == 0x000130, "Wrong size on LightBeamStatics_IsBeamFlagSet");
static_assert(offsetof(LightBeamStatics_IsBeamFlagSet, InitData) == 0x000000, "Member 'LightBeamStatics_IsBeamFlagSet::InitData' has a wrong offset!");
static_assert(offsetof(LightBeamStatics_IsBeamFlagSet, Flag) == 0x000128, "Member 'LightBeamStatics_IsBeamFlagSet::Flag' has a wrong offset!");
static_assert(offsetof(LightBeamStatics_IsBeamFlagSet, ReturnValue) == 0x000129, "Member 'LightBeamStatics_IsBeamFlagSet::ReturnValue' has a wrong offset!");

// Function GbxWeapon.LightBeamStatics.RemoveLightBeamsByActor
// 0x0028 (0x0028 - 0x0000)
struct LightBeamStatics_RemoveLightBeamsByActor final
{
public:
	struct FLightBeamQueryData                    Query;                                             // 0x0000(0x0028)(ConstParm, Parm, OutParm, ReferenceParm, NoDestructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(LightBeamStatics_RemoveLightBeamsByActor) == 0x000008, "Wrong alignment on LightBeamStatics_RemoveLightBeamsByActor");
static_assert(sizeof(LightBeamStatics_RemoveLightBeamsByActor) == 0x000028, "Wrong size on LightBeamStatics_RemoveLightBeamsByActor");
static_assert(offsetof(LightBeamStatics_RemoveLightBeamsByActor, Query) == 0x000000, "Member 'LightBeamStatics_RemoveLightBeamsByActor::Query' has a wrong offset!");

// Function GbxWeapon.LightBeamStatics.RemoveLightBeamsBySource
// 0x0010 (0x0010 - 0x0000)
struct LightBeamStatics_RemoveLightBeamsBySource final
{
public:
	class AActor*                                 Source;                                            // 0x0000(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   NameId;                                            // 0x0008(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(LightBeamStatics_RemoveLightBeamsBySource) == 0x000008, "Wrong alignment on LightBeamStatics_RemoveLightBeamsBySource");
static_assert(sizeof(LightBeamStatics_RemoveLightBeamsBySource) == 0x000010, "Wrong size on LightBeamStatics_RemoveLightBeamsBySource");
static_assert(offsetof(LightBeamStatics_RemoveLightBeamsBySource, Source) == 0x000000, "Member 'LightBeamStatics_RemoveLightBeamsBySource::Source' has a wrong offset!");
static_assert(offsetof(LightBeamStatics_RemoveLightBeamsBySource, NameId) == 0x000008, "Member 'LightBeamStatics_RemoveLightBeamsBySource::NameId' has a wrong offset!");

// Function GbxWeapon.LightBeamStatics.SetBeamFlag
// 0x0130 (0x0130 - 0x0000)
struct LightBeamStatics_SetBeamFlag final
{
public:
	struct FLightBeamInitializationData           InitData;                                          // 0x0000(0x0128)(Parm, OutParm, ReferenceParm, ContainsInstancedReference, NativeAccessSpecifierPublic)
	ELightBeamFlag                                Flag;                                              // 0x0128(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_129[0x7];                                      // 0x0129(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(LightBeamStatics_SetBeamFlag) == 0x000008, "Wrong alignment on LightBeamStatics_SetBeamFlag");
static_assert(sizeof(LightBeamStatics_SetBeamFlag) == 0x000130, "Wrong size on LightBeamStatics_SetBeamFlag");
static_assert(offsetof(LightBeamStatics_SetBeamFlag, InitData) == 0x000000, "Member 'LightBeamStatics_SetBeamFlag::InitData' has a wrong offset!");
static_assert(offsetof(LightBeamStatics_SetBeamFlag, Flag) == 0x000128, "Member 'LightBeamStatics_SetBeamFlag::Flag' has a wrong offset!");

// Function GbxWeapon.LightProjectileStatics.ClearProjectileFlag
// 0x0148 (0x0148 - 0x0000)
struct LightProjectileStatics_ClearProjectileFlag final
{
public:
	struct FLightProjectileInitializationData     InitData;                                          // 0x0000(0x0140)(Parm, OutParm, ReferenceParm, ContainsInstancedReference, NativeAccessSpecifierPublic)
	ELightProjectileFlag                          Flag;                                              // 0x0140(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_141[0x7];                                      // 0x0141(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(LightProjectileStatics_ClearProjectileFlag) == 0x000008, "Wrong alignment on LightProjectileStatics_ClearProjectileFlag");
static_assert(sizeof(LightProjectileStatics_ClearProjectileFlag) == 0x000148, "Wrong size on LightProjectileStatics_ClearProjectileFlag");
static_assert(offsetof(LightProjectileStatics_ClearProjectileFlag, InitData) == 0x000000, "Member 'LightProjectileStatics_ClearProjectileFlag::InitData' has a wrong offset!");
static_assert(offsetof(LightProjectileStatics_ClearProjectileFlag, Flag) == 0x000140, "Member 'LightProjectileStatics_ClearProjectileFlag::Flag' has a wrong offset!");

// Function GbxWeapon.LightProjectileStatics.CreateLightProjectile
// 0x0058 (0x0058 - 0x0000)
struct LightProjectileStatics_CreateLightProjectile final
{
public:
	TSubclassOf<class ULightProjectileData>       Data;                                              // 0x0000(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                Location;                                          // 0x0008(0x000C)(Parm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                Direction;                                         // 0x0014(0x000C)(Parm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class APawn*                                  Instigator;                                        // 0x0020(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class AActor*                                 Source;                                            // 0x0028(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class AActor*                                 DamageCauser;                                      // 0x0030(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         Damage;                                            // 0x0038(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_3C[0x4];                                       // 0x003C(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	TSubclassOf<class UGbxDamageType>             DamageType;                                        // 0x0040(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TSubclassOf<class UDamageSource>              DamageSource;                                      // 0x0048(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UImpactData*                            ImpactDataOverride;                                // 0x0050(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(LightProjectileStatics_CreateLightProjectile) == 0x000008, "Wrong alignment on LightProjectileStatics_CreateLightProjectile");
static_assert(sizeof(LightProjectileStatics_CreateLightProjectile) == 0x000058, "Wrong size on LightProjectileStatics_CreateLightProjectile");
static_assert(offsetof(LightProjectileStatics_CreateLightProjectile, Data) == 0x000000, "Member 'LightProjectileStatics_CreateLightProjectile::Data' has a wrong offset!");
static_assert(offsetof(LightProjectileStatics_CreateLightProjectile, Location) == 0x000008, "Member 'LightProjectileStatics_CreateLightProjectile::Location' has a wrong offset!");
static_assert(offsetof(LightProjectileStatics_CreateLightProjectile, Direction) == 0x000014, "Member 'LightProjectileStatics_CreateLightProjectile::Direction' has a wrong offset!");
static_assert(offsetof(LightProjectileStatics_CreateLightProjectile, Instigator) == 0x000020, "Member 'LightProjectileStatics_CreateLightProjectile::Instigator' has a wrong offset!");
static_assert(offsetof(LightProjectileStatics_CreateLightProjectile, Source) == 0x000028, "Member 'LightProjectileStatics_CreateLightProjectile::Source' has a wrong offset!");
static_assert(offsetof(LightProjectileStatics_CreateLightProjectile, DamageCauser) == 0x000030, "Member 'LightProjectileStatics_CreateLightProjectile::DamageCauser' has a wrong offset!");
static_assert(offsetof(LightProjectileStatics_CreateLightProjectile, Damage) == 0x000038, "Member 'LightProjectileStatics_CreateLightProjectile::Damage' has a wrong offset!");
static_assert(offsetof(LightProjectileStatics_CreateLightProjectile, DamageType) == 0x000040, "Member 'LightProjectileStatics_CreateLightProjectile::DamageType' has a wrong offset!");
static_assert(offsetof(LightProjectileStatics_CreateLightProjectile, DamageSource) == 0x000048, "Member 'LightProjectileStatics_CreateLightProjectile::DamageSource' has a wrong offset!");
static_assert(offsetof(LightProjectileStatics_CreateLightProjectile, ImpactDataOverride) == 0x000050, "Member 'LightProjectileStatics_CreateLightProjectile::ImpactDataOverride' has a wrong offset!");

// Function GbxWeapon.LightProjectileStatics.CreateLightProjectileFromData
// 0x0140 (0x0140 - 0x0000)
struct LightProjectileStatics_CreateLightProjectileFromData final
{
public:
	struct FLightProjectileInitializationData     InitData;                                          // 0x0000(0x0140)(ConstParm, Parm, OutParm, ReferenceParm, ContainsInstancedReference, NativeAccessSpecifierPublic)
};
static_assert(alignof(LightProjectileStatics_CreateLightProjectileFromData) == 0x000008, "Wrong alignment on LightProjectileStatics_CreateLightProjectileFromData");
static_assert(sizeof(LightProjectileStatics_CreateLightProjectileFromData) == 0x000140, "Wrong size on LightProjectileStatics_CreateLightProjectileFromData");
static_assert(offsetof(LightProjectileStatics_CreateLightProjectileFromData, InitData) == 0x000000, "Member 'LightProjectileStatics_CreateLightProjectileFromData::InitData' has a wrong offset!");

// Function GbxWeapon.LightProjectileStatics.CreateLightProjectileFromDataAsync
// 0x0148 (0x0148 - 0x0000)
struct LightProjectileStatics_CreateLightProjectileFromDataAsync final
{
public:
	struct FLightProjectileInitializationData     InitData;                                          // 0x0000(0x0140)(ConstParm, Parm, OutParm, ReferenceParm, ContainsInstancedReference, NativeAccessSpecifierPublic)
	float                                         ForceSpawnTimer;                                   // 0x0140(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_144[0x4];                                      // 0x0144(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(LightProjectileStatics_CreateLightProjectileFromDataAsync) == 0x000008, "Wrong alignment on LightProjectileStatics_CreateLightProjectileFromDataAsync");
static_assert(sizeof(LightProjectileStatics_CreateLightProjectileFromDataAsync) == 0x000148, "Wrong size on LightProjectileStatics_CreateLightProjectileFromDataAsync");
static_assert(offsetof(LightProjectileStatics_CreateLightProjectileFromDataAsync, InitData) == 0x000000, "Member 'LightProjectileStatics_CreateLightProjectileFromDataAsync::InitData' has a wrong offset!");
static_assert(offsetof(LightProjectileStatics_CreateLightProjectileFromDataAsync, ForceSpawnTimer) == 0x000140, "Member 'LightProjectileStatics_CreateLightProjectileFromDataAsync::ForceSpawnTimer' has a wrong offset!");

// Function GbxWeapon.LightProjectileStatics.CreateLightProjectileFromSource
// 0x0030 (0x0030 - 0x0000)
struct LightProjectileStatics_CreateLightProjectileFromSource final
{
public:
	class ULightProjectile*                       SourceProjectile;                                  // 0x0000(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TSubclassOf<class ULightProjectileData>       Data;                                              // 0x0008(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                Location;                                          // 0x0010(0x000C)(Parm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                Direction;                                         // 0x001C(0x000C)(Parm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         Damage;                                            // 0x0028(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2C[0x4];                                       // 0x002C(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(LightProjectileStatics_CreateLightProjectileFromSource) == 0x000008, "Wrong alignment on LightProjectileStatics_CreateLightProjectileFromSource");
static_assert(sizeof(LightProjectileStatics_CreateLightProjectileFromSource) == 0x000030, "Wrong size on LightProjectileStatics_CreateLightProjectileFromSource");
static_assert(offsetof(LightProjectileStatics_CreateLightProjectileFromSource, SourceProjectile) == 0x000000, "Member 'LightProjectileStatics_CreateLightProjectileFromSource::SourceProjectile' has a wrong offset!");
static_assert(offsetof(LightProjectileStatics_CreateLightProjectileFromSource, Data) == 0x000008, "Member 'LightProjectileStatics_CreateLightProjectileFromSource::Data' has a wrong offset!");
static_assert(offsetof(LightProjectileStatics_CreateLightProjectileFromSource, Location) == 0x000010, "Member 'LightProjectileStatics_CreateLightProjectileFromSource::Location' has a wrong offset!");
static_assert(offsetof(LightProjectileStatics_CreateLightProjectileFromSource, Direction) == 0x00001C, "Member 'LightProjectileStatics_CreateLightProjectileFromSource::Direction' has a wrong offset!");
static_assert(offsetof(LightProjectileStatics_CreateLightProjectileFromSource, Damage) == 0x000028, "Member 'LightProjectileStatics_CreateLightProjectileFromSource::Damage' has a wrong offset!");

// Function GbxWeapon.LightProjectileStatics.DetonateLightProjectiles
// 0x0030 (0x0030 - 0x0000)
struct LightProjectileStatics_DetonateLightProjectiles final
{
public:
	struct FLightProjectileQueryData              Query;                                             // 0x0000(0x0020)(ConstParm, Parm, OutParm, ReferenceParm, NoDestructor, NativeAccessSpecifierPublic)
	float                                         StackingEnemyBonusDamage;                          // 0x0020(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         MinDetonationDelay;                                // 0x0024(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         MaxDetonationDelay;                                // 0x0028(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2C[0x4];                                       // 0x002C(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(LightProjectileStatics_DetonateLightProjectiles) == 0x000008, "Wrong alignment on LightProjectileStatics_DetonateLightProjectiles");
static_assert(sizeof(LightProjectileStatics_DetonateLightProjectiles) == 0x000030, "Wrong size on LightProjectileStatics_DetonateLightProjectiles");
static_assert(offsetof(LightProjectileStatics_DetonateLightProjectiles, Query) == 0x000000, "Member 'LightProjectileStatics_DetonateLightProjectiles::Query' has a wrong offset!");
static_assert(offsetof(LightProjectileStatics_DetonateLightProjectiles, StackingEnemyBonusDamage) == 0x000020, "Member 'LightProjectileStatics_DetonateLightProjectiles::StackingEnemyBonusDamage' has a wrong offset!");
static_assert(offsetof(LightProjectileStatics_DetonateLightProjectiles, MinDetonationDelay) == 0x000024, "Member 'LightProjectileStatics_DetonateLightProjectiles::MinDetonationDelay' has a wrong offset!");
static_assert(offsetof(LightProjectileStatics_DetonateLightProjectiles, MaxDetonationDelay) == 0x000028, "Member 'LightProjectileStatics_DetonateLightProjectiles::MaxDetonationDelay' has a wrong offset!");

// Function GbxWeapon.LightProjectileStatics.ForEachLightProjectile
// 0x0030 (0x0030 - 0x0000)
struct LightProjectileStatics_ForEachLightProjectile final
{
public:
	struct FLightProjectileQueryData              Query;                                             // 0x0000(0x0020)(ConstParm, Parm, OutParm, ReferenceParm, NoDestructor, NativeAccessSpecifierPublic)
	TDelegate<void(class ULightProjectile* Projectile)> Callback;                                          // 0x0020(0x0010)(ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, NoDestructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(LightProjectileStatics_ForEachLightProjectile) == 0x000008, "Wrong alignment on LightProjectileStatics_ForEachLightProjectile");
static_assert(sizeof(LightProjectileStatics_ForEachLightProjectile) == 0x000030, "Wrong size on LightProjectileStatics_ForEachLightProjectile");
static_assert(offsetof(LightProjectileStatics_ForEachLightProjectile, Query) == 0x000000, "Member 'LightProjectileStatics_ForEachLightProjectile::Query' has a wrong offset!");
static_assert(offsetof(LightProjectileStatics_ForEachLightProjectile, Callback) == 0x000020, "Member 'LightProjectileStatics_ForEachLightProjectile::Callback' has a wrong offset!");

// Function GbxWeapon.LightProjectileStatics.IsProjectileFlagSet
// 0x0148 (0x0148 - 0x0000)
struct LightProjectileStatics_IsProjectileFlagSet final
{
public:
	struct FLightProjectileInitializationData     InitData;                                          // 0x0000(0x0140)(ConstParm, Parm, OutParm, ReferenceParm, ContainsInstancedReference, NativeAccessSpecifierPublic)
	ELightProjectileFlag                          Flag;                                              // 0x0140(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          ReturnValue;                                       // 0x0141(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_142[0x6];                                      // 0x0142(0x0006)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(LightProjectileStatics_IsProjectileFlagSet) == 0x000008, "Wrong alignment on LightProjectileStatics_IsProjectileFlagSet");
static_assert(sizeof(LightProjectileStatics_IsProjectileFlagSet) == 0x000148, "Wrong size on LightProjectileStatics_IsProjectileFlagSet");
static_assert(offsetof(LightProjectileStatics_IsProjectileFlagSet, InitData) == 0x000000, "Member 'LightProjectileStatics_IsProjectileFlagSet::InitData' has a wrong offset!");
static_assert(offsetof(LightProjectileStatics_IsProjectileFlagSet, Flag) == 0x000140, "Member 'LightProjectileStatics_IsProjectileFlagSet::Flag' has a wrong offset!");
static_assert(offsetof(LightProjectileStatics_IsProjectileFlagSet, ReturnValue) == 0x000141, "Member 'LightProjectileStatics_IsProjectileFlagSet::ReturnValue' has a wrong offset!");

// Function GbxWeapon.LightProjectileStatics.RemoveLightProjectilesByActor
// 0x0020 (0x0020 - 0x0000)
struct LightProjectileStatics_RemoveLightProjectilesByActor final
{
public:
	struct FLightProjectileQueryData              Query;                                             // 0x0000(0x0020)(ConstParm, Parm, OutParm, ReferenceParm, NoDestructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(LightProjectileStatics_RemoveLightProjectilesByActor) == 0x000008, "Wrong alignment on LightProjectileStatics_RemoveLightProjectilesByActor");
static_assert(sizeof(LightProjectileStatics_RemoveLightProjectilesByActor) == 0x000020, "Wrong size on LightProjectileStatics_RemoveLightProjectilesByActor");
static_assert(offsetof(LightProjectileStatics_RemoveLightProjectilesByActor, Query) == 0x000000, "Member 'LightProjectileStatics_RemoveLightProjectilesByActor::Query' has a wrong offset!");

// Function GbxWeapon.LightProjectileStatics.SetHomingState
// 0x0028 (0x0028 - 0x0000)
struct LightProjectileStatics_SetHomingState final
{
public:
	struct FLightProjectileQueryData              Query;                                             // 0x0000(0x0020)(ConstParm, Parm, OutParm, ReferenceParm, NoDestructor, NativeAccessSpecifierPublic)
	bool                                          bIsHoming;                                         // 0x0020(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_21[0x7];                                       // 0x0021(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(LightProjectileStatics_SetHomingState) == 0x000008, "Wrong alignment on LightProjectileStatics_SetHomingState");
static_assert(sizeof(LightProjectileStatics_SetHomingState) == 0x000028, "Wrong size on LightProjectileStatics_SetHomingState");
static_assert(offsetof(LightProjectileStatics_SetHomingState, Query) == 0x000000, "Member 'LightProjectileStatics_SetHomingState::Query' has a wrong offset!");
static_assert(offsetof(LightProjectileStatics_SetHomingState, bIsHoming) == 0x000020, "Member 'LightProjectileStatics_SetHomingState::bIsHoming' has a wrong offset!");

// Function GbxWeapon.LightProjectileStatics.SetProjectileFlag
// 0x0148 (0x0148 - 0x0000)
struct LightProjectileStatics_SetProjectileFlag final
{
public:
	struct FLightProjectileInitializationData     InitData;                                          // 0x0000(0x0140)(Parm, OutParm, ReferenceParm, ContainsInstancedReference, NativeAccessSpecifierPublic)
	ELightProjectileFlag                          Flag;                                              // 0x0140(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_141[0x7];                                      // 0x0141(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(LightProjectileStatics_SetProjectileFlag) == 0x000008, "Wrong alignment on LightProjectileStatics_SetProjectileFlag");
static_assert(sizeof(LightProjectileStatics_SetProjectileFlag) == 0x000148, "Wrong size on LightProjectileStatics_SetProjectileFlag");
static_assert(offsetof(LightProjectileStatics_SetProjectileFlag, InitData) == 0x000000, "Member 'LightProjectileStatics_SetProjectileFlag::InitData' has a wrong offset!");
static_assert(offsetof(LightProjectileStatics_SetProjectileFlag, Flag) == 0x000140, "Member 'LightProjectileStatics_SetProjectileFlag::Flag' has a wrong offset!");

// Function GbxWeapon.LightProjectileStatics.SplitLightProjectile
// 0x0028 (0x0028 - 0x0000)
struct LightProjectileStatics_SplitLightProjectile final
{
public:
	class ULightProjectile*                       Projectile;                                        // 0x0000(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TSubclassOf<class ULightProjectileData>       Data;                                              // 0x0008(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	ELightProjectileSplitPattern                  Pattern;                                           // 0x0010(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_11[0x3];                                       // 0x0011(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	int32                                         Count;                                             // 0x0014(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         SpreadAngle;                                       // 0x0018(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         RotateAngle;                                       // 0x001C(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         OffsetDistance;                                    // 0x0020(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bDestroySource;                                    // 0x0024(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_25[0x3];                                       // 0x0025(0x0003)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(LightProjectileStatics_SplitLightProjectile) == 0x000008, "Wrong alignment on LightProjectileStatics_SplitLightProjectile");
static_assert(sizeof(LightProjectileStatics_SplitLightProjectile) == 0x000028, "Wrong size on LightProjectileStatics_SplitLightProjectile");
static_assert(offsetof(LightProjectileStatics_SplitLightProjectile, Projectile) == 0x000000, "Member 'LightProjectileStatics_SplitLightProjectile::Projectile' has a wrong offset!");
static_assert(offsetof(LightProjectileStatics_SplitLightProjectile, Data) == 0x000008, "Member 'LightProjectileStatics_SplitLightProjectile::Data' has a wrong offset!");
static_assert(offsetof(LightProjectileStatics_SplitLightProjectile, Pattern) == 0x000010, "Member 'LightProjectileStatics_SplitLightProjectile::Pattern' has a wrong offset!");
static_assert(offsetof(LightProjectileStatics_SplitLightProjectile, Count) == 0x000014, "Member 'LightProjectileStatics_SplitLightProjectile::Count' has a wrong offset!");
static_assert(offsetof(LightProjectileStatics_SplitLightProjectile, SpreadAngle) == 0x000018, "Member 'LightProjectileStatics_SplitLightProjectile::SpreadAngle' has a wrong offset!");
static_assert(offsetof(LightProjectileStatics_SplitLightProjectile, RotateAngle) == 0x00001C, "Member 'LightProjectileStatics_SplitLightProjectile::RotateAngle' has a wrong offset!");
static_assert(offsetof(LightProjectileStatics_SplitLightProjectile, OffsetDistance) == 0x000020, "Member 'LightProjectileStatics_SplitLightProjectile::OffsetDistance' has a wrong offset!");
static_assert(offsetof(LightProjectileStatics_SplitLightProjectile, bDestroySource) == 0x000024, "Member 'LightProjectileStatics_SplitLightProjectile::bDestroySource' has a wrong offset!");

// Function GbxWeapon.ProjectileBlueprintLibrary.CalcThrowVelocity
// 0x0060 (0x0060 - 0x0000)
struct ProjectileBlueprintLibrary_CalcThrowVelocity final
{
public:
	const class UObject*                          WorldContextObject;                                // 0x0000(0x0008)(ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                ResultVelocity;                                    // 0x0008(0x000C)(Parm, OutParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         ResultGravityScale;                                // 0x0014(0x0004)(Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                StartLocation;                                     // 0x0018(0x000C)(Parm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                TargetLocation;                                    // 0x0024(0x000C)(Parm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                TargetVelocity;                                    // 0x0030(0x000C)(Parm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         MaxPrediction;                                     // 0x003C(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         Speed;                                             // 0x0040(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         AnglePercent;                                      // 0x0044(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FRotator                               DirectionOffset;                                   // 0x0048(0x000C)(Parm, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
	struct FVector                                LocalTargetOffset;                                 // 0x0054(0x000C)(Parm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(ProjectileBlueprintLibrary_CalcThrowVelocity) == 0x000008, "Wrong alignment on ProjectileBlueprintLibrary_CalcThrowVelocity");
static_assert(sizeof(ProjectileBlueprintLibrary_CalcThrowVelocity) == 0x000060, "Wrong size on ProjectileBlueprintLibrary_CalcThrowVelocity");
static_assert(offsetof(ProjectileBlueprintLibrary_CalcThrowVelocity, WorldContextObject) == 0x000000, "Member 'ProjectileBlueprintLibrary_CalcThrowVelocity::WorldContextObject' has a wrong offset!");
static_assert(offsetof(ProjectileBlueprintLibrary_CalcThrowVelocity, ResultVelocity) == 0x000008, "Member 'ProjectileBlueprintLibrary_CalcThrowVelocity::ResultVelocity' has a wrong offset!");
static_assert(offsetof(ProjectileBlueprintLibrary_CalcThrowVelocity, ResultGravityScale) == 0x000014, "Member 'ProjectileBlueprintLibrary_CalcThrowVelocity::ResultGravityScale' has a wrong offset!");
static_assert(offsetof(ProjectileBlueprintLibrary_CalcThrowVelocity, StartLocation) == 0x000018, "Member 'ProjectileBlueprintLibrary_CalcThrowVelocity::StartLocation' has a wrong offset!");
static_assert(offsetof(ProjectileBlueprintLibrary_CalcThrowVelocity, TargetLocation) == 0x000024, "Member 'ProjectileBlueprintLibrary_CalcThrowVelocity::TargetLocation' has a wrong offset!");
static_assert(offsetof(ProjectileBlueprintLibrary_CalcThrowVelocity, TargetVelocity) == 0x000030, "Member 'ProjectileBlueprintLibrary_CalcThrowVelocity::TargetVelocity' has a wrong offset!");
static_assert(offsetof(ProjectileBlueprintLibrary_CalcThrowVelocity, MaxPrediction) == 0x00003C, "Member 'ProjectileBlueprintLibrary_CalcThrowVelocity::MaxPrediction' has a wrong offset!");
static_assert(offsetof(ProjectileBlueprintLibrary_CalcThrowVelocity, Speed) == 0x000040, "Member 'ProjectileBlueprintLibrary_CalcThrowVelocity::Speed' has a wrong offset!");
static_assert(offsetof(ProjectileBlueprintLibrary_CalcThrowVelocity, AnglePercent) == 0x000044, "Member 'ProjectileBlueprintLibrary_CalcThrowVelocity::AnglePercent' has a wrong offset!");
static_assert(offsetof(ProjectileBlueprintLibrary_CalcThrowVelocity, DirectionOffset) == 0x000048, "Member 'ProjectileBlueprintLibrary_CalcThrowVelocity::DirectionOffset' has a wrong offset!");
static_assert(offsetof(ProjectileBlueprintLibrary_CalcThrowVelocity, LocalTargetOffset) == 0x000054, "Member 'ProjectileBlueprintLibrary_CalcThrowVelocity::LocalTargetOffset' has a wrong offset!");

// Function GbxWeapon.ProjectileBlueprintLibrary.CalcThrowVelocityAtActor
// 0x0050 (0x0050 - 0x0000)
struct ProjectileBlueprintLibrary_CalcThrowVelocityAtActor final
{
public:
	struct FVector                                ResultVelocity;                                    // 0x0000(0x000C)(Parm, OutParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         ResultGravityScale;                                // 0x000C(0x0004)(Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                StartLocation;                                     // 0x0010(0x000C)(Parm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1C[0x4];                                       // 0x001C(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class AActor*                                 Target;                                            // 0x0020(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         MaxPrediction;                                     // 0x0028(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         Speed;                                             // 0x002C(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         AnglePercent;                                      // 0x0030(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FRotator                               DirectionOffset;                                   // 0x0034(0x000C)(Parm, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
	struct FVector                                LocalTargetOffset;                                 // 0x0040(0x000C)(Parm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_4C[0x4];                                       // 0x004C(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(ProjectileBlueprintLibrary_CalcThrowVelocityAtActor) == 0x000008, "Wrong alignment on ProjectileBlueprintLibrary_CalcThrowVelocityAtActor");
static_assert(sizeof(ProjectileBlueprintLibrary_CalcThrowVelocityAtActor) == 0x000050, "Wrong size on ProjectileBlueprintLibrary_CalcThrowVelocityAtActor");
static_assert(offsetof(ProjectileBlueprintLibrary_CalcThrowVelocityAtActor, ResultVelocity) == 0x000000, "Member 'ProjectileBlueprintLibrary_CalcThrowVelocityAtActor::ResultVelocity' has a wrong offset!");
static_assert(offsetof(ProjectileBlueprintLibrary_CalcThrowVelocityAtActor, ResultGravityScale) == 0x00000C, "Member 'ProjectileBlueprintLibrary_CalcThrowVelocityAtActor::ResultGravityScale' has a wrong offset!");
static_assert(offsetof(ProjectileBlueprintLibrary_CalcThrowVelocityAtActor, StartLocation) == 0x000010, "Member 'ProjectileBlueprintLibrary_CalcThrowVelocityAtActor::StartLocation' has a wrong offset!");
static_assert(offsetof(ProjectileBlueprintLibrary_CalcThrowVelocityAtActor, Target) == 0x000020, "Member 'ProjectileBlueprintLibrary_CalcThrowVelocityAtActor::Target' has a wrong offset!");
static_assert(offsetof(ProjectileBlueprintLibrary_CalcThrowVelocityAtActor, MaxPrediction) == 0x000028, "Member 'ProjectileBlueprintLibrary_CalcThrowVelocityAtActor::MaxPrediction' has a wrong offset!");
static_assert(offsetof(ProjectileBlueprintLibrary_CalcThrowVelocityAtActor, Speed) == 0x00002C, "Member 'ProjectileBlueprintLibrary_CalcThrowVelocityAtActor::Speed' has a wrong offset!");
static_assert(offsetof(ProjectileBlueprintLibrary_CalcThrowVelocityAtActor, AnglePercent) == 0x000030, "Member 'ProjectileBlueprintLibrary_CalcThrowVelocityAtActor::AnglePercent' has a wrong offset!");
static_assert(offsetof(ProjectileBlueprintLibrary_CalcThrowVelocityAtActor, DirectionOffset) == 0x000034, "Member 'ProjectileBlueprintLibrary_CalcThrowVelocityAtActor::DirectionOffset' has a wrong offset!");
static_assert(offsetof(ProjectileBlueprintLibrary_CalcThrowVelocityAtActor, LocalTargetOffset) == 0x000040, "Member 'ProjectileBlueprintLibrary_CalcThrowVelocityAtActor::LocalTargetOffset' has a wrong offset!");

// Function GbxWeapon.ProjectileBlueprintLibrary.CalculateConeVector
// 0x0030 (0x0030 - 0x0000)
struct ProjectileBlueprintLibrary_CalculateConeVector final
{
public:
	float                                         Fraction;                                          // 0x0000(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                Origin;                                            // 0x0004(0x000C)(ConstParm, Parm, OutParm, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                Direction;                                         // 0x0010(0x000C)(ConstParm, Parm, OutParm, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         AngleWidth;                                        // 0x001C(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         AngleHeight;                                       // 0x0020(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                ReturnValue;                                       // 0x0024(0x000C)(Parm, OutParm, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(ProjectileBlueprintLibrary_CalculateConeVector) == 0x000004, "Wrong alignment on ProjectileBlueprintLibrary_CalculateConeVector");
static_assert(sizeof(ProjectileBlueprintLibrary_CalculateConeVector) == 0x000030, "Wrong size on ProjectileBlueprintLibrary_CalculateConeVector");
static_assert(offsetof(ProjectileBlueprintLibrary_CalculateConeVector, Fraction) == 0x000000, "Member 'ProjectileBlueprintLibrary_CalculateConeVector::Fraction' has a wrong offset!");
static_assert(offsetof(ProjectileBlueprintLibrary_CalculateConeVector, Origin) == 0x000004, "Member 'ProjectileBlueprintLibrary_CalculateConeVector::Origin' has a wrong offset!");
static_assert(offsetof(ProjectileBlueprintLibrary_CalculateConeVector, Direction) == 0x000010, "Member 'ProjectileBlueprintLibrary_CalculateConeVector::Direction' has a wrong offset!");
static_assert(offsetof(ProjectileBlueprintLibrary_CalculateConeVector, AngleWidth) == 0x00001C, "Member 'ProjectileBlueprintLibrary_CalculateConeVector::AngleWidth' has a wrong offset!");
static_assert(offsetof(ProjectileBlueprintLibrary_CalculateConeVector, AngleHeight) == 0x000020, "Member 'ProjectileBlueprintLibrary_CalculateConeVector::AngleHeight' has a wrong offset!");
static_assert(offsetof(ProjectileBlueprintLibrary_CalculateConeVector, ReturnValue) == 0x000024, "Member 'ProjectileBlueprintLibrary_CalculateConeVector::ReturnValue' has a wrong offset!");

// Function GbxWeapon.ProjectileBlueprintLibrary.DetachProjectilesFromActor
// 0x0008 (0x0008 - 0x0000)
struct ProjectileBlueprintLibrary_DetachProjectilesFromActor final
{
public:
	class AActor*                                 BaseActor;                                         // 0x0000(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(ProjectileBlueprintLibrary_DetachProjectilesFromActor) == 0x000008, "Wrong alignment on ProjectileBlueprintLibrary_DetachProjectilesFromActor");
static_assert(sizeof(ProjectileBlueprintLibrary_DetachProjectilesFromActor) == 0x000008, "Wrong size on ProjectileBlueprintLibrary_DetachProjectilesFromActor");
static_assert(offsetof(ProjectileBlueprintLibrary_DetachProjectilesFromActor, BaseActor) == 0x000000, "Member 'ProjectileBlueprintLibrary_DetachProjectilesFromActor::BaseActor' has a wrong offset!");

// Function GbxWeapon.ProjectileBlueprintLibrary.GeneratePointsOnCone
// 0x0038 (0x0038 - 0x0000)
struct ProjectileBlueprintLibrary_GeneratePointsOnCone final
{
public:
	struct FVector                                Origin;                                            // 0x0000(0x000C)(Parm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                Direction;                                         // 0x000C(0x000C)(Parm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         SampleCount;                                       // 0x0018(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         SpreadAngle;                                       // 0x001C(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         RotateAngle;                                       // 0x0020(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         OriginOffset;                                      // 0x0024(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TArray<struct FTransform>                     ReturnValue;                                       // 0x0028(0x0010)(Parm, OutParm, ZeroConstructor, ReturnParm, NativeAccessSpecifierPublic)
};
static_assert(alignof(ProjectileBlueprintLibrary_GeneratePointsOnCone) == 0x000008, "Wrong alignment on ProjectileBlueprintLibrary_GeneratePointsOnCone");
static_assert(sizeof(ProjectileBlueprintLibrary_GeneratePointsOnCone) == 0x000038, "Wrong size on ProjectileBlueprintLibrary_GeneratePointsOnCone");
static_assert(offsetof(ProjectileBlueprintLibrary_GeneratePointsOnCone, Origin) == 0x000000, "Member 'ProjectileBlueprintLibrary_GeneratePointsOnCone::Origin' has a wrong offset!");
static_assert(offsetof(ProjectileBlueprintLibrary_GeneratePointsOnCone, Direction) == 0x00000C, "Member 'ProjectileBlueprintLibrary_GeneratePointsOnCone::Direction' has a wrong offset!");
static_assert(offsetof(ProjectileBlueprintLibrary_GeneratePointsOnCone, SampleCount) == 0x000018, "Member 'ProjectileBlueprintLibrary_GeneratePointsOnCone::SampleCount' has a wrong offset!");
static_assert(offsetof(ProjectileBlueprintLibrary_GeneratePointsOnCone, SpreadAngle) == 0x00001C, "Member 'ProjectileBlueprintLibrary_GeneratePointsOnCone::SpreadAngle' has a wrong offset!");
static_assert(offsetof(ProjectileBlueprintLibrary_GeneratePointsOnCone, RotateAngle) == 0x000020, "Member 'ProjectileBlueprintLibrary_GeneratePointsOnCone::RotateAngle' has a wrong offset!");
static_assert(offsetof(ProjectileBlueprintLibrary_GeneratePointsOnCone, OriginOffset) == 0x000024, "Member 'ProjectileBlueprintLibrary_GeneratePointsOnCone::OriginOffset' has a wrong offset!");
static_assert(offsetof(ProjectileBlueprintLibrary_GeneratePointsOnCone, ReturnValue) == 0x000028, "Member 'ProjectileBlueprintLibrary_GeneratePointsOnCone::ReturnValue' has a wrong offset!");

// Function GbxWeapon.ProjectileBlueprintLibrary.GeneratePointsOnFan
// 0x0038 (0x0038 - 0x0000)
struct ProjectileBlueprintLibrary_GeneratePointsOnFan final
{
public:
	struct FVector                                Origin;                                            // 0x0000(0x000C)(Parm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                Direction;                                         // 0x000C(0x000C)(Parm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         SampleCount;                                       // 0x0018(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         SpreadAngle;                                       // 0x001C(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         RotateAngle;                                       // 0x0020(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         OriginOffset;                                      // 0x0024(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TArray<struct FTransform>                     ReturnValue;                                       // 0x0028(0x0010)(Parm, OutParm, ZeroConstructor, ReturnParm, NativeAccessSpecifierPublic)
};
static_assert(alignof(ProjectileBlueprintLibrary_GeneratePointsOnFan) == 0x000008, "Wrong alignment on ProjectileBlueprintLibrary_GeneratePointsOnFan");
static_assert(sizeof(ProjectileBlueprintLibrary_GeneratePointsOnFan) == 0x000038, "Wrong size on ProjectileBlueprintLibrary_GeneratePointsOnFan");
static_assert(offsetof(ProjectileBlueprintLibrary_GeneratePointsOnFan, Origin) == 0x000000, "Member 'ProjectileBlueprintLibrary_GeneratePointsOnFan::Origin' has a wrong offset!");
static_assert(offsetof(ProjectileBlueprintLibrary_GeneratePointsOnFan, Direction) == 0x00000C, "Member 'ProjectileBlueprintLibrary_GeneratePointsOnFan::Direction' has a wrong offset!");
static_assert(offsetof(ProjectileBlueprintLibrary_GeneratePointsOnFan, SampleCount) == 0x000018, "Member 'ProjectileBlueprintLibrary_GeneratePointsOnFan::SampleCount' has a wrong offset!");
static_assert(offsetof(ProjectileBlueprintLibrary_GeneratePointsOnFan, SpreadAngle) == 0x00001C, "Member 'ProjectileBlueprintLibrary_GeneratePointsOnFan::SpreadAngle' has a wrong offset!");
static_assert(offsetof(ProjectileBlueprintLibrary_GeneratePointsOnFan, RotateAngle) == 0x000020, "Member 'ProjectileBlueprintLibrary_GeneratePointsOnFan::RotateAngle' has a wrong offset!");
static_assert(offsetof(ProjectileBlueprintLibrary_GeneratePointsOnFan, OriginOffset) == 0x000024, "Member 'ProjectileBlueprintLibrary_GeneratePointsOnFan::OriginOffset' has a wrong offset!");
static_assert(offsetof(ProjectileBlueprintLibrary_GeneratePointsOnFan, ReturnValue) == 0x000028, "Member 'ProjectileBlueprintLibrary_GeneratePointsOnFan::ReturnValue' has a wrong offset!");

// Function GbxWeapon.ProjectileBlueprintLibrary.GetSafeProjectileThrowTransform
// 0x0060 (0x0060 - 0x0000)
struct ProjectileBlueprintLibrary_GetSafeProjectileThrowTransform final
{
public:
	class AActor*                                 SourceActor;                                       // 0x0000(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   SocketName;                                        // 0x0008(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TArray<class AActor*>                         IgnoreActors;                                      // 0x0010(0x0010)(ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, NativeAccessSpecifierPublic)
	bool                                          bThrowFromFirstPersonSocket;                       // 0x0020(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	ECollisionChannel                             TraceChannel;                                      // 0x0021(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_22[0xE];                                       // 0x0022(0x000E)(Fixing Size After Last Property [ Dumper-7 ])
	struct FTransform                             ReturnValue;                                       // 0x0030(0x0030)(Parm, OutParm, ReturnParm, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(ProjectileBlueprintLibrary_GetSafeProjectileThrowTransform) == 0x000010, "Wrong alignment on ProjectileBlueprintLibrary_GetSafeProjectileThrowTransform");
static_assert(sizeof(ProjectileBlueprintLibrary_GetSafeProjectileThrowTransform) == 0x000060, "Wrong size on ProjectileBlueprintLibrary_GetSafeProjectileThrowTransform");
static_assert(offsetof(ProjectileBlueprintLibrary_GetSafeProjectileThrowTransform, SourceActor) == 0x000000, "Member 'ProjectileBlueprintLibrary_GetSafeProjectileThrowTransform::SourceActor' has a wrong offset!");
static_assert(offsetof(ProjectileBlueprintLibrary_GetSafeProjectileThrowTransform, SocketName) == 0x000008, "Member 'ProjectileBlueprintLibrary_GetSafeProjectileThrowTransform::SocketName' has a wrong offset!");
static_assert(offsetof(ProjectileBlueprintLibrary_GetSafeProjectileThrowTransform, IgnoreActors) == 0x000010, "Member 'ProjectileBlueprintLibrary_GetSafeProjectileThrowTransform::IgnoreActors' has a wrong offset!");
static_assert(offsetof(ProjectileBlueprintLibrary_GetSafeProjectileThrowTransform, bThrowFromFirstPersonSocket) == 0x000020, "Member 'ProjectileBlueprintLibrary_GetSafeProjectileThrowTransform::bThrowFromFirstPersonSocket' has a wrong offset!");
static_assert(offsetof(ProjectileBlueprintLibrary_GetSafeProjectileThrowTransform, TraceChannel) == 0x000021, "Member 'ProjectileBlueprintLibrary_GetSafeProjectileThrowTransform::TraceChannel' has a wrong offset!");
static_assert(offsetof(ProjectileBlueprintLibrary_GetSafeProjectileThrowTransform, ReturnValue) == 0x000030, "Member 'ProjectileBlueprintLibrary_GetSafeProjectileThrowTransform::ReturnValue' has a wrong offset!");

// Function GbxWeapon.ProjectileBlueprintLibrary.GetSafeProjectileThrowTransform_Component
// 0x0060 (0x0060 - 0x0000)
struct ProjectileBlueprintLibrary_GetSafeProjectileThrowTransform_Component final
{
public:
	class AActor*                                 SourceActor;                                       // 0x0000(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class USceneComponent*                        SourceComponent;                                   // 0x0008(0x0008)(Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   SocketName;                                        // 0x0010(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TArray<class AActor*>                         IgnoreActors;                                      // 0x0018(0x0010)(ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, NativeAccessSpecifierPublic)
	ECollisionChannel                             TraceChannel;                                      // 0x0028(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_29[0x7];                                       // 0x0029(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	struct FTransform                             ReturnValue;                                       // 0x0030(0x0030)(Parm, OutParm, ReturnParm, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(ProjectileBlueprintLibrary_GetSafeProjectileThrowTransform_Component) == 0x000010, "Wrong alignment on ProjectileBlueprintLibrary_GetSafeProjectileThrowTransform_Component");
static_assert(sizeof(ProjectileBlueprintLibrary_GetSafeProjectileThrowTransform_Component) == 0x000060, "Wrong size on ProjectileBlueprintLibrary_GetSafeProjectileThrowTransform_Component");
static_assert(offsetof(ProjectileBlueprintLibrary_GetSafeProjectileThrowTransform_Component, SourceActor) == 0x000000, "Member 'ProjectileBlueprintLibrary_GetSafeProjectileThrowTransform_Component::SourceActor' has a wrong offset!");
static_assert(offsetof(ProjectileBlueprintLibrary_GetSafeProjectileThrowTransform_Component, SourceComponent) == 0x000008, "Member 'ProjectileBlueprintLibrary_GetSafeProjectileThrowTransform_Component::SourceComponent' has a wrong offset!");
static_assert(offsetof(ProjectileBlueprintLibrary_GetSafeProjectileThrowTransform_Component, SocketName) == 0x000010, "Member 'ProjectileBlueprintLibrary_GetSafeProjectileThrowTransform_Component::SocketName' has a wrong offset!");
static_assert(offsetof(ProjectileBlueprintLibrary_GetSafeProjectileThrowTransform_Component, IgnoreActors) == 0x000018, "Member 'ProjectileBlueprintLibrary_GetSafeProjectileThrowTransform_Component::IgnoreActors' has a wrong offset!");
static_assert(offsetof(ProjectileBlueprintLibrary_GetSafeProjectileThrowTransform_Component, TraceChannel) == 0x000028, "Member 'ProjectileBlueprintLibrary_GetSafeProjectileThrowTransform_Component::TraceChannel' has a wrong offset!");
static_assert(offsetof(ProjectileBlueprintLibrary_GetSafeProjectileThrowTransform_Component, ReturnValue) == 0x000030, "Member 'ProjectileBlueprintLibrary_GetSafeProjectileThrowTransform_Component::ReturnValue' has a wrong offset!");

// Function GbxWeapon.ProjectileBlueprintLibrary.PredictProjectilePathAsync
// 0x0088 (0x0088 - 0x0000)
struct ProjectileBlueprintLibrary_PredictProjectilePathAsync final
{
public:
	const class UObject*                          WorldContext;                                      // 0x0000(0x0008)(ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FPredictProjectilePathAsyncRequest     Request;                                           // 0x0008(0x0080)(ConstParm, Parm, OutParm, ReferenceParm, ContainsInstancedReference, NativeAccessSpecifierPublic)
};
static_assert(alignof(ProjectileBlueprintLibrary_PredictProjectilePathAsync) == 0x000008, "Wrong alignment on ProjectileBlueprintLibrary_PredictProjectilePathAsync");
static_assert(sizeof(ProjectileBlueprintLibrary_PredictProjectilePathAsync) == 0x000088, "Wrong size on ProjectileBlueprintLibrary_PredictProjectilePathAsync");
static_assert(offsetof(ProjectileBlueprintLibrary_PredictProjectilePathAsync, WorldContext) == 0x000000, "Member 'ProjectileBlueprintLibrary_PredictProjectilePathAsync::WorldContext' has a wrong offset!");
static_assert(offsetof(ProjectileBlueprintLibrary_PredictProjectilePathAsync, Request) == 0x000008, "Member 'ProjectileBlueprintLibrary_PredictProjectilePathAsync::Request' has a wrong offset!");

// Function GbxWeapon.ProjectileBlueprintLibrary.ThrowActorAt
// 0x0048 (0x0048 - 0x0000)
struct ProjectileBlueprintLibrary_ThrowActorAt final
{
public:
	class AActor*                                 Actor;                                             // 0x0000(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                TargetLocation;                                    // 0x0008(0x000C)(Parm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                TargetVelocity;                                    // 0x0014(0x000C)(Parm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         MaxPrediction;                                     // 0x0020(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         Speed;                                             // 0x0024(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         AnglePercent;                                      // 0x0028(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FRotator                               DirectionOffset;                                   // 0x002C(0x000C)(Parm, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
	struct FVector                                LocalTargetOffset;                                 // 0x0038(0x000C)(Parm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_44[0x4];                                       // 0x0044(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(ProjectileBlueprintLibrary_ThrowActorAt) == 0x000008, "Wrong alignment on ProjectileBlueprintLibrary_ThrowActorAt");
static_assert(sizeof(ProjectileBlueprintLibrary_ThrowActorAt) == 0x000048, "Wrong size on ProjectileBlueprintLibrary_ThrowActorAt");
static_assert(offsetof(ProjectileBlueprintLibrary_ThrowActorAt, Actor) == 0x000000, "Member 'ProjectileBlueprintLibrary_ThrowActorAt::Actor' has a wrong offset!");
static_assert(offsetof(ProjectileBlueprintLibrary_ThrowActorAt, TargetLocation) == 0x000008, "Member 'ProjectileBlueprintLibrary_ThrowActorAt::TargetLocation' has a wrong offset!");
static_assert(offsetof(ProjectileBlueprintLibrary_ThrowActorAt, TargetVelocity) == 0x000014, "Member 'ProjectileBlueprintLibrary_ThrowActorAt::TargetVelocity' has a wrong offset!");
static_assert(offsetof(ProjectileBlueprintLibrary_ThrowActorAt, MaxPrediction) == 0x000020, "Member 'ProjectileBlueprintLibrary_ThrowActorAt::MaxPrediction' has a wrong offset!");
static_assert(offsetof(ProjectileBlueprintLibrary_ThrowActorAt, Speed) == 0x000024, "Member 'ProjectileBlueprintLibrary_ThrowActorAt::Speed' has a wrong offset!");
static_assert(offsetof(ProjectileBlueprintLibrary_ThrowActorAt, AnglePercent) == 0x000028, "Member 'ProjectileBlueprintLibrary_ThrowActorAt::AnglePercent' has a wrong offset!");
static_assert(offsetof(ProjectileBlueprintLibrary_ThrowActorAt, DirectionOffset) == 0x00002C, "Member 'ProjectileBlueprintLibrary_ThrowActorAt::DirectionOffset' has a wrong offset!");
static_assert(offsetof(ProjectileBlueprintLibrary_ThrowActorAt, LocalTargetOffset) == 0x000038, "Member 'ProjectileBlueprintLibrary_ThrowActorAt::LocalTargetOffset' has a wrong offset!");

// Function GbxWeapon.ProjectileBlueprintLibrary.ThrowProjectileAsync
// 0x0198 (0x0198 - 0x0000)
struct ProjectileBlueprintLibrary_ThrowProjectileAsync final
{
public:
	class UObject*                                WorldContext;                                      // 0x0000(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FThrowProjectileAsyncRequest           Request;                                           // 0x0008(0x0188)(Parm, ContainsInstancedReference, NativeAccessSpecifierPublic)
	int32                                         ReturnValue;                                       // 0x0190(0x0004)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_194[0x4];                                      // 0x0194(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(ProjectileBlueprintLibrary_ThrowProjectileAsync) == 0x000008, "Wrong alignment on ProjectileBlueprintLibrary_ThrowProjectileAsync");
static_assert(sizeof(ProjectileBlueprintLibrary_ThrowProjectileAsync) == 0x000198, "Wrong size on ProjectileBlueprintLibrary_ThrowProjectileAsync");
static_assert(offsetof(ProjectileBlueprintLibrary_ThrowProjectileAsync, WorldContext) == 0x000000, "Member 'ProjectileBlueprintLibrary_ThrowProjectileAsync::WorldContext' has a wrong offset!");
static_assert(offsetof(ProjectileBlueprintLibrary_ThrowProjectileAsync, Request) == 0x000008, "Member 'ProjectileBlueprintLibrary_ThrowProjectileAsync::Request' has a wrong offset!");
static_assert(offsetof(ProjectileBlueprintLibrary_ThrowProjectileAsync, ReturnValue) == 0x000190, "Member 'ProjectileBlueprintLibrary_ThrowProjectileAsync::ReturnValue' has a wrong offset!");

// Function GbxWeapon.RecoilControlComponent.ServerApplyInput
// 0x0004 (0x0004 - 0x0000)
struct RecoilControlComponent_ServerApplyInput final
{
public:
	uint32                                        CompressedInputRot;                                // 0x0000(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(RecoilControlComponent_ServerApplyInput) == 0x000004, "Wrong alignment on RecoilControlComponent_ServerApplyInput");
static_assert(sizeof(RecoilControlComponent_ServerApplyInput) == 0x000004, "Wrong size on RecoilControlComponent_ServerApplyInput");
static_assert(offsetof(RecoilControlComponent_ServerApplyInput, CompressedInputRot) == 0x000000, "Member 'RecoilControlComponent_ServerApplyInput::CompressedInputRot' has a wrong offset!");

// Function GbxWeapon.WeaponAmmoPoolComponent.ClientConsumeAmmo
// 0x0004 (0x0004 - 0x0000)
struct WeaponAmmoPoolComponent_ClientConsumeAmmo final
{
public:
	int32                                         Amount;                                            // 0x0000(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(WeaponAmmoPoolComponent_ClientConsumeAmmo) == 0x000004, "Wrong alignment on WeaponAmmoPoolComponent_ClientConsumeAmmo");
static_assert(sizeof(WeaponAmmoPoolComponent_ClientConsumeAmmo) == 0x000004, "Wrong size on WeaponAmmoPoolComponent_ClientConsumeAmmo");
static_assert(offsetof(WeaponAmmoPoolComponent_ClientConsumeAmmo, Amount) == 0x000000, "Member 'WeaponAmmoPoolComponent_ClientConsumeAmmo::Amount' has a wrong offset!");

// Function GbxWeapon.WeaponAmmoPoolComponent.ClientSetLoadedAmmo
// 0x0004 (0x0004 - 0x0000)
struct WeaponAmmoPoolComponent_ClientSetLoadedAmmo final
{
public:
	int32                                         NewLoadedAmmo;                                     // 0x0000(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(WeaponAmmoPoolComponent_ClientSetLoadedAmmo) == 0x000004, "Wrong alignment on WeaponAmmoPoolComponent_ClientSetLoadedAmmo");
static_assert(sizeof(WeaponAmmoPoolComponent_ClientSetLoadedAmmo) == 0x000004, "Wrong size on WeaponAmmoPoolComponent_ClientSetLoadedAmmo");
static_assert(offsetof(WeaponAmmoPoolComponent_ClientSetLoadedAmmo, NewLoadedAmmo) == 0x000000, "Member 'WeaponAmmoPoolComponent_ClientSetLoadedAmmo::NewLoadedAmmo' has a wrong offset!");

// Function GbxWeapon.WeaponAmmoPoolComponent.OnMaxLoadedAmmoChanged
// 0x0008 (0x0008 - 0x0000)
struct WeaponAmmoPoolComponent_OnMaxLoadedAmmoChanged final
{
public:
	float                                         OldValue;                                          // 0x0000(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         NewValue;                                          // 0x0004(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(WeaponAmmoPoolComponent_OnMaxLoadedAmmoChanged) == 0x000004, "Wrong alignment on WeaponAmmoPoolComponent_OnMaxLoadedAmmoChanged");
static_assert(sizeof(WeaponAmmoPoolComponent_OnMaxLoadedAmmoChanged) == 0x000008, "Wrong size on WeaponAmmoPoolComponent_OnMaxLoadedAmmoChanged");
static_assert(offsetof(WeaponAmmoPoolComponent_OnMaxLoadedAmmoChanged, OldValue) == 0x000000, "Member 'WeaponAmmoPoolComponent_OnMaxLoadedAmmoChanged::OldValue' has a wrong offset!");
static_assert(offsetof(WeaponAmmoPoolComponent_OnMaxLoadedAmmoChanged, NewValue) == 0x000004, "Member 'WeaponAmmoPoolComponent_OnMaxLoadedAmmoChanged::NewValue' has a wrong offset!");

// Function GbxWeapon.WeaponChargeComponent.OnChargeActionEnd
// 0x0001 (0x0001 - 0x0000)
struct WeaponChargeComponent_OnChargeActionEnd final
{
public:
	EGbxActionEndState                            EndState;                                          // 0x0000(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(WeaponChargeComponent_OnChargeActionEnd) == 0x000001, "Wrong alignment on WeaponChargeComponent_OnChargeActionEnd");
static_assert(sizeof(WeaponChargeComponent_OnChargeActionEnd) == 0x000001, "Wrong size on WeaponChargeComponent_OnChargeActionEnd");
static_assert(offsetof(WeaponChargeComponent_OnChargeActionEnd, EndState) == 0x000000, "Member 'WeaponChargeComponent_OnChargeActionEnd::EndState' has a wrong offset!");

// Function GbxWeapon.WeaponChargeComponent.OnRep_ChargeState
// 0x0001 (0x0001 - 0x0000)
struct WeaponChargeComponent_OnRep_ChargeState final
{
public:
	EWeaponChargeState                            PrevChargeState;                                   // 0x0000(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(WeaponChargeComponent_OnRep_ChargeState) == 0x000001, "Wrong alignment on WeaponChargeComponent_OnRep_ChargeState");
static_assert(sizeof(WeaponChargeComponent_OnRep_ChargeState) == 0x000001, "Wrong size on WeaponChargeComponent_OnRep_ChargeState");
static_assert(offsetof(WeaponChargeComponent_OnRep_ChargeState, PrevChargeState) == 0x000000, "Member 'WeaponChargeComponent_OnRep_ChargeState::PrevChargeState' has a wrong offset!");

// Function GbxWeapon.WeaponChargeComponent.GetChargeDuration
// 0x0004 (0x0004 - 0x0000)
struct WeaponChargeComponent_GetChargeDuration final
{
public:
	float                                         ReturnValue;                                       // 0x0000(0x0004)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(WeaponChargeComponent_GetChargeDuration) == 0x000004, "Wrong alignment on WeaponChargeComponent_GetChargeDuration");
static_assert(sizeof(WeaponChargeComponent_GetChargeDuration) == 0x000004, "Wrong size on WeaponChargeComponent_GetChargeDuration");
static_assert(offsetof(WeaponChargeComponent_GetChargeDuration, ReturnValue) == 0x000000, "Member 'WeaponChargeComponent_GetChargeDuration::ReturnValue' has a wrong offset!");

// Function GbxWeapon.WeaponChargeComponent.GetChargePercent
// 0x0004 (0x0004 - 0x0000)
struct WeaponChargeComponent_GetChargePercent final
{
public:
	float                                         ReturnValue;                                       // 0x0000(0x0004)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(WeaponChargeComponent_GetChargePercent) == 0x000004, "Wrong alignment on WeaponChargeComponent_GetChargePercent");
static_assert(sizeof(WeaponChargeComponent_GetChargePercent) == 0x000004, "Wrong size on WeaponChargeComponent_GetChargePercent");
static_assert(offsetof(WeaponChargeComponent_GetChargePercent, ReturnValue) == 0x000000, "Member 'WeaponChargeComponent_GetChargePercent::ReturnValue' has a wrong offset!");

// Function GbxWeapon.WeaponChargeComponent.GetDischargeDuration
// 0x0004 (0x0004 - 0x0000)
struct WeaponChargeComponent_GetDischargeDuration final
{
public:
	float                                         ReturnValue;                                       // 0x0000(0x0004)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(WeaponChargeComponent_GetDischargeDuration) == 0x000004, "Wrong alignment on WeaponChargeComponent_GetDischargeDuration");
static_assert(sizeof(WeaponChargeComponent_GetDischargeDuration) == 0x000004, "Wrong size on WeaponChargeComponent_GetDischargeDuration");
static_assert(offsetof(WeaponChargeComponent_GetDischargeDuration, ReturnValue) == 0x000000, "Member 'WeaponChargeComponent_GetDischargeDuration::ReturnValue' has a wrong offset!");

// Function GbxWeapon.WeaponFireBeamComponent.GetShotLightBeamData
// 0x0008 (0x0008 - 0x0000)
struct WeaponFireBeamComponent_GetShotLightBeamData final
{
public:
	TSubclassOf<class ULightBeamData>             ReturnValue;                                       // 0x0000(0x0008)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(WeaponFireBeamComponent_GetShotLightBeamData) == 0x000008, "Wrong alignment on WeaponFireBeamComponent_GetShotLightBeamData");
static_assert(sizeof(WeaponFireBeamComponent_GetShotLightBeamData) == 0x000008, "Wrong size on WeaponFireBeamComponent_GetShotLightBeamData");
static_assert(offsetof(WeaponFireBeamComponent_GetShotLightBeamData, ReturnValue) == 0x000000, "Member 'WeaponFireBeamComponent_GetShotLightBeamData::ReturnValue' has a wrong offset!");

// Function GbxWeapon.WeaponRecoilPatternComponent.GetRecoilPatternGoodness
// 0x0004 (0x0004 - 0x0000)
struct WeaponRecoilPatternComponent_GetRecoilPatternGoodness final
{
public:
	float                                         ReturnValue;                                       // 0x0000(0x0004)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(WeaponRecoilPatternComponent_GetRecoilPatternGoodness) == 0x000004, "Wrong alignment on WeaponRecoilPatternComponent_GetRecoilPatternGoodness");
static_assert(sizeof(WeaponRecoilPatternComponent_GetRecoilPatternGoodness) == 0x000004, "Wrong size on WeaponRecoilPatternComponent_GetRecoilPatternGoodness");
static_assert(offsetof(WeaponRecoilPatternComponent_GetRecoilPatternGoodness, ReturnValue) == 0x000000, "Member 'WeaponRecoilPatternComponent_GetRecoilPatternGoodness::ReturnValue' has a wrong offset!");

// Function GbxWeapon.WeaponRecoilPatternComponent.GetRecoilPatternHeightGoodness
// 0x0004 (0x0004 - 0x0000)
struct WeaponRecoilPatternComponent_GetRecoilPatternHeightGoodness final
{
public:
	float                                         ReturnValue;                                       // 0x0000(0x0004)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(WeaponRecoilPatternComponent_GetRecoilPatternHeightGoodness) == 0x000004, "Wrong alignment on WeaponRecoilPatternComponent_GetRecoilPatternHeightGoodness");
static_assert(sizeof(WeaponRecoilPatternComponent_GetRecoilPatternHeightGoodness) == 0x000004, "Wrong size on WeaponRecoilPatternComponent_GetRecoilPatternHeightGoodness");
static_assert(offsetof(WeaponRecoilPatternComponent_GetRecoilPatternHeightGoodness, ReturnValue) == 0x000000, "Member 'WeaponRecoilPatternComponent_GetRecoilPatternHeightGoodness::ReturnValue' has a wrong offset!");

// Function GbxWeapon.WeaponRecoilPatternComponent.GetRecoilPatternWidthGoodness
// 0x0004 (0x0004 - 0x0000)
struct WeaponRecoilPatternComponent_GetRecoilPatternWidthGoodness final
{
public:
	float                                         ReturnValue;                                       // 0x0000(0x0004)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(WeaponRecoilPatternComponent_GetRecoilPatternWidthGoodness) == 0x000004, "Wrong alignment on WeaponRecoilPatternComponent_GetRecoilPatternWidthGoodness");
static_assert(sizeof(WeaponRecoilPatternComponent_GetRecoilPatternWidthGoodness) == 0x000004, "Wrong size on WeaponRecoilPatternComponent_GetRecoilPatternWidthGoodness");
static_assert(offsetof(WeaponRecoilPatternComponent_GetRecoilPatternWidthGoodness, ReturnValue) == 0x000000, "Member 'WeaponRecoilPatternComponent_GetRecoilPatternWidthGoodness::ReturnValue' has a wrong offset!");

// Function GbxWeapon.WeaponSingleFeedReloadComponent.OnUserInput
// 0x0001 (0x0001 - 0x0000)
struct WeaponSingleFeedReloadComponent_OnUserInput final
{
public:
	uint8                                         InputChannel;                                      // 0x0000(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(WeaponSingleFeedReloadComponent_OnUserInput) == 0x000001, "Wrong alignment on WeaponSingleFeedReloadComponent_OnUserInput");
static_assert(sizeof(WeaponSingleFeedReloadComponent_OnUserInput) == 0x000001, "Wrong size on WeaponSingleFeedReloadComponent_OnUserInput");
static_assert(offsetof(WeaponSingleFeedReloadComponent_OnUserInput, InputChannel) == 0x000000, "Member 'WeaponSingleFeedReloadComponent_OnUserInput::InputChannel' has a wrong offset!");

// Function GbxWeapon.WeaponStatics.CreateProjectileEQSProxy
// 0x0028 (0x0028 - 0x0000)
struct WeaponStatics_CreateProjectileEQSProxy final
{
public:
	struct FVector                                Location;                                          // 0x0000(0x000C)(Parm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FRotator                               Rotation;                                          // 0x000C(0x000C)(Parm, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
	class AActor*                                 ReferenceActor;                                    // 0x0018(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UProjectileEQSProxy*                    ReturnValue;                                       // 0x0020(0x0008)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(WeaponStatics_CreateProjectileEQSProxy) == 0x000008, "Wrong alignment on WeaponStatics_CreateProjectileEQSProxy");
static_assert(sizeof(WeaponStatics_CreateProjectileEQSProxy) == 0x000028, "Wrong size on WeaponStatics_CreateProjectileEQSProxy");
static_assert(offsetof(WeaponStatics_CreateProjectileEQSProxy, Location) == 0x000000, "Member 'WeaponStatics_CreateProjectileEQSProxy::Location' has a wrong offset!");
static_assert(offsetof(WeaponStatics_CreateProjectileEQSProxy, Rotation) == 0x00000C, "Member 'WeaponStatics_CreateProjectileEQSProxy::Rotation' has a wrong offset!");
static_assert(offsetof(WeaponStatics_CreateProjectileEQSProxy, ReferenceActor) == 0x000018, "Member 'WeaponStatics_CreateProjectileEQSProxy::ReferenceActor' has a wrong offset!");
static_assert(offsetof(WeaponStatics_CreateProjectileEQSProxy, ReturnValue) == 0x000020, "Member 'WeaponStatics_CreateProjectileEQSProxy::ReturnValue' has a wrong offset!");

// Function GbxWeapon.WeaponStatics.GetDamageType
// 0x0018 (0x0018 - 0x0000)
struct WeaponStatics_GetDamageType final
{
public:
	class AWeapon*                                Weapon;                                            // 0x0000(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         UseMode;                                           // 0x0008(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_9[0x7];                                        // 0x0009(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	const class UGbxDamageType*                   ReturnValue;                                       // 0x0010(0x0008)(ConstParm, Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(WeaponStatics_GetDamageType) == 0x000008, "Wrong alignment on WeaponStatics_GetDamageType");
static_assert(sizeof(WeaponStatics_GetDamageType) == 0x000018, "Wrong size on WeaponStatics_GetDamageType");
static_assert(offsetof(WeaponStatics_GetDamageType, Weapon) == 0x000000, "Member 'WeaponStatics_GetDamageType::Weapon' has a wrong offset!");
static_assert(offsetof(WeaponStatics_GetDamageType, UseMode) == 0x000008, "Member 'WeaponStatics_GetDamageType::UseMode' has a wrong offset!");
static_assert(offsetof(WeaponStatics_GetDamageType, ReturnValue) == 0x000010, "Member 'WeaponStatics_GetDamageType::ReturnValue' has a wrong offset!");

// Function GbxWeapon.WeaponStatics.GetFireRate
// 0x0010 (0x0010 - 0x0000)
struct WeaponStatics_GetFireRate final
{
public:
	class AWeapon*                                Weapon;                                            // 0x0000(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         UseMode;                                           // 0x0008(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_9[0x3];                                        // 0x0009(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         ReturnValue;                                       // 0x000C(0x0004)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(WeaponStatics_GetFireRate) == 0x000008, "Wrong alignment on WeaponStatics_GetFireRate");
static_assert(sizeof(WeaponStatics_GetFireRate) == 0x000010, "Wrong size on WeaponStatics_GetFireRate");
static_assert(offsetof(WeaponStatics_GetFireRate, Weapon) == 0x000000, "Member 'WeaponStatics_GetFireRate::Weapon' has a wrong offset!");
static_assert(offsetof(WeaponStatics_GetFireRate, UseMode) == 0x000008, "Member 'WeaponStatics_GetFireRate::UseMode' has a wrong offset!");
static_assert(offsetof(WeaponStatics_GetFireRate, ReturnValue) == 0x00000C, "Member 'WeaponStatics_GetFireRate::ReturnValue' has a wrong offset!");

// Function GbxWeapon.WeaponStatics.GetFireRateAccelPercent
// 0x0010 (0x0010 - 0x0000)
struct WeaponStatics_GetFireRateAccelPercent final
{
public:
	class AWeapon*                                Weapon;                                            // 0x0000(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         UseMode;                                           // 0x0008(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_9[0x3];                                        // 0x0009(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         ReturnValue;                                       // 0x000C(0x0004)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(WeaponStatics_GetFireRateAccelPercent) == 0x000008, "Wrong alignment on WeaponStatics_GetFireRateAccelPercent");
static_assert(sizeof(WeaponStatics_GetFireRateAccelPercent) == 0x000010, "Wrong size on WeaponStatics_GetFireRateAccelPercent");
static_assert(offsetof(WeaponStatics_GetFireRateAccelPercent, Weapon) == 0x000000, "Member 'WeaponStatics_GetFireRateAccelPercent::Weapon' has a wrong offset!");
static_assert(offsetof(WeaponStatics_GetFireRateAccelPercent, UseMode) == 0x000008, "Member 'WeaponStatics_GetFireRateAccelPercent::UseMode' has a wrong offset!");
static_assert(offsetof(WeaponStatics_GetFireRateAccelPercent, ReturnValue) == 0x00000C, "Member 'WeaponStatics_GetFireRateAccelPercent::ReturnValue' has a wrong offset!");

// Function GbxWeapon.WeaponStatics.GetLoadedAmmo
// 0x0010 (0x0010 - 0x0000)
struct WeaponStatics_GetLoadedAmmo final
{
public:
	class AWeapon*                                Weapon;                                            // 0x0000(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         UseMode;                                           // 0x0008(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_9[0x3];                                        // 0x0009(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	int32                                         ReturnValue;                                       // 0x000C(0x0004)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(WeaponStatics_GetLoadedAmmo) == 0x000008, "Wrong alignment on WeaponStatics_GetLoadedAmmo");
static_assert(sizeof(WeaponStatics_GetLoadedAmmo) == 0x000010, "Wrong size on WeaponStatics_GetLoadedAmmo");
static_assert(offsetof(WeaponStatics_GetLoadedAmmo, Weapon) == 0x000000, "Member 'WeaponStatics_GetLoadedAmmo::Weapon' has a wrong offset!");
static_assert(offsetof(WeaponStatics_GetLoadedAmmo, UseMode) == 0x000008, "Member 'WeaponStatics_GetLoadedAmmo::UseMode' has a wrong offset!");
static_assert(offsetof(WeaponStatics_GetLoadedAmmo, ReturnValue) == 0x00000C, "Member 'WeaponStatics_GetLoadedAmmo::ReturnValue' has a wrong offset!");

// Function GbxWeapon.WeaponStatics.GetMaxZoomFOVScale
// 0x0010 (0x0010 - 0x0000)
struct WeaponStatics_GetMaxZoomFOVScale final
{
public:
	class AWeapon*                                Weapon;                                            // 0x0000(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         UseMode;                                           // 0x0008(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_9[0x3];                                        // 0x0009(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         ReturnValue;                                       // 0x000C(0x0004)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(WeaponStatics_GetMaxZoomFOVScale) == 0x000008, "Wrong alignment on WeaponStatics_GetMaxZoomFOVScale");
static_assert(sizeof(WeaponStatics_GetMaxZoomFOVScale) == 0x000010, "Wrong size on WeaponStatics_GetMaxZoomFOVScale");
static_assert(offsetof(WeaponStatics_GetMaxZoomFOVScale, Weapon) == 0x000000, "Member 'WeaponStatics_GetMaxZoomFOVScale::Weapon' has a wrong offset!");
static_assert(offsetof(WeaponStatics_GetMaxZoomFOVScale, UseMode) == 0x000008, "Member 'WeaponStatics_GetMaxZoomFOVScale::UseMode' has a wrong offset!");
static_assert(offsetof(WeaponStatics_GetMaxZoomFOVScale, ReturnValue) == 0x00000C, "Member 'WeaponStatics_GetMaxZoomFOVScale::ReturnValue' has a wrong offset!");

// Function GbxWeapon.WeaponStatics.GetWeapon
// 0x0010 (0x0010 - 0x0000)
struct WeaponStatics_GetWeapon final
{
public:
	class UObject*                                Context;                                           // 0x0000(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class AWeapon*                                ReturnValue;                                       // 0x0008(0x0008)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(WeaponStatics_GetWeapon) == 0x000008, "Wrong alignment on WeaponStatics_GetWeapon");
static_assert(sizeof(WeaponStatics_GetWeapon) == 0x000010, "Wrong size on WeaponStatics_GetWeapon");
static_assert(offsetof(WeaponStatics_GetWeapon, Context) == 0x000000, "Member 'WeaponStatics_GetWeapon::Context' has a wrong offset!");
static_assert(offsetof(WeaponStatics_GetWeapon, ReturnValue) == 0x000008, "Member 'WeaponStatics_GetWeapon::ReturnValue' has a wrong offset!");

// Function GbxWeapon.WeaponStatics.GiveAmmo
// 0x0010 (0x0010 - 0x0000)
struct WeaponStatics_GiveAmmo final
{
public:
	class AWeapon*                                Weapon;                                            // 0x0000(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         Amount;                                            // 0x0008(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bLoaded;                                           // 0x000C(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bAsPercent;                                        // 0x000D(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_E[0x2];                                        // 0x000E(0x0002)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(WeaponStatics_GiveAmmo) == 0x000008, "Wrong alignment on WeaponStatics_GiveAmmo");
static_assert(sizeof(WeaponStatics_GiveAmmo) == 0x000010, "Wrong size on WeaponStatics_GiveAmmo");
static_assert(offsetof(WeaponStatics_GiveAmmo, Weapon) == 0x000000, "Member 'WeaponStatics_GiveAmmo::Weapon' has a wrong offset!");
static_assert(offsetof(WeaponStatics_GiveAmmo, Amount) == 0x000008, "Member 'WeaponStatics_GiveAmmo::Amount' has a wrong offset!");
static_assert(offsetof(WeaponStatics_GiveAmmo, bLoaded) == 0x00000C, "Member 'WeaponStatics_GiveAmmo::bLoaded' has a wrong offset!");
static_assert(offsetof(WeaponStatics_GiveAmmo, bAsPercent) == 0x00000D, "Member 'WeaponStatics_GiveAmmo::bAsPercent' has a wrong offset!");

// Function GbxWeapon.WeaponStatics.HideWeapon
// 0x0018 (0x0018 - 0x0000)
struct WeaponStatics_HideWeapon final
{
public:
	class AActor*                                 WeaponUser;                                        // 0x0000(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Slot;                                              // 0x0008(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_9[0x7];                                        // 0x0009(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	class FName                                   Reason;                                            // 0x0010(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(WeaponStatics_HideWeapon) == 0x000008, "Wrong alignment on WeaponStatics_HideWeapon");
static_assert(sizeof(WeaponStatics_HideWeapon) == 0x000018, "Wrong size on WeaponStatics_HideWeapon");
static_assert(offsetof(WeaponStatics_HideWeapon, WeaponUser) == 0x000000, "Member 'WeaponStatics_HideWeapon::WeaponUser' has a wrong offset!");
static_assert(offsetof(WeaponStatics_HideWeapon, Slot) == 0x000008, "Member 'WeaponStatics_HideWeapon::Slot' has a wrong offset!");
static_assert(offsetof(WeaponStatics_HideWeapon, Reason) == 0x000010, "Member 'WeaponStatics_HideWeapon::Reason' has a wrong offset!");

// Function GbxWeapon.WeaponStatics.HideWeapons
// 0x0010 (0x0010 - 0x0000)
struct WeaponStatics_HideWeapons final
{
public:
	class AActor*                                 WeaponUser;                                        // 0x0000(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   Reason;                                            // 0x0008(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(WeaponStatics_HideWeapons) == 0x000008, "Wrong alignment on WeaponStatics_HideWeapons");
static_assert(sizeof(WeaponStatics_HideWeapons) == 0x000010, "Wrong size on WeaponStatics_HideWeapons");
static_assert(offsetof(WeaponStatics_HideWeapons, WeaponUser) == 0x000000, "Member 'WeaponStatics_HideWeapons::WeaponUser' has a wrong offset!");
static_assert(offsetof(WeaponStatics_HideWeapons, Reason) == 0x000008, "Member 'WeaponStatics_HideWeapons::Reason' has a wrong offset!");

// Function GbxWeapon.WeaponStatics.K2_PlayWeaponHoldAction
// 0x0028 (0x0028 - 0x0000)
struct WeaponStatics_K2_PlayWeaponHoldAction final
{
public:
	class AActor*                                 Actor;                                             // 0x0000(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EWeaponActionType                             WeaponAction;                                      // 0x0008(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_9[0x7];                                        // 0x0009(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	class AWeapon*                                Weapon;                                            // 0x0010(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         PlayRate;                                          // 0x0018(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         Duration;                                          // 0x001C(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UGbxAction*                             ReturnValue;                                       // 0x0020(0x0008)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(WeaponStatics_K2_PlayWeaponHoldAction) == 0x000008, "Wrong alignment on WeaponStatics_K2_PlayWeaponHoldAction");
static_assert(sizeof(WeaponStatics_K2_PlayWeaponHoldAction) == 0x000028, "Wrong size on WeaponStatics_K2_PlayWeaponHoldAction");
static_assert(offsetof(WeaponStatics_K2_PlayWeaponHoldAction, Actor) == 0x000000, "Member 'WeaponStatics_K2_PlayWeaponHoldAction::Actor' has a wrong offset!");
static_assert(offsetof(WeaponStatics_K2_PlayWeaponHoldAction, WeaponAction) == 0x000008, "Member 'WeaponStatics_K2_PlayWeaponHoldAction::WeaponAction' has a wrong offset!");
static_assert(offsetof(WeaponStatics_K2_PlayWeaponHoldAction, Weapon) == 0x000010, "Member 'WeaponStatics_K2_PlayWeaponHoldAction::Weapon' has a wrong offset!");
static_assert(offsetof(WeaponStatics_K2_PlayWeaponHoldAction, PlayRate) == 0x000018, "Member 'WeaponStatics_K2_PlayWeaponHoldAction::PlayRate' has a wrong offset!");
static_assert(offsetof(WeaponStatics_K2_PlayWeaponHoldAction, Duration) == 0x00001C, "Member 'WeaponStatics_K2_PlayWeaponHoldAction::Duration' has a wrong offset!");
static_assert(offsetof(WeaponStatics_K2_PlayWeaponHoldAction, ReturnValue) == 0x000020, "Member 'WeaponStatics_K2_PlayWeaponHoldAction::ReturnValue' has a wrong offset!");

// Function GbxWeapon.WeaponStatics.K2_PlayWeaponHoldActionEx
// 0x00E8 (0x00E8 - 0x0000)
struct WeaponStatics_K2_PlayWeaponHoldActionEx final
{
public:
	class AActor*                                 Actor;                                             // 0x0000(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EWeaponActionType                             WeaponAction;                                      // 0x0008(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_9[0x7];                                        // 0x0009(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	class AWeapon*                                Weapon;                                            // 0x0010(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FActionState_Base                      ActionParams;                                      // 0x0018(0x00C8)(Parm, NativeAccessSpecifierPublic)
	class UGbxAction*                             ReturnValue;                                       // 0x00E0(0x0008)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(WeaponStatics_K2_PlayWeaponHoldActionEx) == 0x000008, "Wrong alignment on WeaponStatics_K2_PlayWeaponHoldActionEx");
static_assert(sizeof(WeaponStatics_K2_PlayWeaponHoldActionEx) == 0x0000E8, "Wrong size on WeaponStatics_K2_PlayWeaponHoldActionEx");
static_assert(offsetof(WeaponStatics_K2_PlayWeaponHoldActionEx, Actor) == 0x000000, "Member 'WeaponStatics_K2_PlayWeaponHoldActionEx::Actor' has a wrong offset!");
static_assert(offsetof(WeaponStatics_K2_PlayWeaponHoldActionEx, WeaponAction) == 0x000008, "Member 'WeaponStatics_K2_PlayWeaponHoldActionEx::WeaponAction' has a wrong offset!");
static_assert(offsetof(WeaponStatics_K2_PlayWeaponHoldActionEx, Weapon) == 0x000010, "Member 'WeaponStatics_K2_PlayWeaponHoldActionEx::Weapon' has a wrong offset!");
static_assert(offsetof(WeaponStatics_K2_PlayWeaponHoldActionEx, ActionParams) == 0x000018, "Member 'WeaponStatics_K2_PlayWeaponHoldActionEx::ActionParams' has a wrong offset!");
static_assert(offsetof(WeaponStatics_K2_PlayWeaponHoldActionEx, ReturnValue) == 0x0000E0, "Member 'WeaponStatics_K2_PlayWeaponHoldActionEx::ReturnValue' has a wrong offset!");

// Function GbxWeapon.WeaponStatics.RefillAmmo
// 0x0010 (0x0010 - 0x0000)
struct WeaponStatics_RefillAmmo final
{
public:
	class AWeapon*                                Weapon;                                            // 0x0000(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         Amount;                                            // 0x0008(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bAsPercent;                                        // 0x000C(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_D[0x3];                                        // 0x000D(0x0003)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(WeaponStatics_RefillAmmo) == 0x000008, "Wrong alignment on WeaponStatics_RefillAmmo");
static_assert(sizeof(WeaponStatics_RefillAmmo) == 0x000010, "Wrong size on WeaponStatics_RefillAmmo");
static_assert(offsetof(WeaponStatics_RefillAmmo, Weapon) == 0x000000, "Member 'WeaponStatics_RefillAmmo::Weapon' has a wrong offset!");
static_assert(offsetof(WeaponStatics_RefillAmmo, Amount) == 0x000008, "Member 'WeaponStatics_RefillAmmo::Amount' has a wrong offset!");
static_assert(offsetof(WeaponStatics_RefillAmmo, bAsPercent) == 0x00000C, "Member 'WeaponStatics_RefillAmmo::bAsPercent' has a wrong offset!");

// Function GbxWeapon.WeaponStatics.ResetVisibleAmmoState
// 0x0008 (0x0008 - 0x0000)
struct WeaponStatics_ResetVisibleAmmoState final
{
public:
	class AWeapon*                                Weapon;                                            // 0x0000(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(WeaponStatics_ResetVisibleAmmoState) == 0x000008, "Wrong alignment on WeaponStatics_ResetVisibleAmmoState");
static_assert(sizeof(WeaponStatics_ResetVisibleAmmoState) == 0x000008, "Wrong size on WeaponStatics_ResetVisibleAmmoState");
static_assert(offsetof(WeaponStatics_ResetVisibleAmmoState, Weapon) == 0x000000, "Member 'WeaponStatics_ResetVisibleAmmoState::Weapon' has a wrong offset!");

// Function GbxWeapon.WeaponStatics.SetVisibleAmmoState
// 0x0010 (0x0010 - 0x0000)
struct WeaponStatics_SetVisibleAmmoState final
{
public:
	class AWeapon*                                Weapon;                                            // 0x0000(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EWeaponVisibleAmmoState                       NewState;                                          // 0x0008(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_9[0x7];                                        // 0x0009(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(WeaponStatics_SetVisibleAmmoState) == 0x000008, "Wrong alignment on WeaponStatics_SetVisibleAmmoState");
static_assert(sizeof(WeaponStatics_SetVisibleAmmoState) == 0x000010, "Wrong size on WeaponStatics_SetVisibleAmmoState");
static_assert(offsetof(WeaponStatics_SetVisibleAmmoState, Weapon) == 0x000000, "Member 'WeaponStatics_SetVisibleAmmoState::Weapon' has a wrong offset!");
static_assert(offsetof(WeaponStatics_SetVisibleAmmoState, NewState) == 0x000008, "Member 'WeaponStatics_SetVisibleAmmoState::NewState' has a wrong offset!");

// Function GbxWeapon.WeaponStatics.SetVisibleAmmoUpdateMethod
// 0x0010 (0x0010 - 0x0000)
struct WeaponStatics_SetVisibleAmmoUpdateMethod final
{
public:
	class AWeapon*                                Weapon;                                            // 0x0000(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EWeaponVisibleAmmoUpdateMethod                NewUpdateMethod;                                   // 0x0008(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_9[0x7];                                        // 0x0009(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(WeaponStatics_SetVisibleAmmoUpdateMethod) == 0x000008, "Wrong alignment on WeaponStatics_SetVisibleAmmoUpdateMethod");
static_assert(sizeof(WeaponStatics_SetVisibleAmmoUpdateMethod) == 0x000010, "Wrong size on WeaponStatics_SetVisibleAmmoUpdateMethod");
static_assert(offsetof(WeaponStatics_SetVisibleAmmoUpdateMethod, Weapon) == 0x000000, "Member 'WeaponStatics_SetVisibleAmmoUpdateMethod::Weapon' has a wrong offset!");
static_assert(offsetof(WeaponStatics_SetVisibleAmmoUpdateMethod, NewUpdateMethod) == 0x000008, "Member 'WeaponStatics_SetVisibleAmmoUpdateMethod::NewUpdateMethod' has a wrong offset!");

// Function GbxWeapon.WeaponStatics.UnhideWeapon
// 0x0018 (0x0018 - 0x0000)
struct WeaponStatics_UnhideWeapon final
{
public:
	class AActor*                                 WeaponUser;                                        // 0x0000(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Slot;                                              // 0x0008(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_9[0x7];                                        // 0x0009(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	class FName                                   Reason;                                            // 0x0010(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(WeaponStatics_UnhideWeapon) == 0x000008, "Wrong alignment on WeaponStatics_UnhideWeapon");
static_assert(sizeof(WeaponStatics_UnhideWeapon) == 0x000018, "Wrong size on WeaponStatics_UnhideWeapon");
static_assert(offsetof(WeaponStatics_UnhideWeapon, WeaponUser) == 0x000000, "Member 'WeaponStatics_UnhideWeapon::WeaponUser' has a wrong offset!");
static_assert(offsetof(WeaponStatics_UnhideWeapon, Slot) == 0x000008, "Member 'WeaponStatics_UnhideWeapon::Slot' has a wrong offset!");
static_assert(offsetof(WeaponStatics_UnhideWeapon, Reason) == 0x000010, "Member 'WeaponStatics_UnhideWeapon::Reason' has a wrong offset!");

// Function GbxWeapon.WeaponStatics.UnhideWeapons
// 0x0010 (0x0010 - 0x0000)
struct WeaponStatics_UnhideWeapons final
{
public:
	class AActor*                                 WeaponUser;                                        // 0x0000(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   Reason;                                            // 0x0008(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(WeaponStatics_UnhideWeapons) == 0x000008, "Wrong alignment on WeaponStatics_UnhideWeapons");
static_assert(sizeof(WeaponStatics_UnhideWeapons) == 0x000010, "Wrong size on WeaponStatics_UnhideWeapons");
static_assert(offsetof(WeaponStatics_UnhideWeapons, WeaponUser) == 0x000000, "Member 'WeaponStatics_UnhideWeapons::WeaponUser' has a wrong offset!");
static_assert(offsetof(WeaponStatics_UnhideWeapons, Reason) == 0x000008, "Member 'WeaponStatics_UnhideWeapons::Reason' has a wrong offset!");

// Function GbxWeapon.WeaponStatics.UpdateVisibleAmmo
// 0x0008 (0x0008 - 0x0000)
struct WeaponStatics_UpdateVisibleAmmo final
{
public:
	class AWeapon*                                Weapon;                                            // 0x0000(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(WeaponStatics_UpdateVisibleAmmo) == 0x000008, "Wrong alignment on WeaponStatics_UpdateVisibleAmmo");
static_assert(sizeof(WeaponStatics_UpdateVisibleAmmo) == 0x000008, "Wrong size on WeaponStatics_UpdateVisibleAmmo");
static_assert(offsetof(WeaponStatics_UpdateVisibleAmmo, Weapon) == 0x000000, "Member 'WeaponStatics_UpdateVisibleAmmo::Weapon' has a wrong offset!");

// Function GbxWeapon.WeaponVisibleAmmoComponent.SetVisibleAmmoState
// 0x0001 (0x0001 - 0x0000)
struct WeaponVisibleAmmoComponent_SetVisibleAmmoState final
{
public:
	EWeaponVisibleAmmoState                       NewState;                                          // 0x0000(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(WeaponVisibleAmmoComponent_SetVisibleAmmoState) == 0x000001, "Wrong alignment on WeaponVisibleAmmoComponent_SetVisibleAmmoState");
static_assert(sizeof(WeaponVisibleAmmoComponent_SetVisibleAmmoState) == 0x000001, "Wrong size on WeaponVisibleAmmoComponent_SetVisibleAmmoState");
static_assert(offsetof(WeaponVisibleAmmoComponent_SetVisibleAmmoState, NewState) == 0x000000, "Member 'WeaponVisibleAmmoComponent_SetVisibleAmmoState::NewState' has a wrong offset!");

// Function GbxWeapon.WeaponVisibleAmmoComponent.SetVisibleAmmoUpdateMethod
// 0x0001 (0x0001 - 0x0000)
struct WeaponVisibleAmmoComponent_SetVisibleAmmoUpdateMethod final
{
public:
	EWeaponVisibleAmmoUpdateMethod                NewUpdateMethod;                                   // 0x0000(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(WeaponVisibleAmmoComponent_SetVisibleAmmoUpdateMethod) == 0x000001, "Wrong alignment on WeaponVisibleAmmoComponent_SetVisibleAmmoUpdateMethod");
static_assert(sizeof(WeaponVisibleAmmoComponent_SetVisibleAmmoUpdateMethod) == 0x000001, "Wrong size on WeaponVisibleAmmoComponent_SetVisibleAmmoUpdateMethod");
static_assert(offsetof(WeaponVisibleAmmoComponent_SetVisibleAmmoUpdateMethod, NewUpdateMethod) == 0x000000, "Member 'WeaponVisibleAmmoComponent_SetVisibleAmmoUpdateMethod::NewUpdateMethod' has a wrong offset!");

// Function GbxWeapon.WeaponVisibleAmmoComponent.UpdateBoneVisibility
// 0x0001 (0x0001 - 0x0000)
struct WeaponVisibleAmmoComponent_UpdateBoneVisibility final
{
public:
	bool                                          bForce;                                            // 0x0000(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(WeaponVisibleAmmoComponent_UpdateBoneVisibility) == 0x000001, "Wrong alignment on WeaponVisibleAmmoComponent_UpdateBoneVisibility");
static_assert(sizeof(WeaponVisibleAmmoComponent_UpdateBoneVisibility) == 0x000001, "Wrong size on WeaponVisibleAmmoComponent_UpdateBoneVisibility");
static_assert(offsetof(WeaponVisibleAmmoComponent_UpdateBoneVisibility, bForce) == 0x000000, "Member 'WeaponVisibleAmmoComponent_UpdateBoneVisibility::bForce' has a wrong offset!");

}

