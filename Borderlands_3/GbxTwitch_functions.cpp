#pragma once

/*
* SDK generated by Dumper-7
*
* https://github.com/Encryqed/Dumper-7
*/

// Package: GbxTwitch

#include "Basic.hpp"

#include "GbxTwitch_classes.hpp"
#include "GbxTwitch_parameters.hpp"


namespace SDK
{

// Function GbxTwitch.TwitchAPI.RequestTwitchStreams
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// int32                                   MaxNbStreams                                           (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class FString                           GameName                                               (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class FString                           UserLogin                                              (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class FString                           Language                                               (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// TDelegate<void(TArray<struct FTwitchStreamInfo>& Streams)>StreamInfoReceivedDelegate                             (Parm, ZeroConstructor, NoDestructor, NativeAccessSpecifierPublic)

void UTwitchAPI::RequestTwitchStreams(int32 MaxNbStreams, const class FString& GameName, const class FString& UserLogin, const class FString& Language, TDelegate<void(TArray<struct FTwitchStreamInfo>& Streams)> StreamInfoReceivedDelegate)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("TwitchAPI", "RequestTwitchStreams");

	Params::TwitchAPI_RequestTwitchStreams Parms{};

	Parms.MaxNbStreams = MaxNbStreams;
	Parms.GameName = std::move(GameName);
	Parms.UserLogin = std::move(UserLogin);
	Parms.Language = std::move(Language);
	Parms.StreamInfoReceivedDelegate = StreamInfoReceivedDelegate;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function GbxTwitch.TwitchIRCClient.ExitChatBot
// (Final, Native, Static, Public, BlueprintCallable)

void UTwitchIRCClient::ExitChatBot()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("TwitchIRCClient", "ExitChatBot");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function GbxTwitch.TwitchIRCClient.InitChatBot
// (Final, Native, Static, Public, BlueprintCallable)

void UTwitchIRCClient::InitChatBot()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("TwitchIRCClient", "InitChatBot");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function GbxTwitch.TwitchIRCClient.JoinChannel
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// class FString                           ChannelName                                            (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// TDelegate<void(struct FTwitchChannelMessage& ChannelUserMessage)>OnMessageReceived                                      (Parm, ZeroConstructor, NoDestructor, NativeAccessSpecifierPublic)

void UTwitchIRCClient::JoinChannel(const class FString& ChannelName, TDelegate<void(struct FTwitchChannelMessage& ChannelUserMessage)> OnMessageReceived)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("TwitchIRCClient", "JoinChannel");

	Params::TwitchIRCClient_JoinChannel Parms{};

	Parms.ChannelName = std::move(ChannelName);
	Parms.OnMessageReceived = OnMessageReceived;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function GbxTwitch.TwitchIRCClient.QuitChannel
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// class FString                           ChannelName                                            (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UTwitchIRCClient::QuitChannel(const class FString& ChannelName)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("TwitchIRCClient", "QuitChannel");

	Params::TwitchIRCClient_QuitChannel Parms{};

	Parms.ChannelName = std::move(ChannelName);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function GbxTwitch.TwitchIRCClient.SendChatMessage
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// class FString                           ChannelName                                            (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class FString                           Message                                                (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UTwitchIRCClient::SendChatMessage(const class FString& ChannelName, const class FString& Message)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("TwitchIRCClient", "SendChatMessage");

	Params::TwitchIRCClient_SendChatMessage Parms{};

	Parms.ChannelName = std::move(ChannelName);
	Parms.Message = std::move(Message);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}

}

