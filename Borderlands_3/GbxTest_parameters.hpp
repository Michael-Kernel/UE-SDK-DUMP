#pragma once

/*
* SDK generated by Dumper-7
*
* https://github.com/Encryqed/Dumper-7
*/

// Package: GbxTest

#include "Basic.hpp"

#include "GbxProbesCore_structs.hpp"
#include "Engine_structs.hpp"
#include "GbxTest_structs.hpp"
#include "GbxProbes_structs.hpp"
#include "CoreUObject_structs.hpp"
#include "InputCore_structs.hpp"


namespace SDK::Params
{

// Function GbxTest.AutomationMenuHelper.CreateAutomationMenuHelper
// 0x0018 (0x0018 - 0x0000)
struct AutomationMenuHelper_CreateAutomationMenuHelper final
{
public:
	class AGbxPlayerController*                   PlayerController;                                  // 0x0000(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          SimulateAllInputs;                                 // 0x0008(0x0001)(ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_9[0x7];                                        // 0x0009(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	class UAutomationMenuHelper*                  ReturnValue;                                       // 0x0010(0x0008)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(AutomationMenuHelper_CreateAutomationMenuHelper) == 0x000008, "Wrong alignment on AutomationMenuHelper_CreateAutomationMenuHelper");
static_assert(sizeof(AutomationMenuHelper_CreateAutomationMenuHelper) == 0x000018, "Wrong size on AutomationMenuHelper_CreateAutomationMenuHelper");
static_assert(offsetof(AutomationMenuHelper_CreateAutomationMenuHelper, PlayerController) == 0x000000, "Member 'AutomationMenuHelper_CreateAutomationMenuHelper::PlayerController' has a wrong offset!");
static_assert(offsetof(AutomationMenuHelper_CreateAutomationMenuHelper, SimulateAllInputs) == 0x000008, "Member 'AutomationMenuHelper_CreateAutomationMenuHelper::SimulateAllInputs' has a wrong offset!");
static_assert(offsetof(AutomationMenuHelper_CreateAutomationMenuHelper, ReturnValue) == 0x000010, "Member 'AutomationMenuHelper_CreateAutomationMenuHelper::ReturnValue' has a wrong offset!");

// Function GbxTest.AutomationMenuHelper.ActuateFocus
// 0x0001 (0x0001 - 0x0000)
struct AutomationMenuHelper_ActuateFocus final
{
public:
	EAutomationUIAction                           Action;                                            // 0x0000(0x0001)(ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(AutomationMenuHelper_ActuateFocus) == 0x000001, "Wrong alignment on AutomationMenuHelper_ActuateFocus");
static_assert(sizeof(AutomationMenuHelper_ActuateFocus) == 0x000001, "Wrong size on AutomationMenuHelper_ActuateFocus");
static_assert(offsetof(AutomationMenuHelper_ActuateFocus, Action) == 0x000000, "Member 'AutomationMenuHelper_ActuateFocus::Action' has a wrong offset!");

// Function GbxTest.AutomationMenuHelper.CurrentDepth
// 0x0004 (0x0004 - 0x0000)
struct AutomationMenuHelper_CurrentDepth final
{
public:
	int32                                         ReturnValue;                                       // 0x0000(0x0004)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(AutomationMenuHelper_CurrentDepth) == 0x000004, "Wrong alignment on AutomationMenuHelper_CurrentDepth");
static_assert(sizeof(AutomationMenuHelper_CurrentDepth) == 0x000004, "Wrong size on AutomationMenuHelper_CurrentDepth");
static_assert(offsetof(AutomationMenuHelper_CurrentDepth, ReturnValue) == 0x000000, "Member 'AutomationMenuHelper_CurrentDepth::ReturnValue' has a wrong offset!");

// Function GbxTest.AutomationMenuHelper.FocusInfo
// 0x0030 (0x0030 - 0x0000)
struct AutomationMenuHelper_FocusInfo final
{
public:
	struct FAutomationMenuFocusInfo               ReturnValue;                                       // 0x0000(0x0030)(Parm, OutParm, ReturnParm, NativeAccessSpecifierPublic)
};
static_assert(alignof(AutomationMenuHelper_FocusInfo) == 0x000008, "Wrong alignment on AutomationMenuHelper_FocusInfo");
static_assert(sizeof(AutomationMenuHelper_FocusInfo) == 0x000030, "Wrong size on AutomationMenuHelper_FocusInfo");
static_assert(offsetof(AutomationMenuHelper_FocusInfo, ReturnValue) == 0x000000, "Member 'AutomationMenuHelper_FocusInfo::ReturnValue' has a wrong offset!");

// Function GbxTest.AutomationMenuHelper.FocusName
// 0x0008 (0x0008 - 0x0000)
struct AutomationMenuHelper_FocusName final
{
public:
	class FName                                   ReturnValue;                                       // 0x0000(0x0008)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(AutomationMenuHelper_FocusName) == 0x000004, "Wrong alignment on AutomationMenuHelper_FocusName");
static_assert(sizeof(AutomationMenuHelper_FocusName) == 0x000008, "Wrong size on AutomationMenuHelper_FocusName");
static_assert(offsetof(AutomationMenuHelper_FocusName, ReturnValue) == 0x000000, "Member 'AutomationMenuHelper_FocusName::ReturnValue' has a wrong offset!");

// Function GbxTest.AutomationMenuHelper.HasOpenMenu
// 0x0001 (0x0001 - 0x0000)
struct AutomationMenuHelper_HasOpenMenu final
{
public:
	bool                                          ReturnValue;                                       // 0x0000(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(AutomationMenuHelper_HasOpenMenu) == 0x000001, "Wrong alignment on AutomationMenuHelper_HasOpenMenu");
static_assert(sizeof(AutomationMenuHelper_HasOpenMenu) == 0x000001, "Wrong size on AutomationMenuHelper_HasOpenMenu");
static_assert(offsetof(AutomationMenuHelper_HasOpenMenu, ReturnValue) == 0x000000, "Member 'AutomationMenuHelper_HasOpenMenu::ReturnValue' has a wrong offset!");

// Function GbxTest.AutomationMenuHelper.MenuName
// 0x0008 (0x0008 - 0x0000)
struct AutomationMenuHelper_MenuName final
{
public:
	class FName                                   ReturnValue;                                       // 0x0000(0x0008)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(AutomationMenuHelper_MenuName) == 0x000004, "Wrong alignment on AutomationMenuHelper_MenuName");
static_assert(sizeof(AutomationMenuHelper_MenuName) == 0x000008, "Wrong size on AutomationMenuHelper_MenuName");
static_assert(offsetof(AutomationMenuHelper_MenuName, ReturnValue) == 0x000000, "Member 'AutomationMenuHelper_MenuName::ReturnValue' has a wrong offset!");

// Function GbxTest.AutomationMenuHelper.NextFocus
// 0x0001 (0x0001 - 0x0000)
struct AutomationMenuHelper_NextFocus final
{
public:
	EAutomationUIDirection                        Direction;                                         // 0x0000(0x0001)(ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(AutomationMenuHelper_NextFocus) == 0x000001, "Wrong alignment on AutomationMenuHelper_NextFocus");
static_assert(sizeof(AutomationMenuHelper_NextFocus) == 0x000001, "Wrong size on AutomationMenuHelper_NextFocus");
static_assert(offsetof(AutomationMenuHelper_NextFocus, Direction) == 0x000000, "Member 'AutomationMenuHelper_NextFocus::Direction' has a wrong offset!");

// Function GbxTest.AutomationMenuHelper.NumPages
// 0x0004 (0x0004 - 0x0000)
struct AutomationMenuHelper_NumPages final
{
public:
	int32                                         ReturnValue;                                       // 0x0000(0x0004)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(AutomationMenuHelper_NumPages) == 0x000004, "Wrong alignment on AutomationMenuHelper_NumPages");
static_assert(sizeof(AutomationMenuHelper_NumPages) == 0x000004, "Wrong size on AutomationMenuHelper_NumPages");
static_assert(offsetof(AutomationMenuHelper_NumPages, ReturnValue) == 0x000000, "Member 'AutomationMenuHelper_NumPages::ReturnValue' has a wrong offset!");

// Function GbxTest.AutomationMenuHelper.PageName
// 0x0008 (0x0008 - 0x0000)
struct AutomationMenuHelper_PageName final
{
public:
	class FName                                   ReturnValue;                                       // 0x0000(0x0008)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(AutomationMenuHelper_PageName) == 0x000004, "Wrong alignment on AutomationMenuHelper_PageName");
static_assert(sizeof(AutomationMenuHelper_PageName) == 0x000008, "Wrong size on AutomationMenuHelper_PageName");
static_assert(offsetof(AutomationMenuHelper_PageName, ReturnValue) == 0x000000, "Member 'AutomationMenuHelper_PageName::ReturnValue' has a wrong offset!");

// Function GbxTest.AutomationUILibrary.ForceDisableTutorials
// 0x0001 (0x0001 - 0x0000)
struct AutomationUILibrary_ForceDisableTutorials final
{
public:
	bool                                          ForceDisable;                                      // 0x0000(0x0001)(ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(AutomationUILibrary_ForceDisableTutorials) == 0x000001, "Wrong alignment on AutomationUILibrary_ForceDisableTutorials");
static_assert(sizeof(AutomationUILibrary_ForceDisableTutorials) == 0x000001, "Wrong size on AutomationUILibrary_ForceDisableTutorials");
static_assert(offsetof(AutomationUILibrary_ForceDisableTutorials, ForceDisable) == 0x000000, "Member 'AutomationUILibrary_ForceDisableTutorials::ForceDisable' has a wrong offset!");

// Function GbxTest.PerfMapCapture.SavePerfMapCaptures
// 0x0050 (0x0050 - 0x0000)
struct PerfMapCapture_SavePerfMapCaptures final
{
public:
	class UObject*                                World;                                             // 0x0000(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FString                                 Path;                                              // 0x0008(0x0010)(Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         Density;                                           // 0x0018(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bLighting;                                         // 0x001C(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bSpecular;                                         // 0x001D(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1E[0x2];                                       // 0x001E(0x0002)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         Gamma;                                             // 0x0020(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         Width;                                             // 0x0024(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         Height;                                            // 0x0028(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         VolumeX;                                           // 0x002C(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         VolumeY;                                           // 0x0030(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         VolumeZ;                                           // 0x0034(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FString                                 OutputPattern;                                     // 0x0038(0x0010)(Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          ReturnValue;                                       // 0x0048(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_49[0x7];                                       // 0x0049(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(PerfMapCapture_SavePerfMapCaptures) == 0x000008, "Wrong alignment on PerfMapCapture_SavePerfMapCaptures");
static_assert(sizeof(PerfMapCapture_SavePerfMapCaptures) == 0x000050, "Wrong size on PerfMapCapture_SavePerfMapCaptures");
static_assert(offsetof(PerfMapCapture_SavePerfMapCaptures, World) == 0x000000, "Member 'PerfMapCapture_SavePerfMapCaptures::World' has a wrong offset!");
static_assert(offsetof(PerfMapCapture_SavePerfMapCaptures, Path) == 0x000008, "Member 'PerfMapCapture_SavePerfMapCaptures::Path' has a wrong offset!");
static_assert(offsetof(PerfMapCapture_SavePerfMapCaptures, Density) == 0x000018, "Member 'PerfMapCapture_SavePerfMapCaptures::Density' has a wrong offset!");
static_assert(offsetof(PerfMapCapture_SavePerfMapCaptures, bLighting) == 0x00001C, "Member 'PerfMapCapture_SavePerfMapCaptures::bLighting' has a wrong offset!");
static_assert(offsetof(PerfMapCapture_SavePerfMapCaptures, bSpecular) == 0x00001D, "Member 'PerfMapCapture_SavePerfMapCaptures::bSpecular' has a wrong offset!");
static_assert(offsetof(PerfMapCapture_SavePerfMapCaptures, Gamma) == 0x000020, "Member 'PerfMapCapture_SavePerfMapCaptures::Gamma' has a wrong offset!");
static_assert(offsetof(PerfMapCapture_SavePerfMapCaptures, Width) == 0x000024, "Member 'PerfMapCapture_SavePerfMapCaptures::Width' has a wrong offset!");
static_assert(offsetof(PerfMapCapture_SavePerfMapCaptures, Height) == 0x000028, "Member 'PerfMapCapture_SavePerfMapCaptures::Height' has a wrong offset!");
static_assert(offsetof(PerfMapCapture_SavePerfMapCaptures, VolumeX) == 0x00002C, "Member 'PerfMapCapture_SavePerfMapCaptures::VolumeX' has a wrong offset!");
static_assert(offsetof(PerfMapCapture_SavePerfMapCaptures, VolumeY) == 0x000030, "Member 'PerfMapCapture_SavePerfMapCaptures::VolumeY' has a wrong offset!");
static_assert(offsetof(PerfMapCapture_SavePerfMapCaptures, VolumeZ) == 0x000034, "Member 'PerfMapCapture_SavePerfMapCaptures::VolumeZ' has a wrong offset!");
static_assert(offsetof(PerfMapCapture_SavePerfMapCaptures, OutputPattern) == 0x000038, "Member 'PerfMapCapture_SavePerfMapCaptures::OutputPattern' has a wrong offset!");
static_assert(offsetof(PerfMapCapture_SavePerfMapCaptures, ReturnValue) == 0x000048, "Member 'PerfMapCapture_SavePerfMapCaptures::ReturnValue' has a wrong offset!");

// Function GbxTest.PerfMapCapture.SavePerfMapCapturesFromConfiguration
// 0x0080 (0x0080 - 0x0000)
struct PerfMapCapture_SavePerfMapCapturesFromConfiguration final
{
public:
	class UWorld*                                 World;                                             // 0x0000(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FString                                 Path;                                              // 0x0008(0x0010)(Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FMapParameters                         Configuration;                                     // 0x0018(0x0050)(Parm, NativeAccessSpecifierPublic)
	struct FLatentActionInfo                      LatentInfo;                                        // 0x0068(0x0018)(Parm, NoDestructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(PerfMapCapture_SavePerfMapCapturesFromConfiguration) == 0x000008, "Wrong alignment on PerfMapCapture_SavePerfMapCapturesFromConfiguration");
static_assert(sizeof(PerfMapCapture_SavePerfMapCapturesFromConfiguration) == 0x000080, "Wrong size on PerfMapCapture_SavePerfMapCapturesFromConfiguration");
static_assert(offsetof(PerfMapCapture_SavePerfMapCapturesFromConfiguration, World) == 0x000000, "Member 'PerfMapCapture_SavePerfMapCapturesFromConfiguration::World' has a wrong offset!");
static_assert(offsetof(PerfMapCapture_SavePerfMapCapturesFromConfiguration, Path) == 0x000008, "Member 'PerfMapCapture_SavePerfMapCapturesFromConfiguration::Path' has a wrong offset!");
static_assert(offsetof(PerfMapCapture_SavePerfMapCapturesFromConfiguration, Configuration) == 0x000018, "Member 'PerfMapCapture_SavePerfMapCapturesFromConfiguration::Configuration' has a wrong offset!");
static_assert(offsetof(PerfMapCapture_SavePerfMapCapturesFromConfiguration, LatentInfo) == 0x000068, "Member 'PerfMapCapture_SavePerfMapCapturesFromConfiguration::LatentInfo' has a wrong offset!");

// Function GbxTest.PerformanceSnapshotCollector.CreatePerformanceSnapshotCollector
// 0x0020 (0x0020 - 0x0000)
struct PerformanceSnapshotCollector_CreatePerformanceSnapshotCollector final
{
public:
	class FString                                 StatSection;                                       // 0x0000(0x0010)(Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	ESnapshotExecOutput                           ExecOut;                                           // 0x0010(0x0001)(Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_11[0x7];                                       // 0x0011(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	class UPerformanceSnapshotCollector*          ReturnValue;                                       // 0x0018(0x0008)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(PerformanceSnapshotCollector_CreatePerformanceSnapshotCollector) == 0x000008, "Wrong alignment on PerformanceSnapshotCollector_CreatePerformanceSnapshotCollector");
static_assert(sizeof(PerformanceSnapshotCollector_CreatePerformanceSnapshotCollector) == 0x000020, "Wrong size on PerformanceSnapshotCollector_CreatePerformanceSnapshotCollector");
static_assert(offsetof(PerformanceSnapshotCollector_CreatePerformanceSnapshotCollector, StatSection) == 0x000000, "Member 'PerformanceSnapshotCollector_CreatePerformanceSnapshotCollector::StatSection' has a wrong offset!");
static_assert(offsetof(PerformanceSnapshotCollector_CreatePerformanceSnapshotCollector, ExecOut) == 0x000010, "Member 'PerformanceSnapshotCollector_CreatePerformanceSnapshotCollector::ExecOut' has a wrong offset!");
static_assert(offsetof(PerformanceSnapshotCollector_CreatePerformanceSnapshotCollector, ReturnValue) == 0x000018, "Member 'PerformanceSnapshotCollector_CreatePerformanceSnapshotCollector::ReturnValue' has a wrong offset!");

// Function GbxTest.PerformanceSnapshotCollector.CollectProbeSnapshot
// 0x0068 (0x0068 - 0x0000)
struct PerformanceSnapshotCollector_CollectProbeSnapshot final
{
public:
	class UObject*                                WorldContextObject;                                // 0x0000(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FString                                 ReportContext;                                     // 0x0008(0x0010)(Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FGbxProbeId                            ProbeId;                                           // 0x0018(0x0018)(ConstParm, Parm, OutParm, ReferenceParm, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FString                                 Test;                                              // 0x0030(0x0010)(Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TArray<struct FGbxProbeExtraData>             ExtraDataArray;                                    // 0x0040(0x0010)(ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, NativeAccessSpecifierPublic)
	struct FLatentActionInfo                      LatentInfo;                                        // 0x0050(0x0018)(Parm, NoDestructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(PerformanceSnapshotCollector_CollectProbeSnapshot) == 0x000008, "Wrong alignment on PerformanceSnapshotCollector_CollectProbeSnapshot");
static_assert(sizeof(PerformanceSnapshotCollector_CollectProbeSnapshot) == 0x000068, "Wrong size on PerformanceSnapshotCollector_CollectProbeSnapshot");
static_assert(offsetof(PerformanceSnapshotCollector_CollectProbeSnapshot, WorldContextObject) == 0x000000, "Member 'PerformanceSnapshotCollector_CollectProbeSnapshot::WorldContextObject' has a wrong offset!");
static_assert(offsetof(PerformanceSnapshotCollector_CollectProbeSnapshot, ReportContext) == 0x000008, "Member 'PerformanceSnapshotCollector_CollectProbeSnapshot::ReportContext' has a wrong offset!");
static_assert(offsetof(PerformanceSnapshotCollector_CollectProbeSnapshot, ProbeId) == 0x000018, "Member 'PerformanceSnapshotCollector_CollectProbeSnapshot::ProbeId' has a wrong offset!");
static_assert(offsetof(PerformanceSnapshotCollector_CollectProbeSnapshot, Test) == 0x000030, "Member 'PerformanceSnapshotCollector_CollectProbeSnapshot::Test' has a wrong offset!");
static_assert(offsetof(PerformanceSnapshotCollector_CollectProbeSnapshot, ExtraDataArray) == 0x000040, "Member 'PerformanceSnapshotCollector_CollectProbeSnapshot::ExtraDataArray' has a wrong offset!");
static_assert(offsetof(PerformanceSnapshotCollector_CollectProbeSnapshot, LatentInfo) == 0x000050, "Member 'PerformanceSnapshotCollector_CollectProbeSnapshot::LatentInfo' has a wrong offset!");

// Function GbxTest.PerformanceSnapshotCollector.CollectSnapshot
// 0x0030 (0x0030 - 0x0000)
struct PerformanceSnapshotCollector_CollectSnapshot final
{
public:
	class UObject*                                WorldContextObject;                                // 0x0000(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FString                                 ReportContext;                                     // 0x0008(0x0010)(Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FLatentActionInfo                      LatentInfo;                                        // 0x0018(0x0018)(Parm, NoDestructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(PerformanceSnapshotCollector_CollectSnapshot) == 0x000008, "Wrong alignment on PerformanceSnapshotCollector_CollectSnapshot");
static_assert(sizeof(PerformanceSnapshotCollector_CollectSnapshot) == 0x000030, "Wrong size on PerformanceSnapshotCollector_CollectSnapshot");
static_assert(offsetof(PerformanceSnapshotCollector_CollectSnapshot, WorldContextObject) == 0x000000, "Member 'PerformanceSnapshotCollector_CollectSnapshot::WorldContextObject' has a wrong offset!");
static_assert(offsetof(PerformanceSnapshotCollector_CollectSnapshot, ReportContext) == 0x000008, "Member 'PerformanceSnapshotCollector_CollectSnapshot::ReportContext' has a wrong offset!");
static_assert(offsetof(PerformanceSnapshotCollector_CollectSnapshot, LatentInfo) == 0x000018, "Member 'PerformanceSnapshotCollector_CollectSnapshot::LatentInfo' has a wrong offset!");

// Function GbxTest.MatcherFunctionality.Empty
// 0x0001 (0x0001 - 0x0000)
struct MatcherFunctionality_Empty final
{
public:
	bool                                          ReturnValue;                                       // 0x0000(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(MatcherFunctionality_Empty) == 0x000001, "Wrong alignment on MatcherFunctionality_Empty");
static_assert(sizeof(MatcherFunctionality_Empty) == 0x000001, "Wrong size on MatcherFunctionality_Empty");
static_assert(offsetof(MatcherFunctionality_Empty, ReturnValue) == 0x000000, "Member 'MatcherFunctionality_Empty::ReturnValue' has a wrong offset!");

// Function GbxTest.MatcherFunctionality.GetAtIndex
// 0x0018 (0x0018 - 0x0000)
struct MatcherFunctionality_GetAtIndex final
{
public:
	int32                                         Index_0;                                           // 0x0000(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_4[0x4];                                        // 0x0004(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class FString                                 ReturnValue;                                       // 0x0008(0x0010)(Parm, OutParm, ZeroConstructor, ReturnParm, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(MatcherFunctionality_GetAtIndex) == 0x000008, "Wrong alignment on MatcherFunctionality_GetAtIndex");
static_assert(sizeof(MatcherFunctionality_GetAtIndex) == 0x000018, "Wrong size on MatcherFunctionality_GetAtIndex");
static_assert(offsetof(MatcherFunctionality_GetAtIndex, Index_0) == 0x000000, "Member 'MatcherFunctionality_GetAtIndex::Index_0' has a wrong offset!");
static_assert(offsetof(MatcherFunctionality_GetAtIndex, ReturnValue) == 0x000008, "Member 'MatcherFunctionality_GetAtIndex::ReturnValue' has a wrong offset!");

// Function GbxTest.MatcherFunctionality.GetLength
// 0x0004 (0x0004 - 0x0000)
struct MatcherFunctionality_GetLength final
{
public:
	int32                                         ReturnValue;                                       // 0x0000(0x0004)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(MatcherFunctionality_GetLength) == 0x000004, "Wrong alignment on MatcherFunctionality_GetLength");
static_assert(sizeof(MatcherFunctionality_GetLength) == 0x000004, "Wrong size on MatcherFunctionality_GetLength");
static_assert(offsetof(MatcherFunctionality_GetLength, ReturnValue) == 0x000000, "Member 'MatcherFunctionality_GetLength::ReturnValue' has a wrong offset!");

// Function GbxTest.MatcherFunctionality.GetMatch
// 0x0018 (0x0018 - 0x0000)
struct MatcherFunctionality_GetMatch final
{
public:
	int32                                         Index_0;                                           // 0x0000(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_4[0x4];                                        // 0x0004(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class FString                                 ReturnValue;                                       // 0x0008(0x0010)(Parm, OutParm, ZeroConstructor, ReturnParm, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(MatcherFunctionality_GetMatch) == 0x000008, "Wrong alignment on MatcherFunctionality_GetMatch");
static_assert(sizeof(MatcherFunctionality_GetMatch) == 0x000018, "Wrong size on MatcherFunctionality_GetMatch");
static_assert(offsetof(MatcherFunctionality_GetMatch, Index_0) == 0x000000, "Member 'MatcherFunctionality_GetMatch::Index_0' has a wrong offset!");
static_assert(offsetof(MatcherFunctionality_GetMatch, ReturnValue) == 0x000008, "Member 'MatcherFunctionality_GetMatch::ReturnValue' has a wrong offset!");

// Function GbxTest.MatcherFunctionality.GetPosition
// 0x0008 (0x0008 - 0x0000)
struct MatcherFunctionality_GetPosition final
{
public:
	int32                                         Start;                                             // 0x0000(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         ReturnValue;                                       // 0x0004(0x0004)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(MatcherFunctionality_GetPosition) == 0x000004, "Wrong alignment on MatcherFunctionality_GetPosition");
static_assert(sizeof(MatcherFunctionality_GetPosition) == 0x000008, "Wrong size on MatcherFunctionality_GetPosition");
static_assert(offsetof(MatcherFunctionality_GetPosition, Start) == 0x000000, "Member 'MatcherFunctionality_GetPosition::Start' has a wrong offset!");
static_assert(offsetof(MatcherFunctionality_GetPosition, ReturnValue) == 0x000004, "Member 'MatcherFunctionality_GetPosition::ReturnValue' has a wrong offset!");

// Function GbxTest.MatcherFunctionality.GetPrefix
// 0x0010 (0x0010 - 0x0000)
struct MatcherFunctionality_GetPrefix final
{
public:
	class FString                                 ReturnValue;                                       // 0x0000(0x0010)(Parm, OutParm, ZeroConstructor, ReturnParm, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(MatcherFunctionality_GetPrefix) == 0x000008, "Wrong alignment on MatcherFunctionality_GetPrefix");
static_assert(sizeof(MatcherFunctionality_GetPrefix) == 0x000010, "Wrong size on MatcherFunctionality_GetPrefix");
static_assert(offsetof(MatcherFunctionality_GetPrefix, ReturnValue) == 0x000000, "Member 'MatcherFunctionality_GetPrefix::ReturnValue' has a wrong offset!");

// Function GbxTest.MatcherFunctionality.GetSuffix
// 0x0010 (0x0010 - 0x0000)
struct MatcherFunctionality_GetSuffix final
{
public:
	class FString                                 ReturnValue;                                       // 0x0000(0x0010)(Parm, OutParm, ZeroConstructor, ReturnParm, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(MatcherFunctionality_GetSuffix) == 0x000008, "Wrong alignment on MatcherFunctionality_GetSuffix");
static_assert(sizeof(MatcherFunctionality_GetSuffix) == 0x000010, "Wrong size on MatcherFunctionality_GetSuffix");
static_assert(offsetof(MatcherFunctionality_GetSuffix, ReturnValue) == 0x000000, "Member 'MatcherFunctionality_GetSuffix::ReturnValue' has a wrong offset!");

// Function GbxTest.MatcherFunctionality.Ready
// 0x0001 (0x0001 - 0x0000)
struct MatcherFunctionality_Ready final
{
public:
	bool                                          ReturnValue;                                       // 0x0000(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(MatcherFunctionality_Ready) == 0x000001, "Wrong alignment on MatcherFunctionality_Ready");
static_assert(sizeof(MatcherFunctionality_Ready) == 0x000001, "Wrong size on MatcherFunctionality_Ready");
static_assert(offsetof(MatcherFunctionality_Ready, ReturnValue) == 0x000000, "Member 'MatcherFunctionality_Ready::ReturnValue' has a wrong offset!");

// Function GbxTest.MatcherFunctionality.Size
// 0x0004 (0x0004 - 0x0000)
struct MatcherFunctionality_Size final
{
public:
	int32                                         ReturnValue;                                       // 0x0000(0x0004)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(MatcherFunctionality_Size) == 0x000004, "Wrong alignment on MatcherFunctionality_Size");
static_assert(sizeof(MatcherFunctionality_Size) == 0x000004, "Wrong size on MatcherFunctionality_Size");
static_assert(offsetof(MatcherFunctionality_Size, ReturnValue) == 0x000000, "Member 'MatcherFunctionality_Size::ReturnValue' has a wrong offset!");

// Function GbxTest.RegexFunctionality.Assign
// 0x0038 (0x0038 - 0x0000)
struct RegexFunctionality_Assign final
{
public:
	struct FRegex                                 Regex_0;                                           // 0x0000(0x0028)(ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
	class FString                                 Pattern;                                           // 0x0028(0x0010)(Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(RegexFunctionality_Assign) == 0x000008, "Wrong alignment on RegexFunctionality_Assign");
static_assert(sizeof(RegexFunctionality_Assign) == 0x000038, "Wrong size on RegexFunctionality_Assign");
static_assert(offsetof(RegexFunctionality_Assign, Regex_0) == 0x000000, "Member 'RegexFunctionality_Assign::Regex_0' has a wrong offset!");
static_assert(offsetof(RegexFunctionality_Assign, Pattern) == 0x000028, "Member 'RegexFunctionality_Assign::Pattern' has a wrong offset!");

// Function GbxTest.RegexFunctionality.Assign2
// 0x0040 (0x0040 - 0x0000)
struct RegexFunctionality_Assign2 final
{
public:
	struct FRegex                                 Regex_0;                                           // 0x0000(0x0028)(ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
	class FString                                 Pattern;                                           // 0x0028(0x0010)(Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	ESyntaxOption                                 Flags_0;                                           // 0x0038(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_39[0x7];                                       // 0x0039(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(RegexFunctionality_Assign2) == 0x000008, "Wrong alignment on RegexFunctionality_Assign2");
static_assert(sizeof(RegexFunctionality_Assign2) == 0x000040, "Wrong size on RegexFunctionality_Assign2");
static_assert(offsetof(RegexFunctionality_Assign2, Regex_0) == 0x000000, "Member 'RegexFunctionality_Assign2::Regex_0' has a wrong offset!");
static_assert(offsetof(RegexFunctionality_Assign2, Pattern) == 0x000028, "Member 'RegexFunctionality_Assign2::Pattern' has a wrong offset!");
static_assert(offsetof(RegexFunctionality_Assign2, Flags_0) == 0x000038, "Member 'RegexFunctionality_Assign2::Flags_0' has a wrong offset!");

// Function GbxTest.RegexFunctionality.FindAll
// 0x0048 (0x0048 - 0x0000)
struct RegexFunctionality_FindAll final
{
public:
	struct FRegex                                 Regex_0;                                           // 0x0000(0x0028)(Parm, NativeAccessSpecifierPublic)
	class FString                                 String;                                            // 0x0028(0x0010)(Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TArray<class FString>                         Return;                                            // 0x0038(0x0010)(Parm, OutParm, ZeroConstructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(RegexFunctionality_FindAll) == 0x000008, "Wrong alignment on RegexFunctionality_FindAll");
static_assert(sizeof(RegexFunctionality_FindAll) == 0x000048, "Wrong size on RegexFunctionality_FindAll");
static_assert(offsetof(RegexFunctionality_FindAll, Regex_0) == 0x000000, "Member 'RegexFunctionality_FindAll::Regex_0' has a wrong offset!");
static_assert(offsetof(RegexFunctionality_FindAll, String) == 0x000028, "Member 'RegexFunctionality_FindAll::String' has a wrong offset!");
static_assert(offsetof(RegexFunctionality_FindAll, Return) == 0x000038, "Member 'RegexFunctionality_FindAll::Return' has a wrong offset!");

// Function GbxTest.RegexFunctionality.RegexMatch
// 0x0040 (0x0040 - 0x0000)
struct RegexFunctionality_RegexMatch final
{
public:
	struct FRegex                                 Regex_0;                                           // 0x0000(0x0028)(ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
	class FString                                 Input;                                             // 0x0028(0x0010)(Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          ReturnValue;                                       // 0x0038(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_39[0x7];                                       // 0x0039(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(RegexFunctionality_RegexMatch) == 0x000008, "Wrong alignment on RegexFunctionality_RegexMatch");
static_assert(sizeof(RegexFunctionality_RegexMatch) == 0x000040, "Wrong size on RegexFunctionality_RegexMatch");
static_assert(offsetof(RegexFunctionality_RegexMatch, Regex_0) == 0x000000, "Member 'RegexFunctionality_RegexMatch::Regex_0' has a wrong offset!");
static_assert(offsetof(RegexFunctionality_RegexMatch, Input) == 0x000028, "Member 'RegexFunctionality_RegexMatch::Input' has a wrong offset!");
static_assert(offsetof(RegexFunctionality_RegexMatch, ReturnValue) == 0x000038, "Member 'RegexFunctionality_RegexMatch::ReturnValue' has a wrong offset!");

// Function GbxTest.RegexFunctionality.RegexMatch2
// 0x0048 (0x0048 - 0x0000)
struct RegexFunctionality_RegexMatch2 final
{
public:
	struct FRegex                                 Regex_0;                                           // 0x0000(0x0028)(ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
	class UMatcherFunctionality*                  Matcher;                                           // 0x0028(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FString                                 Input;                                             // 0x0030(0x0010)(Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          ReturnValue;                                       // 0x0040(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_41[0x7];                                       // 0x0041(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(RegexFunctionality_RegexMatch2) == 0x000008, "Wrong alignment on RegexFunctionality_RegexMatch2");
static_assert(sizeof(RegexFunctionality_RegexMatch2) == 0x000048, "Wrong size on RegexFunctionality_RegexMatch2");
static_assert(offsetof(RegexFunctionality_RegexMatch2, Regex_0) == 0x000000, "Member 'RegexFunctionality_RegexMatch2::Regex_0' has a wrong offset!");
static_assert(offsetof(RegexFunctionality_RegexMatch2, Matcher) == 0x000028, "Member 'RegexFunctionality_RegexMatch2::Matcher' has a wrong offset!");
static_assert(offsetof(RegexFunctionality_RegexMatch2, Input) == 0x000030, "Member 'RegexFunctionality_RegexMatch2::Input' has a wrong offset!");
static_assert(offsetof(RegexFunctionality_RegexMatch2, ReturnValue) == 0x000040, "Member 'RegexFunctionality_RegexMatch2::ReturnValue' has a wrong offset!");

// Function GbxTest.RegexFunctionality.RegexRepleace
// 0x0058 (0x0058 - 0x0000)
struct RegexFunctionality_RegexRepleace final
{
public:
	struct FRegex                                 Regex_0;                                           // 0x0000(0x0028)(ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
	class FString                                 Input;                                             // 0x0028(0x0010)(Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FString                                 Repleacement;                                      // 0x0038(0x0010)(Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FString                                 ReturnValue;                                       // 0x0048(0x0010)(Parm, OutParm, ZeroConstructor, ReturnParm, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(RegexFunctionality_RegexRepleace) == 0x000008, "Wrong alignment on RegexFunctionality_RegexRepleace");
static_assert(sizeof(RegexFunctionality_RegexRepleace) == 0x000058, "Wrong size on RegexFunctionality_RegexRepleace");
static_assert(offsetof(RegexFunctionality_RegexRepleace, Regex_0) == 0x000000, "Member 'RegexFunctionality_RegexRepleace::Regex_0' has a wrong offset!");
static_assert(offsetof(RegexFunctionality_RegexRepleace, Input) == 0x000028, "Member 'RegexFunctionality_RegexRepleace::Input' has a wrong offset!");
static_assert(offsetof(RegexFunctionality_RegexRepleace, Repleacement) == 0x000038, "Member 'RegexFunctionality_RegexRepleace::Repleacement' has a wrong offset!");
static_assert(offsetof(RegexFunctionality_RegexRepleace, ReturnValue) == 0x000048, "Member 'RegexFunctionality_RegexRepleace::ReturnValue' has a wrong offset!");

// Function GbxTest.RegexFunctionality.RegexSearch
// 0x0048 (0x0048 - 0x0000)
struct RegexFunctionality_RegexSearch final
{
public:
	struct FRegex                                 Regex_0;                                           // 0x0000(0x0028)(ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
	class UMatcherFunctionality*                  Matcher;                                           // 0x0028(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FString                                 Input;                                             // 0x0030(0x0010)(Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          ReturnValue;                                       // 0x0040(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_41[0x7];                                       // 0x0041(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(RegexFunctionality_RegexSearch) == 0x000008, "Wrong alignment on RegexFunctionality_RegexSearch");
static_assert(sizeof(RegexFunctionality_RegexSearch) == 0x000048, "Wrong size on RegexFunctionality_RegexSearch");
static_assert(offsetof(RegexFunctionality_RegexSearch, Regex_0) == 0x000000, "Member 'RegexFunctionality_RegexSearch::Regex_0' has a wrong offset!");
static_assert(offsetof(RegexFunctionality_RegexSearch, Matcher) == 0x000028, "Member 'RegexFunctionality_RegexSearch::Matcher' has a wrong offset!");
static_assert(offsetof(RegexFunctionality_RegexSearch, Input) == 0x000030, "Member 'RegexFunctionality_RegexSearch::Input' has a wrong offset!");
static_assert(offsetof(RegexFunctionality_RegexSearch, ReturnValue) == 0x000040, "Member 'RegexFunctionality_RegexSearch::ReturnValue' has a wrong offset!");

// Function GbxTest.TestLibrary.AddArrayToCollection
// 0x0020 (0x0020 - 0x0000)
struct TestLibrary_AddArrayToCollection final
{
public:
	class FString                                 CollectionName;                                    // 0x0000(0x0010)(Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TArray<class FString>                         ObjectNames;                                       // 0x0010(0x0010)(Parm, OutParm, ZeroConstructor, ReferenceParm, NativeAccessSpecifierPublic)
};
static_assert(alignof(TestLibrary_AddArrayToCollection) == 0x000008, "Wrong alignment on TestLibrary_AddArrayToCollection");
static_assert(sizeof(TestLibrary_AddArrayToCollection) == 0x000020, "Wrong size on TestLibrary_AddArrayToCollection");
static_assert(offsetof(TestLibrary_AddArrayToCollection, CollectionName) == 0x000000, "Member 'TestLibrary_AddArrayToCollection::CollectionName' has a wrong offset!");
static_assert(offsetof(TestLibrary_AddArrayToCollection, ObjectNames) == 0x000010, "Member 'TestLibrary_AddArrayToCollection::ObjectNames' has a wrong offset!");

// Function GbxTest.TestLibrary.AddItemToCollection
// 0x0020 (0x0020 - 0x0000)
struct TestLibrary_AddItemToCollection final
{
public:
	class FString                                 CollectionName;                                    // 0x0000(0x0010)(Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FString                                 ObjectName;                                        // 0x0010(0x0010)(Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(TestLibrary_AddItemToCollection) == 0x000008, "Wrong alignment on TestLibrary_AddItemToCollection");
static_assert(sizeof(TestLibrary_AddItemToCollection) == 0x000020, "Wrong size on TestLibrary_AddItemToCollection");
static_assert(offsetof(TestLibrary_AddItemToCollection, CollectionName) == 0x000000, "Member 'TestLibrary_AddItemToCollection::CollectionName' has a wrong offset!");
static_assert(offsetof(TestLibrary_AddItemToCollection, ObjectName) == 0x000010, "Member 'TestLibrary_AddItemToCollection::ObjectName' has a wrong offset!");

// Function GbxTest.TestLibrary.CollectionExists
// 0x0018 (0x0018 - 0x0000)
struct TestLibrary_CollectionExists final
{
public:
	class FString                                 CollectionName;                                    // 0x0000(0x0010)(Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          ReturnValue;                                       // 0x0010(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_11[0x7];                                       // 0x0011(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(TestLibrary_CollectionExists) == 0x000008, "Wrong alignment on TestLibrary_CollectionExists");
static_assert(sizeof(TestLibrary_CollectionExists) == 0x000018, "Wrong size on TestLibrary_CollectionExists");
static_assert(offsetof(TestLibrary_CollectionExists, CollectionName) == 0x000000, "Member 'TestLibrary_CollectionExists::CollectionName' has a wrong offset!");
static_assert(offsetof(TestLibrary_CollectionExists, ReturnValue) == 0x000010, "Member 'TestLibrary_CollectionExists::ReturnValue' has a wrong offset!");

// Function GbxTest.TestLibrary.CollectionExistsEx
// 0x0018 (0x0018 - 0x0000)
struct TestLibrary_CollectionExistsEx final
{
public:
	class FString                                 CollectionName;                                    // 0x0000(0x0010)(Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	ECollectionType                               CollectionType;                                    // 0x0010(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          ReturnValue;                                       // 0x0011(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_12[0x6];                                       // 0x0012(0x0006)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(TestLibrary_CollectionExistsEx) == 0x000008, "Wrong alignment on TestLibrary_CollectionExistsEx");
static_assert(sizeof(TestLibrary_CollectionExistsEx) == 0x000018, "Wrong size on TestLibrary_CollectionExistsEx");
static_assert(offsetof(TestLibrary_CollectionExistsEx, CollectionName) == 0x000000, "Member 'TestLibrary_CollectionExistsEx::CollectionName' has a wrong offset!");
static_assert(offsetof(TestLibrary_CollectionExistsEx, CollectionType) == 0x000010, "Member 'TestLibrary_CollectionExistsEx::CollectionType' has a wrong offset!");
static_assert(offsetof(TestLibrary_CollectionExistsEx, ReturnValue) == 0x000011, "Member 'TestLibrary_CollectionExistsEx::ReturnValue' has a wrong offset!");

// Function GbxTest.TestLibrary.ContainsObjectTag
// 0x0038 (0x0038 - 0x0000)
struct TestLibrary_ContainsObjectTag final
{
public:
	TArray<struct FObjectTag>                     ObjectTags;                                        // 0x0000(0x0010)(Parm, OutParm, ZeroConstructor, ReferenceParm, NativeAccessSpecifierPublic)
	class FString                                 Category;                                          // 0x0010(0x0010)(Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FString                                 Name_0;                                            // 0x0020(0x0010)(Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bExactCategory;                                    // 0x0030(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, AdvancedDisplay, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bCaseSensitiveCategory;                            // 0x0031(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, AdvancedDisplay, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bExactName;                                        // 0x0032(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, AdvancedDisplay, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bCaseSensitiveName;                                // 0x0033(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, AdvancedDisplay, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          ReturnValue;                                       // 0x0034(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_35[0x3];                                       // 0x0035(0x0003)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(TestLibrary_ContainsObjectTag) == 0x000008, "Wrong alignment on TestLibrary_ContainsObjectTag");
static_assert(sizeof(TestLibrary_ContainsObjectTag) == 0x000038, "Wrong size on TestLibrary_ContainsObjectTag");
static_assert(offsetof(TestLibrary_ContainsObjectTag, ObjectTags) == 0x000000, "Member 'TestLibrary_ContainsObjectTag::ObjectTags' has a wrong offset!");
static_assert(offsetof(TestLibrary_ContainsObjectTag, Category) == 0x000010, "Member 'TestLibrary_ContainsObjectTag::Category' has a wrong offset!");
static_assert(offsetof(TestLibrary_ContainsObjectTag, Name_0) == 0x000020, "Member 'TestLibrary_ContainsObjectTag::Name_0' has a wrong offset!");
static_assert(offsetof(TestLibrary_ContainsObjectTag, bExactCategory) == 0x000030, "Member 'TestLibrary_ContainsObjectTag::bExactCategory' has a wrong offset!");
static_assert(offsetof(TestLibrary_ContainsObjectTag, bCaseSensitiveCategory) == 0x000031, "Member 'TestLibrary_ContainsObjectTag::bCaseSensitiveCategory' has a wrong offset!");
static_assert(offsetof(TestLibrary_ContainsObjectTag, bExactName) == 0x000032, "Member 'TestLibrary_ContainsObjectTag::bExactName' has a wrong offset!");
static_assert(offsetof(TestLibrary_ContainsObjectTag, bCaseSensitiveName) == 0x000033, "Member 'TestLibrary_ContainsObjectTag::bCaseSensitiveName' has a wrong offset!");
static_assert(offsetof(TestLibrary_ContainsObjectTag, ReturnValue) == 0x000034, "Member 'TestLibrary_ContainsObjectTag::ReturnValue' has a wrong offset!");

// Function GbxTest.TestLibrary.ContainsSubPath
// 0x0028 (0x0028 - 0x0000)
struct TestLibrary_ContainsSubPath final
{
public:
	class FString                                 Path;                                              // 0x0000(0x0010)(Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FString                                 SubPath;                                           // 0x0010(0x0010)(Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          ReturnValue;                                       // 0x0020(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_21[0x7];                                       // 0x0021(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(TestLibrary_ContainsSubPath) == 0x000008, "Wrong alignment on TestLibrary_ContainsSubPath");
static_assert(sizeof(TestLibrary_ContainsSubPath) == 0x000028, "Wrong size on TestLibrary_ContainsSubPath");
static_assert(offsetof(TestLibrary_ContainsSubPath, Path) == 0x000000, "Member 'TestLibrary_ContainsSubPath::Path' has a wrong offset!");
static_assert(offsetof(TestLibrary_ContainsSubPath, SubPath) == 0x000010, "Member 'TestLibrary_ContainsSubPath::SubPath' has a wrong offset!");
static_assert(offsetof(TestLibrary_ContainsSubPath, ReturnValue) == 0x000020, "Member 'TestLibrary_ContainsSubPath::ReturnValue' has a wrong offset!");

// Function GbxTest.TestLibrary.CreateLocalCollection
// 0x0030 (0x0030 - 0x0000)
struct TestLibrary_CreateLocalCollection final
{
public:
	class FString                                 CollectionName;                                    // 0x0000(0x0010)(Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FString                                 ParentName;                                        // 0x0010(0x0010)(Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FString                                 ReturnValue;                                       // 0x0020(0x0010)(Parm, OutParm, ZeroConstructor, ReturnParm, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(TestLibrary_CreateLocalCollection) == 0x000008, "Wrong alignment on TestLibrary_CreateLocalCollection");
static_assert(sizeof(TestLibrary_CreateLocalCollection) == 0x000030, "Wrong size on TestLibrary_CreateLocalCollection");
static_assert(offsetof(TestLibrary_CreateLocalCollection, CollectionName) == 0x000000, "Member 'TestLibrary_CreateLocalCollection::CollectionName' has a wrong offset!");
static_assert(offsetof(TestLibrary_CreateLocalCollection, ParentName) == 0x000010, "Member 'TestLibrary_CreateLocalCollection::ParentName' has a wrong offset!");
static_assert(offsetof(TestLibrary_CreateLocalCollection, ReturnValue) == 0x000020, "Member 'TestLibrary_CreateLocalCollection::ReturnValue' has a wrong offset!");

// Function GbxTest.TestLibrary.DiscoverAssets
// 0x0058 (0x0058 - 0x0000)
struct TestLibrary_DiscoverAssets final
{
public:
	TArray<class FString>                         PathNames;                                         // 0x0000(0x0010)(Parm, OutParm, ZeroConstructor, NativeAccessSpecifierPublic)
	TArray<class FString>                         PrettyNames;                                       // 0x0010(0x0010)(Parm, OutParm, ZeroConstructor, NativeAccessSpecifierPublic)
	TArray<class FString>                         Directories;                                       // 0x0020(0x0010)(Parm, ZeroConstructor, AdvancedDisplay, NativeAccessSpecifierPublic)
	TArray<class UClass*>                         Classes;                                           // 0x0030(0x0010)(Parm, ZeroConstructor, AdvancedDisplay, NativeAccessSpecifierPublic)
	TArray<class UClass*>                         ExcludeRecursiveClasses;                           // 0x0040(0x0010)(Parm, ZeroConstructor, AdvancedDisplay, NativeAccessSpecifierPublic)
	bool                                          bRecursiveDirectories;                             // 0x0050(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, AdvancedDisplay, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bRecursiveClasses;                                 // 0x0051(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, AdvancedDisplay, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_52[0x6];                                       // 0x0052(0x0006)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(TestLibrary_DiscoverAssets) == 0x000008, "Wrong alignment on TestLibrary_DiscoverAssets");
static_assert(sizeof(TestLibrary_DiscoverAssets) == 0x000058, "Wrong size on TestLibrary_DiscoverAssets");
static_assert(offsetof(TestLibrary_DiscoverAssets, PathNames) == 0x000000, "Member 'TestLibrary_DiscoverAssets::PathNames' has a wrong offset!");
static_assert(offsetof(TestLibrary_DiscoverAssets, PrettyNames) == 0x000010, "Member 'TestLibrary_DiscoverAssets::PrettyNames' has a wrong offset!");
static_assert(offsetof(TestLibrary_DiscoverAssets, Directories) == 0x000020, "Member 'TestLibrary_DiscoverAssets::Directories' has a wrong offset!");
static_assert(offsetof(TestLibrary_DiscoverAssets, Classes) == 0x000030, "Member 'TestLibrary_DiscoverAssets::Classes' has a wrong offset!");
static_assert(offsetof(TestLibrary_DiscoverAssets, ExcludeRecursiveClasses) == 0x000040, "Member 'TestLibrary_DiscoverAssets::ExcludeRecursiveClasses' has a wrong offset!");
static_assert(offsetof(TestLibrary_DiscoverAssets, bRecursiveDirectories) == 0x000050, "Member 'TestLibrary_DiscoverAssets::bRecursiveDirectories' has a wrong offset!");
static_assert(offsetof(TestLibrary_DiscoverAssets, bRecursiveClasses) == 0x000051, "Member 'TestLibrary_DiscoverAssets::bRecursiveClasses' has a wrong offset!");

// Function GbxTest.TestLibrary.FilterDiscoveredAssets
// 0x0080 (0x0080 - 0x0000)
struct TestLibrary_FilterDiscoveredAssets final
{
public:
	TArray<class FString>                         InPathNames;                                       // 0x0000(0x0010)(Parm, OutParm, ZeroConstructor, ReferenceParm, NativeAccessSpecifierPublic)
	TArray<class FString>                         InPrettyNames;                                     // 0x0010(0x0010)(Parm, OutParm, ZeroConstructor, ReferenceParm, NativeAccessSpecifierPublic)
	TArray<class FString>                         OutPathNames;                                      // 0x0020(0x0010)(Parm, OutParm, ZeroConstructor, NativeAccessSpecifierPublic)
	TArray<class FString>                         OutPrettyNames;                                    // 0x0030(0x0010)(Parm, OutParm, ZeroConstructor, NativeAccessSpecifierPublic)
	class FString                                 AssetNamePrefix;                                   // 0x0040(0x0010)(Parm, ZeroConstructor, AdvancedDisplay, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FString                                 AssetNamePostfix;                                  // 0x0050(0x0010)(Parm, ZeroConstructor, AdvancedDisplay, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FString                                 AssetNameContains;                                 // 0x0060(0x0010)(Parm, ZeroConstructor, AdvancedDisplay, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FString                                 AssetPathContains;                                 // 0x0070(0x0010)(Parm, ZeroConstructor, AdvancedDisplay, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(TestLibrary_FilterDiscoveredAssets) == 0x000008, "Wrong alignment on TestLibrary_FilterDiscoveredAssets");
static_assert(sizeof(TestLibrary_FilterDiscoveredAssets) == 0x000080, "Wrong size on TestLibrary_FilterDiscoveredAssets");
static_assert(offsetof(TestLibrary_FilterDiscoveredAssets, InPathNames) == 0x000000, "Member 'TestLibrary_FilterDiscoveredAssets::InPathNames' has a wrong offset!");
static_assert(offsetof(TestLibrary_FilterDiscoveredAssets, InPrettyNames) == 0x000010, "Member 'TestLibrary_FilterDiscoveredAssets::InPrettyNames' has a wrong offset!");
static_assert(offsetof(TestLibrary_FilterDiscoveredAssets, OutPathNames) == 0x000020, "Member 'TestLibrary_FilterDiscoveredAssets::OutPathNames' has a wrong offset!");
static_assert(offsetof(TestLibrary_FilterDiscoveredAssets, OutPrettyNames) == 0x000030, "Member 'TestLibrary_FilterDiscoveredAssets::OutPrettyNames' has a wrong offset!");
static_assert(offsetof(TestLibrary_FilterDiscoveredAssets, AssetNamePrefix) == 0x000040, "Member 'TestLibrary_FilterDiscoveredAssets::AssetNamePrefix' has a wrong offset!");
static_assert(offsetof(TestLibrary_FilterDiscoveredAssets, AssetNamePostfix) == 0x000050, "Member 'TestLibrary_FilterDiscoveredAssets::AssetNamePostfix' has a wrong offset!");
static_assert(offsetof(TestLibrary_FilterDiscoveredAssets, AssetNameContains) == 0x000060, "Member 'TestLibrary_FilterDiscoveredAssets::AssetNameContains' has a wrong offset!");
static_assert(offsetof(TestLibrary_FilterDiscoveredAssets, AssetPathContains) == 0x000070, "Member 'TestLibrary_FilterDiscoveredAssets::AssetPathContains' has a wrong offset!");

// Function GbxTest.TestLibrary.GetAssetName
// 0x0020 (0x0020 - 0x0000)
struct TestLibrary_GetAssetName final
{
public:
	class FString                                 AssetPath;                                         // 0x0000(0x0010)(Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FString                                 AssetName;                                         // 0x0010(0x0010)(Parm, OutParm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(TestLibrary_GetAssetName) == 0x000008, "Wrong alignment on TestLibrary_GetAssetName");
static_assert(sizeof(TestLibrary_GetAssetName) == 0x000020, "Wrong size on TestLibrary_GetAssetName");
static_assert(offsetof(TestLibrary_GetAssetName, AssetPath) == 0x000000, "Member 'TestLibrary_GetAssetName::AssetPath' has a wrong offset!");
static_assert(offsetof(TestLibrary_GetAssetName, AssetName) == 0x000010, "Member 'TestLibrary_GetAssetName::AssetName' has a wrong offset!");

// Function GbxTest.TestLibrary.GetAssetPath
// 0x0018 (0x0018 - 0x0000)
struct TestLibrary_GetAssetPath final
{
public:
	class UObject*                                Asset;                                             // 0x0000(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FString                                 AssetPath;                                         // 0x0008(0x0010)(Parm, OutParm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(TestLibrary_GetAssetPath) == 0x000008, "Wrong alignment on TestLibrary_GetAssetPath");
static_assert(sizeof(TestLibrary_GetAssetPath) == 0x000018, "Wrong size on TestLibrary_GetAssetPath");
static_assert(offsetof(TestLibrary_GetAssetPath, Asset) == 0x000000, "Member 'TestLibrary_GetAssetPath::Asset' has a wrong offset!");
static_assert(offsetof(TestLibrary_GetAssetPath, AssetPath) == 0x000008, "Member 'TestLibrary_GetAssetPath::AssetPath' has a wrong offset!");

// Function GbxTest.TestLibrary.GetObjectTags
// 0x0018 (0x0018 - 0x0000)
struct TestLibrary_GetObjectTags final
{
public:
	TArray<struct FObjectTag>                     ObjectTags;                                        // 0x0000(0x0010)(Parm, OutParm, ZeroConstructor, NativeAccessSpecifierPublic)
	class UObject*                                Asset;                                             // 0x0010(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(TestLibrary_GetObjectTags) == 0x000008, "Wrong alignment on TestLibrary_GetObjectTags");
static_assert(sizeof(TestLibrary_GetObjectTags) == 0x000018, "Wrong size on TestLibrary_GetObjectTags");
static_assert(offsetof(TestLibrary_GetObjectTags, ObjectTags) == 0x000000, "Member 'TestLibrary_GetObjectTags::ObjectTags' has a wrong offset!");
static_assert(offsetof(TestLibrary_GetObjectTags, Asset) == 0x000010, "Member 'TestLibrary_GetObjectTags::Asset' has a wrong offset!");

// Function GbxTest.TestLibrary.GetReferencedBlueprintClasses
// 0x0020 (0x0020 - 0x0000)
struct TestLibrary_GetReferencedBlueprintClasses final
{
public:
	class UObject*                                Object;                                            // 0x0000(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UClass*                                 Class_0;                                           // 0x0008(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TArray<class UClass*>                         Classes;                                           // 0x0010(0x0010)(Parm, OutParm, ZeroConstructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(TestLibrary_GetReferencedBlueprintClasses) == 0x000008, "Wrong alignment on TestLibrary_GetReferencedBlueprintClasses");
static_assert(sizeof(TestLibrary_GetReferencedBlueprintClasses) == 0x000020, "Wrong size on TestLibrary_GetReferencedBlueprintClasses");
static_assert(offsetof(TestLibrary_GetReferencedBlueprintClasses, Object) == 0x000000, "Member 'TestLibrary_GetReferencedBlueprintClasses::Object' has a wrong offset!");
static_assert(offsetof(TestLibrary_GetReferencedBlueprintClasses, Class_0) == 0x000008, "Member 'TestLibrary_GetReferencedBlueprintClasses::Class_0' has a wrong offset!");
static_assert(offsetof(TestLibrary_GetReferencedBlueprintClasses, Classes) == 0x000010, "Member 'TestLibrary_GetReferencedBlueprintClasses::Classes' has a wrong offset!");

// Function GbxTest.TestLibrary.GetTestDriversFromStrings
// 0x0030 (0x0030 - 0x0000)
struct TestLibrary_GetTestDriversFromStrings final
{
public:
	TArray<class FString>                         Strings;                                           // 0x0000(0x0010)(ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, NativeAccessSpecifierPublic)
	TArray<TSubclassOf<class AActor>>             TestDrivers;                                       // 0x0010(0x0010)(Parm, OutParm, ZeroConstructor, UObjectWrapper, NativeAccessSpecifierPublic)
	class FString                                 UndiscoveredItems;                                 // 0x0020(0x0010)(Parm, OutParm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(TestLibrary_GetTestDriversFromStrings) == 0x000008, "Wrong alignment on TestLibrary_GetTestDriversFromStrings");
static_assert(sizeof(TestLibrary_GetTestDriversFromStrings) == 0x000030, "Wrong size on TestLibrary_GetTestDriversFromStrings");
static_assert(offsetof(TestLibrary_GetTestDriversFromStrings, Strings) == 0x000000, "Member 'TestLibrary_GetTestDriversFromStrings::Strings' has a wrong offset!");
static_assert(offsetof(TestLibrary_GetTestDriversFromStrings, TestDrivers) == 0x000010, "Member 'TestLibrary_GetTestDriversFromStrings::TestDrivers' has a wrong offset!");
static_assert(offsetof(TestLibrary_GetTestDriversFromStrings, UndiscoveredItems) == 0x000020, "Member 'TestLibrary_GetTestDriversFromStrings::UndiscoveredItems' has a wrong offset!");

// Function GbxTest.TestLibrary.GetWorldForActor
// 0x0010 (0x0010 - 0x0000)
struct TestLibrary_GetWorldForActor final
{
public:
	class AActor*                                 Actor;                                             // 0x0000(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UWorld*                                 ReturnValue;                                       // 0x0008(0x0008)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(TestLibrary_GetWorldForActor) == 0x000008, "Wrong alignment on TestLibrary_GetWorldForActor");
static_assert(sizeof(TestLibrary_GetWorldForActor) == 0x000010, "Wrong size on TestLibrary_GetWorldForActor");
static_assert(offsetof(TestLibrary_GetWorldForActor, Actor) == 0x000000, "Member 'TestLibrary_GetWorldForActor::Actor' has a wrong offset!");
static_assert(offsetof(TestLibrary_GetWorldForActor, ReturnValue) == 0x000008, "Member 'TestLibrary_GetWorldForActor::ReturnValue' has a wrong offset!");

// Function GbxTest.TestLibrary.IsAssetInCollection
// 0x0028 (0x0028 - 0x0000)
struct TestLibrary_IsAssetInCollection final
{
public:
	class FString                                 CollectionName;                                    // 0x0000(0x0010)(Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FString                                 ObjectName;                                        // 0x0010(0x0010)(Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          ReturnValue;                                       // 0x0020(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_21[0x7];                                       // 0x0021(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(TestLibrary_IsAssetInCollection) == 0x000008, "Wrong alignment on TestLibrary_IsAssetInCollection");
static_assert(sizeof(TestLibrary_IsAssetInCollection) == 0x000028, "Wrong size on TestLibrary_IsAssetInCollection");
static_assert(offsetof(TestLibrary_IsAssetInCollection, CollectionName) == 0x000000, "Member 'TestLibrary_IsAssetInCollection::CollectionName' has a wrong offset!");
static_assert(offsetof(TestLibrary_IsAssetInCollection, ObjectName) == 0x000010, "Member 'TestLibrary_IsAssetInCollection::ObjectName' has a wrong offset!");
static_assert(offsetof(TestLibrary_IsAssetInCollection, ReturnValue) == 0x000020, "Member 'TestLibrary_IsAssetInCollection::ReturnValue' has a wrong offset!");

// Function GbxTest.TestLibrary.IsAssetInCollectionEx
// 0x0030 (0x0030 - 0x0000)
struct TestLibrary_IsAssetInCollectionEx final
{
public:
	class FString                                 CollectionName;                                    // 0x0000(0x0010)(Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	ECollectionType                               CollectionType;                                    // 0x0010(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_11[0x7];                                       // 0x0011(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	class FString                                 ObjectName;                                        // 0x0018(0x0010)(Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          ReturnValue;                                       // 0x0028(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_29[0x7];                                       // 0x0029(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(TestLibrary_IsAssetInCollectionEx) == 0x000008, "Wrong alignment on TestLibrary_IsAssetInCollectionEx");
static_assert(sizeof(TestLibrary_IsAssetInCollectionEx) == 0x000030, "Wrong size on TestLibrary_IsAssetInCollectionEx");
static_assert(offsetof(TestLibrary_IsAssetInCollectionEx, CollectionName) == 0x000000, "Member 'TestLibrary_IsAssetInCollectionEx::CollectionName' has a wrong offset!");
static_assert(offsetof(TestLibrary_IsAssetInCollectionEx, CollectionType) == 0x000010, "Member 'TestLibrary_IsAssetInCollectionEx::CollectionType' has a wrong offset!");
static_assert(offsetof(TestLibrary_IsAssetInCollectionEx, ObjectName) == 0x000018, "Member 'TestLibrary_IsAssetInCollectionEx::ObjectName' has a wrong offset!");
static_assert(offsetof(TestLibrary_IsAssetInCollectionEx, ReturnValue) == 0x000028, "Member 'TestLibrary_IsAssetInCollectionEx::ReturnValue' has a wrong offset!");

// Function GbxTest.TestLibrary.IsEditorSession
// 0x0001 (0x0001 - 0x0000)
struct TestLibrary_IsEditorSession final
{
public:
	bool                                          ReturnValue;                                       // 0x0000(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(TestLibrary_IsEditorSession) == 0x000001, "Wrong alignment on TestLibrary_IsEditorSession");
static_assert(sizeof(TestLibrary_IsEditorSession) == 0x000001, "Wrong size on TestLibrary_IsEditorSession");
static_assert(offsetof(TestLibrary_IsEditorSession, ReturnValue) == 0x000000, "Member 'TestLibrary_IsEditorSession::ReturnValue' has a wrong offset!");

// Function GbxTest.TestLibrary.LoadAsset
// 0x0018 (0x0018 - 0x0000)
struct TestLibrary_LoadAsset final
{
public:
	class FString                                 Path;                                              // 0x0000(0x0010)(Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UObject*                                Object;                                            // 0x0010(0x0008)(Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(TestLibrary_LoadAsset) == 0x000008, "Wrong alignment on TestLibrary_LoadAsset");
static_assert(sizeof(TestLibrary_LoadAsset) == 0x000018, "Wrong size on TestLibrary_LoadAsset");
static_assert(offsetof(TestLibrary_LoadAsset, Path) == 0x000000, "Member 'TestLibrary_LoadAsset::Path' has a wrong offset!");
static_assert(offsetof(TestLibrary_LoadAsset, Object) == 0x000010, "Member 'TestLibrary_LoadAsset::Object' has a wrong offset!");

// Function GbxTest.TestLibrary.LoadBlueprintAsset
// 0x0018 (0x0018 - 0x0000)
struct TestLibrary_LoadBlueprintAsset final
{
public:
	class FString                                 Path;                                              // 0x0000(0x0010)(Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UObject*                                Object;                                            // 0x0010(0x0008)(Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(TestLibrary_LoadBlueprintAsset) == 0x000008, "Wrong alignment on TestLibrary_LoadBlueprintAsset");
static_assert(sizeof(TestLibrary_LoadBlueprintAsset) == 0x000018, "Wrong size on TestLibrary_LoadBlueprintAsset");
static_assert(offsetof(TestLibrary_LoadBlueprintAsset, Path) == 0x000000, "Member 'TestLibrary_LoadBlueprintAsset::Path' has a wrong offset!");
static_assert(offsetof(TestLibrary_LoadBlueprintAsset, Object) == 0x000010, "Member 'TestLibrary_LoadBlueprintAsset::Object' has a wrong offset!");

// Function GbxTest.TestLibrary.MoveArrayCollection
// 0x0030 (0x0030 - 0x0000)
struct TestLibrary_MoveArrayCollection final
{
public:
	class FString                                 FromCollection;                                    // 0x0000(0x0010)(Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FString                                 ToCollection;                                      // 0x0010(0x0010)(Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TArray<class FString>                         ObjectNames;                                       // 0x0020(0x0010)(Parm, OutParm, ZeroConstructor, ReferenceParm, NativeAccessSpecifierPublic)
};
static_assert(alignof(TestLibrary_MoveArrayCollection) == 0x000008, "Wrong alignment on TestLibrary_MoveArrayCollection");
static_assert(sizeof(TestLibrary_MoveArrayCollection) == 0x000030, "Wrong size on TestLibrary_MoveArrayCollection");
static_assert(offsetof(TestLibrary_MoveArrayCollection, FromCollection) == 0x000000, "Member 'TestLibrary_MoveArrayCollection::FromCollection' has a wrong offset!");
static_assert(offsetof(TestLibrary_MoveArrayCollection, ToCollection) == 0x000010, "Member 'TestLibrary_MoveArrayCollection::ToCollection' has a wrong offset!");
static_assert(offsetof(TestLibrary_MoveArrayCollection, ObjectNames) == 0x000020, "Member 'TestLibrary_MoveArrayCollection::ObjectNames' has a wrong offset!");

// Function GbxTest.TestLibrary.MoveItemCollection
// 0x0030 (0x0030 - 0x0000)
struct TestLibrary_MoveItemCollection final
{
public:
	class FString                                 FromCollection;                                    // 0x0000(0x0010)(Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FString                                 ToCollection;                                      // 0x0010(0x0010)(Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FString                                 ObjectName;                                        // 0x0020(0x0010)(Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(TestLibrary_MoveItemCollection) == 0x000008, "Wrong alignment on TestLibrary_MoveItemCollection");
static_assert(sizeof(TestLibrary_MoveItemCollection) == 0x000030, "Wrong size on TestLibrary_MoveItemCollection");
static_assert(offsetof(TestLibrary_MoveItemCollection, FromCollection) == 0x000000, "Member 'TestLibrary_MoveItemCollection::FromCollection' has a wrong offset!");
static_assert(offsetof(TestLibrary_MoveItemCollection, ToCollection) == 0x000010, "Member 'TestLibrary_MoveItemCollection::ToCollection' has a wrong offset!");
static_assert(offsetof(TestLibrary_MoveItemCollection, ObjectName) == 0x000020, "Member 'TestLibrary_MoveItemCollection::ObjectName' has a wrong offset!");

// Function GbxTest.TestLibrary.ReadFromIni
// 0x0038 (0x0038 - 0x0000)
struct TestLibrary_ReadFromIni final
{
public:
	class FString                                 Section;                                           // 0x0000(0x0010)(ConstParm, Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FString                                 Key;                                               // 0x0010(0x0010)(ConstParm, Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TArray<class FString>                         Values;                                            // 0x0020(0x0010)(Parm, OutParm, ZeroConstructor, NativeAccessSpecifierPublic)
	bool                                          ReturnValue;                                       // 0x0030(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_31[0x7];                                       // 0x0031(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(TestLibrary_ReadFromIni) == 0x000008, "Wrong alignment on TestLibrary_ReadFromIni");
static_assert(sizeof(TestLibrary_ReadFromIni) == 0x000038, "Wrong size on TestLibrary_ReadFromIni");
static_assert(offsetof(TestLibrary_ReadFromIni, Section) == 0x000000, "Member 'TestLibrary_ReadFromIni::Section' has a wrong offset!");
static_assert(offsetof(TestLibrary_ReadFromIni, Key) == 0x000010, "Member 'TestLibrary_ReadFromIni::Key' has a wrong offset!");
static_assert(offsetof(TestLibrary_ReadFromIni, Values) == 0x000020, "Member 'TestLibrary_ReadFromIni::Values' has a wrong offset!");
static_assert(offsetof(TestLibrary_ReadFromIni, ReturnValue) == 0x000030, "Member 'TestLibrary_ReadFromIni::ReturnValue' has a wrong offset!");

// Function GbxTest.TestLibrary.RemoveArrayFromCollection
// 0x0020 (0x0020 - 0x0000)
struct TestLibrary_RemoveArrayFromCollection final
{
public:
	class FString                                 CollectionName;                                    // 0x0000(0x0010)(Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TArray<class FString>                         ObjectNames;                                       // 0x0010(0x0010)(Parm, OutParm, ZeroConstructor, ReferenceParm, NativeAccessSpecifierPublic)
};
static_assert(alignof(TestLibrary_RemoveArrayFromCollection) == 0x000008, "Wrong alignment on TestLibrary_RemoveArrayFromCollection");
static_assert(sizeof(TestLibrary_RemoveArrayFromCollection) == 0x000020, "Wrong size on TestLibrary_RemoveArrayFromCollection");
static_assert(offsetof(TestLibrary_RemoveArrayFromCollection, CollectionName) == 0x000000, "Member 'TestLibrary_RemoveArrayFromCollection::CollectionName' has a wrong offset!");
static_assert(offsetof(TestLibrary_RemoveArrayFromCollection, ObjectNames) == 0x000010, "Member 'TestLibrary_RemoveArrayFromCollection::ObjectNames' has a wrong offset!");

// Function GbxTest.TestLibrary.RemoveItemFromCollection
// 0x0020 (0x0020 - 0x0000)
struct TestLibrary_RemoveItemFromCollection final
{
public:
	class FString                                 CollectionName;                                    // 0x0000(0x0010)(Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FString                                 ObjectName;                                        // 0x0010(0x0010)(Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(TestLibrary_RemoveItemFromCollection) == 0x000008, "Wrong alignment on TestLibrary_RemoveItemFromCollection");
static_assert(sizeof(TestLibrary_RemoveItemFromCollection) == 0x000020, "Wrong size on TestLibrary_RemoveItemFromCollection");
static_assert(offsetof(TestLibrary_RemoveItemFromCollection, CollectionName) == 0x000000, "Member 'TestLibrary_RemoveItemFromCollection::CollectionName' has a wrong offset!");
static_assert(offsetof(TestLibrary_RemoveItemFromCollection, ObjectName) == 0x000010, "Member 'TestLibrary_RemoveItemFromCollection::ObjectName' has a wrong offset!");

// Function GbxTest.TestLibrary.SimulateInputAxis
// 0x0040 (0x0040 - 0x0000)
struct TestLibrary_SimulateInputAxis final
{
public:
	const class APlayerController*                PlayerController;                                  // 0x0000(0x0008)(ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FKey                                   Key;                                               // 0x0008(0x0018)(Parm, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         Delta;                                             // 0x0020(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         InterpTime;                                        // 0x0024(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FLatentActionInfo                      LatentInfo;                                        // 0x0028(0x0018)(Parm, NoDestructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(TestLibrary_SimulateInputAxis) == 0x000008, "Wrong alignment on TestLibrary_SimulateInputAxis");
static_assert(sizeof(TestLibrary_SimulateInputAxis) == 0x000040, "Wrong size on TestLibrary_SimulateInputAxis");
static_assert(offsetof(TestLibrary_SimulateInputAxis, PlayerController) == 0x000000, "Member 'TestLibrary_SimulateInputAxis::PlayerController' has a wrong offset!");
static_assert(offsetof(TestLibrary_SimulateInputAxis, Key) == 0x000008, "Member 'TestLibrary_SimulateInputAxis::Key' has a wrong offset!");
static_assert(offsetof(TestLibrary_SimulateInputAxis, Delta) == 0x000020, "Member 'TestLibrary_SimulateInputAxis::Delta' has a wrong offset!");
static_assert(offsetof(TestLibrary_SimulateInputAxis, InterpTime) == 0x000024, "Member 'TestLibrary_SimulateInputAxis::InterpTime' has a wrong offset!");
static_assert(offsetof(TestLibrary_SimulateInputAxis, LatentInfo) == 0x000028, "Member 'TestLibrary_SimulateInputAxis::LatentInfo' has a wrong offset!");

// Function GbxTest.TestLibrary.SimulateInputKey
// 0x0028 (0x0028 - 0x0000)
struct TestLibrary_SimulateInputKey final
{
public:
	const class APlayerController*                PlayerController;                                  // 0x0000(0x0008)(ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FKey                                   Key;                                               // 0x0008(0x0018)(Parm, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EInputEvent                                   EVENTTYPE;                                         // 0x0020(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_21[0x3];                                       // 0x0021(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         AmountDepressed;                                   // 0x0024(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(TestLibrary_SimulateInputKey) == 0x000008, "Wrong alignment on TestLibrary_SimulateInputKey");
static_assert(sizeof(TestLibrary_SimulateInputKey) == 0x000028, "Wrong size on TestLibrary_SimulateInputKey");
static_assert(offsetof(TestLibrary_SimulateInputKey, PlayerController) == 0x000000, "Member 'TestLibrary_SimulateInputKey::PlayerController' has a wrong offset!");
static_assert(offsetof(TestLibrary_SimulateInputKey, Key) == 0x000008, "Member 'TestLibrary_SimulateInputKey::Key' has a wrong offset!");
static_assert(offsetof(TestLibrary_SimulateInputKey, EVENTTYPE) == 0x000020, "Member 'TestLibrary_SimulateInputKey::EVENTTYPE' has a wrong offset!");
static_assert(offsetof(TestLibrary_SimulateInputKey, AmountDepressed) == 0x000024, "Member 'TestLibrary_SimulateInputKey::AmountDepressed' has a wrong offset!");

// Function GbxTest.TestLibrary.SortFloats
// 0x0028 (0x0028 - 0x0000)
struct TestLibrary_SortFloats final
{
public:
	TArray<float>                                 Values;                                            // 0x0000(0x0010)(Parm, ZeroConstructor, NativeAccessSpecifierPublic)
	bool                                          Descending;                                        // 0x0010(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_11[0x7];                                       // 0x0011(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<float>                                 ReturnValue;                                       // 0x0018(0x0010)(Parm, OutParm, ZeroConstructor, ReturnParm, NativeAccessSpecifierPublic)
};
static_assert(alignof(TestLibrary_SortFloats) == 0x000008, "Wrong alignment on TestLibrary_SortFloats");
static_assert(sizeof(TestLibrary_SortFloats) == 0x000028, "Wrong size on TestLibrary_SortFloats");
static_assert(offsetof(TestLibrary_SortFloats, Values) == 0x000000, "Member 'TestLibrary_SortFloats::Values' has a wrong offset!");
static_assert(offsetof(TestLibrary_SortFloats, Descending) == 0x000010, "Member 'TestLibrary_SortFloats::Descending' has a wrong offset!");
static_assert(offsetof(TestLibrary_SortFloats, ReturnValue) == 0x000018, "Member 'TestLibrary_SortFloats::ReturnValue' has a wrong offset!");

// Function GbxTest.TestLibrary.SortIntegers
// 0x0028 (0x0028 - 0x0000)
struct TestLibrary_SortIntegers final
{
public:
	TArray<int32>                                 Values;                                            // 0x0000(0x0010)(Parm, ZeroConstructor, NativeAccessSpecifierPublic)
	bool                                          Descending;                                        // 0x0010(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_11[0x7];                                       // 0x0011(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<int32>                                 ReturnValue;                                       // 0x0018(0x0010)(Parm, OutParm, ZeroConstructor, ReturnParm, NativeAccessSpecifierPublic)
};
static_assert(alignof(TestLibrary_SortIntegers) == 0x000008, "Wrong alignment on TestLibrary_SortIntegers");
static_assert(sizeof(TestLibrary_SortIntegers) == 0x000028, "Wrong size on TestLibrary_SortIntegers");
static_assert(offsetof(TestLibrary_SortIntegers, Values) == 0x000000, "Member 'TestLibrary_SortIntegers::Values' has a wrong offset!");
static_assert(offsetof(TestLibrary_SortIntegers, Descending) == 0x000010, "Member 'TestLibrary_SortIntegers::Descending' has a wrong offset!");
static_assert(offsetof(TestLibrary_SortIntegers, ReturnValue) == 0x000018, "Member 'TestLibrary_SortIntegers::ReturnValue' has a wrong offset!");

// Function GbxTest.TestLibrary.SortObjectsByName
// 0x0028 (0x0028 - 0x0000)
struct TestLibrary_SortObjectsByName final
{
public:
	TArray<class UObject*>                        Values;                                            // 0x0000(0x0010)(Parm, ZeroConstructor, NativeAccessSpecifierPublic)
	bool                                          Descending;                                        // 0x0010(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_11[0x7];                                       // 0x0011(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<class UObject*>                        ReturnValue;                                       // 0x0018(0x0010)(Parm, OutParm, ZeroConstructor, ReturnParm, NativeAccessSpecifierPublic)
};
static_assert(alignof(TestLibrary_SortObjectsByName) == 0x000008, "Wrong alignment on TestLibrary_SortObjectsByName");
static_assert(sizeof(TestLibrary_SortObjectsByName) == 0x000028, "Wrong size on TestLibrary_SortObjectsByName");
static_assert(offsetof(TestLibrary_SortObjectsByName, Values) == 0x000000, "Member 'TestLibrary_SortObjectsByName::Values' has a wrong offset!");
static_assert(offsetof(TestLibrary_SortObjectsByName, Descending) == 0x000010, "Member 'TestLibrary_SortObjectsByName::Descending' has a wrong offset!");
static_assert(offsetof(TestLibrary_SortObjectsByName, ReturnValue) == 0x000018, "Member 'TestLibrary_SortObjectsByName::ReturnValue' has a wrong offset!");

// Function GbxTest.TestLibrary.SortStrings
// 0x0028 (0x0028 - 0x0000)
struct TestLibrary_SortStrings final
{
public:
	TArray<class FString>                         Values;                                            // 0x0000(0x0010)(Parm, ZeroConstructor, NativeAccessSpecifierPublic)
	bool                                          Descending;                                        // 0x0010(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_11[0x7];                                       // 0x0011(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<class FString>                         ReturnValue;                                       // 0x0018(0x0010)(Parm, OutParm, ZeroConstructor, ReturnParm, NativeAccessSpecifierPublic)
};
static_assert(alignof(TestLibrary_SortStrings) == 0x000008, "Wrong alignment on TestLibrary_SortStrings");
static_assert(sizeof(TestLibrary_SortStrings) == 0x000028, "Wrong size on TestLibrary_SortStrings");
static_assert(offsetof(TestLibrary_SortStrings, Values) == 0x000000, "Member 'TestLibrary_SortStrings::Values' has a wrong offset!");
static_assert(offsetof(TestLibrary_SortStrings, Descending) == 0x000010, "Member 'TestLibrary_SortStrings::Descending' has a wrong offset!");
static_assert(offsetof(TestLibrary_SortStrings, ReturnValue) == 0x000018, "Member 'TestLibrary_SortStrings::ReturnValue' has a wrong offset!");

// Function GbxTest.TestLibrary.TakeScreenshot
// 0x0020 (0x0020 - 0x0000)
struct TestLibrary_TakeScreenshot final
{
public:
	class FString                                 CustomFilename;                                    // 0x0000(0x0010)(ConstParm, Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector2D                              OverrideResolution;                                // 0x0010(0x0008)(ConstParm, Parm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          ShowUI;                                            // 0x0018(0x0001)(ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          AddUniqueSuffix;                                   // 0x0019(0x0001)(ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1A[0x6];                                       // 0x001A(0x0006)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(TestLibrary_TakeScreenshot) == 0x000008, "Wrong alignment on TestLibrary_TakeScreenshot");
static_assert(sizeof(TestLibrary_TakeScreenshot) == 0x000020, "Wrong size on TestLibrary_TakeScreenshot");
static_assert(offsetof(TestLibrary_TakeScreenshot, CustomFilename) == 0x000000, "Member 'TestLibrary_TakeScreenshot::CustomFilename' has a wrong offset!");
static_assert(offsetof(TestLibrary_TakeScreenshot, OverrideResolution) == 0x000010, "Member 'TestLibrary_TakeScreenshot::OverrideResolution' has a wrong offset!");
static_assert(offsetof(TestLibrary_TakeScreenshot, ShowUI) == 0x000018, "Member 'TestLibrary_TakeScreenshot::ShowUI' has a wrong offset!");
static_assert(offsetof(TestLibrary_TakeScreenshot, AddUniqueSuffix) == 0x000019, "Member 'TestLibrary_TakeScreenshot::AddUniqueSuffix' has a wrong offset!");

// Function GbxTest.TestLibraryContent.ContentAuditSingleObject
// 0x0018 (0x0018 - 0x0000)
struct TestLibraryContent_ContentAuditSingleObject final
{
public:
	class UObject*                                Asset;                                             // 0x0000(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TArray<class FString>                         ReturnValue;                                       // 0x0008(0x0010)(Parm, OutParm, ZeroConstructor, ReturnParm, NativeAccessSpecifierPublic)
};
static_assert(alignof(TestLibraryContent_ContentAuditSingleObject) == 0x000008, "Wrong alignment on TestLibraryContent_ContentAuditSingleObject");
static_assert(sizeof(TestLibraryContent_ContentAuditSingleObject) == 0x000018, "Wrong size on TestLibraryContent_ContentAuditSingleObject");
static_assert(offsetof(TestLibraryContent_ContentAuditSingleObject, Asset) == 0x000000, "Member 'TestLibraryContent_ContentAuditSingleObject::Asset' has a wrong offset!");
static_assert(offsetof(TestLibraryContent_ContentAuditSingleObject, ReturnValue) == 0x000008, "Member 'TestLibraryContent_ContentAuditSingleObject::ReturnValue' has a wrong offset!");

// Function GbxTest.TestLibraryContent.GetAllPersistentGameMaps
// 0x0018 (0x0018 - 0x0000)
struct TestLibraryContent_GetAllPersistentGameMaps final
{
public:
	TArray<class FString>                         OutMapNames;                                       // 0x0000(0x0010)(Parm, OutParm, ZeroConstructor, NativeAccessSpecifierPublic)
	bool                                          ShortNamesOnly;                                    // 0x0010(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_11[0x7];                                       // 0x0011(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(TestLibraryContent_GetAllPersistentGameMaps) == 0x000008, "Wrong alignment on TestLibraryContent_GetAllPersistentGameMaps");
static_assert(sizeof(TestLibraryContent_GetAllPersistentGameMaps) == 0x000018, "Wrong size on TestLibraryContent_GetAllPersistentGameMaps");
static_assert(offsetof(TestLibraryContent_GetAllPersistentGameMaps, OutMapNames) == 0x000000, "Member 'TestLibraryContent_GetAllPersistentGameMaps::OutMapNames' has a wrong offset!");
static_assert(offsetof(TestLibraryContent_GetAllPersistentGameMaps, ShortNamesOnly) == 0x000010, "Member 'TestLibraryContent_GetAllPersistentGameMaps::ShortNamesOnly' has a wrong offset!");

// Function GbxTest.TestLibraryContent.GetTestInfoMaterial
// 0x0028 (0x0028 - 0x0000)
struct TestLibraryContent_GetTestInfoMaterial final
{
public:
	const class UMaterial*                        Asset;                                             // 0x0000(0x0008)(ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FTestInfoMaterial                      Info;                                              // 0x0008(0x0020)(Parm, OutParm, NativeAccessSpecifierPublic)
};
static_assert(alignof(TestLibraryContent_GetTestInfoMaterial) == 0x000008, "Wrong alignment on TestLibraryContent_GetTestInfoMaterial");
static_assert(sizeof(TestLibraryContent_GetTestInfoMaterial) == 0x000028, "Wrong size on TestLibraryContent_GetTestInfoMaterial");
static_assert(offsetof(TestLibraryContent_GetTestInfoMaterial, Asset) == 0x000000, "Member 'TestLibraryContent_GetTestInfoMaterial::Asset' has a wrong offset!");
static_assert(offsetof(TestLibraryContent_GetTestInfoMaterial, Info) == 0x000008, "Member 'TestLibraryContent_GetTestInfoMaterial::Info' has a wrong offset!");

// Function GbxTest.TestLibraryContent.GetTestInfoParticleEmitter
// 0x0040 (0x0040 - 0x0000)
struct TestLibraryContent_GetTestInfoParticleEmitter final
{
public:
	const class UParticleSystem*                  Asset;                                             // 0x0000(0x0008)(ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         EmitterIndex;                                      // 0x0008(0x0004)(ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_C[0x4];                                        // 0x000C(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	struct FTestInfoParticleEmitter               Info;                                              // 0x0010(0x0030)(Parm, OutParm, NoDestructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(TestLibraryContent_GetTestInfoParticleEmitter) == 0x000008, "Wrong alignment on TestLibraryContent_GetTestInfoParticleEmitter");
static_assert(sizeof(TestLibraryContent_GetTestInfoParticleEmitter) == 0x000040, "Wrong size on TestLibraryContent_GetTestInfoParticleEmitter");
static_assert(offsetof(TestLibraryContent_GetTestInfoParticleEmitter, Asset) == 0x000000, "Member 'TestLibraryContent_GetTestInfoParticleEmitter::Asset' has a wrong offset!");
static_assert(offsetof(TestLibraryContent_GetTestInfoParticleEmitter, EmitterIndex) == 0x000008, "Member 'TestLibraryContent_GetTestInfoParticleEmitter::EmitterIndex' has a wrong offset!");
static_assert(offsetof(TestLibraryContent_GetTestInfoParticleEmitter, Info) == 0x000010, "Member 'TestLibraryContent_GetTestInfoParticleEmitter::Info' has a wrong offset!");

// Function GbxTest.TestLibraryContent.GetTestInfoParticleSystem
// 0x0068 (0x0068 - 0x0000)
struct TestLibraryContent_GetTestInfoParticleSystem final
{
public:
	const class UParticleSystem*                  Asset;                                             // 0x0000(0x0008)(ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FTestInfoParticleSystem                Info;                                              // 0x0008(0x0060)(Parm, OutParm, NativeAccessSpecifierPublic)
};
static_assert(alignof(TestLibraryContent_GetTestInfoParticleSystem) == 0x000008, "Wrong alignment on TestLibraryContent_GetTestInfoParticleSystem");
static_assert(sizeof(TestLibraryContent_GetTestInfoParticleSystem) == 0x000068, "Wrong size on TestLibraryContent_GetTestInfoParticleSystem");
static_assert(offsetof(TestLibraryContent_GetTestInfoParticleSystem, Asset) == 0x000000, "Member 'TestLibraryContent_GetTestInfoParticleSystem::Asset' has a wrong offset!");
static_assert(offsetof(TestLibraryContent_GetTestInfoParticleSystem, Info) == 0x000008, "Member 'TestLibraryContent_GetTestInfoParticleSystem::Info' has a wrong offset!");

// Function GbxTest.TestLibraryContent.GetTestInfoSkeletalMesh
// 0x0068 (0x0068 - 0x0000)
struct TestLibraryContent_GetTestInfoSkeletalMesh final
{
public:
	const class USkeletalMesh*                    Asset;                                             // 0x0000(0x0008)(ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FTestInfoMeshLODSummary                LODSummary;                                        // 0x0008(0x0024)(Parm, OutParm, NoDestructor, NativeAccessSpecifierPublic)
	struct FTestInfoMesh                          Mesh;                                              // 0x002C(0x0024)(Parm, OutParm, NoDestructor, NativeAccessSpecifierPublic)
	struct FTestInfoSkeletalMesh                  SkeletalMesh;                                      // 0x0050(0x0018)(Parm, OutParm, NativeAccessSpecifierPublic)
};
static_assert(alignof(TestLibraryContent_GetTestInfoSkeletalMesh) == 0x000008, "Wrong alignment on TestLibraryContent_GetTestInfoSkeletalMesh");
static_assert(sizeof(TestLibraryContent_GetTestInfoSkeletalMesh) == 0x000068, "Wrong size on TestLibraryContent_GetTestInfoSkeletalMesh");
static_assert(offsetof(TestLibraryContent_GetTestInfoSkeletalMesh, Asset) == 0x000000, "Member 'TestLibraryContent_GetTestInfoSkeletalMesh::Asset' has a wrong offset!");
static_assert(offsetof(TestLibraryContent_GetTestInfoSkeletalMesh, LODSummary) == 0x000008, "Member 'TestLibraryContent_GetTestInfoSkeletalMesh::LODSummary' has a wrong offset!");
static_assert(offsetof(TestLibraryContent_GetTestInfoSkeletalMesh, Mesh) == 0x00002C, "Member 'TestLibraryContent_GetTestInfoSkeletalMesh::Mesh' has a wrong offset!");
static_assert(offsetof(TestLibraryContent_GetTestInfoSkeletalMesh, SkeletalMesh) == 0x000050, "Member 'TestLibraryContent_GetTestInfoSkeletalMesh::SkeletalMesh' has a wrong offset!");

// Function GbxTest.TestLibraryContent.GetTestInfoSkeletalMeshLOD
// 0x0028 (0x0028 - 0x0000)
struct TestLibraryContent_GetTestInfoSkeletalMeshLOD final
{
public:
	const class USkeletalMesh*                    Asset;                                             // 0x0000(0x0008)(ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         LODIndex;                                          // 0x0008(0x0004)(ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FTestInfoMeshLOD                       Info;                                              // 0x000C(0x001C)(Parm, OutParm, NoDestructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(TestLibraryContent_GetTestInfoSkeletalMeshLOD) == 0x000008, "Wrong alignment on TestLibraryContent_GetTestInfoSkeletalMeshLOD");
static_assert(sizeof(TestLibraryContent_GetTestInfoSkeletalMeshLOD) == 0x000028, "Wrong size on TestLibraryContent_GetTestInfoSkeletalMeshLOD");
static_assert(offsetof(TestLibraryContent_GetTestInfoSkeletalMeshLOD, Asset) == 0x000000, "Member 'TestLibraryContent_GetTestInfoSkeletalMeshLOD::Asset' has a wrong offset!");
static_assert(offsetof(TestLibraryContent_GetTestInfoSkeletalMeshLOD, LODIndex) == 0x000008, "Member 'TestLibraryContent_GetTestInfoSkeletalMeshLOD::LODIndex' has a wrong offset!");
static_assert(offsetof(TestLibraryContent_GetTestInfoSkeletalMeshLOD, Info) == 0x00000C, "Member 'TestLibraryContent_GetTestInfoSkeletalMeshLOD::Info' has a wrong offset!");

// Function GbxTest.TestLibraryContent.GetTestInfoStaticMesh
// 0x0080 (0x0080 - 0x0000)
struct TestLibraryContent_GetTestInfoStaticMesh final
{
public:
	const class UStaticMesh*                      Asset;                                             // 0x0000(0x0008)(ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FTestInfoMeshLODSummary                LODSummary;                                        // 0x0008(0x0024)(Parm, OutParm, NoDestructor, NativeAccessSpecifierPublic)
	struct FTestInfoMesh                          Mesh;                                              // 0x002C(0x0024)(Parm, OutParm, NoDestructor, NativeAccessSpecifierPublic)
	struct FTestInfoStaticMesh                    StaticMesh;                                        // 0x0050(0x0030)(Parm, OutParm, NativeAccessSpecifierPublic)
};
static_assert(alignof(TestLibraryContent_GetTestInfoStaticMesh) == 0x000008, "Wrong alignment on TestLibraryContent_GetTestInfoStaticMesh");
static_assert(sizeof(TestLibraryContent_GetTestInfoStaticMesh) == 0x000080, "Wrong size on TestLibraryContent_GetTestInfoStaticMesh");
static_assert(offsetof(TestLibraryContent_GetTestInfoStaticMesh, Asset) == 0x000000, "Member 'TestLibraryContent_GetTestInfoStaticMesh::Asset' has a wrong offset!");
static_assert(offsetof(TestLibraryContent_GetTestInfoStaticMesh, LODSummary) == 0x000008, "Member 'TestLibraryContent_GetTestInfoStaticMesh::LODSummary' has a wrong offset!");
static_assert(offsetof(TestLibraryContent_GetTestInfoStaticMesh, Mesh) == 0x00002C, "Member 'TestLibraryContent_GetTestInfoStaticMesh::Mesh' has a wrong offset!");
static_assert(offsetof(TestLibraryContent_GetTestInfoStaticMesh, StaticMesh) == 0x000050, "Member 'TestLibraryContent_GetTestInfoStaticMesh::StaticMesh' has a wrong offset!");

// Function GbxTest.TestLibraryContent.GetTestInfoStaticMeshLOD
// 0x0028 (0x0028 - 0x0000)
struct TestLibraryContent_GetTestInfoStaticMeshLOD final
{
public:
	const class UStaticMesh*                      Asset;                                             // 0x0000(0x0008)(ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         LODIndex;                                          // 0x0008(0x0004)(ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FTestInfoMeshLOD                       Info;                                              // 0x000C(0x001C)(Parm, OutParm, NoDestructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(TestLibraryContent_GetTestInfoStaticMeshLOD) == 0x000008, "Wrong alignment on TestLibraryContent_GetTestInfoStaticMeshLOD");
static_assert(sizeof(TestLibraryContent_GetTestInfoStaticMeshLOD) == 0x000028, "Wrong size on TestLibraryContent_GetTestInfoStaticMeshLOD");
static_assert(offsetof(TestLibraryContent_GetTestInfoStaticMeshLOD, Asset) == 0x000000, "Member 'TestLibraryContent_GetTestInfoStaticMeshLOD::Asset' has a wrong offset!");
static_assert(offsetof(TestLibraryContent_GetTestInfoStaticMeshLOD, LODIndex) == 0x000008, "Member 'TestLibraryContent_GetTestInfoStaticMeshLOD::LODIndex' has a wrong offset!");
static_assert(offsetof(TestLibraryContent_GetTestInfoStaticMeshLOD, Info) == 0x00000C, "Member 'TestLibraryContent_GetTestInfoStaticMeshLOD::Info' has a wrong offset!");

// Function GbxTest.TestLibraryContent.GetTestInfoTexture
// 0x0030 (0x0030 - 0x0000)
struct TestLibraryContent_GetTestInfoTexture final
{
public:
	const class UTexture*                         Asset;                                             // 0x0000(0x0008)(ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FTestInfoTexture                       Info;                                              // 0x0008(0x0028)(Parm, OutParm, NativeAccessSpecifierPublic)
};
static_assert(alignof(TestLibraryContent_GetTestInfoTexture) == 0x000008, "Wrong alignment on TestLibraryContent_GetTestInfoTexture");
static_assert(sizeof(TestLibraryContent_GetTestInfoTexture) == 0x000030, "Wrong size on TestLibraryContent_GetTestInfoTexture");
static_assert(offsetof(TestLibraryContent_GetTestInfoTexture, Asset) == 0x000000, "Member 'TestLibraryContent_GetTestInfoTexture::Asset' has a wrong offset!");
static_assert(offsetof(TestLibraryContent_GetTestInfoTexture, Info) == 0x000008, "Member 'TestLibraryContent_GetTestInfoTexture::Info' has a wrong offset!");

// Function GbxTest.TestLibraryContent.LoadAssetMaterial
// 0x0018 (0x0018 - 0x0000)
struct TestLibraryContent_LoadAssetMaterial final
{
public:
	class FString                                 ObjectPath;                                        // 0x0000(0x0010)(Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UMaterial*                              ReturnValue;                                       // 0x0010(0x0008)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(TestLibraryContent_LoadAssetMaterial) == 0x000008, "Wrong alignment on TestLibraryContent_LoadAssetMaterial");
static_assert(sizeof(TestLibraryContent_LoadAssetMaterial) == 0x000018, "Wrong size on TestLibraryContent_LoadAssetMaterial");
static_assert(offsetof(TestLibraryContent_LoadAssetMaterial, ObjectPath) == 0x000000, "Member 'TestLibraryContent_LoadAssetMaterial::ObjectPath' has a wrong offset!");
static_assert(offsetof(TestLibraryContent_LoadAssetMaterial, ReturnValue) == 0x000010, "Member 'TestLibraryContent_LoadAssetMaterial::ReturnValue' has a wrong offset!");

// Function GbxTest.TestLibraryContent.LoadAssetParticleSystem
// 0x0018 (0x0018 - 0x0000)
struct TestLibraryContent_LoadAssetParticleSystem final
{
public:
	class FString                                 ObjectPath;                                        // 0x0000(0x0010)(Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UParticleSystem*                        ReturnValue;                                       // 0x0010(0x0008)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(TestLibraryContent_LoadAssetParticleSystem) == 0x000008, "Wrong alignment on TestLibraryContent_LoadAssetParticleSystem");
static_assert(sizeof(TestLibraryContent_LoadAssetParticleSystem) == 0x000018, "Wrong size on TestLibraryContent_LoadAssetParticleSystem");
static_assert(offsetof(TestLibraryContent_LoadAssetParticleSystem, ObjectPath) == 0x000000, "Member 'TestLibraryContent_LoadAssetParticleSystem::ObjectPath' has a wrong offset!");
static_assert(offsetof(TestLibraryContent_LoadAssetParticleSystem, ReturnValue) == 0x000010, "Member 'TestLibraryContent_LoadAssetParticleSystem::ReturnValue' has a wrong offset!");

// Function GbxTest.TestLibraryContent.LoadAssetSkeletalMesh
// 0x0018 (0x0018 - 0x0000)
struct TestLibraryContent_LoadAssetSkeletalMesh final
{
public:
	class FString                                 ObjectPath;                                        // 0x0000(0x0010)(Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class USkeletalMesh*                          ReturnValue;                                       // 0x0010(0x0008)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(TestLibraryContent_LoadAssetSkeletalMesh) == 0x000008, "Wrong alignment on TestLibraryContent_LoadAssetSkeletalMesh");
static_assert(sizeof(TestLibraryContent_LoadAssetSkeletalMesh) == 0x000018, "Wrong size on TestLibraryContent_LoadAssetSkeletalMesh");
static_assert(offsetof(TestLibraryContent_LoadAssetSkeletalMesh, ObjectPath) == 0x000000, "Member 'TestLibraryContent_LoadAssetSkeletalMesh::ObjectPath' has a wrong offset!");
static_assert(offsetof(TestLibraryContent_LoadAssetSkeletalMesh, ReturnValue) == 0x000010, "Member 'TestLibraryContent_LoadAssetSkeletalMesh::ReturnValue' has a wrong offset!");

// Function GbxTest.TestLibraryContent.LoadAssetStaticMesh
// 0x0018 (0x0018 - 0x0000)
struct TestLibraryContent_LoadAssetStaticMesh final
{
public:
	class FString                                 ObjectPath;                                        // 0x0000(0x0010)(Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UStaticMesh*                            ReturnValue;                                       // 0x0010(0x0008)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(TestLibraryContent_LoadAssetStaticMesh) == 0x000008, "Wrong alignment on TestLibraryContent_LoadAssetStaticMesh");
static_assert(sizeof(TestLibraryContent_LoadAssetStaticMesh) == 0x000018, "Wrong size on TestLibraryContent_LoadAssetStaticMesh");
static_assert(offsetof(TestLibraryContent_LoadAssetStaticMesh, ObjectPath) == 0x000000, "Member 'TestLibraryContent_LoadAssetStaticMesh::ObjectPath' has a wrong offset!");
static_assert(offsetof(TestLibraryContent_LoadAssetStaticMesh, ReturnValue) == 0x000010, "Member 'TestLibraryContent_LoadAssetStaticMesh::ReturnValue' has a wrong offset!");

// Function GbxTest.TestLibraryContent.LoadAssetTexture
// 0x0018 (0x0018 - 0x0000)
struct TestLibraryContent_LoadAssetTexture final
{
public:
	class FString                                 ObjectPath;                                        // 0x0000(0x0010)(Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UTexture*                               ReturnValue;                                       // 0x0010(0x0008)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(TestLibraryContent_LoadAssetTexture) == 0x000008, "Wrong alignment on TestLibraryContent_LoadAssetTexture");
static_assert(sizeof(TestLibraryContent_LoadAssetTexture) == 0x000018, "Wrong size on TestLibraryContent_LoadAssetTexture");
static_assert(offsetof(TestLibraryContent_LoadAssetTexture, ObjectPath) == 0x000000, "Member 'TestLibraryContent_LoadAssetTexture::ObjectPath' has a wrong offset!");
static_assert(offsetof(TestLibraryContent_LoadAssetTexture, ReturnValue) == 0x000010, "Member 'TestLibraryContent_LoadAssetTexture::ReturnValue' has a wrong offset!");

// Function GbxTest.TestLibraryPerformance.GenerateLevelGrid
// 0x0020 (0x0020 - 0x0000)
struct TestLibraryPerformance_GenerateLevelGrid final
{
public:
	TArray<struct FVector>                        GridLocations;                                     // 0x0000(0x0010)(Parm, OutParm, ZeroConstructor, NativeAccessSpecifierPublic)
	class APawn*                                  Pawn;                                              // 0x0010(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         GridSize;                                          // 0x0018(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bWalkableOnly;                                     // 0x001C(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1D[0x3];                                       // 0x001D(0x0003)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(TestLibraryPerformance_GenerateLevelGrid) == 0x000008, "Wrong alignment on TestLibraryPerformance_GenerateLevelGrid");
static_assert(sizeof(TestLibraryPerformance_GenerateLevelGrid) == 0x000020, "Wrong size on TestLibraryPerformance_GenerateLevelGrid");
static_assert(offsetof(TestLibraryPerformance_GenerateLevelGrid, GridLocations) == 0x000000, "Member 'TestLibraryPerformance_GenerateLevelGrid::GridLocations' has a wrong offset!");
static_assert(offsetof(TestLibraryPerformance_GenerateLevelGrid, Pawn) == 0x000010, "Member 'TestLibraryPerformance_GenerateLevelGrid::Pawn' has a wrong offset!");
static_assert(offsetof(TestLibraryPerformance_GenerateLevelGrid, GridSize) == 0x000018, "Member 'TestLibraryPerformance_GenerateLevelGrid::GridSize' has a wrong offset!");
static_assert(offsetof(TestLibraryPerformance_GenerateLevelGrid, bWalkableOnly) == 0x00001C, "Member 'TestLibraryPerformance_GenerateLevelGrid::bWalkableOnly' has a wrong offset!");

// Function GbxTest.TestLibraryPerformance.WaitForFrames
// 0x0028 (0x0028 - 0x0000)
struct TestLibraryPerformance_WaitForFrames final
{
public:
	class UObject*                                WorldContextObject;                                // 0x0000(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         NumFrames;                                         // 0x0008(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_C[0x4];                                        // 0x000C(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	struct FLatentActionInfo                      LatentInfo;                                        // 0x0010(0x0018)(Parm, NoDestructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(TestLibraryPerformance_WaitForFrames) == 0x000008, "Wrong alignment on TestLibraryPerformance_WaitForFrames");
static_assert(sizeof(TestLibraryPerformance_WaitForFrames) == 0x000028, "Wrong size on TestLibraryPerformance_WaitForFrames");
static_assert(offsetof(TestLibraryPerformance_WaitForFrames, WorldContextObject) == 0x000000, "Member 'TestLibraryPerformance_WaitForFrames::WorldContextObject' has a wrong offset!");
static_assert(offsetof(TestLibraryPerformance_WaitForFrames, NumFrames) == 0x000008, "Member 'TestLibraryPerformance_WaitForFrames::NumFrames' has a wrong offset!");
static_assert(offsetof(TestLibraryPerformance_WaitForFrames, LatentInfo) == 0x000010, "Member 'TestLibraryPerformance_WaitForFrames::LatentInfo' has a wrong offset!");

// Function GbxTest.TestLibrarySimulation.CanReceiveBackgroundInput
// 0x0010 (0x0010 - 0x0000)
struct TestLibrarySimulation_CanReceiveBackgroundInput final
{
public:
	class APlayerController*                      PlayerController;                                  // 0x0000(0x0008)(Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          ReturnValue;                                       // 0x0008(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_9[0x7];                                        // 0x0009(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(TestLibrarySimulation_CanReceiveBackgroundInput) == 0x000008, "Wrong alignment on TestLibrarySimulation_CanReceiveBackgroundInput");
static_assert(sizeof(TestLibrarySimulation_CanReceiveBackgroundInput) == 0x000010, "Wrong size on TestLibrarySimulation_CanReceiveBackgroundInput");
static_assert(offsetof(TestLibrarySimulation_CanReceiveBackgroundInput, PlayerController) == 0x000000, "Member 'TestLibrarySimulation_CanReceiveBackgroundInput::PlayerController' has a wrong offset!");
static_assert(offsetof(TestLibrarySimulation_CanReceiveBackgroundInput, ReturnValue) == 0x000008, "Member 'TestLibrarySimulation_CanReceiveBackgroundInput::ReturnValue' has a wrong offset!");

// Function GbxTest.TestLibrarySimulation.GetPolicyForPlayMap
// 0x0008 (0x0008 - 0x0000)
struct TestLibrarySimulation_GetPolicyForPlayMap final
{
public:
	class UTestPolicySimulation*                  ReturnValue;                                       // 0x0000(0x0008)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(TestLibrarySimulation_GetPolicyForPlayMap) == 0x000008, "Wrong alignment on TestLibrarySimulation_GetPolicyForPlayMap");
static_assert(sizeof(TestLibrarySimulation_GetPolicyForPlayMap) == 0x000008, "Wrong size on TestLibrarySimulation_GetPolicyForPlayMap");
static_assert(offsetof(TestLibrarySimulation_GetPolicyForPlayMap, ReturnValue) == 0x000000, "Member 'TestLibrarySimulation_GetPolicyForPlayMap::ReturnValue' has a wrong offset!");

// Function GbxTest.TestLibrarySimulation.IsDemiGodEnabled
// 0x0010 (0x0010 - 0x0000)
struct TestLibrarySimulation_IsDemiGodEnabled final
{
public:
	class APlayerController*                      PlayerController;                                  // 0x0000(0x0008)(Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          ReturnValue;                                       // 0x0008(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_9[0x7];                                        // 0x0009(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(TestLibrarySimulation_IsDemiGodEnabled) == 0x000008, "Wrong alignment on TestLibrarySimulation_IsDemiGodEnabled");
static_assert(sizeof(TestLibrarySimulation_IsDemiGodEnabled) == 0x000010, "Wrong size on TestLibrarySimulation_IsDemiGodEnabled");
static_assert(offsetof(TestLibrarySimulation_IsDemiGodEnabled, PlayerController) == 0x000000, "Member 'TestLibrarySimulation_IsDemiGodEnabled::PlayerController' has a wrong offset!");
static_assert(offsetof(TestLibrarySimulation_IsDemiGodEnabled, ReturnValue) == 0x000008, "Member 'TestLibrarySimulation_IsDemiGodEnabled::ReturnValue' has a wrong offset!");

// Function GbxTest.TestLibrarySimulation.IsGhostEnabled
// 0x0010 (0x0010 - 0x0000)
struct TestLibrarySimulation_IsGhostEnabled final
{
public:
	class APlayerController*                      PlayerController;                                  // 0x0000(0x0008)(Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          ReturnValue;                                       // 0x0008(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_9[0x7];                                        // 0x0009(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(TestLibrarySimulation_IsGhostEnabled) == 0x000008, "Wrong alignment on TestLibrarySimulation_IsGhostEnabled");
static_assert(sizeof(TestLibrarySimulation_IsGhostEnabled) == 0x000010, "Wrong size on TestLibrarySimulation_IsGhostEnabled");
static_assert(offsetof(TestLibrarySimulation_IsGhostEnabled, PlayerController) == 0x000000, "Member 'TestLibrarySimulation_IsGhostEnabled::PlayerController' has a wrong offset!");
static_assert(offsetof(TestLibrarySimulation_IsGhostEnabled, ReturnValue) == 0x000008, "Member 'TestLibrarySimulation_IsGhostEnabled::ReturnValue' has a wrong offset!");

// Function GbxTest.TestLibrarySimulation.IsGodEnabled
// 0x0010 (0x0010 - 0x0000)
struct TestLibrarySimulation_IsGodEnabled final
{
public:
	class APlayerController*                      PlayerController;                                  // 0x0000(0x0008)(Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          ReturnValue;                                       // 0x0008(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_9[0x7];                                        // 0x0009(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(TestLibrarySimulation_IsGodEnabled) == 0x000008, "Wrong alignment on TestLibrarySimulation_IsGodEnabled");
static_assert(sizeof(TestLibrarySimulation_IsGodEnabled) == 0x000010, "Wrong size on TestLibrarySimulation_IsGodEnabled");
static_assert(offsetof(TestLibrarySimulation_IsGodEnabled, PlayerController) == 0x000000, "Member 'TestLibrarySimulation_IsGodEnabled::PlayerController' has a wrong offset!");
static_assert(offsetof(TestLibrarySimulation_IsGodEnabled, ReturnValue) == 0x000008, "Member 'TestLibrarySimulation_IsGodEnabled::ReturnValue' has a wrong offset!");

// Function GbxTest.TestLibrarySimulation.IsHLQNoClipEnabled
// 0x0010 (0x0010 - 0x0000)
struct TestLibrarySimulation_IsHLQNoClipEnabled final
{
public:
	class APlayerController*                      PlayerController;                                  // 0x0000(0x0008)(Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          ReturnValue;                                       // 0x0008(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_9[0x7];                                        // 0x0009(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(TestLibrarySimulation_IsHLQNoClipEnabled) == 0x000008, "Wrong alignment on TestLibrarySimulation_IsHLQNoClipEnabled");
static_assert(sizeof(TestLibrarySimulation_IsHLQNoClipEnabled) == 0x000010, "Wrong size on TestLibrarySimulation_IsHLQNoClipEnabled");
static_assert(offsetof(TestLibrarySimulation_IsHLQNoClipEnabled, PlayerController) == 0x000000, "Member 'TestLibrarySimulation_IsHLQNoClipEnabled::PlayerController' has a wrong offset!");
static_assert(offsetof(TestLibrarySimulation_IsHLQNoClipEnabled, ReturnValue) == 0x000008, "Member 'TestLibrarySimulation_IsHLQNoClipEnabled::ReturnValue' has a wrong offset!");

// Function GbxTest.TestLibrarySimulation.IsPlayMapRunning
// 0x0001 (0x0001 - 0x0000)
struct TestLibrarySimulation_IsPlayMapRunning final
{
public:
	bool                                          ReturnValue;                                       // 0x0000(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(TestLibrarySimulation_IsPlayMapRunning) == 0x000001, "Wrong alignment on TestLibrarySimulation_IsPlayMapRunning");
static_assert(sizeof(TestLibrarySimulation_IsPlayMapRunning) == 0x000001, "Wrong size on TestLibrarySimulation_IsPlayMapRunning");
static_assert(offsetof(TestLibrarySimulation_IsPlayMapRunning, ReturnValue) == 0x000000, "Member 'TestLibrarySimulation_IsPlayMapRunning::ReturnValue' has a wrong offset!");

// Function GbxTest.TestLibrarySimulation.PopAssetContext
// 0x0018 (0x0018 - 0x0000)
struct TestLibrarySimulation_PopAssetContext final
{
public:
	struct FGbxProbeId                            ID;                                                // 0x0000(0x0018)(Parm, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(TestLibrarySimulation_PopAssetContext) == 0x000008, "Wrong alignment on TestLibrarySimulation_PopAssetContext");
static_assert(sizeof(TestLibrarySimulation_PopAssetContext) == 0x000018, "Wrong size on TestLibrarySimulation_PopAssetContext");
static_assert(offsetof(TestLibrarySimulation_PopAssetContext, ID) == 0x000000, "Member 'TestLibrarySimulation_PopAssetContext::ID' has a wrong offset!");

// Function GbxTest.TestLibrarySimulation.PushAssetContext
// 0x0018 (0x0018 - 0x0000)
struct TestLibrarySimulation_PushAssetContext final
{
public:
	struct FGbxProbeId                            ID;                                                // 0x0000(0x0018)(Parm, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(TestLibrarySimulation_PushAssetContext) == 0x000008, "Wrong alignment on TestLibrarySimulation_PushAssetContext");
static_assert(sizeof(TestLibrarySimulation_PushAssetContext) == 0x000018, "Wrong size on TestLibrarySimulation_PushAssetContext");
static_assert(offsetof(TestLibrarySimulation_PushAssetContext, ID) == 0x000000, "Member 'TestLibrarySimulation_PushAssetContext::ID' has a wrong offset!");

// Function GbxTest.TestLibrarySimulation.PushWorldContext
// 0x0008 (0x0008 - 0x0000)
struct TestLibrarySimulation_PushWorldContext final
{
public:
	class UObject*                                WorldContextObject;                                // 0x0000(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(TestLibrarySimulation_PushWorldContext) == 0x000008, "Wrong alignment on TestLibrarySimulation_PushWorldContext");
static_assert(sizeof(TestLibrarySimulation_PushWorldContext) == 0x000008, "Wrong size on TestLibrarySimulation_PushWorldContext");
static_assert(offsetof(TestLibrarySimulation_PushWorldContext, WorldContextObject) == 0x000000, "Member 'TestLibrarySimulation_PushWorldContext::WorldContextObject' has a wrong offset!");

// Function GbxTest.TestLibrarySimulation.ReportIssueFromPlayMap
// 0x0028 (0x0028 - 0x0000)
struct TestLibrarySimulation_ReportIssueFromPlayMap final
{
public:
	ETestIssueType                                IssueType;                                         // 0x0000(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1[0x7];                                        // 0x0001(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	class FString                                 IssueCategory;                                     // 0x0008(0x0010)(Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FString                                 IssueMessage;                                      // 0x0018(0x0010)(Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(TestLibrarySimulation_ReportIssueFromPlayMap) == 0x000008, "Wrong alignment on TestLibrarySimulation_ReportIssueFromPlayMap");
static_assert(sizeof(TestLibrarySimulation_ReportIssueFromPlayMap) == 0x000028, "Wrong size on TestLibrarySimulation_ReportIssueFromPlayMap");
static_assert(offsetof(TestLibrarySimulation_ReportIssueFromPlayMap, IssueType) == 0x000000, "Member 'TestLibrarySimulation_ReportIssueFromPlayMap::IssueType' has a wrong offset!");
static_assert(offsetof(TestLibrarySimulation_ReportIssueFromPlayMap, IssueCategory) == 0x000008, "Member 'TestLibrarySimulation_ReportIssueFromPlayMap::IssueCategory' has a wrong offset!");
static_assert(offsetof(TestLibrarySimulation_ReportIssueFromPlayMap, IssueMessage) == 0x000018, "Member 'TestLibrarySimulation_ReportIssueFromPlayMap::IssueMessage' has a wrong offset!");

// Function GbxTest.TestLibrarySimulation.ReportResultFromPlayMap
// 0x0048 (0x0048 - 0x0000)
struct TestLibrarySimulation_ReportResultFromPlayMap final
{
public:
	bool                                          bSucceeded;                                        // 0x0000(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1[0x7];                                        // 0x0001(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	class FString                                 IssueCategory;                                     // 0x0008(0x0010)(Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FString                                 IssueMessage;                                      // 0x0018(0x0010)(Parm, ZeroConstructor, AdvancedDisplay, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FGbxProbeId                            AssetContext;                                      // 0x0028(0x0018)(Parm, AdvancedDisplay, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	ETestIssueType                                FailedIssueType;                                   // 0x0040(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, AdvancedDisplay, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_41[0x7];                                       // 0x0041(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(TestLibrarySimulation_ReportResultFromPlayMap) == 0x000008, "Wrong alignment on TestLibrarySimulation_ReportResultFromPlayMap");
static_assert(sizeof(TestLibrarySimulation_ReportResultFromPlayMap) == 0x000048, "Wrong size on TestLibrarySimulation_ReportResultFromPlayMap");
static_assert(offsetof(TestLibrarySimulation_ReportResultFromPlayMap, bSucceeded) == 0x000000, "Member 'TestLibrarySimulation_ReportResultFromPlayMap::bSucceeded' has a wrong offset!");
static_assert(offsetof(TestLibrarySimulation_ReportResultFromPlayMap, IssueCategory) == 0x000008, "Member 'TestLibrarySimulation_ReportResultFromPlayMap::IssueCategory' has a wrong offset!");
static_assert(offsetof(TestLibrarySimulation_ReportResultFromPlayMap, IssueMessage) == 0x000018, "Member 'TestLibrarySimulation_ReportResultFromPlayMap::IssueMessage' has a wrong offset!");
static_assert(offsetof(TestLibrarySimulation_ReportResultFromPlayMap, AssetContext) == 0x000028, "Member 'TestLibrarySimulation_ReportResultFromPlayMap::AssetContext' has a wrong offset!");
static_assert(offsetof(TestLibrarySimulation_ReportResultFromPlayMap, FailedIssueType) == 0x000040, "Member 'TestLibrarySimulation_ReportResultFromPlayMap::FailedIssueType' has a wrong offset!");

// Function GbxTest.TestLibrarySimulation.SetReceiveBackgroundInput
// 0x0010 (0x0010 - 0x0000)
struct TestLibrarySimulation_SetReceiveBackgroundInput final
{
public:
	class APlayerController*                      PlayerController;                                  // 0x0000(0x0008)(Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          AllowBackgroundInput;                              // 0x0008(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          ReturnValue;                                       // 0x0009(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_A[0x6];                                        // 0x000A(0x0006)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(TestLibrarySimulation_SetReceiveBackgroundInput) == 0x000008, "Wrong alignment on TestLibrarySimulation_SetReceiveBackgroundInput");
static_assert(sizeof(TestLibrarySimulation_SetReceiveBackgroundInput) == 0x000010, "Wrong size on TestLibrarySimulation_SetReceiveBackgroundInput");
static_assert(offsetof(TestLibrarySimulation_SetReceiveBackgroundInput, PlayerController) == 0x000000, "Member 'TestLibrarySimulation_SetReceiveBackgroundInput::PlayerController' has a wrong offset!");
static_assert(offsetof(TestLibrarySimulation_SetReceiveBackgroundInput, AllowBackgroundInput) == 0x000008, "Member 'TestLibrarySimulation_SetReceiveBackgroundInput::AllowBackgroundInput' has a wrong offset!");
static_assert(offsetof(TestLibrarySimulation_SetReceiveBackgroundInput, ReturnValue) == 0x000009, "Member 'TestLibrarySimulation_SetReceiveBackgroundInput::ReturnValue' has a wrong offset!");

// Function GbxTest.TestLibrarySimulation.SetReportContext
// 0x0018 (0x0018 - 0x0000)
struct TestLibrarySimulation_SetReportContext final
{
public:
	class UObject*                                WorldContextObject;                                // 0x0000(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TArray<struct FGbxProbeId>                    AssetContexts;                                     // 0x0008(0x0010)(ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, NativeAccessSpecifierPublic)
};
static_assert(alignof(TestLibrarySimulation_SetReportContext) == 0x000008, "Wrong alignment on TestLibrarySimulation_SetReportContext");
static_assert(sizeof(TestLibrarySimulation_SetReportContext) == 0x000018, "Wrong size on TestLibrarySimulation_SetReportContext");
static_assert(offsetof(TestLibrarySimulation_SetReportContext, WorldContextObject) == 0x000000, "Member 'TestLibrarySimulation_SetReportContext::WorldContextObject' has a wrong offset!");
static_assert(offsetof(TestLibrarySimulation_SetReportContext, AssetContexts) == 0x000008, "Member 'TestLibrarySimulation_SetReportContext::AssetContexts' has a wrong offset!");

// Function GbxTest.TestLibrarySimulation.SimulatePlayerInput
// 0x0040 (0x0040 - 0x0000)
struct TestLibrarySimulation_SimulatePlayerInput final
{
public:
	class UObject*                                WorldContextObject;                                // 0x0000(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class APlayerController*                      PlayerController;                                  // 0x0008(0x0008)(Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TArray<struct FGbxTestInputAction>            InputDescription;                                  // 0x0010(0x0010)(ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, NativeAccessSpecifierPublic)
	float                                         PreDelay;                                          // 0x0020(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, AdvancedDisplay, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         PostDelay;                                         // 0x0024(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, AdvancedDisplay, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FLatentActionInfo                      LatentInfo;                                        // 0x0028(0x0018)(Parm, NoDestructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(TestLibrarySimulation_SimulatePlayerInput) == 0x000008, "Wrong alignment on TestLibrarySimulation_SimulatePlayerInput");
static_assert(sizeof(TestLibrarySimulation_SimulatePlayerInput) == 0x000040, "Wrong size on TestLibrarySimulation_SimulatePlayerInput");
static_assert(offsetof(TestLibrarySimulation_SimulatePlayerInput, WorldContextObject) == 0x000000, "Member 'TestLibrarySimulation_SimulatePlayerInput::WorldContextObject' has a wrong offset!");
static_assert(offsetof(TestLibrarySimulation_SimulatePlayerInput, PlayerController) == 0x000008, "Member 'TestLibrarySimulation_SimulatePlayerInput::PlayerController' has a wrong offset!");
static_assert(offsetof(TestLibrarySimulation_SimulatePlayerInput, InputDescription) == 0x000010, "Member 'TestLibrarySimulation_SimulatePlayerInput::InputDescription' has a wrong offset!");
static_assert(offsetof(TestLibrarySimulation_SimulatePlayerInput, PreDelay) == 0x000020, "Member 'TestLibrarySimulation_SimulatePlayerInput::PreDelay' has a wrong offset!");
static_assert(offsetof(TestLibrarySimulation_SimulatePlayerInput, PostDelay) == 0x000024, "Member 'TestLibrarySimulation_SimulatePlayerInput::PostDelay' has a wrong offset!");
static_assert(offsetof(TestLibrarySimulation_SimulatePlayerInput, LatentInfo) == 0x000028, "Member 'TestLibrarySimulation_SimulatePlayerInput::LatentInfo' has a wrong offset!");

// Function GbxTest.TestLibrarySimulation.TestBoolIsFalseFromPlayMap
// 0x0028 (0x0028 - 0x0000)
struct TestLibrarySimulation_TestBoolIsFalseFromPlayMap final
{
public:
	bool                                          Value;                                             // 0x0000(0x0001)(ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	ETestIssueType                                IssueType;                                         // 0x0001(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, AdvancedDisplay, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2[0x6];                                        // 0x0002(0x0006)(Fixing Size After Last Property [ Dumper-7 ])
	class FString                                 IssueCategory;                                     // 0x0008(0x0010)(Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FString                                 IssueMessage;                                      // 0x0018(0x0010)(Parm, ZeroConstructor, AdvancedDisplay, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(TestLibrarySimulation_TestBoolIsFalseFromPlayMap) == 0x000008, "Wrong alignment on TestLibrarySimulation_TestBoolIsFalseFromPlayMap");
static_assert(sizeof(TestLibrarySimulation_TestBoolIsFalseFromPlayMap) == 0x000028, "Wrong size on TestLibrarySimulation_TestBoolIsFalseFromPlayMap");
static_assert(offsetof(TestLibrarySimulation_TestBoolIsFalseFromPlayMap, Value) == 0x000000, "Member 'TestLibrarySimulation_TestBoolIsFalseFromPlayMap::Value' has a wrong offset!");
static_assert(offsetof(TestLibrarySimulation_TestBoolIsFalseFromPlayMap, IssueType) == 0x000001, "Member 'TestLibrarySimulation_TestBoolIsFalseFromPlayMap::IssueType' has a wrong offset!");
static_assert(offsetof(TestLibrarySimulation_TestBoolIsFalseFromPlayMap, IssueCategory) == 0x000008, "Member 'TestLibrarySimulation_TestBoolIsFalseFromPlayMap::IssueCategory' has a wrong offset!");
static_assert(offsetof(TestLibrarySimulation_TestBoolIsFalseFromPlayMap, IssueMessage) == 0x000018, "Member 'TestLibrarySimulation_TestBoolIsFalseFromPlayMap::IssueMessage' has a wrong offset!");

// Function GbxTest.TestLibrarySimulation.TestBoolIsTrueFromPlayMap
// 0x0028 (0x0028 - 0x0000)
struct TestLibrarySimulation_TestBoolIsTrueFromPlayMap final
{
public:
	bool                                          Value;                                             // 0x0000(0x0001)(ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	ETestIssueType                                IssueType;                                         // 0x0001(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, AdvancedDisplay, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2[0x6];                                        // 0x0002(0x0006)(Fixing Size After Last Property [ Dumper-7 ])
	class FString                                 IssueCategory;                                     // 0x0008(0x0010)(Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FString                                 IssueMessage;                                      // 0x0018(0x0010)(Parm, ZeroConstructor, AdvancedDisplay, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(TestLibrarySimulation_TestBoolIsTrueFromPlayMap) == 0x000008, "Wrong alignment on TestLibrarySimulation_TestBoolIsTrueFromPlayMap");
static_assert(sizeof(TestLibrarySimulation_TestBoolIsTrueFromPlayMap) == 0x000028, "Wrong size on TestLibrarySimulation_TestBoolIsTrueFromPlayMap");
static_assert(offsetof(TestLibrarySimulation_TestBoolIsTrueFromPlayMap, Value) == 0x000000, "Member 'TestLibrarySimulation_TestBoolIsTrueFromPlayMap::Value' has a wrong offset!");
static_assert(offsetof(TestLibrarySimulation_TestBoolIsTrueFromPlayMap, IssueType) == 0x000001, "Member 'TestLibrarySimulation_TestBoolIsTrueFromPlayMap::IssueType' has a wrong offset!");
static_assert(offsetof(TestLibrarySimulation_TestBoolIsTrueFromPlayMap, IssueCategory) == 0x000008, "Member 'TestLibrarySimulation_TestBoolIsTrueFromPlayMap::IssueCategory' has a wrong offset!");
static_assert(offsetof(TestLibrarySimulation_TestBoolIsTrueFromPlayMap, IssueMessage) == 0x000018, "Member 'TestLibrarySimulation_TestBoolIsTrueFromPlayMap::IssueMessage' has a wrong offset!");

// Function GbxTest.TestLibrarySimulation.TestFloatCompareFromPlayMap
// 0x0038 (0x0038 - 0x0000)
struct TestLibrarySimulation_TestFloatCompareFromPlayMap final
{
public:
	float                                         Value;                                             // 0x0000(0x0004)(ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         Other;                                             // 0x0004(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	ECompare                                      Comparison;                                        // 0x0008(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, AdvancedDisplay, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	ETestIssueType                                IssueType;                                         // 0x0009(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, AdvancedDisplay, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_A[0x6];                                        // 0x000A(0x0006)(Fixing Size After Last Property [ Dumper-7 ])
	class FString                                 IssueCategory;                                     // 0x0010(0x0010)(Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FString                                 IssueMessage;                                      // 0x0020(0x0010)(Parm, ZeroConstructor, AdvancedDisplay, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         Tolerance;                                         // 0x0030(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, AdvancedDisplay, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_34[0x4];                                       // 0x0034(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(TestLibrarySimulation_TestFloatCompareFromPlayMap) == 0x000008, "Wrong alignment on TestLibrarySimulation_TestFloatCompareFromPlayMap");
static_assert(sizeof(TestLibrarySimulation_TestFloatCompareFromPlayMap) == 0x000038, "Wrong size on TestLibrarySimulation_TestFloatCompareFromPlayMap");
static_assert(offsetof(TestLibrarySimulation_TestFloatCompareFromPlayMap, Value) == 0x000000, "Member 'TestLibrarySimulation_TestFloatCompareFromPlayMap::Value' has a wrong offset!");
static_assert(offsetof(TestLibrarySimulation_TestFloatCompareFromPlayMap, Other) == 0x000004, "Member 'TestLibrarySimulation_TestFloatCompareFromPlayMap::Other' has a wrong offset!");
static_assert(offsetof(TestLibrarySimulation_TestFloatCompareFromPlayMap, Comparison) == 0x000008, "Member 'TestLibrarySimulation_TestFloatCompareFromPlayMap::Comparison' has a wrong offset!");
static_assert(offsetof(TestLibrarySimulation_TestFloatCompareFromPlayMap, IssueType) == 0x000009, "Member 'TestLibrarySimulation_TestFloatCompareFromPlayMap::IssueType' has a wrong offset!");
static_assert(offsetof(TestLibrarySimulation_TestFloatCompareFromPlayMap, IssueCategory) == 0x000010, "Member 'TestLibrarySimulation_TestFloatCompareFromPlayMap::IssueCategory' has a wrong offset!");
static_assert(offsetof(TestLibrarySimulation_TestFloatCompareFromPlayMap, IssueMessage) == 0x000020, "Member 'TestLibrarySimulation_TestFloatCompareFromPlayMap::IssueMessage' has a wrong offset!");
static_assert(offsetof(TestLibrarySimulation_TestFloatCompareFromPlayMap, Tolerance) == 0x000030, "Member 'TestLibrarySimulation_TestFloatCompareFromPlayMap::Tolerance' has a wrong offset!");

// Function GbxTest.TestLibrarySimulation.TestFloatInRangeFromPlayMap
// 0x0030 (0x0030 - 0x0000)
struct TestLibrarySimulation_TestFloatInRangeFromPlayMap final
{
public:
	float                                         Value;                                             // 0x0000(0x0004)(ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         Min;                                               // 0x0004(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         Max;                                               // 0x0008(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	ETestIssueType                                IssueType;                                         // 0x000C(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, AdvancedDisplay, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_D[0x3];                                        // 0x000D(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	class FString                                 IssueCategory;                                     // 0x0010(0x0010)(Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FString                                 IssueMessage;                                      // 0x0020(0x0010)(Parm, ZeroConstructor, AdvancedDisplay, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(TestLibrarySimulation_TestFloatInRangeFromPlayMap) == 0x000008, "Wrong alignment on TestLibrarySimulation_TestFloatInRangeFromPlayMap");
static_assert(sizeof(TestLibrarySimulation_TestFloatInRangeFromPlayMap) == 0x000030, "Wrong size on TestLibrarySimulation_TestFloatInRangeFromPlayMap");
static_assert(offsetof(TestLibrarySimulation_TestFloatInRangeFromPlayMap, Value) == 0x000000, "Member 'TestLibrarySimulation_TestFloatInRangeFromPlayMap::Value' has a wrong offset!");
static_assert(offsetof(TestLibrarySimulation_TestFloatInRangeFromPlayMap, Min) == 0x000004, "Member 'TestLibrarySimulation_TestFloatInRangeFromPlayMap::Min' has a wrong offset!");
static_assert(offsetof(TestLibrarySimulation_TestFloatInRangeFromPlayMap, Max) == 0x000008, "Member 'TestLibrarySimulation_TestFloatInRangeFromPlayMap::Max' has a wrong offset!");
static_assert(offsetof(TestLibrarySimulation_TestFloatInRangeFromPlayMap, IssueType) == 0x00000C, "Member 'TestLibrarySimulation_TestFloatInRangeFromPlayMap::IssueType' has a wrong offset!");
static_assert(offsetof(TestLibrarySimulation_TestFloatInRangeFromPlayMap, IssueCategory) == 0x000010, "Member 'TestLibrarySimulation_TestFloatInRangeFromPlayMap::IssueCategory' has a wrong offset!");
static_assert(offsetof(TestLibrarySimulation_TestFloatInRangeFromPlayMap, IssueMessage) == 0x000020, "Member 'TestLibrarySimulation_TestFloatInRangeFromPlayMap::IssueMessage' has a wrong offset!");

// Function GbxTest.TestLibrarySimulation.TestIntCompareFromPlayMap
// 0x0030 (0x0030 - 0x0000)
struct TestLibrarySimulation_TestIntCompareFromPlayMap final
{
public:
	int32                                         Value;                                             // 0x0000(0x0004)(ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         Other;                                             // 0x0004(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	ECompare                                      Comparison;                                        // 0x0008(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, AdvancedDisplay, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	ETestIssueType                                IssueType;                                         // 0x0009(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, AdvancedDisplay, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_A[0x6];                                        // 0x000A(0x0006)(Fixing Size After Last Property [ Dumper-7 ])
	class FString                                 IssueCategory;                                     // 0x0010(0x0010)(Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FString                                 IssueMessage;                                      // 0x0020(0x0010)(Parm, ZeroConstructor, AdvancedDisplay, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(TestLibrarySimulation_TestIntCompareFromPlayMap) == 0x000008, "Wrong alignment on TestLibrarySimulation_TestIntCompareFromPlayMap");
static_assert(sizeof(TestLibrarySimulation_TestIntCompareFromPlayMap) == 0x000030, "Wrong size on TestLibrarySimulation_TestIntCompareFromPlayMap");
static_assert(offsetof(TestLibrarySimulation_TestIntCompareFromPlayMap, Value) == 0x000000, "Member 'TestLibrarySimulation_TestIntCompareFromPlayMap::Value' has a wrong offset!");
static_assert(offsetof(TestLibrarySimulation_TestIntCompareFromPlayMap, Other) == 0x000004, "Member 'TestLibrarySimulation_TestIntCompareFromPlayMap::Other' has a wrong offset!");
static_assert(offsetof(TestLibrarySimulation_TestIntCompareFromPlayMap, Comparison) == 0x000008, "Member 'TestLibrarySimulation_TestIntCompareFromPlayMap::Comparison' has a wrong offset!");
static_assert(offsetof(TestLibrarySimulation_TestIntCompareFromPlayMap, IssueType) == 0x000009, "Member 'TestLibrarySimulation_TestIntCompareFromPlayMap::IssueType' has a wrong offset!");
static_assert(offsetof(TestLibrarySimulation_TestIntCompareFromPlayMap, IssueCategory) == 0x000010, "Member 'TestLibrarySimulation_TestIntCompareFromPlayMap::IssueCategory' has a wrong offset!");
static_assert(offsetof(TestLibrarySimulation_TestIntCompareFromPlayMap, IssueMessage) == 0x000020, "Member 'TestLibrarySimulation_TestIntCompareFromPlayMap::IssueMessage' has a wrong offset!");

// Function GbxTest.TestLibrarySimulation.TestIntInRangeFromPlayMap
// 0x0030 (0x0030 - 0x0000)
struct TestLibrarySimulation_TestIntInRangeFromPlayMap final
{
public:
	int32                                         Value;                                             // 0x0000(0x0004)(ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         Min;                                               // 0x0004(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         Max;                                               // 0x0008(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	ETestIssueType                                IssueType;                                         // 0x000C(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, AdvancedDisplay, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_D[0x3];                                        // 0x000D(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	class FString                                 IssueCategory;                                     // 0x0010(0x0010)(Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FString                                 IssueMessage;                                      // 0x0020(0x0010)(Parm, ZeroConstructor, AdvancedDisplay, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(TestLibrarySimulation_TestIntInRangeFromPlayMap) == 0x000008, "Wrong alignment on TestLibrarySimulation_TestIntInRangeFromPlayMap");
static_assert(sizeof(TestLibrarySimulation_TestIntInRangeFromPlayMap) == 0x000030, "Wrong size on TestLibrarySimulation_TestIntInRangeFromPlayMap");
static_assert(offsetof(TestLibrarySimulation_TestIntInRangeFromPlayMap, Value) == 0x000000, "Member 'TestLibrarySimulation_TestIntInRangeFromPlayMap::Value' has a wrong offset!");
static_assert(offsetof(TestLibrarySimulation_TestIntInRangeFromPlayMap, Min) == 0x000004, "Member 'TestLibrarySimulation_TestIntInRangeFromPlayMap::Min' has a wrong offset!");
static_assert(offsetof(TestLibrarySimulation_TestIntInRangeFromPlayMap, Max) == 0x000008, "Member 'TestLibrarySimulation_TestIntInRangeFromPlayMap::Max' has a wrong offset!");
static_assert(offsetof(TestLibrarySimulation_TestIntInRangeFromPlayMap, IssueType) == 0x00000C, "Member 'TestLibrarySimulation_TestIntInRangeFromPlayMap::IssueType' has a wrong offset!");
static_assert(offsetof(TestLibrarySimulation_TestIntInRangeFromPlayMap, IssueCategory) == 0x000010, "Member 'TestLibrarySimulation_TestIntInRangeFromPlayMap::IssueCategory' has a wrong offset!");
static_assert(offsetof(TestLibrarySimulation_TestIntInRangeFromPlayMap, IssueMessage) == 0x000020, "Member 'TestLibrarySimulation_TestIntInRangeFromPlayMap::IssueMessage' has a wrong offset!");

// Function GbxTest.TestPolicy.OnRunTestCommand
// 0x0010 (0x0010 - 0x0000)
struct TestPolicy_OnRunTestCommand final
{
public:
	class FString                                 TestCommand;                                       // 0x0000(0x0010)(Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(TestPolicy_OnRunTestCommand) == 0x000008, "Wrong alignment on TestPolicy_OnRunTestCommand");
static_assert(sizeof(TestPolicy_OnRunTestCommand) == 0x000010, "Wrong size on TestPolicy_OnRunTestCommand");
static_assert(offsetof(TestPolicy_OnRunTestCommand, TestCommand) == 0x000000, "Member 'TestPolicy_OnRunTestCommand::TestCommand' has a wrong offset!");

// Function GbxTest.TestPolicy.PopAssetContext
// 0x0018 (0x0018 - 0x0000)
struct TestPolicy_PopAssetContext final
{
public:
	struct FGbxProbeId                            ID;                                                // 0x0000(0x0018)(Parm, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(TestPolicy_PopAssetContext) == 0x000008, "Wrong alignment on TestPolicy_PopAssetContext");
static_assert(sizeof(TestPolicy_PopAssetContext) == 0x000018, "Wrong size on TestPolicy_PopAssetContext");
static_assert(offsetof(TestPolicy_PopAssetContext, ID) == 0x000000, "Member 'TestPolicy_PopAssetContext::ID' has a wrong offset!");

// Function GbxTest.TestPolicy.PushAssetContext
// 0x0018 (0x0018 - 0x0000)
struct TestPolicy_PushAssetContext final
{
public:
	struct FGbxProbeId                            ID;                                                // 0x0000(0x0018)(Parm, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(TestPolicy_PushAssetContext) == 0x000008, "Wrong alignment on TestPolicy_PushAssetContext");
static_assert(sizeof(TestPolicy_PushAssetContext) == 0x000018, "Wrong size on TestPolicy_PushAssetContext");
static_assert(offsetof(TestPolicy_PushAssetContext, ID) == 0x000000, "Member 'TestPolicy_PushAssetContext::ID' has a wrong offset!");

// Function GbxTest.TestPolicy.ReportIssue
// 0x0028 (0x0028 - 0x0000)
struct TestPolicy_ReportIssue final
{
public:
	ETestIssueType                                IssueType;                                         // 0x0000(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1[0x7];                                        // 0x0001(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	class FString                                 IssueCategory;                                     // 0x0008(0x0010)(Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FString                                 IssueMessage;                                      // 0x0018(0x0010)(Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(TestPolicy_ReportIssue) == 0x000008, "Wrong alignment on TestPolicy_ReportIssue");
static_assert(sizeof(TestPolicy_ReportIssue) == 0x000028, "Wrong size on TestPolicy_ReportIssue");
static_assert(offsetof(TestPolicy_ReportIssue, IssueType) == 0x000000, "Member 'TestPolicy_ReportIssue::IssueType' has a wrong offset!");
static_assert(offsetof(TestPolicy_ReportIssue, IssueCategory) == 0x000008, "Member 'TestPolicy_ReportIssue::IssueCategory' has a wrong offset!");
static_assert(offsetof(TestPolicy_ReportIssue, IssueMessage) == 0x000018, "Member 'TestPolicy_ReportIssue::IssueMessage' has a wrong offset!");

// Function GbxTest.TestPolicy.ReportResult
// 0x0048 (0x0048 - 0x0000)
struct TestPolicy_ReportResult final
{
public:
	bool                                          bSucceeded;                                        // 0x0000(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1[0x7];                                        // 0x0001(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	class FString                                 IssueCategory;                                     // 0x0008(0x0010)(Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FString                                 IssueMessage;                                      // 0x0018(0x0010)(Parm, ZeroConstructor, AdvancedDisplay, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FGbxProbeId                            AssetContext;                                      // 0x0028(0x0018)(Parm, AdvancedDisplay, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	ETestIssueType                                FailedIssueType;                                   // 0x0040(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, AdvancedDisplay, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_41[0x7];                                       // 0x0041(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(TestPolicy_ReportResult) == 0x000008, "Wrong alignment on TestPolicy_ReportResult");
static_assert(sizeof(TestPolicy_ReportResult) == 0x000048, "Wrong size on TestPolicy_ReportResult");
static_assert(offsetof(TestPolicy_ReportResult, bSucceeded) == 0x000000, "Member 'TestPolicy_ReportResult::bSucceeded' has a wrong offset!");
static_assert(offsetof(TestPolicy_ReportResult, IssueCategory) == 0x000008, "Member 'TestPolicy_ReportResult::IssueCategory' has a wrong offset!");
static_assert(offsetof(TestPolicy_ReportResult, IssueMessage) == 0x000018, "Member 'TestPolicy_ReportResult::IssueMessage' has a wrong offset!");
static_assert(offsetof(TestPolicy_ReportResult, AssetContext) == 0x000028, "Member 'TestPolicy_ReportResult::AssetContext' has a wrong offset!");
static_assert(offsetof(TestPolicy_ReportResult, FailedIssueType) == 0x000040, "Member 'TestPolicy_ReportResult::FailedIssueType' has a wrong offset!");

// Function GbxTest.TestPolicy.SetReportContext
// 0x0018 (0x0018 - 0x0000)
struct TestPolicy_SetReportContext final
{
public:
	class UObject*                                WorldContextObject;                                // 0x0000(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TArray<struct FGbxProbeId>                    AssetContexts;                                     // 0x0008(0x0010)(ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, NativeAccessSpecifierPublic)
};
static_assert(alignof(TestPolicy_SetReportContext) == 0x000008, "Wrong alignment on TestPolicy_SetReportContext");
static_assert(sizeof(TestPolicy_SetReportContext) == 0x000018, "Wrong size on TestPolicy_SetReportContext");
static_assert(offsetof(TestPolicy_SetReportContext, WorldContextObject) == 0x000000, "Member 'TestPolicy_SetReportContext::WorldContextObject' has a wrong offset!");
static_assert(offsetof(TestPolicy_SetReportContext, AssetContexts) == 0x000008, "Member 'TestPolicy_SetReportContext::AssetContexts' has a wrong offset!");

// Function GbxTest.TestPolicy.TestAssetAudit
// 0x0008 (0x0008 - 0x0000)
struct TestPolicy_TestAssetAudit final
{
public:
	const class UObject*                          Asset;                                             // 0x0000(0x0008)(ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(TestPolicy_TestAssetAudit) == 0x000008, "Wrong alignment on TestPolicy_TestAssetAudit");
static_assert(sizeof(TestPolicy_TestAssetAudit) == 0x000008, "Wrong size on TestPolicy_TestAssetAudit");
static_assert(offsetof(TestPolicy_TestAssetAudit, Asset) == 0x000000, "Member 'TestPolicy_TestAssetAudit::Asset' has a wrong offset!");

// Function GbxTest.TestPolicy.TestAssetTraits
// 0x0008 (0x0008 - 0x0000)
struct TestPolicy_TestAssetTraits final
{
public:
	const class UObject*                          Asset;                                             // 0x0000(0x0008)(ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(TestPolicy_TestAssetTraits) == 0x000008, "Wrong alignment on TestPolicy_TestAssetTraits");
static_assert(sizeof(TestPolicy_TestAssetTraits) == 0x000008, "Wrong size on TestPolicy_TestAssetTraits");
static_assert(offsetof(TestPolicy_TestAssetTraits, Asset) == 0x000000, "Member 'TestPolicy_TestAssetTraits::Asset' has a wrong offset!");

// Function GbxTest.TestPolicy.TestBoolIsFalse
// 0x0028 (0x0028 - 0x0000)
struct TestPolicy_TestBoolIsFalse final
{
public:
	bool                                          Value;                                             // 0x0000(0x0001)(ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	ETestIssueType                                IssueType;                                         // 0x0001(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, AdvancedDisplay, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2[0x6];                                        // 0x0002(0x0006)(Fixing Size After Last Property [ Dumper-7 ])
	class FString                                 IssueCategory;                                     // 0x0008(0x0010)(Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FString                                 IssueMessage;                                      // 0x0018(0x0010)(Parm, ZeroConstructor, AdvancedDisplay, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(TestPolicy_TestBoolIsFalse) == 0x000008, "Wrong alignment on TestPolicy_TestBoolIsFalse");
static_assert(sizeof(TestPolicy_TestBoolIsFalse) == 0x000028, "Wrong size on TestPolicy_TestBoolIsFalse");
static_assert(offsetof(TestPolicy_TestBoolIsFalse, Value) == 0x000000, "Member 'TestPolicy_TestBoolIsFalse::Value' has a wrong offset!");
static_assert(offsetof(TestPolicy_TestBoolIsFalse, IssueType) == 0x000001, "Member 'TestPolicy_TestBoolIsFalse::IssueType' has a wrong offset!");
static_assert(offsetof(TestPolicy_TestBoolIsFalse, IssueCategory) == 0x000008, "Member 'TestPolicy_TestBoolIsFalse::IssueCategory' has a wrong offset!");
static_assert(offsetof(TestPolicy_TestBoolIsFalse, IssueMessage) == 0x000018, "Member 'TestPolicy_TestBoolIsFalse::IssueMessage' has a wrong offset!");

// Function GbxTest.TestPolicy.TestBoolIsTrue
// 0x0028 (0x0028 - 0x0000)
struct TestPolicy_TestBoolIsTrue final
{
public:
	bool                                          Value;                                             // 0x0000(0x0001)(ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	ETestIssueType                                IssueType;                                         // 0x0001(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, AdvancedDisplay, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2[0x6];                                        // 0x0002(0x0006)(Fixing Size After Last Property [ Dumper-7 ])
	class FString                                 IssueCategory;                                     // 0x0008(0x0010)(Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FString                                 IssueMessage;                                      // 0x0018(0x0010)(Parm, ZeroConstructor, AdvancedDisplay, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(TestPolicy_TestBoolIsTrue) == 0x000008, "Wrong alignment on TestPolicy_TestBoolIsTrue");
static_assert(sizeof(TestPolicy_TestBoolIsTrue) == 0x000028, "Wrong size on TestPolicy_TestBoolIsTrue");
static_assert(offsetof(TestPolicy_TestBoolIsTrue, Value) == 0x000000, "Member 'TestPolicy_TestBoolIsTrue::Value' has a wrong offset!");
static_assert(offsetof(TestPolicy_TestBoolIsTrue, IssueType) == 0x000001, "Member 'TestPolicy_TestBoolIsTrue::IssueType' has a wrong offset!");
static_assert(offsetof(TestPolicy_TestBoolIsTrue, IssueCategory) == 0x000008, "Member 'TestPolicy_TestBoolIsTrue::IssueCategory' has a wrong offset!");
static_assert(offsetof(TestPolicy_TestBoolIsTrue, IssueMessage) == 0x000018, "Member 'TestPolicy_TestBoolIsTrue::IssueMessage' has a wrong offset!");

// Function GbxTest.TestPolicy.TestFloatCompare
// 0x0038 (0x0038 - 0x0000)
struct TestPolicy_TestFloatCompare final
{
public:
	float                                         Value;                                             // 0x0000(0x0004)(ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         Other;                                             // 0x0004(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	ECompare                                      Comparison;                                        // 0x0008(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, AdvancedDisplay, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	ETestIssueType                                IssueType;                                         // 0x0009(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, AdvancedDisplay, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_A[0x6];                                        // 0x000A(0x0006)(Fixing Size After Last Property [ Dumper-7 ])
	class FString                                 IssueCategory;                                     // 0x0010(0x0010)(Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FString                                 IssueMessage;                                      // 0x0020(0x0010)(Parm, ZeroConstructor, AdvancedDisplay, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         Tolerance;                                         // 0x0030(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, AdvancedDisplay, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_34[0x4];                                       // 0x0034(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(TestPolicy_TestFloatCompare) == 0x000008, "Wrong alignment on TestPolicy_TestFloatCompare");
static_assert(sizeof(TestPolicy_TestFloatCompare) == 0x000038, "Wrong size on TestPolicy_TestFloatCompare");
static_assert(offsetof(TestPolicy_TestFloatCompare, Value) == 0x000000, "Member 'TestPolicy_TestFloatCompare::Value' has a wrong offset!");
static_assert(offsetof(TestPolicy_TestFloatCompare, Other) == 0x000004, "Member 'TestPolicy_TestFloatCompare::Other' has a wrong offset!");
static_assert(offsetof(TestPolicy_TestFloatCompare, Comparison) == 0x000008, "Member 'TestPolicy_TestFloatCompare::Comparison' has a wrong offset!");
static_assert(offsetof(TestPolicy_TestFloatCompare, IssueType) == 0x000009, "Member 'TestPolicy_TestFloatCompare::IssueType' has a wrong offset!");
static_assert(offsetof(TestPolicy_TestFloatCompare, IssueCategory) == 0x000010, "Member 'TestPolicy_TestFloatCompare::IssueCategory' has a wrong offset!");
static_assert(offsetof(TestPolicy_TestFloatCompare, IssueMessage) == 0x000020, "Member 'TestPolicy_TestFloatCompare::IssueMessage' has a wrong offset!");
static_assert(offsetof(TestPolicy_TestFloatCompare, Tolerance) == 0x000030, "Member 'TestPolicy_TestFloatCompare::Tolerance' has a wrong offset!");

// Function GbxTest.TestPolicy.TestFloatInRange
// 0x0030 (0x0030 - 0x0000)
struct TestPolicy_TestFloatInRange final
{
public:
	float                                         Value;                                             // 0x0000(0x0004)(ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         Min;                                               // 0x0004(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         Max;                                               // 0x0008(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	ETestIssueType                                IssueType;                                         // 0x000C(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, AdvancedDisplay, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_D[0x3];                                        // 0x000D(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	class FString                                 IssueCategory;                                     // 0x0010(0x0010)(Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FString                                 IssueMessage;                                      // 0x0020(0x0010)(Parm, ZeroConstructor, AdvancedDisplay, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(TestPolicy_TestFloatInRange) == 0x000008, "Wrong alignment on TestPolicy_TestFloatInRange");
static_assert(sizeof(TestPolicy_TestFloatInRange) == 0x000030, "Wrong size on TestPolicy_TestFloatInRange");
static_assert(offsetof(TestPolicy_TestFloatInRange, Value) == 0x000000, "Member 'TestPolicy_TestFloatInRange::Value' has a wrong offset!");
static_assert(offsetof(TestPolicy_TestFloatInRange, Min) == 0x000004, "Member 'TestPolicy_TestFloatInRange::Min' has a wrong offset!");
static_assert(offsetof(TestPolicy_TestFloatInRange, Max) == 0x000008, "Member 'TestPolicy_TestFloatInRange::Max' has a wrong offset!");
static_assert(offsetof(TestPolicy_TestFloatInRange, IssueType) == 0x00000C, "Member 'TestPolicy_TestFloatInRange::IssueType' has a wrong offset!");
static_assert(offsetof(TestPolicy_TestFloatInRange, IssueCategory) == 0x000010, "Member 'TestPolicy_TestFloatInRange::IssueCategory' has a wrong offset!");
static_assert(offsetof(TestPolicy_TestFloatInRange, IssueMessage) == 0x000020, "Member 'TestPolicy_TestFloatInRange::IssueMessage' has a wrong offset!");

// Function GbxTest.TestPolicy.TestIntCompare
// 0x0030 (0x0030 - 0x0000)
struct TestPolicy_TestIntCompare final
{
public:
	int32                                         Value;                                             // 0x0000(0x0004)(ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         Other;                                             // 0x0004(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	ECompare                                      Comparison;                                        // 0x0008(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, AdvancedDisplay, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	ETestIssueType                                IssueType;                                         // 0x0009(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, AdvancedDisplay, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_A[0x6];                                        // 0x000A(0x0006)(Fixing Size After Last Property [ Dumper-7 ])
	class FString                                 IssueCategory;                                     // 0x0010(0x0010)(Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FString                                 IssueMessage;                                      // 0x0020(0x0010)(Parm, ZeroConstructor, AdvancedDisplay, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(TestPolicy_TestIntCompare) == 0x000008, "Wrong alignment on TestPolicy_TestIntCompare");
static_assert(sizeof(TestPolicy_TestIntCompare) == 0x000030, "Wrong size on TestPolicy_TestIntCompare");
static_assert(offsetof(TestPolicy_TestIntCompare, Value) == 0x000000, "Member 'TestPolicy_TestIntCompare::Value' has a wrong offset!");
static_assert(offsetof(TestPolicy_TestIntCompare, Other) == 0x000004, "Member 'TestPolicy_TestIntCompare::Other' has a wrong offset!");
static_assert(offsetof(TestPolicy_TestIntCompare, Comparison) == 0x000008, "Member 'TestPolicy_TestIntCompare::Comparison' has a wrong offset!");
static_assert(offsetof(TestPolicy_TestIntCompare, IssueType) == 0x000009, "Member 'TestPolicy_TestIntCompare::IssueType' has a wrong offset!");
static_assert(offsetof(TestPolicy_TestIntCompare, IssueCategory) == 0x000010, "Member 'TestPolicy_TestIntCompare::IssueCategory' has a wrong offset!");
static_assert(offsetof(TestPolicy_TestIntCompare, IssueMessage) == 0x000020, "Member 'TestPolicy_TestIntCompare::IssueMessage' has a wrong offset!");

// Function GbxTest.TestPolicy.TestIntInRange
// 0x0030 (0x0030 - 0x0000)
struct TestPolicy_TestIntInRange final
{
public:
	int32                                         Value;                                             // 0x0000(0x0004)(ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         Min;                                               // 0x0004(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         Max;                                               // 0x0008(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	ETestIssueType                                IssueType;                                         // 0x000C(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, AdvancedDisplay, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_D[0x3];                                        // 0x000D(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	class FString                                 IssueCategory;                                     // 0x0010(0x0010)(Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FString                                 IssueMessage;                                      // 0x0020(0x0010)(Parm, ZeroConstructor, AdvancedDisplay, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(TestPolicy_TestIntInRange) == 0x000008, "Wrong alignment on TestPolicy_TestIntInRange");
static_assert(sizeof(TestPolicy_TestIntInRange) == 0x000030, "Wrong size on TestPolicy_TestIntInRange");
static_assert(offsetof(TestPolicy_TestIntInRange, Value) == 0x000000, "Member 'TestPolicy_TestIntInRange::Value' has a wrong offset!");
static_assert(offsetof(TestPolicy_TestIntInRange, Min) == 0x000004, "Member 'TestPolicy_TestIntInRange::Min' has a wrong offset!");
static_assert(offsetof(TestPolicy_TestIntInRange, Max) == 0x000008, "Member 'TestPolicy_TestIntInRange::Max' has a wrong offset!");
static_assert(offsetof(TestPolicy_TestIntInRange, IssueType) == 0x00000C, "Member 'TestPolicy_TestIntInRange::IssueType' has a wrong offset!");
static_assert(offsetof(TestPolicy_TestIntInRange, IssueCategory) == 0x000010, "Member 'TestPolicy_TestIntInRange::IssueCategory' has a wrong offset!");
static_assert(offsetof(TestPolicy_TestIntInRange, IssueMessage) == 0x000020, "Member 'TestPolicy_TestIntInRange::IssueMessage' has a wrong offset!");

// Function GbxTest.TestPolicy.OnGetTestCommands
// 0x0020 (0x0020 - 0x0000)
struct TestPolicy_OnGetTestCommands final
{
public:
	TArray<class FString>                         TestCommands;                                      // 0x0000(0x0010)(Parm, OutParm, ZeroConstructor, NativeAccessSpecifierPublic)
	TArray<class FString>                         PrettyNames;                                       // 0x0010(0x0010)(Parm, OutParm, ZeroConstructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(TestPolicy_OnGetTestCommands) == 0x000008, "Wrong alignment on TestPolicy_OnGetTestCommands");
static_assert(sizeof(TestPolicy_OnGetTestCommands) == 0x000020, "Wrong size on TestPolicy_OnGetTestCommands");
static_assert(offsetof(TestPolicy_OnGetTestCommands, TestCommands) == 0x000000, "Member 'TestPolicy_OnGetTestCommands::TestCommands' has a wrong offset!");
static_assert(offsetof(TestPolicy_OnGetTestCommands, PrettyNames) == 0x000010, "Member 'TestPolicy_OnGetTestCommands::PrettyNames' has a wrong offset!");

// Function GbxTest.TestPolicyContent.OnValidForImport
// 0x0010 (0x0010 - 0x0000)
struct TestPolicyContent_OnValidForImport final
{
public:
	const class UObject*                          ImportObject;                                      // 0x0000(0x0008)(ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          Result;                                            // 0x0008(0x0001)(Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_9[0x7];                                        // 0x0009(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(TestPolicyContent_OnValidForImport) == 0x000008, "Wrong alignment on TestPolicyContent_OnValidForImport");
static_assert(sizeof(TestPolicyContent_OnValidForImport) == 0x000010, "Wrong size on TestPolicyContent_OnValidForImport");
static_assert(offsetof(TestPolicyContent_OnValidForImport, ImportObject) == 0x000000, "Member 'TestPolicyContent_OnValidForImport::ImportObject' has a wrong offset!");
static_assert(offsetof(TestPolicyContent_OnValidForImport, Result) == 0x000008, "Member 'TestPolicyContent_OnValidForImport::Result' has a wrong offset!");

// Function GbxTest.TestPolicySimulation.AddTestDriver
// 0x0008 (0x0008 - 0x0000)
struct TestPolicySimulation_AddTestDriver final
{
public:
	TSubclassOf<class AActor>                     TestDriver;                                        // 0x0000(0x0008)(ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(TestPolicySimulation_AddTestDriver) == 0x000008, "Wrong alignment on TestPolicySimulation_AddTestDriver");
static_assert(sizeof(TestPolicySimulation_AddTestDriver) == 0x000008, "Wrong size on TestPolicySimulation_AddTestDriver");
static_assert(offsetof(TestPolicySimulation_AddTestDriver, TestDriver) == 0x000000, "Member 'TestPolicySimulation_AddTestDriver::TestDriver' has a wrong offset!");

// Function GbxTest.TestPolicySimulation.IntendToMapTravel
// 0x0001 (0x0001 - 0x0000)
struct TestPolicySimulation_IntendToMapTravel final
{
public:
	bool                                          WillMapTravel;                                     // 0x0000(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(TestPolicySimulation_IntendToMapTravel) == 0x000001, "Wrong alignment on TestPolicySimulation_IntendToMapTravel");
static_assert(sizeof(TestPolicySimulation_IntendToMapTravel) == 0x000001, "Wrong size on TestPolicySimulation_IntendToMapTravel");
static_assert(offsetof(TestPolicySimulation_IntendToMapTravel, WillMapTravel) == 0x000000, "Member 'TestPolicySimulation_IntendToMapTravel::WillMapTravel' has a wrong offset!");

// Function GbxTest.TestPolicySimulation.OnMapTraveled
// 0x0008 (0x0008 - 0x0000)
struct TestPolicySimulation_OnMapTraveled final
{
public:
	class UWorld*                                 NewWorld;                                          // 0x0000(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(TestPolicySimulation_OnMapTraveled) == 0x000008, "Wrong alignment on TestPolicySimulation_OnMapTraveled");
static_assert(sizeof(TestPolicySimulation_OnMapTraveled) == 0x000008, "Wrong size on TestPolicySimulation_OnMapTraveled");
static_assert(offsetof(TestPolicySimulation_OnMapTraveled, NewWorld) == 0x000000, "Member 'TestPolicySimulation_OnMapTraveled::NewWorld' has a wrong offset!");

// Function GbxTest.TestPolicySimulation.PlayMap
// 0x0028 (0x0028 - 0x0000)
struct TestPolicySimulation_PlayMap final
{
public:
	class FString                                 MapName;                                           // 0x0000(0x0010)(Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TArray<TSubclassOf<class AActor>>             TestDrivers;                                       // 0x0010(0x0010)(ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, UObjectWrapper, NativeAccessSpecifierPublic)
	float                                         Timeout;                                           // 0x0020(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, AdvancedDisplay, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         TimeLimit;                                         // 0x0024(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, AdvancedDisplay, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(TestPolicySimulation_PlayMap) == 0x000008, "Wrong alignment on TestPolicySimulation_PlayMap");
static_assert(sizeof(TestPolicySimulation_PlayMap) == 0x000028, "Wrong size on TestPolicySimulation_PlayMap");
static_assert(offsetof(TestPolicySimulation_PlayMap, MapName) == 0x000000, "Member 'TestPolicySimulation_PlayMap::MapName' has a wrong offset!");
static_assert(offsetof(TestPolicySimulation_PlayMap, TestDrivers) == 0x000010, "Member 'TestPolicySimulation_PlayMap::TestDrivers' has a wrong offset!");
static_assert(offsetof(TestPolicySimulation_PlayMap, Timeout) == 0x000020, "Member 'TestPolicySimulation_PlayMap::Timeout' has a wrong offset!");
static_assert(offsetof(TestPolicySimulation_PlayMap, TimeLimit) == 0x000024, "Member 'TestPolicySimulation_PlayMap::TimeLimit' has a wrong offset!");

// Function GbxTest.TestPolicySimulation.PlayTestMap
// 0x0030 (0x0030 - 0x0000)
struct TestPolicySimulation_PlayTestMap final
{
public:
	class FString                                 MapName;                                           // 0x0000(0x0010)(Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TArray<TSubclassOf<class AActor>>             TestDrivers;                                       // 0x0010(0x0010)(ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, UObjectWrapper, NativeAccessSpecifierPublic)
	float                                         Timeout;                                           // 0x0020(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, AdvancedDisplay, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         TimeLimit;                                         // 0x0024(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, AdvancedDisplay, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bLoadMapOnce;                                      // 0x0028(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, AdvancedDisplay, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bLoadMapIfNotLoaded;                               // 0x0029(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, AdvancedDisplay, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2A[0x6];                                       // 0x002A(0x0006)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(TestPolicySimulation_PlayTestMap) == 0x000008, "Wrong alignment on TestPolicySimulation_PlayTestMap");
static_assert(sizeof(TestPolicySimulation_PlayTestMap) == 0x000030, "Wrong size on TestPolicySimulation_PlayTestMap");
static_assert(offsetof(TestPolicySimulation_PlayTestMap, MapName) == 0x000000, "Member 'TestPolicySimulation_PlayTestMap::MapName' has a wrong offset!");
static_assert(offsetof(TestPolicySimulation_PlayTestMap, TestDrivers) == 0x000010, "Member 'TestPolicySimulation_PlayTestMap::TestDrivers' has a wrong offset!");
static_assert(offsetof(TestPolicySimulation_PlayTestMap, Timeout) == 0x000020, "Member 'TestPolicySimulation_PlayTestMap::Timeout' has a wrong offset!");
static_assert(offsetof(TestPolicySimulation_PlayTestMap, TimeLimit) == 0x000024, "Member 'TestPolicySimulation_PlayTestMap::TimeLimit' has a wrong offset!");
static_assert(offsetof(TestPolicySimulation_PlayTestMap, bLoadMapOnce) == 0x000028, "Member 'TestPolicySimulation_PlayTestMap::bLoadMapOnce' has a wrong offset!");
static_assert(offsetof(TestPolicySimulation_PlayTestMap, bLoadMapIfNotLoaded) == 0x000029, "Member 'TestPolicySimulation_PlayTestMap::bLoadMapIfNotLoaded' has a wrong offset!");

// Function GbxTest.TestPolicySimulation.RunTestDrivers
// 0x0018 (0x0018 - 0x0000)
struct TestPolicySimulation_RunTestDrivers final
{
public:
	TArray<TSubclassOf<class AActor>>             TestDrivers;                                       // 0x0000(0x0010)(ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, UObjectWrapper, NativeAccessSpecifierPublic)
	float                                         Timeout;                                           // 0x0010(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, AdvancedDisplay, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         TimeLimit;                                         // 0x0014(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, AdvancedDisplay, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(TestPolicySimulation_RunTestDrivers) == 0x000008, "Wrong alignment on TestPolicySimulation_RunTestDrivers");
static_assert(sizeof(TestPolicySimulation_RunTestDrivers) == 0x000018, "Wrong size on TestPolicySimulation_RunTestDrivers");
static_assert(offsetof(TestPolicySimulation_RunTestDrivers, TestDrivers) == 0x000000, "Member 'TestPolicySimulation_RunTestDrivers::TestDrivers' has a wrong offset!");
static_assert(offsetof(TestPolicySimulation_RunTestDrivers, Timeout) == 0x000010, "Member 'TestPolicySimulation_RunTestDrivers::Timeout' has a wrong offset!");
static_assert(offsetof(TestPolicySimulation_RunTestDrivers, TimeLimit) == 0x000014, "Member 'TestPolicySimulation_RunTestDrivers::TimeLimit' has a wrong offset!");

}

