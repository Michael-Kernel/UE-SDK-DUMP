#pragma once

/*
* SDK generated by Dumper-7
*
* https://github.com/Encryqed/Dumper-7
*/

// Package: GbxTest

#include "Basic.hpp"

#include "GbxTest_classes.hpp"
#include "GbxTest_parameters.hpp"


namespace SDK
{

// Function GbxTest.AutomationMenuHelper.CreateAutomationMenuHelper
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// class AGbxPlayerController*             PlayerController                                       (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    SimulateAllInputs                                      (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class UAutomationMenuHelper*            ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class UAutomationMenuHelper* UAutomationMenuHelper::CreateAutomationMenuHelper(class AGbxPlayerController* PlayerController, const bool SimulateAllInputs)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("AutomationMenuHelper", "CreateAutomationMenuHelper");

	Params::AutomationMenuHelper_CreateAutomationMenuHelper Parms{};

	Parms.PlayerController = PlayerController;
	Parms.SimulateAllInputs = SimulateAllInputs;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function GbxTest.AutomationMenuHelper.ActuateFocus
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// EAutomationUIAction                     Action                                                 (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UAutomationMenuHelper::ActuateFocus(const EAutomationUIAction Action)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("AutomationMenuHelper", "ActuateFocus");

	Params::AutomationMenuHelper_ActuateFocus Parms{};

	Parms.Action = Action;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function GbxTest.AutomationMenuHelper.BackOut
// (Final, Native, Public, BlueprintCallable)

void UAutomationMenuHelper::BackOut()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("AutomationMenuHelper", "BackOut");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function GbxTest.AutomationMenuHelper.CurrentDepth
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// int32                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

int32 UAutomationMenuHelper::CurrentDepth()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("AutomationMenuHelper", "CurrentDepth");

	Params::AutomationMenuHelper_CurrentDepth Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function GbxTest.AutomationMenuHelper.FocusInfo
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// struct FAutomationMenuFocusInfo         ReturnValue                                            (Parm, OutParm, ReturnParm, NativeAccessSpecifierPublic)

struct FAutomationMenuFocusInfo UAutomationMenuHelper::FocusInfo()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("AutomationMenuHelper", "FocusInfo");

	Params::AutomationMenuHelper_FocusInfo Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function GbxTest.AutomationMenuHelper.FocusName
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// class FName                             ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class FName UAutomationMenuHelper::FocusName()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("AutomationMenuHelper", "FocusName");

	Params::AutomationMenuHelper_FocusName Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function GbxTest.AutomationMenuHelper.HasOpenMenu
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UAutomationMenuHelper::HasOpenMenu()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("AutomationMenuHelper", "HasOpenMenu");

	Params::AutomationMenuHelper_HasOpenMenu Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function GbxTest.AutomationMenuHelper.MenuName
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// class FName                             ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class FName UAutomationMenuHelper::MenuName()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("AutomationMenuHelper", "MenuName");

	Params::AutomationMenuHelper_MenuName Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function GbxTest.AutomationMenuHelper.NextFocus
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// EAutomationUIDirection                  Direction                                              (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UAutomationMenuHelper::NextFocus(const EAutomationUIDirection Direction)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("AutomationMenuHelper", "NextFocus");

	Params::AutomationMenuHelper_NextFocus Parms{};

	Parms.Direction = Direction;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function GbxTest.AutomationMenuHelper.NextPage
// (Final, Native, Public, BlueprintCallable)

void UAutomationMenuHelper::NextPage()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("AutomationMenuHelper", "NextPage");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function GbxTest.AutomationMenuHelper.NumPages
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// int32                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

int32 UAutomationMenuHelper::NumPages()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("AutomationMenuHelper", "NumPages");

	Params::AutomationMenuHelper_NumPages Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function GbxTest.AutomationMenuHelper.PageName
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// class FName                             ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class FName UAutomationMenuHelper::PageName()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("AutomationMenuHelper", "PageName");

	Params::AutomationMenuHelper_PageName Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function GbxTest.AutomationMenuHelper.PrevPage
// (Final, Native, Public, BlueprintCallable)

void UAutomationMenuHelper::PrevPage()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("AutomationMenuHelper", "PrevPage");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function GbxTest.AutomationUILibrary.ForceDisableTutorials
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// bool                                    ForceDisable                                           (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UAutomationUILibrary::ForceDisableTutorials(const bool ForceDisable)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("AutomationUILibrary", "ForceDisableTutorials");

	Params::AutomationUILibrary_ForceDisableTutorials Parms{};

	Parms.ForceDisable = ForceDisable;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function GbxTest.PerfMapCapture.SavePerfMapCaptures
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// class UObject*                          World                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class FString                           Path                                                   (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   Density                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    bLighting                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    bSpecular                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   Gamma                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   Width                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   Height                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   VolumeX                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   VolumeY                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   VolumeZ                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class FString                           OutputPattern                                          (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UPerfMapCapture::SavePerfMapCaptures(class UObject* World, const class FString& Path, float Density, bool bLighting, bool bSpecular, float Gamma, int32 Width, int32 Height, float VolumeX, float VolumeY, float VolumeZ, const class FString& OutputPattern)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("PerfMapCapture", "SavePerfMapCaptures");

	Params::PerfMapCapture_SavePerfMapCaptures Parms{};

	Parms.World = World;
	Parms.Path = std::move(Path);
	Parms.Density = Density;
	Parms.bLighting = bLighting;
	Parms.bSpecular = bSpecular;
	Parms.Gamma = Gamma;
	Parms.Width = Width;
	Parms.Height = Height;
	Parms.VolumeX = VolumeX;
	Parms.VolumeY = VolumeY;
	Parms.VolumeZ = VolumeZ;
	Parms.OutputPattern = std::move(OutputPattern);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function GbxTest.PerfMapCapture.SavePerfMapCapturesFromConfiguration
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// class UWorld*                           World                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class FString                           Path                                                   (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FMapParameters                   Configuration                                          (Parm, NativeAccessSpecifierPublic)
// struct FLatentActionInfo                LatentInfo                                             (Parm, NoDestructor, NativeAccessSpecifierPublic)

void UPerfMapCapture::SavePerfMapCapturesFromConfiguration(class UWorld* World, const class FString& Path, const struct FMapParameters& Configuration, const struct FLatentActionInfo& LatentInfo)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("PerfMapCapture", "SavePerfMapCapturesFromConfiguration");

	Params::PerfMapCapture_SavePerfMapCapturesFromConfiguration Parms{};

	Parms.World = World;
	Parms.Path = std::move(Path);
	Parms.Configuration = std::move(Configuration);
	Parms.LatentInfo = std::move(LatentInfo);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function GbxTest.PerformanceSnapshotCollector.CreatePerformanceSnapshotCollector
// (Final, Native, Static, Public, HasOutParams, BlueprintCallable)
// Parameters:
// class FString                           StatSection                                            (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// ESnapshotExecOutput                     ExecOut                                                (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class UPerformanceSnapshotCollector*    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class UPerformanceSnapshotCollector* UPerformanceSnapshotCollector::CreatePerformanceSnapshotCollector(const class FString& StatSection, ESnapshotExecOutput* ExecOut)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("PerformanceSnapshotCollector", "CreatePerformanceSnapshotCollector");

	Params::PerformanceSnapshotCollector_CreatePerformanceSnapshotCollector Parms{};

	Parms.StatSection = std::move(StatSection);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	if (ExecOut != nullptr)
		*ExecOut = Parms.ExecOut;

	return Parms.ReturnValue;
}


// Function GbxTest.PerformanceSnapshotCollector.CollectProbeSnapshot
// (Final, Native, Public, HasOutParams, BlueprintCallable)
// Parameters:
// class UObject*                          WorldContextObject                                     (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class FString                           ReportContext                                          (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FGbxProbeId                      ProbeId                                                (ConstParm, Parm, OutParm, ReferenceParm, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class FString                           Test                                                   (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// TArray<struct FGbxProbeExtraData>       ExtraDataArray                                         (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, NativeAccessSpecifierPublic)
// struct FLatentActionInfo                LatentInfo                                             (Parm, NoDestructor, NativeAccessSpecifierPublic)

void UPerformanceSnapshotCollector::CollectProbeSnapshot(class UObject* WorldContextObject, const class FString& ReportContext, const struct FGbxProbeId& ProbeId, const class FString& Test, const TArray<struct FGbxProbeExtraData>& ExtraDataArray, const struct FLatentActionInfo& LatentInfo)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("PerformanceSnapshotCollector", "CollectProbeSnapshot");

	Params::PerformanceSnapshotCollector_CollectProbeSnapshot Parms{};

	Parms.WorldContextObject = WorldContextObject;
	Parms.ReportContext = std::move(ReportContext);
	Parms.ProbeId = std::move(ProbeId);
	Parms.Test = std::move(Test);
	Parms.ExtraDataArray = std::move(ExtraDataArray);
	Parms.LatentInfo = std::move(LatentInfo);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function GbxTest.PerformanceSnapshotCollector.CollectSnapshot
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// class UObject*                          WorldContextObject                                     (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class FString                           ReportContext                                          (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FLatentActionInfo                LatentInfo                                             (Parm, NoDestructor, NativeAccessSpecifierPublic)

void UPerformanceSnapshotCollector::CollectSnapshot(class UObject* WorldContextObject, const class FString& ReportContext, const struct FLatentActionInfo& LatentInfo)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("PerformanceSnapshotCollector", "CollectSnapshot");

	Params::PerformanceSnapshotCollector_CollectSnapshot Parms{};

	Parms.WorldContextObject = WorldContextObject;
	Parms.ReportContext = std::move(ReportContext);
	Parms.LatentInfo = std::move(LatentInfo);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function GbxTest.PerformanceSnapshotCollector.ResetSnapshotProviders
// (Final, Native, Public, BlueprintCallable)

void UPerformanceSnapshotCollector::ResetSnapshotProviders()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("PerformanceSnapshotCollector", "ResetSnapshotProviders");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function GbxTest.MatcherFunctionality.Empty
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UMatcherFunctionality::Empty()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("MatcherFunctionality", "Empty");

	Params::MatcherFunctionality_Empty Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function GbxTest.MatcherFunctionality.GetAtIndex
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// int32                                   Index_0                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class FString                           ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class FString UMatcherFunctionality::GetAtIndex(int32 Index_0)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("MatcherFunctionality", "GetAtIndex");

	Params::MatcherFunctionality_GetAtIndex Parms{};

	Parms.Index_0 = Index_0;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function GbxTest.MatcherFunctionality.GetLength
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// int32                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

int32 UMatcherFunctionality::GetLength()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("MatcherFunctionality", "GetLength");

	Params::MatcherFunctionality_GetLength Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function GbxTest.MatcherFunctionality.GetMatch
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// int32                                   Index_0                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class FString                           ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class FString UMatcherFunctionality::GetMatch(int32 Index_0)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("MatcherFunctionality", "GetMatch");

	Params::MatcherFunctionality_GetMatch Parms{};

	Parms.Index_0 = Index_0;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function GbxTest.MatcherFunctionality.GetPosition
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// int32                                   Start                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

int32 UMatcherFunctionality::GetPosition(int32 Start)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("MatcherFunctionality", "GetPosition");

	Params::MatcherFunctionality_GetPosition Parms{};

	Parms.Start = Start;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function GbxTest.MatcherFunctionality.GetPrefix
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// class FString                           ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class FString UMatcherFunctionality::GetPrefix()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("MatcherFunctionality", "GetPrefix");

	Params::MatcherFunctionality_GetPrefix Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function GbxTest.MatcherFunctionality.GetSuffix
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// class FString                           ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class FString UMatcherFunctionality::GetSuffix()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("MatcherFunctionality", "GetSuffix");

	Params::MatcherFunctionality_GetSuffix Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function GbxTest.MatcherFunctionality.Ready
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UMatcherFunctionality::Ready()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("MatcherFunctionality", "Ready");

	Params::MatcherFunctionality_Ready Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function GbxTest.MatcherFunctionality.Size
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// int32                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

int32 UMatcherFunctionality::Size()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("MatcherFunctionality", "Size");

	Params::MatcherFunctionality_Size Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function GbxTest.RegexFunctionality.Assign
// (Final, Native, Static, Public, HasOutParams, BlueprintCallable)
// Parameters:
// struct FRegex                           Regex_0                                                (ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
// class FString                           Pattern                                                (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void URegexFunctionality::Assign(const struct FRegex& Regex_0, const class FString& Pattern)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("RegexFunctionality", "Assign");

	Params::RegexFunctionality_Assign Parms{};

	Parms.Regex_0 = std::move(Regex_0);
	Parms.Pattern = std::move(Pattern);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function GbxTest.RegexFunctionality.Assign2
// (Final, Native, Static, Public, HasOutParams, BlueprintCallable)
// Parameters:
// struct FRegex                           Regex_0                                                (ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
// class FString                           Pattern                                                (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// ESyntaxOption                           Flags_0                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void URegexFunctionality::Assign2(const struct FRegex& Regex_0, const class FString& Pattern, ESyntaxOption Flags_0)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("RegexFunctionality", "Assign2");

	Params::RegexFunctionality_Assign2 Parms{};

	Parms.Regex_0 = std::move(Regex_0);
	Parms.Pattern = std::move(Pattern);
	Parms.Flags_0 = Flags_0;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function GbxTest.RegexFunctionality.FindAll
// (Final, Native, Static, Public, HasOutParams, BlueprintCallable)
// Parameters:
// struct FRegex                           Regex_0                                                (Parm, NativeAccessSpecifierPublic)
// class FString                           String                                                 (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// TArray<class FString>                   Return                                                 (Parm, OutParm, ZeroConstructor, NativeAccessSpecifierPublic)

void URegexFunctionality::FindAll(const struct FRegex& Regex_0, const class FString& String, TArray<class FString>* Return)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("RegexFunctionality", "FindAll");

	Params::RegexFunctionality_FindAll Parms{};

	Parms.Regex_0 = std::move(Regex_0);
	Parms.String = std::move(String);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	if (Return != nullptr)
		*Return = std::move(Parms.Return);
}


// Function GbxTest.RegexFunctionality.RegexMatch
// (Final, Native, Static, Public, HasOutParams, BlueprintCallable)
// Parameters:
// struct FRegex                           Regex_0                                                (ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
// class FString                           Input                                                  (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool URegexFunctionality::RegexMatch(const struct FRegex& Regex_0, const class FString& Input)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("RegexFunctionality", "RegexMatch");

	Params::RegexFunctionality_RegexMatch Parms{};

	Parms.Regex_0 = std::move(Regex_0);
	Parms.Input = std::move(Input);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function GbxTest.RegexFunctionality.RegexMatch2
// (Final, Native, Static, Public, HasOutParams, BlueprintCallable)
// Parameters:
// struct FRegex                           Regex_0                                                (ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
// class UMatcherFunctionality*            Matcher                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class FString                           Input                                                  (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool URegexFunctionality::RegexMatch2(const struct FRegex& Regex_0, class UMatcherFunctionality* Matcher, const class FString& Input)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("RegexFunctionality", "RegexMatch2");

	Params::RegexFunctionality_RegexMatch2 Parms{};

	Parms.Regex_0 = std::move(Regex_0);
	Parms.Matcher = Matcher;
	Parms.Input = std::move(Input);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function GbxTest.RegexFunctionality.RegexRepleace
// (Final, Native, Static, Public, HasOutParams, BlueprintCallable)
// Parameters:
// struct FRegex                           Regex_0                                                (ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
// class FString                           Input                                                  (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class FString                           Repleacement                                           (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class FString                           ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class FString URegexFunctionality::RegexRepleace(const struct FRegex& Regex_0, const class FString& Input, const class FString& Repleacement)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("RegexFunctionality", "RegexRepleace");

	Params::RegexFunctionality_RegexRepleace Parms{};

	Parms.Regex_0 = std::move(Regex_0);
	Parms.Input = std::move(Input);
	Parms.Repleacement = std::move(Repleacement);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function GbxTest.RegexFunctionality.RegexSearch
// (Final, Native, Static, Public, HasOutParams, BlueprintCallable)
// Parameters:
// struct FRegex                           Regex_0                                                (ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
// class UMatcherFunctionality*            Matcher                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class FString                           Input                                                  (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool URegexFunctionality::RegexSearch(const struct FRegex& Regex_0, class UMatcherFunctionality* Matcher, const class FString& Input)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("RegexFunctionality", "RegexSearch");

	Params::RegexFunctionality_RegexSearch Parms{};

	Parms.Regex_0 = std::move(Regex_0);
	Parms.Matcher = Matcher;
	Parms.Input = std::move(Input);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function GbxTest.TestLibrary.AddArrayToCollection
// (Final, Native, Static, Public, HasOutParams, BlueprintCallable)
// Parameters:
// class FString                           CollectionName                                         (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// TArray<class FString>                   ObjectNames                                            (Parm, OutParm, ZeroConstructor, ReferenceParm, NativeAccessSpecifierPublic)

void UTestLibrary::AddArrayToCollection(const class FString& CollectionName, TArray<class FString>& ObjectNames)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("TestLibrary", "AddArrayToCollection");

	Params::TestLibrary_AddArrayToCollection Parms{};

	Parms.CollectionName = std::move(CollectionName);
	Parms.ObjectNames = std::move(ObjectNames);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	ObjectNames = std::move(Parms.ObjectNames);
}


// Function GbxTest.TestLibrary.AddItemToCollection
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// class FString                           CollectionName                                         (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class FString                           ObjectName                                             (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UTestLibrary::AddItemToCollection(const class FString& CollectionName, const class FString& ObjectName)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("TestLibrary", "AddItemToCollection");

	Params::TestLibrary_AddItemToCollection Parms{};

	Parms.CollectionName = std::move(CollectionName);
	Parms.ObjectName = std::move(ObjectName);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function GbxTest.TestLibrary.CollectionExists
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// class FString                           CollectionName                                         (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UTestLibrary::CollectionExists(const class FString& CollectionName)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("TestLibrary", "CollectionExists");

	Params::TestLibrary_CollectionExists Parms{};

	Parms.CollectionName = std::move(CollectionName);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function GbxTest.TestLibrary.CollectionExistsEx
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// class FString                           CollectionName                                         (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// ECollectionType                         CollectionType                                         (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UTestLibrary::CollectionExistsEx(const class FString& CollectionName, ECollectionType CollectionType)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("TestLibrary", "CollectionExistsEx");

	Params::TestLibrary_CollectionExistsEx Parms{};

	Parms.CollectionName = std::move(CollectionName);
	Parms.CollectionType = CollectionType;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function GbxTest.TestLibrary.ContainsObjectTag
// (Final, Native, Static, Public, HasOutParams, BlueprintCallable, BlueprintPure)
// Parameters:
// TArray<struct FObjectTag>               ObjectTags                                             (Parm, OutParm, ZeroConstructor, ReferenceParm, NativeAccessSpecifierPublic)
// class FString                           Category                                               (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class FString                           Name_0                                                 (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    bExactCategory                                         (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, AdvancedDisplay, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    bCaseSensitiveCategory                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, AdvancedDisplay, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    bExactName                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, AdvancedDisplay, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    bCaseSensitiveName                                     (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, AdvancedDisplay, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UTestLibrary::ContainsObjectTag(TArray<struct FObjectTag>& ObjectTags, const class FString& Category, const class FString& Name_0, bool bExactCategory, bool bCaseSensitiveCategory, bool bExactName, bool bCaseSensitiveName)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("TestLibrary", "ContainsObjectTag");

	Params::TestLibrary_ContainsObjectTag Parms{};

	Parms.ObjectTags = std::move(ObjectTags);
	Parms.Category = std::move(Category);
	Parms.Name_0 = std::move(Name_0);
	Parms.bExactCategory = bExactCategory;
	Parms.bCaseSensitiveCategory = bCaseSensitiveCategory;
	Parms.bExactName = bExactName;
	Parms.bCaseSensitiveName = bCaseSensitiveName;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	ObjectTags = std::move(Parms.ObjectTags);

	return Parms.ReturnValue;
}


// Function GbxTest.TestLibrary.ContainsSubPath
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// class FString                           Path                                                   (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class FString                           SubPath                                                (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UTestLibrary::ContainsSubPath(const class FString& Path, const class FString& SubPath)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("TestLibrary", "ContainsSubPath");

	Params::TestLibrary_ContainsSubPath Parms{};

	Parms.Path = std::move(Path);
	Parms.SubPath = std::move(SubPath);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function GbxTest.TestLibrary.CreateLocalCollection
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// class FString                           CollectionName                                         (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class FString                           ParentName                                             (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class FString                           ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class FString UTestLibrary::CreateLocalCollection(const class FString& CollectionName, const class FString& ParentName)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("TestLibrary", "CreateLocalCollection");

	Params::TestLibrary_CreateLocalCollection Parms{};

	Parms.CollectionName = std::move(CollectionName);
	Parms.ParentName = std::move(ParentName);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function GbxTest.TestLibrary.DiscoverAssets
// (Final, Native, Static, Public, HasOutParams, BlueprintCallable, BlueprintPure)
// Parameters:
// TArray<class FString>                   PathNames                                              (Parm, OutParm, ZeroConstructor, NativeAccessSpecifierPublic)
// TArray<class FString>                   PrettyNames                                            (Parm, OutParm, ZeroConstructor, NativeAccessSpecifierPublic)
// TArray<class FString>                   Directories                                            (Parm, ZeroConstructor, AdvancedDisplay, NativeAccessSpecifierPublic)
// TArray<class UClass*>                   Classes                                                (Parm, ZeroConstructor, AdvancedDisplay, NativeAccessSpecifierPublic)
// TArray<class UClass*>                   ExcludeRecursiveClasses                                (Parm, ZeroConstructor, AdvancedDisplay, NativeAccessSpecifierPublic)
// bool                                    bRecursiveDirectories                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, AdvancedDisplay, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    bRecursiveClasses                                      (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, AdvancedDisplay, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UTestLibrary::DiscoverAssets(TArray<class FString>* PathNames, TArray<class FString>* PrettyNames, const TArray<class FString>& Directories, const TArray<class UClass*>& Classes, const TArray<class UClass*>& ExcludeRecursiveClasses, bool bRecursiveDirectories, bool bRecursiveClasses)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("TestLibrary", "DiscoverAssets");

	Params::TestLibrary_DiscoverAssets Parms{};

	Parms.Directories = std::move(Directories);
	Parms.Classes = std::move(Classes);
	Parms.ExcludeRecursiveClasses = std::move(ExcludeRecursiveClasses);
	Parms.bRecursiveDirectories = bRecursiveDirectories;
	Parms.bRecursiveClasses = bRecursiveClasses;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	if (PathNames != nullptr)
		*PathNames = std::move(Parms.PathNames);

	if (PrettyNames != nullptr)
		*PrettyNames = std::move(Parms.PrettyNames);
}


// Function GbxTest.TestLibrary.FilterDiscoveredAssets
// (Final, Native, Static, Public, HasOutParams, BlueprintCallable, BlueprintPure)
// Parameters:
// TArray<class FString>                   InPathNames                                            (Parm, OutParm, ZeroConstructor, ReferenceParm, NativeAccessSpecifierPublic)
// TArray<class FString>                   InPrettyNames                                          (Parm, OutParm, ZeroConstructor, ReferenceParm, NativeAccessSpecifierPublic)
// TArray<class FString>                   OutPathNames                                           (Parm, OutParm, ZeroConstructor, NativeAccessSpecifierPublic)
// TArray<class FString>                   OutPrettyNames                                         (Parm, OutParm, ZeroConstructor, NativeAccessSpecifierPublic)
// class FString                           AssetNamePrefix                                        (Parm, ZeroConstructor, AdvancedDisplay, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class FString                           AssetNamePostfix                                       (Parm, ZeroConstructor, AdvancedDisplay, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class FString                           AssetNameContains                                      (Parm, ZeroConstructor, AdvancedDisplay, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class FString                           AssetPathContains                                      (Parm, ZeroConstructor, AdvancedDisplay, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UTestLibrary::FilterDiscoveredAssets(TArray<class FString>& InPathNames, TArray<class FString>& InPrettyNames, TArray<class FString>* OutPathNames, TArray<class FString>* OutPrettyNames, const class FString& AssetNamePrefix, const class FString& AssetNamePostfix, const class FString& AssetNameContains, const class FString& AssetPathContains)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("TestLibrary", "FilterDiscoveredAssets");

	Params::TestLibrary_FilterDiscoveredAssets Parms{};

	Parms.InPathNames = std::move(InPathNames);
	Parms.InPrettyNames = std::move(InPrettyNames);
	Parms.AssetNamePrefix = std::move(AssetNamePrefix);
	Parms.AssetNamePostfix = std::move(AssetNamePostfix);
	Parms.AssetNameContains = std::move(AssetNameContains);
	Parms.AssetPathContains = std::move(AssetPathContains);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	InPathNames = std::move(Parms.InPathNames);
	InPrettyNames = std::move(Parms.InPrettyNames);

	if (OutPathNames != nullptr)
		*OutPathNames = std::move(Parms.OutPathNames);

	if (OutPrettyNames != nullptr)
		*OutPrettyNames = std::move(Parms.OutPrettyNames);
}


// Function GbxTest.TestLibrary.GetAssetName
// (Final, Native, Static, Public, HasOutParams, BlueprintCallable, BlueprintPure)
// Parameters:
// class FString                           AssetPath                                              (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class FString                           AssetName                                              (Parm, OutParm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UTestLibrary::GetAssetName(const class FString& AssetPath, class FString* AssetName)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("TestLibrary", "GetAssetName");

	Params::TestLibrary_GetAssetName Parms{};

	Parms.AssetPath = std::move(AssetPath);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	if (AssetName != nullptr)
		*AssetName = std::move(Parms.AssetName);
}


// Function GbxTest.TestLibrary.GetAssetPath
// (Final, Native, Static, Public, HasOutParams, BlueprintCallable, BlueprintPure)
// Parameters:
// class UObject*                          Asset                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class FString                           AssetPath                                              (Parm, OutParm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UTestLibrary::GetAssetPath(class UObject* Asset, class FString* AssetPath)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("TestLibrary", "GetAssetPath");

	Params::TestLibrary_GetAssetPath Parms{};

	Parms.Asset = Asset;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	if (AssetPath != nullptr)
		*AssetPath = std::move(Parms.AssetPath);
}


// Function GbxTest.TestLibrary.GetObjectTags
// (Final, Native, Static, Public, HasOutParams, BlueprintCallable, BlueprintPure)
// Parameters:
// TArray<struct FObjectTag>               ObjectTags                                             (Parm, OutParm, ZeroConstructor, NativeAccessSpecifierPublic)
// class UObject*                          Asset                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UTestLibrary::GetObjectTags(TArray<struct FObjectTag>* ObjectTags, class UObject* Asset)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("TestLibrary", "GetObjectTags");

	Params::TestLibrary_GetObjectTags Parms{};

	Parms.Asset = Asset;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	if (ObjectTags != nullptr)
		*ObjectTags = std::move(Parms.ObjectTags);
}


// Function GbxTest.TestLibrary.GetReferencedBlueprintClasses
// (Final, Native, Static, Public, HasOutParams, BlueprintCallable)
// Parameters:
// class UObject*                          Object                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class UClass*                           Class_0                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// TArray<class UClass*>                   Classes                                                (Parm, OutParm, ZeroConstructor, NativeAccessSpecifierPublic)

void UTestLibrary::GetReferencedBlueprintClasses(class UObject* Object, class UClass* Class_0, TArray<class UClass*>* Classes)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("TestLibrary", "GetReferencedBlueprintClasses");

	Params::TestLibrary_GetReferencedBlueprintClasses Parms{};

	Parms.Object = Object;
	Parms.Class_0 = Class_0;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	if (Classes != nullptr)
		*Classes = std::move(Parms.Classes);
}


// Function GbxTest.TestLibrary.GetTestDriversFromStrings
// (Final, Native, Static, Public, HasOutParams, BlueprintCallable, BlueprintPure)
// Parameters:
// TArray<class FString>                   Strings                                                (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, NativeAccessSpecifierPublic)
// TArray<TSubclassOf<class AActor>>       TestDrivers                                            (Parm, OutParm, ZeroConstructor, UObjectWrapper, NativeAccessSpecifierPublic)
// class FString                           UndiscoveredItems                                      (Parm, OutParm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UTestLibrary::GetTestDriversFromStrings(const TArray<class FString>& Strings, TArray<TSubclassOf<class AActor>>* TestDrivers, class FString* UndiscoveredItems)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("TestLibrary", "GetTestDriversFromStrings");

	Params::TestLibrary_GetTestDriversFromStrings Parms{};

	Parms.Strings = std::move(Strings);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	if (TestDrivers != nullptr)
		*TestDrivers = std::move(Parms.TestDrivers);

	if (UndiscoveredItems != nullptr)
		*UndiscoveredItems = std::move(Parms.UndiscoveredItems);
}


// Function GbxTest.TestLibrary.GetWorldForActor
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// class AActor*                           Actor                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class UWorld*                           ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class UWorld* UTestLibrary::GetWorldForActor(class AActor* Actor)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("TestLibrary", "GetWorldForActor");

	Params::TestLibrary_GetWorldForActor Parms{};

	Parms.Actor = Actor;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function GbxTest.TestLibrary.IsAssetInCollection
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// class FString                           CollectionName                                         (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class FString                           ObjectName                                             (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UTestLibrary::IsAssetInCollection(const class FString& CollectionName, const class FString& ObjectName)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("TestLibrary", "IsAssetInCollection");

	Params::TestLibrary_IsAssetInCollection Parms{};

	Parms.CollectionName = std::move(CollectionName);
	Parms.ObjectName = std::move(ObjectName);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function GbxTest.TestLibrary.IsAssetInCollectionEx
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// class FString                           CollectionName                                         (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// ECollectionType                         CollectionType                                         (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class FString                           ObjectName                                             (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UTestLibrary::IsAssetInCollectionEx(const class FString& CollectionName, ECollectionType CollectionType, const class FString& ObjectName)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("TestLibrary", "IsAssetInCollectionEx");

	Params::TestLibrary_IsAssetInCollectionEx Parms{};

	Parms.CollectionName = std::move(CollectionName);
	Parms.CollectionType = CollectionType;
	Parms.ObjectName = std::move(ObjectName);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function GbxTest.TestLibrary.IsEditorSession
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UTestLibrary::IsEditorSession()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("TestLibrary", "IsEditorSession");

	Params::TestLibrary_IsEditorSession Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function GbxTest.TestLibrary.LoadAsset
// (Final, Native, Static, Public, HasOutParams, BlueprintCallable, BlueprintPure)
// Parameters:
// class FString                           Path                                                   (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class UObject*                          Object                                                 (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UTestLibrary::LoadAsset(const class FString& Path, class UObject** Object)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("TestLibrary", "LoadAsset");

	Params::TestLibrary_LoadAsset Parms{};

	Parms.Path = std::move(Path);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	if (Object != nullptr)
		*Object = Parms.Object;
}


// Function GbxTest.TestLibrary.LoadBlueprintAsset
// (Final, Native, Static, Public, HasOutParams, BlueprintCallable, BlueprintPure)
// Parameters:
// class FString                           Path                                                   (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class UObject*                          Object                                                 (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UTestLibrary::LoadBlueprintAsset(const class FString& Path, class UObject** Object)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("TestLibrary", "LoadBlueprintAsset");

	Params::TestLibrary_LoadBlueprintAsset Parms{};

	Parms.Path = std::move(Path);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	if (Object != nullptr)
		*Object = Parms.Object;
}


// Function GbxTest.TestLibrary.MoveArrayCollection
// (Final, Native, Static, Public, HasOutParams, BlueprintCallable)
// Parameters:
// class FString                           FromCollection                                         (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class FString                           ToCollection                                           (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// TArray<class FString>                   ObjectNames                                            (Parm, OutParm, ZeroConstructor, ReferenceParm, NativeAccessSpecifierPublic)

void UTestLibrary::MoveArrayCollection(const class FString& FromCollection, const class FString& ToCollection, TArray<class FString>& ObjectNames)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("TestLibrary", "MoveArrayCollection");

	Params::TestLibrary_MoveArrayCollection Parms{};

	Parms.FromCollection = std::move(FromCollection);
	Parms.ToCollection = std::move(ToCollection);
	Parms.ObjectNames = std::move(ObjectNames);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	ObjectNames = std::move(Parms.ObjectNames);
}


// Function GbxTest.TestLibrary.MoveItemCollection
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// class FString                           FromCollection                                         (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class FString                           ToCollection                                           (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class FString                           ObjectName                                             (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UTestLibrary::MoveItemCollection(const class FString& FromCollection, const class FString& ToCollection, const class FString& ObjectName)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("TestLibrary", "MoveItemCollection");

	Params::TestLibrary_MoveItemCollection Parms{};

	Parms.FromCollection = std::move(FromCollection);
	Parms.ToCollection = std::move(ToCollection);
	Parms.ObjectName = std::move(ObjectName);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function GbxTest.TestLibrary.ReadFromIni
// (Final, Native, Static, Public, HasOutParams, BlueprintCallable)
// Parameters:
// class FString                           Section                                                (ConstParm, Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class FString                           Key                                                    (ConstParm, Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// TArray<class FString>                   Values                                                 (Parm, OutParm, ZeroConstructor, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UTestLibrary::ReadFromIni(const class FString& Section, const class FString& Key, TArray<class FString>* Values)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("TestLibrary", "ReadFromIni");

	Params::TestLibrary_ReadFromIni Parms{};

	Parms.Section = std::move(Section);
	Parms.Key = std::move(Key);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	if (Values != nullptr)
		*Values = std::move(Parms.Values);

	return Parms.ReturnValue;
}


// Function GbxTest.TestLibrary.RemoveArrayFromCollection
// (Final, Native, Static, Public, HasOutParams, BlueprintCallable)
// Parameters:
// class FString                           CollectionName                                         (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// TArray<class FString>                   ObjectNames                                            (Parm, OutParm, ZeroConstructor, ReferenceParm, NativeAccessSpecifierPublic)

void UTestLibrary::RemoveArrayFromCollection(const class FString& CollectionName, TArray<class FString>& ObjectNames)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("TestLibrary", "RemoveArrayFromCollection");

	Params::TestLibrary_RemoveArrayFromCollection Parms{};

	Parms.CollectionName = std::move(CollectionName);
	Parms.ObjectNames = std::move(ObjectNames);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	ObjectNames = std::move(Parms.ObjectNames);
}


// Function GbxTest.TestLibrary.RemoveItemFromCollection
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// class FString                           CollectionName                                         (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class FString                           ObjectName                                             (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UTestLibrary::RemoveItemFromCollection(const class FString& CollectionName, const class FString& ObjectName)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("TestLibrary", "RemoveItemFromCollection");

	Params::TestLibrary_RemoveItemFromCollection Parms{};

	Parms.CollectionName = std::move(CollectionName);
	Parms.ObjectName = std::move(ObjectName);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function GbxTest.TestLibrary.SimulateInputAxis
// (Final, Native, Static, Public, HasOutParams, BlueprintCallable)
// Parameters:
// class APlayerController*                PlayerController                                       (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FKey                             Key                                                    (Parm, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   Delta                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   InterpTime                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FLatentActionInfo                LatentInfo                                             (Parm, NoDestructor, NativeAccessSpecifierPublic)

void UTestLibrary::SimulateInputAxis(const class APlayerController*& PlayerController, const struct FKey& Key, float Delta, float InterpTime, const struct FLatentActionInfo& LatentInfo)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("TestLibrary", "SimulateInputAxis");

	Params::TestLibrary_SimulateInputAxis Parms{};

	Parms.PlayerController = PlayerController;
	Parms.Key = std::move(Key);
	Parms.Delta = Delta;
	Parms.InterpTime = InterpTime;
	Parms.LatentInfo = std::move(LatentInfo);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function GbxTest.TestLibrary.SimulateInputKey
// (Final, Native, Static, Public, HasOutParams, BlueprintCallable)
// Parameters:
// class APlayerController*                PlayerController                                       (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FKey                             Key                                                    (Parm, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// EInputEvent                             EVENTTYPE                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   AmountDepressed                                        (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UTestLibrary::SimulateInputKey(const class APlayerController*& PlayerController, const struct FKey& Key, EInputEvent EVENTTYPE, float AmountDepressed)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("TestLibrary", "SimulateInputKey");

	Params::TestLibrary_SimulateInputKey Parms{};

	Parms.PlayerController = PlayerController;
	Parms.Key = std::move(Key);
	Parms.EVENTTYPE = EVENTTYPE;
	Parms.AmountDepressed = AmountDepressed;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function GbxTest.TestLibrary.SortFloats
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// TArray<float>                           Values                                                 (Parm, ZeroConstructor, NativeAccessSpecifierPublic)
// bool                                    Descending                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// TArray<float>                           ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, NativeAccessSpecifierPublic)

TArray<float> UTestLibrary::SortFloats(const TArray<float>& Values, bool Descending)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("TestLibrary", "SortFloats");

	Params::TestLibrary_SortFloats Parms{};

	Parms.Values = std::move(Values);
	Parms.Descending = Descending;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function GbxTest.TestLibrary.SortIntegers
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// TArray<int32>                           Values                                                 (Parm, ZeroConstructor, NativeAccessSpecifierPublic)
// bool                                    Descending                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// TArray<int32>                           ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, NativeAccessSpecifierPublic)

TArray<int32> UTestLibrary::SortIntegers(const TArray<int32>& Values, bool Descending)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("TestLibrary", "SortIntegers");

	Params::TestLibrary_SortIntegers Parms{};

	Parms.Values = std::move(Values);
	Parms.Descending = Descending;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function GbxTest.TestLibrary.SortObjectsByName
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// TArray<class UObject*>                  Values                                                 (Parm, ZeroConstructor, NativeAccessSpecifierPublic)
// bool                                    Descending                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// TArray<class UObject*>                  ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, NativeAccessSpecifierPublic)

TArray<class UObject*> UTestLibrary::SortObjectsByName(const TArray<class UObject*>& Values, bool Descending)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("TestLibrary", "SortObjectsByName");

	Params::TestLibrary_SortObjectsByName Parms{};

	Parms.Values = std::move(Values);
	Parms.Descending = Descending;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function GbxTest.TestLibrary.SortStrings
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// TArray<class FString>                   Values                                                 (Parm, ZeroConstructor, NativeAccessSpecifierPublic)
// bool                                    Descending                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// TArray<class FString>                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, NativeAccessSpecifierPublic)

TArray<class FString> UTestLibrary::SortStrings(const TArray<class FString>& Values, bool Descending)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("TestLibrary", "SortStrings");

	Params::TestLibrary_SortStrings Parms{};

	Parms.Values = std::move(Values);
	Parms.Descending = Descending;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function GbxTest.TestLibrary.TakeScreenshot
// (Final, Native, Static, Public, HasDefaults, BlueprintCallable)
// Parameters:
// class FString                           CustomFilename                                         (ConstParm, Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FVector2D                        OverrideResolution                                     (ConstParm, Parm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ShowUI                                                 (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    AddUniqueSuffix                                        (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UTestLibrary::TakeScreenshot(const class FString& CustomFilename, const struct FVector2D& OverrideResolution, const bool ShowUI, const bool AddUniqueSuffix)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("TestLibrary", "TakeScreenshot");

	Params::TestLibrary_TakeScreenshot Parms{};

	Parms.CustomFilename = std::move(CustomFilename);
	Parms.OverrideResolution = std::move(OverrideResolution);
	Parms.ShowUI = ShowUI;
	Parms.AddUniqueSuffix = AddUniqueSuffix;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function GbxTest.TestLibraryContent.ContentAuditSingleObject
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// class UObject*                          Asset                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// TArray<class FString>                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, NativeAccessSpecifierPublic)

TArray<class FString> UTestLibraryContent::ContentAuditSingleObject(class UObject* Asset)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("TestLibraryContent", "ContentAuditSingleObject");

	Params::TestLibraryContent_ContentAuditSingleObject Parms{};

	Parms.Asset = Asset;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function GbxTest.TestLibraryContent.GetAllPersistentGameMaps
// (Final, Native, Static, Public, HasOutParams, BlueprintCallable, BlueprintPure)
// Parameters:
// TArray<class FString>                   OutMapNames                                            (Parm, OutParm, ZeroConstructor, NativeAccessSpecifierPublic)
// bool                                    ShortNamesOnly                                         (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UTestLibraryContent::GetAllPersistentGameMaps(TArray<class FString>* OutMapNames, bool ShortNamesOnly)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("TestLibraryContent", "GetAllPersistentGameMaps");

	Params::TestLibraryContent_GetAllPersistentGameMaps Parms{};

	Parms.ShortNamesOnly = ShortNamesOnly;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	if (OutMapNames != nullptr)
		*OutMapNames = std::move(Parms.OutMapNames);
}


// Function GbxTest.TestLibraryContent.GetTestInfoMaterial
// (Final, Native, Static, Public, HasOutParams, BlueprintCallable, BlueprintPure)
// Parameters:
// class UMaterial*                        Asset                                                  (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FTestInfoMaterial                Info                                                   (Parm, OutParm, NativeAccessSpecifierPublic)

void UTestLibraryContent::GetTestInfoMaterial(const class UMaterial* Asset, struct FTestInfoMaterial* Info)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("TestLibraryContent", "GetTestInfoMaterial");

	Params::TestLibraryContent_GetTestInfoMaterial Parms{};

	Parms.Asset = Asset;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	if (Info != nullptr)
		*Info = std::move(Parms.Info);
}


// Function GbxTest.TestLibraryContent.GetTestInfoParticleEmitter
// (Final, Native, Static, Public, HasOutParams, BlueprintCallable, BlueprintPure)
// Parameters:
// class UParticleSystem*                  Asset                                                  (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   EmitterIndex                                           (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FTestInfoParticleEmitter         Info                                                   (Parm, OutParm, NoDestructor, NativeAccessSpecifierPublic)

void UTestLibraryContent::GetTestInfoParticleEmitter(const class UParticleSystem* Asset, const int32 EmitterIndex, struct FTestInfoParticleEmitter* Info)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("TestLibraryContent", "GetTestInfoParticleEmitter");

	Params::TestLibraryContent_GetTestInfoParticleEmitter Parms{};

	Parms.Asset = Asset;
	Parms.EmitterIndex = EmitterIndex;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	if (Info != nullptr)
		*Info = std::move(Parms.Info);
}


// Function GbxTest.TestLibraryContent.GetTestInfoParticleSystem
// (Final, Native, Static, Public, HasOutParams, BlueprintCallable, BlueprintPure)
// Parameters:
// class UParticleSystem*                  Asset                                                  (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FTestInfoParticleSystem          Info                                                   (Parm, OutParm, NativeAccessSpecifierPublic)

void UTestLibraryContent::GetTestInfoParticleSystem(const class UParticleSystem* Asset, struct FTestInfoParticleSystem* Info)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("TestLibraryContent", "GetTestInfoParticleSystem");

	Params::TestLibraryContent_GetTestInfoParticleSystem Parms{};

	Parms.Asset = Asset;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	if (Info != nullptr)
		*Info = std::move(Parms.Info);
}


// Function GbxTest.TestLibraryContent.GetTestInfoSkeletalMesh
// (Final, Native, Static, Public, HasOutParams, BlueprintCallable, BlueprintPure)
// Parameters:
// class USkeletalMesh*                    Asset                                                  (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FTestInfoMeshLODSummary          LODSummary                                             (Parm, OutParm, NoDestructor, NativeAccessSpecifierPublic)
// struct FTestInfoMesh                    Mesh                                                   (Parm, OutParm, NoDestructor, NativeAccessSpecifierPublic)
// struct FTestInfoSkeletalMesh            SkeletalMesh                                           (Parm, OutParm, NativeAccessSpecifierPublic)

void UTestLibraryContent::GetTestInfoSkeletalMesh(const class USkeletalMesh* Asset, struct FTestInfoMeshLODSummary* LODSummary, struct FTestInfoMesh* Mesh, struct FTestInfoSkeletalMesh* SkeletalMesh)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("TestLibraryContent", "GetTestInfoSkeletalMesh");

	Params::TestLibraryContent_GetTestInfoSkeletalMesh Parms{};

	Parms.Asset = Asset;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	if (LODSummary != nullptr)
		*LODSummary = std::move(Parms.LODSummary);

	if (Mesh != nullptr)
		*Mesh = std::move(Parms.Mesh);

	if (SkeletalMesh != nullptr)
		*SkeletalMesh = std::move(Parms.SkeletalMesh);
}


// Function GbxTest.TestLibraryContent.GetTestInfoSkeletalMeshLOD
// (Final, Native, Static, Public, HasOutParams, BlueprintCallable, BlueprintPure)
// Parameters:
// class USkeletalMesh*                    Asset                                                  (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   LODIndex                                               (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FTestInfoMeshLOD                 Info                                                   (Parm, OutParm, NoDestructor, NativeAccessSpecifierPublic)

void UTestLibraryContent::GetTestInfoSkeletalMeshLOD(const class USkeletalMesh* Asset, const int32 LODIndex, struct FTestInfoMeshLOD* Info)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("TestLibraryContent", "GetTestInfoSkeletalMeshLOD");

	Params::TestLibraryContent_GetTestInfoSkeletalMeshLOD Parms{};

	Parms.Asset = Asset;
	Parms.LODIndex = LODIndex;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	if (Info != nullptr)
		*Info = std::move(Parms.Info);
}


// Function GbxTest.TestLibraryContent.GetTestInfoStaticMesh
// (Final, Native, Static, Public, HasOutParams, BlueprintCallable, BlueprintPure)
// Parameters:
// class UStaticMesh*                      Asset                                                  (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FTestInfoMeshLODSummary          LODSummary                                             (Parm, OutParm, NoDestructor, NativeAccessSpecifierPublic)
// struct FTestInfoMesh                    Mesh                                                   (Parm, OutParm, NoDestructor, NativeAccessSpecifierPublic)
// struct FTestInfoStaticMesh              StaticMesh                                             (Parm, OutParm, NativeAccessSpecifierPublic)

void UTestLibraryContent::GetTestInfoStaticMesh(const class UStaticMesh* Asset, struct FTestInfoMeshLODSummary* LODSummary, struct FTestInfoMesh* Mesh, struct FTestInfoStaticMesh* StaticMesh)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("TestLibraryContent", "GetTestInfoStaticMesh");

	Params::TestLibraryContent_GetTestInfoStaticMesh Parms{};

	Parms.Asset = Asset;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	if (LODSummary != nullptr)
		*LODSummary = std::move(Parms.LODSummary);

	if (Mesh != nullptr)
		*Mesh = std::move(Parms.Mesh);

	if (StaticMesh != nullptr)
		*StaticMesh = std::move(Parms.StaticMesh);
}


// Function GbxTest.TestLibraryContent.GetTestInfoStaticMeshLOD
// (Final, Native, Static, Public, HasOutParams, BlueprintCallable, BlueprintPure)
// Parameters:
// class UStaticMesh*                      Asset                                                  (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   LODIndex                                               (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FTestInfoMeshLOD                 Info                                                   (Parm, OutParm, NoDestructor, NativeAccessSpecifierPublic)

void UTestLibraryContent::GetTestInfoStaticMeshLOD(const class UStaticMesh* Asset, const int32 LODIndex, struct FTestInfoMeshLOD* Info)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("TestLibraryContent", "GetTestInfoStaticMeshLOD");

	Params::TestLibraryContent_GetTestInfoStaticMeshLOD Parms{};

	Parms.Asset = Asset;
	Parms.LODIndex = LODIndex;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	if (Info != nullptr)
		*Info = std::move(Parms.Info);
}


// Function GbxTest.TestLibraryContent.GetTestInfoTexture
// (Final, Native, Static, Public, HasOutParams, BlueprintCallable, BlueprintPure)
// Parameters:
// class UTexture*                         Asset                                                  (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FTestInfoTexture                 Info                                                   (Parm, OutParm, NativeAccessSpecifierPublic)

void UTestLibraryContent::GetTestInfoTexture(const class UTexture* Asset, struct FTestInfoTexture* Info)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("TestLibraryContent", "GetTestInfoTexture");

	Params::TestLibraryContent_GetTestInfoTexture Parms{};

	Parms.Asset = Asset;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	if (Info != nullptr)
		*Info = std::move(Parms.Info);
}


// Function GbxTest.TestLibraryContent.LoadAssetMaterial
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// class FString                           ObjectPath                                             (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class UMaterial*                        ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class UMaterial* UTestLibraryContent::LoadAssetMaterial(const class FString& ObjectPath)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("TestLibraryContent", "LoadAssetMaterial");

	Params::TestLibraryContent_LoadAssetMaterial Parms{};

	Parms.ObjectPath = std::move(ObjectPath);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function GbxTest.TestLibraryContent.LoadAssetParticleSystem
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// class FString                           ObjectPath                                             (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class UParticleSystem*                  ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class UParticleSystem* UTestLibraryContent::LoadAssetParticleSystem(const class FString& ObjectPath)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("TestLibraryContent", "LoadAssetParticleSystem");

	Params::TestLibraryContent_LoadAssetParticleSystem Parms{};

	Parms.ObjectPath = std::move(ObjectPath);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function GbxTest.TestLibraryContent.LoadAssetSkeletalMesh
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// class FString                           ObjectPath                                             (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class USkeletalMesh*                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class USkeletalMesh* UTestLibraryContent::LoadAssetSkeletalMesh(const class FString& ObjectPath)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("TestLibraryContent", "LoadAssetSkeletalMesh");

	Params::TestLibraryContent_LoadAssetSkeletalMesh Parms{};

	Parms.ObjectPath = std::move(ObjectPath);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function GbxTest.TestLibraryContent.LoadAssetStaticMesh
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// class FString                           ObjectPath                                             (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class UStaticMesh*                      ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class UStaticMesh* UTestLibraryContent::LoadAssetStaticMesh(const class FString& ObjectPath)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("TestLibraryContent", "LoadAssetStaticMesh");

	Params::TestLibraryContent_LoadAssetStaticMesh Parms{};

	Parms.ObjectPath = std::move(ObjectPath);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function GbxTest.TestLibraryContent.LoadAssetTexture
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// class FString                           ObjectPath                                             (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class UTexture*                         ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class UTexture* UTestLibraryContent::LoadAssetTexture(const class FString& ObjectPath)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("TestLibraryContent", "LoadAssetTexture");

	Params::TestLibraryContent_LoadAssetTexture Parms{};

	Parms.ObjectPath = std::move(ObjectPath);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function GbxTest.TestLibraryPerformance.GenerateLevelGrid
// (Final, Native, Static, Public, HasOutParams, BlueprintCallable)
// Parameters:
// TArray<struct FVector>                  GridLocations                                          (Parm, OutParm, ZeroConstructor, NativeAccessSpecifierPublic)
// class APawn*                            Pawn                                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   GridSize                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    bWalkableOnly                                          (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UTestLibraryPerformance::GenerateLevelGrid(TArray<struct FVector>* GridLocations, class APawn* Pawn, float GridSize, bool bWalkableOnly)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("TestLibraryPerformance", "GenerateLevelGrid");

	Params::TestLibraryPerformance_GenerateLevelGrid Parms{};

	Parms.Pawn = Pawn;
	Parms.GridSize = GridSize;
	Parms.bWalkableOnly = bWalkableOnly;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	if (GridLocations != nullptr)
		*GridLocations = std::move(Parms.GridLocations);
}


// Function GbxTest.TestLibraryPerformance.WaitForFrames
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// class UObject*                          WorldContextObject                                     (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   NumFrames                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FLatentActionInfo                LatentInfo                                             (Parm, NoDestructor, NativeAccessSpecifierPublic)

void UTestLibraryPerformance::WaitForFrames(class UObject* WorldContextObject, int32 NumFrames, const struct FLatentActionInfo& LatentInfo)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("TestLibraryPerformance", "WaitForFrames");

	Params::TestLibraryPerformance_WaitForFrames Parms{};

	Parms.WorldContextObject = WorldContextObject;
	Parms.NumFrames = NumFrames;
	Parms.LatentInfo = std::move(LatentInfo);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function GbxTest.TestLibrarySimulation.CanReceiveBackgroundInput
// (Final, Native, Static, Public, HasOutParams, BlueprintCallable)
// Parameters:
// class APlayerController*                PlayerController                                       (Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UTestLibrarySimulation::CanReceiveBackgroundInput(class APlayerController*& PlayerController)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("TestLibrarySimulation", "CanReceiveBackgroundInput");

	Params::TestLibrarySimulation_CanReceiveBackgroundInput Parms{};

	Parms.PlayerController = PlayerController;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	PlayerController = Parms.PlayerController;

	return Parms.ReturnValue;
}


// Function GbxTest.TestLibrarySimulation.GetPolicyForPlayMap
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// class UTestPolicySimulation*            ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class UTestPolicySimulation* UTestLibrarySimulation::GetPolicyForPlayMap()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("TestLibrarySimulation", "GetPolicyForPlayMap");

	Params::TestLibrarySimulation_GetPolicyForPlayMap Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function GbxTest.TestLibrarySimulation.IsDemiGodEnabled
// (Final, Native, Static, Public, HasOutParams, BlueprintCallable)
// Parameters:
// class APlayerController*                PlayerController                                       (Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UTestLibrarySimulation::IsDemiGodEnabled(class APlayerController*& PlayerController)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("TestLibrarySimulation", "IsDemiGodEnabled");

	Params::TestLibrarySimulation_IsDemiGodEnabled Parms{};

	Parms.PlayerController = PlayerController;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	PlayerController = Parms.PlayerController;

	return Parms.ReturnValue;
}


// Function GbxTest.TestLibrarySimulation.IsGhostEnabled
// (Final, Native, Static, Public, HasOutParams, BlueprintCallable)
// Parameters:
// class APlayerController*                PlayerController                                       (Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UTestLibrarySimulation::IsGhostEnabled(class APlayerController*& PlayerController)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("TestLibrarySimulation", "IsGhostEnabled");

	Params::TestLibrarySimulation_IsGhostEnabled Parms{};

	Parms.PlayerController = PlayerController;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	PlayerController = Parms.PlayerController;

	return Parms.ReturnValue;
}


// Function GbxTest.TestLibrarySimulation.IsGodEnabled
// (Final, Native, Static, Public, HasOutParams, BlueprintCallable)
// Parameters:
// class APlayerController*                PlayerController                                       (Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UTestLibrarySimulation::IsGodEnabled(class APlayerController*& PlayerController)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("TestLibrarySimulation", "IsGodEnabled");

	Params::TestLibrarySimulation_IsGodEnabled Parms{};

	Parms.PlayerController = PlayerController;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	PlayerController = Parms.PlayerController;

	return Parms.ReturnValue;
}


// Function GbxTest.TestLibrarySimulation.IsHLQNoClipEnabled
// (Final, Native, Static, Public, HasOutParams, BlueprintCallable)
// Parameters:
// class APlayerController*                PlayerController                                       (Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UTestLibrarySimulation::IsHLQNoClipEnabled(class APlayerController*& PlayerController)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("TestLibrarySimulation", "IsHLQNoClipEnabled");

	Params::TestLibrarySimulation_IsHLQNoClipEnabled Parms{};

	Parms.PlayerController = PlayerController;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	PlayerController = Parms.PlayerController;

	return Parms.ReturnValue;
}


// Function GbxTest.TestLibrarySimulation.IsPlayMapRunning
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UTestLibrarySimulation::IsPlayMapRunning()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("TestLibrarySimulation", "IsPlayMapRunning");

	Params::TestLibrarySimulation_IsPlayMapRunning Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function GbxTest.TestLibrarySimulation.PopAssetContext
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// struct FGbxProbeId                      ID                                                     (Parm, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UTestLibrarySimulation::PopAssetContext(const struct FGbxProbeId& ID)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("TestLibrarySimulation", "PopAssetContext");

	Params::TestLibrarySimulation_PopAssetContext Parms{};

	Parms.ID = std::move(ID);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function GbxTest.TestLibrarySimulation.PopWorldContext
// (Final, Native, Static, Public, BlueprintCallable)

void UTestLibrarySimulation::PopWorldContext()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("TestLibrarySimulation", "PopWorldContext");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function GbxTest.TestLibrarySimulation.PushAssetContext
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// struct FGbxProbeId                      ID                                                     (Parm, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UTestLibrarySimulation::PushAssetContext(const struct FGbxProbeId& ID)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("TestLibrarySimulation", "PushAssetContext");

	Params::TestLibrarySimulation_PushAssetContext Parms{};

	Parms.ID = std::move(ID);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function GbxTest.TestLibrarySimulation.PushWorldContext
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// class UObject*                          WorldContextObject                                     (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UTestLibrarySimulation::PushWorldContext(class UObject* WorldContextObject)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("TestLibrarySimulation", "PushWorldContext");

	Params::TestLibrarySimulation_PushWorldContext Parms{};

	Parms.WorldContextObject = WorldContextObject;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function GbxTest.TestLibrarySimulation.ReportIssueFromPlayMap
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// ETestIssueType                          IssueType                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class FString                           IssueCategory                                          (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class FString                           IssueMessage                                           (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UTestLibrarySimulation::ReportIssueFromPlayMap(ETestIssueType IssueType, const class FString& IssueCategory, const class FString& IssueMessage)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("TestLibrarySimulation", "ReportIssueFromPlayMap");

	Params::TestLibrarySimulation_ReportIssueFromPlayMap Parms{};

	Parms.IssueType = IssueType;
	Parms.IssueCategory = std::move(IssueCategory);
	Parms.IssueMessage = std::move(IssueMessage);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function GbxTest.TestLibrarySimulation.ReportResultFromPlayMap
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// bool                                    bSucceeded                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class FString                           IssueCategory                                          (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class FString                           IssueMessage                                           (Parm, ZeroConstructor, AdvancedDisplay, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FGbxProbeId                      AssetContext                                           (Parm, AdvancedDisplay, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// ETestIssueType                          FailedIssueType                                        (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, AdvancedDisplay, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UTestLibrarySimulation::ReportResultFromPlayMap(bool bSucceeded, const class FString& IssueCategory, const class FString& IssueMessage, const struct FGbxProbeId& AssetContext, ETestIssueType FailedIssueType)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("TestLibrarySimulation", "ReportResultFromPlayMap");

	Params::TestLibrarySimulation_ReportResultFromPlayMap Parms{};

	Parms.bSucceeded = bSucceeded;
	Parms.IssueCategory = std::move(IssueCategory);
	Parms.IssueMessage = std::move(IssueMessage);
	Parms.AssetContext = std::move(AssetContext);
	Parms.FailedIssueType = FailedIssueType;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function GbxTest.TestLibrarySimulation.ResetTestTimeout
// (Final, Native, Static, Public, BlueprintCallable)

void UTestLibrarySimulation::ResetTestTimeout()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("TestLibrarySimulation", "ResetTestTimeout");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function GbxTest.TestLibrarySimulation.SetReceiveBackgroundInput
// (Final, Native, Static, Public, HasOutParams, BlueprintCallable)
// Parameters:
// class APlayerController*                PlayerController                                       (Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    AllowBackgroundInput                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UTestLibrarySimulation::SetReceiveBackgroundInput(class APlayerController*& PlayerController, bool AllowBackgroundInput)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("TestLibrarySimulation", "SetReceiveBackgroundInput");

	Params::TestLibrarySimulation_SetReceiveBackgroundInput Parms{};

	Parms.PlayerController = PlayerController;
	Parms.AllowBackgroundInput = AllowBackgroundInput;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	PlayerController = Parms.PlayerController;

	return Parms.ReturnValue;
}


// Function GbxTest.TestLibrarySimulation.SetReportContext
// (Final, Native, Static, Public, HasOutParams, BlueprintCallable)
// Parameters:
// class UObject*                          WorldContextObject                                     (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// TArray<struct FGbxProbeId>              AssetContexts                                          (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, NativeAccessSpecifierPublic)

void UTestLibrarySimulation::SetReportContext(class UObject* WorldContextObject, const TArray<struct FGbxProbeId>& AssetContexts)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("TestLibrarySimulation", "SetReportContext");

	Params::TestLibrarySimulation_SetReportContext Parms{};

	Parms.WorldContextObject = WorldContextObject;
	Parms.AssetContexts = std::move(AssetContexts);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function GbxTest.TestLibrarySimulation.SimulatePlayerInput
// (Final, Native, Static, Public, HasOutParams, BlueprintCallable)
// Parameters:
// class UObject*                          WorldContextObject                                     (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class APlayerController*                PlayerController                                       (Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// TArray<struct FGbxTestInputAction>      InputDescription                                       (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, NativeAccessSpecifierPublic)
// float                                   PreDelay                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, AdvancedDisplay, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   PostDelay                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, AdvancedDisplay, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FLatentActionInfo                LatentInfo                                             (Parm, NoDestructor, NativeAccessSpecifierPublic)

void UTestLibrarySimulation::SimulatePlayerInput(class UObject* WorldContextObject, class APlayerController*& PlayerController, const TArray<struct FGbxTestInputAction>& InputDescription, float PreDelay, float PostDelay, const struct FLatentActionInfo& LatentInfo)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("TestLibrarySimulation", "SimulatePlayerInput");

	Params::TestLibrarySimulation_SimulatePlayerInput Parms{};

	Parms.WorldContextObject = WorldContextObject;
	Parms.PlayerController = PlayerController;
	Parms.InputDescription = std::move(InputDescription);
	Parms.PreDelay = PreDelay;
	Parms.PostDelay = PostDelay;
	Parms.LatentInfo = std::move(LatentInfo);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	PlayerController = Parms.PlayerController;
}


// Function GbxTest.TestLibrarySimulation.StopPlayTest
// (Final, Native, Static, Public, BlueprintCallable)

void UTestLibrarySimulation::StopPlayTest()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("TestLibrarySimulation", "StopPlayTest");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function GbxTest.TestLibrarySimulation.TestBoolIsFalseFromPlayMap
// (Final, Native, Static, Public, HasOutParams, BlueprintCallable)
// Parameters:
// bool                                    Value                                                  (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// ETestIssueType                          IssueType                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, AdvancedDisplay, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class FString                           IssueCategory                                          (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class FString                           IssueMessage                                           (Parm, ZeroConstructor, AdvancedDisplay, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UTestLibrarySimulation::TestBoolIsFalseFromPlayMap(const bool& Value, ETestIssueType IssueType, const class FString& IssueCategory, const class FString& IssueMessage)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("TestLibrarySimulation", "TestBoolIsFalseFromPlayMap");

	Params::TestLibrarySimulation_TestBoolIsFalseFromPlayMap Parms{};

	Parms.Value = Value;
	Parms.IssueType = IssueType;
	Parms.IssueCategory = std::move(IssueCategory);
	Parms.IssueMessage = std::move(IssueMessage);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function GbxTest.TestLibrarySimulation.TestBoolIsTrueFromPlayMap
// (Final, Native, Static, Public, HasOutParams, BlueprintCallable)
// Parameters:
// bool                                    Value                                                  (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// ETestIssueType                          IssueType                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, AdvancedDisplay, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class FString                           IssueCategory                                          (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class FString                           IssueMessage                                           (Parm, ZeroConstructor, AdvancedDisplay, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UTestLibrarySimulation::TestBoolIsTrueFromPlayMap(const bool& Value, ETestIssueType IssueType, const class FString& IssueCategory, const class FString& IssueMessage)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("TestLibrarySimulation", "TestBoolIsTrueFromPlayMap");

	Params::TestLibrarySimulation_TestBoolIsTrueFromPlayMap Parms{};

	Parms.Value = Value;
	Parms.IssueType = IssueType;
	Parms.IssueCategory = std::move(IssueCategory);
	Parms.IssueMessage = std::move(IssueMessage);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function GbxTest.TestLibrarySimulation.TestFloatCompareFromPlayMap
// (Final, Native, Static, Public, HasOutParams, BlueprintCallable)
// Parameters:
// float                                   Value                                                  (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   Other                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// ECompare                                Comparison                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, AdvancedDisplay, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// ETestIssueType                          IssueType                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, AdvancedDisplay, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class FString                           IssueCategory                                          (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class FString                           IssueMessage                                           (Parm, ZeroConstructor, AdvancedDisplay, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   Tolerance                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, AdvancedDisplay, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UTestLibrarySimulation::TestFloatCompareFromPlayMap(const float& Value, float Other, ECompare Comparison, ETestIssueType IssueType, const class FString& IssueCategory, const class FString& IssueMessage, float Tolerance)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("TestLibrarySimulation", "TestFloatCompareFromPlayMap");

	Params::TestLibrarySimulation_TestFloatCompareFromPlayMap Parms{};

	Parms.Value = Value;
	Parms.Other = Other;
	Parms.Comparison = Comparison;
	Parms.IssueType = IssueType;
	Parms.IssueCategory = std::move(IssueCategory);
	Parms.IssueMessage = std::move(IssueMessage);
	Parms.Tolerance = Tolerance;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function GbxTest.TestLibrarySimulation.TestFloatInRangeFromPlayMap
// (Final, Native, Static, Public, HasOutParams, BlueprintCallable)
// Parameters:
// float                                   Value                                                  (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   Min                                                    (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   Max                                                    (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// ETestIssueType                          IssueType                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, AdvancedDisplay, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class FString                           IssueCategory                                          (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class FString                           IssueMessage                                           (Parm, ZeroConstructor, AdvancedDisplay, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UTestLibrarySimulation::TestFloatInRangeFromPlayMap(const float& Value, float Min, float Max, ETestIssueType IssueType, const class FString& IssueCategory, const class FString& IssueMessage)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("TestLibrarySimulation", "TestFloatInRangeFromPlayMap");

	Params::TestLibrarySimulation_TestFloatInRangeFromPlayMap Parms{};

	Parms.Value = Value;
	Parms.Min = Min;
	Parms.Max = Max;
	Parms.IssueType = IssueType;
	Parms.IssueCategory = std::move(IssueCategory);
	Parms.IssueMessage = std::move(IssueMessage);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function GbxTest.TestLibrarySimulation.TestIntCompareFromPlayMap
// (Final, Native, Static, Public, HasOutParams, BlueprintCallable)
// Parameters:
// int32                                   Value                                                  (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   Other                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// ECompare                                Comparison                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, AdvancedDisplay, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// ETestIssueType                          IssueType                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, AdvancedDisplay, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class FString                           IssueCategory                                          (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class FString                           IssueMessage                                           (Parm, ZeroConstructor, AdvancedDisplay, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UTestLibrarySimulation::TestIntCompareFromPlayMap(const int32& Value, int32 Other, ECompare Comparison, ETestIssueType IssueType, const class FString& IssueCategory, const class FString& IssueMessage)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("TestLibrarySimulation", "TestIntCompareFromPlayMap");

	Params::TestLibrarySimulation_TestIntCompareFromPlayMap Parms{};

	Parms.Value = Value;
	Parms.Other = Other;
	Parms.Comparison = Comparison;
	Parms.IssueType = IssueType;
	Parms.IssueCategory = std::move(IssueCategory);
	Parms.IssueMessage = std::move(IssueMessage);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function GbxTest.TestLibrarySimulation.TestIntInRangeFromPlayMap
// (Final, Native, Static, Public, HasOutParams, BlueprintCallable)
// Parameters:
// int32                                   Value                                                  (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   Min                                                    (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   Max                                                    (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// ETestIssueType                          IssueType                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, AdvancedDisplay, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class FString                           IssueCategory                                          (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class FString                           IssueMessage                                           (Parm, ZeroConstructor, AdvancedDisplay, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UTestLibrarySimulation::TestIntInRangeFromPlayMap(const int32& Value, int32 Min, int32 Max, ETestIssueType IssueType, const class FString& IssueCategory, const class FString& IssueMessage)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("TestLibrarySimulation", "TestIntInRangeFromPlayMap");

	Params::TestLibrarySimulation_TestIntInRangeFromPlayMap Parms{};

	Parms.Value = Value;
	Parms.Min = Min;
	Parms.Max = Max;
	Parms.IssueType = IssueType;
	Parms.IssueCategory = std::move(IssueCategory);
	Parms.IssueMessage = std::move(IssueMessage);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function GbxTest.TestPolicy.ClearSavedTestCommand
// (Final, Native, Public, BlueprintCallable)

void UTestPolicy::ClearSavedTestCommand()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("TestPolicy", "ClearSavedTestCommand");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function GbxTest.TestPolicy.OnRunTestCommand
// (Native, Event, Protected, BlueprintEvent)
// Parameters:
// class FString                           TestCommand                                            (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UTestPolicy::OnRunTestCommand(const class FString& TestCommand)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("TestPolicy", "OnRunTestCommand");

	Params::TestPolicy_OnRunTestCommand Parms{};

	Parms.TestCommand = std::move(TestCommand);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function GbxTest.TestPolicy.PopAssetContext
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// struct FGbxProbeId                      ID                                                     (Parm, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UTestPolicy::PopAssetContext(const struct FGbxProbeId& ID)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("TestPolicy", "PopAssetContext");

	Params::TestPolicy_PopAssetContext Parms{};

	Parms.ID = std::move(ID);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function GbxTest.TestPolicy.PushAssetContext
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// struct FGbxProbeId                      ID                                                     (Parm, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UTestPolicy::PushAssetContext(const struct FGbxProbeId& ID)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("TestPolicy", "PushAssetContext");

	Params::TestPolicy_PushAssetContext Parms{};

	Parms.ID = std::move(ID);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function GbxTest.TestPolicy.ReportIssue
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// ETestIssueType                          IssueType                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class FString                           IssueCategory                                          (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class FString                           IssueMessage                                           (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UTestPolicy::ReportIssue(ETestIssueType IssueType, const class FString& IssueCategory, const class FString& IssueMessage)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("TestPolicy", "ReportIssue");

	Params::TestPolicy_ReportIssue Parms{};

	Parms.IssueType = IssueType;
	Parms.IssueCategory = std::move(IssueCategory);
	Parms.IssueMessage = std::move(IssueMessage);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function GbxTest.TestPolicy.ReportResult
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// bool                                    bSucceeded                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class FString                           IssueCategory                                          (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class FString                           IssueMessage                                           (Parm, ZeroConstructor, AdvancedDisplay, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FGbxProbeId                      AssetContext                                           (Parm, AdvancedDisplay, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// ETestIssueType                          FailedIssueType                                        (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, AdvancedDisplay, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UTestPolicy::ReportResult(bool bSucceeded, const class FString& IssueCategory, const class FString& IssueMessage, const struct FGbxProbeId& AssetContext, ETestIssueType FailedIssueType)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("TestPolicy", "ReportResult");

	Params::TestPolicy_ReportResult Parms{};

	Parms.bSucceeded = bSucceeded;
	Parms.IssueCategory = std::move(IssueCategory);
	Parms.IssueMessage = std::move(IssueMessage);
	Parms.AssetContext = std::move(AssetContext);
	Parms.FailedIssueType = FailedIssueType;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function GbxTest.TestPolicy.SetReportContext
// (Final, Native, Public, HasOutParams, BlueprintCallable)
// Parameters:
// class UObject*                          WorldContextObject                                     (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// TArray<struct FGbxProbeId>              AssetContexts                                          (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, NativeAccessSpecifierPublic)

void UTestPolicy::SetReportContext(class UObject* WorldContextObject, const TArray<struct FGbxProbeId>& AssetContexts)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("TestPolicy", "SetReportContext");

	Params::TestPolicy_SetReportContext Parms{};

	Parms.WorldContextObject = WorldContextObject;
	Parms.AssetContexts = std::move(AssetContexts);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function GbxTest.TestPolicy.TestAssetAudit
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// class UObject*                          Asset                                                  (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UTestPolicy::TestAssetAudit(const class UObject* Asset)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("TestPolicy", "TestAssetAudit");

	Params::TestPolicy_TestAssetAudit Parms{};

	Parms.Asset = Asset;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function GbxTest.TestPolicy.TestAssetTraits
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// class UObject*                          Asset                                                  (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UTestPolicy::TestAssetTraits(const class UObject* Asset)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("TestPolicy", "TestAssetTraits");

	Params::TestPolicy_TestAssetTraits Parms{};

	Parms.Asset = Asset;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function GbxTest.TestPolicy.TestBoolIsFalse
// (Final, Native, Public, HasOutParams, BlueprintCallable)
// Parameters:
// bool                                    Value                                                  (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// ETestIssueType                          IssueType                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, AdvancedDisplay, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class FString                           IssueCategory                                          (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class FString                           IssueMessage                                           (Parm, ZeroConstructor, AdvancedDisplay, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UTestPolicy::TestBoolIsFalse(const bool& Value, ETestIssueType IssueType, const class FString& IssueCategory, const class FString& IssueMessage)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("TestPolicy", "TestBoolIsFalse");

	Params::TestPolicy_TestBoolIsFalse Parms{};

	Parms.Value = Value;
	Parms.IssueType = IssueType;
	Parms.IssueCategory = std::move(IssueCategory);
	Parms.IssueMessage = std::move(IssueMessage);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function GbxTest.TestPolicy.TestBoolIsTrue
// (Final, Native, Public, HasOutParams, BlueprintCallable)
// Parameters:
// bool                                    Value                                                  (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// ETestIssueType                          IssueType                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, AdvancedDisplay, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class FString                           IssueCategory                                          (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class FString                           IssueMessage                                           (Parm, ZeroConstructor, AdvancedDisplay, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UTestPolicy::TestBoolIsTrue(const bool& Value, ETestIssueType IssueType, const class FString& IssueCategory, const class FString& IssueMessage)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("TestPolicy", "TestBoolIsTrue");

	Params::TestPolicy_TestBoolIsTrue Parms{};

	Parms.Value = Value;
	Parms.IssueType = IssueType;
	Parms.IssueCategory = std::move(IssueCategory);
	Parms.IssueMessage = std::move(IssueMessage);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function GbxTest.TestPolicy.TestFloatCompare
// (Final, Native, Public, HasOutParams, BlueprintCallable)
// Parameters:
// float                                   Value                                                  (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   Other                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// ECompare                                Comparison                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, AdvancedDisplay, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// ETestIssueType                          IssueType                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, AdvancedDisplay, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class FString                           IssueCategory                                          (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class FString                           IssueMessage                                           (Parm, ZeroConstructor, AdvancedDisplay, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   Tolerance                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, AdvancedDisplay, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UTestPolicy::TestFloatCompare(const float& Value, float Other, ECompare Comparison, ETestIssueType IssueType, const class FString& IssueCategory, const class FString& IssueMessage, float Tolerance)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("TestPolicy", "TestFloatCompare");

	Params::TestPolicy_TestFloatCompare Parms{};

	Parms.Value = Value;
	Parms.Other = Other;
	Parms.Comparison = Comparison;
	Parms.IssueType = IssueType;
	Parms.IssueCategory = std::move(IssueCategory);
	Parms.IssueMessage = std::move(IssueMessage);
	Parms.Tolerance = Tolerance;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function GbxTest.TestPolicy.TestFloatInRange
// (Final, Native, Public, HasOutParams, BlueprintCallable)
// Parameters:
// float                                   Value                                                  (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   Min                                                    (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   Max                                                    (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// ETestIssueType                          IssueType                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, AdvancedDisplay, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class FString                           IssueCategory                                          (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class FString                           IssueMessage                                           (Parm, ZeroConstructor, AdvancedDisplay, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UTestPolicy::TestFloatInRange(const float& Value, float Min, float Max, ETestIssueType IssueType, const class FString& IssueCategory, const class FString& IssueMessage)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("TestPolicy", "TestFloatInRange");

	Params::TestPolicy_TestFloatInRange Parms{};

	Parms.Value = Value;
	Parms.Min = Min;
	Parms.Max = Max;
	Parms.IssueType = IssueType;
	Parms.IssueCategory = std::move(IssueCategory);
	Parms.IssueMessage = std::move(IssueMessage);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function GbxTest.TestPolicy.TestIntCompare
// (Final, Native, Public, HasOutParams, BlueprintCallable)
// Parameters:
// int32                                   Value                                                  (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   Other                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// ECompare                                Comparison                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, AdvancedDisplay, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// ETestIssueType                          IssueType                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, AdvancedDisplay, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class FString                           IssueCategory                                          (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class FString                           IssueMessage                                           (Parm, ZeroConstructor, AdvancedDisplay, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UTestPolicy::TestIntCompare(const int32& Value, int32 Other, ECompare Comparison, ETestIssueType IssueType, const class FString& IssueCategory, const class FString& IssueMessage)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("TestPolicy", "TestIntCompare");

	Params::TestPolicy_TestIntCompare Parms{};

	Parms.Value = Value;
	Parms.Other = Other;
	Parms.Comparison = Comparison;
	Parms.IssueType = IssueType;
	Parms.IssueCategory = std::move(IssueCategory);
	Parms.IssueMessage = std::move(IssueMessage);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function GbxTest.TestPolicy.TestIntInRange
// (Final, Native, Public, HasOutParams, BlueprintCallable)
// Parameters:
// int32                                   Value                                                  (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   Min                                                    (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   Max                                                    (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// ETestIssueType                          IssueType                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, AdvancedDisplay, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class FString                           IssueCategory                                          (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class FString                           IssueMessage                                           (Parm, ZeroConstructor, AdvancedDisplay, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UTestPolicy::TestIntInRange(const int32& Value, int32 Min, int32 Max, ETestIssueType IssueType, const class FString& IssueCategory, const class FString& IssueMessage)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("TestPolicy", "TestIntInRange");

	Params::TestPolicy_TestIntInRange Parms{};

	Parms.Value = Value;
	Parms.Min = Min;
	Parms.Max = Max;
	Parms.IssueType = IssueType;
	Parms.IssueCategory = std::move(IssueCategory);
	Parms.IssueMessage = std::move(IssueMessage);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function GbxTest.TestPolicy.OnGetTestCommands
// (Native, Event, Protected, HasOutParams, BlueprintEvent, Const)
// Parameters:
// TArray<class FString>                   TestCommands                                           (Parm, OutParm, ZeroConstructor, NativeAccessSpecifierPublic)
// TArray<class FString>                   PrettyNames                                            (Parm, OutParm, ZeroConstructor, NativeAccessSpecifierPublic)

void UTestPolicy::OnGetTestCommands(TArray<class FString>* TestCommands, TArray<class FString>* PrettyNames) const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("TestPolicy", "OnGetTestCommands");

	Params::TestPolicy_OnGetTestCommands Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	if (TestCommands != nullptr)
		*TestCommands = std::move(Parms.TestCommands);

	if (PrettyNames != nullptr)
		*PrettyNames = std::move(Parms.PrettyNames);
}


// Function GbxTest.TestPolicyContent.OnValidForImport
// (Native, Event, Protected, HasOutParams, BlueprintEvent, Const)
// Parameters:
// class UObject*                          ImportObject                                           (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    Result                                                 (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UTestPolicyContent::OnValidForImport(const class UObject* ImportObject, bool* Result) const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("TestPolicyContent", "OnValidForImport");

	Params::TestPolicyContent_OnValidForImport Parms{};

	Parms.ImportObject = ImportObject;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	if (Result != nullptr)
		*Result = Parms.Result;
}


// Function GbxTest.TestPolicySimulation.AddTestDriver
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// TSubclassOf<class AActor>               TestDriver                                             (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UTestPolicySimulation::AddTestDriver(const TSubclassOf<class AActor> TestDriver)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("TestPolicySimulation", "AddTestDriver");

	Params::TestPolicySimulation_AddTestDriver Parms{};

	Parms.TestDriver = TestDriver;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function GbxTest.TestPolicySimulation.IntendToMapTravel
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// bool                                    WillMapTravel                                          (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UTestPolicySimulation::IntendToMapTravel(bool WillMapTravel)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("TestPolicySimulation", "IntendToMapTravel");

	Params::TestPolicySimulation_IntendToMapTravel Parms{};

	Parms.WillMapTravel = WillMapTravel;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function GbxTest.TestPolicySimulation.OnMapTraveled
// (Event, Public, BlueprintEvent)
// Parameters:
// class UWorld*                           NewWorld                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UTestPolicySimulation::OnMapTraveled(class UWorld* NewWorld)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("TestPolicySimulation", "OnMapTraveled");

	Params::TestPolicySimulation_OnMapTraveled Parms{};

	Parms.NewWorld = NewWorld;

	UObject::ProcessEvent(Func, &Parms);
}


// Function GbxTest.TestPolicySimulation.PlayMap
// (Final, Native, Public, HasOutParams, BlueprintCallable)
// Parameters:
// class FString                           MapName                                                (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// TArray<TSubclassOf<class AActor>>       TestDrivers                                            (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, UObjectWrapper, NativeAccessSpecifierPublic)
// float                                   Timeout                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, AdvancedDisplay, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   TimeLimit                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, AdvancedDisplay, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UTestPolicySimulation::PlayMap(const class FString& MapName, const TArray<TSubclassOf<class AActor>>& TestDrivers, float Timeout, float TimeLimit)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("TestPolicySimulation", "PlayMap");

	Params::TestPolicySimulation_PlayMap Parms{};

	Parms.MapName = std::move(MapName);
	Parms.TestDrivers = std::move(TestDrivers);
	Parms.Timeout = Timeout;
	Parms.TimeLimit = TimeLimit;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function GbxTest.TestPolicySimulation.PlayTestMap
// (Final, Native, Public, HasOutParams, BlueprintCallable)
// Parameters:
// class FString                           MapName                                                (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// TArray<TSubclassOf<class AActor>>       TestDrivers                                            (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, UObjectWrapper, NativeAccessSpecifierPublic)
// float                                   Timeout                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, AdvancedDisplay, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   TimeLimit                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, AdvancedDisplay, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    bLoadMapOnce                                           (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, AdvancedDisplay, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    bLoadMapIfNotLoaded                                    (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, AdvancedDisplay, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UTestPolicySimulation::PlayTestMap(const class FString& MapName, const TArray<TSubclassOf<class AActor>>& TestDrivers, float Timeout, float TimeLimit, bool bLoadMapOnce, bool bLoadMapIfNotLoaded)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("TestPolicySimulation", "PlayTestMap");

	Params::TestPolicySimulation_PlayTestMap Parms{};

	Parms.MapName = std::move(MapName);
	Parms.TestDrivers = std::move(TestDrivers);
	Parms.Timeout = Timeout;
	Parms.TimeLimit = TimeLimit;
	Parms.bLoadMapOnce = bLoadMapOnce;
	Parms.bLoadMapIfNotLoaded = bLoadMapIfNotLoaded;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function GbxTest.TestPolicySimulation.RunTestDrivers
// (Final, Native, Public, HasOutParams, BlueprintCallable)
// Parameters:
// TArray<TSubclassOf<class AActor>>       TestDrivers                                            (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, UObjectWrapper, NativeAccessSpecifierPublic)
// float                                   Timeout                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, AdvancedDisplay, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   TimeLimit                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, AdvancedDisplay, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UTestPolicySimulation::RunTestDrivers(const TArray<TSubclassOf<class AActor>>& TestDrivers, float Timeout, float TimeLimit)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("TestPolicySimulation", "RunTestDrivers");

	Params::TestPolicySimulation_RunTestDrivers Parms{};

	Parms.TestDrivers = std::move(TestDrivers);
	Parms.Timeout = Timeout;
	Parms.TimeLimit = TimeLimit;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function GbxTest.TestPolicySimulation.StopPlay
// (Final, Native, Public, BlueprintCallable)

void UTestPolicySimulation::StopPlay()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("TestPolicySimulation", "StopPlay");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}

}

