#pragma once

/*
* SDK generated by Dumper-7
*
* https://github.com/Encryqed/Dumper-7
*/

// Package: GbxGameSystemCore

#include "Basic.hpp"

#include "AnimGraphRuntime_structs.hpp"
#include "CoreUObject_structs.hpp"
#include "Engine_structs.hpp"
#include "InputCore_structs.hpp"
#include "GbxRuntime_structs.hpp"
#include "AIModule_structs.hpp"
#include "GameplayTags_structs.hpp"
#include "ImmediatePhysics_structs.hpp"
#include "AnimationCore_structs.hpp"


namespace SDK
{

// Enum GbxGameSystemCore.EGbxActionEndState
// NumValues: 0x0007
enum class EGbxActionEndState : uint8
{
	NotFinished                              = 0,
	Success                                  = 1,
	Interrupted                              = 2,
	Aborted                                  = 3,
	Denied                                   = 4,
	Error                                    = 5,
	EGbxActionEndState_MAX                   = 6,
};

// Enum GbxGameSystemCore.EStanceStackLayer
// NumValues: 0x0006
enum class EStanceStackLayer : uint8
{
	Default                                  = 0,
	AITree                                   = 1,
	Blueprint                                = 2,
	Scripted                                 = 3,
	Count                                    = 4,
	EStanceStackLayer_MAX                    = 5,
};

// Enum GbxGameSystemCore.EFacingChannel
// NumValues: 0x0005
enum class EFacingChannel : uint8
{
	Body                                     = 0,
	Aim                                      = 1,
	Look                                     = 2,
	Count                                    = 3,
	EFacingChannel_MAX                       = 4,
};

// Enum GbxGameSystemCore.EFacingInfoType
// NumValues: 0x000C
enum class EFacingInfoType : uint8
{
	None                                     = 0,
	Actor                                    = 1,
	ActorEyes                                = 2,
	Component                                = 3,
	Location                                 = 4,
	Direction                                = 5,
	Rotation                                 = 6,
	Controller                               = 7,
	ControllerAim                            = 8,
	Path                                     = 9,
	Count                                    = 10,
	EFacingInfoType_MAX                      = 11,
};

// Enum GbxGameSystemCore.ENavAnimState
// NumValues: 0x000A
enum class ENavAnimState : uint8
{
	None                                     = 0,
	Idle                                     = 1,
	Hop                                      = 2,
	Start                                    = 3,
	Move                                     = 4,
	Stop                                     = 5,
	TurnIdle                                 = 6,
	TurnMoving                               = 7,
	TurnBlend                                = 8,
	Max                                      = 9,
};

// Enum GbxGameSystemCore.EScriptedLadderType
// NumValues: 0x0006
enum class EScriptedLadderType : uint8
{
	None                                     = 0,
	GettingOnAtBottom                        = 1,
	GettingOffAtBottom                       = 2,
	GettingOnAtTop                           = 3,
	GettingOffAtTop                          = 4,
	EScriptedLadderType_MAX                  = 5,
};

// Enum GbxGameSystemCore.EUsabilityType
// NumValues: 0x0004
enum class EUsabilityType : uint8
{
	Primary                                  = 0,
	Secondary                                = 1,
	Count                                    = 2,
	EUsabilityType_MAX                       = 3,
};

// Enum GbxGameSystemCore.EAIDodgeType
// NumValues: 0x0006
enum class EAIDodgeType : uint8
{
	None                                     = 0,
	Bullet                                   = 1,
	Grenade                                  = 2,
	Random                                   = 3,
	Zone                                     = 4,
	EAIDodgeType_MAX                         = 5,
};

// Enum GbxGameSystemCore.EGbxGlyphSetOption
// NumValues: 0x0008
enum class EGbxGlyphSetOption : uint8
{
	AutoDetect                               = 0,
	Set1                                     = 1,
	Set2                                     = 2,
	Set3                                     = 3,
	Set4                                     = 4,
	Set5                                     = 5,
	Set6                                     = 6,
	EGbxGlyphSetOption_MAX                   = 7,
};

// Enum GbxGameSystemCore.EStatusEffectDurationType
// NumValues: 0x0003
enum class EStatusEffectDurationType : uint8
{
	Timed                                    = 0,
	Infinite                                 = 1,
	EStatusEffectDurationType_MAX            = 2,
};

// Enum GbxGameSystemCore.EHoldToUseMode
// NumValues: 0x0004
enum class EHoldToUseMode : uint8
{
	Disabled                                 = 0,
	HoldOnly                                 = 1,
	Both                                     = 2,
	EHoldToUseMode_MAX                       = 3,
};

// Enum GbxGameSystemCore.EPawnAttachStatus
// NumValues: 0x0005
enum class EPawnAttachStatus : uint8
{
	Unoccupied                               = 0,
	Attaching                                = 1,
	Attached                                 = 2,
	Detaching                                = 3,
	EPawnAttachStatus_MAX                    = 4,
};

// Enum GbxGameSystemCore.ESpawnCostSelection
// NumValues: 0x0003
enum class ESpawnCostSelection : uint8
{
	Preset                                   = 0,
	Custom                                   = 1,
	ESpawnCostSelection_MAX                  = 2,
};

// Enum GbxGameSystemCore.EMassSelection
// NumValues: 0x0004
enum class EMassSelection : uint8
{
	Automatic                                = 0,
	Custom                                   = 1,
	Preset                                   = 2,
	EMassSelection_MAX                       = 3,
};

// Enum GbxGameSystemCore.EDamageCausedModificationStrategy
// NumValues: 0x0003
enum class EDamageCausedModificationStrategy : uint32
{
	UseSelfModifier                          = 0,
	UseInstigatorModifier                    = 1,
	EDamageCausedModificationStrategy_MAX    = 2,
};

// Enum GbxGameSystemCore.ECriticalHitDamageOverride
// NumValues: 0x0004
enum class ECriticalHitDamageOverride : uint8
{
	None                                     = 0,
	ForceCrit                                = 1,
	ForceNotCrit                             = 2,
	ECriticalHitDamageOverride_MAX           = 3,
};

// Enum GbxGameSystemCore.ETeamCollisionChannel
// NumValues: 0x0005
enum class ETeamCollisionChannel : uint8
{
	One                                      = 0,
	Two                                      = 1,
	Three                                    = 2,
	Four                                     = 3,
	ETeamCollisionChannel_MAX                = 4,
};

// Enum GbxGameSystemCore.EStanceValueOverrideType
// NumValues: 0x0004
enum class EStanceValueOverrideType : uint8
{
	None                                     = 0,
	Relative                                 = 1,
	Absolute                                 = 2,
	EStanceValueOverrideType_MAX             = 3,
};

// Enum GbxGameSystemCore.ERecentDamageFlags
// NumValues: 0x000A
enum class ERecentDamageFlags : uint8
{
	None                                     = 0,
	CriticalHit                              = 1,
	Healing                                  = 2,
	Shield                                   = 4,
	Armor                                    = 8,
	DamageOverTime                           = 16,
	Resist                                   = 32,
	ZeroDamage                               = 64,
	Weapon                                   = 128,
	ERecentDamageFlags_MAX                   = 129,
};

// Enum GbxGameSystemCore.EUIStatComparisonResult
// NumValues: 0x0005
enum class EUIStatComparisonResult : uint8
{
	None                                     = 0,
	Better                                   = 1,
	Worse                                    = 2,
	Same                                     = 3,
	EUIStatComparisonResult_MAX              = 4,
};

// Enum GbxGameSystemCore.EActorPartTypeSelectionOverrideMode
// NumValues: 0x0003
enum class EActorPartTypeSelectionOverrideMode : uint8
{
	PreferredParts                           = 0,
	OverrideParts                            = 1,
	EActorPartTypeSelectionOverrideMode_MAX  = 2,
};

// Enum GbxGameSystemCore.EActorPartReplacementMode
// NumValues: 0x0004
enum class EActorPartReplacementMode : uint8
{
	Additive                                 = 0,
	Selective                                = 1,
	Complete                                 = 2,
	EActorPartReplacementMode_MAX            = 3,
};

// Enum GbxGameSystemCore.EActorTagQueryMode
// NumValues: 0x0004
enum class EActorTagQueryMode : uint8
{
	HasAny                                   = 0,
	HasNone                                  = 1,
	HasAll                                   = 2,
	EActorTagQueryMode_MAX                   = 3,
};

// Enum GbxGameSystemCore.EChargeCurveType
// NumValues: 0x0003
enum class EChargeCurveType : uint8
{
	Relative                                 = 0,
	Absolute                                 = 1,
	EChargeCurveType_MAX                     = 2,
};

// Enum GbxGameSystemCore.ERelativeSizeCharge
// NumValues: 0x0005
enum class ERelativeSizeCharge : uint8
{
	Everyone                                 = 0,
	SameAndBigger                            = 1,
	OnlyBigger                               = 2,
	None                                     = 3,
	ERelativeSizeCharge_MAX                  = 4,
};

// Enum GbxGameSystemCore.EAnimActionDefInput
// NumValues: 0x0003
enum class EAnimActionDefInput : uint8
{
	AnimAsset                                = 1,
	AnimAssetName                            = 2,
	EAnimActionDefInput_MAX                  = 3,
};

// Enum GbxGameSystemCore.EAnimNotifyAlignType
// NumValues: 0x0003
enum class EAnimNotifyAlignType : uint8
{
	Self                                     = 0,
	Partner                                  = 1,
	EAnimNotifyAlignType_MAX                 = 2,
};

// Enum GbxGameSystemCore.EAttributeInitializerUsageMode
// NumValues: 0x0005
enum class EAttributeInitializerUsageMode : uint8
{
	Set                                      = 0,
	Add                                      = 1,
	Scale                                    = 2,
	Offset                                   = 3,
	EAttributeInitializerUsageMode_MAX       = 4,
};

// Enum GbxGameSystemCore.EBalanceValueType
// NumValues: 0x0003
enum class EBalanceValueType : uint8
{
	GameStage                                = 0,
	ExperienceLevel                          = 1,
	EBalanceValueType_MAX                    = 2,
};

// Enum GbxGameSystemCore.EChallengeType
// NumValues: 0x0005
enum class EChallengeType : uint8
{
	ECT_Stat                                 = 0,
	ECT_LevelObject                          = 1,
	ECT_DesignerTriggered                    = 2,
	ECT_Blueprint                            = 3,
	ECT_MAX                                  = 4,
};

// Enum GbxGameSystemCore.ECharacterMovementAttributeValueType
// NumValues: 0x0003
enum class ECharacterMovementAttributeValueType : uint8
{
	Speed                                    = 0,
	Speed2D                                  = 1,
	ECharacterMovementAttributeValueType_MAX = 2,
};

// Enum GbxGameSystemCore.ECinematicAudioMode
// NumValues: 0x0004
enum class ECinematicAudioMode : uint8
{
	NormalWorldAudio                         = 0,
	StandardCinematic                        = 1,
	ExclusiveMode                            = 2,
	ECinematicAudioMode_MAX                  = 3,
};

// Enum GbxGameSystemCore.EConditionalAreaDamageFilter
// NumValues: 0x0003
enum class EConditionalAreaDamageFilter : uint8
{
	MustNotBeRadiusDamage                    = 0,
	MustBeRadiusDamage                       = 1,
	EConditionalAreaDamageFilter_MAX         = 2,
};

// Enum GbxGameSystemCore.EConditionalDamageCriticalFilter
// NumValues: 0x0005
enum class EConditionalDamageCriticalFilter : uint8
{
	HitRegionMustBeCritical                  = 0,
	HitRegioneMustNotBeCritical              = 1,
	MustBeAnyCritical                        = 2,
	MustNotBeAnyCritical                     = 3,
	EConditionalDamageCriticalFilter_MAX     = 4,
};

// Enum GbxGameSystemCore.EDamageFilterExprMode
// NumValues: 0x0003
enum class EDamageFilterExprMode : uint32
{
	MustMatch                                = 0,
	MustNotMatch                             = 1,
	EDamageFilterExprMode_MAX                = 2,
};

// Enum GbxGameSystemCore.EConditionalDamageTypeBonusMode
// NumValues: 0x0006
enum class EConditionalDamageTypeBonusMode : uint8
{
	AddBonusDamage                           = 0,
	AddBonusDamage_BackToAttacker            = 1,
	AddBonusDamage_BackToAttackerInstigator  = 2,
	ConvertPartialDamage                     = 3,
	ConvertAllDamage                         = 4,
	EConditionalDamageTypeBonusMode_MAX      = 5,
};

// Enum GbxGameSystemCore.EConditionalDamageModifierType
// NumValues: 0x0004
enum class EConditionalDamageModifierType : uint8
{
	Scale                                    = 0,
	Add                                      = 1,
	ScaleSimple                              = 2,
	EConditionalDamageModifierType_MAX       = 3,
};

// Enum GbxGameSystemCore.ECMInheritVelocityType
// NumValues: 0x0007
enum class ECMInheritVelocityType : uint8
{
	Forward                                  = 0,
	Backward                                 = 1,
	Right                                    = 2,
	Left                                     = 3,
	Up                                       = 4,
	Down                                     = 5,
	ECMInheritVelocityType_MAX               = 6,
};

// Enum GbxGameSystemCore.ECMTerminalVelocityModificationType
// NumValues: 0x0003
enum class ECMTerminalVelocityModificationType : uint8
{
	OverrideTerminalVelocity                 = 0,
	ScaleTerminalVelocity                    = 1,
	ECMTerminalVelocityModificationType_MAX  = 2,
};

// Enum GbxGameSystemCore.ECMGravityModificationType
// NumValues: 0x0004
enum class ECMGravityModificationType : uint8
{
	ScaleGravity                             = 0,
	ScaleDefaultGravity                      = 1,
	OverrideGravity                          = 2,
	ECMGravityModificationType_MAX           = 3,
};

// Enum GbxGameSystemCore.ECMLedgeBehavior
// NumValues: 0x0004
enum class ECMLedgeBehavior : uint8
{
	CanWalkOffLedges                         = 0,
	CannotWalkOffLedges                      = 1,
	StopOnReachedLedge                       = 2,
	ECMLedgeBehavior_MAX                     = 3,
};

// Enum GbxGameSystemCore.ECMTeleportPreferenceType
// NumValues: 0x0005
enum class ECMTeleportPreferenceType : uint8
{
	Behind_TargetFacing                      = 0,
	Ahead_TargetFacing                       = 1,
	Behind_MoveDirection                     = 2,
	Ahead_MoveDirection                      = 3,
	ECMTeleportPreferenceType_MAX            = 4,
};

// Enum GbxGameSystemCore.ECMMoveLRControlType
// NumValues: 0x0004
enum class ECMMoveLRControlType : uint8
{
	None                                     = 0,
	Yaw                                      = 1,
	Speed                                    = 2,
	ECMMoveLRControlType_MAX                 = 3,
};

// Enum GbxGameSystemCore.ECMMoveFBControlType
// NumValues: 0x0004
enum class ECMMoveFBControlType : uint8
{
	None                                     = 0,
	Pitch                                    = 1,
	Speed                                    = 2,
	ECMMoveFBControlType_MAX                 = 3,
};

// Enum GbxGameSystemCore.ECMMovementType
// NumValues: 0x0005
enum class ECMMovementType : uint8
{
	Ground                                   = 0,
	Flying                                   = 1,
	Falling                                  = 2,
	MoveNoneRootMotion                       = 3,
	ECMMovementType_MAX                      = 4,
};

// Enum GbxGameSystemCore.EDamageAreaBoxOriginType
// NumValues: 0x0003
enum class EDamageAreaBoxOriginType : uint8
{
	Centered                                 = 0,
	OffsetByDepth                            = 1,
	EDamageAreaBoxOriginType_MAX             = 2,
};

// Enum GbxGameSystemCore.EDamageAreaOverlapFilterType
// NumValues: 0x0004
enum class EDamageAreaOverlapFilterType : uint8
{
	AllDynamicObjects                        = 0,
	Profile                                  = 1,
	Custom                                   = 2,
	EDamageAreaOverlapFilterType_MAX         = 3,
};

// Enum GbxGameSystemCore.EDamageComponentHealthMode
// NumValues: 0x0003
enum class EDamageComponentHealthMode : uint32
{
	ResourcePools                            = 0,
	SimpleHealth                             = 1,
	EDamageComponentHealthMode_MAX           = 2,
};

// Enum GbxGameSystemCore.EAdditionalDamageClassifier
// NumValues: 0x0005
enum class EAdditionalDamageClassifier : uint8
{
	None                                     = 0,
	BonusDamage                              = 1,
	ReflectedBonusDamage                     = 2,
	ConvertedDamage                          = 3,
	EAdditionalDamageClassifier_MAX          = 4,
};

// Enum GbxGameSystemCore.EDebugDisplayVerbosityLevel
// NumValues: 0x0003
enum class EDebugDisplayVerbosityLevel : uint8
{
	Normal                                   = 0,
	Verbose                                  = 1,
	EDebugDisplayVerbosityLevel_MAX          = 2,
};

// Enum GbxGameSystemCore.EExplosionTinnitusDuration
// NumValues: 0x0005
enum class EExplosionTinnitusDuration : uint8
{
	None                                     = 0,
	Short                                    = 1,
	Medium                                   = 2,
	Long                                     = 3,
	EExplosionTinnitusDuration_MAX           = 4,
};

// Enum GbxGameSystemCore.EFeedbackDataFirstPersonImpulseType
// NumValues: 0x0003
enum class EFeedbackDataFirstPersonImpulseType : uint8
{
	None                                     = 0,
	Custom                                   = 1,
	EFeedbackDataFirstPersonImpulseType_MAX  = 2,
};

// Enum GbxGameSystemCore.EFeedbackType
// NumValues: 0x0006
enum class EFeedbackType : uint8
{
	Ranged                                   = 0,
	Directional                              = 1,
	RandomRumble                             = 2,
	Continuous                               = 3,
	RandomShake                              = 4,
	EFeedbackType_MAX                        = 255,
};

// Enum GbxGameSystemCore.EForceSelection
// NumValues: 0x0004
enum class EForceSelection : uint8
{
	Custom                                   = 0,
	Attribute                                = 1,
	Preset                                   = 2,
	EForceSelection_MAX                      = 3,
};

// Enum GbxGameSystemCore.EContainsTagComponent
// NumValues: 0x0003
enum class EContainsTagComponent : uint8
{
	HasTagComponent                          = 0,
	NoTagComponent                           = 1,
	EContainsTagComponent_MAX                = 2,
};

// Enum GbxGameSystemCore.EGameResourcePoolState
// NumValues: 0x0005
enum class EGameResourcePoolState : uint8
{
	RPS_Depleted                             = 0,
	RPS_Depleting                            = 1,
	RPS_Filled                               = 2,
	RPS_Regenerating                         = 3,
	RPS_MAX                                  = 4,
};

// Enum GbxGameSystemCore.GameResourcePoolReplicationType
// NumValues: 0x0004
enum class EGameResourcePoolReplicationType : uint8
{
	GRPRT_None                               = 0,
	GRPRT_Basic                              = 1,
	GRPRT_Full                               = 2,
	GRPRT_MAX                                = 3,
};

// Enum GbxGameSystemCore.EAIChargeAnim
// NumValues: 0x0009
enum class EAIChargeAnim : uint8
{
	None                                     = 0,
	Start                                    = 1,
	Loop                                     = 2,
	Miss                                     = 3,
	Strike                                   = 4,
	HitWall                                  = 5,
	ReachCliff                               = 6,
	StopForFriendly                          = 7,
	EAIChargeAnim_MAX                        = 8,
};

// Enum GbxGameSystemCore.EActionSelectionMethod
// NumValues: 0x0003
enum class EActionSelectionMethod : uint8
{
	FIRST                                    = 0,
	RANDOM                                   = 1,
	EActionSelectionMethod_MAX               = 2,
};

// Enum GbxGameSystemCore.ECoordinatedOwnedParticleAction
// NumValues: 0x0004
enum class ECoordinatedOwnedParticleAction : uint8
{
	None                                     = 0,
	Hide                                     = 1,
	Suppress                                 = 2,
	ECoordinatedOwnedParticleAction_MAX      = 3,
};

// Enum GbxGameSystemCore.ECoordinatedParticleScaleMode
// NumValues: 0x0007
enum class ECoordinatedParticleScaleMode : uint8
{
	None                                     = 0,
	LargestAxis                              = 1,
	SmallestAxis                             = 2,
	HorizontalAxis                           = 3,
	VerticalAxis                             = 4,
	EachAxis                                 = 5,
	ECoordinatedParticleScaleMode_MAX        = 6,
};

// Enum GbxGameSystemCore.ECoordinatedEffectParamScaleMode
// NumValues: 0x0005
enum class ECoordinatedEffectParamScaleMode : uint8
{
	None                                     = 0,
	XBounds                                  = 1,
	YBounds                                  = 2,
	ZBounds                                  = 3,
	ECoordinatedEffectParamScaleMode_MAX     = 4,
};

// Enum GbxGameSystemCore.EDirectionPlane
// NumValues: 0x0003
enum class EDirectionPlane : uint32
{
	Horizontal                               = 0,
	Vertical                                 = 1,
	EDirectionPlane_MAX                      = 2,
};

// Enum GbxGameSystemCore.EGbxPhysicalActionMovementLockMode
// NumValues: 0x0005
enum class EGbxPhysicalActionMovementLockMode : uint8
{
	MLM_None                                 = 0,
	MLM_AquireOnBegin                        = 1,
	MLM_ReleaseOnEnd                         = 2,
	MLM_AquireRelease                        = 3,
	MLM_MAX                                  = 4,
};

// Enum GbxGameSystemCore.EGbxPhysicalActionDynamicBodyState
// NumValues: 0x0005
enum class EGbxPhysicalActionDynamicBodyState : uint8
{
	DBS_Upright                              = 0,
	DBS_FaceDown                             = 1,
	DBS_FaceUp                               = 2,
	DBS_Unknown                              = 3,
	DBS_MAX                                  = 4,
};

// Enum GbxGameSystemCore.EGbxPhysicalActionDynamicBoneActivationMode
// NumValues: 0x0004
enum class EGbxPhysicalActionDynamicBoneActivationMode : uint8
{
	DBAM_HitBone                             = 0,
	DBAM_Recursive                           = 1,
	DBAM_FullBody                            = 2,
	DBAM_MAX                                 = 3,
};

// Enum GbxGameSystemCore.EGbxPhysicalActionEndCondition
// NumValues: 0x0008
enum class EGbxPhysicalActionEndCondition : uint8
{
	EndCondition_AnimationMatch              = 0,
	EndCondition_NoFatigue                   = 1,
	EndCondition_FullFatigue                 = 2,
	EndCondition_AnimationEnd                = 3,
	EndCondition_NotAllFlagsMatch            = 4,
	EndCondition_NotAnyFlagsMatch            = 5,
	EndCondition_Undetermined                = 6,
	EndCondition_MAX                         = 7,
};

// Enum GbxGameSystemCore.EGbxPhysicalActionBeginCondition
// NumValues: 0x0005
enum class EGbxPhysicalActionBeginCondition : uint8
{
	BeginCondition_Immediate                 = 0,
	BeginCondition_WaitUntilPoseMatch        = 1,
	BeginCondition_NotAllFlagsMatch          = 2,
	BeginCondition_NotAnyFlagsMatch          = 3,
	BeginCondition_MAX                       = 4,
};

// Enum GbxGameSystemCore.ERagdollState
// NumValues: 0x0009
enum class ERagdollState : uint8
{
	Start                                    = 0,
	Anim                                     = 1,
	Ragdoll                                  = 2,
	IdlePoseDriving                          = 3,
	StartBlend                               = 4,
	Blend                                    = 5,
	Getup                                    = 6,
	Done                                     = 7,
	ERagdollState_MAX                        = 8,
};

// Enum GbxGameSystemCore.EDynamicToKinematicTransition
// NumValues: 0x0005
enum class EDynamicToKinematicTransition : uint32
{
	NoTransition                             = 0,
	RagdollLandToStandUp                     = 1,
	PredictiveLanding                        = 2,
	AttemptPredictiveLanding                 = 3,
	EDynamicToKinematicTransition_MAX        = 4,
};

// Enum GbxGameSystemCore.EGbxActionEndCondition
// NumValues: 0x0004
enum class EGbxActionEndCondition : uint8
{
	EndCondition_BlendOut                    = 0,
	EndCondition_LastFrame                   = 1,
	EndCondition_Loop                        = 2,
	EndCondition_MAX                         = 3,
};

// Enum GbxGameSystemCore.EGbxActionPriority
// NumValues: 0x0005
enum class EGbxActionPriority : uint8
{
	Low                                      = 0,
	Normal                                   = 1,
	High                                     = 2,
	Important                                = 3,
	EGbxActionPriority_MAX                   = 4,
};

// Enum GbxGameSystemCore.EGbxActionNetMode
// NumValues: 0x0005
enum class EGbxActionNetMode : uint8
{
	ServerAuth                               = 0,
	AlwaysRep                                = 1,
	LocalOnly                                = 2,
	SkipNetOwner                             = 3,
	EGbxActionNetMode_MAX                    = 4,
};

// Enum GbxGameSystemCore.EActionRegisterType
// NumValues: 0x0007
enum class EActionRegisterType : uint8
{
	NoType                                   = 0,
	Float                                    = 1,
	Int                                      = 2,
	Object                                   = 3,
	Name                                     = 4,
	Vector                                   = 5,
	EActionRegisterType_MAX                  = 6,
};

// Enum GbxGameSystemCore.EAnimBPProfileImport
// NumValues: 0x0005
enum class EAnimBPProfileImport : uint8
{
	All                                      = 0,
	FootIK                                   = 1,
	LookAt                                   = 2,
	ForwardDynamics                          = 3,
	EAnimBPProfileImport_MAX                 = 4,
};

// Enum GbxGameSystemCore.EForwardDynamicsActivation
// NumValues: 0x0003
enum class EForwardDynamicsActivation : uint32
{
	PhysicsAssetSimulated                    = 0,
	ForwardDynamicsProfileDefinition         = 1,
	EForwardDynamicsActivation_MAX           = 2,
};

// Enum GbxGameSystemCore.EGbxAreaDrawStyle
// NumValues: 0x0005
enum class EGbxAreaDrawStyle : uint8
{
	None                                     = 0,
	Wire                                     = 1,
	Solid                                    = 2,
	SolidAndWire                             = 3,
	EGbxAreaDrawStyle_MAX                    = 4,
};

// Enum GbxGameSystemCore.EGbxAttributeModifierActionExecOutput
// NumValues: 0x0003
enum class EGbxAttributeModifierActionExecOutput : uint8
{
	Success                                  = 0,
	Failure                                  = 1,
	EGbxAttributeModifierActionExecOutput_MAX = 2,
};

// Enum GbxGameSystemCore.EGbxBoneModifyProfile_PoseMode
// NumValues: 0x0003
enum class EGbxBoneModifyProfile_PoseMode : uint8
{
	Override                                 = 0,
	Additive                                 = 1,
	EGbxBoneModifyProfile_MAX                = 2,
};

// Enum GbxGameSystemCore.EBoneModifyTransition_TransformType
// NumValues: 0x0004
enum class EBoneModifyTransition_TransformType : uint8
{
	Translation                              = 0,
	Rotation                                 = 1,
	Scale                                    = 2,
	EBoneModifyTransition_MAX                = 3,
};

// Enum GbxGameSystemCore.EGbxCharacterBlendPoints
// NumValues: 0x0003
enum class EGbxCharacterBlendPoints : uint8
{
	SixPoint                                 = 0,
	EightPoint                               = 1,
	EGbxCharacterBlendPoints_MAX             = 2,
};

// Enum GbxGameSystemCore.EMantleUpCheckState
// NumValues: 0x001A
enum class EMantleUpCheckState : uint8
{
	Unknown                                  = 0,
	WallCheck_NoWall                         = 1,
	WallCheck_TooFlat                        = 2,
	WallCheck_InvalidHitComponent            = 3,
	HeadRoomCheck_BlockedAhead               = 4,
	HeadRoomCheck_BlockedAbove               = 5,
	StandingSpotCheck_Initial_Ahead_NoFloor  = 6,
	StandingSpotCheck_Initial_Ahead_InitiallyPenetrating = 7,
	StandingSpotCheck_Initial_Ahead_InvalidHitComponent = 8,
	StandingSpotCheck_Final_Ahead_NoFloor    = 9,
	StandingSpotCheck_Final_Ahead_InitiallyPenetrating = 10,
	StandingSpotCheck_Final_Ahead_InvalidHitComponent = 11,
	StandingSpotCheck_Final_Ahead_UnwalkableSlope = 12,
	StandingSpotCheck_Final_Ahead_OutsideOfHeightTolerance = 13,
	StandingSpotCheck_Final_Ahead_BlockedAtHead = 14,
	StandingSpotCheck_Initial_Rotated_NoFloor = 15,
	StandingSpotCheck_Initial_Rotated_InitiallyPenetrating = 16,
	StandingSpotCheck_Initial_Rotated_InvalidHitComponent = 17,
	StandingSpotCheck_Final_Rotated_NoFloor  = 18,
	StandingSpotCheck_Final_Rotated_InitiallyPenetrating = 19,
	StandingSpotCheck_Final_Rotated_InvalidHitComponent = 20,
	StandingSpotCheck_Final_Rotated_UnwalkableSlope = 21,
	StandingSpotCheck_Final_Rotated_OutsideOfHeightTolerance = 22,
	StandingSpotCheck_Final_Rotated_BlockedAtHead = 23,
	Good                                     = 24,
	EMantleUpCheckState_MAX                  = 25,
};

// Enum GbxGameSystemCore.EGbxMovementMode
// NumValues: 0x0006
enum class EGbxMovementMode : uint8
{
	GBXMOVE_Ladder                           = 0,
	GBXMOVE_Mantle                           = 1,
	GBXMOVE_PawnAttached                     = 2,
	GBXMOVE_PretendWalk                      = 3,
	GBXMOVE_NoneWithRootMotion               = 4,
	GBXMOVE_MAX                              = 5,
};

// Enum GbxGameSystemCore.EMassComparison
// NumValues: 0x0007
enum class EMassComparison : uint8
{
	LessThanOrEqual                          = 0,
	LessThan                                 = 1,
	EqualTo                                  = 2,
	NotEqualTo                               = 3,
	GreaterThan                              = 4,
	GreaterThanOrEqual                       = 5,
	EMassComparison_MAX                      = 6,
};

// Enum GbxGameSystemCore.EConditionComparisonOperatorType
// NumValues: 0x0007
enum class EConditionComparisonOperatorType : uint8
{
	EqualTo                                  = 0,
	NotEqualTo                               = 1,
	LessThan                                 = 2,
	LessThanOrEqual                          = 3,
	GreaterThan                              = 4,
	GreaterThanOrEqual                       = 5,
	EConditionComparisonOperatorType_MAX     = 6,
};

// Enum GbxGameSystemCore.ECompoundConditionOperatorType
// NumValues: 0x0005
enum class ECompoundConditionOperatorType : uint8
{
	And                                      = 0,
	Or                                       = 1,
	Xor                                      = 2,
	Not                                      = 3,
	ECompoundConditionOperatorType_MAX       = 4,
};

// Enum GbxGameSystemCore.ELinkedParameterType
// NumValues: 0x0004
enum class ELinkedParameterType : uint8
{
	Scalar                                   = 0,
	Vector                                   = 1,
	Texture                                  = 2,
	ELinkedParameterType_MAX                 = 3,
};

// Enum GbxGameSystemCore.EGbxCustomizationComponentInitSourceType
// NumValues: 0x0004
enum class EGbxCustomizationComponentInitSourceType : uint8
{
	None                                     = 0,
	CopyFromInstigatorOnSpawn                = 1,
	LinkToInstigatorOnSpawn                  = 2,
	EGbxCustomizationComponentInitSourceType_MAX = 3,
};

// Enum GbxGameSystemCore.EDamageSurfaceType
// NumValues: 0x0005
enum class EDamageSurfaceType : uint8
{
	Default                                  = 0,
	Flesh                                    = 1,
	Armor                                    = 2,
	Shield                                   = 3,
	EDamageSurfaceType_MAX                   = 4,
};

// Enum GbxGameSystemCore.EGbxFeedbackType
// NumValues: 0x0007
enum class EGbxFeedbackType : uint8
{
	Ranged                                   = 1,
	Directional                              = 2,
	RandomRumble                             = 4,
	Continuous                               = 8,
	RandomShake                              = 16,
	EFeedbackType_MAX                        = 255,
	EGbxFeedbackType_MAX                     = 256,
};

// Enum GbxGameSystemCore.EGbxFlagEval
// NumValues: 0x0007
enum class EGbxFlagEval : uint8
{
	IsTrue                                   = 0,
	IsFalse                                  = 1,
	TrueForXSeconds                          = 2,
	FalseForXSeconds                         = 3,
	TrueWithinXSeconds                       = 4,
	FalseWithinXSeconds                      = 5,
	EGbxFlagEval_MAX                         = 6,
};

// Enum GbxGameSystemCore.EPlayersOverlappingActorOutput
// NumValues: 0x0003
enum class EPlayersOverlappingActorOutput : uint8
{
	Overlapping                              = 0,
	NotOverlapping                           = 1,
	EPlayersOverlappingActorOutput_MAX       = 2,
};

// Enum GbxGameSystemCore.EPlayersInVolumeOutput
// NumValues: 0x0003
enum class EPlayersInVolumeOutput : uint8
{
	InVolume                                 = 0,
	NotInVolume                              = 1,
	EPlayersInVolumeOutput_MAX               = 2,
};

// Enum GbxGameSystemCore.EIsAutonomousOuput
// NumValues: 0x0003
enum class EIsAutonomousOuput : uint8
{
	Autonomous                               = 0,
	NotAutonomous                            = 1,
	EIsAutonomousOuput_MAX                   = 2,
};

// Enum GbxGameSystemCore.EIsPlayerExecOutput
// NumValues: 0x0003
enum class EIsPlayerExecOutput : uint8
{
	Player                                   = 0,
	NotPlayer                                = 1,
	EIsPlayerExecOutput_MAX                  = 2,
};

// Enum GbxGameSystemCore.EGbxParamValueFlags
// NumValues: 0x0003
enum class EGbxParamValueFlags : uint8
{
	ClampPositive                            = 0,
	AllBBKeyTypes                            = 1,
	EGbxParamValueFlags_MAX                  = 2,
};

// Enum GbxGameSystemCore.EGbxParamValueType
// NumValues: 0x0007
enum class EGbxParamValueType : uint8
{
	Float                                    = 0,
	Bool                                     = 1,
	Int                                      = 2,
	EnvQueryContext                          = 3,
	Object                                   = 4,
	Count                                    = 5,
	EGbxParamValueType_MAX                   = 6,
};

// Enum GbxGameSystemCore.EGbxParamValueMode
// NumValues: 0x000A
enum class EGbxParamValueMode : uint8
{
	Value                                    = 0,
	ValueVariance                            = 1,
	MinMax                                   = 2,
	Actor                                    = 3,
	None                                     = 4,
	BlackboardKey                            = 5,
	Condition                                = 6,
	AttributeInitializationData              = 7,
	Count                                    = 8,
	EGbxParamValueMode_MAX                   = 9,
};

// Enum GbxGameSystemCore.EDestructibleDamageThresholdMagnitude
// NumValues: 0x0005
enum class EDestructibleDamageThresholdMagnitude : uint8
{
	Low                                      = 0,
	Medium                                   = 1,
	High                                     = 2,
	Legacy                                   = 3,
	EDestructibleDamageThresholdMagnitude_MAX = 4,
};

// Enum GbxGameSystemCore.EGraphicsMode
// NumValues: 0x0003
enum class EGraphicsMode : uint8
{
	Performance                              = 0,
	Resolution                               = 1,
	EGraphicsMode_MAX                        = 2,
};

// Enum GbxGameSystemCore.ESpeakerSetup
// NumValues: 0x0007
enum class ESpeakerSetup : uint8
{
	SmallSpeaker                             = 0,
	Hifi                                     = 1,
	NightTime                                = 2,
	Mono                                     = 3,
	Headphones                               = 4,
	Logitech                                 = 5,
	ESpeakerSetup_MAX                        = 6,
};

// Enum GbxGameSystemCore.ETimedUpdateBehavior
// NumValues: 0x0004
enum class ETimedUpdateBehavior : uint8
{
	DontDoTimedUpdates                       = 0,
	UpdateRegularlyEvenWhenNavigating        = 1,
	UpdateRegularlyExceptWhenNavigating      = 2,
	ETimedUpdateBehavior_MAX                 = 3,
};

// Enum GbxGameSystemCore.EQueryOwnerLocationUse
// NumValues: 0x0004
enum class EQueryOwnerLocationUse : uint8
{
	Never                                    = 0,
	Always                                   = 1,
	Only                                     = 2,
	EQueryOwnerLocationUse_MAX               = 3,
};

// Enum GbxGameSystemCore.ESimpleMotionType
// NumValues: 0x0006
enum class ESimpleMotionType : uint8
{
	None                                     = 0,
	ScaleByValue                             = 1,
	Interpolate                              = 2,
	Loop                                     = 3,
	Alternate                                = 4,
	ESimpleMotionType_MAX                    = 5,
};

// Enum GbxGameSystemCore.EGlobalBoneModifyProfile_PoseMode
// NumValues: 0x0003
enum class EGlobalBoneModifyProfile_PoseMode : uint8
{
	Override                                 = 0,
	Multiplicative                           = 1,
	EGlobalBoneModifyProfile_MAX             = 2,
};

// Enum GbxGameSystemCore.EHitReactionConditionCombine
// NumValues: 0x0003
enum class EHitReactionConditionCombine : uint8
{
	And                                      = 0,
	Or                                       = 1,
	EHitReactionConditionCombine_MAX         = 2,
};

// Enum GbxGameSystemCore.EHitReactionConditionContext
// NumValues: 0x0008
enum class EHitReactionConditionContext : uint8
{
	ReceiverOwner                            = 0,
	Receiver                                 = 1,
	CauserOwner                              = 2,
	Causer                                   = 3,
	DamageType                               = 4,
	DamageSource                             = 5,
	HitRegion                                = 6,
	EHitReactionConditionContext_MAX         = 7,
};

// Enum GbxGameSystemCore.EDamageReactionEventType
// NumValues: 0x0005
enum class EDamageReactionEventType : uint8
{
	Health                                   = 0,
	HealthPersistent                         = 1,
	Damage                                   = 2,
	DamageOverTime                           = 3,
	EDamageReactionEventType_MAX             = 4,
};

// Enum GbxGameSystemCore.EHitRegionDamageRule
// NumValues: 0x0004
enum class EHitRegionDamageRule : uint8
{
	IndependentHealth                        = 0,
	OwnerHealth_DamageCap                    = 1,
	OwnerHealth_NoDamageCap                  = 2,
	EHitRegionDamageRule_MAX                 = 3,
};

// Enum GbxGameSystemCore.EImpactUsage
// NumValues: 0x0003
enum class EImpactUsage : uint8
{
	Default                                  = 0,
	Footstep                                 = 1,
	EImpactUsage_MAX                         = 2,
};

// Enum GbxGameSystemCore.EInstigatorAttributeEffectModifierValueContext
// NumValues: 0x0003
enum class EInstigatorAttributeEffectModifierValueContext : uint8
{
	Instigator                               = 0,
	ThisInventoryActor                       = 1,
	EInstigatorAttributeEffectModifierValueContext_MAX = 2,
};

// Enum GbxGameSystemCore.EInstigatorAttributeEffectAttributeToModifyContextSource
// NumValues: 0x0003
enum class EInstigatorAttributeEffectAttributeToModifyContextSource : uint8
{
	ThisInventoryActorWithInstigatorFallback = 0,
	InstigatorOnly                           = 1,
	EInstigatorAttributeEffectAttributeToModifyContextSource_MAX = 2,
};

// Enum GbxGameSystemCore.EInterpMode
// NumValues: 0x0005
enum class EInterpMode : uint8
{
	None                                     = 0,
	Linear                                   = 1,
	NonLinear                                = 2,
	Count                                    = 3,
	EInterpMode_MAX                          = 4,
};

// Enum GbxGameSystemCore.EMantleType
// NumValues: 0x0003
enum class EMantleType : uint8
{
	MantleUp                                 = 0,
	WallHop                                  = 1,
	EMantleType_MAX                          = 255,
};

// Enum GbxGameSystemCore.ENavAnimType
// NumValues: 0x0005
enum class ENavAnimType : uint8
{
	None                                     = 0,
	Direction                                = 1,
	Destination                              = 2,
	Rotation                                 = 3,
	ENavAnimType_MAX                         = 4,
};

// Enum GbxGameSystemCore.EAttachmentTransitionTiming
// NumValues: 0x0004
enum class EAttachmentTransitionTiming : uint8
{
	ChangePawnBeforeTransition               = 0,
	ChangePawnAfterTransition                = 1,
	AttachBaseDuringTransition               = 2,
	EAttachmentTransitionTiming_MAX          = 3,
};

// Enum GbxGameSystemCore.EAttachmentPossessionRule
// NumValues: 0x0003
enum class EAttachmentPossessionRule : uint8
{
	PossessBase                              = 0,
	Unchanged                                = 1,
	EAttachmentPossessionRule_MAX            = 2,
};

// Enum GbxGameSystemCore.EPhysicalAnimationBlendToKinematicMode
// NumValues: 0x0004
enum class EPhysicalAnimationBlendToKinematicMode : uint32
{
	KinematicLerp                            = 0,
	DynamicMatchesAnimation                  = 1,
	Immediate                                = 2,
	EPhysicalAnimationBlendToKinematicMode_MAX = 3,
};

// Enum GbxGameSystemCore.EPhysicalAnimationRootMotionControl
// NumValues: 0x0005
enum class EPhysicalAnimationRootMotionControl : uint8
{
	PARMC_DrivenByAnimated                   = 0,
	PARMC_PureDynamic                        = 1,
	PARMC_SimulatedPointDrive                = 2,
	PARMC_SimulatedOrientationDrive          = 3,
	PARMC_MAX                                = 4,
};

// Enum GbxGameSystemCore.EAggregateBoneStatusFlag
// NumValues: 0x0006
enum class EAggregateBoneStatusFlag : uint8
{
	ABS_HasDynamic                           = 0,
	ABS_HasMotion                            = 1,
	ABS_HasPoseVariance                      = 2,
	ABS_HasFatigue                           = 3,
	ABS_HasPlayingAnimation                  = 4,
	ABS_MAX                                  = 5,
};

// Enum GbxGameSystemCore.EAggregateBoneFatigueStatus
// NumValues: 0x0005
enum class EAggregateBoneFatigueStatus : uint8
{
	ABFS_FullyFatigued                       = 0,
	ABFS_NoFatigue                           = 1,
	ABFS_FullyDivergedFatigue                = 2,
	ABFS_VariedFatigue                       = 3,
	ABFS_MAX                                 = 4,
};

// Enum GbxGameSystemCore.ECycleDirection
// NumValues: 0x0003
enum class ECycleDirection : uint8
{
	Backward                                 = 0,
	Forward                                  = 1,
	ECycleDirection_MAX                      = 2,
};

// Enum GbxGameSystemCore.ERelativeDirectionType
// NumValues: 0x0017
enum class ERelativeDirectionType : uint8
{
	Default                                  = 0,
	ParentOrientation                        = 1,
	ParentOrientation2D                      = 2,
	InverseParentOrientation                 = 3,
	ParentVelocity                           = 4,
	ParentVelocity2D                         = 5,
	InverseParentVelocity                    = 6,
	InverseParentVelocity2D                  = 7,
	Random                                   = 8,
	RandomUpwards                            = 9,
	RandomDownwards                          = 10,
	RandomOnHorizontalPlane                  = 11,
	StraightUp                               = 12,
	StraightDown                             = 13,
	StraightTowardTarget                     = 14,
	StraightAwayFromTarget                   = 15,
	ParentAimDirection                       = 16,
	InverseParentAimDirection                = 17,
	ParentAimDirection2D                     = 18,
	InverseParentAimDirection2D              = 19,
	ParentAcceleration2D                     = 20,
	InverseParentAimOffset                   = 21,
	ERelativeDirectionType_MAX               = 22,
};

// Enum GbxGameSystemCore.EScreenParticleScalingMode
// NumValues: 0x0008
enum class EScreenParticleScalingMode : uint8
{
	FitToHorizontal                          = 0,
	FitToVertical                            = 1,
	FitToExterior                            = 2,
	FitToInterior                            = 3,
	FitToViewport                            = 4,
	DontAdjustScaling                        = 5,
	FitToViewportAndKeepContentAspectRatio   = 6,
	EScreenParticleScalingMode_MAX           = 7,
};

// Enum GbxGameSystemCore.ESimpleMathValueResolverOperatorType
// NumValues: 0x0005
enum class ESimpleMathValueResolverOperatorType : uint8
{
	Add                                      = 0,
	Subtract                                 = 1,
	Multiply                                 = 2,
	Divide                                   = 3,
	ESimpleMathValueResolverOperatorType_MAX = 4,
};

// Enum GbxGameSystemCore.ESplitScreenViewportType
// NumValues: 0x0005
enum class ESplitScreenViewportType : uint8
{
	Standard                                 = 0,
	Horizontal                               = 1,
	Vertical                                 = 2,
	Quad                                     = 3,
	ESplitScreenViewportType_MAX             = 4,
};

// Enum GbxGameSystemCore.EStatusEffectStackingInstanceReplacementCriteria
// NumValues: 0x0006
enum class EStatusEffectStackingInstanceReplacementCriteria : uint8
{
	ChooseSpec                               = 0,
	ChooseLowerDPS                           = 1,
	ChooseHigherDPS                          = 2,
	ChooseLongerDuration                     = 3,
	ChooseShorterDuration                    = 4,
	EStatusEffectStackingInstanceReplacementCriteria_MAX = 5,
};

// Enum GbxGameSystemCore.EStatusEffectStackingInstanceSelectionCriteria
// NumValues: 0x0005
enum class EStatusEffectStackingInstanceSelectionCriteria : uint8
{
	NewestInstance                           = 0,
	OldestInstance                           = 1,
	MostTimeRemaining                        = 2,
	LeastTimeRemaining                       = 3,
	EStatusEffectStackingInstanceSelectionCriteria_MAX = 4,
};

// Enum GbxGameSystemCore.EStretchBonesMarkerMode
// NumValues: 0x0004
enum class EStretchBonesMarkerMode : uint8
{
	BeforeMarker                             = 0,
	AttachedMarker                           = 1,
	AfterMarker                              = 2,
	EStretchBonesMarkerMode_MAX              = 3,
};

// Enum GbxGameSystemCore.EStretchBonesActorTrackingStyle
// NumValues: 0x0008
enum class EStretchBonesActorTrackingStyle : uint8
{
	FirstFrame                               = 0,
	PredictedFirstFrame                      = 1,
	Track                                    = 2,
	TrackUntilNotify                         = 3,
	NavEntry                                 = 4,
	NavExit                                  = 5,
	NavMidpoint                              = 6,
	EStretchBonesActorTrackingStyle_MAX      = 7,
};

// Enum GbxGameSystemCore.EAimAssistSnapTargetType
// NumValues: 0x0005
enum class EAimAssistSnapTargetType : uint8
{
	Default                                  = 0,
	Disabled                                 = 1,
	Horizontal                               = 2,
	Center                                   = 3,
	EAimAssistSnapTargetType_MAX             = 4,
};

// Enum GbxGameSystemCore.EAITargetScoringBoost
// NumValues: 0x0008
enum class EAITargetScoringBoost : uint8
{
	ReduceExtreme                            = 0,
	ReduceModerate                           = 1,
	ReduceLight                              = 2,
	NoBoost                                  = 3,
	AmplifyLight                             = 4,
	AmplifyModerate                          = 5,
	AmplifyExtreme                           = 6,
	MAX                                      = 7,
};

// Enum GbxGameSystemCore.ETerritoryCombatProxyType
// NumValues: 0x0003
enum class ETerritoryCombatProxyType : uint8
{
	Threat                                   = 0,
	Patrol                                   = 1,
	ETerritoryCombatProxyType_MAX            = 2,
};

// Enum GbxGameSystemCore.ETerritoryType
// NumValues: 0x0004
enum class ETerritoryType : uint8
{
	Patrol                                   = 0,
	Threat                                   = 1,
	Combat                                   = 2,
	ETerritoryType_MAX                       = 3,
};

// Enum GbxGameSystemCore.ETerritoryDrawStyle
// NumValues: 0x0005
enum class ETerritoryDrawStyle : uint8
{
	None                                     = 0,
	Wire                                     = 1,
	Solid                                    = 2,
	SolidAndWire                             = 3,
	ETerritoryDrawStyle_MAX                  = 4,
};

// Enum GbxGameSystemCore.EThreatReason
// NumValues: 0x000A
enum class EThreatReason : uint8
{
	ThreatReason_None                        = 0,
	ThreatReason_TerritoryEverywhereThreat   = 1,
	ThreatReason_TerritoryIncursionAuto      = 2,
	ThreatReason_TerritoryIncursionSeen      = 3,
	ThreatReason_ShotAt                      = 4,
	ThreatReason_Damaged                     = 5,
	ThreatReason_Proximity                   = 6,
	ThreatReason_TeamNotification            = 7,
	ThreatReason_Scripted                    = 8,
	ThreatReason_MAX                         = 9,
};

// Enum GbxGameSystemCore.EUIStatCombinationMethod
// NumValues: 0x0006
enum class EUIStatCombinationMethod : uint8
{
	Multiply                                 = 0,
	Divide                                   = 1,
	Add                                      = 2,
	Subtract                                 = 3,
	DontCombine                              = 4,
	EUIStatCombinationMethod_MAX             = 5,
};

// Enum GbxGameSystemCore.EUIStatValueRoundingMode
// NumValues: 0x0005
enum class EUIStatValueRoundingMode : uint8
{
	None                                     = 0,
	RoundToInt                               = 1,
	FloorToInt                               = 2,
	CeilToInt                                = 3,
	EUIStatValueRoundingMode_MAX             = 4,
};

// Enum GbxGameSystemCore.EUIStatValueSignStyle
// NumValues: 0x0005
enum class EUIStatValueSignStyle : uint8
{
	AsIs                                     = 0,
	Positive                                 = 1,
	Negative                                 = 2,
	OppositeSign                             = 3,
	EUIStatValueSignStyle_MAX                = 4,
};

// Enum GbxGameSystemCore.EUIStatValueStyle
// NumValues: 0x0004
enum class EUIStatValueStyle : uint8
{
	AttributeValue                           = 0,
	AbsoluteModification                     = 1,
	ScaleModification                        = 2,
	EUIStatValueStyle_MAX                    = 3,
};

// Enum GbxGameSystemCore.EUsableTypeCostContext
// NumValues: 0x0003
enum class EUsableTypeCostContext : uint8
{
	UsableObject                             = 0,
	Player                                   = 1,
	EUsableTypeCostContext_MAX               = 2,
};

// ScriptStruct GbxGameSystemCore.ChallengeStatInstanceData
// 0x0038 (0x0038 - 0x0000)
struct FChallengeStatInstanceData final
{
public:
	class UGameStatData*                          StatId;                                            // 0x0000(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TSoftObjectPtr<class UGameStatData>           ChallengeStatPath;                                 // 0x0008(0x0028)(UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         CurrentStatValue;                                  // 0x0030(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_34[0x4];                                       // 0x0034(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FChallengeStatInstanceData) == 0x000008, "Wrong alignment on FChallengeStatInstanceData");
static_assert(sizeof(FChallengeStatInstanceData) == 0x000038, "Wrong size on FChallengeStatInstanceData");
static_assert(offsetof(FChallengeStatInstanceData, StatId) == 0x000000, "Member 'FChallengeStatInstanceData::StatId' has a wrong offset!");
static_assert(offsetof(FChallengeStatInstanceData, ChallengeStatPath) == 0x000008, "Member 'FChallengeStatInstanceData::ChallengeStatPath' has a wrong offset!");
static_assert(offsetof(FChallengeStatInstanceData, CurrentStatValue) == 0x000030, "Member 'FChallengeStatInstanceData::CurrentStatValue' has a wrong offset!");

// ScriptStruct GbxGameSystemCore.ChallengePersistentState
// 0x0060 (0x0060 - 0x0000)
struct FChallengePersistentState final
{
public:
	class UClass*                                 ChallengeClass;                                    // 0x0000(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TSoftClassPtr<class UClass>                   ChallengeClassPath;                                // 0x0008(0x0028)(UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         CompletedCount;                                    // 0x0030(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         CompletedProgressLevel;                            // 0x0034(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TArray<struct FChallengeStatInstanceData>     StatInstanceState;                                 // 0x0038(0x0010)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, NativeAccessSpecifierPublic)
	bool                                          bIsActive;                                         // 0x0048(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bCurrentlyCompleted;                               // 0x0049(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_4A[0x2];                                       // 0x004A(0x0002)(Fixing Size After Last Property [ Dumper-7 ])
	int32                                         ProgressCounter;                                   // 0x004C(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UCustomChallengePersistentState*        CustomPersistentData;                              // 0x0050(0x0008)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_58[0x8];                                       // 0x0058(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FChallengePersistentState) == 0x000008, "Wrong alignment on FChallengePersistentState");
static_assert(sizeof(FChallengePersistentState) == 0x000060, "Wrong size on FChallengePersistentState");
static_assert(offsetof(FChallengePersistentState, ChallengeClass) == 0x000000, "Member 'FChallengePersistentState::ChallengeClass' has a wrong offset!");
static_assert(offsetof(FChallengePersistentState, ChallengeClassPath) == 0x000008, "Member 'FChallengePersistentState::ChallengeClassPath' has a wrong offset!");
static_assert(offsetof(FChallengePersistentState, CompletedCount) == 0x000030, "Member 'FChallengePersistentState::CompletedCount' has a wrong offset!");
static_assert(offsetof(FChallengePersistentState, CompletedProgressLevel) == 0x000034, "Member 'FChallengePersistentState::CompletedProgressLevel' has a wrong offset!");
static_assert(offsetof(FChallengePersistentState, StatInstanceState) == 0x000038, "Member 'FChallengePersistentState::StatInstanceState' has a wrong offset!");
static_assert(offsetof(FChallengePersistentState, bIsActive) == 0x000048, "Member 'FChallengePersistentState::bIsActive' has a wrong offset!");
static_assert(offsetof(FChallengePersistentState, bCurrentlyCompleted) == 0x000049, "Member 'FChallengePersistentState::bCurrentlyCompleted' has a wrong offset!");
static_assert(offsetof(FChallengePersistentState, ProgressCounter) == 0x00004C, "Member 'FChallengePersistentState::ProgressCounter' has a wrong offset!");
static_assert(offsetof(FChallengePersistentState, CustomPersistentData) == 0x000050, "Member 'FChallengePersistentState::CustomPersistentData' has a wrong offset!");

// ScriptStruct GbxGameSystemCore.StanceChangedEventArgs
// 0x0030 (0x0030 - 0x0000)
struct FStanceChangedEventArgs final
{
public:
	EStanceStackLayer                             PreviousLayer;                                     // 0x0000(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1[0x7];                                        // 0x0001(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	class UStanceType*                            PreviousStanceType;                                // 0x0008(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UStanceData*                            PreviousStance;                                    // 0x0010(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EStanceStackLayer                             NextLayer;                                         // 0x0018(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_19[0x7];                                       // 0x0019(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	class UStanceType*                            NextStanceType;                                    // 0x0020(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UStanceData*                            NextStance;                                        // 0x0028(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FStanceChangedEventArgs) == 0x000008, "Wrong alignment on FStanceChangedEventArgs");
static_assert(sizeof(FStanceChangedEventArgs) == 0x000030, "Wrong size on FStanceChangedEventArgs");
static_assert(offsetof(FStanceChangedEventArgs, PreviousLayer) == 0x000000, "Member 'FStanceChangedEventArgs::PreviousLayer' has a wrong offset!");
static_assert(offsetof(FStanceChangedEventArgs, PreviousStanceType) == 0x000008, "Member 'FStanceChangedEventArgs::PreviousStanceType' has a wrong offset!");
static_assert(offsetof(FStanceChangedEventArgs, PreviousStance) == 0x000010, "Member 'FStanceChangedEventArgs::PreviousStance' has a wrong offset!");
static_assert(offsetof(FStanceChangedEventArgs, NextLayer) == 0x000018, "Member 'FStanceChangedEventArgs::NextLayer' has a wrong offset!");
static_assert(offsetof(FStanceChangedEventArgs, NextStanceType) == 0x000020, "Member 'FStanceChangedEventArgs::NextStanceType' has a wrong offset!");
static_assert(offsetof(FStanceChangedEventArgs, NextStance) == 0x000028, "Member 'FStanceChangedEventArgs::NextStance' has a wrong offset!");

// ScriptStruct GbxGameSystemCore.ActionState_Base
// 0x00C8 (0x00C8 - 0x0000)
struct alignas(0x08) FActionState_Base
{
public:
	uint8                                         Pad_0[0xC8];                                       // 0x0000(0x00C8)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FActionState_Base) == 0x000008, "Wrong alignment on FActionState_Base");
static_assert(sizeof(FActionState_Base) == 0x0000C8, "Wrong size on FActionState_Base");

// ScriptStruct GbxGameSystemCore.ActionState_SimpleAnim
// 0x03A0 (0x0468 - 0x00C8)
struct FActionState_SimpleAnim : public FActionState_Base
{
public:
	uint8                                         Pad_C8[0x3A0];                                     // 0x00C8(0x03A0)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FActionState_SimpleAnim) == 0x000008, "Wrong alignment on FActionState_SimpleAnim");
static_assert(sizeof(FActionState_SimpleAnim) == 0x000468, "Wrong size on FActionState_SimpleAnim");

// ScriptStruct GbxGameSystemCore.ActionState_Anim
// 0x0090 (0x04F8 - 0x0468)
struct FActionState_Anim : public FActionState_SimpleAnim
{
public:
	uint8                                         Pad_468[0x90];                                     // 0x0468(0x0090)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FActionState_Anim) == 0x000008, "Wrong alignment on FActionState_Anim");
static_assert(sizeof(FActionState_Anim) == 0x0004F8, "Wrong size on FActionState_Anim");

// ScriptStruct GbxGameSystemCore.GbxEasingFunc
// 0x000C (0x000C - 0x0000)
struct FGbxEasingFunc final
{
public:
	EEasingFunc                                   Func;                                              // 0x0000(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1[0x3];                                        // 0x0001(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         BlendExp;                                          // 0x0004(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         Steps;                                             // 0x0008(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FGbxEasingFunc) == 0x000004, "Wrong alignment on FGbxEasingFunc");
static_assert(sizeof(FGbxEasingFunc) == 0x00000C, "Wrong size on FGbxEasingFunc");
static_assert(offsetof(FGbxEasingFunc, Func) == 0x000000, "Member 'FGbxEasingFunc::Func' has a wrong offset!");
static_assert(offsetof(FGbxEasingFunc, BlendExp) == 0x000004, "Member 'FGbxEasingFunc::BlendExp' has a wrong offset!");
static_assert(offsetof(FGbxEasingFunc, Steps) == 0x000008, "Member 'FGbxEasingFunc::Steps' has a wrong offset!");

// ScriptStruct GbxGameSystemCore.FacingInfo
// 0x003C (0x003C - 0x0000)
struct FFacingInfo final
{
public:
	EFacingInfoType                               Type;                                              // 0x0000(0x0001)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1[0x3];                                        // 0x0001(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	TWeakObjectPtr<class AActor>                  Actor;                                             // 0x0004(0x0008)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TWeakObjectPtr<class USceneComponent>         Component;                                         // 0x000C(0x0008)(BlueprintVisible, ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                Vector;                                            // 0x0014(0x000C)(BlueprintVisible, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FRotator                               Rotator;                                           // 0x0020(0x000C)(BlueprintVisible, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
	struct FVector                                Offset;                                            // 0x002C(0x000C)(BlueprintVisible, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_38[0x4];                                       // 0x0038(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FFacingInfo) == 0x000004, "Wrong alignment on FFacingInfo");
static_assert(sizeof(FFacingInfo) == 0x00003C, "Wrong size on FFacingInfo");
static_assert(offsetof(FFacingInfo, Type) == 0x000000, "Member 'FFacingInfo::Type' has a wrong offset!");
static_assert(offsetof(FFacingInfo, Actor) == 0x000004, "Member 'FFacingInfo::Actor' has a wrong offset!");
static_assert(offsetof(FFacingInfo, Component) == 0x00000C, "Member 'FFacingInfo::Component' has a wrong offset!");
static_assert(offsetof(FFacingInfo, Vector) == 0x000014, "Member 'FFacingInfo::Vector' has a wrong offset!");
static_assert(offsetof(FFacingInfo, Rotator) == 0x000020, "Member 'FFacingInfo::Rotator' has a wrong offset!");
static_assert(offsetof(FFacingInfo, Offset) == 0x00002C, "Member 'FFacingInfo::Offset' has a wrong offset!");

// ScriptStruct GbxGameSystemCore.LatentUseState
// 0x0010 (0x0010 - 0x0000)
struct FLatentUseState final
{
public:
	class UUsableComponent*                       UsableComponent;                                   // 0x0000(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_8[0x8];                                        // 0x0008(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FLatentUseState) == 0x000008, "Wrong alignment on FLatentUseState");
static_assert(sizeof(FLatentUseState) == 0x000010, "Wrong size on FLatentUseState");
static_assert(offsetof(FLatentUseState, UsableComponent) == 0x000000, "Member 'FLatentUseState::UsableComponent' has a wrong offset!");

// ScriptStruct GbxGameSystemCore.ControlledMoveNetCorrection
// 0x0010 (0x0010 - 0x0000)
struct FControlledMoveNetCorrection final
{
public:
	float                                         Runtime;                                           // 0x0000(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_4[0x4];                                        // 0x0004(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	TSubclassOf<class UControlledMove>            ControlledMove;                                    // 0x0008(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FControlledMoveNetCorrection) == 0x000008, "Wrong alignment on FControlledMoveNetCorrection");
static_assert(sizeof(FControlledMoveNetCorrection) == 0x000010, "Wrong size on FControlledMoveNetCorrection");
static_assert(offsetof(FControlledMoveNetCorrection, Runtime) == 0x000000, "Member 'FControlledMoveNetCorrection::Runtime' has a wrong offset!");
static_assert(offsetof(FControlledMoveNetCorrection, ControlledMove) == 0x000008, "Member 'FControlledMoveNetCorrection::ControlledMove' has a wrong offset!");

// ScriptStruct GbxGameSystemCore.MantleAttemptInfo
// 0x0018 (0x0018 - 0x0000)
struct FMantleAttemptInfo final
{
public:
	int32                                         ActionIndex;                                       // 0x0000(0x0004)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                Location;                                          // 0x0004(0x000C)(Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UPrimitiveComponent*                    MovementBase;                                      // 0x0010(0x0008)(ExportObject, ZeroConstructor, Transient, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FMantleAttemptInfo) == 0x000008, "Wrong alignment on FMantleAttemptInfo");
static_assert(sizeof(FMantleAttemptInfo) == 0x000018, "Wrong size on FMantleAttemptInfo");
static_assert(offsetof(FMantleAttemptInfo, ActionIndex) == 0x000000, "Member 'FMantleAttemptInfo::ActionIndex' has a wrong offset!");
static_assert(offsetof(FMantleAttemptInfo, Location) == 0x000004, "Member 'FMantleAttemptInfo::Location' has a wrong offset!");
static_assert(offsetof(FMantleAttemptInfo, MovementBase) == 0x000010, "Member 'FMantleAttemptInfo::MovementBase' has a wrong offset!");

// ScriptStruct GbxGameSystemCore.RootMotionStateData
// 0x0058 (0x0058 - 0x0000)
struct FRootMotionStateData final
{
public:
	uint8                                         Pad_0[0x48];                                       // 0x0000(0x0048)(Fixing Size After Last Property [ Dumper-7 ])
	class UGbxCharacterMovementComponent*         GbxCharMoveComp;                                   // 0x0048(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UGbxCharacterAnimInstance*              GbxAnimInstance;                                   // 0x0050(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
};
static_assert(alignof(FRootMotionStateData) == 0x000008, "Wrong alignment on FRootMotionStateData");
static_assert(sizeof(FRootMotionStateData) == 0x000058, "Wrong size on FRootMotionStateData");
static_assert(offsetof(FRootMotionStateData, GbxCharMoveComp) == 0x000048, "Member 'FRootMotionStateData::GbxCharMoveComp' has a wrong offset!");
static_assert(offsetof(FRootMotionStateData, GbxAnimInstance) == 0x000050, "Member 'FRootMotionStateData::GbxAnimInstance' has a wrong offset!");

// ScriptStruct GbxGameSystemCore.GbxInterpData
// 0x0140 (0x0140 - 0x0000)
struct FGbxInterpData final
{
public:
	uint8                                         Pad_0[0x8];                                        // 0x0000(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	class AActor*                                 Actor;                                             // 0x0008(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class AController*                            Controller;                                        // 0x0010(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UMovementComponent*                     MoveComp;                                          // 0x0018(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_20[0x120];                                     // 0x0020(0x0120)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FGbxInterpData) == 0x000008, "Wrong alignment on FGbxInterpData");
static_assert(sizeof(FGbxInterpData) == 0x000140, "Wrong size on FGbxInterpData");
static_assert(offsetof(FGbxInterpData, Actor) == 0x000008, "Member 'FGbxInterpData::Actor' has a wrong offset!");
static_assert(offsetof(FGbxInterpData, Controller) == 0x000010, "Member 'FGbxInterpData::Controller' has a wrong offset!");
static_assert(offsetof(FGbxInterpData, MoveComp) == 0x000018, "Member 'FGbxInterpData::MoveComp' has a wrong offset!");

// ScriptStruct GbxGameSystemCore.DataTableValueHandle
// 0x0018 (0x0018 - 0x0000)
struct FDataTableValueHandle final
{
public:
	class UDataTable*                             DataTable;                                         // 0x0000(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   RowName;                                           // 0x0008(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   ValueName;                                         // 0x0010(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FDataTableValueHandle) == 0x000008, "Wrong alignment on FDataTableValueHandle");
static_assert(sizeof(FDataTableValueHandle) == 0x000018, "Wrong size on FDataTableValueHandle");
static_assert(offsetof(FDataTableValueHandle, DataTable) == 0x000000, "Member 'FDataTableValueHandle::DataTable' has a wrong offset!");
static_assert(offsetof(FDataTableValueHandle, RowName) == 0x000008, "Member 'FDataTableValueHandle::RowName' has a wrong offset!");
static_assert(offsetof(FDataTableValueHandle, ValueName) == 0x000010, "Member 'FDataTableValueHandle::ValueName' has a wrong offset!");

// ScriptStruct GbxGameSystemCore.UseEvent
// 0x0018 (0x0018 - 0x0000)
struct FUseEvent final
{
public:
	class AController*                            UserController;                                    // 0x0000(0x0008)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UPrimitiveComponent*                    UsedComponent;                                     // 0x0008(0x0008)(BlueprintVisible, ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EUsabilityType                                UseType;                                           // 0x0010(0x0001)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bWasHeld;                                          // 0x0011(0x0001)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_12[0x6];                                       // 0x0012(0x0006)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FUseEvent) == 0x000008, "Wrong alignment on FUseEvent");
static_assert(sizeof(FUseEvent) == 0x000018, "Wrong size on FUseEvent");
static_assert(offsetof(FUseEvent, UserController) == 0x000000, "Member 'FUseEvent::UserController' has a wrong offset!");
static_assert(offsetof(FUseEvent, UsedComponent) == 0x000008, "Member 'FUseEvent::UsedComponent' has a wrong offset!");
static_assert(offsetof(FUseEvent, UseType) == 0x000010, "Member 'FUseEvent::UseType' has a wrong offset!");
static_assert(offsetof(FUseEvent, bWasHeld) == 0x000011, "Member 'FUseEvent::bWasHeld' has a wrong offset!");

// ScriptStruct GbxGameSystemCore.CharacterMoveToCommand
// 0x001C (0x001C - 0x0000)
struct FCharacterMoveToCommand final
{
public:
	TWeakObjectPtr<class AActor>                  TargetActor;                                       // 0x0000(0x0008)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                TargetLocation;                                    // 0x0008(0x000C)(BlueprintVisible, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         Duration;                                          // 0x0014(0x0004)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         bContinuouslyUpdate : 1;                           // 0x0018(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (BlueprintVisible, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         bEnforceMaxSpeed : 1;                              // 0x0018(0x0001)(BitIndex: 0x01, PropSize: 0x0001 (BlueprintVisible, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         bEnforceMaxSpeedOnEnding : 1;                      // 0x0018(0x0001)(BitIndex: 0x02, PropSize: 0x0001 (BlueprintVisible, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         bMoveZAxis : 1;                                    // 0x0018(0x0001)(BitIndex: 0x03, PropSize: 0x0001 (BlueprintVisible, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         Pad_19[0x3];                                       // 0x0019(0x0003)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FCharacterMoveToCommand) == 0x000004, "Wrong alignment on FCharacterMoveToCommand");
static_assert(sizeof(FCharacterMoveToCommand) == 0x00001C, "Wrong size on FCharacterMoveToCommand");
static_assert(offsetof(FCharacterMoveToCommand, TargetActor) == 0x000000, "Member 'FCharacterMoveToCommand::TargetActor' has a wrong offset!");
static_assert(offsetof(FCharacterMoveToCommand, TargetLocation) == 0x000008, "Member 'FCharacterMoveToCommand::TargetLocation' has a wrong offset!");
static_assert(offsetof(FCharacterMoveToCommand, Duration) == 0x000014, "Member 'FCharacterMoveToCommand::Duration' has a wrong offset!");

// ScriptStruct GbxGameSystemCore.AttributePropertyValueResolverTestStruct
// 0x0050 (0x0050 - 0x0000)
struct FAttributePropertyValueResolverTestStruct final
{
public:
	float                                         FloatProp;                                         // 0x0000(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         FloatPropStaticArray[0x3];                         // 0x0004(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TArray<float>                                 FloatPropDynamicArray;                             // 0x0010(0x0010)(ZeroConstructor, NativeAccessSpecifierPublic)
	class UAttributePropertyValueResolverTestContext* ObjectProp;                                        // 0x0020(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UAttributePropertyValueResolverTestContext* ObjectPropStaticArray[0x3];                        // 0x0028(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TArray<class UAttributePropertyValueResolverTestContext*> ObjectPropDynamicArray;                            // 0x0040(0x0010)(ZeroConstructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(FAttributePropertyValueResolverTestStruct) == 0x000008, "Wrong alignment on FAttributePropertyValueResolverTestStruct");
static_assert(sizeof(FAttributePropertyValueResolverTestStruct) == 0x000050, "Wrong size on FAttributePropertyValueResolverTestStruct");
static_assert(offsetof(FAttributePropertyValueResolverTestStruct, FloatProp) == 0x000000, "Member 'FAttributePropertyValueResolverTestStruct::FloatProp' has a wrong offset!");
static_assert(offsetof(FAttributePropertyValueResolverTestStruct, FloatPropStaticArray) == 0x000004, "Member 'FAttributePropertyValueResolverTestStruct::FloatPropStaticArray' has a wrong offset!");
static_assert(offsetof(FAttributePropertyValueResolverTestStruct, FloatPropDynamicArray) == 0x000010, "Member 'FAttributePropertyValueResolverTestStruct::FloatPropDynamicArray' has a wrong offset!");
static_assert(offsetof(FAttributePropertyValueResolverTestStruct, ObjectProp) == 0x000020, "Member 'FAttributePropertyValueResolverTestStruct::ObjectProp' has a wrong offset!");
static_assert(offsetof(FAttributePropertyValueResolverTestStruct, ObjectPropStaticArray) == 0x000028, "Member 'FAttributePropertyValueResolverTestStruct::ObjectPropStaticArray' has a wrong offset!");
static_assert(offsetof(FAttributePropertyValueResolverTestStruct, ObjectPropDynamicArray) == 0x000040, "Member 'FAttributePropertyValueResolverTestStruct::ObjectPropDynamicArray' has a wrong offset!");

// ScriptStruct GbxGameSystemCore.CharacterRotateToCommand
// 0x0050 (0x0050 - 0x0000)
struct FCharacterRotateToCommand final
{
public:
	class AActor*                                 TargetActor;                                       // 0x0000(0x0008)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   TargetSocket;                                      // 0x0008(0x0008)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                TargetLocation;                                    // 0x0010(0x000C)(BlueprintVisible, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1C[0x10];                                      // 0x001C(0x0010)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         Duration;                                          // 0x002C(0x0004)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bFreezeRotation;                                   // 0x0030(0x0001)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_31[0x3];                                       // 0x0031(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         InterpSpeed;                                       // 0x0034(0x0004)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         MaxYawRate;                                        // 0x0038(0x0004)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         MaxPitchRate;                                      // 0x003C(0x0004)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bUseEasing;                                        // 0x0040(0x0001)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_41[0x3];                                       // 0x0041(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	struct FGbxEasingFunc                         Easing;                                            // 0x0044(0x000C)(BlueprintVisible, NoDestructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(FCharacterRotateToCommand) == 0x000008, "Wrong alignment on FCharacterRotateToCommand");
static_assert(sizeof(FCharacterRotateToCommand) == 0x000050, "Wrong size on FCharacterRotateToCommand");
static_assert(offsetof(FCharacterRotateToCommand, TargetActor) == 0x000000, "Member 'FCharacterRotateToCommand::TargetActor' has a wrong offset!");
static_assert(offsetof(FCharacterRotateToCommand, TargetSocket) == 0x000008, "Member 'FCharacterRotateToCommand::TargetSocket' has a wrong offset!");
static_assert(offsetof(FCharacterRotateToCommand, TargetLocation) == 0x000010, "Member 'FCharacterRotateToCommand::TargetLocation' has a wrong offset!");
static_assert(offsetof(FCharacterRotateToCommand, Duration) == 0x00002C, "Member 'FCharacterRotateToCommand::Duration' has a wrong offset!");
static_assert(offsetof(FCharacterRotateToCommand, bFreezeRotation) == 0x000030, "Member 'FCharacterRotateToCommand::bFreezeRotation' has a wrong offset!");
static_assert(offsetof(FCharacterRotateToCommand, InterpSpeed) == 0x000034, "Member 'FCharacterRotateToCommand::InterpSpeed' has a wrong offset!");
static_assert(offsetof(FCharacterRotateToCommand, MaxYawRate) == 0x000038, "Member 'FCharacterRotateToCommand::MaxYawRate' has a wrong offset!");
static_assert(offsetof(FCharacterRotateToCommand, MaxPitchRate) == 0x00003C, "Member 'FCharacterRotateToCommand::MaxPitchRate' has a wrong offset!");
static_assert(offsetof(FCharacterRotateToCommand, bUseEasing) == 0x000040, "Member 'FCharacterRotateToCommand::bUseEasing' has a wrong offset!");
static_assert(offsetof(FCharacterRotateToCommand, Easing) == 0x000044, "Member 'FCharacterRotateToCommand::Easing' has a wrong offset!");

// ScriptStruct GbxGameSystemCore.IdleVelocityData
// 0x0018 (0x0018 - 0x0000)
struct alignas(0x04) FIdleVelocityData final
{
public:
	uint8                                         Pad_0[0x18];                                       // 0x0000(0x0018)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FIdleVelocityData) == 0x000004, "Wrong alignment on FIdleVelocityData");
static_assert(sizeof(FIdleVelocityData) == 0x000018, "Wrong size on FIdleVelocityData");

// ScriptStruct GbxGameSystemCore.GbxAttributeDelegateBindingHandle
// 0x0030 (0x0030 - 0x0000)
struct alignas(0x08) FGbxAttributeDelegateBindingHandle final
{
public:
	uint8                                         Pad_0[0x30];                                       // 0x0000(0x0030)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FGbxAttributeDelegateBindingHandle) == 0x000008, "Wrong alignment on FGbxAttributeDelegateBindingHandle");
static_assert(sizeof(FGbxAttributeDelegateBindingHandle) == 0x000030, "Wrong size on FGbxAttributeDelegateBindingHandle");

// ScriptStruct GbxGameSystemCore.RotationDeltaMatchingInfo
// 0x00C0 (0x00C0 - 0x0000)
struct FRotationDeltaMatchingInfo final
{
public:
	struct FFloatCurve                            RotationTimeCurve;                                 // 0x0000(0x0090)(Transient, NativeAccessSpecifierPublic)
	uint8                                         Pad_90[0x30];                                      // 0x0090(0x0030)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FRotationDeltaMatchingInfo) == 0x000008, "Wrong alignment on FRotationDeltaMatchingInfo");
static_assert(sizeof(FRotationDeltaMatchingInfo) == 0x0000C0, "Wrong size on FRotationDeltaMatchingInfo");
static_assert(offsetof(FRotationDeltaMatchingInfo, RotationTimeCurve) == 0x000000, "Member 'FRotationDeltaMatchingInfo::RotationTimeCurve' has a wrong offset!");

// ScriptStruct GbxGameSystemCore.NavAnimClientData
// 0x001C (0x001C - 0x0000)
struct FNavAnimClientData final
{
public:
	struct FVector_NetQuantizeNormal              Direction;                                         // 0x0000(0x000C)(NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector_NetQuantize                    GoalLoc;                                           // 0x000C(0x000C)(NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         GoalRadius;                                        // 0x0018(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FNavAnimClientData) == 0x000004, "Wrong alignment on FNavAnimClientData");
static_assert(sizeof(FNavAnimClientData) == 0x00001C, "Wrong size on FNavAnimClientData");
static_assert(offsetof(FNavAnimClientData, Direction) == 0x000000, "Member 'FNavAnimClientData::Direction' has a wrong offset!");
static_assert(offsetof(FNavAnimClientData, GoalLoc) == 0x00000C, "Member 'FNavAnimClientData::GoalLoc' has a wrong offset!");
static_assert(offsetof(FNavAnimClientData, GoalRadius) == 0x000018, "Member 'FNavAnimClientData::GoalRadius' has a wrong offset!");

// ScriptStruct GbxGameSystemCore.ArticulatedRigidBodyState
// 0x0010 (0x0050 - 0x0040)
struct FArticulatedRigidBodyState final : public FRigidBodyState
{
public:
	class FName                                   BodyName;                                          // 0x0040(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_48[0x8];                                       // 0x0048(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FArticulatedRigidBodyState) == 0x000010, "Wrong alignment on FArticulatedRigidBodyState");
static_assert(sizeof(FArticulatedRigidBodyState) == 0x000050, "Wrong size on FArticulatedRigidBodyState");
static_assert(offsetof(FArticulatedRigidBodyState, BodyName) == 0x000040, "Member 'FArticulatedRigidBodyState::BodyName' has a wrong offset!");

// ScriptStruct GbxGameSystemCore.GbxBlueprintlegateBinding
// 0x0118 (0x0118 - 0x0000)
struct FGbxBlueprintlegateBinding final
{
public:
	class FString                                 SubobjectPath;                                     // 0x0000(0x0010)(ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FParsedProperty                        ParsedDelegateOwnerPath;                           // 0x0010(0x0080)(NoDestructor, NativeAccessSpecifierPublic)
	struct FParsedProperty                        ParsedDelegatePath;                                // 0x0090(0x0080)(NoDestructor, NativeAccessSpecifierPublic)
	class FName                                   FunctionNameToBind;                                // 0x0110(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FGbxBlueprintlegateBinding) == 0x000008, "Wrong alignment on FGbxBlueprintlegateBinding");
static_assert(sizeof(FGbxBlueprintlegateBinding) == 0x000118, "Wrong size on FGbxBlueprintlegateBinding");
static_assert(offsetof(FGbxBlueprintlegateBinding, SubobjectPath) == 0x000000, "Member 'FGbxBlueprintlegateBinding::SubobjectPath' has a wrong offset!");
static_assert(offsetof(FGbxBlueprintlegateBinding, ParsedDelegateOwnerPath) == 0x000010, "Member 'FGbxBlueprintlegateBinding::ParsedDelegateOwnerPath' has a wrong offset!");
static_assert(offsetof(FGbxBlueprintlegateBinding, ParsedDelegatePath) == 0x000090, "Member 'FGbxBlueprintlegateBinding::ParsedDelegatePath' has a wrong offset!");
static_assert(offsetof(FGbxBlueprintlegateBinding, FunctionNameToBind) == 0x000110, "Member 'FGbxBlueprintlegateBinding::FunctionNameToBind' has a wrong offset!");

// ScriptStruct GbxGameSystemCore.NavAnimServerData
// 0x00A0 (0x00A0 - 0x0000)
struct FNavAnimServerData final
{
public:
	uint8                                         Pad_0[0x90];                                       // 0x0000(0x0090)(Fixing Size After Last Property [ Dumper-7 ])
	class UObject*                                Areas;                                             // 0x0090(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UObject*                                UserEdges;                                         // 0x0098(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FNavAnimServerData) == 0x000008, "Wrong alignment on FNavAnimServerData");
static_assert(sizeof(FNavAnimServerData) == 0x0000A0, "Wrong size on FNavAnimServerData");
static_assert(offsetof(FNavAnimServerData, Areas) == 0x000090, "Member 'FNavAnimServerData::Areas' has a wrong offset!");
static_assert(offsetof(FNavAnimServerData, UserEdges) == 0x000098, "Member 'FNavAnimServerData::UserEdges' has a wrong offset!");

// ScriptStruct GbxGameSystemCore.CustomizationLinkedParameter
// 0x0010 (0x0010 - 0x0000)
struct alignas(0x08) FCustomizationLinkedParameter final
{
public:
	class FName                                   LinkedParameterName;                               // 0x0000(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	ELinkedParameterType                          LinkedParameterType;                               // 0x0008(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_9[0x7];                                        // 0x0009(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FCustomizationLinkedParameter) == 0x000008, "Wrong alignment on FCustomizationLinkedParameter");
static_assert(sizeof(FCustomizationLinkedParameter) == 0x000010, "Wrong size on FCustomizationLinkedParameter");
static_assert(offsetof(FCustomizationLinkedParameter, LinkedParameterName) == 0x000000, "Member 'FCustomizationLinkedParameter::LinkedParameterName' has a wrong offset!");
static_assert(offsetof(FCustomizationLinkedParameter, LinkedParameterType) == 0x000008, "Member 'FCustomizationLinkedParameter::LinkedParameterType' has a wrong offset!");

// ScriptStruct GbxGameSystemCore.NavAnimMachineData
// 0x0008 (0x0008 - 0x0000)
struct FNavAnimMachineData final
{
public:
	int32                                         MachineIdx;                                        // 0x0000(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	ENavAnimState                                 ServerBaseState;                                   // 0x0004(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	ENavAnimState                                 CurrState;                                         // 0x0005(0x0001)(ZeroConstructor, IsPlainOldData, RepSkip, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_6[0x2];                                        // 0x0006(0x0002)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FNavAnimMachineData) == 0x000004, "Wrong alignment on FNavAnimMachineData");
static_assert(sizeof(FNavAnimMachineData) == 0x000008, "Wrong size on FNavAnimMachineData");
static_assert(offsetof(FNavAnimMachineData, MachineIdx) == 0x000000, "Member 'FNavAnimMachineData::MachineIdx' has a wrong offset!");
static_assert(offsetof(FNavAnimMachineData, ServerBaseState) == 0x000004, "Member 'FNavAnimMachineData::ServerBaseState' has a wrong offset!");
static_assert(offsetof(FNavAnimMachineData, CurrState) == 0x000005, "Member 'FNavAnimMachineData::CurrState' has a wrong offset!");

// ScriptStruct GbxGameSystemCore.NavAnimDesiredInfo
// 0x0010 (0x0010 - 0x0000)
struct FNavAnimDesiredInfo final
{
public:
	float                                         Yaw;                                               // 0x0000(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector_NetQuantize                    FaceLoc;                                           // 0x0004(0x000C)(NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FNavAnimDesiredInfo) == 0x000004, "Wrong alignment on FNavAnimDesiredInfo");
static_assert(sizeof(FNavAnimDesiredInfo) == 0x000010, "Wrong size on FNavAnimDesiredInfo");
static_assert(offsetof(FNavAnimDesiredInfo, Yaw) == 0x000000, "Member 'FNavAnimDesiredInfo::Yaw' has a wrong offset!");
static_assert(offsetof(FNavAnimDesiredInfo, FaceLoc) == 0x000004, "Member 'FNavAnimDesiredInfo::FaceLoc' has a wrong offset!");

// ScriptStruct GbxGameSystemCore.NavAnimTransition
// 0x0028 (0x0028 - 0x0000)
struct alignas(0x08) FNavAnimTransition final
{
public:
	ENavAnimState                                 State;                                             // 0x0000(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1[0x3];                                        // 0x0001(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	struct FNavAnimDesiredInfo                    Info;                                              // 0x0004(0x0010)(NoDestructor, NativeAccessSpecifierPublic)
	uint8                                         Pad_14[0x4];                                       // 0x0014(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class FName                                   RowName;                                           // 0x0018(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         MachineIdx;                                        // 0x0020(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         RunIdx;                                            // 0x0024(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FNavAnimTransition) == 0x000008, "Wrong alignment on FNavAnimTransition");
static_assert(sizeof(FNavAnimTransition) == 0x000028, "Wrong size on FNavAnimTransition");
static_assert(offsetof(FNavAnimTransition, State) == 0x000000, "Member 'FNavAnimTransition::State' has a wrong offset!");
static_assert(offsetof(FNavAnimTransition, Info) == 0x000004, "Member 'FNavAnimTransition::Info' has a wrong offset!");
static_assert(offsetof(FNavAnimTransition, RowName) == 0x000018, "Member 'FNavAnimTransition::RowName' has a wrong offset!");
static_assert(offsetof(FNavAnimTransition, MachineIdx) == 0x000020, "Member 'FNavAnimTransition::MachineIdx' has a wrong offset!");
static_assert(offsetof(FNavAnimTransition, RunIdx) == 0x000024, "Member 'FNavAnimTransition::RunIdx' has a wrong offset!");

// ScriptStruct GbxGameSystemCore.NavAnimState
// 0x0050 (0x0050 - 0x0000)
struct FNavAnimState final
{
public:
	uint8                                         Pad_0[0x8];                                        // 0x0000(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	class UAnimInstance*                          CachedAnimInst;                                    // 0x0008(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	TArray<struct FNavAnimMachineData>            MachineList;                                       // 0x0010(0x0010)(ZeroConstructor, NativeAccessSpecifierPrivate)
	struct FNavAnimTransition                     ServerTransition;                                  // 0x0020(0x0028)(NoDestructor, NativeAccessSpecifierPrivate)
	int32                                         ClientTransitionIdx;                               // 0x0048(0x0004)(ZeroConstructor, IsPlainOldData, RepSkip, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_4C[0x4];                                       // 0x004C(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FNavAnimState) == 0x000008, "Wrong alignment on FNavAnimState");
static_assert(sizeof(FNavAnimState) == 0x000050, "Wrong size on FNavAnimState");
static_assert(offsetof(FNavAnimState, CachedAnimInst) == 0x000008, "Member 'FNavAnimState::CachedAnimInst' has a wrong offset!");
static_assert(offsetof(FNavAnimState, MachineList) == 0x000010, "Member 'FNavAnimState::MachineList' has a wrong offset!");
static_assert(offsetof(FNavAnimState, ServerTransition) == 0x000020, "Member 'FNavAnimState::ServerTransition' has a wrong offset!");
static_assert(offsetof(FNavAnimState, ClientTransitionIdx) == 0x000048, "Member 'FNavAnimState::ClientTransitionIdx' has a wrong offset!");

// ScriptStruct GbxGameSystemCore.GbxRefPoseBoneConstraint
// 0x0020 (0x0020 - 0x0000)
struct FGbxRefPoseBoneConstraint final
{
public:
	struct FBoneReference                         Bone;                                              // 0x0000(0x0018)(Edit, NoDestructor, NativeAccessSpecifierPublic)
	float                                         Weight;                                            // 0x0018(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1C[0x4];                                       // 0x001C(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FGbxRefPoseBoneConstraint) == 0x000008, "Wrong alignment on FGbxRefPoseBoneConstraint");
static_assert(sizeof(FGbxRefPoseBoneConstraint) == 0x000020, "Wrong size on FGbxRefPoseBoneConstraint");
static_assert(offsetof(FGbxRefPoseBoneConstraint, Bone) == 0x000000, "Member 'FGbxRefPoseBoneConstraint::Bone' has a wrong offset!");
static_assert(offsetof(FGbxRefPoseBoneConstraint, Weight) == 0x000018, "Member 'FGbxRefPoseBoneConstraint::Weight' has a wrong offset!");

// ScriptStruct GbxGameSystemCore.GbxAnimNode_RefPoseConstraints
// 0x0020 (0x0160 - 0x0140)
struct FGbxAnimNode_RefPoseConstraints final : public FAnimNode_SkeletalControlBase
{
public:
	TArray<struct FGbxRefPoseBoneConstraint>      Constraints;                                       // 0x0140(0x0010)(Edit, ZeroConstructor, NativeAccessSpecifierPublic)
	uint8                                         Pad_150[0x10];                                     // 0x0150(0x0010)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FGbxAnimNode_RefPoseConstraints) == 0x000008, "Wrong alignment on FGbxAnimNode_RefPoseConstraints");
static_assert(sizeof(FGbxAnimNode_RefPoseConstraints) == 0x000160, "Wrong size on FGbxAnimNode_RefPoseConstraints");
static_assert(offsetof(FGbxAnimNode_RefPoseConstraints, Constraints) == 0x000140, "Member 'FGbxAnimNode_RefPoseConstraints::Constraints' has a wrong offset!");

// ScriptStruct GbxGameSystemCore.UsabilityInfo
// 0x0040 (0x0040 - 0x0000)
struct FUsabilityInfo final
{
public:
	bool                                          bCanUse;                                           // 0x0000(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bCanInteractWith;                                  // 0x0001(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bCanPrimaryUse;                                    // 0x0002(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bCanPrimaryHoldUse;                                // 0x0003(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bCanSecondaryUse;                                  // 0x0004(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bCanSecondaryHoldUse;                              // 0x0005(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bCanShowUseDef;                                    // 0x0006(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_7[0x1];                                        // 0x0007(0x0001)(Fixing Size After Last Property [ Dumper-7 ])
	class FText                                   OptionalErrorText;                                 // 0x0008(0x0018)(Edit, NativeAccessSpecifierPublic)
	class UUsableTypeDefinition*                  PrimaryUseDef;                                     // 0x0020(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UUsableTypeDefinition*                  PrimaryHoldUseDef;                                 // 0x0028(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UUsableTypeDefinition*                  SecondaryUseDef;                                   // 0x0030(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UUsableTypeDefinition*                  SecondaryHoldUseDef;                               // 0x0038(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FUsabilityInfo) == 0x000008, "Wrong alignment on FUsabilityInfo");
static_assert(sizeof(FUsabilityInfo) == 0x000040, "Wrong size on FUsabilityInfo");
static_assert(offsetof(FUsabilityInfo, bCanUse) == 0x000000, "Member 'FUsabilityInfo::bCanUse' has a wrong offset!");
static_assert(offsetof(FUsabilityInfo, bCanInteractWith) == 0x000001, "Member 'FUsabilityInfo::bCanInteractWith' has a wrong offset!");
static_assert(offsetof(FUsabilityInfo, bCanPrimaryUse) == 0x000002, "Member 'FUsabilityInfo::bCanPrimaryUse' has a wrong offset!");
static_assert(offsetof(FUsabilityInfo, bCanPrimaryHoldUse) == 0x000003, "Member 'FUsabilityInfo::bCanPrimaryHoldUse' has a wrong offset!");
static_assert(offsetof(FUsabilityInfo, bCanSecondaryUse) == 0x000004, "Member 'FUsabilityInfo::bCanSecondaryUse' has a wrong offset!");
static_assert(offsetof(FUsabilityInfo, bCanSecondaryHoldUse) == 0x000005, "Member 'FUsabilityInfo::bCanSecondaryHoldUse' has a wrong offset!");
static_assert(offsetof(FUsabilityInfo, bCanShowUseDef) == 0x000006, "Member 'FUsabilityInfo::bCanShowUseDef' has a wrong offset!");
static_assert(offsetof(FUsabilityInfo, OptionalErrorText) == 0x000008, "Member 'FUsabilityInfo::OptionalErrorText' has a wrong offset!");
static_assert(offsetof(FUsabilityInfo, PrimaryUseDef) == 0x000020, "Member 'FUsabilityInfo::PrimaryUseDef' has a wrong offset!");
static_assert(offsetof(FUsabilityInfo, PrimaryHoldUseDef) == 0x000028, "Member 'FUsabilityInfo::PrimaryHoldUseDef' has a wrong offset!");
static_assert(offsetof(FUsabilityInfo, SecondaryUseDef) == 0x000030, "Member 'FUsabilityInfo::SecondaryUseDef' has a wrong offset!");
static_assert(offsetof(FUsabilityInfo, SecondaryHoldUseDef) == 0x000038, "Member 'FUsabilityInfo::SecondaryHoldUseDef' has a wrong offset!");

// ScriptStruct GbxGameSystemCore.AttributeInitializationData
// 0x0038 (0x0038 - 0x0000)
struct FAttributeInitializationData final
{
public:
	float                                         BaseValueConstant;                                 // 0x0000(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_4[0x4];                                        // 0x0004(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	struct FDataTableValueHandle                  DataTableValue;                                    // 0x0008(0x0018)(Edit, BlueprintVisible, NoDestructor, NativeAccessSpecifierPublic)
	class UGbxAttributeData*                      BaseValueAttribute;                                // 0x0020(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TSubclassOf<class UAttributeInitializer>      AttributeInitializer;                              // 0x0028(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         BaseValueScale;                                    // 0x0030(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_34[0x4];                                       // 0x0034(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FAttributeInitializationData) == 0x000008, "Wrong alignment on FAttributeInitializationData");
static_assert(sizeof(FAttributeInitializationData) == 0x000038, "Wrong size on FAttributeInitializationData");
static_assert(offsetof(FAttributeInitializationData, BaseValueConstant) == 0x000000, "Member 'FAttributeInitializationData::BaseValueConstant' has a wrong offset!");
static_assert(offsetof(FAttributeInitializationData, DataTableValue) == 0x000008, "Member 'FAttributeInitializationData::DataTableValue' has a wrong offset!");
static_assert(offsetof(FAttributeInitializationData, BaseValueAttribute) == 0x000020, "Member 'FAttributeInitializationData::BaseValueAttribute' has a wrong offset!");
static_assert(offsetof(FAttributeInitializationData, AttributeInitializer) == 0x000028, "Member 'FAttributeInitializationData::AttributeInitializer' has a wrong offset!");
static_assert(offsetof(FAttributeInitializationData, BaseValueScale) == 0x000030, "Member 'FAttributeInitializationData::BaseValueScale' has a wrong offset!");

// ScriptStruct GbxGameSystemCore.CharacterScriptedMeshOffsetCommand
// 0x0138 (0x0138 - 0x0000)
struct FCharacterScriptedMeshOffsetCommand final
{
public:
	uint8                                         Pad_0[0x10];                                       // 0x0000(0x0010)(Fixing Size After Last Property [ Dumper-7 ])
	class UAnimSequence*                          RootMotionSourceAnim;                              // 0x0010(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FRuntimeFloatCurve                     HorzCurv;                                          // 0x0018(0x0078)(NativeAccessSpecifierPublic)
	struct FRuntimeFloatCurve                     VertCurv;                                          // 0x0090(0x0078)(NativeAccessSpecifierPublic)
	uint8                                         Pad_108[0x30];                                     // 0x0108(0x0030)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FCharacterScriptedMeshOffsetCommand) == 0x000008, "Wrong alignment on FCharacterScriptedMeshOffsetCommand");
static_assert(sizeof(FCharacterScriptedMeshOffsetCommand) == 0x000138, "Wrong size on FCharacterScriptedMeshOffsetCommand");
static_assert(offsetof(FCharacterScriptedMeshOffsetCommand, RootMotionSourceAnim) == 0x000010, "Member 'FCharacterScriptedMeshOffsetCommand::RootMotionSourceAnim' has a wrong offset!");
static_assert(offsetof(FCharacterScriptedMeshOffsetCommand, HorzCurv) == 0x000018, "Member 'FCharacterScriptedMeshOffsetCommand::HorzCurv' has a wrong offset!");
static_assert(offsetof(FCharacterScriptedMeshOffsetCommand, VertCurv) == 0x000090, "Member 'FCharacterScriptedMeshOffsetCommand::VertCurv' has a wrong offset!");

// ScriptStruct GbxGameSystemCore.CharacterScriptedMeshOffsetState
// 0x0140 (0x0140 - 0x0000)
struct FCharacterScriptedMeshOffsetState final
{
public:
	uint8                                         Pad_0[0x8];                                        // 0x0000(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	struct FCharacterScriptedMeshOffsetCommand    Cmd;                                               // 0x0008(0x0138)(NativeAccessSpecifierPublic)
};
static_assert(alignof(FCharacterScriptedMeshOffsetState) == 0x000008, "Wrong alignment on FCharacterScriptedMeshOffsetState");
static_assert(sizeof(FCharacterScriptedMeshOffsetState) == 0x000140, "Wrong size on FCharacterScriptedMeshOffsetState");
static_assert(offsetof(FCharacterScriptedMeshOffsetState, Cmd) == 0x000008, "Member 'FCharacterScriptedMeshOffsetState::Cmd' has a wrong offset!");

// ScriptStruct GbxGameSystemCore.GbxBlackboardKeySelector
// 0x0010 (0x0010 - 0x0000)
struct alignas(0x08) FGbxBlackboardKeySelector final
{
public:
	class FName                                   KeyName;                                           // 0x0000(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bRuntimeKey;                                       // 0x0008(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_9[0x7];                                        // 0x0009(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FGbxBlackboardKeySelector) == 0x000008, "Wrong alignment on FGbxBlackboardKeySelector");
static_assert(sizeof(FGbxBlackboardKeySelector) == 0x000010, "Wrong size on FGbxBlackboardKeySelector");
static_assert(offsetof(FGbxBlackboardKeySelector, KeyName) == 0x000000, "Member 'FGbxBlackboardKeySelector::KeyName' has a wrong offset!");
static_assert(offsetof(FGbxBlackboardKeySelector, bRuntimeKey) == 0x000008, "Member 'FGbxBlackboardKeySelector::bRuntimeKey' has a wrong offset!");

// ScriptStruct GbxGameSystemCore.StretchBonesSettings
// 0x0030 (0x0030 - 0x0000)
struct FStretchBonesSettings final
{
public:
	bool                                          bUniformStretch;                                   // 0x0000(0x0001)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1[0x7];                                        // 0x0001(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	struct FGbxBlackboardKeySelector              TargetKey;                                         // 0x0008(0x0010)(Edit, DisableEditOnInstance, NoDestructor, NativeAccessSpecifierPublic)
	struct FVector                                TargetOffset;                                      // 0x0018(0x000C)(Edit, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EStretchBonesActorTrackingStyle               ActorTrackingStyle;                                // 0x0024(0x0001)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bTraceToGround;                                    // 0x0025(0x0001)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_26[0x2];                                       // 0x0026(0x0002)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         TraceToGroundDistance;                             // 0x0028(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         MaxPredictionDistance;                             // 0x002C(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FStretchBonesSettings) == 0x000008, "Wrong alignment on FStretchBonesSettings");
static_assert(sizeof(FStretchBonesSettings) == 0x000030, "Wrong size on FStretchBonesSettings");
static_assert(offsetof(FStretchBonesSettings, bUniformStretch) == 0x000000, "Member 'FStretchBonesSettings::bUniformStretch' has a wrong offset!");
static_assert(offsetof(FStretchBonesSettings, TargetKey) == 0x000008, "Member 'FStretchBonesSettings::TargetKey' has a wrong offset!");
static_assert(offsetof(FStretchBonesSettings, TargetOffset) == 0x000018, "Member 'FStretchBonesSettings::TargetOffset' has a wrong offset!");
static_assert(offsetof(FStretchBonesSettings, ActorTrackingStyle) == 0x000024, "Member 'FStretchBonesSettings::ActorTrackingStyle' has a wrong offset!");
static_assert(offsetof(FStretchBonesSettings, bTraceToGround) == 0x000025, "Member 'FStretchBonesSettings::bTraceToGround' has a wrong offset!");
static_assert(offsetof(FStretchBonesSettings, TraceToGroundDistance) == 0x000028, "Member 'FStretchBonesSettings::TraceToGroundDistance' has a wrong offset!");
static_assert(offsetof(FStretchBonesSettings, MaxPredictionDistance) == 0x00002C, "Member 'FStretchBonesSettings::MaxPredictionDistance' has a wrong offset!");

// ScriptStruct GbxGameSystemCore.PhysicalAnimationBoneData
// 0x0020 (0x0020 - 0x0000)
struct alignas(0x08) FPhysicalAnimationBoneData final
{
public:
	class FName                                   BodyName;                                          // 0x0000(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bIncludeChildren;                                  // 0x0008(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         bIsLocalSimulation : 1;                            // 0x0009(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (Edit, BlueprintVisible, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         Pad_A[0x2];                                        // 0x000A(0x0002)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         OrientationStrength;                               // 0x000C(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         AngularVelocityStrength;                           // 0x0010(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         PositionStrength;                                  // 0x0014(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         VelocityStrength;                                  // 0x0018(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1C[0x4];                                       // 0x001C(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FPhysicalAnimationBoneData) == 0x000008, "Wrong alignment on FPhysicalAnimationBoneData");
static_assert(sizeof(FPhysicalAnimationBoneData) == 0x000020, "Wrong size on FPhysicalAnimationBoneData");
static_assert(offsetof(FPhysicalAnimationBoneData, BodyName) == 0x000000, "Member 'FPhysicalAnimationBoneData::BodyName' has a wrong offset!");
static_assert(offsetof(FPhysicalAnimationBoneData, bIncludeChildren) == 0x000008, "Member 'FPhysicalAnimationBoneData::bIncludeChildren' has a wrong offset!");
static_assert(offsetof(FPhysicalAnimationBoneData, OrientationStrength) == 0x00000C, "Member 'FPhysicalAnimationBoneData::OrientationStrength' has a wrong offset!");
static_assert(offsetof(FPhysicalAnimationBoneData, AngularVelocityStrength) == 0x000010, "Member 'FPhysicalAnimationBoneData::AngularVelocityStrength' has a wrong offset!");
static_assert(offsetof(FPhysicalAnimationBoneData, PositionStrength) == 0x000014, "Member 'FPhysicalAnimationBoneData::PositionStrength' has a wrong offset!");
static_assert(offsetof(FPhysicalAnimationBoneData, VelocityStrength) == 0x000018, "Member 'FPhysicalAnimationBoneData::VelocityStrength' has a wrong offset!");

// ScriptStruct GbxGameSystemCore.AimControlParameters
// 0x0078 (0x0078 - 0x0000)
struct FAimControlParameters final
{
public:
	class UAimControlData*                        AimControlData;                                    // 0x0000(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_8[0x70];                                       // 0x0008(0x0070)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FAimControlParameters) == 0x000008, "Wrong alignment on FAimControlParameters");
static_assert(sizeof(FAimControlParameters) == 0x000078, "Wrong size on FAimControlParameters");
static_assert(offsetof(FAimControlParameters, AimControlData) == 0x000000, "Member 'FAimControlParameters::AimControlData' has a wrong offset!");

// ScriptStruct GbxGameSystemCore.GbxCharacterNavWalking
// 0x00B0 (0x00B0 - 0x0000)
struct FGbxCharacterNavWalking final
{
public:
	class UGbxCharacterMovementComponent*         MoveComp;                                          // 0x0000(0x0008)(ExportObject, ZeroConstructor, Transient, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_8[0xA8];                                       // 0x0008(0x00A8)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FGbxCharacterNavWalking) == 0x000008, "Wrong alignment on FGbxCharacterNavWalking");
static_assert(sizeof(FGbxCharacterNavWalking) == 0x0000B0, "Wrong size on FGbxCharacterNavWalking");
static_assert(offsetof(FGbxCharacterNavWalking, MoveComp) == 0x000000, "Member 'FGbxCharacterNavWalking::MoveComp' has a wrong offset!");

// ScriptStruct GbxGameSystemCore.UsableAngleRestriction
// 0x0008 (0x0008 - 0x0000)
struct FUsableAngleRestriction final
{
public:
	float                                         AngleOffset;                                       // 0x0000(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         AngleWidth;                                        // 0x0004(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FUsableAngleRestriction) == 0x000004, "Wrong alignment on FUsableAngleRestriction");
static_assert(sizeof(FUsableAngleRestriction) == 0x000008, "Wrong size on FUsableAngleRestriction");
static_assert(offsetof(FUsableAngleRestriction, AngleOffset) == 0x000000, "Member 'FUsableAngleRestriction::AngleOffset' has a wrong offset!");
static_assert(offsetof(FUsableAngleRestriction, AngleWidth) == 0x000004, "Member 'FUsableAngleRestriction::AngleWidth' has a wrong offset!");

// ScriptStruct GbxGameSystemCore.SimpleMotionState
// 0x0020 (0x0020 - 0x0000)
struct FSimpleMotionState final
{
public:
	ESimpleMotionType                             MotionType;                                        // 0x0000(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1[0x3];                                        // 0x0001(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         MinSpeed;                                          // 0x0004(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         MaxSpeed;                                          // 0x0008(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_C[0x4];                                        // 0x000C(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class UCurveFloat*                            SpeedControlCurve;                                 // 0x0010(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         Acceleration;                                      // 0x0018(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         bScaleTransformByValue : 1;                        // 0x001C(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (Edit, BlueprintVisible, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         bScaleSpeedByValue : 1;                            // 0x001C(0x0001)(BitIndex: 0x01, PropSize: 0x0001 (Edit, BlueprintVisible, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         bScaleAccelerationByValue : 1;                     // 0x001C(0x0001)(BitIndex: 0x02, PropSize: 0x0001 (Edit, BlueprintVisible, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         Pad_1D[0x3];                                       // 0x001D(0x0003)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FSimpleMotionState) == 0x000008, "Wrong alignment on FSimpleMotionState");
static_assert(sizeof(FSimpleMotionState) == 0x000020, "Wrong size on FSimpleMotionState");
static_assert(offsetof(FSimpleMotionState, MotionType) == 0x000000, "Member 'FSimpleMotionState::MotionType' has a wrong offset!");
static_assert(offsetof(FSimpleMotionState, MinSpeed) == 0x000004, "Member 'FSimpleMotionState::MinSpeed' has a wrong offset!");
static_assert(offsetof(FSimpleMotionState, MaxSpeed) == 0x000008, "Member 'FSimpleMotionState::MaxSpeed' has a wrong offset!");
static_assert(offsetof(FSimpleMotionState, SpeedControlCurve) == 0x000010, "Member 'FSimpleMotionState::SpeedControlCurve' has a wrong offset!");
static_assert(offsetof(FSimpleMotionState, Acceleration) == 0x000018, "Member 'FSimpleMotionState::Acceleration' has a wrong offset!");

// ScriptStruct GbxGameSystemCore.ReplicatedMantleState
// 0x0008 (0x0008 - 0x0000)
struct FReplicatedMantleState final
{
public:
	uint8                                         Counter;                                           // 0x0000(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1[0x3];                                        // 0x0001(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	int32                                         ActionIndex;                                       // 0x0004(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FReplicatedMantleState) == 0x000004, "Wrong alignment on FReplicatedMantleState");
static_assert(sizeof(FReplicatedMantleState) == 0x000008, "Wrong size on FReplicatedMantleState");
static_assert(offsetof(FReplicatedMantleState, Counter) == 0x000000, "Member 'FReplicatedMantleState::Counter' has a wrong offset!");
static_assert(offsetof(FReplicatedMantleState, ActionIndex) == 0x000004, "Member 'FReplicatedMantleState::ActionIndex' has a wrong offset!");

// ScriptStruct GbxGameSystemCore.RangedDistanceOverrides
// 0x000C (0x000C - 0x0000)
struct FRangedDistanceOverrides final
{
public:
	bool                                          bOverrideRangedDistances;                          // 0x0000(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1[0x3];                                        // 0x0001(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         MinDistanceOverride;                               // 0x0004(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         MaxDistanceOverride;                               // 0x0008(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FRangedDistanceOverrides) == 0x000004, "Wrong alignment on FRangedDistanceOverrides");
static_assert(sizeof(FRangedDistanceOverrides) == 0x00000C, "Wrong size on FRangedDistanceOverrides");
static_assert(offsetof(FRangedDistanceOverrides, bOverrideRangedDistances) == 0x000000, "Member 'FRangedDistanceOverrides::bOverrideRangedDistances' has a wrong offset!");
static_assert(offsetof(FRangedDistanceOverrides, MinDistanceOverride) == 0x000004, "Member 'FRangedDistanceOverrides::MinDistanceOverride' has a wrong offset!");
static_assert(offsetof(FRangedDistanceOverrides, MaxDistanceOverride) == 0x000008, "Member 'FRangedDistanceOverrides::MaxDistanceOverride' has a wrong offset!");

// ScriptStruct GbxGameSystemCore.MantleActiveActionData
// 0x0020 (0x0020 - 0x0000)
struct FMantleActiveActionData final
{
public:
	struct FMantleAttemptInfo                     MantleAttempt;                                     // 0x0000(0x0018)(Transient, NoDestructor, ContainsInstancedReference, NativeAccessSpecifierPublic)
	uint8                                         Pad_18[0x8];                                       // 0x0018(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FMantleActiveActionData) == 0x000008, "Wrong alignment on FMantleActiveActionData");
static_assert(sizeof(FMantleActiveActionData) == 0x000020, "Wrong size on FMantleActiveActionData");
static_assert(offsetof(FMantleActiveActionData, MantleAttempt) == 0x000000, "Member 'FMantleActiveActionData::MantleAttempt' has a wrong offset!");

// ScriptStruct GbxGameSystemCore.MantleTraceInputs
// 0x0068 (0x0068 - 0x0000)
struct FMantleTraceInputs final
{
public:
	uint8                                         Pad_0[0x48];                                       // 0x0000(0x0048)(Fixing Size After Last Property [ Dumper-7 ])
	class UWorld*                                 World;                                             // 0x0048(0x0008)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UMantleData*                            MantleData;                                        // 0x0050(0x0008)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UGbxGameplayGlobals*                    Globals;                                           // 0x0058(0x0008)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class AActor*                                 SourceActor;                                       // 0x0060(0x0008)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FMantleTraceInputs) == 0x000008, "Wrong alignment on FMantleTraceInputs");
static_assert(sizeof(FMantleTraceInputs) == 0x000068, "Wrong size on FMantleTraceInputs");
static_assert(offsetof(FMantleTraceInputs, World) == 0x000048, "Member 'FMantleTraceInputs::World' has a wrong offset!");
static_assert(offsetof(FMantleTraceInputs, MantleData) == 0x000050, "Member 'FMantleTraceInputs::MantleData' has a wrong offset!");
static_assert(offsetof(FMantleTraceInputs, Globals) == 0x000058, "Member 'FMantleTraceInputs::Globals' has a wrong offset!");
static_assert(offsetof(FMantleTraceInputs, SourceActor) == 0x000060, "Member 'FMantleTraceInputs::SourceActor' has a wrong offset!");

// ScriptStruct GbxGameSystemCore.MantleTraceCheck
// 0x0278 (0x0278 - 0x0000)
struct FMantleTraceCheck final
{
public:
	struct FMantleTraceInputs                     Inputs;                                            // 0x0000(0x0068)(Transient, NoDestructor, NativeAccessSpecifierPublic)
	uint8                                         Pad_68[0x210];                                     // 0x0068(0x0210)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FMantleTraceCheck) == 0x000008, "Wrong alignment on FMantleTraceCheck");
static_assert(sizeof(FMantleTraceCheck) == 0x000278, "Wrong size on FMantleTraceCheck");
static_assert(offsetof(FMantleTraceCheck, Inputs) == 0x000000, "Member 'FMantleTraceCheck::Inputs' has a wrong offset!");

// ScriptStruct GbxGameSystemCore.MantleState
// 0x06E8 (0x06E8 - 0x0000)
struct FMantleState final
{
public:
	class UGbxCharacterMovementComponent*         MovementComponentOwner;                            // 0x0000(0x0008)(ExportObject, ZeroConstructor, Transient, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UMantleData*                            MantleData;                                        // 0x0008(0x0008)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UGbxGameplayGlobals*                    GameplayGlobals;                                   // 0x0010(0x0008)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_18[0x8];                                       // 0x0018(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	struct FMantleActiveActionData                ActiveActionData;                                  // 0x0020(0x0020)(Transient, NoDestructor, ContainsInstancedReference, NativeAccessSpecifierPrivate)
	uint8                                         Pad_40[0x430];                                     // 0x0040(0x0430)(Fixing Size After Last Property [ Dumper-7 ])
	struct FMantleTraceCheck                      CurrentTrace;                                      // 0x0470(0x0278)(Transient, NoDestructor, NativeAccessSpecifierPrivate)
};
static_assert(alignof(FMantleState) == 0x000008, "Wrong alignment on FMantleState");
static_assert(sizeof(FMantleState) == 0x0006E8, "Wrong size on FMantleState");
static_assert(offsetof(FMantleState, MovementComponentOwner) == 0x000000, "Member 'FMantleState::MovementComponentOwner' has a wrong offset!");
static_assert(offsetof(FMantleState, MantleData) == 0x000008, "Member 'FMantleState::MantleData' has a wrong offset!");
static_assert(offsetof(FMantleState, GameplayGlobals) == 0x000010, "Member 'FMantleState::GameplayGlobals' has a wrong offset!");
static_assert(offsetof(FMantleState, ActiveActionData) == 0x000020, "Member 'FMantleState::ActiveActionData' has a wrong offset!");
static_assert(offsetof(FMantleState, CurrentTrace) == 0x000470, "Member 'FMantleState::CurrentTrace' has a wrong offset!");

// ScriptStruct GbxGameSystemCore.AttributeDefinedValueRow
// 0x0000 (0x0008 - 0x0008)
struct FAttributeDefinedValueRow : public FTableRowBase
{
};
static_assert(alignof(FAttributeDefinedValueRow) == 0x000008, "Wrong alignment on FAttributeDefinedValueRow");
static_assert(sizeof(FAttributeDefinedValueRow) == 0x000008, "Wrong size on FAttributeDefinedValueRow");

// ScriptStruct GbxGameSystemCore.UsableCostCache
// 0x0010 (0x0010 - 0x0000)
struct FUsableCostCache final
{
public:
	int32                                         PrimaryCost;                                       // 0x0000(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         SecondaryCost;                                     // 0x0004(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         PrimaryHoldUseCost;                                // 0x0008(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         SecondaryHoldUseCost;                              // 0x000C(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FUsableCostCache) == 0x000004, "Wrong alignment on FUsableCostCache");
static_assert(sizeof(FUsableCostCache) == 0x000010, "Wrong size on FUsableCostCache");
static_assert(offsetof(FUsableCostCache, PrimaryCost) == 0x000000, "Member 'FUsableCostCache::PrimaryCost' has a wrong offset!");
static_assert(offsetof(FUsableCostCache, SecondaryCost) == 0x000004, "Member 'FUsableCostCache::SecondaryCost' has a wrong offset!");
static_assert(offsetof(FUsableCostCache, PrimaryHoldUseCost) == 0x000008, "Member 'FUsableCostCache::PrimaryHoldUseCost' has a wrong offset!");
static_assert(offsetof(FUsableCostCache, SecondaryHoldUseCost) == 0x00000C, "Member 'FUsableCostCache::SecondaryHoldUseCost' has a wrong offset!");

// ScriptStruct GbxGameSystemCore.PawnAttachSlotState
// 0x0040 (0x0040 - 0x0000)
struct FPawnAttachSlotState final
{
public:
	class UPawnAttachSlotComponent*               Owner;                                             // 0x0000(0x0008)(ExportObject, ZeroConstructor, Transient, InstancedReference, IsPlainOldData, RepSkip, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class APawn*                                  Pawn;                                              // 0x0008(0x0008)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class AController*                            Controller;                                        // 0x0010(0x0008)(ZeroConstructor, Transient, IsPlainOldData, RepSkip, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	EPawnAttachStatus                             Status;                                            // 0x0018(0x0001)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	bool                                          bSkipDetachPlacement;                              // 0x0019(0x0001)(ZeroConstructor, Transient, IsPlainOldData, RepSkip, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	bool                                          bSkipStopTransitionAction;                         // 0x001A(0x0001)(ZeroConstructor, Transient, IsPlainOldData, RepSkip, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_1B[0x1];                                       // 0x001B(0x0001)(Fixing Size After Last Property [ Dumper-7 ])
	int32                                         DetachTransitionIndex;                             // 0x001C(0x0004)(ZeroConstructor, Transient, IsPlainOldData, RepSkip, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_20[0x20];                                      // 0x0020(0x0020)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FPawnAttachSlotState) == 0x000008, "Wrong alignment on FPawnAttachSlotState");
static_assert(sizeof(FPawnAttachSlotState) == 0x000040, "Wrong size on FPawnAttachSlotState");
static_assert(offsetof(FPawnAttachSlotState, Owner) == 0x000000, "Member 'FPawnAttachSlotState::Owner' has a wrong offset!");
static_assert(offsetof(FPawnAttachSlotState, Pawn) == 0x000008, "Member 'FPawnAttachSlotState::Pawn' has a wrong offset!");
static_assert(offsetof(FPawnAttachSlotState, Controller) == 0x000010, "Member 'FPawnAttachSlotState::Controller' has a wrong offset!");
static_assert(offsetof(FPawnAttachSlotState, Status) == 0x000018, "Member 'FPawnAttachSlotState::Status' has a wrong offset!");
static_assert(offsetof(FPawnAttachSlotState, bSkipDetachPlacement) == 0x000019, "Member 'FPawnAttachSlotState::bSkipDetachPlacement' has a wrong offset!");
static_assert(offsetof(FPawnAttachSlotState, bSkipStopTransitionAction) == 0x00001A, "Member 'FPawnAttachSlotState::bSkipStopTransitionAction' has a wrong offset!");
static_assert(offsetof(FPawnAttachSlotState, DetachTransitionIndex) == 0x00001C, "Member 'FPawnAttachSlotState::DetachTransitionIndex' has a wrong offset!");

// ScriptStruct GbxGameSystemCore.HealthTypeDamageSummary
// 0x0010 (0x0010 - 0x0000)
struct FHealthTypeDamageSummary final
{
public:
	class UHealthTypeData*                        HealthType;                                        // 0x0000(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         Damage;                                            // 0x0008(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_C[0x4];                                        // 0x000C(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FHealthTypeDamageSummary) == 0x000008, "Wrong alignment on FHealthTypeDamageSummary");
static_assert(sizeof(FHealthTypeDamageSummary) == 0x000010, "Wrong size on FHealthTypeDamageSummary");
static_assert(offsetof(FHealthTypeDamageSummary, HealthType) == 0x000000, "Member 'FHealthTypeDamageSummary::HealthType' has a wrong offset!");
static_assert(offsetof(FHealthTypeDamageSummary, Damage) == 0x000008, "Member 'FHealthTypeDamageSummary::Damage' has a wrong offset!");

// ScriptStruct GbxGameSystemCore.CausedDamageDetails
// 0x0060 (0x0060 - 0x0000)
struct FCausedDamageDetails final
{
public:
	bool                                          bWasCrit;                                          // 0x0000(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1[0x3];                                        // 0x0001(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	struct FVector                                HitLocation;                                       // 0x0004(0x000C)(BlueprintVisible, BlueprintReadOnly, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                HitDirection;                                      // 0x0010(0x000C)(BlueprintVisible, BlueprintReadOnly, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1C[0x4];                                       // 0x001C(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class AActor*                                 DamageCauser;                                      // 0x0020(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UPrimitiveComponent*                    HitComponent;                                      // 0x0028(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UHitRegionData*                         HitRegion;                                         // 0x0030(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TArray<struct FHealthTypeDamageSummary>       DamagePerHealthType;                               // 0x0038(0x0010)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, NativeAccessSpecifierPublic)
	struct FVector                                RadiusDamageOrigin;                                // 0x0048(0x000C)(BlueprintVisible, BlueprintReadOnly, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         DamageRadius;                                      // 0x0054(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bIsDamageOverTime;                                 // 0x0058(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_59[0x7];                                       // 0x0059(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FCausedDamageDetails) == 0x000008, "Wrong alignment on FCausedDamageDetails");
static_assert(sizeof(FCausedDamageDetails) == 0x000060, "Wrong size on FCausedDamageDetails");
static_assert(offsetof(FCausedDamageDetails, bWasCrit) == 0x000000, "Member 'FCausedDamageDetails::bWasCrit' has a wrong offset!");
static_assert(offsetof(FCausedDamageDetails, HitLocation) == 0x000004, "Member 'FCausedDamageDetails::HitLocation' has a wrong offset!");
static_assert(offsetof(FCausedDamageDetails, HitDirection) == 0x000010, "Member 'FCausedDamageDetails::HitDirection' has a wrong offset!");
static_assert(offsetof(FCausedDamageDetails, DamageCauser) == 0x000020, "Member 'FCausedDamageDetails::DamageCauser' has a wrong offset!");
static_assert(offsetof(FCausedDamageDetails, HitComponent) == 0x000028, "Member 'FCausedDamageDetails::HitComponent' has a wrong offset!");
static_assert(offsetof(FCausedDamageDetails, HitRegion) == 0x000030, "Member 'FCausedDamageDetails::HitRegion' has a wrong offset!");
static_assert(offsetof(FCausedDamageDetails, DamagePerHealthType) == 0x000038, "Member 'FCausedDamageDetails::DamagePerHealthType' has a wrong offset!");
static_assert(offsetof(FCausedDamageDetails, RadiusDamageOrigin) == 0x000048, "Member 'FCausedDamageDetails::RadiusDamageOrigin' has a wrong offset!");
static_assert(offsetof(FCausedDamageDetails, DamageRadius) == 0x000054, "Member 'FCausedDamageDetails::DamageRadius' has a wrong offset!");
static_assert(offsetof(FCausedDamageDetails, bIsDamageOverTime) == 0x000058, "Member 'FCausedDamageDetails::bIsDamageOverTime' has a wrong offset!");

// ScriptStruct GbxGameSystemCore.ScreenParticleInitParams
// 0x0030 (0x0030 - 0x0000)
struct FScreenParticleInitParams final
{
public:
	class UParticleSystem*                        Template;                                          // 0x0000(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         bHideWhenFinished : 1;                             // 0x0008(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         bDestroyWhenFinished : 1;                          // 0x0008(0x0001)(BitIndex: 0x01, PropSize: 0x0001 (NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         bOnlyOwnerSee : 1;                                 // 0x0008(0x0001)(BitIndex: 0x02, PropSize: 0x0001 (NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         bAlwaysVisible : 1;                                // 0x0008(0x0001)(BitIndex: 0x03, PropSize: 0x0001 (NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         bAllowMultipleInstances : 1;                       // 0x0008(0x0001)(BitIndex: 0x04, PropSize: 0x0001 (Edit, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         bTickEvenWhenPaused : 1;                           // 0x0008(0x0001)(BitIndex: 0x05, PropSize: 0x0001 (Edit, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         bHideDuringInGameMenu : 1;                         // 0x0008(0x0001)(BitIndex: 0x06, PropSize: 0x0001 (Edit, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         bDepthPriorityWorld : 1;                           // 0x0008(0x0001)(BitIndex: 0x07, PropSize: 0x0001 (Edit, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         Pad_9[0x3];                                        // 0x0009(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	struct FVector2D                              ContentDims;                                       // 0x000C(0x0008)(Edit, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         ParticleDepth;                                     // 0x0014(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EScreenParticleScalingMode                    ScalingMode;                                       // 0x0018(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_19[0x7];                                       // 0x0019(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	class FName                                   Tag;                                               // 0x0020(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class AActor*                                 OwnerOverride;                                     // 0x0028(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FScreenParticleInitParams) == 0x000008, "Wrong alignment on FScreenParticleInitParams");
static_assert(sizeof(FScreenParticleInitParams) == 0x000030, "Wrong size on FScreenParticleInitParams");
static_assert(offsetof(FScreenParticleInitParams, Template) == 0x000000, "Member 'FScreenParticleInitParams::Template' has a wrong offset!");
static_assert(offsetof(FScreenParticleInitParams, ContentDims) == 0x00000C, "Member 'FScreenParticleInitParams::ContentDims' has a wrong offset!");
static_assert(offsetof(FScreenParticleInitParams, ParticleDepth) == 0x000014, "Member 'FScreenParticleInitParams::ParticleDepth' has a wrong offset!");
static_assert(offsetof(FScreenParticleInitParams, ScalingMode) == 0x000018, "Member 'FScreenParticleInitParams::ScalingMode' has a wrong offset!");
static_assert(offsetof(FScreenParticleInitParams, Tag) == 0x000020, "Member 'FScreenParticleInitParams::Tag' has a wrong offset!");
static_assert(offsetof(FScreenParticleInitParams, OwnerOverride) == 0x000028, "Member 'FScreenParticleInitParams::OwnerOverride' has a wrong offset!");

// ScriptStruct GbxGameSystemCore.SpawnPatternResult
// 0x002C (0x002C - 0x0000)
struct FSpawnPatternResult final
{
public:
	struct FVector                                Location;                                          // 0x0000(0x000C)(BlueprintVisible, BlueprintReadOnly, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                LinearImpulse;                                     // 0x000C(0x000C)(BlueprintVisible, BlueprintReadOnly, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bLinearVelocityChange;                             // 0x0018(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_19[0x3];                                       // 0x0019(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	struct FVector                                AngularImpulse;                                    // 0x001C(0x000C)(BlueprintVisible, BlueprintReadOnly, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bAngularVelocityChange;                            // 0x0028(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_29[0x3];                                       // 0x0029(0x0003)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FSpawnPatternResult) == 0x000004, "Wrong alignment on FSpawnPatternResult");
static_assert(sizeof(FSpawnPatternResult) == 0x00002C, "Wrong size on FSpawnPatternResult");
static_assert(offsetof(FSpawnPatternResult, Location) == 0x000000, "Member 'FSpawnPatternResult::Location' has a wrong offset!");
static_assert(offsetof(FSpawnPatternResult, LinearImpulse) == 0x00000C, "Member 'FSpawnPatternResult::LinearImpulse' has a wrong offset!");
static_assert(offsetof(FSpawnPatternResult, bLinearVelocityChange) == 0x000018, "Member 'FSpawnPatternResult::bLinearVelocityChange' has a wrong offset!");
static_assert(offsetof(FSpawnPatternResult, AngularImpulse) == 0x00001C, "Member 'FSpawnPatternResult::AngularImpulse' has a wrong offset!");
static_assert(offsetof(FSpawnPatternResult, bAngularVelocityChange) == 0x000028, "Member 'FSpawnPatternResult::bAngularVelocityChange' has a wrong offset!");

// ScriptStruct GbxGameSystemCore.CharacterRotateToState
// 0x0068 (0x0068 - 0x0000)
struct FCharacterRotateToState final
{
public:
	struct FCharacterRotateToCommand              CommandData;                                       // 0x0000(0x0050)(NativeAccessSpecifierPublic)
	uint8                                         Pad_50[0x18];                                      // 0x0050(0x0018)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FCharacterRotateToState) == 0x000008, "Wrong alignment on FCharacterRotateToState");
static_assert(sizeof(FCharacterRotateToState) == 0x000068, "Wrong size on FCharacterRotateToState");
static_assert(offsetof(FCharacterRotateToState, CommandData) == 0x000000, "Member 'FCharacterRotateToState::CommandData' has a wrong offset!");

// ScriptStruct GbxGameSystemCore.ExampleStruct
// 0x0008 (0x0008 - 0x0000)
struct FExampleStruct final
{
public:
	struct FGameplayTag                           ActionKey;                                         // 0x0000(0x0008)(Edit, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FExampleStruct) == 0x000008, "Wrong alignment on FExampleStruct");
static_assert(sizeof(FExampleStruct) == 0x000008, "Wrong size on FExampleStruct");
static_assert(offsetof(FExampleStruct, ActionKey) == 0x000000, "Member 'FExampleStruct::ActionKey' has a wrong offset!");

// ScriptStruct GbxGameSystemCore.CachedInterp
// 0x0020 (0x0020 - 0x0000)
struct FCachedInterp final
{
public:
	class FName                                   Tag;                                               // 0x0000(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FString                                 Interp;                                            // 0x0008(0x0010)(ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_18[0x8];                                       // 0x0018(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FCachedInterp) == 0x000008, "Wrong alignment on FCachedInterp");
static_assert(sizeof(FCachedInterp) == 0x000020, "Wrong size on FCachedInterp");
static_assert(offsetof(FCachedInterp, Tag) == 0x000000, "Member 'FCachedInterp::Tag' has a wrong offset!");
static_assert(offsetof(FCachedInterp, Interp) == 0x000008, "Member 'FCachedInterp::Interp' has a wrong offset!");

// ScriptStruct GbxGameSystemCore.RandomActionPair
// 0x0010 (0x0010 - 0x0000)
struct FRandomActionPair final
{
public:
	TSubclassOf<class UGbxAction>                 ActionClass;                                       // 0x0000(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         Weight;                                            // 0x0008(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_C[0x4];                                        // 0x000C(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FRandomActionPair) == 0x000008, "Wrong alignment on FRandomActionPair");
static_assert(sizeof(FRandomActionPair) == 0x000010, "Wrong size on FRandomActionPair");
static_assert(offsetof(FRandomActionPair, ActionClass) == 0x000000, "Member 'FRandomActionPair::ActionClass' has a wrong offset!");
static_assert(offsetof(FRandomActionPair, Weight) == 0x000008, "Member 'FRandomActionPair::Weight' has a wrong offset!");

// ScriptStruct GbxGameSystemCore.AnimActionDef
// 0x0018 (0x0018 - 0x0000)
struct FAnimActionDef final
{
public:
	EAnimActionDefInput                           InputType;                                         // 0x0000(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1[0x7];                                        // 0x0001(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	class UAnimationAsset*                        AnimAsset;                                         // 0x0008(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   AnimAssetName;                                     // 0x0010(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FAnimActionDef) == 0x000008, "Wrong alignment on FAnimActionDef");
static_assert(sizeof(FAnimActionDef) == 0x000018, "Wrong size on FAnimActionDef");
static_assert(offsetof(FAnimActionDef, InputType) == 0x000000, "Member 'FAnimActionDef::InputType' has a wrong offset!");
static_assert(offsetof(FAnimActionDef, AnimAsset) == 0x000008, "Member 'FAnimActionDef::AnimAsset' has a wrong offset!");
static_assert(offsetof(FAnimActionDef, AnimAssetName) == 0x000010, "Member 'FAnimActionDef::AnimAssetName' has a wrong offset!");

// ScriptStruct GbxGameSystemCore.AnimMeshExtra
// 0x0040 (0x0040 - 0x0000)
struct FAnimMeshExtra final
{
public:
	struct FAnimActionDef                         Anim;                                              // 0x0000(0x0018)(Edit, NoDestructor, NativeAccessSpecifierPublic)
	class FName                                   MeshName;                                          // 0x0018(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   AnimSlotOverride;                                  // 0x0020(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bHasAnimSlotOverride;                              // 0x0028(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_29[0x3];                                       // 0x0029(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         BlendInOverride;                                   // 0x002C(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bHasBlendInOverride;                               // 0x0030(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_31[0x3];                                       // 0x0031(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         BlendOutOverride;                                  // 0x0034(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bHasBlendOutOverride;                              // 0x0038(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_39[0x7];                                       // 0x0039(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FAnimMeshExtra) == 0x000008, "Wrong alignment on FAnimMeshExtra");
static_assert(sizeof(FAnimMeshExtra) == 0x000040, "Wrong size on FAnimMeshExtra");
static_assert(offsetof(FAnimMeshExtra, Anim) == 0x000000, "Member 'FAnimMeshExtra::Anim' has a wrong offset!");
static_assert(offsetof(FAnimMeshExtra, MeshName) == 0x000018, "Member 'FAnimMeshExtra::MeshName' has a wrong offset!");
static_assert(offsetof(FAnimMeshExtra, AnimSlotOverride) == 0x000020, "Member 'FAnimMeshExtra::AnimSlotOverride' has a wrong offset!");
static_assert(offsetof(FAnimMeshExtra, bHasAnimSlotOverride) == 0x000028, "Member 'FAnimMeshExtra::bHasAnimSlotOverride' has a wrong offset!");
static_assert(offsetof(FAnimMeshExtra, BlendInOverride) == 0x00002C, "Member 'FAnimMeshExtra::BlendInOverride' has a wrong offset!");
static_assert(offsetof(FAnimMeshExtra, bHasBlendInOverride) == 0x000030, "Member 'FAnimMeshExtra::bHasBlendInOverride' has a wrong offset!");
static_assert(offsetof(FAnimMeshExtra, BlendOutOverride) == 0x000034, "Member 'FAnimMeshExtra::BlendOutOverride' has a wrong offset!");
static_assert(offsetof(FAnimMeshExtra, bHasBlendOutOverride) == 0x000038, "Member 'FAnimMeshExtra::bHasBlendOutOverride' has a wrong offset!");

// ScriptStruct GbxGameSystemCore.AnimMeshList
// 0x0078 (0x0078 - 0x0000)
struct FAnimMeshList final
{
public:
	struct FAnimActionDef                         Body3rd;                                           // 0x0000(0x0018)(Edit, NoDestructor, NativeAccessSpecifierPublic)
	struct FAnimActionDef                         Body1st;                                           // 0x0018(0x0018)(Edit, NoDestructor, NativeAccessSpecifierPublic)
	struct FAnimActionDef                         Weapon3rd;                                         // 0x0030(0x0018)(Edit, NoDestructor, NativeAccessSpecifierPublic)
	struct FAnimActionDef                         Weapon1st;                                         // 0x0048(0x0018)(Edit, NoDestructor, NativeAccessSpecifierPublic)
	TArray<struct FAnimMeshExtra>                 Extras;                                            // 0x0060(0x0010)(Edit, ZeroConstructor, NativeAccessSpecifierPublic)
	uint8                                         Pad_70[0x8];                                       // 0x0070(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FAnimMeshList) == 0x000008, "Wrong alignment on FAnimMeshList");
static_assert(sizeof(FAnimMeshList) == 0x000078, "Wrong size on FAnimMeshList");
static_assert(offsetof(FAnimMeshList, Body3rd) == 0x000000, "Member 'FAnimMeshList::Body3rd' has a wrong offset!");
static_assert(offsetof(FAnimMeshList, Body1st) == 0x000018, "Member 'FAnimMeshList::Body1st' has a wrong offset!");
static_assert(offsetof(FAnimMeshList, Weapon3rd) == 0x000030, "Member 'FAnimMeshList::Weapon3rd' has a wrong offset!");
static_assert(offsetof(FAnimMeshList, Weapon1st) == 0x000048, "Member 'FAnimMeshList::Weapon1st' has a wrong offset!");
static_assert(offsetof(FAnimMeshList, Extras) == 0x000060, "Member 'FAnimMeshList::Extras' has a wrong offset!");

// ScriptStruct GbxGameSystemCore.GameResourcePoolReference
// 0x0018 (0x0018 - 0x0000)
struct FGameResourcePoolReference final
{
public:
	uint8                                         PoolIndexInManager;                                // 0x0000(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1[0x7];                                        // 0x0001(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	class UGameResourcePoolManagerComponent*      PoolManager;                                       // 0x0008(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_10[0x8];                                       // 0x0010(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FGameResourcePoolReference) == 0x000008, "Wrong alignment on FGameResourcePoolReference");
static_assert(sizeof(FGameResourcePoolReference) == 0x000018, "Wrong size on FGameResourcePoolReference");
static_assert(offsetof(FGameResourcePoolReference, PoolIndexInManager) == 0x000000, "Member 'FGameResourcePoolReference::PoolIndexInManager' has a wrong offset!");
static_assert(offsetof(FGameResourcePoolReference, PoolManager) == 0x000008, "Member 'FGameResourcePoolReference::PoolManager' has a wrong offset!");

// ScriptStruct GbxGameSystemCore.ConditionActionPair
// 0x0010 (0x0010 - 0x0000)
struct FConditionActionPair final
{
public:
	class UGbxCondition*                          Condition;                                         // 0x0000(0x0008)(Edit, ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, PersistentInstance, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TSubclassOf<class UGbxAction>                 ActionClass;                                       // 0x0008(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FConditionActionPair) == 0x000008, "Wrong alignment on FConditionActionPair");
static_assert(sizeof(FConditionActionPair) == 0x000010, "Wrong size on FConditionActionPair");
static_assert(offsetof(FConditionActionPair, Condition) == 0x000000, "Member 'FConditionActionPair::Condition' has a wrong offset!");
static_assert(offsetof(FConditionActionPair, ActionClass) == 0x000008, "Member 'FConditionActionPair::ActionClass' has a wrong offset!");

// ScriptStruct GbxGameSystemCore.CausedDeathDetails
// 0x0068 (0x0068 - 0x0000)
struct FCausedDeathDetails final
{
public:
	class UDamageSource*                          DamageSource;                                      // 0x0000(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UGbxDamageType*                         DamageType;                                        // 0x0008(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class APawn*                                  DamageInstigator;                                  // 0x0010(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class AActor*                                 DamageCauser;                                      // 0x0018(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         Damage;                                            // 0x0020(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         OverkillDamage;                                    // 0x0024(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bWasCrit;                                          // 0x0028(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bWasAwareOfKiller;                                 // 0x0029(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bWasFullyHealthy;                                  // 0x002A(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2B[0x1];                                       // 0x002B(0x0001)(Fixing Size After Last Property [ Dumper-7 ])
	struct FVector                                HitLocation;                                       // 0x002C(0x000C)(BlueprintVisible, BlueprintReadOnly, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                HitDirection;                                      // 0x0038(0x000C)(BlueprintVisible, BlueprintReadOnly, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                RadiusDamageOrigin;                                // 0x0044(0x000C)(BlueprintVisible, BlueprintReadOnly, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         DamageRadius;                                      // 0x0050(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_54[0x4];                                       // 0x0054(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<struct FHealthTypeDamageSummary>       DamagePerHealthType;                               // 0x0058(0x0010)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(FCausedDeathDetails) == 0x000008, "Wrong alignment on FCausedDeathDetails");
static_assert(sizeof(FCausedDeathDetails) == 0x000068, "Wrong size on FCausedDeathDetails");
static_assert(offsetof(FCausedDeathDetails, DamageSource) == 0x000000, "Member 'FCausedDeathDetails::DamageSource' has a wrong offset!");
static_assert(offsetof(FCausedDeathDetails, DamageType) == 0x000008, "Member 'FCausedDeathDetails::DamageType' has a wrong offset!");
static_assert(offsetof(FCausedDeathDetails, DamageInstigator) == 0x000010, "Member 'FCausedDeathDetails::DamageInstigator' has a wrong offset!");
static_assert(offsetof(FCausedDeathDetails, DamageCauser) == 0x000018, "Member 'FCausedDeathDetails::DamageCauser' has a wrong offset!");
static_assert(offsetof(FCausedDeathDetails, Damage) == 0x000020, "Member 'FCausedDeathDetails::Damage' has a wrong offset!");
static_assert(offsetof(FCausedDeathDetails, OverkillDamage) == 0x000024, "Member 'FCausedDeathDetails::OverkillDamage' has a wrong offset!");
static_assert(offsetof(FCausedDeathDetails, bWasCrit) == 0x000028, "Member 'FCausedDeathDetails::bWasCrit' has a wrong offset!");
static_assert(offsetof(FCausedDeathDetails, bWasAwareOfKiller) == 0x000029, "Member 'FCausedDeathDetails::bWasAwareOfKiller' has a wrong offset!");
static_assert(offsetof(FCausedDeathDetails, bWasFullyHealthy) == 0x00002A, "Member 'FCausedDeathDetails::bWasFullyHealthy' has a wrong offset!");
static_assert(offsetof(FCausedDeathDetails, HitLocation) == 0x00002C, "Member 'FCausedDeathDetails::HitLocation' has a wrong offset!");
static_assert(offsetof(FCausedDeathDetails, HitDirection) == 0x000038, "Member 'FCausedDeathDetails::HitDirection' has a wrong offset!");
static_assert(offsetof(FCausedDeathDetails, RadiusDamageOrigin) == 0x000044, "Member 'FCausedDeathDetails::RadiusDamageOrigin' has a wrong offset!");
static_assert(offsetof(FCausedDeathDetails, DamageRadius) == 0x000050, "Member 'FCausedDeathDetails::DamageRadius' has a wrong offset!");
static_assert(offsetof(FCausedDeathDetails, DamagePerHealthType) == 0x000058, "Member 'FCausedDeathDetails::DamagePerHealthType' has a wrong offset!");

// ScriptStruct GbxGameSystemCore.BoneFatigueParams
// 0x0014 (0x0014 - 0x0000)
struct FBoneFatigueParams final
{
public:
	float                                         CurrentFatigue;                                    // 0x0000(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         FatigueDissipationRate;                            // 0x0004(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_8[0xC];                                        // 0x0008(0x000C)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FBoneFatigueParams) == 0x000004, "Wrong alignment on FBoneFatigueParams");
static_assert(sizeof(FBoneFatigueParams) == 0x000014, "Wrong size on FBoneFatigueParams");
static_assert(offsetof(FBoneFatigueParams, CurrentFatigue) == 0x000000, "Member 'FBoneFatigueParams::CurrentFatigue' has a wrong offset!");
static_assert(offsetof(FBoneFatigueParams, FatigueDissipationRate) == 0x000004, "Member 'FBoneFatigueParams::FatigueDissipationRate' has a wrong offset!");

// ScriptStruct GbxGameSystemCore.GbxCustomizationContainerEntry
// 0x001C (0x0028 - 0x000C)
struct FGbxCustomizationContainerEntry final : public FFastArraySerializerItem
{
public:
	uint8                                         Pad_C[0x4];                                        // 0x000C(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class UGbxCustomizationData*                  CustomizationData;                                 // 0x0010(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         OptionalCustomizationId;                           // 0x0018(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1C[0x4];                                       // 0x001C(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class UGbxCustomizationData*                  ClientCachedCustomizationData;                     // 0x0020(0x0008)(ZeroConstructor, IsPlainOldData, RepSkip, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
};
static_assert(alignof(FGbxCustomizationContainerEntry) == 0x000008, "Wrong alignment on FGbxCustomizationContainerEntry");
static_assert(sizeof(FGbxCustomizationContainerEntry) == 0x000028, "Wrong size on FGbxCustomizationContainerEntry");
static_assert(offsetof(FGbxCustomizationContainerEntry, CustomizationData) == 0x000010, "Member 'FGbxCustomizationContainerEntry::CustomizationData' has a wrong offset!");
static_assert(offsetof(FGbxCustomizationContainerEntry, OptionalCustomizationId) == 0x000018, "Member 'FGbxCustomizationContainerEntry::OptionalCustomizationId' has a wrong offset!");
static_assert(offsetof(FGbxCustomizationContainerEntry, ClientCachedCustomizationData) == 0x000020, "Member 'FGbxCustomizationContainerEntry::ClientCachedCustomizationData' has a wrong offset!");

// ScriptStruct GbxGameSystemCore.ReplicatedLadderState
// 0x0002 (0x0002 - 0x0000)
struct FReplicatedLadderState final
{
public:
	uint8                                         DirtyCounter;                                      // 0x0000(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EScriptedLadderType                           LadderType;                                        // 0x0001(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FReplicatedLadderState) == 0x000001, "Wrong alignment on FReplicatedLadderState");
static_assert(sizeof(FReplicatedLadderState) == 0x000002, "Wrong size on FReplicatedLadderState");
static_assert(offsetof(FReplicatedLadderState, DirtyCounter) == 0x000000, "Member 'FReplicatedLadderState::DirtyCounter' has a wrong offset!");
static_assert(offsetof(FReplicatedLadderState, LadderType) == 0x000001, "Member 'FReplicatedLadderState::LadderType' has a wrong offset!");

// ScriptStruct GbxGameSystemCore.ControlledMoveParameters
// 0x0028 (0x0028 - 0x0000)
struct FControlledMoveParameters final
{
public:
	float                                         SpeedOverride;                                     // 0x0000(0x0004)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	float                                         DurationOverride;                                  // 0x0004(0x0004)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	float                                         LaunchAngleOverride;                               // 0x0008(0x0004)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_C[0x4];                                        // 0x000C(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class AActor*                                 TargetActor;                                       // 0x0010(0x0008)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	struct FVector                                TargetLocation;                                    // 0x0018(0x000C)(Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_24[0x4];                                       // 0x0024(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FControlledMoveParameters) == 0x000008, "Wrong alignment on FControlledMoveParameters");
static_assert(sizeof(FControlledMoveParameters) == 0x000028, "Wrong size on FControlledMoveParameters");
static_assert(offsetof(FControlledMoveParameters, SpeedOverride) == 0x000000, "Member 'FControlledMoveParameters::SpeedOverride' has a wrong offset!");
static_assert(offsetof(FControlledMoveParameters, DurationOverride) == 0x000004, "Member 'FControlledMoveParameters::DurationOverride' has a wrong offset!");
static_assert(offsetof(FControlledMoveParameters, LaunchAngleOverride) == 0x000008, "Member 'FControlledMoveParameters::LaunchAngleOverride' has a wrong offset!");
static_assert(offsetof(FControlledMoveParameters, TargetActor) == 0x000010, "Member 'FControlledMoveParameters::TargetActor' has a wrong offset!");
static_assert(offsetof(FControlledMoveParameters, TargetLocation) == 0x000018, "Member 'FControlledMoveParameters::TargetLocation' has a wrong offset!");

// ScriptStruct GbxGameSystemCore.ControlledMoveReplicationData
// 0x0048 (0x0048 - 0x0000)
struct FControlledMoveReplicationData final
{
public:
	uint8                                         DirtyCounter;                                      // 0x0000(0x0001)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_1[0x7];                                        // 0x0001(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	TSubclassOf<class UControlledMove>            ControlledMove;                                    // 0x0008(0x0008)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	struct FControlledMoveParameters              Parameters;                                        // 0x0010(0x0028)(Transient, NoDestructor, NativeAccessSpecifierPrivate)
	struct FVector                                PackedDirection;                                   // 0x0038(0x000C)(Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         bZeroVelocity : 1;                                 // 0x0044(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (Transient, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate))
	uint8                                         bInterrupted : 1;                                  // 0x0044(0x0001)(BitIndex: 0x01, PropSize: 0x0001 (Transient, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate))
	uint8                                         Pad_45[0x3];                                       // 0x0045(0x0003)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FControlledMoveReplicationData) == 0x000008, "Wrong alignment on FControlledMoveReplicationData");
static_assert(sizeof(FControlledMoveReplicationData) == 0x000048, "Wrong size on FControlledMoveReplicationData");
static_assert(offsetof(FControlledMoveReplicationData, DirtyCounter) == 0x000000, "Member 'FControlledMoveReplicationData::DirtyCounter' has a wrong offset!");
static_assert(offsetof(FControlledMoveReplicationData, ControlledMove) == 0x000008, "Member 'FControlledMoveReplicationData::ControlledMove' has a wrong offset!");
static_assert(offsetof(FControlledMoveReplicationData, Parameters) == 0x000010, "Member 'FControlledMoveReplicationData::Parameters' has a wrong offset!");
static_assert(offsetof(FControlledMoveReplicationData, PackedDirection) == 0x000038, "Member 'FControlledMoveReplicationData::PackedDirection' has a wrong offset!");

// ScriptStruct GbxGameSystemCore.TerritoryData
// 0x0020 (0x0020 - 0x0000)
struct FTerritoryData final
{
public:
	bool                                          bEverywhere;                                       // 0x0000(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1[0x3];                                        // 0x0001(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         Radius;                                            // 0x0004(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         Height;                                            // 0x0008(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_C[0x4];                                        // 0x000C(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<class AVolume*>                        Volumes;                                           // 0x0010(0x0010)(Edit, BlueprintVisible, ZeroConstructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(FTerritoryData) == 0x000008, "Wrong alignment on FTerritoryData");
static_assert(sizeof(FTerritoryData) == 0x000020, "Wrong size on FTerritoryData");
static_assert(offsetof(FTerritoryData, bEverywhere) == 0x000000, "Member 'FTerritoryData::bEverywhere' has a wrong offset!");
static_assert(offsetof(FTerritoryData, Radius) == 0x000004, "Member 'FTerritoryData::Radius' has a wrong offset!");
static_assert(offsetof(FTerritoryData, Height) == 0x000008, "Member 'FTerritoryData::Height' has a wrong offset!");
static_assert(offsetof(FTerritoryData, Volumes) == 0x000010, "Member 'FTerritoryData::Volumes' has a wrong offset!");

// ScriptStruct GbxGameSystemCore.UseDefinitionConditional
// 0x0010 (0x0010 - 0x0000)
struct FUseDefinitionConditional final
{
public:
	class UUsableTypeDefinition*                  UseDefinition;                                     // 0x0000(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UGbxCondition*                          UseCondition;                                      // 0x0008(0x0008)(Edit, ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, PersistentInstance, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FUseDefinitionConditional) == 0x000008, "Wrong alignment on FUseDefinitionConditional");
static_assert(sizeof(FUseDefinitionConditional) == 0x000010, "Wrong size on FUseDefinitionConditional");
static_assert(offsetof(FUseDefinitionConditional, UseDefinition) == 0x000000, "Member 'FUseDefinitionConditional::UseDefinition' has a wrong offset!");
static_assert(offsetof(FUseDefinitionConditional, UseCondition) == 0x000008, "Member 'FUseDefinitionConditional::UseCondition' has a wrong offset!");

// ScriptStruct GbxGameSystemCore.HoldToUseSettings
// 0x0014 (0x0014 - 0x0000)
struct FHoldToUseSettings final
{
public:
	EHoldToUseMode                                Mode;                                              // 0x0000(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1[0x3];                                        // 0x0001(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         HoldToUseStartTime;                                // 0x0004(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         HoldToUseTime;                                     // 0x0008(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bUseInteractionBreakDistance;                      // 0x000C(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_D[0x3];                                        // 0x000D(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         InteractionBreakDistance;                          // 0x0010(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FHoldToUseSettings) == 0x000004, "Wrong alignment on FHoldToUseSettings");
static_assert(sizeof(FHoldToUseSettings) == 0x000014, "Wrong size on FHoldToUseSettings");
static_assert(offsetof(FHoldToUseSettings, Mode) == 0x000000, "Member 'FHoldToUseSettings::Mode' has a wrong offset!");
static_assert(offsetof(FHoldToUseSettings, HoldToUseStartTime) == 0x000004, "Member 'FHoldToUseSettings::HoldToUseStartTime' has a wrong offset!");
static_assert(offsetof(FHoldToUseSettings, HoldToUseTime) == 0x000008, "Member 'FHoldToUseSettings::HoldToUseTime' has a wrong offset!");
static_assert(offsetof(FHoldToUseSettings, bUseInteractionBreakDistance) == 0x00000C, "Member 'FHoldToUseSettings::bUseInteractionBreakDistance' has a wrong offset!");
static_assert(offsetof(FHoldToUseSettings, InteractionBreakDistance) == 0x000010, "Member 'FHoldToUseSettings::InteractionBreakDistance' has a wrong offset!");

// ScriptStruct GbxGameSystemCore.CoordinatedScalarParameter
// 0x0158 (0x0158 - 0x0000)
struct FCoordinatedScalarParameter final
{
public:
	class FName                                   ParamName;                                         // 0x0000(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FRuntimeFloatCurve                     ParamValueOverTime;                                // 0x0008(0x0078)(Edit, DisableEditOnInstance, NativeAccessSpecifierPublic)
	ECoordinatedEffectParamScaleMode              ScaleMode;                                         // 0x0080(0x0001)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EAxis                                         WorldSpaceAxis;                                    // 0x0081(0x0001)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         bLoop : 1;                                         // 0x0082(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (Edit, DisableEditOnInstance, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         bBlendFromInitialValue : 1;                        // 0x0082(0x0001)(BitIndex: 0x01, PropSize: 0x0001 (Edit, DisableEditOnInstance, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         Pad_83[0x5];                                       // 0x0083(0x0005)(Fixing Size After Last Property [ Dumper-7 ])
	struct FRuntimeFloatCurve                     BlendCurve;                                        // 0x0088(0x0078)(Edit, DisableEditOnInstance, NativeAccessSpecifierPublic)
	uint8                                         bApplyAttribute : 1;                               // 0x0100(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (Edit, DisableEditOnInstance, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         bScaleAttributeByValueOverTime : 1;                // 0x0100(0x0001)(BitIndex: 0x01, PropSize: 0x0001 (Edit, DisableEditOnInstance, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         Pad_101[0x7];                                      // 0x0101(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	struct FAttributeInitializationData           ParamAttributeValue;                               // 0x0108(0x0038)(Edit, DisableEditOnInstance, NoDestructor, NativeAccessSpecifierPublic)
	uint8                                         bSpecificMaterial : 1;                             // 0x0140(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (Edit, DisableEditOnInstance, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         Pad_141[0x7];                                      // 0x0141(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<int32>                                 SpecificMaterialList;                              // 0x0148(0x0010)(Edit, ZeroConstructor, DisableEditOnInstance, NativeAccessSpecifierPublic)
};
static_assert(alignof(FCoordinatedScalarParameter) == 0x000008, "Wrong alignment on FCoordinatedScalarParameter");
static_assert(sizeof(FCoordinatedScalarParameter) == 0x000158, "Wrong size on FCoordinatedScalarParameter");
static_assert(offsetof(FCoordinatedScalarParameter, ParamName) == 0x000000, "Member 'FCoordinatedScalarParameter::ParamName' has a wrong offset!");
static_assert(offsetof(FCoordinatedScalarParameter, ParamValueOverTime) == 0x000008, "Member 'FCoordinatedScalarParameter::ParamValueOverTime' has a wrong offset!");
static_assert(offsetof(FCoordinatedScalarParameter, ScaleMode) == 0x000080, "Member 'FCoordinatedScalarParameter::ScaleMode' has a wrong offset!");
static_assert(offsetof(FCoordinatedScalarParameter, WorldSpaceAxis) == 0x000081, "Member 'FCoordinatedScalarParameter::WorldSpaceAxis' has a wrong offset!");
static_assert(offsetof(FCoordinatedScalarParameter, BlendCurve) == 0x000088, "Member 'FCoordinatedScalarParameter::BlendCurve' has a wrong offset!");
static_assert(offsetof(FCoordinatedScalarParameter, ParamAttributeValue) == 0x000108, "Member 'FCoordinatedScalarParameter::ParamAttributeValue' has a wrong offset!");
static_assert(offsetof(FCoordinatedScalarParameter, SpecificMaterialList) == 0x000148, "Member 'FCoordinatedScalarParameter::SpecificMaterialList' has a wrong offset!");

// ScriptStruct GbxGameSystemCore.CoordinatedVectorParameter
// 0x0268 (0x0268 - 0x0000)
struct FCoordinatedVectorParameter final
{
public:
	class FName                                   ParamName;                                         // 0x0000(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FRuntimeCurveLinearColor               ParamValueOverTime;                                // 0x0008(0x01C8)(Edit, DisableEditOnInstance, NativeAccessSpecifierPublic)
	uint8                                         bLoop : 1;                                         // 0x01D0(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (Edit, DisableEditOnInstance, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         bBlendFromInitialValue : 1;                        // 0x01D0(0x0001)(BitIndex: 0x01, PropSize: 0x0001 (Edit, DisableEditOnInstance, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         bBlendUsingHSV : 1;                                // 0x01D0(0x0001)(BitIndex: 0x02, PropSize: 0x0001 (Edit, DisableEditOnInstance, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         Pad_1D1[0x7];                                      // 0x01D1(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	struct FRuntimeFloatCurve                     BlendCurve;                                        // 0x01D8(0x0078)(Edit, DisableEditOnInstance, NativeAccessSpecifierPublic)
	uint8                                         bSpecificMaterial : 1;                             // 0x0250(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (Edit, DisableEditOnInstance, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         Pad_251[0x7];                                      // 0x0251(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<int32>                                 SpecificMaterialList;                              // 0x0258(0x0010)(Edit, ZeroConstructor, DisableEditOnInstance, NativeAccessSpecifierPublic)
};
static_assert(alignof(FCoordinatedVectorParameter) == 0x000008, "Wrong alignment on FCoordinatedVectorParameter");
static_assert(sizeof(FCoordinatedVectorParameter) == 0x000268, "Wrong size on FCoordinatedVectorParameter");
static_assert(offsetof(FCoordinatedVectorParameter, ParamName) == 0x000000, "Member 'FCoordinatedVectorParameter::ParamName' has a wrong offset!");
static_assert(offsetof(FCoordinatedVectorParameter, ParamValueOverTime) == 0x000008, "Member 'FCoordinatedVectorParameter::ParamValueOverTime' has a wrong offset!");
static_assert(offsetof(FCoordinatedVectorParameter, BlendCurve) == 0x0001D8, "Member 'FCoordinatedVectorParameter::BlendCurve' has a wrong offset!");
static_assert(offsetof(FCoordinatedVectorParameter, SpecificMaterialList) == 0x000258, "Member 'FCoordinatedVectorParameter::SpecificMaterialList' has a wrong offset!");

// ScriptStruct GbxGameSystemCore.CoordinatedParticleSystemData
// 0x0080 (0x0080 - 0x0000)
struct FCoordinatedParticleSystemData final
{
public:
	class UParticleSystem*                        ParticleSystem;                                    // 0x0000(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_8[0x8];                                        // 0x0008(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	struct FTransform                             RelativeTransform;                                 // 0x0010(0x0030)(Edit, DisableEditOnInstance, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
	class FName                                   AttachmentName;                                    // 0x0040(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         StartTime;                                         // 0x0048(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         DeactivateTime;                                    // 0x004C(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TArray<struct FCoordinatedScalarParameter>    ScalarParameters;                                  // 0x0050(0x0010)(Edit, ZeroConstructor, DisableEditOnInstance, NativeAccessSpecifierPublic)
	TArray<struct FCoordinatedVectorParameter>    VectorParameters;                                  // 0x0060(0x0010)(Edit, ZeroConstructor, DisableEditOnInstance, NativeAccessSpecifierPublic)
	ECoordinatedParticleScaleMode                 ScaleMode;                                         // 0x0070(0x0001)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         bOnlyPlayerOwnerCanSee : 1;                        // 0x0071(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (Edit, DisableEditOnInstance, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         bForegroundLayer : 1;                              // 0x0071(0x0001)(BitIndex: 0x01, PropSize: 0x0001 (Edit, DisableEditOnInstance, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         bInheritViewFlags : 1;                             // 0x0071(0x0001)(BitIndex: 0x02, PropSize: 0x0001 (Edit, DisableEditOnInstance, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         bPermanent : 1;                                    // 0x0071(0x0001)(BitIndex: 0x03, PropSize: 0x0001 (Edit, DisableEditOnInstance, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         Pad_72[0xE];                                       // 0x0072(0x000E)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FCoordinatedParticleSystemData) == 0x000010, "Wrong alignment on FCoordinatedParticleSystemData");
static_assert(sizeof(FCoordinatedParticleSystemData) == 0x000080, "Wrong size on FCoordinatedParticleSystemData");
static_assert(offsetof(FCoordinatedParticleSystemData, ParticleSystem) == 0x000000, "Member 'FCoordinatedParticleSystemData::ParticleSystem' has a wrong offset!");
static_assert(offsetof(FCoordinatedParticleSystemData, RelativeTransform) == 0x000010, "Member 'FCoordinatedParticleSystemData::RelativeTransform' has a wrong offset!");
static_assert(offsetof(FCoordinatedParticleSystemData, AttachmentName) == 0x000040, "Member 'FCoordinatedParticleSystemData::AttachmentName' has a wrong offset!");
static_assert(offsetof(FCoordinatedParticleSystemData, StartTime) == 0x000048, "Member 'FCoordinatedParticleSystemData::StartTime' has a wrong offset!");
static_assert(offsetof(FCoordinatedParticleSystemData, DeactivateTime) == 0x00004C, "Member 'FCoordinatedParticleSystemData::DeactivateTime' has a wrong offset!");
static_assert(offsetof(FCoordinatedParticleSystemData, ScalarParameters) == 0x000050, "Member 'FCoordinatedParticleSystemData::ScalarParameters' has a wrong offset!");
static_assert(offsetof(FCoordinatedParticleSystemData, VectorParameters) == 0x000060, "Member 'FCoordinatedParticleSystemData::VectorParameters' has a wrong offset!");
static_assert(offsetof(FCoordinatedParticleSystemData, ScaleMode) == 0x000070, "Member 'FCoordinatedParticleSystemData::ScaleMode' has a wrong offset!");

// ScriptStruct GbxGameSystemCore.ControlledMoveState
// 0x0160 (0x0160 - 0x0000)
struct FControlledMoveState final
{
public:
	class UGbxCharacterMovementComponent*         MovementComponentOwner;                            // 0x0000(0x0008)(ExportObject, ZeroConstructor, Transient, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UControlledMove*                        CurrentMove;                                       // 0x0008(0x0008)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class AActor*                                 Instigator;                                        // 0x0010(0x0008)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         BaseSpeed;                                         // 0x0018(0x0004)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         Speed;                                             // 0x001C(0x0004)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_20[0x30];                                      // 0x0020(0x0030)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         Runtime;                                           // 0x0050(0x0004)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_54[0x34];                                      // 0x0054(0x0034)(Fixing Size After Last Property [ Dumper-7 ])
	class AActor*                                 TargetActor;                                       // 0x0088(0x0008)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_90[0x18];                                      // 0x0090(0x0018)(Fixing Size After Last Property [ Dumper-7 ])
	struct FVector                                InitialDirection;                                  // 0x00A8(0x000C)(Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                CurrentDirection;                                  // 0x00B4(0x000C)(Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_C0[0x30];                                      // 0x00C0(0x0030)(Fixing Size After Last Property [ Dumper-7 ])
	struct FVector                                FrameMoveVelocity;                                 // 0x00F0(0x000C)(Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_FC[0x34];                                      // 0x00FC(0x0034)(Fixing Size After Last Property [ Dumper-7 ])
	class AActor*                                 LastHitActor;                                      // 0x0130(0x0008)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_138[0x4];                                      // 0x0138(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         AForwardInput;                                     // 0x013C(0x0004)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         AStrafeInput;                                      // 0x0140(0x0004)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_144[0x1C];                                     // 0x0144(0x001C)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FControlledMoveState) == 0x000008, "Wrong alignment on FControlledMoveState");
static_assert(sizeof(FControlledMoveState) == 0x000160, "Wrong size on FControlledMoveState");
static_assert(offsetof(FControlledMoveState, MovementComponentOwner) == 0x000000, "Member 'FControlledMoveState::MovementComponentOwner' has a wrong offset!");
static_assert(offsetof(FControlledMoveState, CurrentMove) == 0x000008, "Member 'FControlledMoveState::CurrentMove' has a wrong offset!");
static_assert(offsetof(FControlledMoveState, Instigator) == 0x000010, "Member 'FControlledMoveState::Instigator' has a wrong offset!");
static_assert(offsetof(FControlledMoveState, BaseSpeed) == 0x000018, "Member 'FControlledMoveState::BaseSpeed' has a wrong offset!");
static_assert(offsetof(FControlledMoveState, Speed) == 0x00001C, "Member 'FControlledMoveState::Speed' has a wrong offset!");
static_assert(offsetof(FControlledMoveState, Runtime) == 0x000050, "Member 'FControlledMoveState::Runtime' has a wrong offset!");
static_assert(offsetof(FControlledMoveState, TargetActor) == 0x000088, "Member 'FControlledMoveState::TargetActor' has a wrong offset!");
static_assert(offsetof(FControlledMoveState, InitialDirection) == 0x0000A8, "Member 'FControlledMoveState::InitialDirection' has a wrong offset!");
static_assert(offsetof(FControlledMoveState, CurrentDirection) == 0x0000B4, "Member 'FControlledMoveState::CurrentDirection' has a wrong offset!");
static_assert(offsetof(FControlledMoveState, FrameMoveVelocity) == 0x0000F0, "Member 'FControlledMoveState::FrameMoveVelocity' has a wrong offset!");
static_assert(offsetof(FControlledMoveState, LastHitActor) == 0x000130, "Member 'FControlledMoveState::LastHitActor' has a wrong offset!");
static_assert(offsetof(FControlledMoveState, AForwardInput) == 0x00013C, "Member 'FControlledMoveState::AForwardInput' has a wrong offset!");
static_assert(offsetof(FControlledMoveState, AStrafeInput) == 0x000140, "Member 'FControlledMoveState::AStrafeInput' has a wrong offset!");

// ScriptStruct GbxGameSystemCore.LadderAnimState
// 0x0028 (0x0028 - 0x0000)
struct alignas(0x08) FLadderAnimState final
{
public:
	EScriptedLadderType                           PendingType;                                       // 0x0000(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1[0x1F];                                       // 0x0001(0x001F)(Fixing Size After Last Property [ Dumper-7 ])
	EScriptedLadderType                           CurrentType;                                       // 0x0020(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_21[0x7];                                       // 0x0021(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FLadderAnimState) == 0x000008, "Wrong alignment on FLadderAnimState");
static_assert(sizeof(FLadderAnimState) == 0x000028, "Wrong size on FLadderAnimState");
static_assert(offsetof(FLadderAnimState, PendingType) == 0x000000, "Member 'FLadderAnimState::PendingType' has a wrong offset!");
static_assert(offsetof(FLadderAnimState, CurrentType) == 0x000020, "Member 'FLadderAnimState::CurrentType' has a wrong offset!");

// ScriptStruct GbxGameSystemCore.ImpactAudioParam
// 0x0018 (0x0018 - 0x0000)
struct FImpactAudioParam final
{
public:
	class UWwiseRtpc*                             Parameter;                                         // 0x0000(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UWwiseSwitch*                           Switch;                                            // 0x0008(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         Value;                                             // 0x0010(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_14[0x4];                                       // 0x0014(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FImpactAudioParam) == 0x000008, "Wrong alignment on FImpactAudioParam");
static_assert(sizeof(FImpactAudioParam) == 0x000018, "Wrong size on FImpactAudioParam");
static_assert(offsetof(FImpactAudioParam, Parameter) == 0x000000, "Member 'FImpactAudioParam::Parameter' has a wrong offset!");
static_assert(offsetof(FImpactAudioParam, Switch) == 0x000008, "Member 'FImpactAudioParam::Switch' has a wrong offset!");
static_assert(offsetof(FImpactAudioParam, Value) == 0x000010, "Member 'FImpactAudioParam::Value' has a wrong offset!");

// ScriptStruct GbxGameSystemCore.CharacterMoveToState
// 0x0030 (0x0030 - 0x0000)
struct FCharacterMoveToState final
{
public:
	struct FCharacterMoveToCommand                CommandData;                                       // 0x0000(0x001C)(NoDestructor, NativeAccessSpecifierPublic)
	uint8                                         Pad_1C[0x14];                                      // 0x001C(0x0014)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FCharacterMoveToState) == 0x000004, "Wrong alignment on FCharacterMoveToState");
static_assert(sizeof(FCharacterMoveToState) == 0x000030, "Wrong size on FCharacterMoveToState");
static_assert(offsetof(FCharacterMoveToState, CommandData) == 0x000000, "Member 'FCharacterMoveToState::CommandData' has a wrong offset!");

// ScriptStruct GbxGameSystemCore.DamageReactionEvent
// 0x0050 (0x0050 - 0x0000)
struct FDamageReactionEvent final
{
public:
	class FName                                   EventName;                                         // 0x0000(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         EventHealthPercent;                                // 0x0008(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EDamageReactionEventType                      EVENTTYPE;                                         // 0x000C(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_D[0x3];                                        // 0x000D(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	class UDamageFilter*                          Filter;                                            // 0x0010(0x0008)(Edit, ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, PersistentInstance, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         DamageTime;                                        // 0x0018(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         RetriggerDelay;                                    // 0x001C(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         MaxTriggerCount;                                   // 0x0020(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_24[0x4];                                       // 0x0024(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class FName                                   DamageBoneName;                                    // 0x0028(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         bIncludeDamageBoneChildren : 1;                    // 0x0030(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (Edit, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         bCensored : 1;                                     // 0x0030(0x0001)(BitIndex: 0x01, PropSize: 0x0001 (Edit, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         bTriggerOnlyOnDeath : 1;                           // 0x0030(0x0001)(BitIndex: 0x02, PropSize: 0x0001 (Edit, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         Pad_31[0x1F];                                      // 0x0031(0x001F)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FDamageReactionEvent) == 0x000008, "Wrong alignment on FDamageReactionEvent");
static_assert(sizeof(FDamageReactionEvent) == 0x000050, "Wrong size on FDamageReactionEvent");
static_assert(offsetof(FDamageReactionEvent, EventName) == 0x000000, "Member 'FDamageReactionEvent::EventName' has a wrong offset!");
static_assert(offsetof(FDamageReactionEvent, EventHealthPercent) == 0x000008, "Member 'FDamageReactionEvent::EventHealthPercent' has a wrong offset!");
static_assert(offsetof(FDamageReactionEvent, EVENTTYPE) == 0x00000C, "Member 'FDamageReactionEvent::EVENTTYPE' has a wrong offset!");
static_assert(offsetof(FDamageReactionEvent, Filter) == 0x000010, "Member 'FDamageReactionEvent::Filter' has a wrong offset!");
static_assert(offsetof(FDamageReactionEvent, DamageTime) == 0x000018, "Member 'FDamageReactionEvent::DamageTime' has a wrong offset!");
static_assert(offsetof(FDamageReactionEvent, RetriggerDelay) == 0x00001C, "Member 'FDamageReactionEvent::RetriggerDelay' has a wrong offset!");
static_assert(offsetof(FDamageReactionEvent, MaxTriggerCount) == 0x000020, "Member 'FDamageReactionEvent::MaxTriggerCount' has a wrong offset!");
static_assert(offsetof(FDamageReactionEvent, DamageBoneName) == 0x000028, "Member 'FDamageReactionEvent::DamageBoneName' has a wrong offset!");

// ScriptStruct GbxGameSystemCore.LandingInfo
// 0x0028 (0x0028 - 0x0000)
struct FLandingInfo final
{
public:
	bool                                          bNoMinVelIfJumped;                                 // 0x0000(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1[0x3];                                        // 0x0001(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         LandedMinVel;                                      // 0x0004(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UImpactData*                            LandedImpact;                                      // 0x0008(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bPlayLandedImpactAtSpecificFeet;                   // 0x0010(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_11[0x7];                                       // 0x0011(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	TSubclassOf<class UGbxAction>                 LandedAction;                                      // 0x0018(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UCharacterSoundTag*                     VocalizationTag;                                   // 0x0020(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FLandingInfo) == 0x000008, "Wrong alignment on FLandingInfo");
static_assert(sizeof(FLandingInfo) == 0x000028, "Wrong size on FLandingInfo");
static_assert(offsetof(FLandingInfo, bNoMinVelIfJumped) == 0x000000, "Member 'FLandingInfo::bNoMinVelIfJumped' has a wrong offset!");
static_assert(offsetof(FLandingInfo, LandedMinVel) == 0x000004, "Member 'FLandingInfo::LandedMinVel' has a wrong offset!");
static_assert(offsetof(FLandingInfo, LandedImpact) == 0x000008, "Member 'FLandingInfo::LandedImpact' has a wrong offset!");
static_assert(offsetof(FLandingInfo, bPlayLandedImpactAtSpecificFeet) == 0x000010, "Member 'FLandingInfo::bPlayLandedImpactAtSpecificFeet' has a wrong offset!");
static_assert(offsetof(FLandingInfo, LandedAction) == 0x000018, "Member 'FLandingInfo::LandedAction' has a wrong offset!");
static_assert(offsetof(FLandingInfo, VocalizationTag) == 0x000020, "Member 'FLandingInfo::VocalizationTag' has a wrong offset!");

// ScriptStruct GbxGameSystemCore.HitReactionParams
// 0x0058 (0x0058 - 0x0000)
struct FHitReactionParams final
{
public:
	class UDamageComponent*                       Receiver;                                          // 0x0000(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UDamageCauserComponent*                 Causer;                                            // 0x0008(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         DamageAmount;                                      // 0x0010(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_14[0x4];                                       // 0x0014(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class UGbxDamageType*                         DamageType;                                        // 0x0018(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UDamageSource*                          DamageSource;                                      // 0x0020(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                Direction;                                         // 0x0028(0x000C)(IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         Force;                                             // 0x0034(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UHitRegionData*                         HitRegion;                                         // 0x0038(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         HitBoneIndex;                                      // 0x0040(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                HitLocation;                                       // 0x0044(0x000C)(IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bIgnoreCooldowns;                                  // 0x0050(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bForceInterruptSelf;                               // 0x0051(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_52[0x6];                                       // 0x0052(0x0006)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FHitReactionParams) == 0x000008, "Wrong alignment on FHitReactionParams");
static_assert(sizeof(FHitReactionParams) == 0x000058, "Wrong size on FHitReactionParams");
static_assert(offsetof(FHitReactionParams, Receiver) == 0x000000, "Member 'FHitReactionParams::Receiver' has a wrong offset!");
static_assert(offsetof(FHitReactionParams, Causer) == 0x000008, "Member 'FHitReactionParams::Causer' has a wrong offset!");
static_assert(offsetof(FHitReactionParams, DamageAmount) == 0x000010, "Member 'FHitReactionParams::DamageAmount' has a wrong offset!");
static_assert(offsetof(FHitReactionParams, DamageType) == 0x000018, "Member 'FHitReactionParams::DamageType' has a wrong offset!");
static_assert(offsetof(FHitReactionParams, DamageSource) == 0x000020, "Member 'FHitReactionParams::DamageSource' has a wrong offset!");
static_assert(offsetof(FHitReactionParams, Direction) == 0x000028, "Member 'FHitReactionParams::Direction' has a wrong offset!");
static_assert(offsetof(FHitReactionParams, Force) == 0x000034, "Member 'FHitReactionParams::Force' has a wrong offset!");
static_assert(offsetof(FHitReactionParams, HitRegion) == 0x000038, "Member 'FHitReactionParams::HitRegion' has a wrong offset!");
static_assert(offsetof(FHitReactionParams, HitBoneIndex) == 0x000040, "Member 'FHitReactionParams::HitBoneIndex' has a wrong offset!");
static_assert(offsetof(FHitReactionParams, HitLocation) == 0x000044, "Member 'FHitReactionParams::HitLocation' has a wrong offset!");
static_assert(offsetof(FHitReactionParams, bIgnoreCooldowns) == 0x000050, "Member 'FHitReactionParams::bIgnoreCooldowns' has a wrong offset!");
static_assert(offsetof(FHitReactionParams, bForceInterruptSelf) == 0x000051, "Member 'FHitReactionParams::bForceInterruptSelf' has a wrong offset!");

// ScriptStruct GbxGameSystemCore.HitReactionState
// 0x0290 (0x0290 - 0x0000)
struct FHitReactionState final
{
public:
	uint8                                         Pad_0[0x130];                                      // 0x0000(0x0130)(Fixing Size After Last Property [ Dumper-7 ])
	class UHitReactionData*                       HitReactionData;                                   // 0x0130(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	TArray<class UHitReactionTag*>                NoLockTags;                                        // 0x0138(0x0010)(Edit, ZeroConstructor, NativeAccessSpecifierPrivate)
	class UHitReactionTag*                        BackupDeathTag;                                    // 0x0148(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	TSubclassOf<class UGbxAction>                 DefaultDeathAction;                                // 0x0150(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	bool                                          bCensorDeaths;                                     // 0x0158(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_159[0x7];                                      // 0x0159(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	class UHitReactionData*                       CurrHitReactionData;                               // 0x0160(0x0008)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UDamageComponent*                       DamageComp;                                        // 0x0168(0x0008)(ExportObject, ZeroConstructor, Transient, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UAIDodgeComponent*                      DodgeComp;                                         // 0x0170(0x0008)(ExportObject, ZeroConstructor, Transient, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UGbxActionComponent*                    ActionComp;                                        // 0x0178(0x0008)(ExportObject, ZeroConstructor, Transient, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UBrainComponent*                        BrainComp;                                         // 0x0180(0x0008)(ExportObject, ZeroConstructor, Transient, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class FName                                   DeathOverrideId;                                   // 0x0188(0x0008)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UHitReactionTag*                        DeathOverride;                                     // 0x0190(0x0008)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	TArray<TSubclassOf<class UHitReactionLayer>>  LiveLayers;                                        // 0x0198(0x0010)(ZeroConstructor, Transient, UObjectWrapper, NativeAccessSpecifierPrivate)
	TArray<TSubclassOf<class UHitReactionLayer>>  DeathLayers;                                       // 0x01A8(0x0010)(ZeroConstructor, Transient, UObjectWrapper, NativeAccessSpecifierPrivate)
	TMap<class UHitReactionTag*, float>           TagTimeStartMap;                                   // 0x01B8(0x0050)(ZeroConstructor, Transient, NativeAccessSpecifierPrivate)
	TMap<class UHitReactionTag*, float>           TagTimeEndMap;                                     // 0x0208(0x0050)(ZeroConstructor, Transient, NativeAccessSpecifierPrivate)
	class UHitReactionTag*                        ActiveTag;                                         // 0x0258(0x0008)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_260[0x10];                                     // 0x0260(0x0010)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<struct FHitReactionParams>             Hits;                                              // 0x0270(0x0010)(ZeroConstructor, Transient, ContainsInstancedReference, NativeAccessSpecifierPrivate)
	class AGbxCharacter*                          SoundCharacter;                                    // 0x0280(0x0008)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_288[0x8];                                      // 0x0288(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FHitReactionState) == 0x000008, "Wrong alignment on FHitReactionState");
static_assert(sizeof(FHitReactionState) == 0x000290, "Wrong size on FHitReactionState");
static_assert(offsetof(FHitReactionState, HitReactionData) == 0x000130, "Member 'FHitReactionState::HitReactionData' has a wrong offset!");
static_assert(offsetof(FHitReactionState, NoLockTags) == 0x000138, "Member 'FHitReactionState::NoLockTags' has a wrong offset!");
static_assert(offsetof(FHitReactionState, BackupDeathTag) == 0x000148, "Member 'FHitReactionState::BackupDeathTag' has a wrong offset!");
static_assert(offsetof(FHitReactionState, DefaultDeathAction) == 0x000150, "Member 'FHitReactionState::DefaultDeathAction' has a wrong offset!");
static_assert(offsetof(FHitReactionState, bCensorDeaths) == 0x000158, "Member 'FHitReactionState::bCensorDeaths' has a wrong offset!");
static_assert(offsetof(FHitReactionState, CurrHitReactionData) == 0x000160, "Member 'FHitReactionState::CurrHitReactionData' has a wrong offset!");
static_assert(offsetof(FHitReactionState, DamageComp) == 0x000168, "Member 'FHitReactionState::DamageComp' has a wrong offset!");
static_assert(offsetof(FHitReactionState, DodgeComp) == 0x000170, "Member 'FHitReactionState::DodgeComp' has a wrong offset!");
static_assert(offsetof(FHitReactionState, ActionComp) == 0x000178, "Member 'FHitReactionState::ActionComp' has a wrong offset!");
static_assert(offsetof(FHitReactionState, BrainComp) == 0x000180, "Member 'FHitReactionState::BrainComp' has a wrong offset!");
static_assert(offsetof(FHitReactionState, DeathOverrideId) == 0x000188, "Member 'FHitReactionState::DeathOverrideId' has a wrong offset!");
static_assert(offsetof(FHitReactionState, DeathOverride) == 0x000190, "Member 'FHitReactionState::DeathOverride' has a wrong offset!");
static_assert(offsetof(FHitReactionState, LiveLayers) == 0x000198, "Member 'FHitReactionState::LiveLayers' has a wrong offset!");
static_assert(offsetof(FHitReactionState, DeathLayers) == 0x0001A8, "Member 'FHitReactionState::DeathLayers' has a wrong offset!");
static_assert(offsetof(FHitReactionState, TagTimeStartMap) == 0x0001B8, "Member 'FHitReactionState::TagTimeStartMap' has a wrong offset!");
static_assert(offsetof(FHitReactionState, TagTimeEndMap) == 0x000208, "Member 'FHitReactionState::TagTimeEndMap' has a wrong offset!");
static_assert(offsetof(FHitReactionState, ActiveTag) == 0x000258, "Member 'FHitReactionState::ActiveTag' has a wrong offset!");
static_assert(offsetof(FHitReactionState, Hits) == 0x000270, "Member 'FHitReactionState::Hits' has a wrong offset!");
static_assert(offsetof(FHitReactionState, SoundCharacter) == 0x000280, "Member 'FHitReactionState::SoundCharacter' has a wrong offset!");

// ScriptStruct GbxGameSystemCore.GestaltPartFoleyAccessory
// 0x0018 (0x0018 - 0x0000)
struct FGestaltPartFoleyAccessory final
{
public:
	int32                                         Priority;                                          // 0x0000(0x0004)(Edit, ZeroConstructor, DisableEditOnTemplate, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_4[0x4];                                        // 0x0004(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class UWwiseEvent*                            WwiseEvent;                                        // 0x0008(0x0008)(Edit, ZeroConstructor, DisableEditOnTemplate, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   AttachmentPoint;                                   // 0x0010(0x0008)(Edit, ZeroConstructor, DisableEditOnTemplate, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FGestaltPartFoleyAccessory) == 0x000008, "Wrong alignment on FGestaltPartFoleyAccessory");
static_assert(sizeof(FGestaltPartFoleyAccessory) == 0x000018, "Wrong size on FGestaltPartFoleyAccessory");
static_assert(offsetof(FGestaltPartFoleyAccessory, Priority) == 0x000000, "Member 'FGestaltPartFoleyAccessory::Priority' has a wrong offset!");
static_assert(offsetof(FGestaltPartFoleyAccessory, WwiseEvent) == 0x000008, "Member 'FGestaltPartFoleyAccessory::WwiseEvent' has a wrong offset!");
static_assert(offsetof(FGestaltPartFoleyAccessory, AttachmentPoint) == 0x000010, "Member 'FGestaltPartFoleyAccessory::AttachmentPoint' has a wrong offset!");

// ScriptStruct GbxGameSystemCore.StatusEffectModifiers
// 0x0030 (0x0030 - 0x0000)
struct FStatusEffectModifiers final
{
public:
	class UStatusEffectData*                      StatusEffectData;                                  // 0x0000(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FGbxAttributeFloat                     EffectChanceModifier;                              // 0x0008(0x000C)(Edit, BlueprintVisible, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FGbxAttributeFloat                     EffectDurationModifier;                            // 0x0014(0x000C)(Edit, BlueprintVisible, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FGbxAttributeFloat                     EffectDamageModifier;                              // 0x0020(0x000C)(Edit, BlueprintVisible, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2C[0x4];                                       // 0x002C(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FStatusEffectModifiers) == 0x000008, "Wrong alignment on FStatusEffectModifiers");
static_assert(sizeof(FStatusEffectModifiers) == 0x000030, "Wrong size on FStatusEffectModifiers");
static_assert(offsetof(FStatusEffectModifiers, StatusEffectData) == 0x000000, "Member 'FStatusEffectModifiers::StatusEffectData' has a wrong offset!");
static_assert(offsetof(FStatusEffectModifiers, EffectChanceModifier) == 0x000008, "Member 'FStatusEffectModifiers::EffectChanceModifier' has a wrong offset!");
static_assert(offsetof(FStatusEffectModifiers, EffectDurationModifier) == 0x000014, "Member 'FStatusEffectModifiers::EffectDurationModifier' has a wrong offset!");
static_assert(offsetof(FStatusEffectModifiers, EffectDamageModifier) == 0x000020, "Member 'FStatusEffectModifiers::EffectDamageModifier' has a wrong offset!");

// ScriptStruct GbxGameSystemCore.ReceivedDamageDetails
// 0x0058 (0x0058 - 0x0000)
struct FReceivedDamageDetails final
{
public:
	bool                                          bWasCrit;                                          // 0x0000(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1[0x3];                                        // 0x0001(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	struct FVector                                HitLocation;                                       // 0x0004(0x000C)(BlueprintVisible, BlueprintReadOnly, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                HitDirection;                                      // 0x0010(0x000C)(BlueprintVisible, BlueprintReadOnly, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1C[0x4];                                       // 0x001C(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class UPrimitiveComponent*                    HitComponent;                                      // 0x0020(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UHitRegionData*                         HitRegion;                                         // 0x0028(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TArray<struct FHealthTypeDamageSummary>       DamagePerHealthType;                               // 0x0030(0x0010)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, NativeAccessSpecifierPublic)
	struct FVector                                RadiusDamageOrigin;                                // 0x0040(0x000C)(BlueprintVisible, BlueprintReadOnly, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         DamageRadius;                                      // 0x004C(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bWasBulletReflected;                               // 0x0050(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_51[0x7];                                       // 0x0051(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FReceivedDamageDetails) == 0x000008, "Wrong alignment on FReceivedDamageDetails");
static_assert(sizeof(FReceivedDamageDetails) == 0x000058, "Wrong size on FReceivedDamageDetails");
static_assert(offsetof(FReceivedDamageDetails, bWasCrit) == 0x000000, "Member 'FReceivedDamageDetails::bWasCrit' has a wrong offset!");
static_assert(offsetof(FReceivedDamageDetails, HitLocation) == 0x000004, "Member 'FReceivedDamageDetails::HitLocation' has a wrong offset!");
static_assert(offsetof(FReceivedDamageDetails, HitDirection) == 0x000010, "Member 'FReceivedDamageDetails::HitDirection' has a wrong offset!");
static_assert(offsetof(FReceivedDamageDetails, HitComponent) == 0x000020, "Member 'FReceivedDamageDetails::HitComponent' has a wrong offset!");
static_assert(offsetof(FReceivedDamageDetails, HitRegion) == 0x000028, "Member 'FReceivedDamageDetails::HitRegion' has a wrong offset!");
static_assert(offsetof(FReceivedDamageDetails, DamagePerHealthType) == 0x000030, "Member 'FReceivedDamageDetails::DamagePerHealthType' has a wrong offset!");
static_assert(offsetof(FReceivedDamageDetails, RadiusDamageOrigin) == 0x000040, "Member 'FReceivedDamageDetails::RadiusDamageOrigin' has a wrong offset!");
static_assert(offsetof(FReceivedDamageDetails, DamageRadius) == 0x00004C, "Member 'FReceivedDamageDetails::DamageRadius' has a wrong offset!");
static_assert(offsetof(FReceivedDamageDetails, bWasBulletReflected) == 0x000050, "Member 'FReceivedDamageDetails::bWasBulletReflected' has a wrong offset!");

// ScriptStruct GbxGameSystemCore.ForwardDynamicsNodeProfile
// 0x0078 (0x0078 - 0x0000)
struct FForwardDynamicsNodeProfile final
{
public:
	class UPhysicalAnimationProfileAsset*         ForwardDynamicsProfile;                            // 0x0000(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EForwardDynamicsActivation                    ForwardDynamicsActivation;                         // 0x0008(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_C[0x4];                                        // 0x000C(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class FName                                   PhysicsAssetStrengthDefinitionProfileName;         // 0x0010(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         TargetSimulationFrequency;                         // 0x0018(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         MaxSubstepCount;                                   // 0x001C(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         MaxTranslationDistanceUntilReset;                  // 0x0020(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         LinearJointDivergentTolerence;                     // 0x0024(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         WorldSpaceVelocityBlend;                           // 0x0028(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         WorldSpaceAngularVelocityBlend;                    // 0x002C(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bBypassSkelMeshSimulatePhysOption;                 // 0x0030(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bStripAnimationFromNonSimulationRelevantBones;     // 0x0031(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_32[0x6];                                       // 0x0032(0x0006)(Fixing Size After Last Property [ Dumper-7 ])
	class UPhysicsAsset*                          OverridePhysicsAsset;                              // 0x0038(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                OverrideWorldGravity;                              // 0x0040(0x000C)(Edit, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                ExternalForce;                                     // 0x004C(0x000C)(Edit, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	ECollisionChannel                             OverlapChannel;                                    // 0x0058(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bEnableWorldGeometry;                              // 0x0059(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_5A[0x2];                                       // 0x005A(0x0002)(Fixing Size After Last Property [ Dumper-7 ])
	ESimulationSpace                              SimulationSpace;                                   // 0x005C(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bOverrideWorldGravity;                             // 0x0060(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_61[0x3];                                       // 0x0061(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         CachedBoundsScale;                                 // 0x0064(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bTransferBoneVelocities;                           // 0x0068(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bFreezeIncomingPoseOnStart;                        // 0x0069(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_6A[0x2];                                       // 0x006A(0x0002)(Fixing Size After Last Property [ Dumper-7 ])
	int32                                         LODThreshold;                                      // 0x006C(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         LODInterpolationSpeed;                             // 0x0070(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_74[0x4];                                       // 0x0074(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FForwardDynamicsNodeProfile) == 0x000008, "Wrong alignment on FForwardDynamicsNodeProfile");
static_assert(sizeof(FForwardDynamicsNodeProfile) == 0x000078, "Wrong size on FForwardDynamicsNodeProfile");
static_assert(offsetof(FForwardDynamicsNodeProfile, ForwardDynamicsProfile) == 0x000000, "Member 'FForwardDynamicsNodeProfile::ForwardDynamicsProfile' has a wrong offset!");
static_assert(offsetof(FForwardDynamicsNodeProfile, ForwardDynamicsActivation) == 0x000008, "Member 'FForwardDynamicsNodeProfile::ForwardDynamicsActivation' has a wrong offset!");
static_assert(offsetof(FForwardDynamicsNodeProfile, PhysicsAssetStrengthDefinitionProfileName) == 0x000010, "Member 'FForwardDynamicsNodeProfile::PhysicsAssetStrengthDefinitionProfileName' has a wrong offset!");
static_assert(offsetof(FForwardDynamicsNodeProfile, TargetSimulationFrequency) == 0x000018, "Member 'FForwardDynamicsNodeProfile::TargetSimulationFrequency' has a wrong offset!");
static_assert(offsetof(FForwardDynamicsNodeProfile, MaxSubstepCount) == 0x00001C, "Member 'FForwardDynamicsNodeProfile::MaxSubstepCount' has a wrong offset!");
static_assert(offsetof(FForwardDynamicsNodeProfile, MaxTranslationDistanceUntilReset) == 0x000020, "Member 'FForwardDynamicsNodeProfile::MaxTranslationDistanceUntilReset' has a wrong offset!");
static_assert(offsetof(FForwardDynamicsNodeProfile, LinearJointDivergentTolerence) == 0x000024, "Member 'FForwardDynamicsNodeProfile::LinearJointDivergentTolerence' has a wrong offset!");
static_assert(offsetof(FForwardDynamicsNodeProfile, WorldSpaceVelocityBlend) == 0x000028, "Member 'FForwardDynamicsNodeProfile::WorldSpaceVelocityBlend' has a wrong offset!");
static_assert(offsetof(FForwardDynamicsNodeProfile, WorldSpaceAngularVelocityBlend) == 0x00002C, "Member 'FForwardDynamicsNodeProfile::WorldSpaceAngularVelocityBlend' has a wrong offset!");
static_assert(offsetof(FForwardDynamicsNodeProfile, bBypassSkelMeshSimulatePhysOption) == 0x000030, "Member 'FForwardDynamicsNodeProfile::bBypassSkelMeshSimulatePhysOption' has a wrong offset!");
static_assert(offsetof(FForwardDynamicsNodeProfile, bStripAnimationFromNonSimulationRelevantBones) == 0x000031, "Member 'FForwardDynamicsNodeProfile::bStripAnimationFromNonSimulationRelevantBones' has a wrong offset!");
static_assert(offsetof(FForwardDynamicsNodeProfile, OverridePhysicsAsset) == 0x000038, "Member 'FForwardDynamicsNodeProfile::OverridePhysicsAsset' has a wrong offset!");
static_assert(offsetof(FForwardDynamicsNodeProfile, OverrideWorldGravity) == 0x000040, "Member 'FForwardDynamicsNodeProfile::OverrideWorldGravity' has a wrong offset!");
static_assert(offsetof(FForwardDynamicsNodeProfile, ExternalForce) == 0x00004C, "Member 'FForwardDynamicsNodeProfile::ExternalForce' has a wrong offset!");
static_assert(offsetof(FForwardDynamicsNodeProfile, OverlapChannel) == 0x000058, "Member 'FForwardDynamicsNodeProfile::OverlapChannel' has a wrong offset!");
static_assert(offsetof(FForwardDynamicsNodeProfile, bEnableWorldGeometry) == 0x000059, "Member 'FForwardDynamicsNodeProfile::bEnableWorldGeometry' has a wrong offset!");
static_assert(offsetof(FForwardDynamicsNodeProfile, SimulationSpace) == 0x00005C, "Member 'FForwardDynamicsNodeProfile::SimulationSpace' has a wrong offset!");
static_assert(offsetof(FForwardDynamicsNodeProfile, bOverrideWorldGravity) == 0x000060, "Member 'FForwardDynamicsNodeProfile::bOverrideWorldGravity' has a wrong offset!");
static_assert(offsetof(FForwardDynamicsNodeProfile, CachedBoundsScale) == 0x000064, "Member 'FForwardDynamicsNodeProfile::CachedBoundsScale' has a wrong offset!");
static_assert(offsetof(FForwardDynamicsNodeProfile, bTransferBoneVelocities) == 0x000068, "Member 'FForwardDynamicsNodeProfile::bTransferBoneVelocities' has a wrong offset!");
static_assert(offsetof(FForwardDynamicsNodeProfile, bFreezeIncomingPoseOnStart) == 0x000069, "Member 'FForwardDynamicsNodeProfile::bFreezeIncomingPoseOnStart' has a wrong offset!");
static_assert(offsetof(FForwardDynamicsNodeProfile, LODThreshold) == 0x00006C, "Member 'FForwardDynamicsNodeProfile::LODThreshold' has a wrong offset!");
static_assert(offsetof(FForwardDynamicsNodeProfile, LODInterpolationSpeed) == 0x000070, "Member 'FForwardDynamicsNodeProfile::LODInterpolationSpeed' has a wrong offset!");

// ScriptStruct GbxGameSystemCore.PhysicalMaterialImpactPair
// 0x0010 (0x0010 - 0x0000)
struct FPhysicalMaterialImpactPair final
{
public:
	class UPhysicalMaterial*                      MaterialA;                                         // 0x0000(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UPhysicalMaterial*                      MaterialB;                                         // 0x0008(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FPhysicalMaterialImpactPair) == 0x000008, "Wrong alignment on FPhysicalMaterialImpactPair");
static_assert(sizeof(FPhysicalMaterialImpactPair) == 0x000010, "Wrong size on FPhysicalMaterialImpactPair");
static_assert(offsetof(FPhysicalMaterialImpactPair, MaterialA) == 0x000000, "Member 'FPhysicalMaterialImpactPair::MaterialA' has a wrong offset!");
static_assert(offsetof(FPhysicalMaterialImpactPair, MaterialB) == 0x000008, "Member 'FPhysicalMaterialImpactPair::MaterialB' has a wrong offset!");

// ScriptStruct GbxGameSystemCore.CausedHealingDetails
// 0x0028 (0x0028 - 0x0000)
struct FCausedHealingDetails final
{
public:
	class AActor*                                 HealTarget;                                        // 0x0000(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class AActor*                                 HealInstigator;                                    // 0x0008(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         Healing;                                           // 0x0010(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_14[0x4];                                       // 0x0014(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class UDamageSource*                          DamageSource;                                      // 0x0018(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UGbxDamageType*                         DamageType;                                        // 0x0020(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FCausedHealingDetails) == 0x000008, "Wrong alignment on FCausedHealingDetails");
static_assert(sizeof(FCausedHealingDetails) == 0x000028, "Wrong size on FCausedHealingDetails");
static_assert(offsetof(FCausedHealingDetails, HealTarget) == 0x000000, "Member 'FCausedHealingDetails::HealTarget' has a wrong offset!");
static_assert(offsetof(FCausedHealingDetails, HealInstigator) == 0x000008, "Member 'FCausedHealingDetails::HealInstigator' has a wrong offset!");
static_assert(offsetof(FCausedHealingDetails, Healing) == 0x000010, "Member 'FCausedHealingDetails::Healing' has a wrong offset!");
static_assert(offsetof(FCausedHealingDetails, DamageSource) == 0x000018, "Member 'FCausedHealingDetails::DamageSource' has a wrong offset!");
static_assert(offsetof(FCausedHealingDetails, DamageType) == 0x000020, "Member 'FCausedHealingDetails::DamageType' has a wrong offset!");

// ScriptStruct GbxGameSystemCore.DamageContextSource
// 0x0010 (0x0010 - 0x0000)
struct FDamageContextSource final
{
public:
	class AActor*                                 SourceActor;                                       // 0x0000(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class APawn*                                  Instigator;                                        // 0x0008(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FDamageContextSource) == 0x000008, "Wrong alignment on FDamageContextSource");
static_assert(sizeof(FDamageContextSource) == 0x000010, "Wrong size on FDamageContextSource");
static_assert(offsetof(FDamageContextSource, SourceActor) == 0x000000, "Member 'FDamageContextSource::SourceActor' has a wrong offset!");
static_assert(offsetof(FDamageContextSource, Instigator) == 0x000008, "Member 'FDamageContextSource::Instigator' has a wrong offset!");

// ScriptStruct GbxGameSystemCore.HitFriendlyEventDetails
// 0x0020 (0x0020 - 0x0000)
struct FHitFriendlyEventDetails final
{
public:
	class AActor*                                 HitTarget;                                         // 0x0000(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class AActor*                                 HitInstigator;                                     // 0x0008(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UDamageSource*                          DamageSource;                                      // 0x0010(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UGbxDamageType*                         DamageType;                                        // 0x0018(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FHitFriendlyEventDetails) == 0x000008, "Wrong alignment on FHitFriendlyEventDetails");
static_assert(sizeof(FHitFriendlyEventDetails) == 0x000020, "Wrong size on FHitFriendlyEventDetails");
static_assert(offsetof(FHitFriendlyEventDetails, HitTarget) == 0x000000, "Member 'FHitFriendlyEventDetails::HitTarget' has a wrong offset!");
static_assert(offsetof(FHitFriendlyEventDetails, HitInstigator) == 0x000008, "Member 'FHitFriendlyEventDetails::HitInstigator' has a wrong offset!");
static_assert(offsetof(FHitFriendlyEventDetails, DamageSource) == 0x000010, "Member 'FHitFriendlyEventDetails::DamageSource' has a wrong offset!");
static_assert(offsetof(FHitFriendlyEventDetails, DamageType) == 0x000018, "Member 'FHitFriendlyEventDetails::DamageType' has a wrong offset!");

// ScriptStruct GbxGameSystemCore.HitByFriendlyEventDetails
// 0x0018 (0x0018 - 0x0000)
struct FHitByFriendlyEventDetails final
{
public:
	class AActor*                                 DamageInstigator;                                  // 0x0000(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UGbxDamageType*                         DamageType;                                        // 0x0008(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UDamageSource*                          DamageSource;                                      // 0x0010(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FHitByFriendlyEventDetails) == 0x000008, "Wrong alignment on FHitByFriendlyEventDetails");
static_assert(sizeof(FHitByFriendlyEventDetails) == 0x000018, "Wrong size on FHitByFriendlyEventDetails");
static_assert(offsetof(FHitByFriendlyEventDetails, DamageInstigator) == 0x000000, "Member 'FHitByFriendlyEventDetails::DamageInstigator' has a wrong offset!");
static_assert(offsetof(FHitByFriendlyEventDetails, DamageType) == 0x000008, "Member 'FHitByFriendlyEventDetails::DamageType' has a wrong offset!");
static_assert(offsetof(FHitByFriendlyEventDetails, DamageSource) == 0x000010, "Member 'FHitByFriendlyEventDetails::DamageSource' has a wrong offset!");

// ScriptStruct GbxGameSystemCore.PlayerDamageDataPresentation
// 0x0018 (0x0018 - 0x0000)
struct FPlayerDamageDataPresentation final
{
public:
	class UParticleSystem*                        ScreenParticle;                                    // 0x0000(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector_NetQuantizeNormal              HitDirection;                                      // 0x0008(0x000C)(NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_14[0x4];                                       // 0x0014(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FPlayerDamageDataPresentation) == 0x000008, "Wrong alignment on FPlayerDamageDataPresentation");
static_assert(sizeof(FPlayerDamageDataPresentation) == 0x000018, "Wrong size on FPlayerDamageDataPresentation");
static_assert(offsetof(FPlayerDamageDataPresentation, ScreenParticle) == 0x000000, "Member 'FPlayerDamageDataPresentation::ScreenParticle' has a wrong offset!");
static_assert(offsetof(FPlayerDamageDataPresentation, HitDirection) == 0x000008, "Member 'FPlayerDamageDataPresentation::HitDirection' has a wrong offset!");

// ScriptStruct GbxGameSystemCore.DistanceMatchingInfo
// 0x0070 (0x0070 - 0x0000)
struct FDistanceMatchingInfo
{
public:
	TMap<int32, struct FFloatCurve>               DistanceCurveMap;                                  // 0x0000(0x0050)(ZeroConstructor, NativeAccessSpecifierPublic)
	uint8                                         Pad_50[0x20];                                      // 0x0050(0x0020)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FDistanceMatchingInfo) == 0x000008, "Wrong alignment on FDistanceMatchingInfo");
static_assert(sizeof(FDistanceMatchingInfo) == 0x000070, "Wrong size on FDistanceMatchingInfo");
static_assert(offsetof(FDistanceMatchingInfo, DistanceCurveMap) == 0x000000, "Member 'FDistanceMatchingInfo::DistanceCurveMap' has a wrong offset!");

// ScriptStruct GbxGameSystemCore.ActiveTrackedFeedback
// 0x0060 (0x0060 - 0x0000)
struct FActiveTrackedFeedback final
{
public:
	class UFeedbackData*                          FeedbackData;                                      // 0x0000(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         LastStartTime;                                     // 0x0008(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         LastRandomShakeTime;                               // 0x000C(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         RandomCameraShake;                                 // 0x0010(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         BaseScale;                                         // 0x0014(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         CurrentScale;                                      // 0x0018(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         CurrentCameraShakeScale;                           // 0x001C(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         CameraShakeXScale;                                 // 0x0020(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         CameraShakeYScale;                                 // 0x0024(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                SourceLocation;                                    // 0x0028(0x000C)(IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FRangedDistanceOverrides               RangedDistanceOverrides;                           // 0x0034(0x000C)(NoDestructor, NativeAccessSpecifierPublic)
	bool                                          bRumbleFinished;                                   // 0x0040(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bShakeFinished;                                    // 0x0041(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_42[0x6];                                       // 0x0042(0x0006)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<float>                                 AdditionalCameraShakeScales;                       // 0x0048(0x0010)(ZeroConstructor, NativeAccessSpecifierPublic)
	TWeakObjectPtr<class UObject>                 SourceContext;                                     // 0x0058(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FActiveTrackedFeedback) == 0x000008, "Wrong alignment on FActiveTrackedFeedback");
static_assert(sizeof(FActiveTrackedFeedback) == 0x000060, "Wrong size on FActiveTrackedFeedback");
static_assert(offsetof(FActiveTrackedFeedback, FeedbackData) == 0x000000, "Member 'FActiveTrackedFeedback::FeedbackData' has a wrong offset!");
static_assert(offsetof(FActiveTrackedFeedback, LastStartTime) == 0x000008, "Member 'FActiveTrackedFeedback::LastStartTime' has a wrong offset!");
static_assert(offsetof(FActiveTrackedFeedback, LastRandomShakeTime) == 0x00000C, "Member 'FActiveTrackedFeedback::LastRandomShakeTime' has a wrong offset!");
static_assert(offsetof(FActiveTrackedFeedback, RandomCameraShake) == 0x000010, "Member 'FActiveTrackedFeedback::RandomCameraShake' has a wrong offset!");
static_assert(offsetof(FActiveTrackedFeedback, BaseScale) == 0x000014, "Member 'FActiveTrackedFeedback::BaseScale' has a wrong offset!");
static_assert(offsetof(FActiveTrackedFeedback, CurrentScale) == 0x000018, "Member 'FActiveTrackedFeedback::CurrentScale' has a wrong offset!");
static_assert(offsetof(FActiveTrackedFeedback, CurrentCameraShakeScale) == 0x00001C, "Member 'FActiveTrackedFeedback::CurrentCameraShakeScale' has a wrong offset!");
static_assert(offsetof(FActiveTrackedFeedback, CameraShakeXScale) == 0x000020, "Member 'FActiveTrackedFeedback::CameraShakeXScale' has a wrong offset!");
static_assert(offsetof(FActiveTrackedFeedback, CameraShakeYScale) == 0x000024, "Member 'FActiveTrackedFeedback::CameraShakeYScale' has a wrong offset!");
static_assert(offsetof(FActiveTrackedFeedback, SourceLocation) == 0x000028, "Member 'FActiveTrackedFeedback::SourceLocation' has a wrong offset!");
static_assert(offsetof(FActiveTrackedFeedback, RangedDistanceOverrides) == 0x000034, "Member 'FActiveTrackedFeedback::RangedDistanceOverrides' has a wrong offset!");
static_assert(offsetof(FActiveTrackedFeedback, bRumbleFinished) == 0x000040, "Member 'FActiveTrackedFeedback::bRumbleFinished' has a wrong offset!");
static_assert(offsetof(FActiveTrackedFeedback, bShakeFinished) == 0x000041, "Member 'FActiveTrackedFeedback::bShakeFinished' has a wrong offset!");
static_assert(offsetof(FActiveTrackedFeedback, AdditionalCameraShakeScales) == 0x000048, "Member 'FActiveTrackedFeedback::AdditionalCameraShakeScales' has a wrong offset!");
static_assert(offsetof(FActiveTrackedFeedback, SourceContext) == 0x000058, "Member 'FActiveTrackedFeedback::SourceContext' has a wrong offset!");

// ScriptStruct GbxGameSystemCore.CriticalHitDamageOverrides
// 0x0008 (0x0008 - 0x0000)
struct FCriticalHitDamageOverrides final
{
public:
	ECriticalHitDamageOverride                    Type;                                              // 0x0000(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bUseDefaultCriticalHitMultiplier;                  // 0x0001(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2[0x2];                                        // 0x0002(0x0002)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         AdditionalCriticalMultiplier;                      // 0x0004(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FCriticalHitDamageOverrides) == 0x000004, "Wrong alignment on FCriticalHitDamageOverrides");
static_assert(sizeof(FCriticalHitDamageOverrides) == 0x000008, "Wrong size on FCriticalHitDamageOverrides");
static_assert(offsetof(FCriticalHitDamageOverrides, Type) == 0x000000, "Member 'FCriticalHitDamageOverrides::Type' has a wrong offset!");
static_assert(offsetof(FCriticalHitDamageOverrides, bUseDefaultCriticalHitMultiplier) == 0x000001, "Member 'FCriticalHitDamageOverrides::bUseDefaultCriticalHitMultiplier' has a wrong offset!");
static_assert(offsetof(FCriticalHitDamageOverrides, AdditionalCriticalMultiplier) == 0x000004, "Member 'FCriticalHitDamageOverrides::AdditionalCriticalMultiplier' has a wrong offset!");

// ScriptStruct GbxGameSystemCore.DamageInfo
// 0x0058 (0x0058 - 0x0000)
struct FDamageInfo final
{
public:
	float                                         Damage;                                            // 0x0000(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, RepSkip, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_4[0x4];                                        // 0x0004(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	TSubclassOf<class UGbxDamageType>             DamageType;                                        // 0x0008(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TSubclassOf<class UDamageSource>              DamageSource;                                      // 0x0010(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, RepSkip, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         DamageRadius;                                      // 0x0018(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         ImpactForce;                                       // 0x001C(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UFeedbackData*                          InstigatorFeedback;                                // 0x0020(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, RepSkip, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UDamageModifierComponent*               DamageModifierComponent;                           // 0x0028(0x0008)(Edit, BlueprintVisible, ExportObject, ZeroConstructor, EditConst, InstancedReference, IsPlainOldData, RepSkip, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class AActor*                                 DamageCauser;                                      // 0x0030(0x0008)(Edit, BlueprintVisible, ZeroConstructor, EditConst, IsPlainOldData, RepSkip, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TArray<class AActor*>                         ActorsToIgnore;                                    // 0x0038(0x0010)(Edit, BlueprintVisible, ZeroConstructor, EditConst, RepSkip, NativeAccessSpecifierPublic)
	bool                                          bApplyCriticalHitModsToAoEDamage;                  // 0x0048(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, RepSkip, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_49[0x3];                                       // 0x0049(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	struct FCriticalHitDamageOverrides            CriticalHitOverrides;                              // 0x004C(0x0008)(Edit, BlueprintVisible, RepSkip, NoDestructor, NativeAccessSpecifierPublic)
	uint8                                         Pad_54[0x4];                                       // 0x0054(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FDamageInfo) == 0x000008, "Wrong alignment on FDamageInfo");
static_assert(sizeof(FDamageInfo) == 0x000058, "Wrong size on FDamageInfo");
static_assert(offsetof(FDamageInfo, Damage) == 0x000000, "Member 'FDamageInfo::Damage' has a wrong offset!");
static_assert(offsetof(FDamageInfo, DamageType) == 0x000008, "Member 'FDamageInfo::DamageType' has a wrong offset!");
static_assert(offsetof(FDamageInfo, DamageSource) == 0x000010, "Member 'FDamageInfo::DamageSource' has a wrong offset!");
static_assert(offsetof(FDamageInfo, DamageRadius) == 0x000018, "Member 'FDamageInfo::DamageRadius' has a wrong offset!");
static_assert(offsetof(FDamageInfo, ImpactForce) == 0x00001C, "Member 'FDamageInfo::ImpactForce' has a wrong offset!");
static_assert(offsetof(FDamageInfo, InstigatorFeedback) == 0x000020, "Member 'FDamageInfo::InstigatorFeedback' has a wrong offset!");
static_assert(offsetof(FDamageInfo, DamageModifierComponent) == 0x000028, "Member 'FDamageInfo::DamageModifierComponent' has a wrong offset!");
static_assert(offsetof(FDamageInfo, DamageCauser) == 0x000030, "Member 'FDamageInfo::DamageCauser' has a wrong offset!");
static_assert(offsetof(FDamageInfo, ActorsToIgnore) == 0x000038, "Member 'FDamageInfo::ActorsToIgnore' has a wrong offset!");
static_assert(offsetof(FDamageInfo, bApplyCriticalHitModsToAoEDamage) == 0x000048, "Member 'FDamageInfo::bApplyCriticalHitModsToAoEDamage' has a wrong offset!");
static_assert(offsetof(FDamageInfo, CriticalHitOverrides) == 0x00004C, "Member 'FDamageInfo::CriticalHitOverrides' has a wrong offset!");

// ScriptStruct GbxGameSystemCore.StatusEffectSpec
// 0x0038 (0x0038 - 0x0000)
struct FStatusEffectSpec final
{
public:
	class UStatusEffectData*                      StatusEffectData;                                  // 0x0000(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TWeakObjectPtr<class UObject>                 EffectOwner;                                       // 0x0008(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TWeakObjectPtr<class UObject>                 EffectOwnerContextOverride;                        // 0x0010(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EStatusEffectDurationType                     DurationType;                                      // 0x0018(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_19[0x3];                                       // 0x0019(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         Duration;                                          // 0x001C(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class AController*                            EffectInstigator;                                  // 0x0020(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class AActor*                                 DamageCauser;                                      // 0x0028(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         DamagePerSecond;                                   // 0x0030(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_34[0x4];                                       // 0x0034(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FStatusEffectSpec) == 0x000008, "Wrong alignment on FStatusEffectSpec");
static_assert(sizeof(FStatusEffectSpec) == 0x000038, "Wrong size on FStatusEffectSpec");
static_assert(offsetof(FStatusEffectSpec, StatusEffectData) == 0x000000, "Member 'FStatusEffectSpec::StatusEffectData' has a wrong offset!");
static_assert(offsetof(FStatusEffectSpec, EffectOwner) == 0x000008, "Member 'FStatusEffectSpec::EffectOwner' has a wrong offset!");
static_assert(offsetof(FStatusEffectSpec, EffectOwnerContextOverride) == 0x000010, "Member 'FStatusEffectSpec::EffectOwnerContextOverride' has a wrong offset!");
static_assert(offsetof(FStatusEffectSpec, DurationType) == 0x000018, "Member 'FStatusEffectSpec::DurationType' has a wrong offset!");
static_assert(offsetof(FStatusEffectSpec, Duration) == 0x00001C, "Member 'FStatusEffectSpec::Duration' has a wrong offset!");
static_assert(offsetof(FStatusEffectSpec, EffectInstigator) == 0x000020, "Member 'FStatusEffectSpec::EffectInstigator' has a wrong offset!");
static_assert(offsetof(FStatusEffectSpec, DamageCauser) == 0x000028, "Member 'FStatusEffectSpec::DamageCauser' has a wrong offset!");
static_assert(offsetof(FStatusEffectSpec, DamagePerSecond) == 0x000030, "Member 'FStatusEffectSpec::DamagePerSecond' has a wrong offset!");

// ScriptStruct GbxGameSystemCore.ResourceLock
// 0x0098 (0x0098 - 0x0000)
struct alignas(0x08) FResourceLock final
{
public:
	bool                                          bLocked;                                           // 0x0000(0x0001)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_1[0x97];                                       // 0x0001(0x0097)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FResourceLock) == 0x000008, "Wrong alignment on FResourceLock");
static_assert(sizeof(FResourceLock) == 0x000098, "Wrong size on FResourceLock");
static_assert(offsetof(FResourceLock, bLocked) == 0x000000, "Member 'FResourceLock::bLocked' has a wrong offset!");

// ScriptStruct GbxGameSystemCore.ActorPartList
// 0x0018 (0x0018 - 0x0000)
struct FActorPartList final
{
public:
	uint8                                         Pad_0[0x8];                                        // 0x0000(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<class UActorPartData*>                 Parts;                                             // 0x0008(0x0010)(ZeroConstructor, Transient, NativeAccessSpecifierPublic)
};
static_assert(alignof(FActorPartList) == 0x000008, "Wrong alignment on FActorPartList");
static_assert(sizeof(FActorPartList) == 0x000018, "Wrong size on FActorPartList");
static_assert(offsetof(FActorPartList, Parts) == 0x000008, "Member 'FActorPartList::Parts' has a wrong offset!");

// ScriptStruct GbxGameSystemCore.UseDefSelection
// 0x0020 (0x0020 - 0x0000)
struct FUseDefSelection final
{
public:
	uint8                                         bOverrideDefaultUseDefinition : 1;                 // 0x0000(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (Edit, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         bOverrideConditionalDefs : 1;                      // 0x0000(0x0001)(BitIndex: 0x01, PropSize: 0x0001 (Edit, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         Pad_1[0x7];                                        // 0x0001(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	class UUsableTypeDefinition*                  DefaultUseDefinition;                              // 0x0008(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TArray<struct FUseDefinitionConditional>      ConditionalUseDefs;                                // 0x0010(0x0010)(Edit, ZeroConstructor, ContainsInstancedReference, NativeAccessSpecifierPublic)
};
static_assert(alignof(FUseDefSelection) == 0x000008, "Wrong alignment on FUseDefSelection");
static_assert(sizeof(FUseDefSelection) == 0x000020, "Wrong size on FUseDefSelection");
static_assert(offsetof(FUseDefSelection, DefaultUseDefinition) == 0x000008, "Member 'FUseDefSelection::DefaultUseDefinition' has a wrong offset!");
static_assert(offsetof(FUseDefSelection, ConditionalUseDefs) == 0x000010, "Member 'FUseDefSelection::ConditionalUseDefs' has a wrong offset!");

// ScriptStruct GbxGameSystemCore.FeedbackDataFirstPersonImpulse
// 0x0060 (0x0060 - 0x0000)
struct FFeedbackDataFirstPersonImpulse final
{
public:
	bool                                          bUseDurationFromCameraShake;                       // 0x0000(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1[0x3];                                        // 0x0001(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         CameraShakeDurationEaseInWeight;                   // 0x0004(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         EaseInDuration;                                    // 0x0008(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         EaseOutDuration;                                   // 0x000C(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FGbxEasingFunc                         EaseInFunc;                                        // 0x0010(0x000C)(Edit, NoDestructor, NativeAccessSpecifierPublic)
	struct FGbxEasingFunc                         EaseOutFunc;                                       // 0x001C(0x000C)(Edit, NoDestructor, NativeAccessSpecifierPublic)
	struct FRotator                               RandomRotationOffset;                              // 0x0028(0x000C)(Edit, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
	struct FRotator                               RotationExtent;                                    // 0x0034(0x000C)(Edit, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
	bool                                          bOffsetRotationByDirection;                        // 0x0040(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_41[0x3];                                       // 0x0041(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	struct FVector                                RandomTranslationOffset;                           // 0x0044(0x000C)(Edit, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                TranslationExtent;                                 // 0x0050(0x000C)(Edit, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         ZoomedEffectScale;                                 // 0x005C(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FFeedbackDataFirstPersonImpulse) == 0x000004, "Wrong alignment on FFeedbackDataFirstPersonImpulse");
static_assert(sizeof(FFeedbackDataFirstPersonImpulse) == 0x000060, "Wrong size on FFeedbackDataFirstPersonImpulse");
static_assert(offsetof(FFeedbackDataFirstPersonImpulse, bUseDurationFromCameraShake) == 0x000000, "Member 'FFeedbackDataFirstPersonImpulse::bUseDurationFromCameraShake' has a wrong offset!");
static_assert(offsetof(FFeedbackDataFirstPersonImpulse, CameraShakeDurationEaseInWeight) == 0x000004, "Member 'FFeedbackDataFirstPersonImpulse::CameraShakeDurationEaseInWeight' has a wrong offset!");
static_assert(offsetof(FFeedbackDataFirstPersonImpulse, EaseInDuration) == 0x000008, "Member 'FFeedbackDataFirstPersonImpulse::EaseInDuration' has a wrong offset!");
static_assert(offsetof(FFeedbackDataFirstPersonImpulse, EaseOutDuration) == 0x00000C, "Member 'FFeedbackDataFirstPersonImpulse::EaseOutDuration' has a wrong offset!");
static_assert(offsetof(FFeedbackDataFirstPersonImpulse, EaseInFunc) == 0x000010, "Member 'FFeedbackDataFirstPersonImpulse::EaseInFunc' has a wrong offset!");
static_assert(offsetof(FFeedbackDataFirstPersonImpulse, EaseOutFunc) == 0x00001C, "Member 'FFeedbackDataFirstPersonImpulse::EaseOutFunc' has a wrong offset!");
static_assert(offsetof(FFeedbackDataFirstPersonImpulse, RandomRotationOffset) == 0x000028, "Member 'FFeedbackDataFirstPersonImpulse::RandomRotationOffset' has a wrong offset!");
static_assert(offsetof(FFeedbackDataFirstPersonImpulse, RotationExtent) == 0x000034, "Member 'FFeedbackDataFirstPersonImpulse::RotationExtent' has a wrong offset!");
static_assert(offsetof(FFeedbackDataFirstPersonImpulse, bOffsetRotationByDirection) == 0x000040, "Member 'FFeedbackDataFirstPersonImpulse::bOffsetRotationByDirection' has a wrong offset!");
static_assert(offsetof(FFeedbackDataFirstPersonImpulse, RandomTranslationOffset) == 0x000044, "Member 'FFeedbackDataFirstPersonImpulse::RandomTranslationOffset' has a wrong offset!");
static_assert(offsetof(FFeedbackDataFirstPersonImpulse, TranslationExtent) == 0x000050, "Member 'FFeedbackDataFirstPersonImpulse::TranslationExtent' has a wrong offset!");
static_assert(offsetof(FFeedbackDataFirstPersonImpulse, ZoomedEffectScale) == 0x00005C, "Member 'FFeedbackDataFirstPersonImpulse::ZoomedEffectScale' has a wrong offset!");

// ScriptStruct GbxGameSystemCore.UseTraceResult
// 0x0060 (0x0060 - 0x0000)
struct FUseTraceResult final
{
public:
	class UUsableComponent*                       UsableComponent;                                   // 0x0000(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UPrimitiveComponent*                    HitComponent;                                      // 0x0008(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, RepSkip, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FUsabilityInfo                         Usability;                                         // 0x0010(0x0040)(NativeAccessSpecifierPublic)
	uint8                                         Pad_50[0x10];                                      // 0x0050(0x0010)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FUseTraceResult) == 0x000008, "Wrong alignment on FUseTraceResult");
static_assert(sizeof(FUseTraceResult) == 0x000060, "Wrong size on FUseTraceResult");
static_assert(offsetof(FUseTraceResult, UsableComponent) == 0x000000, "Member 'FUseTraceResult::UsableComponent' has a wrong offset!");
static_assert(offsetof(FUseTraceResult, HitComponent) == 0x000008, "Member 'FUseTraceResult::HitComponent' has a wrong offset!");
static_assert(offsetof(FUseTraceResult, Usability) == 0x000010, "Member 'FUseTraceResult::Usability' has a wrong offset!");

// ScriptStruct GbxGameSystemCore.DataActionPair_Base
// 0x0008 (0x0008 - 0x0000)
struct FDataActionPair_Base
{
public:
	TSubclassOf<class UGbxAction>                 ActionValue;                                       // 0x0000(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FDataActionPair_Base) == 0x000008, "Wrong alignment on FDataActionPair_Base");
static_assert(sizeof(FDataActionPair_Base) == 0x000008, "Wrong size on FDataActionPair_Base");
static_assert(offsetof(FDataActionPair_Base, ActionValue) == 0x000000, "Member 'FDataActionPair_Base::ActionValue' has a wrong offset!");

// ScriptStruct GbxGameSystemCore.DataActionPair
// 0x0008 (0x0010 - 0x0008)
struct FDataActionPair final : public FDataActionPair_Base
{
public:
	struct FGameplayTag                           ActionKey;                                         // 0x0008(0x0008)(Edit, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FDataActionPair) == 0x000008, "Wrong alignment on FDataActionPair");
static_assert(sizeof(FDataActionPair) == 0x000010, "Wrong size on FDataActionPair");
static_assert(offsetof(FDataActionPair, ActionKey) == 0x000008, "Member 'FDataActionPair::ActionKey' has a wrong offset!");

// ScriptStruct GbxGameSystemCore.AnimGraphBoneSet
// 0x0010 (0x0010 - 0x0000)
struct FAnimGraphBoneSet final
{
public:
	class UGbxBoneSet*                            BoneSet;                                           // 0x0000(0x0008)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   AnimGraphMachineName;                              // 0x0008(0x0008)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FAnimGraphBoneSet) == 0x000008, "Wrong alignment on FAnimGraphBoneSet");
static_assert(sizeof(FAnimGraphBoneSet) == 0x000010, "Wrong size on FAnimGraphBoneSet");
static_assert(offsetof(FAnimGraphBoneSet, BoneSet) == 0x000000, "Member 'FAnimGraphBoneSet::BoneSet' has a wrong offset!");
static_assert(offsetof(FAnimGraphBoneSet, AnimGraphMachineName) == 0x000008, "Member 'FAnimGraphBoneSet::AnimGraphMachineName' has a wrong offset!");

// ScriptStruct GbxGameSystemCore.UsabilityQuery
// 0x0018 (0x0018 - 0x0000)
struct FUsabilityQuery final
{
public:
	class AController*                            UserController;                                    // 0x0000(0x0008)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UPrimitiveComponent*                    UsedComponent;                                     // 0x0008(0x0008)(BlueprintVisible, ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EUsabilityType                                UseType;                                           // 0x0010(0x0001)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bUseHeld;                                          // 0x0011(0x0001)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_12[0x6];                                       // 0x0012(0x0006)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FUsabilityQuery) == 0x000008, "Wrong alignment on FUsabilityQuery");
static_assert(sizeof(FUsabilityQuery) == 0x000018, "Wrong size on FUsabilityQuery");
static_assert(offsetof(FUsabilityQuery, UserController) == 0x000000, "Member 'FUsabilityQuery::UserController' has a wrong offset!");
static_assert(offsetof(FUsabilityQuery, UsedComponent) == 0x000008, "Member 'FUsabilityQuery::UsedComponent' has a wrong offset!");
static_assert(offsetof(FUsabilityQuery, UseType) == 0x000010, "Member 'FUsabilityQuery::UseType' has a wrong offset!");
static_assert(offsetof(FUsabilityQuery, bUseHeld) == 0x000011, "Member 'FUsabilityQuery::bUseHeld' has a wrong offset!");

// ScriptStruct GbxGameSystemCore.ParticlePropertyTracker
// 0x0038 (0x0038 - 0x0000)
struct FParticlePropertyTracker final
{
public:
	class UParticlePropertyTrackingData*          TrackingData;                                      // 0x0000(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UParticleSystem*                        Template;                                          // 0x0008(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   Tag;                                               // 0x0010(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   PropertyName;                                      // 0x0018(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         FloatParamValue;                                   // 0x0020(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         LastUpdateTime;                                    // 0x0024(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UMaterialInstanceDynamic*               Material;                                          // 0x0028(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   MaterialPropertyName;                              // 0x0030(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FParticlePropertyTracker) == 0x000008, "Wrong alignment on FParticlePropertyTracker");
static_assert(sizeof(FParticlePropertyTracker) == 0x000038, "Wrong size on FParticlePropertyTracker");
static_assert(offsetof(FParticlePropertyTracker, TrackingData) == 0x000000, "Member 'FParticlePropertyTracker::TrackingData' has a wrong offset!");
static_assert(offsetof(FParticlePropertyTracker, Template) == 0x000008, "Member 'FParticlePropertyTracker::Template' has a wrong offset!");
static_assert(offsetof(FParticlePropertyTracker, Tag) == 0x000010, "Member 'FParticlePropertyTracker::Tag' has a wrong offset!");
static_assert(offsetof(FParticlePropertyTracker, PropertyName) == 0x000018, "Member 'FParticlePropertyTracker::PropertyName' has a wrong offset!");
static_assert(offsetof(FParticlePropertyTracker, FloatParamValue) == 0x000020, "Member 'FParticlePropertyTracker::FloatParamValue' has a wrong offset!");
static_assert(offsetof(FParticlePropertyTracker, LastUpdateTime) == 0x000024, "Member 'FParticlePropertyTracker::LastUpdateTime' has a wrong offset!");
static_assert(offsetof(FParticlePropertyTracker, Material) == 0x000028, "Member 'FParticlePropertyTracker::Material' has a wrong offset!");
static_assert(offsetof(FParticlePropertyTracker, MaterialPropertyName) == 0x000030, "Member 'FParticlePropertyTracker::MaterialPropertyName' has a wrong offset!");

// ScriptStruct GbxGameSystemCore.StatusEffectInstanceReference
// 0x0018 (0x0018 - 0x0000)
struct FStatusEffectInstanceReference final
{
public:
	class UStatusEffectManagerComponent*          StatusEffectManagerComponent;                      // 0x0000(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UStatusEffectData*                      StatusEffectData;                                  // 0x0008(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	int32                                         StatusEffectInstanceID;                            // 0x0010(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_14[0x4];                                       // 0x0014(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FStatusEffectInstanceReference) == 0x000008, "Wrong alignment on FStatusEffectInstanceReference");
static_assert(sizeof(FStatusEffectInstanceReference) == 0x000018, "Wrong size on FStatusEffectInstanceReference");
static_assert(offsetof(FStatusEffectInstanceReference, StatusEffectManagerComponent) == 0x000000, "Member 'FStatusEffectInstanceReference::StatusEffectManagerComponent' has a wrong offset!");
static_assert(offsetof(FStatusEffectInstanceReference, StatusEffectData) == 0x000008, "Member 'FStatusEffectInstanceReference::StatusEffectData' has a wrong offset!");
static_assert(offsetof(FStatusEffectInstanceReference, StatusEffectInstanceID) == 0x000010, "Member 'FStatusEffectInstanceReference::StatusEffectInstanceID' has a wrong offset!");

// ScriptStruct GbxGameSystemCore.HealthType
// 0x0078 (0x0078 - 0x0000)
struct FHealthType final
{
public:
	class UHealthTypeData*                        HealthTypeData;                                    // 0x0000(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UGameResourcePoolData*                  HealthPoolData;                                    // 0x0008(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TArray<float>                                 HealthSectionPercentages;                          // 0x0010(0x0010)(Edit, ZeroConstructor, NativeAccessSpecifierPublic)
	uint8                                         bResetIdleTimerIfNoDamage : 1;                     // 0x0020(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (Edit, RepSkip, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         bUseChanceToExist : 1;                             // 0x0020(0x0001)(BitIndex: 0x01, PropSize: 0x0001 (Edit, RepSkip, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         Pad_21[0x7];                                       // 0x0021(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	struct FAttributeInitializationData           ChanceToExist;                                     // 0x0028(0x0038)(Edit, RepSkip, NoDestructor, NativeAccessSpecifierPublic)
	struct FGameResourcePoolReference             HealthPool;                                        // 0x0060(0x0018)(Transient, NoDestructor, ContainsInstancedReference, NativeAccessSpecifierPublic)
};
static_assert(alignof(FHealthType) == 0x000008, "Wrong alignment on FHealthType");
static_assert(sizeof(FHealthType) == 0x000078, "Wrong size on FHealthType");
static_assert(offsetof(FHealthType, HealthTypeData) == 0x000000, "Member 'FHealthType::HealthTypeData' has a wrong offset!");
static_assert(offsetof(FHealthType, HealthPoolData) == 0x000008, "Member 'FHealthType::HealthPoolData' has a wrong offset!");
static_assert(offsetof(FHealthType, HealthSectionPercentages) == 0x000010, "Member 'FHealthType::HealthSectionPercentages' has a wrong offset!");
static_assert(offsetof(FHealthType, ChanceToExist) == 0x000028, "Member 'FHealthType::ChanceToExist' has a wrong offset!");
static_assert(offsetof(FHealthType, HealthPool) == 0x000060, "Member 'FHealthType::HealthPool' has a wrong offset!");

// ScriptStruct GbxGameSystemCore.ReplicatedImpactHitResult
// 0x0040 (0x0040 - 0x0000)
struct alignas(0x08) FReplicatedImpactHitResult final
{
public:
	bool                                          bLocalSpace;                                       // 0x0000(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1[0x3];                                        // 0x0001(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	struct FVector_NetQuantize                    ImpactPoint;                                       // 0x0004(0x000C)(NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector_NetQuantizeNormal              Normal;                                            // 0x0010(0x000C)(NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TWeakObjectPtr<class UPhysicalMaterial>       PhysMaterial;                                      // 0x001C(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TWeakObjectPtr<class AActor>                  Actor;                                             // 0x0024(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TWeakObjectPtr<class UPrimitiveComponent>     Component;                                         // 0x002C(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_34[0x4];                                       // 0x0034(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class FName                                   BoneName;                                          // 0x0038(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FReplicatedImpactHitResult) == 0x000008, "Wrong alignment on FReplicatedImpactHitResult");
static_assert(sizeof(FReplicatedImpactHitResult) == 0x000040, "Wrong size on FReplicatedImpactHitResult");
static_assert(offsetof(FReplicatedImpactHitResult, bLocalSpace) == 0x000000, "Member 'FReplicatedImpactHitResult::bLocalSpace' has a wrong offset!");
static_assert(offsetof(FReplicatedImpactHitResult, ImpactPoint) == 0x000004, "Member 'FReplicatedImpactHitResult::ImpactPoint' has a wrong offset!");
static_assert(offsetof(FReplicatedImpactHitResult, Normal) == 0x000010, "Member 'FReplicatedImpactHitResult::Normal' has a wrong offset!");
static_assert(offsetof(FReplicatedImpactHitResult, PhysMaterial) == 0x00001C, "Member 'FReplicatedImpactHitResult::PhysMaterial' has a wrong offset!");
static_assert(offsetof(FReplicatedImpactHitResult, Actor) == 0x000024, "Member 'FReplicatedImpactHitResult::Actor' has a wrong offset!");
static_assert(offsetof(FReplicatedImpactHitResult, Component) == 0x00002C, "Member 'FReplicatedImpactHitResult::Component' has a wrong offset!");
static_assert(offsetof(FReplicatedImpactHitResult, BoneName) == 0x000038, "Member 'FReplicatedImpactHitResult::BoneName' has a wrong offset!");

// ScriptStruct GbxGameSystemCore.ImpactResponseParams
// 0x00B0 (0x00B0 - 0x0000)
struct alignas(0x10) FImpactResponseParams final
{
public:
	TArray<struct FParticleSysParam>              ParticleParameters;                                // 0x0000(0x0010)(ZeroConstructor, NativeAccessSpecifierPublic)
	TArray<struct FImpactAudioParam>              AudioParameters;                                   // 0x0010(0x0010)(ZeroConstructor, NativeAccessSpecifierPublic)
	class UWwiseSwitch*                           AudioSurfaceSwitch;                                // 0x0020(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_28[0x70];                                      // 0x0028(0x0070)(Fixing Size After Last Property [ Dumper-7 ])
	class UMaterialInterface*                     DecalOverride;                                     // 0x0098(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_A0[0x10];                                      // 0x00A0(0x0010)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FImpactResponseParams) == 0x000010, "Wrong alignment on FImpactResponseParams");
static_assert(sizeof(FImpactResponseParams) == 0x0000B0, "Wrong size on FImpactResponseParams");
static_assert(offsetof(FImpactResponseParams, ParticleParameters) == 0x000000, "Member 'FImpactResponseParams::ParticleParameters' has a wrong offset!");
static_assert(offsetof(FImpactResponseParams, AudioParameters) == 0x000010, "Member 'FImpactResponseParams::AudioParameters' has a wrong offset!");
static_assert(offsetof(FImpactResponseParams, AudioSurfaceSwitch) == 0x000020, "Member 'FImpactResponseParams::AudioSurfaceSwitch' has a wrong offset!");
static_assert(offsetof(FImpactResponseParams, DecalOverride) == 0x000098, "Member 'FImpactResponseParams::DecalOverride' has a wrong offset!");

// ScriptStruct GbxGameSystemCore.SavedCollisionItem
// 0x0028 (0x0028 - 0x0000)
struct FSavedCollisionItem final
{
public:
	class UPrimitiveComponent*                    Primitive;                                         // 0x0000(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FCollisionResponseContainer            Responses;                                         // 0x0008(0x0020)(NoDestructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(FSavedCollisionItem) == 0x000008, "Wrong alignment on FSavedCollisionItem");
static_assert(sizeof(FSavedCollisionItem) == 0x000028, "Wrong size on FSavedCollisionItem");
static_assert(offsetof(FSavedCollisionItem, Primitive) == 0x000000, "Member 'FSavedCollisionItem::Primitive' has a wrong offset!");
static_assert(offsetof(FSavedCollisionItem, Responses) == 0x000008, "Member 'FSavedCollisionItem::Responses' has a wrong offset!");

// ScriptStruct GbxGameSystemCore.SavedTeamCollision
// 0x0010 (0x0010 - 0x0000)
struct FSavedTeamCollision final
{
public:
	class UTeamComponent*                         TeamComponent;                                     // 0x0000(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bUseTeamCollision;                                 // 0x0008(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bCollideWithTeam;                                  // 0x0009(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_A[0x6];                                        // 0x000A(0x0006)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FSavedTeamCollision) == 0x000008, "Wrong alignment on FSavedTeamCollision");
static_assert(sizeof(FSavedTeamCollision) == 0x000010, "Wrong size on FSavedTeamCollision");
static_assert(offsetof(FSavedTeamCollision, TeamComponent) == 0x000000, "Member 'FSavedTeamCollision::TeamComponent' has a wrong offset!");
static_assert(offsetof(FSavedTeamCollision, bUseTeamCollision) == 0x000008, "Member 'FSavedTeamCollision::bUseTeamCollision' has a wrong offset!");
static_assert(offsetof(FSavedTeamCollision, bCollideWithTeam) == 0x000009, "Member 'FSavedTeamCollision::bCollideWithTeam' has a wrong offset!");

// ScriptStruct GbxGameSystemCore.SavedCollision
// 0x0020 (0x0020 - 0x0000)
struct FSavedCollision final
{
public:
	TArray<struct FSavedCollisionItem>            SavedItems;                                        // 0x0000(0x0010)(ZeroConstructor, ContainsInstancedReference, NativeAccessSpecifierPrivate)
	TArray<struct FSavedTeamCollision>            SavedTeamItems;                                    // 0x0010(0x0010)(ZeroConstructor, ContainsInstancedReference, NativeAccessSpecifierPrivate)
};
static_assert(alignof(FSavedCollision) == 0x000008, "Wrong alignment on FSavedCollision");
static_assert(sizeof(FSavedCollision) == 0x000020, "Wrong size on FSavedCollision");
static_assert(offsetof(FSavedCollision, SavedItems) == 0x000000, "Member 'FSavedCollision::SavedItems' has a wrong offset!");
static_assert(offsetof(FSavedCollision, SavedTeamItems) == 0x000010, "Member 'FSavedCollision::SavedTeamItems' has a wrong offset!");

// ScriptStruct GbxGameSystemCore.GbxAnimPoseMatch
// 0x0020 (0x0020 - 0x0000)
struct FGbxAnimPoseMatch final
{
public:
	TArray<class FName>                           PoseMatchBones;                                    // 0x0000(0x0010)(Edit, ZeroConstructor, NativeAccessSpecifierPrivate)
	uint8                                         Pad_10[0x10];                                      // 0x0010(0x0010)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FGbxAnimPoseMatch) == 0x000008, "Wrong alignment on FGbxAnimPoseMatch");
static_assert(sizeof(FGbxAnimPoseMatch) == 0x000020, "Wrong size on FGbxAnimPoseMatch");
static_assert(offsetof(FGbxAnimPoseMatch, PoseMatchBones) == 0x000000, "Member 'FGbxAnimPoseMatch::PoseMatchBones' has a wrong offset!");

// ScriptStruct GbxGameSystemCore.CustomizationColorApplication
// 0x0034 (0x0034 - 0x0000)
struct FCustomizationColorApplication final
{
public:
	bool                                          bUseDefaultColor;                                  // 0x0000(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bUseDefaultSplitColor;                             // 0x0001(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bSupportsSplitColor;                               // 0x0002(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_3[0x1];                                        // 0x0003(0x0001)(Fixing Size After Last Property [ Dumper-7 ])
	struct FVector                                AppliedColor;                                      // 0x0004(0x000C)(IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                SplitColor;                                        // 0x0010(0x000C)(IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                DefaultColor;                                      // 0x001C(0x000C)(IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                DefaultSplitColor;                                 // 0x0028(0x000C)(IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FCustomizationColorApplication) == 0x000004, "Wrong alignment on FCustomizationColorApplication");
static_assert(sizeof(FCustomizationColorApplication) == 0x000034, "Wrong size on FCustomizationColorApplication");
static_assert(offsetof(FCustomizationColorApplication, bUseDefaultColor) == 0x000000, "Member 'FCustomizationColorApplication::bUseDefaultColor' has a wrong offset!");
static_assert(offsetof(FCustomizationColorApplication, bUseDefaultSplitColor) == 0x000001, "Member 'FCustomizationColorApplication::bUseDefaultSplitColor' has a wrong offset!");
static_assert(offsetof(FCustomizationColorApplication, bSupportsSplitColor) == 0x000002, "Member 'FCustomizationColorApplication::bSupportsSplitColor' has a wrong offset!");
static_assert(offsetof(FCustomizationColorApplication, AppliedColor) == 0x000004, "Member 'FCustomizationColorApplication::AppliedColor' has a wrong offset!");
static_assert(offsetof(FCustomizationColorApplication, SplitColor) == 0x000010, "Member 'FCustomizationColorApplication::SplitColor' has a wrong offset!");
static_assert(offsetof(FCustomizationColorApplication, DefaultColor) == 0x00001C, "Member 'FCustomizationColorApplication::DefaultColor' has a wrong offset!");
static_assert(offsetof(FCustomizationColorApplication, DefaultSplitColor) == 0x000028, "Member 'FCustomizationColorApplication::DefaultSplitColor' has a wrong offset!");

// ScriptStruct GbxGameSystemCore.BoneModifyState_RepData
// 0x000C (0x000C - 0x0000)
struct FBoneModifyState_RepData final
{
public:
	bool                                          bActive;                                           // 0x0000(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1[0x3];                                        // 0x0001(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         Alpha;                                             // 0x0004(0x0004)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         BlendTime;                                         // 0x0008(0x0004)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FBoneModifyState_RepData) == 0x000004, "Wrong alignment on FBoneModifyState_RepData");
static_assert(sizeof(FBoneModifyState_RepData) == 0x00000C, "Wrong size on FBoneModifyState_RepData");
static_assert(offsetof(FBoneModifyState_RepData, bActive) == 0x000000, "Member 'FBoneModifyState_RepData::bActive' has a wrong offset!");
static_assert(offsetof(FBoneModifyState_RepData, Alpha) == 0x000004, "Member 'FBoneModifyState_RepData::Alpha' has a wrong offset!");
static_assert(offsetof(FBoneModifyState_RepData, BlendTime) == 0x000008, "Member 'FBoneModifyState_RepData::BlendTime' has a wrong offset!");

// ScriptStruct GbxGameSystemCore.BoneModifyProfileData
// 0x0018 (0x0018 - 0x0000)
struct FBoneModifyProfileData final
{
public:
	class UGbxBoneModifyProfile*                  Profile;                                           // 0x0000(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TArray<struct FBoneModifyState_RepData>       States;                                            // 0x0008(0x0010)(Edit, ZeroConstructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(FBoneModifyProfileData) == 0x000008, "Wrong alignment on FBoneModifyProfileData");
static_assert(sizeof(FBoneModifyProfileData) == 0x000018, "Wrong size on FBoneModifyProfileData");
static_assert(offsetof(FBoneModifyProfileData, Profile) == 0x000000, "Member 'FBoneModifyProfileData::Profile' has a wrong offset!");
static_assert(offsetof(FBoneModifyProfileData, States) == 0x000008, "Member 'FBoneModifyProfileData::States' has a wrong offset!");

// ScriptStruct GbxGameSystemCore.RemoteFacingChannel
// 0x0002 (0x0002 - 0x0000)
struct FRemoteFacingChannel final
{
public:
	uint8                                         Pitch;                                             // 0x0000(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Yaw;                                               // 0x0001(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FRemoteFacingChannel) == 0x000001, "Wrong alignment on FRemoteFacingChannel");
static_assert(sizeof(FRemoteFacingChannel) == 0x000002, "Wrong size on FRemoteFacingChannel");
static_assert(offsetof(FRemoteFacingChannel, Pitch) == 0x000000, "Member 'FRemoteFacingChannel::Pitch' has a wrong offset!");
static_assert(offsetof(FRemoteFacingChannel, Yaw) == 0x000001, "Member 'FRemoteFacingChannel::Yaw' has a wrong offset!");

// ScriptStruct GbxGameSystemCore.FacingController
// 0x0110 (0x0110 - 0x0000)
struct alignas(0x08) FFacingController final
{
public:
	uint8                                         Pad_0[0x109];                                      // 0x0000(0x0109)(Fixing Size After Last Property [ Dumper-7 ])
	struct FRemoteFacingChannel                   RemoteChannels[0x3];                               // 0x0109(0x0002)(NoDestructor, NativeAccessSpecifierPrivate)
	uint8                                         Pad_10F[0x1];                                      // 0x010F(0x0001)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FFacingController) == 0x000008, "Wrong alignment on FFacingController");
static_assert(sizeof(FFacingController) == 0x000110, "Wrong size on FFacingController");
static_assert(offsetof(FFacingController, RemoteChannels) == 0x000109, "Member 'FFacingController::RemoteChannels' has a wrong offset!");

// ScriptStruct GbxGameSystemCore.UserStatesReplicationData
// 0x0008 (0x0008 - 0x0000)
struct FUserStatesReplicationData final
{
public:
	bool                                          bInitialized;                                      // 0x0000(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1[0x3];                                        // 0x0001(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	uint32                                        PackedStateBits;                                   // 0x0004(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FUserStatesReplicationData) == 0x000004, "Wrong alignment on FUserStatesReplicationData");
static_assert(sizeof(FUserStatesReplicationData) == 0x000008, "Wrong size on FUserStatesReplicationData");
static_assert(offsetof(FUserStatesReplicationData, bInitialized) == 0x000000, "Member 'FUserStatesReplicationData::bInitialized' has a wrong offset!");
static_assert(offsetof(FUserStatesReplicationData, PackedStateBits) == 0x000004, "Member 'FUserStatesReplicationData::PackedStateBits' has a wrong offset!");

// ScriptStruct GbxGameSystemCore.ReplicatedPawnAttachState
// 0x0010 (0x0010 - 0x0000)
struct FReplicatedPawnAttachState final
{
public:
	class UPawnAttachSlotComponent*               Slot;                                              // 0x0000(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EPawnAttachStatus                             Status;                                            // 0x0008(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_9[0x1];                                        // 0x0009(0x0001)(Fixing Size After Last Property [ Dumper-7 ])
	uint16                                        StatusFlag;                                        // 0x000A(0x0002)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_C[0x4];                                        // 0x000C(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FReplicatedPawnAttachState) == 0x000008, "Wrong alignment on FReplicatedPawnAttachState");
static_assert(sizeof(FReplicatedPawnAttachState) == 0x000010, "Wrong size on FReplicatedPawnAttachState");
static_assert(offsetof(FReplicatedPawnAttachState, Slot) == 0x000000, "Member 'FReplicatedPawnAttachState::Slot' has a wrong offset!");
static_assert(offsetof(FReplicatedPawnAttachState, Status) == 0x000008, "Member 'FReplicatedPawnAttachState::Status' has a wrong offset!");
static_assert(offsetof(FReplicatedPawnAttachState, StatusFlag) == 0x00000A, "Member 'FReplicatedPawnAttachState::StatusFlag' has a wrong offset!");

// ScriptStruct GbxGameSystemCore.GbxParam
// 0x0080 (0x0080 - 0x0000)
struct FGbxParam
{
public:
	EGbxParamValueType                            ValueType;                                         // 0x0000(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         DisabledValueModes;                                // 0x0001(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         ValueFlags;                                        // 0x0002(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EGbxParamValueMode                            ValueMode;                                         // 0x0003(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FNumericRange                          Range;                                             // 0x0004(0x0008)(Edit, NoDestructor, NativeAccessSpecifierPublic)
	uint8                                         Pad_C[0x4];                                        // 0x000C(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	TSubclassOf<class UAttributeInitializer>      AttributeInitializer;                              // 0x0010(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UGbxAttributeData*                      AttributeData;                                     // 0x0018(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	struct FAttributeInitializationData           AttributeInitializationData;                       // 0x0020(0x0038)(Edit, NoDestructor, NativeAccessSpecifierPublic)
	struct FGbxBlackboardKeySelector              BlackboardKey;                                     // 0x0058(0x0010)(Edit, NoDestructor, NativeAccessSpecifierPublic)
	class UGbxCondition*                          Condition;                                         // 0x0068(0x0008)(Edit, ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, PersistentInstance, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TWeakObjectPtr<class AActor>                  Actor;                                             // 0x0070(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_78[0x8];                                       // 0x0078(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FGbxParam) == 0x000008, "Wrong alignment on FGbxParam");
static_assert(sizeof(FGbxParam) == 0x000080, "Wrong size on FGbxParam");
static_assert(offsetof(FGbxParam, ValueType) == 0x000000, "Member 'FGbxParam::ValueType' has a wrong offset!");
static_assert(offsetof(FGbxParam, DisabledValueModes) == 0x000001, "Member 'FGbxParam::DisabledValueModes' has a wrong offset!");
static_assert(offsetof(FGbxParam, ValueFlags) == 0x000002, "Member 'FGbxParam::ValueFlags' has a wrong offset!");
static_assert(offsetof(FGbxParam, ValueMode) == 0x000003, "Member 'FGbxParam::ValueMode' has a wrong offset!");
static_assert(offsetof(FGbxParam, Range) == 0x000004, "Member 'FGbxParam::Range' has a wrong offset!");
static_assert(offsetof(FGbxParam, AttributeInitializer) == 0x000010, "Member 'FGbxParam::AttributeInitializer' has a wrong offset!");
static_assert(offsetof(FGbxParam, AttributeData) == 0x000018, "Member 'FGbxParam::AttributeData' has a wrong offset!");
static_assert(offsetof(FGbxParam, AttributeInitializationData) == 0x000020, "Member 'FGbxParam::AttributeInitializationData' has a wrong offset!");
static_assert(offsetof(FGbxParam, BlackboardKey) == 0x000058, "Member 'FGbxParam::BlackboardKey' has a wrong offset!");
static_assert(offsetof(FGbxParam, Condition) == 0x000068, "Member 'FGbxParam::Condition' has a wrong offset!");
static_assert(offsetof(FGbxParam, Actor) == 0x000070, "Member 'FGbxParam::Actor' has a wrong offset!");

// ScriptStruct GbxGameSystemCore.GbxNamedParam
// 0x0008 (0x0088 - 0x0080)
struct FGbxNamedParam final : public FGbxParam
{
public:
	class FName                                   Name;                                              // 0x0080(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FGbxNamedParam) == 0x000008, "Wrong alignment on FGbxNamedParam");
static_assert(sizeof(FGbxNamedParam) == 0x000088, "Wrong size on FGbxNamedParam");
static_assert(offsetof(FGbxNamedParam, Name) == 0x000080, "Member 'FGbxNamedParam::Name' has a wrong offset!");

// ScriptStruct GbxGameSystemCore.SpawnCostSelection
// 0x0018 (0x0018 - 0x0000)
struct alignas(0x08) FSpawnCostSelection final
{
public:
	ESpawnCostSelection                           Selection;                                         // 0x0000(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1[0x7];                                        // 0x0001(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	class FName                                   Preset;                                            // 0x0008(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         SpawnCost;                                         // 0x0010(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_14[0x4];                                       // 0x0014(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FSpawnCostSelection) == 0x000008, "Wrong alignment on FSpawnCostSelection");
static_assert(sizeof(FSpawnCostSelection) == 0x000018, "Wrong size on FSpawnCostSelection");
static_assert(offsetof(FSpawnCostSelection, Selection) == 0x000000, "Member 'FSpawnCostSelection::Selection' has a wrong offset!");
static_assert(offsetof(FSpawnCostSelection, Preset) == 0x000008, "Member 'FSpawnCostSelection::Preset' has a wrong offset!");
static_assert(offsetof(FSpawnCostSelection, SpawnCost) == 0x000010, "Member 'FSpawnCostSelection::SpawnCost' has a wrong offset!");

// ScriptStruct GbxGameSystemCore.MassSelection
// 0x0018 (0x0018 - 0x0000)
struct alignas(0x08) FMassSelection final
{
public:
	EMassSelection                                Selection;                                         // 0x0000(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1[0x7];                                        // 0x0001(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	class FName                                   Preset;                                            // 0x0008(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         Mass;                                              // 0x0010(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_14[0x4];                                       // 0x0014(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FMassSelection) == 0x000008, "Wrong alignment on FMassSelection");
static_assert(sizeof(FMassSelection) == 0x000018, "Wrong size on FMassSelection");
static_assert(offsetof(FMassSelection, Selection) == 0x000000, "Member 'FMassSelection::Selection' has a wrong offset!");
static_assert(offsetof(FMassSelection, Preset) == 0x000008, "Member 'FMassSelection::Preset' has a wrong offset!");
static_assert(offsetof(FMassSelection, Mass) == 0x000010, "Member 'FMassSelection::Mass' has a wrong offset!");

// ScriptStruct GbxGameSystemCore.DamageReactionEvent_DamageComponent
// 0x0048 (0x0048 - 0x0000)
struct FDamageReactionEvent_DamageComponent final
{
public:
	class FName                                   EventName;                                         // 0x0000(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UGameResourcePoolData*                  HealthPool;                                        // 0x0008(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         EventHealthPercent;                                // 0x0010(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EDamageReactionEventType                      EVENTTYPE;                                         // 0x0014(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_15[0x3];                                       // 0x0015(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	class UDamageFilter*                          Filter;                                            // 0x0018(0x0008)(Edit, ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, PersistentInstance, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         DamageTime;                                        // 0x0020(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         RetriggerDelay;                                    // 0x0024(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         MaxTriggerCount;                                   // 0x0028(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2C[0x1C];                                      // 0x002C(0x001C)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FDamageReactionEvent_DamageComponent) == 0x000008, "Wrong alignment on FDamageReactionEvent_DamageComponent");
static_assert(sizeof(FDamageReactionEvent_DamageComponent) == 0x000048, "Wrong size on FDamageReactionEvent_DamageComponent");
static_assert(offsetof(FDamageReactionEvent_DamageComponent, EventName) == 0x000000, "Member 'FDamageReactionEvent_DamageComponent::EventName' has a wrong offset!");
static_assert(offsetof(FDamageReactionEvent_DamageComponent, HealthPool) == 0x000008, "Member 'FDamageReactionEvent_DamageComponent::HealthPool' has a wrong offset!");
static_assert(offsetof(FDamageReactionEvent_DamageComponent, EventHealthPercent) == 0x000010, "Member 'FDamageReactionEvent_DamageComponent::EventHealthPercent' has a wrong offset!");
static_assert(offsetof(FDamageReactionEvent_DamageComponent, EVENTTYPE) == 0x000014, "Member 'FDamageReactionEvent_DamageComponent::EVENTTYPE' has a wrong offset!");
static_assert(offsetof(FDamageReactionEvent_DamageComponent, Filter) == 0x000018, "Member 'FDamageReactionEvent_DamageComponent::Filter' has a wrong offset!");
static_assert(offsetof(FDamageReactionEvent_DamageComponent, DamageTime) == 0x000020, "Member 'FDamageReactionEvent_DamageComponent::DamageTime' has a wrong offset!");
static_assert(offsetof(FDamageReactionEvent_DamageComponent, RetriggerDelay) == 0x000024, "Member 'FDamageReactionEvent_DamageComponent::RetriggerDelay' has a wrong offset!");
static_assert(offsetof(FDamageReactionEvent_DamageComponent, MaxTriggerCount) == 0x000028, "Member 'FDamageReactionEvent_DamageComponent::MaxTriggerCount' has a wrong offset!");

// ScriptStruct GbxGameSystemCore.SoundPerceptionProperties
// 0x000C (0x000C - 0x0000)
struct FSoundPerceptionProperties final
{
public:
	bool                                          bEnabled;                                          // 0x0000(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1[0x3];                                        // 0x0001(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         Loudness;                                          // 0x0004(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         MaxRange;                                          // 0x0008(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FSoundPerceptionProperties) == 0x000004, "Wrong alignment on FSoundPerceptionProperties");
static_assert(sizeof(FSoundPerceptionProperties) == 0x00000C, "Wrong size on FSoundPerceptionProperties");
static_assert(offsetof(FSoundPerceptionProperties, bEnabled) == 0x000000, "Member 'FSoundPerceptionProperties::bEnabled' has a wrong offset!");
static_assert(offsetof(FSoundPerceptionProperties, Loudness) == 0x000004, "Member 'FSoundPerceptionProperties::Loudness' has a wrong offset!");
static_assert(offsetof(FSoundPerceptionProperties, MaxRange) == 0x000008, "Member 'FSoundPerceptionProperties::MaxRange' has a wrong offset!");

// ScriptStruct GbxGameSystemCore.ReplicatedGestaltPartsData
// 0x0018 (0x0018 - 0x0000)
struct alignas(0x08) FReplicatedGestaltPartsData final
{
public:
	uint8                                         Pad_0[0x18];                                       // 0x0000(0x0018)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FReplicatedGestaltPartsData) == 0x000008, "Wrong alignment on FReplicatedGestaltPartsData");
static_assert(sizeof(FReplicatedGestaltPartsData) == 0x000018, "Wrong size on FReplicatedGestaltPartsData");

// ScriptStruct GbxGameSystemCore.BulletPerceptionProperties
// 0x0008 (0x0008 - 0x0000)
struct FBulletPerceptionProperties final
{
public:
	bool                                          bEnabled;                                          // 0x0000(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1[0x3];                                        // 0x0001(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         Strength;                                          // 0x0004(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FBulletPerceptionProperties) == 0x000004, "Wrong alignment on FBulletPerceptionProperties");
static_assert(sizeof(FBulletPerceptionProperties) == 0x000008, "Wrong size on FBulletPerceptionProperties");
static_assert(offsetof(FBulletPerceptionProperties, bEnabled) == 0x000000, "Member 'FBulletPerceptionProperties::bEnabled' has a wrong offset!");
static_assert(offsetof(FBulletPerceptionProperties, Strength) == 0x000004, "Member 'FBulletPerceptionProperties::Strength' has a wrong offset!");

// ScriptStruct GbxGameSystemCore.LevelBasedDamageScale
// 0x000C (0x000C - 0x0000)
struct FLevelBasedDamageScale final
{
public:
	int32                                         LevelDifference;                                   // 0x0000(0x0004)(Edit, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         HigherLevelAttackerDmgScale;                       // 0x0004(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         LowerLevelAttackerDmgScale;                        // 0x0008(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FLevelBasedDamageScale) == 0x000004, "Wrong alignment on FLevelBasedDamageScale");
static_assert(sizeof(FLevelBasedDamageScale) == 0x00000C, "Wrong size on FLevelBasedDamageScale");
static_assert(offsetof(FLevelBasedDamageScale, LevelDifference) == 0x000000, "Member 'FLevelBasedDamageScale::LevelDifference' has a wrong offset!");
static_assert(offsetof(FLevelBasedDamageScale, HigherLevelAttackerDmgScale) == 0x000004, "Member 'FLevelBasedDamageScale::HigherLevelAttackerDmgScale' has a wrong offset!");
static_assert(offsetof(FLevelBasedDamageScale, LowerLevelAttackerDmgScale) == 0x000008, "Member 'FLevelBasedDamageScale::LowerLevelAttackerDmgScale' has a wrong offset!");

// ScriptStruct GbxGameSystemCore.ActorPartSelectionOverrideData
// 0x0010 (0x0010 - 0x0000)
struct FActorPartSelectionOverrideData final
{
public:
	TArray<struct FActorPartList>                 PreferredParts;                                    // 0x0000(0x0010)(ZeroConstructor, Transient, NativeAccessSpecifierPublic)
};
static_assert(alignof(FActorPartSelectionOverrideData) == 0x000008, "Wrong alignment on FActorPartSelectionOverrideData");
static_assert(sizeof(FActorPartSelectionOverrideData) == 0x000010, "Wrong size on FActorPartSelectionOverrideData");
static_assert(offsetof(FActorPartSelectionOverrideData, PreferredParts) == 0x000000, "Member 'FActorPartSelectionOverrideData::PreferredParts' has a wrong offset!");

// ScriptStruct GbxGameSystemCore.MinimalStaticRigidBodyState
// 0x001C (0x001C - 0x0000)
struct FMinimalStaticRigidBodyState final
{
public:
	uint32                                        BoneIndex;                                         // 0x0000(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector_NetQuantize100                 Position;                                          // 0x0004(0x000C)(NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FRotator                               Rotation;                                          // 0x0010(0x000C)(IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(FMinimalStaticRigidBodyState) == 0x000004, "Wrong alignment on FMinimalStaticRigidBodyState");
static_assert(sizeof(FMinimalStaticRigidBodyState) == 0x00001C, "Wrong size on FMinimalStaticRigidBodyState");
static_assert(offsetof(FMinimalStaticRigidBodyState, BoneIndex) == 0x000000, "Member 'FMinimalStaticRigidBodyState::BoneIndex' has a wrong offset!");
static_assert(offsetof(FMinimalStaticRigidBodyState, Position) == 0x000004, "Member 'FMinimalStaticRigidBodyState::Position' has a wrong offset!");
static_assert(offsetof(FMinimalStaticRigidBodyState, Rotation) == 0x000010, "Member 'FMinimalStaticRigidBodyState::Rotation' has a wrong offset!");

// ScriptStruct GbxGameSystemCore.StaticRagdollReplicationData
// 0x0010 (0x0010 - 0x0000)
struct FStaticRagdollReplicationData final
{
public:
	TArray<struct FMinimalStaticRigidBodyState>   Bodies;                                            // 0x0000(0x0010)(ZeroConstructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(FStaticRagdollReplicationData) == 0x000008, "Wrong alignment on FStaticRagdollReplicationData");
static_assert(sizeof(FStaticRagdollReplicationData) == 0x000010, "Wrong size on FStaticRagdollReplicationData");
static_assert(offsetof(FStaticRagdollReplicationData, Bodies) == 0x000000, "Member 'FStaticRagdollReplicationData::Bodies' has a wrong offset!");

// ScriptStruct GbxGameSystemCore.AimSensitivityLevelParameters
// 0x001C (0x001C - 0x0000)
struct FAimSensitivityLevelParameters final
{
public:
	int32                                         Index;                                             // 0x0000(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         YawMaxRotationRate;                                // 0x0004(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         PitchMaxRotationRate;                              // 0x0008(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         TurningExtraYaw;                                   // 0x000C(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         TurningExtraPitch;                                 // 0x0010(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         TurningRampUpTime;                                 // 0x0014(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         TurningRampUpDelay;                                // 0x0018(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FAimSensitivityLevelParameters) == 0x000004, "Wrong alignment on FAimSensitivityLevelParameters");
static_assert(sizeof(FAimSensitivityLevelParameters) == 0x00001C, "Wrong size on FAimSensitivityLevelParameters");
static_assert(offsetof(FAimSensitivityLevelParameters, Index) == 0x000000, "Member 'FAimSensitivityLevelParameters::Index' has a wrong offset!");
static_assert(offsetof(FAimSensitivityLevelParameters, YawMaxRotationRate) == 0x000004, "Member 'FAimSensitivityLevelParameters::YawMaxRotationRate' has a wrong offset!");
static_assert(offsetof(FAimSensitivityLevelParameters, PitchMaxRotationRate) == 0x000008, "Member 'FAimSensitivityLevelParameters::PitchMaxRotationRate' has a wrong offset!");
static_assert(offsetof(FAimSensitivityLevelParameters, TurningExtraYaw) == 0x00000C, "Member 'FAimSensitivityLevelParameters::TurningExtraYaw' has a wrong offset!");
static_assert(offsetof(FAimSensitivityLevelParameters, TurningExtraPitch) == 0x000010, "Member 'FAimSensitivityLevelParameters::TurningExtraPitch' has a wrong offset!");
static_assert(offsetof(FAimSensitivityLevelParameters, TurningRampUpTime) == 0x000014, "Member 'FAimSensitivityLevelParameters::TurningRampUpTime' has a wrong offset!");
static_assert(offsetof(FAimSensitivityLevelParameters, TurningRampUpDelay) == 0x000018, "Member 'FAimSensitivityLevelParameters::TurningRampUpDelay' has a wrong offset!");

// ScriptStruct GbxGameSystemCore.RuntimeActorPartListPartTypeData
// 0x0008 (0x0008 - 0x0000)
struct FRuntimeActorPartListPartTypeData final
{
public:
	int32                                         StartIndex;                                        // 0x0000(0x0004)(Edit, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	int32                                         NumParts;                                          // 0x0004(0x0004)(Edit, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
};
static_assert(alignof(FRuntimeActorPartListPartTypeData) == 0x000004, "Wrong alignment on FRuntimeActorPartListPartTypeData");
static_assert(sizeof(FRuntimeActorPartListPartTypeData) == 0x000008, "Wrong size on FRuntimeActorPartListPartTypeData");
static_assert(offsetof(FRuntimeActorPartListPartTypeData, StartIndex) == 0x000000, "Member 'FRuntimeActorPartListPartTypeData::StartIndex' has a wrong offset!");
static_assert(offsetof(FRuntimeActorPartListPartTypeData, NumParts) == 0x000004, "Member 'FRuntimeActorPartListPartTypeData::NumParts' has a wrong offset!");

// ScriptStruct GbxGameSystemCore.GbxAttributeModifierHandle
// 0x0010 (0x0010 - 0x0000)
struct alignas(0x08) FGbxAttributeModifierHandle final
{
public:
	uint8                                         Pad_0[0x10];                                       // 0x0000(0x0010)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FGbxAttributeModifierHandle) == 0x000008, "Wrong alignment on FGbxAttributeModifierHandle");
static_assert(sizeof(FGbxAttributeModifierHandle) == 0x000010, "Wrong size on FGbxAttributeModifierHandle");

// ScriptStruct GbxGameSystemCore.DefaultExplosionSettings
// 0x0010 (0x0010 - 0x0000)
struct FDefaultExplosionSettings final
{
public:
	float                                         ExplosionSize;                                     // 0x0000(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FRadialBlurSelection                   RadialBlur;                                        // 0x0004(0x000C)(Edit, NoDestructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(FDefaultExplosionSettings) == 0x000004, "Wrong alignment on FDefaultExplosionSettings");
static_assert(sizeof(FDefaultExplosionSettings) == 0x000010, "Wrong size on FDefaultExplosionSettings");
static_assert(offsetof(FDefaultExplosionSettings, ExplosionSize) == 0x000000, "Member 'FDefaultExplosionSettings::ExplosionSize' has a wrong offset!");
static_assert(offsetof(FDefaultExplosionSettings, RadialBlur) == 0x000004, "Member 'FDefaultExplosionSettings::RadialBlur' has a wrong offset!");

// ScriptStruct GbxGameSystemCore.RegisteredConditionalDamageCriticalModifier
// 0x0010 (0x0010 - 0x0000)
struct FRegisteredConditionalDamageCriticalModifier final
{
public:
	class UConditionalDamageCriticalModifier*     Modifier;                                          // 0x0000(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UObject*                                ModifierValueContextOverride;                      // 0x0008(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FRegisteredConditionalDamageCriticalModifier) == 0x000008, "Wrong alignment on FRegisteredConditionalDamageCriticalModifier");
static_assert(sizeof(FRegisteredConditionalDamageCriticalModifier) == 0x000010, "Wrong size on FRegisteredConditionalDamageCriticalModifier");
static_assert(offsetof(FRegisteredConditionalDamageCriticalModifier, Modifier) == 0x000000, "Member 'FRegisteredConditionalDamageCriticalModifier::Modifier' has a wrong offset!");
static_assert(offsetof(FRegisteredConditionalDamageCriticalModifier, ModifierValueContextOverride) == 0x000008, "Member 'FRegisteredConditionalDamageCriticalModifier::ModifierValueContextOverride' has a wrong offset!");

// ScriptStruct GbxGameSystemCore.ActionStateNet
// 0x0108 (0x0108 - 0x0000)
struct alignas(0x08) FActionStateNet final
{
public:
	uint8                                         Pad_0[0x108];                                      // 0x0000(0x0108)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FActionStateNet) == 0x000008, "Wrong alignment on FActionStateNet");
static_assert(sizeof(FActionStateNet) == 0x000108, "Wrong size on FActionStateNet");

// ScriptStruct GbxGameSystemCore.RegisteredConditionalDamageValueModifier
// 0x0010 (0x0010 - 0x0000)
struct FRegisteredConditionalDamageValueModifier final
{
public:
	class UConditionalDamageValueModifier*        Modifier;                                          // 0x0000(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UObject*                                DamageValueContextOverride;                        // 0x0008(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FRegisteredConditionalDamageValueModifier) == 0x000008, "Wrong alignment on FRegisteredConditionalDamageValueModifier");
static_assert(sizeof(FRegisteredConditionalDamageValueModifier) == 0x000010, "Wrong size on FRegisteredConditionalDamageValueModifier");
static_assert(offsetof(FRegisteredConditionalDamageValueModifier, Modifier) == 0x000000, "Member 'FRegisteredConditionalDamageValueModifier::Modifier' has a wrong offset!");
static_assert(offsetof(FRegisteredConditionalDamageValueModifier, DamageValueContextOverride) == 0x000008, "Member 'FRegisteredConditionalDamageValueModifier::DamageValueContextOverride' has a wrong offset!");

// ScriptStruct GbxGameSystemCore.ReflectedDamageParams
// 0x0018 (0x0018 - 0x0000)
struct FReflectedDamageParams final
{
public:
	float                                         DamageScale;                                       // 0x0000(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         DamageTakenScale;                                  // 0x0004(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bReflectTowardAttacker;                            // 0x0008(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_9[0x7];                                        // 0x0009(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	TSubclassOf<class UGbxDamageType>             DamageType;                                        // 0x0010(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FReflectedDamageParams) == 0x000008, "Wrong alignment on FReflectedDamageParams");
static_assert(sizeof(FReflectedDamageParams) == 0x000018, "Wrong size on FReflectedDamageParams");
static_assert(offsetof(FReflectedDamageParams, DamageScale) == 0x000000, "Member 'FReflectedDamageParams::DamageScale' has a wrong offset!");
static_assert(offsetof(FReflectedDamageParams, DamageTakenScale) == 0x000004, "Member 'FReflectedDamageParams::DamageTakenScale' has a wrong offset!");
static_assert(offsetof(FReflectedDamageParams, bReflectTowardAttacker) == 0x000008, "Member 'FReflectedDamageParams::bReflectTowardAttacker' has a wrong offset!");
static_assert(offsetof(FReflectedDamageParams, DamageType) == 0x000010, "Member 'FReflectedDamageParams::DamageType' has a wrong offset!");

// ScriptStruct GbxGameSystemCore.GbxObjectReplicatorProxyItem
// 0x0018 (0x0018 - 0x0000)
struct FGbxObjectReplicatorProxyItem final
{
public:
	TScriptInterface<class IGbxReplicatorProxyData> Object;                                            // 0x0000(0x0010)(ZeroConstructor, IsPlainOldData, NoDestructor, UObjectWrapper, NativeAccessSpecifierPublic)
	class UActorComponent*                        Component;                                         // 0x0010(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FGbxObjectReplicatorProxyItem) == 0x000008, "Wrong alignment on FGbxObjectReplicatorProxyItem");
static_assert(sizeof(FGbxObjectReplicatorProxyItem) == 0x000018, "Wrong size on FGbxObjectReplicatorProxyItem");
static_assert(offsetof(FGbxObjectReplicatorProxyItem, Object) == 0x000000, "Member 'FGbxObjectReplicatorProxyItem::Object' has a wrong offset!");
static_assert(offsetof(FGbxObjectReplicatorProxyItem, Component) == 0x000010, "Member 'FGbxObjectReplicatorProxyItem::Component' has a wrong offset!");

// ScriptStruct GbxGameSystemCore.GbxObjectReplicatorProxy
// 0x0068 (0x0068 - 0x0000)
struct FGbxObjectReplicatorProxy final
{
public:
	TArray<struct FGbxObjectReplicatorProxyItem>  Items;                                             // 0x0000(0x0010)(ZeroConstructor, ContainsInstancedReference, NativeAccessSpecifierPrivate)
	uint8                                         Pad_10[0x58];                                      // 0x0010(0x0058)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FGbxObjectReplicatorProxy) == 0x000008, "Wrong alignment on FGbxObjectReplicatorProxy");
static_assert(sizeof(FGbxObjectReplicatorProxy) == 0x000068, "Wrong size on FGbxObjectReplicatorProxy");
static_assert(offsetof(FGbxObjectReplicatorProxy, Items) == 0x000000, "Member 'FGbxObjectReplicatorProxy::Items' has a wrong offset!");

// ScriptStruct GbxGameSystemCore.AttitudeDamageRules
// 0x0004 (0x0004 - 0x0000)
struct alignas(0x04) FAttitudeDamageRules final
{
public:
	uint8                                         bAllowHostileDamage : 1;                           // 0x0000(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (Edit, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         bAllowNeutralDamage : 1;                           // 0x0000(0x0001)(BitIndex: 0x01, PropSize: 0x0001 (Edit, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         bAllowFriendlyDamage : 1;                          // 0x0000(0x0001)(BitIndex: 0x02, PropSize: 0x0001 (Edit, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         Pad_1[0x3];                                        // 0x0001(0x0003)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FAttitudeDamageRules) == 0x000004, "Wrong alignment on FAttitudeDamageRules");
static_assert(sizeof(FAttitudeDamageRules) == 0x000004, "Wrong size on FAttitudeDamageRules");

// ScriptStruct GbxGameSystemCore.DamageGoreModifiers
// 0x0008 (0x0008 - 0x0000)
struct FDamageGoreModifiers final
{
public:
	float                                         GoreModifier;                                      // 0x0000(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         GibModifier;                                       // 0x0004(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FDamageGoreModifiers) == 0x000004, "Wrong alignment on FDamageGoreModifiers");
static_assert(sizeof(FDamageGoreModifiers) == 0x000008, "Wrong size on FDamageGoreModifiers");
static_assert(offsetof(FDamageGoreModifiers, GoreModifier) == 0x000000, "Member 'FDamageGoreModifiers::GoreModifier' has a wrong offset!");
static_assert(offsetof(FDamageGoreModifiers, GibModifier) == 0x000004, "Member 'FDamageGoreModifiers::GibModifier' has a wrong offset!");

// ScriptStruct GbxGameSystemCore.RagdollReplicationData
// 0x0018 (0x0018 - 0x0000)
struct FRagdollReplicationData final
{
public:
	uint8                                         Pad_0[0x8];                                        // 0x0000(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<struct FArticulatedRigidBodyState>     Bodies;                                            // 0x0008(0x0010)(ZeroConstructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(FRagdollReplicationData) == 0x000008, "Wrong alignment on FRagdollReplicationData");
static_assert(sizeof(FRagdollReplicationData) == 0x000018, "Wrong size on FRagdollReplicationData");
static_assert(offsetof(FRagdollReplicationData, Bodies) == 0x000008, "Member 'FRagdollReplicationData::Bodies' has a wrong offset!");

// ScriptStruct GbxGameSystemCore.AttributeEffectReference
// 0x0010 (0x0010 - 0x0000)
struct FAttributeEffectReference final
{
public:
	class UStatusEffectData*                      StatusEffectData;                                  // 0x0000(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_8[0x8];                                        // 0x0008(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FAttributeEffectReference) == 0x000008, "Wrong alignment on FAttributeEffectReference");
static_assert(sizeof(FAttributeEffectReference) == 0x000010, "Wrong size on FAttributeEffectReference");
static_assert(offsetof(FAttributeEffectReference, StatusEffectData) == 0x000000, "Member 'FAttributeEffectReference::StatusEffectData' has a wrong offset!");

// ScriptStruct GbxGameSystemCore.HitRegionInfo
// 0x0010 (0x0010 - 0x0000)
struct FHitRegionInfo final
{
public:
	class UHitRegionData*                         Data;                                              // 0x0000(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         StateIndex;                                        // 0x0008(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_C[0x4];                                        // 0x000C(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FHitRegionInfo) == 0x000008, "Wrong alignment on FHitRegionInfo");
static_assert(sizeof(FHitRegionInfo) == 0x000010, "Wrong size on FHitRegionInfo");
static_assert(offsetof(FHitRegionInfo, Data) == 0x000000, "Member 'FHitRegionInfo::Data' has a wrong offset!");
static_assert(offsetof(FHitRegionInfo, StateIndex) == 0x000008, "Member 'FHitRegionInfo::StateIndex' has a wrong offset!");

// ScriptStruct GbxGameSystemCore.DamageReactionEventSummary
// 0x0060 (0x0060 - 0x0000)
struct FDamageReactionEventSummary final
{
public:
	class APawn*                                  DamageCauser;                                      // 0x0000(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                HitLocation;                                       // 0x0008(0x000C)(BlueprintVisible, BlueprintReadOnly, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                HitDirection;                                      // 0x0014(0x000C)(BlueprintVisible, BlueprintReadOnly, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TSubclassOf<class UDamageSource>              DamageSource;                                      // 0x0020(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TSubclassOf<class UGbxDamageType>             DamageType;                                        // 0x0028(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UPrimitiveComponent*                    HitComponent;                                      // 0x0030(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FHitRegionInfo                         HitRegion;                                         // 0x0038(0x0010)(BlueprintVisible, BlueprintReadOnly, NoDestructor, NativeAccessSpecifierPublic)
	struct FVector                                Origin;                                            // 0x0048(0x000C)(BlueprintVisible, BlueprintReadOnly, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         Radius;                                            // 0x0054(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         EventIndex;                                        // 0x0058(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_5C[0x4];                                       // 0x005C(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FDamageReactionEventSummary) == 0x000008, "Wrong alignment on FDamageReactionEventSummary");
static_assert(sizeof(FDamageReactionEventSummary) == 0x000060, "Wrong size on FDamageReactionEventSummary");
static_assert(offsetof(FDamageReactionEventSummary, DamageCauser) == 0x000000, "Member 'FDamageReactionEventSummary::DamageCauser' has a wrong offset!");
static_assert(offsetof(FDamageReactionEventSummary, HitLocation) == 0x000008, "Member 'FDamageReactionEventSummary::HitLocation' has a wrong offset!");
static_assert(offsetof(FDamageReactionEventSummary, HitDirection) == 0x000014, "Member 'FDamageReactionEventSummary::HitDirection' has a wrong offset!");
static_assert(offsetof(FDamageReactionEventSummary, DamageSource) == 0x000020, "Member 'FDamageReactionEventSummary::DamageSource' has a wrong offset!");
static_assert(offsetof(FDamageReactionEventSummary, DamageType) == 0x000028, "Member 'FDamageReactionEventSummary::DamageType' has a wrong offset!");
static_assert(offsetof(FDamageReactionEventSummary, HitComponent) == 0x000030, "Member 'FDamageReactionEventSummary::HitComponent' has a wrong offset!");
static_assert(offsetof(FDamageReactionEventSummary, HitRegion) == 0x000038, "Member 'FDamageReactionEventSummary::HitRegion' has a wrong offset!");
static_assert(offsetof(FDamageReactionEventSummary, Origin) == 0x000048, "Member 'FDamageReactionEventSummary::Origin' has a wrong offset!");
static_assert(offsetof(FDamageReactionEventSummary, Radius) == 0x000054, "Member 'FDamageReactionEventSummary::Radius' has a wrong offset!");
static_assert(offsetof(FDamageReactionEventSummary, EventIndex) == 0x000058, "Member 'FDamageReactionEventSummary::EventIndex' has a wrong offset!");

// ScriptStruct GbxGameSystemCore.GibData
// 0x0028 (0x0028 - 0x0000)
struct FGibData final
{
public:
	int32                                         MaxCount;                                          // 0x0000(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         SelectionWeight;                                   // 0x0004(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bOverrideGlobalScale;                              // 0x0008(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_9[0x3];                                        // 0x0009(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         MinScale;                                          // 0x000C(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         MaxScale;                                          // 0x0010(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_14[0x4];                                       // 0x0014(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class UObject*                                Mesh;                                              // 0x0018(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UMaterialInstanceConstant*              MaterialOverride;                                  // 0x0020(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FGibData) == 0x000008, "Wrong alignment on FGibData");
static_assert(sizeof(FGibData) == 0x000028, "Wrong size on FGibData");
static_assert(offsetof(FGibData, MaxCount) == 0x000000, "Member 'FGibData::MaxCount' has a wrong offset!");
static_assert(offsetof(FGibData, SelectionWeight) == 0x000004, "Member 'FGibData::SelectionWeight' has a wrong offset!");
static_assert(offsetof(FGibData, bOverrideGlobalScale) == 0x000008, "Member 'FGibData::bOverrideGlobalScale' has a wrong offset!");
static_assert(offsetof(FGibData, MinScale) == 0x00000C, "Member 'FGibData::MinScale' has a wrong offset!");
static_assert(offsetof(FGibData, MaxScale) == 0x000010, "Member 'FGibData::MaxScale' has a wrong offset!");
static_assert(offsetof(FGibData, Mesh) == 0x000018, "Member 'FGibData::Mesh' has a wrong offset!");
static_assert(offsetof(FGibData, MaterialOverride) == 0x000020, "Member 'FGibData::MaterialOverride' has a wrong offset!");

// ScriptStruct GbxGameSystemCore.WeightedAnim
// 0x00B0 (0x00B0 - 0x0000)
struct FWeightedAnim final
{
public:
	struct FAnimMeshList                          Anims;                                             // 0x0000(0x0078)(Edit, NativeAccessSpecifierPublic)
	struct FAttributeInitializationData           Weight;                                            // 0x0078(0x0038)(Edit, NoDestructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(FWeightedAnim) == 0x000008, "Wrong alignment on FWeightedAnim");
static_assert(sizeof(FWeightedAnim) == 0x0000B0, "Wrong size on FWeightedAnim");
static_assert(offsetof(FWeightedAnim, Anims) == 0x000000, "Member 'FWeightedAnim::Anims' has a wrong offset!");
static_assert(offsetof(FWeightedAnim, Weight) == 0x000078, "Member 'FWeightedAnim::Weight' has a wrong offset!");

// ScriptStruct GbxGameSystemCore.StanceFloatValue
// 0x0008 (0x0008 - 0x0000)
struct FStanceFloatValue final
{
public:
	EStanceValueOverrideType                      ValueType;                                         // 0x0000(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1[0x3];                                        // 0x0001(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         Value;                                             // 0x0004(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FStanceFloatValue) == 0x000004, "Wrong alignment on FStanceFloatValue");
static_assert(sizeof(FStanceFloatValue) == 0x000008, "Wrong size on FStanceFloatValue");
static_assert(offsetof(FStanceFloatValue, ValueType) == 0x000000, "Member 'FStanceFloatValue::ValueType' has a wrong offset!");
static_assert(offsetof(FStanceFloatValue, Value) == 0x000004, "Member 'FStanceFloatValue::Value' has a wrong offset!");

// ScriptStruct GbxGameSystemCore.StatusEffectRemoveSpec
// 0x0010 (0x0010 - 0x0000)
struct FStatusEffectRemoveSpec final
{
public:
	class UStatusEffectData*                      StatusEffectData;                                  // 0x0000(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UObject*                                EffectOwner;                                       // 0x0008(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FStatusEffectRemoveSpec) == 0x000008, "Wrong alignment on FStatusEffectRemoveSpec");
static_assert(sizeof(FStatusEffectRemoveSpec) == 0x000010, "Wrong size on FStatusEffectRemoveSpec");
static_assert(offsetof(FStatusEffectRemoveSpec, StatusEffectData) == 0x000000, "Member 'FStatusEffectRemoveSpec::StatusEffectData' has a wrong offset!");
static_assert(offsetof(FStatusEffectRemoveSpec, EffectOwner) == 0x000008, "Member 'FStatusEffectRemoveSpec::EffectOwner' has a wrong offset!");

// ScriptStruct GbxGameSystemCore.CachedUIStatData
// 0x0040 (0x0040 - 0x0000)
struct FCachedUIStatData final
{
public:
	class UUIStatData*                            Stat;                                              // 0x0000(0x0008)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class FText                                   Description;                                       // 0x0008(0x0018)(Transient, NativeAccessSpecifierPrivate)
	class FText                                   ValueText;                                         // 0x0020(0x0018)(Transient, NativeAccessSpecifierPrivate)
	float                                         ComparisonValue;                                   // 0x0038(0x0004)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	EUIStatComparisonResult                       ComparisonResult;                                  // 0x003C(0x0001)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_3D[0x3];                                       // 0x003D(0x0003)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FCachedUIStatData) == 0x000008, "Wrong alignment on FCachedUIStatData");
static_assert(sizeof(FCachedUIStatData) == 0x000040, "Wrong size on FCachedUIStatData");
static_assert(offsetof(FCachedUIStatData, Stat) == 0x000000, "Member 'FCachedUIStatData::Stat' has a wrong offset!");
static_assert(offsetof(FCachedUIStatData, Description) == 0x000008, "Member 'FCachedUIStatData::Description' has a wrong offset!");
static_assert(offsetof(FCachedUIStatData, ValueText) == 0x000020, "Member 'FCachedUIStatData::ValueText' has a wrong offset!");
static_assert(offsetof(FCachedUIStatData, ComparisonValue) == 0x000038, "Member 'FCachedUIStatData::ComparisonValue' has a wrong offset!");
static_assert(offsetof(FCachedUIStatData, ComparisonResult) == 0x00003C, "Member 'FCachedUIStatData::ComparisonResult' has a wrong offset!");

// ScriptStruct GbxGameSystemCore.CachedUIStatSectionData
// 0x0018 (0x0018 - 0x0000)
struct FCachedUIStatSectionData final
{
public:
	class FName                                   Name;                                              // 0x0000(0x0008)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	TArray<struct FCachedUIStatData>              Stats;                                             // 0x0008(0x0010)(ZeroConstructor, Transient, NativeAccessSpecifierPrivate)
};
static_assert(alignof(FCachedUIStatSectionData) == 0x000008, "Wrong alignment on FCachedUIStatSectionData");
static_assert(sizeof(FCachedUIStatSectionData) == 0x000018, "Wrong size on FCachedUIStatSectionData");
static_assert(offsetof(FCachedUIStatSectionData, Name) == 0x000000, "Member 'FCachedUIStatSectionData::Name' has a wrong offset!");
static_assert(offsetof(FCachedUIStatSectionData, Stats) == 0x000008, "Member 'FCachedUIStatSectionData::Stats' has a wrong offset!");

// ScriptStruct GbxGameSystemCore.CachedUIStatCollectionData
// 0x0010 (0x0010 - 0x0000)
struct FCachedUIStatCollectionData final
{
public:
	TArray<struct FCachedUIStatSectionData>       Sections;                                          // 0x0000(0x0010)(ZeroConstructor, Transient, NativeAccessSpecifierPrivate)
};
static_assert(alignof(FCachedUIStatCollectionData) == 0x000008, "Wrong alignment on FCachedUIStatCollectionData");
static_assert(sizeof(FCachedUIStatCollectionData) == 0x000010, "Wrong size on FCachedUIStatCollectionData");
static_assert(offsetof(FCachedUIStatCollectionData, Sections) == 0x000000, "Member 'FCachedUIStatCollectionData::Sections' has a wrong offset!");

// ScriptStruct GbxGameSystemCore.DamageScaleConditionalData
// 0x0050 (0x0050 - 0x0000)
struct FDamageScaleConditionalData final
{
public:
	bool                                          bEvaluateUsingAttacker;                            // 0x0000(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1[0x7];                                        // 0x0001(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	class UGbxCondition*                          Condition;                                         // 0x0008(0x0008)(Edit, ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, PersistentInstance, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bAddValueToDamage;                                 // 0x0010(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_11[0x7];                                       // 0x0011(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	struct FAttributeInitializationData           DamageScale;                                       // 0x0018(0x0038)(Edit, NoDestructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(FDamageScaleConditionalData) == 0x000008, "Wrong alignment on FDamageScaleConditionalData");
static_assert(sizeof(FDamageScaleConditionalData) == 0x000050, "Wrong size on FDamageScaleConditionalData");
static_assert(offsetof(FDamageScaleConditionalData, bEvaluateUsingAttacker) == 0x000000, "Member 'FDamageScaleConditionalData::bEvaluateUsingAttacker' has a wrong offset!");
static_assert(offsetof(FDamageScaleConditionalData, Condition) == 0x000008, "Member 'FDamageScaleConditionalData::Condition' has a wrong offset!");
static_assert(offsetof(FDamageScaleConditionalData, bAddValueToDamage) == 0x000010, "Member 'FDamageScaleConditionalData::bAddValueToDamage' has a wrong offset!");
static_assert(offsetof(FDamageScaleConditionalData, DamageScale) == 0x000018, "Member 'FDamageScaleConditionalData::DamageScale' has a wrong offset!");

// ScriptStruct GbxGameSystemCore.StatusEffectQueryResult
// 0x0010 (0x0010 - 0x0000)
struct FStatusEffectQueryResult final
{
public:
	int32                                         NumberOfInstances;                                 // 0x0000(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         DPS;                                               // 0x0004(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_8[0x8];                                        // 0x0008(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FStatusEffectQueryResult) == 0x000004, "Wrong alignment on FStatusEffectQueryResult");
static_assert(sizeof(FStatusEffectQueryResult) == 0x000010, "Wrong size on FStatusEffectQueryResult");
static_assert(offsetof(FStatusEffectQueryResult, NumberOfInstances) == 0x000000, "Member 'FStatusEffectQueryResult::NumberOfInstances' has a wrong offset!");
static_assert(offsetof(FStatusEffectQueryResult, DPS) == 0x000004, "Member 'FStatusEffectQueryResult::DPS' has a wrong offset!");

// ScriptStruct GbxGameSystemCore.StatusEffectQuery
// 0x0018 (0x0018 - 0x0000)
struct FStatusEffectQuery final
{
public:
	class UStatusEffectData*                      StatusEffectData;                                  // 0x0000(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UObject*                                Owner;                                             // 0x0008(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_10[0x8];                                       // 0x0010(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FStatusEffectQuery) == 0x000008, "Wrong alignment on FStatusEffectQuery");
static_assert(sizeof(FStatusEffectQuery) == 0x000018, "Wrong size on FStatusEffectQuery");
static_assert(offsetof(FStatusEffectQuery, StatusEffectData) == 0x000000, "Member 'FStatusEffectQuery::StatusEffectData' has a wrong offset!");
static_assert(offsetof(FStatusEffectQuery, Owner) == 0x000008, "Member 'FStatusEffectQuery::Owner' has a wrong offset!");

// ScriptStruct GbxGameSystemCore.AppliedAttributeEffect
// 0x0038 (0x0038 - 0x0000)
struct FAppliedAttributeEffect final
{
public:
	struct FAttributeEffectReference              AttributeEffectRef;                                // 0x0000(0x0010)(NoDestructor, NativeAccessSpecifierPublic)
	class UObject*                                AttributeResolutionContext;                        // 0x0010(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UStatusEffectManagerComponent*          Owner;                                             // 0x0018(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_20[0x18];                                      // 0x0020(0x0018)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FAppliedAttributeEffect) == 0x000008, "Wrong alignment on FAppliedAttributeEffect");
static_assert(sizeof(FAppliedAttributeEffect) == 0x000038, "Wrong size on FAppliedAttributeEffect");
static_assert(offsetof(FAppliedAttributeEffect, AttributeEffectRef) == 0x000000, "Member 'FAppliedAttributeEffect::AttributeEffectRef' has a wrong offset!");
static_assert(offsetof(FAppliedAttributeEffect, AttributeResolutionContext) == 0x000010, "Member 'FAppliedAttributeEffect::AttributeResolutionContext' has a wrong offset!");
static_assert(offsetof(FAppliedAttributeEffect, Owner) == 0x000018, "Member 'FAppliedAttributeEffect::Owner' has a wrong offset!");

// ScriptStruct GbxGameSystemCore.PipelineDamageInput
// 0x01B0 (0x01B0 - 0x0000)
struct alignas(0x10) FPipelineDamageInput
{
public:
	class UDamageComponent*                       DamageReceiverComp;                                // 0x0000(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TScriptInterface<class IDamageableInterface>  Damageable;                                        // 0x0008(0x0010)(ZeroConstructor, IsPlainOldData, NoDestructor, UObjectWrapper, NativeAccessSpecifierPublic)
	class APawn*                                  InstigatorPawn;                                    // 0x0018(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class APawn*                                  AdditionalEventListenerPawn;                       // 0x0020(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class AActor*                                 DamageCauser;                                      // 0x0028(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UDamageModifierComponent*               DamageModifierComp;                                // 0x0030(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class AController*                            InstigatorController;                              // 0x0038(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TSubclassOf<class UDamageSource>              DamageSource;                                      // 0x0040(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TSubclassOf<class UGbxDamageType>             DamageType;                                        // 0x0048(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_50[0x90];                                      // 0x0050(0x0090)(Fixing Size After Last Property [ Dumper-7 ])
	class UImpactData*                            ImpactData;                                        // 0x00E0(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UFeedbackData*                          InstigatorFeedback;                                // 0x00E8(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         bSimulatedOnClient : 1;                            // 0x00F0(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         Pad_F1[0x9F];                                      // 0x00F1(0x009F)(Fixing Size After Last Property [ Dumper-7 ])
	struct FCriticalHitDamageOverrides            CriticalHitOverrides;                              // 0x0190(0x0008)(NoDestructor, NativeAccessSpecifierPublic)
	struct FDamageGoreModifiers                   GoreModifiers;                                     // 0x0198(0x0008)(NoDestructor, NativeAccessSpecifierPublic)
	uint8                                         Pad_1A0[0x10];                                     // 0x01A0(0x0010)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FPipelineDamageInput) == 0x000010, "Wrong alignment on FPipelineDamageInput");
static_assert(sizeof(FPipelineDamageInput) == 0x0001B0, "Wrong size on FPipelineDamageInput");
static_assert(offsetof(FPipelineDamageInput, DamageReceiverComp) == 0x000000, "Member 'FPipelineDamageInput::DamageReceiverComp' has a wrong offset!");
static_assert(offsetof(FPipelineDamageInput, Damageable) == 0x000008, "Member 'FPipelineDamageInput::Damageable' has a wrong offset!");
static_assert(offsetof(FPipelineDamageInput, InstigatorPawn) == 0x000018, "Member 'FPipelineDamageInput::InstigatorPawn' has a wrong offset!");
static_assert(offsetof(FPipelineDamageInput, AdditionalEventListenerPawn) == 0x000020, "Member 'FPipelineDamageInput::AdditionalEventListenerPawn' has a wrong offset!");
static_assert(offsetof(FPipelineDamageInput, DamageCauser) == 0x000028, "Member 'FPipelineDamageInput::DamageCauser' has a wrong offset!");
static_assert(offsetof(FPipelineDamageInput, DamageModifierComp) == 0x000030, "Member 'FPipelineDamageInput::DamageModifierComp' has a wrong offset!");
static_assert(offsetof(FPipelineDamageInput, InstigatorController) == 0x000038, "Member 'FPipelineDamageInput::InstigatorController' has a wrong offset!");
static_assert(offsetof(FPipelineDamageInput, DamageSource) == 0x000040, "Member 'FPipelineDamageInput::DamageSource' has a wrong offset!");
static_assert(offsetof(FPipelineDamageInput, DamageType) == 0x000048, "Member 'FPipelineDamageInput::DamageType' has a wrong offset!");
static_assert(offsetof(FPipelineDamageInput, ImpactData) == 0x0000E0, "Member 'FPipelineDamageInput::ImpactData' has a wrong offset!");
static_assert(offsetof(FPipelineDamageInput, InstigatorFeedback) == 0x0000E8, "Member 'FPipelineDamageInput::InstigatorFeedback' has a wrong offset!");
static_assert(offsetof(FPipelineDamageInput, CriticalHitOverrides) == 0x000190, "Member 'FPipelineDamageInput::CriticalHitOverrides' has a wrong offset!");
static_assert(offsetof(FPipelineDamageInput, GoreModifiers) == 0x000198, "Member 'FPipelineDamageInput::GoreModifiers' has a wrong offset!");

// ScriptStruct GbxGameSystemCore.DamageOverTimeContribution
// 0x01C0 (0x01C0 - 0x0000)
struct FDamageOverTimeContribution final
{
public:
	struct FPipelineDamageInput                   PipelineInput;                                     // 0x0000(0x01B0)(ContainsInstancedReference, NativeAccessSpecifierPublic)
	uint8                                         Pad_1B0[0x10];                                     // 0x01B0(0x0010)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FDamageOverTimeContribution) == 0x000010, "Wrong alignment on FDamageOverTimeContribution");
static_assert(sizeof(FDamageOverTimeContribution) == 0x0001C0, "Wrong size on FDamageOverTimeContribution");
static_assert(offsetof(FDamageOverTimeContribution, PipelineInput) == 0x000000, "Member 'FDamageOverTimeContribution::PipelineInput' has a wrong offset!");

// ScriptStruct GbxGameSystemCore.StatusEffectInstance
// 0x0048 (0x0048 - 0x0000)
struct FStatusEffectInstance final
{
public:
	struct FStatusEffectSpec                      Spec;                                              // 0x0000(0x0038)(NoDestructor, NativeAccessSpecifierPublic)
	uint8                                         Pad_38[0x10];                                      // 0x0038(0x0010)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FStatusEffectInstance) == 0x000008, "Wrong alignment on FStatusEffectInstance");
static_assert(sizeof(FStatusEffectInstance) == 0x000048, "Wrong size on FStatusEffectInstance");
static_assert(offsetof(FStatusEffectInstance, Spec) == 0x000000, "Member 'FStatusEffectInstance::Spec' has a wrong offset!");

// ScriptStruct GbxGameSystemCore.StatusEffectInstanceStack
// 0x0070 (0x0070 - 0x0000)
struct FStatusEffectInstanceStack final
{
public:
	class UStatusEffectManagerComponent*          Owner;                                             // 0x0000(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UStatusEffectData*                      StatusEffectData;                                  // 0x0008(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UDamageComponent*                       DoTDamageComponent;                                // 0x0010(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TArray<struct FAppliedAttributeEffect>        AttributeEffects;                                  // 0x0018(0x0010)(ZeroConstructor, ContainsInstancedReference, NativeAccessSpecifierPublic)
	uint8                                         Pad_28[0x10];                                      // 0x0028(0x0010)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<struct FDamageOverTimeContribution>    DPSContributions;                                  // 0x0038(0x0010)(ZeroConstructor, ContainsInstancedReference, NativeAccessSpecifierPublic)
	TArray<struct FStatusEffectInstance>          Instances;                                         // 0x0048(0x0010)(ZeroConstructor, NativeAccessSpecifierPublic)
	uint8                                         Pad_58[0x18];                                      // 0x0058(0x0018)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FStatusEffectInstanceStack) == 0x000008, "Wrong alignment on FStatusEffectInstanceStack");
static_assert(sizeof(FStatusEffectInstanceStack) == 0x000070, "Wrong size on FStatusEffectInstanceStack");
static_assert(offsetof(FStatusEffectInstanceStack, Owner) == 0x000000, "Member 'FStatusEffectInstanceStack::Owner' has a wrong offset!");
static_assert(offsetof(FStatusEffectInstanceStack, StatusEffectData) == 0x000008, "Member 'FStatusEffectInstanceStack::StatusEffectData' has a wrong offset!");
static_assert(offsetof(FStatusEffectInstanceStack, DoTDamageComponent) == 0x000010, "Member 'FStatusEffectInstanceStack::DoTDamageComponent' has a wrong offset!");
static_assert(offsetof(FStatusEffectInstanceStack, AttributeEffects) == 0x000018, "Member 'FStatusEffectInstanceStack::AttributeEffects' has a wrong offset!");
static_assert(offsetof(FStatusEffectInstanceStack, DPSContributions) == 0x000038, "Member 'FStatusEffectInstanceStack::DPSContributions' has a wrong offset!");
static_assert(offsetof(FStatusEffectInstanceStack, Instances) == 0x000048, "Member 'FStatusEffectInstanceStack::Instances' has a wrong offset!");

// ScriptStruct GbxGameSystemCore.AttributeEffectData
// 0x0048 (0x0048 - 0x0000)
struct FAttributeEffectData
{
public:
	class UGbxAttributeData*                      AttributeToModify;                                 // 0x0000(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EGbxAttributeModifierType                     ModifierType;                                      // 0x0008(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_9[0x7];                                        // 0x0009(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	struct FAttributeInitializationData           ModifierValue;                                     // 0x0010(0x0038)(Edit, NoDestructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(FAttributeEffectData) == 0x000008, "Wrong alignment on FAttributeEffectData");
static_assert(sizeof(FAttributeEffectData) == 0x000048, "Wrong size on FAttributeEffectData");
static_assert(offsetof(FAttributeEffectData, AttributeToModify) == 0x000000, "Member 'FAttributeEffectData::AttributeToModify' has a wrong offset!");
static_assert(offsetof(FAttributeEffectData, ModifierType) == 0x000008, "Member 'FAttributeEffectData::ModifierType' has a wrong offset!");
static_assert(offsetof(FAttributeEffectData, ModifierValue) == 0x000010, "Member 'FAttributeEffectData::ModifierValue' has a wrong offset!");

// ScriptStruct GbxGameSystemCore.InstigatorAttributeEffectData
// 0x0008 (0x0050 - 0x0048)
struct FInstigatorAttributeEffectData final : public FAttributeEffectData
{
public:
	EInstigatorAttributeEffectAttributeToModifyContextSource AttributeToModifyContextSource;                    // 0x0048(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EInstigatorAttributeEffectModifierValueContext ModifierValueContext;                              // 0x0049(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_4A[0x6];                                       // 0x004A(0x0006)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FInstigatorAttributeEffectData) == 0x000008, "Wrong alignment on FInstigatorAttributeEffectData");
static_assert(sizeof(FInstigatorAttributeEffectData) == 0x000050, "Wrong size on FInstigatorAttributeEffectData");
static_assert(offsetof(FInstigatorAttributeEffectData, AttributeToModifyContextSource) == 0x000048, "Member 'FInstigatorAttributeEffectData::AttributeToModifyContextSource' has a wrong offset!");
static_assert(offsetof(FInstigatorAttributeEffectData, ModifierValueContext) == 0x000049, "Member 'FInstigatorAttributeEffectData::ModifierValueContext' has a wrong offset!");

// ScriptStruct GbxGameSystemCore.UserStateSetRuntimeData
// 0x0028 (0x0028 - 0x0000)
struct FUserStateSetRuntimeData final
{
public:
	class UByteProperty*                          Property;                                          // 0x0000(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         ActiveState;                                       // 0x0008(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_9[0x7];                                        // 0x0009(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<class UGbxCondition*>                  EnableConditions;                                  // 0x0010(0x0010)(ZeroConstructor, NativeAccessSpecifierPublic)
	uint8                                         Pad_20[0x8];                                       // 0x0020(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FUserStateSetRuntimeData) == 0x000008, "Wrong alignment on FUserStateSetRuntimeData");
static_assert(sizeof(FUserStateSetRuntimeData) == 0x000028, "Wrong size on FUserStateSetRuntimeData");
static_assert(offsetof(FUserStateSetRuntimeData, Property) == 0x000000, "Member 'FUserStateSetRuntimeData::Property' has a wrong offset!");
static_assert(offsetof(FUserStateSetRuntimeData, ActiveState) == 0x000008, "Member 'FUserStateSetRuntimeData::ActiveState' has a wrong offset!");
static_assert(offsetof(FUserStateSetRuntimeData, EnableConditions) == 0x000010, "Member 'FUserStateSetRuntimeData::EnableConditions' has a wrong offset!");

// ScriptStruct GbxGameSystemCore.UserStatesRuntimeData
// 0x0010 (0x0010 - 0x0000)
struct FUserStatesRuntimeData final
{
public:
	TArray<struct FUserStateSetRuntimeData>       States;                                            // 0x0000(0x0010)(ZeroConstructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(FUserStatesRuntimeData) == 0x000008, "Wrong alignment on FUserStatesRuntimeData");
static_assert(sizeof(FUserStatesRuntimeData) == 0x000010, "Wrong size on FUserStatesRuntimeData");
static_assert(offsetof(FUserStatesRuntimeData, States) == 0x000000, "Member 'FUserStatesRuntimeData::States' has a wrong offset!");

// ScriptStruct GbxGameSystemCore.ActorTagQuery
// 0x0018 (0x0018 - 0x0000)
struct FActorTagQuery final
{
public:
	bool                                          bIncludeComponents;                                // 0x0000(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EActorTagQueryMode                            Mode;                                              // 0x0001(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2[0x6];                                        // 0x0002(0x0006)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<class FName>                           Tags;                                              // 0x0008(0x0010)(Edit, ZeroConstructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(FActorTagQuery) == 0x000008, "Wrong alignment on FActorTagQuery");
static_assert(sizeof(FActorTagQuery) == 0x000018, "Wrong size on FActorTagQuery");
static_assert(offsetof(FActorTagQuery, bIncludeComponents) == 0x000000, "Member 'FActorTagQuery::bIncludeComponents' has a wrong offset!");
static_assert(offsetof(FActorTagQuery, Mode) == 0x000001, "Member 'FActorTagQuery::Mode' has a wrong offset!");
static_assert(offsetof(FActorTagQuery, Tags) == 0x000008, "Member 'FActorTagQuery::Tags' has a wrong offset!");

// ScriptStruct GbxGameSystemCore.ActorTagCompositeQuery
// 0x0010 (0x0010 - 0x0000)
struct FActorTagCompositeQuery final
{
public:
	TArray<struct FActorTagQuery>                 Queries;                                           // 0x0000(0x0010)(Edit, ZeroConstructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(FActorTagCompositeQuery) == 0x000008, "Wrong alignment on FActorTagCompositeQuery");
static_assert(sizeof(FActorTagCompositeQuery) == 0x000010, "Wrong size on FActorTagCompositeQuery");
static_assert(offsetof(FActorTagCompositeQuery, Queries) == 0x000000, "Member 'FActorTagCompositeQuery::Queries' has a wrong offset!");

// ScriptStruct GbxGameSystemCore.CompiledUserSet
// 0x0048 (0x0048 - 0x0000)
struct FCompiledUserSet final
{
public:
	struct FMemberReference                       StateProperty;                                     // 0x0000(0x0038)(NativeAccessSpecifierPublic)
	TArray<class FName>                           EnableConditionVariableNames;                      // 0x0038(0x0010)(ZeroConstructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(FCompiledUserSet) == 0x000008, "Wrong alignment on FCompiledUserSet");
static_assert(sizeof(FCompiledUserSet) == 0x000048, "Wrong size on FCompiledUserSet");
static_assert(offsetof(FCompiledUserSet, StateProperty) == 0x000000, "Member 'FCompiledUserSet::StateProperty' has a wrong offset!");
static_assert(offsetof(FCompiledUserSet, EnableConditionVariableNames) == 0x000038, "Member 'FCompiledUserSet::EnableConditionVariableNames' has a wrong offset!");

// ScriptStruct GbxGameSystemCore.CompiledUserStatesData
// 0x0010 (0x0010 - 0x0000)
struct FCompiledUserStatesData final
{
public:
	TArray<struct FCompiledUserSet>               CompiledSets;                                      // 0x0000(0x0010)(ZeroConstructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(FCompiledUserStatesData) == 0x000008, "Wrong alignment on FCompiledUserStatesData");
static_assert(sizeof(FCompiledUserStatesData) == 0x000010, "Wrong size on FCompiledUserStatesData");
static_assert(offsetof(FCompiledUserStatesData, CompiledSets) == 0x000000, "Member 'FCompiledUserStatesData::CompiledSets' has a wrong offset!");

// ScriptStruct GbxGameSystemCore.CoordinatedLightParameterData
// 0x03D0 (0x03D0 - 0x0000)
struct FCoordinatedLightParameterData final
{
public:
	class FName                                   LightName;                                         // 0x0000(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         bSetColor : 1;                                     // 0x0008(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (Edit, DisableEditOnInstance, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         bSetIntensity : 1;                                 // 0x0008(0x0001)(BitIndex: 0x01, PropSize: 0x0001 (Edit, DisableEditOnInstance, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         Pad_9[0x7];                                        // 0x0009(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	struct FCoordinatedVectorParameter            Color;                                             // 0x0010(0x0268)(Edit, DisableEditOnInstance, NativeAccessSpecifierPublic)
	struct FCoordinatedScalarParameter            Intensity;                                         // 0x0278(0x0158)(Edit, DisableEditOnInstance, NativeAccessSpecifierPublic)
};
static_assert(alignof(FCoordinatedLightParameterData) == 0x000008, "Wrong alignment on FCoordinatedLightParameterData");
static_assert(sizeof(FCoordinatedLightParameterData) == 0x0003D0, "Wrong size on FCoordinatedLightParameterData");
static_assert(offsetof(FCoordinatedLightParameterData, LightName) == 0x000000, "Member 'FCoordinatedLightParameterData::LightName' has a wrong offset!");
static_assert(offsetof(FCoordinatedLightParameterData, Color) == 0x000010, "Member 'FCoordinatedLightParameterData::Color' has a wrong offset!");
static_assert(offsetof(FCoordinatedLightParameterData, Intensity) == 0x000278, "Member 'FCoordinatedLightParameterData::Intensity' has a wrong offset!");

// ScriptStruct GbxGameSystemCore.GbxUIFormattedText
// 0x0068 (0x0068 - 0x0000)
struct FGbxUIFormattedText final
{
public:
	class FText                                   FormatText;                                        // 0x0000(0x0018)(Edit, NativeAccessSpecifierPublic)
	TMap<class FString, TScriptInterface<class IGbxUIFormattableParameter>> FormatParams;                                      // 0x0018(0x0050)(Edit, ZeroConstructor, UObjectWrapper, NativeAccessSpecifierPublic)
};
static_assert(alignof(FGbxUIFormattedText) == 0x000008, "Wrong alignment on FGbxUIFormattedText");
static_assert(sizeof(FGbxUIFormattedText) == 0x000068, "Wrong size on FGbxUIFormattedText");
static_assert(offsetof(FGbxUIFormattedText, FormatText) == 0x000000, "Member 'FGbxUIFormattedText::FormatText' has a wrong offset!");
static_assert(offsetof(FGbxUIFormattedText, FormatParams) == 0x000018, "Member 'FGbxUIFormattedText::FormatParams' has a wrong offset!");

// ScriptStruct GbxGameSystemCore.GbxQueryOriginOptions
// 0x0108 (0x0108 - 0x0000)
struct FGbxQueryOriginOptions final
{
public:
	struct FGbxParam                              UpdatePeriod;                                      // 0x0000(0x0080)(Edit, NoDestructor, ContainsInstancedReference, NativeAccessSpecifierPublic)
	struct FGbxParam                              UpdateCondition;                                   // 0x0080(0x0080)(Edit, NoDestructor, ContainsInstancedReference, NativeAccessSpecifierPublic)
	bool                                          bInvertCondition;                                  // 0x0100(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_101[0x7];                                      // 0x0101(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FGbxQueryOriginOptions) == 0x000008, "Wrong alignment on FGbxQueryOriginOptions");
static_assert(sizeof(FGbxQueryOriginOptions) == 0x000108, "Wrong size on FGbxQueryOriginOptions");
static_assert(offsetof(FGbxQueryOriginOptions, UpdatePeriod) == 0x000000, "Member 'FGbxQueryOriginOptions::UpdatePeriod' has a wrong offset!");
static_assert(offsetof(FGbxQueryOriginOptions, UpdateCondition) == 0x000080, "Member 'FGbxQueryOriginOptions::UpdateCondition' has a wrong offset!");
static_assert(offsetof(FGbxQueryOriginOptions, bInvertCondition) == 0x000100, "Member 'FGbxQueryOriginOptions::bInvertCondition' has a wrong offset!");

// ScriptStruct GbxGameSystemCore.GbxQueryOptions
// 0x0238 (0x0238 - 0x0000)
struct FGbxQueryOptions final
{
public:
	EQueryOwnerLocationUse                        OwnerLocationUse;                                  // 0x0000(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1[0x3];                                        // 0x0001(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         ReplaceLastResultThreshold;                        // 0x0004(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bReplaceLastResult;                                // 0x0008(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bKeepValidValues;                                  // 0x0009(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_A[0x2];                                        // 0x000A(0x0002)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         MinUpdatePeriod;                                   // 0x000C(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         PauseUpdatesWhenNotPingedForTime;                  // 0x0010(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bUpdateAlways;                                     // 0x0014(0x0001)(ZeroConstructor, Deprecated, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	ETimedUpdateBehavior                          WhenToDoFullQueryUpdates;                          // 0x0015(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bCanUpdateWhileActive;                             // 0x0016(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_17[0x1];                                       // 0x0017(0x0001)(Fixing Size After Last Property [ Dumper-7 ])
	struct FGbxParam                              OwnerMoveThreshold;                                // 0x0018(0x0080)(Edit, NoDestructor, ContainsInstancedReference, NativeAccessSpecifierPublic)
	bool                                          bUpdateWhenOwnerMoves;                             // 0x0098(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_99[0x7];                                       // 0x0099(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	struct FGbxParam                              PrimaryContextMoveThreshold;                       // 0x00A0(0x0080)(Edit, NoDestructor, ContainsInstancedReference, NativeAccessSpecifierPublic)
	bool                                          bUpdateWhenPrimaryContextMoves;                    // 0x0120(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_121[0x7];                                      // 0x0121(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	struct FGbxQueryOriginOptions                 Origin;                                            // 0x0128(0x0108)(Edit, NoDestructor, ContainsInstancedReference, NativeAccessSpecifierPublic)
	bool                                          bUpdateOrigin;                                     // 0x0230(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bOnlyUpdateWhenCanPath;                            // 0x0231(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bUpdateWhenHotSpotsListChanges;                    // 0x0232(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_233[0x5];                                      // 0x0233(0x0005)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FGbxQueryOptions) == 0x000008, "Wrong alignment on FGbxQueryOptions");
static_assert(sizeof(FGbxQueryOptions) == 0x000238, "Wrong size on FGbxQueryOptions");
static_assert(offsetof(FGbxQueryOptions, OwnerLocationUse) == 0x000000, "Member 'FGbxQueryOptions::OwnerLocationUse' has a wrong offset!");
static_assert(offsetof(FGbxQueryOptions, ReplaceLastResultThreshold) == 0x000004, "Member 'FGbxQueryOptions::ReplaceLastResultThreshold' has a wrong offset!");
static_assert(offsetof(FGbxQueryOptions, bReplaceLastResult) == 0x000008, "Member 'FGbxQueryOptions::bReplaceLastResult' has a wrong offset!");
static_assert(offsetof(FGbxQueryOptions, bKeepValidValues) == 0x000009, "Member 'FGbxQueryOptions::bKeepValidValues' has a wrong offset!");
static_assert(offsetof(FGbxQueryOptions, MinUpdatePeriod) == 0x00000C, "Member 'FGbxQueryOptions::MinUpdatePeriod' has a wrong offset!");
static_assert(offsetof(FGbxQueryOptions, PauseUpdatesWhenNotPingedForTime) == 0x000010, "Member 'FGbxQueryOptions::PauseUpdatesWhenNotPingedForTime' has a wrong offset!");
static_assert(offsetof(FGbxQueryOptions, bUpdateAlways) == 0x000014, "Member 'FGbxQueryOptions::bUpdateAlways' has a wrong offset!");
static_assert(offsetof(FGbxQueryOptions, WhenToDoFullQueryUpdates) == 0x000015, "Member 'FGbxQueryOptions::WhenToDoFullQueryUpdates' has a wrong offset!");
static_assert(offsetof(FGbxQueryOptions, bCanUpdateWhileActive) == 0x000016, "Member 'FGbxQueryOptions::bCanUpdateWhileActive' has a wrong offset!");
static_assert(offsetof(FGbxQueryOptions, OwnerMoveThreshold) == 0x000018, "Member 'FGbxQueryOptions::OwnerMoveThreshold' has a wrong offset!");
static_assert(offsetof(FGbxQueryOptions, bUpdateWhenOwnerMoves) == 0x000098, "Member 'FGbxQueryOptions::bUpdateWhenOwnerMoves' has a wrong offset!");
static_assert(offsetof(FGbxQueryOptions, PrimaryContextMoveThreshold) == 0x0000A0, "Member 'FGbxQueryOptions::PrimaryContextMoveThreshold' has a wrong offset!");
static_assert(offsetof(FGbxQueryOptions, bUpdateWhenPrimaryContextMoves) == 0x000120, "Member 'FGbxQueryOptions::bUpdateWhenPrimaryContextMoves' has a wrong offset!");
static_assert(offsetof(FGbxQueryOptions, Origin) == 0x000128, "Member 'FGbxQueryOptions::Origin' has a wrong offset!");
static_assert(offsetof(FGbxQueryOptions, bUpdateOrigin) == 0x000230, "Member 'FGbxQueryOptions::bUpdateOrigin' has a wrong offset!");
static_assert(offsetof(FGbxQueryOptions, bOnlyUpdateWhenCanPath) == 0x000231, "Member 'FGbxQueryOptions::bOnlyUpdateWhenCanPath' has a wrong offset!");
static_assert(offsetof(FGbxQueryOptions, bUpdateWhenHotSpotsListChanges) == 0x000232, "Member 'FGbxQueryOptions::bUpdateWhenHotSpotsListChanges' has a wrong offset!");

// ScriptStruct GbxGameSystemCore.EnvQueryParams
// 0x00B8 (0x00B8 - 0x0000)
struct FEnvQueryParams final
{
public:
	class UEnvQuery*                              Query;                                             // 0x0000(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TArray<class UEnvQueryTest*>                  AdditionalTests;                                   // 0x0008(0x0010)(Edit, ExportObject, ZeroConstructor, ContainsInstancedReference, NativeAccessSpecifierPublic)
	TArray<class UEnvQueryTestAsset*>             AdditionalTestAssets;                              // 0x0018(0x0010)(Edit, ZeroConstructor, NativeAccessSpecifierPublic)
	EEnvQueryRunMode                              RunMode;                                           // 0x0028(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bDisableRunModeEditing;                            // 0x0029(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2A[0x6];                                       // 0x002A(0x0006)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<struct FGbxNamedParam>                 Contexts;                                          // 0x0030(0x0010)(Edit, BlueprintVisible, EditFixedSize, ZeroConstructor, NoClear, ContainsInstancedReference, NativeAccessSpecifierPublic)
	bool                                          bDisableContextEditing;                            // 0x0040(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bAllowEmptyContexts;                               // 0x0041(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_42[0x6];                                       // 0x0042(0x0006)(Fixing Size After Last Property [ Dumper-7 ])
	TMap<class UClass*, int32>                    ContextTypeTable;                                  // 0x0048(0x0050)(ZeroConstructor, Transient, NativeAccessSpecifierPublic)
	uint8                                         Pad_98[0x8];                                       // 0x0098(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<struct FGbxNamedParam>                 Params;                                            // 0x00A0(0x0010)(Edit, BlueprintVisible, EditFixedSize, ZeroConstructor, NoClear, ContainsInstancedReference, NativeAccessSpecifierPublic)
	EGbxSignificance                              RequiredSignificanceRating;                        // 0x00B0(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_B1[0x7];                                       // 0x00B1(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FEnvQueryParams) == 0x000008, "Wrong alignment on FEnvQueryParams");
static_assert(sizeof(FEnvQueryParams) == 0x0000B8, "Wrong size on FEnvQueryParams");
static_assert(offsetof(FEnvQueryParams, Query) == 0x000000, "Member 'FEnvQueryParams::Query' has a wrong offset!");
static_assert(offsetof(FEnvQueryParams, AdditionalTests) == 0x000008, "Member 'FEnvQueryParams::AdditionalTests' has a wrong offset!");
static_assert(offsetof(FEnvQueryParams, AdditionalTestAssets) == 0x000018, "Member 'FEnvQueryParams::AdditionalTestAssets' has a wrong offset!");
static_assert(offsetof(FEnvQueryParams, RunMode) == 0x000028, "Member 'FEnvQueryParams::RunMode' has a wrong offset!");
static_assert(offsetof(FEnvQueryParams, bDisableRunModeEditing) == 0x000029, "Member 'FEnvQueryParams::bDisableRunModeEditing' has a wrong offset!");
static_assert(offsetof(FEnvQueryParams, Contexts) == 0x000030, "Member 'FEnvQueryParams::Contexts' has a wrong offset!");
static_assert(offsetof(FEnvQueryParams, bDisableContextEditing) == 0x000040, "Member 'FEnvQueryParams::bDisableContextEditing' has a wrong offset!");
static_assert(offsetof(FEnvQueryParams, bAllowEmptyContexts) == 0x000041, "Member 'FEnvQueryParams::bAllowEmptyContexts' has a wrong offset!");
static_assert(offsetof(FEnvQueryParams, ContextTypeTable) == 0x000048, "Member 'FEnvQueryParams::ContextTypeTable' has a wrong offset!");
static_assert(offsetof(FEnvQueryParams, Params) == 0x0000A0, "Member 'FEnvQueryParams::Params' has a wrong offset!");
static_assert(offsetof(FEnvQueryParams, RequiredSignificanceRating) == 0x0000B0, "Member 'FEnvQueryParams::RequiredSignificanceRating' has a wrong offset!");

// ScriptStruct GbxGameSystemCore.GbxAnimTableRow
// 0x0018 (0x0020 - 0x0008)
struct FGbxAnimTableRow : public FTableRowBase
{
public:
	struct FAnimActionDef                         Animation;                                         // 0x0008(0x0018)(Edit, NoDestructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(FGbxAnimTableRow) == 0x000008, "Wrong alignment on FGbxAnimTableRow");
static_assert(sizeof(FGbxAnimTableRow) == 0x000020, "Wrong size on FGbxAnimTableRow");
static_assert(offsetof(FGbxAnimTableRow, Animation) == 0x000008, "Member 'FGbxAnimTableRow::Animation' has a wrong offset!");

// ScriptStruct GbxGameSystemCore.AttributeDefinedSingleValueRow
// 0x0038 (0x0040 - 0x0008)
struct FAttributeDefinedSingleValueRow final : public FAttributeDefinedValueRow
{
public:
	struct FAttributeInitializationData           Value;                                             // 0x0008(0x0038)(Edit, NoDestructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(FAttributeDefinedSingleValueRow) == 0x000008, "Wrong alignment on FAttributeDefinedSingleValueRow");
static_assert(sizeof(FAttributeDefinedSingleValueRow) == 0x000040, "Wrong size on FAttributeDefinedSingleValueRow");
static_assert(offsetof(FAttributeDefinedSingleValueRow, Value) == 0x000008, "Member 'FAttributeDefinedSingleValueRow::Value' has a wrong offset!");

// ScriptStruct GbxGameSystemCore.EmitterWwiseEventRTPCParam
// 0x0010 (0x0010 - 0x0000)
struct FEmitterWwiseEventRTPCParam final
{
public:
	class UWwiseRtpc*                             RTPC;                                              // 0x0000(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         Value;                                             // 0x0008(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_C[0x4];                                        // 0x000C(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FEmitterWwiseEventRTPCParam) == 0x000008, "Wrong alignment on FEmitterWwiseEventRTPCParam");
static_assert(sizeof(FEmitterWwiseEventRTPCParam) == 0x000010, "Wrong size on FEmitterWwiseEventRTPCParam");
static_assert(offsetof(FEmitterWwiseEventRTPCParam, RTPC) == 0x000000, "Member 'FEmitterWwiseEventRTPCParam::RTPC' has a wrong offset!");
static_assert(offsetof(FEmitterWwiseEventRTPCParam, Value) == 0x000008, "Member 'FEmitterWwiseEventRTPCParam::Value' has a wrong offset!");

// ScriptStruct GbxGameSystemCore.AttributeBaseValueData
// 0x0040 (0x0040 - 0x0000)
struct FAttributeBaseValueData final
{
public:
	class UGbxAttributeData*                      AttributeToSetBaseValueOf;                         // 0x0000(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FAttributeInitializationData           BaseValue;                                         // 0x0008(0x0038)(Edit, NoDestructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(FAttributeBaseValueData) == 0x000008, "Wrong alignment on FAttributeBaseValueData");
static_assert(sizeof(FAttributeBaseValueData) == 0x000040, "Wrong size on FAttributeBaseValueData");
static_assert(offsetof(FAttributeBaseValueData, AttributeToSetBaseValueOf) == 0x000000, "Member 'FAttributeBaseValueData::AttributeToSetBaseValueOf' has a wrong offset!");
static_assert(offsetof(FAttributeBaseValueData, BaseValue) == 0x000008, "Member 'FAttributeBaseValueData::BaseValue' has a wrong offset!");

// ScriptStruct GbxGameSystemCore.PreviewActorManager
// 0x0080 (0x0080 - 0x0000)
struct FPreviewActorManager final
{
public:
	class USceneComponent*                        AttachComponent;                                   // 0x0000(0x0008)(ExportObject, ZeroConstructor, Transient, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class AActor*                                 Actor;                                             // 0x0008(0x0008)(ZeroConstructor, IsPlainOldData, NonTransactional, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	TSubclassOf<class AActor>                     ActorClass;                                        // 0x0010(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class AActor*                                 ActorTemplate;                                     // 0x0018(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_20[0x60];                                      // 0x0020(0x0060)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FPreviewActorManager) == 0x000008, "Wrong alignment on FPreviewActorManager");
static_assert(sizeof(FPreviewActorManager) == 0x000080, "Wrong size on FPreviewActorManager");
static_assert(offsetof(FPreviewActorManager, AttachComponent) == 0x000000, "Member 'FPreviewActorManager::AttachComponent' has a wrong offset!");
static_assert(offsetof(FPreviewActorManager, Actor) == 0x000008, "Member 'FPreviewActorManager::Actor' has a wrong offset!");
static_assert(offsetof(FPreviewActorManager, ActorClass) == 0x000010, "Member 'FPreviewActorManager::ActorClass' has a wrong offset!");
static_assert(offsetof(FPreviewActorManager, ActorTemplate) == 0x000018, "Member 'FPreviewActorManager::ActorTemplate' has a wrong offset!");

// ScriptStruct GbxGameSystemCore.PreviewState
// 0x00D8 (0x00D8 - 0x0000)
struct FPreviewState
{
public:
	uint8                                         Pad_0[0x8];                                        // 0x0000(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	bool                                          bEnabled;                                          // 0x0008(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_9[0x7];                                        // 0x0009(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	struct FPreviewActorManager                   PreviewActorManager;                               // 0x0010(0x0080)(ContainsInstancedReference, Protected, NativeAccessSpecifierProtected)
	TSubclassOf<class AActor>                     PreviewClass;                                      // 0x0090(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	struct FBox                                   PreviewBounds;                                     // 0x0098(0x001C)(IsPlainOldData, NoDestructor, Protected, NativeAccessSpecifierProtected)
	bool                                          bAutoCycle;                                        // 0x00B4(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_B5[0x3];                                       // 0x00B5(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	int32                                         PreviewIdx;                                        // 0x00B8(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_BC[0x4];                                       // 0x00BC(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	TSubclassOf<class UGbxAction>                 PreviewAction;                                     // 0x00C0(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         ElapsedTime;                                       // 0x00C8(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         Duration;                                          // 0x00CC(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bPlayingAction;                                    // 0x00D0(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bQueuedAction;                                     // 0x00D1(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bShowAction;                                       // 0x00D2(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bRepeatAction;                                     // 0x00D3(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_D4[0x4];                                       // 0x00D4(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FPreviewState) == 0x000008, "Wrong alignment on FPreviewState");
static_assert(sizeof(FPreviewState) == 0x0000D8, "Wrong size on FPreviewState");
static_assert(offsetof(FPreviewState, bEnabled) == 0x000008, "Member 'FPreviewState::bEnabled' has a wrong offset!");
static_assert(offsetof(FPreviewState, PreviewActorManager) == 0x000010, "Member 'FPreviewState::PreviewActorManager' has a wrong offset!");
static_assert(offsetof(FPreviewState, PreviewClass) == 0x000090, "Member 'FPreviewState::PreviewClass' has a wrong offset!");
static_assert(offsetof(FPreviewState, PreviewBounds) == 0x000098, "Member 'FPreviewState::PreviewBounds' has a wrong offset!");
static_assert(offsetof(FPreviewState, bAutoCycle) == 0x0000B4, "Member 'FPreviewState::bAutoCycle' has a wrong offset!");
static_assert(offsetof(FPreviewState, PreviewIdx) == 0x0000B8, "Member 'FPreviewState::PreviewIdx' has a wrong offset!");
static_assert(offsetof(FPreviewState, PreviewAction) == 0x0000C0, "Member 'FPreviewState::PreviewAction' has a wrong offset!");
static_assert(offsetof(FPreviewState, ElapsedTime) == 0x0000C8, "Member 'FPreviewState::ElapsedTime' has a wrong offset!");
static_assert(offsetof(FPreviewState, Duration) == 0x0000CC, "Member 'FPreviewState::Duration' has a wrong offset!");
static_assert(offsetof(FPreviewState, bPlayingAction) == 0x0000D0, "Member 'FPreviewState::bPlayingAction' has a wrong offset!");
static_assert(offsetof(FPreviewState, bQueuedAction) == 0x0000D1, "Member 'FPreviewState::bQueuedAction' has a wrong offset!");
static_assert(offsetof(FPreviewState, bShowAction) == 0x0000D2, "Member 'FPreviewState::bShowAction' has a wrong offset!");
static_assert(offsetof(FPreviewState, bRepeatAction) == 0x0000D3, "Member 'FPreviewState::bRepeatAction' has a wrong offset!");

// ScriptStruct GbxGameSystemCore.UserStateEnumValue
// 0x0038 (0x0038 - 0x0000)
struct FUserStateEnumValue final
{
public:
	struct FSimpleMemberReference                 StateProperty;                                     // 0x0000(0x0020)(Edit, NoDestructor, NativeAccessSpecifierPublic)
	class FName                                   PropertyName;                                      // 0x0020(0x0008)(Edit, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UEnum*                                  Enum;                                              // 0x0028(0x0008)(Edit, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         EnumValue;                                         // 0x0030(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_31[0x7];                                       // 0x0031(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FUserStateEnumValue) == 0x000008, "Wrong alignment on FUserStateEnumValue");
static_assert(sizeof(FUserStateEnumValue) == 0x000038, "Wrong size on FUserStateEnumValue");
static_assert(offsetof(FUserStateEnumValue, StateProperty) == 0x000000, "Member 'FUserStateEnumValue::StateProperty' has a wrong offset!");
static_assert(offsetof(FUserStateEnumValue, PropertyName) == 0x000020, "Member 'FUserStateEnumValue::PropertyName' has a wrong offset!");
static_assert(offsetof(FUserStateEnumValue, Enum) == 0x000028, "Member 'FUserStateEnumValue::Enum' has a wrong offset!");
static_assert(offsetof(FUserStateEnumValue, EnumValue) == 0x000030, "Member 'FUserStateEnumValue::EnumValue' has a wrong offset!");

// ScriptStruct GbxGameSystemCore.AimAssistSmoothingProperties
// 0x0020 (0x0020 - 0x0000)
struct FAimAssistSmoothingProperties final
{
public:
	uint8                                         Pad_0[0x8];                                        // 0x0000(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	class AActor*                                 LastTarget;                                        // 0x0008(0x0008)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UTeam*                                  LastTargetTeam;                                    // 0x0010(0x0008)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_18[0x8];                                       // 0x0018(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FAimAssistSmoothingProperties) == 0x000008, "Wrong alignment on FAimAssistSmoothingProperties");
static_assert(sizeof(FAimAssistSmoothingProperties) == 0x000020, "Wrong size on FAimAssistSmoothingProperties");
static_assert(offsetof(FAimAssistSmoothingProperties, LastTarget) == 0x000008, "Member 'FAimAssistSmoothingProperties::LastTarget' has a wrong offset!");
static_assert(offsetof(FAimAssistSmoothingProperties, LastTargetTeam) == 0x000010, "Member 'FAimAssistSmoothingProperties::LastTargetTeam' has a wrong offset!");

// ScriptStruct GbxGameSystemCore.GbxSignificanceEvent
// 0x0008 (0x0008 - 0x0000)
struct alignas(0x08) FGbxSignificanceEvent final
{
public:
	class FName                                   Event;                                             // 0x0000(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FGbxSignificanceEvent) == 0x000008, "Wrong alignment on FGbxSignificanceEvent");
static_assert(sizeof(FGbxSignificanceEvent) == 0x000008, "Wrong size on FGbxSignificanceEvent");
static_assert(offsetof(FGbxSignificanceEvent, Event) == 0x000000, "Member 'FGbxSignificanceEvent::Event' has a wrong offset!");

// ScriptStruct GbxGameSystemCore.ImpactResponseEffect
// 0x0140 (0x0140 - 0x0000)
struct FImpactResponseEffect final
{
public:
	bool                                          bHighPriority;                                     // 0x0000(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bCensorThisEffect;                                 // 0x0001(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2[0x6];                                        // 0x0002(0x0006)(Fixing Size After Last Property [ Dumper-7 ])
	class UImpactData*                            CensoredEffectAlternative;                         // 0x0008(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bOverrideImpactWwiseEvent;                         // 0x0010(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_11[0x7];                                       // 0x0011(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	class UWwiseEvent*                            ImpactWwiseEvent;                                  // 0x0018(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UParticleSystem*                        ParticleTemplate;                                  // 0x0020(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         bAttachParticleToHitActor : 1;                     // 0x0028(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (Edit, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         bAttachParticleToHitBone : 1;                      // 0x0028(0x0001)(BitIndex: 0x01, PropSize: 0x0001 (Edit, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         bHideEffectFromHitActor : 1;                       // 0x0028(0x0001)(BitIndex: 0x02, PropSize: 0x0001 (Edit, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         bNoOverlapDecal : 1;                               // 0x0028(0x0001)(BitIndex: 0x03, PropSize: 0x0001 (Edit, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         Pad_29[0x7];                                       // 0x0029(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	class FName                                   NoOverlapDecalGroupName;                           // 0x0030(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TArray<class UMaterialInterface*>             DecalMaterials;                                    // 0x0038(0x0010)(Edit, ZeroConstructor, NativeAccessSpecifierPublic)
	float                                         DecalWidth;                                        // 0x0048(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         DecalHeight;                                       // 0x004C(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         DecalThickness;                                    // 0x0050(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         DecalMinScale;                                     // 0x0054(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         DecalMaxScale;                                     // 0x0058(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bDecalRandomRotation;                              // 0x005C(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_5D[0x3];                                       // 0x005D(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         DecalRandomRotationLimit;                          // 0x0060(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         DecalLifetime;                                     // 0x0064(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         DecalFadeDuration;                                 // 0x0068(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_6C[0x4];                                       // 0x006C(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	struct FGbxSignificanceEvent                  SignificanceEvent;                                 // 0x0070(0x0008)(Edit, NoDestructor, NativeAccessSpecifierPublic)
	bool                                          bPlayFeedbackOnHitActor;                           // 0x0078(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_79[0x7];                                       // 0x0079(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	class UFeedbackData*                          HitFeedback;                                       // 0x0080(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UFeedbackData*                          AreaFeedback;                                      // 0x0088(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FImpactResponseParams                  EffectParameters;                                  // 0x0090(0x00B0)(NativeAccessSpecifierPublic)
};
static_assert(alignof(FImpactResponseEffect) == 0x000010, "Wrong alignment on FImpactResponseEffect");
static_assert(sizeof(FImpactResponseEffect) == 0x000140, "Wrong size on FImpactResponseEffect");
static_assert(offsetof(FImpactResponseEffect, bHighPriority) == 0x000000, "Member 'FImpactResponseEffect::bHighPriority' has a wrong offset!");
static_assert(offsetof(FImpactResponseEffect, bCensorThisEffect) == 0x000001, "Member 'FImpactResponseEffect::bCensorThisEffect' has a wrong offset!");
static_assert(offsetof(FImpactResponseEffect, CensoredEffectAlternative) == 0x000008, "Member 'FImpactResponseEffect::CensoredEffectAlternative' has a wrong offset!");
static_assert(offsetof(FImpactResponseEffect, bOverrideImpactWwiseEvent) == 0x000010, "Member 'FImpactResponseEffect::bOverrideImpactWwiseEvent' has a wrong offset!");
static_assert(offsetof(FImpactResponseEffect, ImpactWwiseEvent) == 0x000018, "Member 'FImpactResponseEffect::ImpactWwiseEvent' has a wrong offset!");
static_assert(offsetof(FImpactResponseEffect, ParticleTemplate) == 0x000020, "Member 'FImpactResponseEffect::ParticleTemplate' has a wrong offset!");
static_assert(offsetof(FImpactResponseEffect, NoOverlapDecalGroupName) == 0x000030, "Member 'FImpactResponseEffect::NoOverlapDecalGroupName' has a wrong offset!");
static_assert(offsetof(FImpactResponseEffect, DecalMaterials) == 0x000038, "Member 'FImpactResponseEffect::DecalMaterials' has a wrong offset!");
static_assert(offsetof(FImpactResponseEffect, DecalWidth) == 0x000048, "Member 'FImpactResponseEffect::DecalWidth' has a wrong offset!");
static_assert(offsetof(FImpactResponseEffect, DecalHeight) == 0x00004C, "Member 'FImpactResponseEffect::DecalHeight' has a wrong offset!");
static_assert(offsetof(FImpactResponseEffect, DecalThickness) == 0x000050, "Member 'FImpactResponseEffect::DecalThickness' has a wrong offset!");
static_assert(offsetof(FImpactResponseEffect, DecalMinScale) == 0x000054, "Member 'FImpactResponseEffect::DecalMinScale' has a wrong offset!");
static_assert(offsetof(FImpactResponseEffect, DecalMaxScale) == 0x000058, "Member 'FImpactResponseEffect::DecalMaxScale' has a wrong offset!");
static_assert(offsetof(FImpactResponseEffect, bDecalRandomRotation) == 0x00005C, "Member 'FImpactResponseEffect::bDecalRandomRotation' has a wrong offset!");
static_assert(offsetof(FImpactResponseEffect, DecalRandomRotationLimit) == 0x000060, "Member 'FImpactResponseEffect::DecalRandomRotationLimit' has a wrong offset!");
static_assert(offsetof(FImpactResponseEffect, DecalLifetime) == 0x000064, "Member 'FImpactResponseEffect::DecalLifetime' has a wrong offset!");
static_assert(offsetof(FImpactResponseEffect, DecalFadeDuration) == 0x000068, "Member 'FImpactResponseEffect::DecalFadeDuration' has a wrong offset!");
static_assert(offsetof(FImpactResponseEffect, SignificanceEvent) == 0x000070, "Member 'FImpactResponseEffect::SignificanceEvent' has a wrong offset!");
static_assert(offsetof(FImpactResponseEffect, bPlayFeedbackOnHitActor) == 0x000078, "Member 'FImpactResponseEffect::bPlayFeedbackOnHitActor' has a wrong offset!");
static_assert(offsetof(FImpactResponseEffect, HitFeedback) == 0x000080, "Member 'FImpactResponseEffect::HitFeedback' has a wrong offset!");
static_assert(offsetof(FImpactResponseEffect, AreaFeedback) == 0x000088, "Member 'FImpactResponseEffect::AreaFeedback' has a wrong offset!");
static_assert(offsetof(FImpactResponseEffect, EffectParameters) == 0x000090, "Member 'FImpactResponseEffect::EffectParameters' has a wrong offset!");

// ScriptStruct GbxGameSystemCore.ImpactResponseInfo
// 0x0150 (0x0150 - 0x0000)
struct FImpactResponseInfo final
{
public:
	class UPhysicalMaterial*                      PhysicalMaterial;                                  // 0x0000(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_8[0x8];                                        // 0x0008(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	struct FImpactResponseEffect                  Response;                                          // 0x0010(0x0140)(Edit, NativeAccessSpecifierPublic)
};
static_assert(alignof(FImpactResponseInfo) == 0x000010, "Wrong alignment on FImpactResponseInfo");
static_assert(sizeof(FImpactResponseInfo) == 0x000150, "Wrong size on FImpactResponseInfo");
static_assert(offsetof(FImpactResponseInfo, PhysicalMaterial) == 0x000000, "Member 'FImpactResponseInfo::PhysicalMaterial' has a wrong offset!");
static_assert(offsetof(FImpactResponseInfo, Response) == 0x000010, "Member 'FImpactResponseInfo::Response' has a wrong offset!");

// ScriptStruct GbxGameSystemCore.ForceSelection
// 0x0020 (0x0020 - 0x0000)
struct FForceSelection final
{
public:
	EForceSelection                               Selection;                                         // 0x0000(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1[0x7];                                        // 0x0001(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	class FName                                   Preset;                                            // 0x0008(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UGbxAttributeData*                      Attribute;                                         // 0x0010(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         Force;                                             // 0x0018(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1C[0x4];                                       // 0x001C(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FForceSelection) == 0x000008, "Wrong alignment on FForceSelection");
static_assert(sizeof(FForceSelection) == 0x000020, "Wrong size on FForceSelection");
static_assert(offsetof(FForceSelection, Selection) == 0x000000, "Member 'FForceSelection::Selection' has a wrong offset!");
static_assert(offsetof(FForceSelection, Preset) == 0x000008, "Member 'FForceSelection::Preset' has a wrong offset!");
static_assert(offsetof(FForceSelection, Attribute) == 0x000010, "Member 'FForceSelection::Attribute' has a wrong offset!");
static_assert(offsetof(FForceSelection, Force) == 0x000018, "Member 'FForceSelection::Force' has a wrong offset!");

// ScriptStruct GbxGameSystemCore.DamageSourceHealthTypeModifier
// 0x0010 (0x0010 - 0x0000)
struct FDamageSourceHealthTypeModifier final
{
public:
	class UHealthTypeData*                        HealthTypeData;                                    // 0x0000(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UGbxAttributeData*                      InstigatedFriendlyFireHealingModifier;             // 0x0008(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FDamageSourceHealthTypeModifier) == 0x000008, "Wrong alignment on FDamageSourceHealthTypeModifier");
static_assert(sizeof(FDamageSourceHealthTypeModifier) == 0x000010, "Wrong size on FDamageSourceHealthTypeModifier");
static_assert(offsetof(FDamageSourceHealthTypeModifier, HealthTypeData) == 0x000000, "Member 'FDamageSourceHealthTypeModifier::HealthTypeData' has a wrong offset!");
static_assert(offsetof(FDamageSourceHealthTypeModifier, InstigatedFriendlyFireHealingModifier) == 0x000008, "Member 'FDamageSourceHealthTypeModifier::InstigatedFriendlyFireHealingModifier' has a wrong offset!");

// ScriptStruct GbxGameSystemCore.GbxAnimInstanceProxy
// 0x0010 (0x06D0 - 0x06C0)
struct FGbxAnimInstanceProxy : public FAnimInstanceProxy
{
public:
	uint8                                         Pad_6C0[0x10];                                     // 0x06C0(0x0010)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FGbxAnimInstanceProxy) == 0x000010, "Wrong alignment on FGbxAnimInstanceProxy");
static_assert(sizeof(FGbxAnimInstanceProxy) == 0x0006D0, "Wrong size on FGbxAnimInstanceProxy");

// ScriptStruct GbxGameSystemCore.GbxCharacterAnimInstanceProxy
// 0x0000 (0x06D0 - 0x06D0)
struct FGbxCharacterAnimInstanceProxy : public FGbxAnimInstanceProxy
{
};
static_assert(alignof(FGbxCharacterAnimInstanceProxy) == 0x000010, "Wrong alignment on FGbxCharacterAnimInstanceProxy");
static_assert(sizeof(FGbxCharacterAnimInstanceProxy) == 0x0006D0, "Wrong size on FGbxCharacterAnimInstanceProxy");

// ScriptStruct GbxGameSystemCore.MontageLoopRecord
// 0x0020 (0x0020 - 0x0000)
struct alignas(0x08) FMontageLoopRecord final
{
public:
	uint8                                         Pad_0[0x20];                                       // 0x0000(0x0020)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FMontageLoopRecord) == 0x000008, "Wrong alignment on FMontageLoopRecord");
static_assert(sizeof(FMontageLoopRecord) == 0x000020, "Wrong size on FMontageLoopRecord");

// ScriptStruct GbxGameSystemCore.ActionState_CoordinatedEffect
// 0x00F8 (0x01C0 - 0x00C8)
struct FActionState_CoordinatedEffect : public FActionState_Base
{
public:
	uint8                                         Pad_C8[0xF8];                                      // 0x00C8(0x00F8)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FActionState_CoordinatedEffect) == 0x000008, "Wrong alignment on FActionState_CoordinatedEffect");
static_assert(sizeof(FActionState_CoordinatedEffect) == 0x0001C0, "Wrong size on FActionState_CoordinatedEffect");

// ScriptStruct GbxGameSystemCore.UIStatValueRemappingData
// 0x00E8 (0x00E8 - 0x0000)
struct FUIStatValueRemappingData final
{
public:
	uint8                                         bUseContextOverride : 1;                           // 0x0000(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (Edit, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         Pad_1[0x7];                                        // 0x0001(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	struct FAttributeInitializationData           InputValueMin;                                     // 0x0008(0x0038)(Edit, NoDestructor, NativeAccessSpecifierPublic)
	struct FAttributeInitializationData           InputValueMax;                                     // 0x0040(0x0038)(Edit, NoDestructor, NativeAccessSpecifierPublic)
	struct FAttributeInitializationData           OutputValueMin;                                    // 0x0078(0x0038)(Edit, NoDestructor, NativeAccessSpecifierPublic)
	struct FAttributeInitializationData           OutputValueMax;                                    // 0x00B0(0x0038)(Edit, NoDestructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(FUIStatValueRemappingData) == 0x000008, "Wrong alignment on FUIStatValueRemappingData");
static_assert(sizeof(FUIStatValueRemappingData) == 0x0000E8, "Wrong size on FUIStatValueRemappingData");
static_assert(offsetof(FUIStatValueRemappingData, InputValueMin) == 0x000008, "Member 'FUIStatValueRemappingData::InputValueMin' has a wrong offset!");
static_assert(offsetof(FUIStatValueRemappingData, InputValueMax) == 0x000040, "Member 'FUIStatValueRemappingData::InputValueMax' has a wrong offset!");
static_assert(offsetof(FUIStatValueRemappingData, OutputValueMin) == 0x000078, "Member 'FUIStatValueRemappingData::OutputValueMin' has a wrong offset!");
static_assert(offsetof(FUIStatValueRemappingData, OutputValueMax) == 0x0000B0, "Member 'FUIStatValueRemappingData::OutputValueMax' has a wrong offset!");

// ScriptStruct GbxGameSystemCore.ActionState_Gib
// 0x0008 (0x00D0 - 0x00C8)
struct FActionState_Gib : public FActionState_Base
{
public:
	uint8                                         Pad_C8[0x8];                                       // 0x00C8(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FActionState_Gib) == 0x000008, "Wrong alignment on FActionState_Gib");
static_assert(sizeof(FActionState_Gib) == 0x0000D0, "Wrong size on FActionState_Gib");

// ScriptStruct GbxGameSystemCore.ActionState_Loop
// 0x00D0 (0x0538 - 0x0468)
struct FActionState_Loop : public FActionState_SimpleAnim
{
public:
	uint8                                         Pad_468[0xD0];                                     // 0x0468(0x00D0)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FActionState_Loop) == 0x000008, "Wrong alignment on FActionState_Loop");
static_assert(sizeof(FActionState_Loop) == 0x000538, "Wrong size on FActionState_Loop");

// ScriptStruct GbxGameSystemCore.FloatWaveform
// 0x000C (0x000C - 0x0000)
struct FFloatWaveform final
{
public:
	float                                         Frequency;                                         // 0x0000(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         Amplitude;                                         // 0x0004(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         Phase;                                             // 0x0008(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FFloatWaveform) == 0x000004, "Wrong alignment on FFloatWaveform");
static_assert(sizeof(FFloatWaveform) == 0x00000C, "Wrong size on FFloatWaveform");
static_assert(offsetof(FFloatWaveform, Frequency) == 0x000000, "Member 'FFloatWaveform::Frequency' has a wrong offset!");
static_assert(offsetof(FFloatWaveform, Amplitude) == 0x000004, "Member 'FFloatWaveform::Amplitude' has a wrong offset!");
static_assert(offsetof(FFloatWaveform, Phase) == 0x000008, "Member 'FFloatWaveform::Phase' has a wrong offset!");

// ScriptStruct GbxGameSystemCore.VectorWaveform
// 0x0024 (0x0024 - 0x0000)
struct FVectorWaveform final
{
public:
	struct FFloatWaveform                         X;                                                 // 0x0000(0x000C)(Edit, NoDestructor, NativeAccessSpecifierPublic)
	struct FFloatWaveform                         Y;                                                 // 0x000C(0x000C)(Edit, NoDestructor, NativeAccessSpecifierPublic)
	struct FFloatWaveform                         Z;                                                 // 0x0018(0x000C)(Edit, NoDestructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(FVectorWaveform) == 0x000004, "Wrong alignment on FVectorWaveform");
static_assert(sizeof(FVectorWaveform) == 0x000024, "Wrong size on FVectorWaveform");
static_assert(offsetof(FVectorWaveform, X) == 0x000000, "Member 'FVectorWaveform::X' has a wrong offset!");
static_assert(offsetof(FVectorWaveform, Y) == 0x00000C, "Member 'FVectorWaveform::Y' has a wrong offset!");
static_assert(offsetof(FVectorWaveform, Z) == 0x000018, "Member 'FVectorWaveform::Z' has a wrong offset!");

// ScriptStruct GbxGameSystemCore.ExplosionImpactOverride
// 0x0010 (0x0010 - 0x0000)
struct FExplosionImpactOverride final
{
public:
	class UMaterialInterface*                     DecalOverride;                                     // 0x0000(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_8[0x8];                                        // 0x0008(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FExplosionImpactOverride) == 0x000008, "Wrong alignment on FExplosionImpactOverride");
static_assert(sizeof(FExplosionImpactOverride) == 0x000010, "Wrong size on FExplosionImpactOverride");
static_assert(offsetof(FExplosionImpactOverride, DecalOverride) == 0x000000, "Member 'FExplosionImpactOverride::DecalOverride' has a wrong offset!");

// ScriptStruct GbxGameSystemCore.ActionState_PhysicalAnim
// 0x0018 (0x0510 - 0x04F8)
struct FActionState_PhysicalAnim : public FActionState_Anim
{
public:
	uint8                                         Pad_4F8[0x18];                                     // 0x04F8(0x0018)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FActionState_PhysicalAnim) == 0x000008, "Wrong alignment on FActionState_PhysicalAnim");
static_assert(sizeof(FActionState_PhysicalAnim) == 0x000510, "Wrong size on FActionState_PhysicalAnim");

// ScriptStruct GbxGameSystemCore.MantleCheckData
// 0x0208 (0x0208 - 0x0000)
struct alignas(0x04) FMantleCheckData final
{
public:
	uint8                                         Pad_0[0x208];                                      // 0x0000(0x0208)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FMantleCheckData) == 0x000004, "Wrong alignment on FMantleCheckData");
static_assert(sizeof(FMantleCheckData) == 0x000208, "Wrong size on FMantleCheckData");

// ScriptStruct GbxGameSystemCore.ActionState_PhysicalDeath
// 0x0028 (0x0538 - 0x0510)
struct FActionState_PhysicalDeath : public FActionState_PhysicalAnim
{
public:
	uint8                                         Pad_510[0x28];                                     // 0x0510(0x0028)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FActionState_PhysicalDeath) == 0x000008, "Wrong alignment on FActionState_PhysicalDeath");
static_assert(sizeof(FActionState_PhysicalDeath) == 0x000538, "Wrong size on FActionState_PhysicalDeath");

// ScriptStruct GbxGameSystemCore.MontageLoopHelper
// 0x00C0 (0x00C0 - 0x0000)
struct alignas(0x08) FMontageLoopHelper final
{
public:
	uint8                                         Pad_0[0xC0];                                       // 0x0000(0x00C0)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FMontageLoopHelper) == 0x000008, "Wrong alignment on FMontageLoopHelper");
static_assert(sizeof(FMontageLoopHelper) == 0x0000C0, "Wrong size on FMontageLoopHelper");

// ScriptStruct GbxGameSystemCore.HealthTypeBalanceData
// 0x0000 (0x0008 - 0x0008)
struct FHealthTypeBalanceData : public FTableRowBase
{
};
static_assert(alignof(FHealthTypeBalanceData) == 0x000008, "Wrong alignment on FHealthTypeBalanceData");
static_assert(sizeof(FHealthTypeBalanceData) == 0x000008, "Wrong size on FHealthTypeBalanceData");

// ScriptStruct GbxGameSystemCore.WeightedActorPartData
// 0x0040 (0x0040 - 0x0000)
struct FWeightedActorPartData final
{
public:
	class UActorPartData*                         PartData;                                          // 0x0000(0x0008)(Edit, ZeroConstructor, DisableEditOnTemplate, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	struct FAttributeInitializationData           Weight;                                            // 0x0008(0x0038)(Edit, DisableEditOnTemplate, NoDestructor, Protected, NativeAccessSpecifierProtected)
};
static_assert(alignof(FWeightedActorPartData) == 0x000008, "Wrong alignment on FWeightedActorPartData");
static_assert(sizeof(FWeightedActorPartData) == 0x000040, "Wrong size on FWeightedActorPartData");
static_assert(offsetof(FWeightedActorPartData, PartData) == 0x000000, "Member 'FWeightedActorPartData::PartData' has a wrong offset!");
static_assert(offsetof(FWeightedActorPartData, Weight) == 0x000008, "Member 'FWeightedActorPartData::Weight' has a wrong offset!");

// ScriptStruct GbxGameSystemCore.ViewLeadingRotationInfo
// 0x003C (0x003C - 0x0000)
struct FViewLeadingRotationInfo final
{
public:
	struct FRotator                               Effect;                                            // 0x0000(0x000C)(Edit, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
	struct FVector                                EffectFromTranslation;                             // 0x000C(0x000C)(Edit, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         TiltFromRotationYaw;                               // 0x0018(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         AccelRate;                                         // 0x001C(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         DecelRate;                                         // 0x0020(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FRotator                               Max;                                               // 0x0024(0x000C)(Edit, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
	struct FRotator                               Min;                                               // 0x0030(0x000C)(Edit, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(FViewLeadingRotationInfo) == 0x000004, "Wrong alignment on FViewLeadingRotationInfo");
static_assert(sizeof(FViewLeadingRotationInfo) == 0x00003C, "Wrong size on FViewLeadingRotationInfo");
static_assert(offsetof(FViewLeadingRotationInfo, Effect) == 0x000000, "Member 'FViewLeadingRotationInfo::Effect' has a wrong offset!");
static_assert(offsetof(FViewLeadingRotationInfo, EffectFromTranslation) == 0x00000C, "Member 'FViewLeadingRotationInfo::EffectFromTranslation' has a wrong offset!");
static_assert(offsetof(FViewLeadingRotationInfo, TiltFromRotationYaw) == 0x000018, "Member 'FViewLeadingRotationInfo::TiltFromRotationYaw' has a wrong offset!");
static_assert(offsetof(FViewLeadingRotationInfo, AccelRate) == 0x00001C, "Member 'FViewLeadingRotationInfo::AccelRate' has a wrong offset!");
static_assert(offsetof(FViewLeadingRotationInfo, DecelRate) == 0x000020, "Member 'FViewLeadingRotationInfo::DecelRate' has a wrong offset!");
static_assert(offsetof(FViewLeadingRotationInfo, Max) == 0x000024, "Member 'FViewLeadingRotationInfo::Max' has a wrong offset!");
static_assert(offsetof(FViewLeadingRotationInfo, Min) == 0x000030, "Member 'FViewLeadingRotationInfo::Min' has a wrong offset!");

// ScriptStruct GbxGameSystemCore.ViewLeadingTranslationInfo
// 0x002C (0x002C - 0x0000)
struct FViewLeadingTranslationInfo final
{
public:
	struct FVector                                Effect;                                            // 0x0000(0x000C)(Edit, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         AccelRate;                                         // 0x000C(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         DecelRate;                                         // 0x0010(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                Max;                                               // 0x0014(0x000C)(Edit, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                Min;                                               // 0x0020(0x000C)(Edit, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FViewLeadingTranslationInfo) == 0x000004, "Wrong alignment on FViewLeadingTranslationInfo");
static_assert(sizeof(FViewLeadingTranslationInfo) == 0x00002C, "Wrong size on FViewLeadingTranslationInfo");
static_assert(offsetof(FViewLeadingTranslationInfo, Effect) == 0x000000, "Member 'FViewLeadingTranslationInfo::Effect' has a wrong offset!");
static_assert(offsetof(FViewLeadingTranslationInfo, AccelRate) == 0x00000C, "Member 'FViewLeadingTranslationInfo::AccelRate' has a wrong offset!");
static_assert(offsetof(FViewLeadingTranslationInfo, DecelRate) == 0x000010, "Member 'FViewLeadingTranslationInfo::DecelRate' has a wrong offset!");
static_assert(offsetof(FViewLeadingTranslationInfo, Max) == 0x000014, "Member 'FViewLeadingTranslationInfo::Max' has a wrong offset!");
static_assert(offsetof(FViewLeadingTranslationInfo, Min) == 0x000020, "Member 'FViewLeadingTranslationInfo::Min' has a wrong offset!");

// ScriptStruct GbxGameSystemCore.DirectionActionData
// 0x0010 (0x0010 - 0x0000)
struct FDirectionActionData final
{
public:
	struct FNumericRange                          AngleRange;                                        // 0x0000(0x0008)(Edit, NoDestructor, NativeAccessSpecifierPublic)
	TSubclassOf<class UGbxAction>                 ActionClass;                                       // 0x0008(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FDirectionActionData) == 0x000008, "Wrong alignment on FDirectionActionData");
static_assert(sizeof(FDirectionActionData) == 0x000010, "Wrong size on FDirectionActionData");
static_assert(offsetof(FDirectionActionData, AngleRange) == 0x000000, "Member 'FDirectionActionData::AngleRange' has a wrong offset!");
static_assert(offsetof(FDirectionActionData, ActionClass) == 0x000008, "Member 'FDirectionActionData::ActionClass' has a wrong offset!");

// ScriptStruct GbxGameSystemCore.ChallengeInstanceData
// 0x0080 (0x0080 - 0x0000)
struct FChallengeInstanceData final
{
public:
	class AActor*                                 CCOwner;                                           // 0x0000(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FChallengePersistentState              ChallengeState;                                    // 0x0008(0x0060)(BlueprintVisible, BlueprintReadOnly, NativeAccessSpecifierPublic)
	class UChallenge*                             ChallengeInstance;                                 // 0x0068(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_70[0x10];                                      // 0x0070(0x0010)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FChallengeInstanceData) == 0x000008, "Wrong alignment on FChallengeInstanceData");
static_assert(sizeof(FChallengeInstanceData) == 0x000080, "Wrong size on FChallengeInstanceData");
static_assert(offsetof(FChallengeInstanceData, CCOwner) == 0x000000, "Member 'FChallengeInstanceData::CCOwner' has a wrong offset!");
static_assert(offsetof(FChallengeInstanceData, ChallengeState) == 0x000008, "Member 'FChallengeInstanceData::ChallengeState' has a wrong offset!");
static_assert(offsetof(FChallengeInstanceData, ChallengeInstance) == 0x000068, "Member 'FChallengeInstanceData::ChallengeInstance' has a wrong offset!");

// ScriptStruct GbxGameSystemCore.MantleGlobalData
// 0x0090 (0x0090 - 0x0000)
struct FMantleGlobalData final
{
public:
	int32                                         DistanceToLookAheadForWalls;                       // 0x0000(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         FootCollisionHeight;                               // 0x0004(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         HeadCollisionHeight;                               // 0x0008(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         MinWallSlope;                                      // 0x000C(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         MaxAngleToKeepMantleCache;                         // 0x0010(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         TimeToHoldValidClimbLocationSeconds;               // 0x0014(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         MaxDegreeAngleFromForward;                         // 0x0018(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         LookAngleRange;                                    // 0x001C(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         bShowPromptWhenAvailable : 1;                      // 0x0020(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (Edit, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         Pad_21[0x3];                                       // 0x0021(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         DelayBeforeShowingPrompt;                          // 0x0024(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TArray<TSubclassOf<class AActor>>             ValidActorClasses;                                 // 0x0028(0x0010)(Edit, ZeroConstructor, UObjectWrapper, NativeAccessSpecifierPublic)
	TArray<TSubclassOf<class AActor>>             InvalidActorClasses;                               // 0x0038(0x0010)(Edit, ZeroConstructor, UObjectWrapper, NativeAccessSpecifierPublic)
	TArray<TSubclassOf<class UPrimitiveComponent>> ValidPrimitiveComponentClasses;                    // 0x0048(0x0010)(Edit, ZeroConstructor, UObjectWrapper, NativeAccessSpecifierPublic)
	TArray<EMovementMode>                         ValidMovementModes;                                // 0x0058(0x0010)(Edit, ZeroConstructor, NativeAccessSpecifierPublic)
	float                                         MaxAscendingSpeedZ;                                // 0x0068(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         MaxDescendingSpeedZ;                               // 0x006C(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         MinLedgeHeightToStillAllowMantle;                  // 0x0070(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         MaxPossibleLedgeHeight;                            // 0x0074(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         MaxPossibleLedgeDistance;                          // 0x0078(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         ClientValidationTolerance;                         // 0x007C(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         MinPassiveMantleHeight_Default;                    // 0x0080(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         MinPassiveMantleHeight_ForwardInput;               // 0x0084(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bIgnoreTeamCollision;                              // 0x0088(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_89[0x7];                                       // 0x0089(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FMantleGlobalData) == 0x000008, "Wrong alignment on FMantleGlobalData");
static_assert(sizeof(FMantleGlobalData) == 0x000090, "Wrong size on FMantleGlobalData");
static_assert(offsetof(FMantleGlobalData, DistanceToLookAheadForWalls) == 0x000000, "Member 'FMantleGlobalData::DistanceToLookAheadForWalls' has a wrong offset!");
static_assert(offsetof(FMantleGlobalData, FootCollisionHeight) == 0x000004, "Member 'FMantleGlobalData::FootCollisionHeight' has a wrong offset!");
static_assert(offsetof(FMantleGlobalData, HeadCollisionHeight) == 0x000008, "Member 'FMantleGlobalData::HeadCollisionHeight' has a wrong offset!");
static_assert(offsetof(FMantleGlobalData, MinWallSlope) == 0x00000C, "Member 'FMantleGlobalData::MinWallSlope' has a wrong offset!");
static_assert(offsetof(FMantleGlobalData, MaxAngleToKeepMantleCache) == 0x000010, "Member 'FMantleGlobalData::MaxAngleToKeepMantleCache' has a wrong offset!");
static_assert(offsetof(FMantleGlobalData, TimeToHoldValidClimbLocationSeconds) == 0x000014, "Member 'FMantleGlobalData::TimeToHoldValidClimbLocationSeconds' has a wrong offset!");
static_assert(offsetof(FMantleGlobalData, MaxDegreeAngleFromForward) == 0x000018, "Member 'FMantleGlobalData::MaxDegreeAngleFromForward' has a wrong offset!");
static_assert(offsetof(FMantleGlobalData, LookAngleRange) == 0x00001C, "Member 'FMantleGlobalData::LookAngleRange' has a wrong offset!");
static_assert(offsetof(FMantleGlobalData, DelayBeforeShowingPrompt) == 0x000024, "Member 'FMantleGlobalData::DelayBeforeShowingPrompt' has a wrong offset!");
static_assert(offsetof(FMantleGlobalData, ValidActorClasses) == 0x000028, "Member 'FMantleGlobalData::ValidActorClasses' has a wrong offset!");
static_assert(offsetof(FMantleGlobalData, InvalidActorClasses) == 0x000038, "Member 'FMantleGlobalData::InvalidActorClasses' has a wrong offset!");
static_assert(offsetof(FMantleGlobalData, ValidPrimitiveComponentClasses) == 0x000048, "Member 'FMantleGlobalData::ValidPrimitiveComponentClasses' has a wrong offset!");
static_assert(offsetof(FMantleGlobalData, ValidMovementModes) == 0x000058, "Member 'FMantleGlobalData::ValidMovementModes' has a wrong offset!");
static_assert(offsetof(FMantleGlobalData, MaxAscendingSpeedZ) == 0x000068, "Member 'FMantleGlobalData::MaxAscendingSpeedZ' has a wrong offset!");
static_assert(offsetof(FMantleGlobalData, MaxDescendingSpeedZ) == 0x00006C, "Member 'FMantleGlobalData::MaxDescendingSpeedZ' has a wrong offset!");
static_assert(offsetof(FMantleGlobalData, MinLedgeHeightToStillAllowMantle) == 0x000070, "Member 'FMantleGlobalData::MinLedgeHeightToStillAllowMantle' has a wrong offset!");
static_assert(offsetof(FMantleGlobalData, MaxPossibleLedgeHeight) == 0x000074, "Member 'FMantleGlobalData::MaxPossibleLedgeHeight' has a wrong offset!");
static_assert(offsetof(FMantleGlobalData, MaxPossibleLedgeDistance) == 0x000078, "Member 'FMantleGlobalData::MaxPossibleLedgeDistance' has a wrong offset!");
static_assert(offsetof(FMantleGlobalData, ClientValidationTolerance) == 0x00007C, "Member 'FMantleGlobalData::ClientValidationTolerance' has a wrong offset!");
static_assert(offsetof(FMantleGlobalData, MinPassiveMantleHeight_Default) == 0x000080, "Member 'FMantleGlobalData::MinPassiveMantleHeight_Default' has a wrong offset!");
static_assert(offsetof(FMantleGlobalData, MinPassiveMantleHeight_ForwardInput) == 0x000084, "Member 'FMantleGlobalData::MinPassiveMantleHeight_ForwardInput' has a wrong offset!");
static_assert(offsetof(FMantleGlobalData, bIgnoreTeamCollision) == 0x000088, "Member 'FMantleGlobalData::bIgnoreTeamCollision' has a wrong offset!");

// ScriptStruct GbxGameSystemCore.DataActionPair_SmartObject
// 0x0010 (0x0018 - 0x0008)
struct FDataActionPair_SmartObject final : public FDataActionPair_Base
{
public:
	struct FGameplayTag                           ActionKey;                                         // 0x0008(0x0008)(Edit, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UGbxBoneSet*                            BoneSetFilter;                                     // 0x0010(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FDataActionPair_SmartObject) == 0x000008, "Wrong alignment on FDataActionPair_SmartObject");
static_assert(sizeof(FDataActionPair_SmartObject) == 0x000018, "Wrong size on FDataActionPair_SmartObject");
static_assert(offsetof(FDataActionPair_SmartObject, ActionKey) == 0x000008, "Member 'FDataActionPair_SmartObject::ActionKey' has a wrong offset!");
static_assert(offsetof(FDataActionPair_SmartObject, BoneSetFilter) == 0x000010, "Member 'FDataActionPair_SmartObject::BoneSetFilter' has a wrong offset!");

// ScriptStruct GbxGameSystemCore.DataActionPair_SpawnMesh
// 0x0008 (0x0010 - 0x0008)
struct FDataActionPair_SpawnMesh final : public FDataActionPair_Base
{
public:
	struct FGameplayTag                           ActionKey;                                         // 0x0008(0x0008)(Edit, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FDataActionPair_SpawnMesh) == 0x000008, "Wrong alignment on FDataActionPair_SpawnMesh");
static_assert(sizeof(FDataActionPair_SpawnMesh) == 0x000010, "Wrong size on FDataActionPair_SpawnMesh");
static_assert(offsetof(FDataActionPair_SpawnMesh, ActionKey) == 0x000008, "Member 'FDataActionPair_SpawnMesh::ActionKey' has a wrong offset!");

// ScriptStruct GbxGameSystemCore.ExplosionSizeProperties
// 0x0050 (0x0050 - 0x0000)
struct FExplosionSizeProperties final
{
public:
	float                                         ExplosionSize;                                     // 0x0000(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_4[0x4];                                        // 0x0004(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class UFeedbackData*                          ExplosionFeedback;                                 // 0x0008(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UParticleSystem*                        ExplosionParticleSystem;                           // 0x0010(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UParticleSystem*                        CensoredExplosionParticleSystem;                   // 0x0018(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UWwiseEvent*                            ExplosionAudioEvent;                               // 0x0020(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UImpactData*                            ExplosionImpact;                                   // 0x0028(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         bCensorThisExplosion : 1;                          // 0x0030(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (Edit, DisableEditOnInstance, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         bUseExplosionRadialBlur : 1;                       // 0x0030(0x0001)(BitIndex: 0x01, PropSize: 0x0001 (Edit, DisableEditOnInstance, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         bOverrideTinnitusDuration : 1;                     // 0x0030(0x0001)(BitIndex: 0x02, PropSize: 0x0001 (Edit, DisableEditOnInstance, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         Pad_31[0x3];                                       // 0x0031(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	struct FRadialBlurSelection                   ExplosionRadialBlur;                               // 0x0034(0x000C)(Edit, DisableEditOnInstance, NoDestructor, NativeAccessSpecifierPublic)
	EExplosionTinnitusDuration                    TinnitusDuration;                                  // 0x0040(0x0001)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_41[0x7];                                       // 0x0041(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	struct FGbxSignificanceEvent                  SignificanceEvent;                                 // 0x0048(0x0008)(Edit, DisableEditOnInstance, NoDestructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(FExplosionSizeProperties) == 0x000008, "Wrong alignment on FExplosionSizeProperties");
static_assert(sizeof(FExplosionSizeProperties) == 0x000050, "Wrong size on FExplosionSizeProperties");
static_assert(offsetof(FExplosionSizeProperties, ExplosionSize) == 0x000000, "Member 'FExplosionSizeProperties::ExplosionSize' has a wrong offset!");
static_assert(offsetof(FExplosionSizeProperties, ExplosionFeedback) == 0x000008, "Member 'FExplosionSizeProperties::ExplosionFeedback' has a wrong offset!");
static_assert(offsetof(FExplosionSizeProperties, ExplosionParticleSystem) == 0x000010, "Member 'FExplosionSizeProperties::ExplosionParticleSystem' has a wrong offset!");
static_assert(offsetof(FExplosionSizeProperties, CensoredExplosionParticleSystem) == 0x000018, "Member 'FExplosionSizeProperties::CensoredExplosionParticleSystem' has a wrong offset!");
static_assert(offsetof(FExplosionSizeProperties, ExplosionAudioEvent) == 0x000020, "Member 'FExplosionSizeProperties::ExplosionAudioEvent' has a wrong offset!");
static_assert(offsetof(FExplosionSizeProperties, ExplosionImpact) == 0x000028, "Member 'FExplosionSizeProperties::ExplosionImpact' has a wrong offset!");
static_assert(offsetof(FExplosionSizeProperties, ExplosionRadialBlur) == 0x000034, "Member 'FExplosionSizeProperties::ExplosionRadialBlur' has a wrong offset!");
static_assert(offsetof(FExplosionSizeProperties, TinnitusDuration) == 0x000040, "Member 'FExplosionSizeProperties::TinnitusDuration' has a wrong offset!");
static_assert(offsetof(FExplosionSizeProperties, SignificanceEvent) == 0x000048, "Member 'FExplosionSizeProperties::SignificanceEvent' has a wrong offset!");

// ScriptStruct GbxGameSystemCore.DataActionPair_Spawn
// 0x0008 (0x0010 - 0x0008)
struct FDataActionPair_Spawn final : public FDataActionPair_Base
{
public:
	struct FGameplayTag                           ActionKey;                                         // 0x0008(0x0008)(Edit, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FDataActionPair_Spawn) == 0x000008, "Wrong alignment on FDataActionPair_Spawn");
static_assert(sizeof(FDataActionPair_Spawn) == 0x000010, "Wrong size on FDataActionPair_Spawn");
static_assert(offsetof(FDataActionPair_Spawn, ActionKey) == 0x000008, "Member 'FDataActionPair_Spawn::ActionKey' has a wrong offset!");

// ScriptStruct GbxGameSystemCore.ActorPartListData
// 0x0028 (0x0028 - 0x0000)
struct FActorPartListData
{
public:
	class UEnum*                                  PartTypeEnum;                                      // 0x0000(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         PartType;                                          // 0x0008(0x0001)(Edit, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bCanSelectMultipleParts;                           // 0x0009(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bUseWeightWithMultiplePartSelection;               // 0x000A(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_B[0x1];                                        // 0x000B(0x0001)(Fixing Size After Last Property [ Dumper-7 ])
	struct FInt32Interval                         MultiplePartSelectionRange;                        // 0x000C(0x0008)(Edit, DisableEditOnTemplate, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bEnabled;                                          // 0x0014(0x0001)(Edit, ZeroConstructor, DisableEditOnTemplate, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_15[0x3];                                       // 0x0015(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<struct FWeightedActorPartData>         Parts;                                             // 0x0018(0x0010)(Edit, ZeroConstructor, DisableEditOnTemplate, Protected, NativeAccessSpecifierProtected)
};
static_assert(alignof(FActorPartListData) == 0x000008, "Wrong alignment on FActorPartListData");
static_assert(sizeof(FActorPartListData) == 0x000028, "Wrong size on FActorPartListData");
static_assert(offsetof(FActorPartListData, PartTypeEnum) == 0x000000, "Member 'FActorPartListData::PartTypeEnum' has a wrong offset!");
static_assert(offsetof(FActorPartListData, PartType) == 0x000008, "Member 'FActorPartListData::PartType' has a wrong offset!");
static_assert(offsetof(FActorPartListData, bCanSelectMultipleParts) == 0x000009, "Member 'FActorPartListData::bCanSelectMultipleParts' has a wrong offset!");
static_assert(offsetof(FActorPartListData, bUseWeightWithMultiplePartSelection) == 0x00000A, "Member 'FActorPartListData::bUseWeightWithMultiplePartSelection' has a wrong offset!");
static_assert(offsetof(FActorPartListData, MultiplePartSelectionRange) == 0x00000C, "Member 'FActorPartListData::MultiplePartSelectionRange' has a wrong offset!");
static_assert(offsetof(FActorPartListData, bEnabled) == 0x000014, "Member 'FActorPartListData::bEnabled' has a wrong offset!");
static_assert(offsetof(FActorPartListData, Parts) == 0x000018, "Member 'FActorPartListData::Parts' has a wrong offset!");

// ScriptStruct GbxGameSystemCore.MantleActionData
// 0x0110 (0x0110 - 0x0000)
struct FMantleActionData final
{
public:
	EMantleType                                   Type;                                              // 0x0000(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1[0x7];                                        // 0x0001(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	TSubclassOf<class UGbxAction>                 Animation;                                         // 0x0008(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         HeightMinimum;                                     // 0x0010(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         AlignTime;                                         // 0x0014(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FRuntimeFloatCurve                     HorizontalCurve;                                   // 0x0018(0x0078)(Edit, NativeAccessSpecifierPublic)
	struct FRuntimeFloatCurve                     VerticalCurve;                                     // 0x0090(0x0078)(Edit, NativeAccessSpecifierPublic)
	float                                         PercentThroughAnimationToFinishMantle;             // 0x0108(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         bAlignRotation : 1;                                // 0x010C(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (Edit, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         bMustLookAt : 1;                                   // 0x010C(0x0001)(BitIndex: 0x01, PropSize: 0x0001 (Edit, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         Pad_10D[0x3];                                      // 0x010D(0x0003)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FMantleActionData) == 0x000008, "Wrong alignment on FMantleActionData");
static_assert(sizeof(FMantleActionData) == 0x000110, "Wrong size on FMantleActionData");
static_assert(offsetof(FMantleActionData, Type) == 0x000000, "Member 'FMantleActionData::Type' has a wrong offset!");
static_assert(offsetof(FMantleActionData, Animation) == 0x000008, "Member 'FMantleActionData::Animation' has a wrong offset!");
static_assert(offsetof(FMantleActionData, HeightMinimum) == 0x000010, "Member 'FMantleActionData::HeightMinimum' has a wrong offset!");
static_assert(offsetof(FMantleActionData, AlignTime) == 0x000014, "Member 'FMantleActionData::AlignTime' has a wrong offset!");
static_assert(offsetof(FMantleActionData, HorizontalCurve) == 0x000018, "Member 'FMantleActionData::HorizontalCurve' has a wrong offset!");
static_assert(offsetof(FMantleActionData, VerticalCurve) == 0x000090, "Member 'FMantleActionData::VerticalCurve' has a wrong offset!");
static_assert(offsetof(FMantleActionData, PercentThroughAnimationToFinishMantle) == 0x000108, "Member 'FMantleActionData::PercentThroughAnimationToFinishMantle' has a wrong offset!");

// ScriptStruct GbxGameSystemCore.ConditionalMultiSelectionGestaltPartNameData
// 0x0020 (0x0020 - 0x0000)
struct FConditionalMultiSelectionGestaltPartNameData final
{
public:
	TArray<class UActorPartData*>                 OtherParts;                                        // 0x0000(0x0010)(Edit, ZeroConstructor, DisableEditOnTemplate, Protected, NativeAccessSpecifierProtected)
	TArray<class FName>                           GestaltMeshPartNames;                              // 0x0010(0x0010)(Edit, ZeroConstructor, DisableEditOnTemplate, Protected, NativeAccessSpecifierProtected)
};
static_assert(alignof(FConditionalMultiSelectionGestaltPartNameData) == 0x000008, "Wrong alignment on FConditionalMultiSelectionGestaltPartNameData");
static_assert(sizeof(FConditionalMultiSelectionGestaltPartNameData) == 0x000020, "Wrong size on FConditionalMultiSelectionGestaltPartNameData");
static_assert(offsetof(FConditionalMultiSelectionGestaltPartNameData, OtherParts) == 0x000000, "Member 'FConditionalMultiSelectionGestaltPartNameData::OtherParts' has a wrong offset!");
static_assert(offsetof(FConditionalMultiSelectionGestaltPartNameData, GestaltMeshPartNames) == 0x000010, "Member 'FConditionalMultiSelectionGestaltPartNameData::GestaltMeshPartNames' has a wrong offset!");

// ScriptStruct GbxGameSystemCore.MultiSelectionGestaltPartNameData
// 0x0028 (0x0028 - 0x0000)
struct FMultiSelectionGestaltPartNameData final
{
public:
	int32                                         IndexOfType;                                       // 0x0000(0x0004)(Edit, ZeroConstructor, DisableEditOnTemplate, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_4[0x4];                                        // 0x0004(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<class FName>                           GestaltMeshPartNames;                              // 0x0008(0x0010)(Edit, ZeroConstructor, DisableEditOnTemplate, Protected, NativeAccessSpecifierProtected)
	TArray<struct FConditionalMultiSelectionGestaltPartNameData> ConditionalGestaltMeshPartNames;                   // 0x0018(0x0010)(Edit, ZeroConstructor, DisableEditOnTemplate, Protected, NativeAccessSpecifierProtected)
};
static_assert(alignof(FMultiSelectionGestaltPartNameData) == 0x000008, "Wrong alignment on FMultiSelectionGestaltPartNameData");
static_assert(sizeof(FMultiSelectionGestaltPartNameData) == 0x000028, "Wrong size on FMultiSelectionGestaltPartNameData");
static_assert(offsetof(FMultiSelectionGestaltPartNameData, IndexOfType) == 0x000000, "Member 'FMultiSelectionGestaltPartNameData::IndexOfType' has a wrong offset!");
static_assert(offsetof(FMultiSelectionGestaltPartNameData, GestaltMeshPartNames) == 0x000008, "Member 'FMultiSelectionGestaltPartNameData::GestaltMeshPartNames' has a wrong offset!");
static_assert(offsetof(FMultiSelectionGestaltPartNameData, ConditionalGestaltMeshPartNames) == 0x000018, "Member 'FMultiSelectionGestaltPartNameData::ConditionalGestaltMeshPartNames' has a wrong offset!");

// ScriptStruct GbxGameSystemCore.RuntimeActorPartListData
// 0x0028 (0x0028 - 0x0000)
struct FRuntimeActorPartListData final
{
public:
	uint8                                         bIsInitialized : 1;                                // 0x0000(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (Edit, EditConst, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate))
	uint8                                         Pad_1[0x7];                                        // 0x0001(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<struct FRuntimeActorPartListPartTypeData> PartTypeTOC;                                       // 0x0008(0x0010)(Edit, ZeroConstructor, EditConst, NativeAccessSpecifierPrivate)
	TArray<struct FWeightedActorPartData>         AllParts;                                          // 0x0018(0x0010)(Edit, ZeroConstructor, EditConst, NativeAccessSpecifierPrivate)
};
static_assert(alignof(FRuntimeActorPartListData) == 0x000008, "Wrong alignment on FRuntimeActorPartListData");
static_assert(sizeof(FRuntimeActorPartListData) == 0x000028, "Wrong size on FRuntimeActorPartListData");
static_assert(offsetof(FRuntimeActorPartListData, PartTypeTOC) == 0x000008, "Member 'FRuntimeActorPartListData::PartTypeTOC' has a wrong offset!");
static_assert(offsetof(FRuntimeActorPartListData, AllParts) == 0x000018, "Member 'FRuntimeActorPartListData::AllParts' has a wrong offset!");

// ScriptStruct GbxGameSystemCore.AttributeEffect
// 0x0050 (0x0050 - 0x0000)
struct FAttributeEffect final
{
public:
	class UGbxAttributeData*                      AttributeData;                                     // 0x0000(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EGbxAttributeModifierType                     ModifierType;                                      // 0x0008(0x0001)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_9[0x7];                                        // 0x0009(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	struct FAttributeInitializationData           BaseModifierValue;                                 // 0x0010(0x0038)(Edit, DisableEditOnInstance, NoDestructor, NativeAccessSpecifierPublic)
	class UAttributeEffectMutatorData*            Mutator;                                           // 0x0048(0x0008)(Edit, ExportObject, ZeroConstructor, DisableEditOnInstance, InstancedReference, IsPlainOldData, NoDestructor, PersistentInstance, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FAttributeEffect) == 0x000008, "Wrong alignment on FAttributeEffect");
static_assert(sizeof(FAttributeEffect) == 0x000050, "Wrong size on FAttributeEffect");
static_assert(offsetof(FAttributeEffect, AttributeData) == 0x000000, "Member 'FAttributeEffect::AttributeData' has a wrong offset!");
static_assert(offsetof(FAttributeEffect, ModifierType) == 0x000008, "Member 'FAttributeEffect::ModifierType' has a wrong offset!");
static_assert(offsetof(FAttributeEffect, BaseModifierValue) == 0x000010, "Member 'FAttributeEffect::BaseModifierValue' has a wrong offset!");
static_assert(offsetof(FAttributeEffect, Mutator) == 0x000048, "Member 'FAttributeEffect::Mutator' has a wrong offset!");

// ScriptStruct GbxGameSystemCore.DamageDataEventDetails
// 0x0048 (0x0048 - 0x0000)
struct FDamageDataEventDetails final
{
public:
	float                                         DamageDealt;                                       // 0x0000(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_4[0x4];                                        // 0x0004(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<struct FHealthTypeDamageSummary>       DamagePerHealthType;                               // 0x0008(0x0010)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, NativeAccessSpecifierPublic)
	class UGbxDamageType*                         DamageType;                                        // 0x0018(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UDamageSource*                          DamageSource;                                      // 0x0020(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                HitDirection;                                      // 0x0028(0x000C)(BlueprintVisible, BlueprintReadOnly, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                HitLocation;                                       // 0x0034(0x000C)(BlueprintVisible, BlueprintReadOnly, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bWasCrit;                                          // 0x0040(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_41[0x7];                                       // 0x0041(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FDamageDataEventDetails) == 0x000008, "Wrong alignment on FDamageDataEventDetails");
static_assert(sizeof(FDamageDataEventDetails) == 0x000048, "Wrong size on FDamageDataEventDetails");
static_assert(offsetof(FDamageDataEventDetails, DamageDealt) == 0x000000, "Member 'FDamageDataEventDetails::DamageDealt' has a wrong offset!");
static_assert(offsetof(FDamageDataEventDetails, DamagePerHealthType) == 0x000008, "Member 'FDamageDataEventDetails::DamagePerHealthType' has a wrong offset!");
static_assert(offsetof(FDamageDataEventDetails, DamageType) == 0x000018, "Member 'FDamageDataEventDetails::DamageType' has a wrong offset!");
static_assert(offsetof(FDamageDataEventDetails, DamageSource) == 0x000020, "Member 'FDamageDataEventDetails::DamageSource' has a wrong offset!");
static_assert(offsetof(FDamageDataEventDetails, HitDirection) == 0x000028, "Member 'FDamageDataEventDetails::HitDirection' has a wrong offset!");
static_assert(offsetof(FDamageDataEventDetails, HitLocation) == 0x000034, "Member 'FDamageDataEventDetails::HitLocation' has a wrong offset!");
static_assert(offsetof(FDamageDataEventDetails, bWasCrit) == 0x000040, "Member 'FDamageDataEventDetails::bWasCrit' has a wrong offset!");

// ScriptStruct GbxGameSystemCore.AIChargeState
// 0x0018 (0x0018 - 0x0000)
struct alignas(0x08) FAIChargeState final
{
public:
	uint8                                         Pad_0[0x18];                                       // 0x0000(0x0018)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FAIChargeState) == 0x000008, "Wrong alignment on FAIChargeState");
static_assert(sizeof(FAIChargeState) == 0x000018, "Wrong size on FAIChargeState");

// ScriptStruct GbxGameSystemCore.AIDodgeInstance
// 0x0020 (0x0020 - 0x0000)
struct FAIDodgeInstance final
{
public:
	TSubclassOf<class UGbxAction>                 Action;                                            // 0x0000(0x0008)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class AActor*                                 SourceActor;                                       // 0x0008(0x0008)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_10[0x10];                                      // 0x0010(0x0010)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FAIDodgeInstance) == 0x000008, "Wrong alignment on FAIDodgeInstance");
static_assert(sizeof(FAIDodgeInstance) == 0x000020, "Wrong size on FAIDodgeInstance");
static_assert(offsetof(FAIDodgeInstance, Action) == 0x000000, "Member 'FAIDodgeInstance::Action' has a wrong offset!");
static_assert(offsetof(FAIDodgeInstance, SourceActor) == 0x000008, "Member 'FAIDodgeInstance::SourceActor' has a wrong offset!");

// ScriptStruct GbxGameSystemCore.TargetQueryTestDebugDesc
// 0x0008 (0x0008 - 0x0000)
struct FTargetQueryTestDebugDesc final
{
public:
	float                                         Value;                                             // 0x0000(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         Score;                                             // 0x0004(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FTargetQueryTestDebugDesc) == 0x000004, "Wrong alignment on FTargetQueryTestDebugDesc");
static_assert(sizeof(FTargetQueryTestDebugDesc) == 0x000008, "Wrong size on FTargetQueryTestDebugDesc");
static_assert(offsetof(FTargetQueryTestDebugDesc, Value) == 0x000000, "Member 'FTargetQueryTestDebugDesc::Value' has a wrong offset!");
static_assert(offsetof(FTargetQueryTestDebugDesc, Score) == 0x000004, "Member 'FTargetQueryTestDebugDesc::Score' has a wrong offset!");

// ScriptStruct GbxGameSystemCore.AIDodgeBasicData
// 0x0098 (0x0098 - 0x0000)
struct FAIDodgeBasicData
{
public:
	struct FGbxParam                              Cooldown;                                          // 0x0000(0x0080)(Edit, NoDestructor, ContainsInstancedReference, NativeAccessSpecifierPublic)
	TSubclassOf<class UGbxAction>                 Action;                                            // 0x0080(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UGbxCondition*                          Condition;                                         // 0x0088(0x0008)(Edit, ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, PersistentInstance, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_90[0x8];                                       // 0x0090(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FAIDodgeBasicData) == 0x000008, "Wrong alignment on FAIDodgeBasicData");
static_assert(sizeof(FAIDodgeBasicData) == 0x000098, "Wrong size on FAIDodgeBasicData");
static_assert(offsetof(FAIDodgeBasicData, Cooldown) == 0x000000, "Member 'FAIDodgeBasicData::Cooldown' has a wrong offset!");
static_assert(offsetof(FAIDodgeBasicData, Action) == 0x000080, "Member 'FAIDodgeBasicData::Action' has a wrong offset!");
static_assert(offsetof(FAIDodgeBasicData, Condition) == 0x000088, "Member 'FAIDodgeBasicData::Condition' has a wrong offset!");

// ScriptStruct GbxGameSystemCore.SceneComponentSwitchRecord
// 0x0070 (0x0070 - 0x0000)
struct alignas(0x10) FSceneComponentSwitchRecord final
{
public:
	class USceneComponent*                        Component;                                         // 0x0000(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class USceneComponent*                        ParentComponent;                                   // 0x0008(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class USceneBodySwitchAction*                 DetachAction;                                      // 0x0010(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_18[0x58];                                      // 0x0018(0x0058)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FSceneComponentSwitchRecord) == 0x000010, "Wrong alignment on FSceneComponentSwitchRecord");
static_assert(sizeof(FSceneComponentSwitchRecord) == 0x000070, "Wrong size on FSceneComponentSwitchRecord");
static_assert(offsetof(FSceneComponentSwitchRecord, Component) == 0x000000, "Member 'FSceneComponentSwitchRecord::Component' has a wrong offset!");
static_assert(offsetof(FSceneComponentSwitchRecord, ParentComponent) == 0x000008, "Member 'FSceneComponentSwitchRecord::ParentComponent' has a wrong offset!");
static_assert(offsetof(FSceneComponentSwitchRecord, DetachAction) == 0x000010, "Member 'FSceneComponentSwitchRecord::DetachAction' has a wrong offset!");

// ScriptStruct GbxGameSystemCore.AttachSlotAnimSet
// 0x0030 (0x0030 - 0x0000)
struct FAttachSlotAnimSet final
{
public:
	TSoftObjectPtr<class UObject>                 AssociatedCharacter;                               // 0x0000(0x0028)(Edit, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UGbxAnimSet*                            AnimSet;                                           // 0x0028(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FAttachSlotAnimSet) == 0x000008, "Wrong alignment on FAttachSlotAnimSet");
static_assert(sizeof(FAttachSlotAnimSet) == 0x000030, "Wrong size on FAttachSlotAnimSet");
static_assert(offsetof(FAttachSlotAnimSet, AssociatedCharacter) == 0x000000, "Member 'FAttachSlotAnimSet::AssociatedCharacter' has a wrong offset!");
static_assert(offsetof(FAttachSlotAnimSet, AnimSet) == 0x000028, "Member 'FAttachSlotAnimSet::AnimSet' has a wrong offset!");

// ScriptStruct GbxGameSystemCore.AIDodgeData
// 0x0120 (0x01B8 - 0x0098)
struct FAIDodgeData final : public FAIDodgeBasicData
{
public:
	struct FGbxParam                              Chance;                                            // 0x0098(0x0080)(Edit, NoDestructor, ContainsInstancedReference, NativeAccessSpecifierPublic)
	struct FGbxParam                              Delay;                                             // 0x0118(0x0080)(Edit, NoDestructor, ContainsInstancedReference, NativeAccessSpecifierPublic)
	bool                                          bRemoveAllDelay;                                   // 0x0198(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_199[0x3];                                      // 0x0199(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         MaxAngle;                                          // 0x019C(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bLimitAngle;                                       // 0x01A0(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1A1[0x3];                                      // 0x01A1(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         MaxDistance;                                       // 0x01A4(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bLimitDistance;                                    // 0x01A8(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1A9[0x3];                                      // 0x01A9(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         MinShooterDistance;                                // 0x01AC(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bLimitShooterDistance;                             // 0x01B0(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1B1[0x7];                                      // 0x01B1(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FAIDodgeData) == 0x000008, "Wrong alignment on FAIDodgeData");
static_assert(sizeof(FAIDodgeData) == 0x0001B8, "Wrong size on FAIDodgeData");
static_assert(offsetof(FAIDodgeData, Chance) == 0x000098, "Member 'FAIDodgeData::Chance' has a wrong offset!");
static_assert(offsetof(FAIDodgeData, Delay) == 0x000118, "Member 'FAIDodgeData::Delay' has a wrong offset!");
static_assert(offsetof(FAIDodgeData, bRemoveAllDelay) == 0x000198, "Member 'FAIDodgeData::bRemoveAllDelay' has a wrong offset!");
static_assert(offsetof(FAIDodgeData, MaxAngle) == 0x00019C, "Member 'FAIDodgeData::MaxAngle' has a wrong offset!");
static_assert(offsetof(FAIDodgeData, bLimitAngle) == 0x0001A0, "Member 'FAIDodgeData::bLimitAngle' has a wrong offset!");
static_assert(offsetof(FAIDodgeData, MaxDistance) == 0x0001A4, "Member 'FAIDodgeData::MaxDistance' has a wrong offset!");
static_assert(offsetof(FAIDodgeData, bLimitDistance) == 0x0001A8, "Member 'FAIDodgeData::bLimitDistance' has a wrong offset!");
static_assert(offsetof(FAIDodgeData, MinShooterDistance) == 0x0001AC, "Member 'FAIDodgeData::MinShooterDistance' has a wrong offset!");
static_assert(offsetof(FAIDodgeData, bLimitShooterDistance) == 0x0001B0, "Member 'FAIDodgeData::bLimitShooterDistance' has a wrong offset!");

// ScriptStruct GbxGameSystemCore.CustomizationStreamingEntry
// 0x0040 (0x0040 - 0x0000)
struct FCustomizationStreamingEntry final
{
public:
	class UGbxCustomizationData*                  CustomizationData;                                 // 0x0000(0x0008)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_8[0x8];                                        // 0x0008(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<class UGbxCustomizationComponent*>     WaitingComponents;                                 // 0x0010(0x0010)(ExportObject, ZeroConstructor, Transient, ContainsInstancedReference, NativeAccessSpecifierPublic)
	uint8                                         Pad_20[0x20];                                      // 0x0020(0x0020)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FCustomizationStreamingEntry) == 0x000008, "Wrong alignment on FCustomizationStreamingEntry");
static_assert(sizeof(FCustomizationStreamingEntry) == 0x000040, "Wrong size on FCustomizationStreamingEntry");
static_assert(offsetof(FCustomizationStreamingEntry, CustomizationData) == 0x000000, "Member 'FCustomizationStreamingEntry::CustomizationData' has a wrong offset!");
static_assert(offsetof(FCustomizationStreamingEntry, WaitingComponents) == 0x000010, "Member 'FCustomizationStreamingEntry::WaitingComponents' has a wrong offset!");

// ScriptStruct GbxGameSystemCore.AIBulletEvent
// 0x0038 (0x0038 - 0x0000)
struct FAIBulletEvent final
{
public:
	uint8                                         Pad_0[0x20];                                       // 0x0000(0x0020)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         Strength;                                          // 0x0020(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_24[0x4];                                       // 0x0024(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class AActor*                                 Instigator;                                        // 0x0028(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_30[0x8];                                       // 0x0030(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FAIBulletEvent) == 0x000008, "Wrong alignment on FAIBulletEvent");
static_assert(sizeof(FAIBulletEvent) == 0x000038, "Wrong size on FAIBulletEvent");
static_assert(offsetof(FAIBulletEvent, Strength) == 0x000020, "Member 'FAIBulletEvent::Strength' has a wrong offset!");
static_assert(offsetof(FAIBulletEvent, Instigator) == 0x000028, "Member 'FAIBulletEvent::Instigator' has a wrong offset!");

// ScriptStruct GbxGameSystemCore.TargetLocationBoundsSettings
// 0x000C (0x000C - 0x0000)
struct FTargetLocationBoundsSettings
{
public:
	float                                         BoundsRadius;                                      // 0x0000(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         BoundsHalfHeight;                                  // 0x0004(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bUseBoundsHalfHeight;                              // 0x0008(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_9[0x3];                                        // 0x0009(0x0003)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FTargetLocationBoundsSettings) == 0x000004, "Wrong alignment on FTargetLocationBoundsSettings");
static_assert(sizeof(FTargetLocationBoundsSettings) == 0x00000C, "Wrong size on FTargetLocationBoundsSettings");
static_assert(offsetof(FTargetLocationBoundsSettings, BoundsRadius) == 0x000000, "Member 'FTargetLocationBoundsSettings::BoundsRadius' has a wrong offset!");
static_assert(offsetof(FTargetLocationBoundsSettings, BoundsHalfHeight) == 0x000004, "Member 'FTargetLocationBoundsSettings::BoundsHalfHeight' has a wrong offset!");
static_assert(offsetof(FTargetLocationBoundsSettings, bUseBoundsHalfHeight) == 0x000008, "Member 'FTargetLocationBoundsSettings::bUseBoundsHalfHeight' has a wrong offset!");

// ScriptStruct GbxGameSystemCore.TargetLocationSettings
// 0x008C (0x0098 - 0x000C)
struct FTargetLocationSettings final : public FTargetLocationBoundsSettings
{
public:
	uint8                                         Pad_C[0x4];                                        // 0x000C(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	struct FGbxParam                              Enabled;                                           // 0x0010(0x0080)(Edit, BlueprintVisible, NoDestructor, ContainsInstancedReference, NativeAccessSpecifierPublic)
	class FName                                   Socket;                                            // 0x0090(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FTargetLocationSettings) == 0x000008, "Wrong alignment on FTargetLocationSettings");
static_assert(sizeof(FTargetLocationSettings) == 0x000098, "Wrong size on FTargetLocationSettings");
static_assert(offsetof(FTargetLocationSettings, Enabled) == 0x000010, "Member 'FTargetLocationSettings::Enabled' has a wrong offset!");
static_assert(offsetof(FTargetLocationSettings, Socket) == 0x000090, "Member 'FTargetLocationSettings::Socket' has a wrong offset!");

// ScriptStruct GbxGameSystemCore.PredictionSource
// 0x000C (0x000C - 0x0000)
struct alignas(0x04) FPredictionSource final
{
public:
	uint8                                         Pad_0[0xC];                                        // 0x0000(0x000C)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FPredictionSource) == 0x000004, "Wrong alignment on FPredictionSource");
static_assert(sizeof(FPredictionSource) == 0x00000C, "Wrong size on FPredictionSource");

// ScriptStruct GbxGameSystemCore.EmitterWwiseEvent
// 0x0040 (0x0040 - 0x0000)
struct FEmitterWwiseEvent final
{
public:
	class UObject*                                ParamsProvider;                                    // 0x0000(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UWwiseEvent*                            Event;                                             // 0x0008(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TArray<struct FEmitterWwiseEventRTPCParam>    RTPCs;                                             // 0x0010(0x0010)(ZeroConstructor, NativeAccessSpecifierPublic)
	TArray<class UWwiseSwitch*>                   Switches;                                          // 0x0020(0x0010)(ZeroConstructor, NativeAccessSpecifierPublic)
	struct FVector                                PlaybackLocation;                                  // 0x0030(0x000C)(IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_3C[0x4];                                       // 0x003C(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FEmitterWwiseEvent) == 0x000008, "Wrong alignment on FEmitterWwiseEvent");
static_assert(sizeof(FEmitterWwiseEvent) == 0x000040, "Wrong size on FEmitterWwiseEvent");
static_assert(offsetof(FEmitterWwiseEvent, ParamsProvider) == 0x000000, "Member 'FEmitterWwiseEvent::ParamsProvider' has a wrong offset!");
static_assert(offsetof(FEmitterWwiseEvent, Event) == 0x000008, "Member 'FEmitterWwiseEvent::Event' has a wrong offset!");
static_assert(offsetof(FEmitterWwiseEvent, RTPCs) == 0x000010, "Member 'FEmitterWwiseEvent::RTPCs' has a wrong offset!");
static_assert(offsetof(FEmitterWwiseEvent, Switches) == 0x000020, "Member 'FEmitterWwiseEvent::Switches' has a wrong offset!");
static_assert(offsetof(FEmitterWwiseEvent, PlaybackLocation) == 0x000030, "Member 'FEmitterWwiseEvent::PlaybackLocation' has a wrong offset!");

// ScriptStruct GbxGameSystemCore.GbxAISightEvent
// 0x0018 (0x0018 - 0x0000)
struct FGbxAISightEvent final
{
public:
	uint8                                         Pad_0[0x8];                                        // 0x0000(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	class AActor*                                 SeenActor;                                         // 0x0008(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class AActor*                                 Observer;                                          // 0x0010(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FGbxAISightEvent) == 0x000008, "Wrong alignment on FGbxAISightEvent");
static_assert(sizeof(FGbxAISightEvent) == 0x000018, "Wrong size on FGbxAISightEvent");
static_assert(offsetof(FGbxAISightEvent, SeenActor) == 0x000008, "Member 'FGbxAISightEvent::SeenActor' has a wrong offset!");
static_assert(offsetof(FGbxAISightEvent, Observer) == 0x000010, "Member 'FGbxAISightEvent::Observer' has a wrong offset!");

// ScriptStruct GbxGameSystemCore.RecentlyCausedDamageInstance
// 0x0048 (0x0048 - 0x0000)
struct FRecentlyCausedDamageInstance final
{
public:
	TSubclassOf<class UGbxDamageType>             DamageType;                                        // 0x0000(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TSubclassOf<class UDamageSource>              DamageSource;                                      // 0x0008(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector_NetQuantize                    DamageLocation;                                    // 0x0010(0x000C)(NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         TotalDamage;                                       // 0x001C(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         DirtyCounter;                                      // 0x0020(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_21[0x7];                                       // 0x0021(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	class UHitRegionData*                         HitRegion;                                         // 0x0028(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	ERecentDamageFlags                            DamageFlags;                                       // 0x0030(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_31[0x7];                                       // 0x0031(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	class AActor*                                 DamagedActor;                                      // 0x0038(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_40[0x8];                                       // 0x0040(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FRecentlyCausedDamageInstance) == 0x000008, "Wrong alignment on FRecentlyCausedDamageInstance");
static_assert(sizeof(FRecentlyCausedDamageInstance) == 0x000048, "Wrong size on FRecentlyCausedDamageInstance");
static_assert(offsetof(FRecentlyCausedDamageInstance, DamageType) == 0x000000, "Member 'FRecentlyCausedDamageInstance::DamageType' has a wrong offset!");
static_assert(offsetof(FRecentlyCausedDamageInstance, DamageSource) == 0x000008, "Member 'FRecentlyCausedDamageInstance::DamageSource' has a wrong offset!");
static_assert(offsetof(FRecentlyCausedDamageInstance, DamageLocation) == 0x000010, "Member 'FRecentlyCausedDamageInstance::DamageLocation' has a wrong offset!");
static_assert(offsetof(FRecentlyCausedDamageInstance, TotalDamage) == 0x00001C, "Member 'FRecentlyCausedDamageInstance::TotalDamage' has a wrong offset!");
static_assert(offsetof(FRecentlyCausedDamageInstance, DirtyCounter) == 0x000020, "Member 'FRecentlyCausedDamageInstance::DirtyCounter' has a wrong offset!");
static_assert(offsetof(FRecentlyCausedDamageInstance, HitRegion) == 0x000028, "Member 'FRecentlyCausedDamageInstance::HitRegion' has a wrong offset!");
static_assert(offsetof(FRecentlyCausedDamageInstance, DamageFlags) == 0x000030, "Member 'FRecentlyCausedDamageInstance::DamageFlags' has a wrong offset!");
static_assert(offsetof(FRecentlyCausedDamageInstance, DamagedActor) == 0x000038, "Member 'FRecentlyCausedDamageInstance::DamagedActor' has a wrong offset!");

// ScriptStruct GbxGameSystemCore.StretchAnimData
// 0x01E0 (0x01E0 - 0x0000)
struct FStretchAnimData final
{
public:
	class AActor*                                 Actor;                                             // 0x0000(0x0008)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UAnimSequence*                          AnimSeq;                                           // 0x0008(0x0008)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_10[0x1D0];                                     // 0x0010(0x01D0)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FStretchAnimData) == 0x000008, "Wrong alignment on FStretchAnimData");
static_assert(sizeof(FStretchAnimData) == 0x0001E0, "Wrong size on FStretchAnimData");
static_assert(offsetof(FStretchAnimData, Actor) == 0x000000, "Member 'FStretchAnimData::Actor' has a wrong offset!");
static_assert(offsetof(FStretchAnimData, AnimSeq) == 0x000008, "Member 'FStretchAnimData::AnimSeq' has a wrong offset!");

// ScriptStruct GbxGameSystemCore.HitRegionDamagePreview
// 0x0018 (0x0018 - 0x0000)
struct FHitRegionDamagePreview final
{
public:
	struct FHitRegionInfo                         HitRegion;                                         // 0x0000(0x0010)(NoDestructor, NativeAccessSpecifierPublic)
	uint8                                         Pad_10[0x8];                                       // 0x0010(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FHitRegionDamagePreview) == 0x000008, "Wrong alignment on FHitRegionDamagePreview");
static_assert(sizeof(FHitRegionDamagePreview) == 0x000018, "Wrong size on FHitRegionDamagePreview");
static_assert(offsetof(FHitRegionDamagePreview, HitRegion) == 0x000000, "Member 'FHitRegionDamagePreview::HitRegion' has a wrong offset!");

// ScriptStruct GbxGameSystemCore.AsyncExplosionImpactRequest
// 0x0170 (0x0170 - 0x0000)
struct FAsyncExplosionImpactRequest final
{
public:
	class UImpactData*                            ExplosionImpact;                                   // 0x0000(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class AActor*                                 ExplodingActor;                                    // 0x0008(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class AActor*                                 Instigator;                                        // 0x0010(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UWorld*                                 World;                                             // 0x0018(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_20[0x150];                                     // 0x0020(0x0150)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FAsyncExplosionImpactRequest) == 0x000008, "Wrong alignment on FAsyncExplosionImpactRequest");
static_assert(sizeof(FAsyncExplosionImpactRequest) == 0x000170, "Wrong size on FAsyncExplosionImpactRequest");
static_assert(offsetof(FAsyncExplosionImpactRequest, ExplosionImpact) == 0x000000, "Member 'FAsyncExplosionImpactRequest::ExplosionImpact' has a wrong offset!");
static_assert(offsetof(FAsyncExplosionImpactRequest, ExplodingActor) == 0x000008, "Member 'FAsyncExplosionImpactRequest::ExplodingActor' has a wrong offset!");
static_assert(offsetof(FAsyncExplosionImpactRequest, Instigator) == 0x000010, "Member 'FAsyncExplosionImpactRequest::Instigator' has a wrong offset!");
static_assert(offsetof(FAsyncExplosionImpactRequest, World) == 0x000018, "Member 'FAsyncExplosionImpactRequest::World' has a wrong offset!");

// ScriptStruct GbxGameSystemCore.ActionState_DropshipSpawn
// 0x0068 (0x04D0 - 0x0468)
struct alignas(0x10) FActionState_DropshipSpawn final : public FActionState_SimpleAnim
{
public:
	uint8                                         Pad_468[0x68];                                     // 0x0468(0x0068)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FActionState_DropshipSpawn) == 0x000010, "Wrong alignment on FActionState_DropshipSpawn");
static_assert(sizeof(FActionState_DropshipSpawn) == 0x0004D0, "Wrong size on FActionState_DropshipSpawn");

// ScriptStruct GbxGameSystemCore.AsyncExplosionImpactRequestEntry
// 0x00A0 (0x00A0 - 0x0000)
struct alignas(0x08) FAsyncExplosionImpactRequestEntry final
{
public:
	uint8                                         Pad_0[0xA0];                                       // 0x0000(0x00A0)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FAsyncExplosionImpactRequestEntry) == 0x000008, "Wrong alignment on FAsyncExplosionImpactRequestEntry");
static_assert(sizeof(FAsyncExplosionImpactRequestEntry) == 0x0000A0, "Wrong size on FAsyncExplosionImpactRequestEntry");

// ScriptStruct GbxGameSystemCore.GameStageGradeWeightData
// 0x0070 (0x0070 - 0x0000)
struct FGameStageGradeWeightData final
{
public:
	struct FAttributeInitializationData           MinGameStage;                                      // 0x0000(0x0038)(Edit, NoDestructor, NativeAccessSpecifierPrivate)
	struct FAttributeInitializationData           MaxGameStage;                                      // 0x0038(0x0038)(Edit, NoDestructor, NativeAccessSpecifierPrivate)
};
static_assert(alignof(FGameStageGradeWeightData) == 0x000008, "Wrong alignment on FGameStageGradeWeightData");
static_assert(sizeof(FGameStageGradeWeightData) == 0x000070, "Wrong size on FGameStageGradeWeightData");
static_assert(offsetof(FGameStageGradeWeightData, MinGameStage) == 0x000000, "Member 'FGameStageGradeWeightData::MinGameStage' has a wrong offset!");
static_assert(offsetof(FGameStageGradeWeightData, MaxGameStage) == 0x000038, "Member 'FGameStageGradeWeightData::MaxGameStage' has a wrong offset!");

// ScriptStruct GbxGameSystemCore.ChallengeGoalValue
// 0x0008 (0x0008 - 0x0000)
struct FChallengeGoalValue final
{
public:
	int32                                         GoalValue;                                         // 0x0000(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         NotificationThreshold;                             // 0x0004(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FChallengeGoalValue) == 0x000004, "Wrong alignment on FChallengeGoalValue");
static_assert(sizeof(FChallengeGoalValue) == 0x000008, "Wrong size on FChallengeGoalValue");
static_assert(offsetof(FChallengeGoalValue, GoalValue) == 0x000000, "Member 'FChallengeGoalValue::GoalValue' has a wrong offset!");
static_assert(offsetof(FChallengeGoalValue, NotificationThreshold) == 0x000004, "Member 'FChallengeGoalValue::NotificationThreshold' has a wrong offset!");

// ScriptStruct GbxGameSystemCore.StatChallengeTest
// 0x0030 (0x0030 - 0x0000)
struct FStatChallengeTest final
{
public:
	class UGameStatData*                          StatId;                                            // 0x0000(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TArray<struct FChallengeGoalValue>            GoalInfo;                                          // 0x0008(0x0010)(Edit, ZeroConstructor, NativeAccessSpecifierPublic)
	TArray<int32>                                 GoalValues;                                        // 0x0018(0x0010)(ZeroConstructor, Deprecated, NativeAccessSpecifierPublic)
	bool                                          bUseLocalStat;                                     // 0x0028(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bResetLocalStatWhenGoalReached;                    // 0x0029(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2A[0x6];                                       // 0x002A(0x0006)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FStatChallengeTest) == 0x000008, "Wrong alignment on FStatChallengeTest");
static_assert(sizeof(FStatChallengeTest) == 0x000030, "Wrong size on FStatChallengeTest");
static_assert(offsetof(FStatChallengeTest, StatId) == 0x000000, "Member 'FStatChallengeTest::StatId' has a wrong offset!");
static_assert(offsetof(FStatChallengeTest, GoalInfo) == 0x000008, "Member 'FStatChallengeTest::GoalInfo' has a wrong offset!");
static_assert(offsetof(FStatChallengeTest, GoalValues) == 0x000018, "Member 'FStatChallengeTest::GoalValues' has a wrong offset!");
static_assert(offsetof(FStatChallengeTest, bUseLocalStat) == 0x000028, "Member 'FStatChallengeTest::bUseLocalStat' has a wrong offset!");
static_assert(offsetof(FStatChallengeTest, bResetLocalStatWhenGoalReached) == 0x000029, "Member 'FStatChallengeTest::bResetLocalStatWhenGoalReached' has a wrong offset!");

// ScriptStruct GbxGameSystemCore.PlayerInputBinding_Axis_Key
// 0x0018 (0x0018 - 0x0000)
struct alignas(0x08) FPlayerInputBinding_Axis_Key final
{
public:
	class FName                                   KeyName;                                           // 0x0000(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                Scale3D;                                           // 0x0008(0x000C)(IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_14[0x4];                                       // 0x0014(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FPlayerInputBinding_Axis_Key) == 0x000008, "Wrong alignment on FPlayerInputBinding_Axis_Key");
static_assert(sizeof(FPlayerInputBinding_Axis_Key) == 0x000018, "Wrong size on FPlayerInputBinding_Axis_Key");
static_assert(offsetof(FPlayerInputBinding_Axis_Key, KeyName) == 0x000000, "Member 'FPlayerInputBinding_Axis_Key::KeyName' has a wrong offset!");
static_assert(offsetof(FPlayerInputBinding_Axis_Key, Scale3D) == 0x000008, "Member 'FPlayerInputBinding_Axis_Key::Scale3D' has a wrong offset!");

// ScriptStruct GbxGameSystemCore.PlayerInputBinding_Axis
// 0x0020 (0x0020 - 0x0000)
struct FPlayerInputBinding_Axis final
{
public:
	class FString                                 RebindDataPath;                                    // 0x0000(0x0010)(ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TArray<struct FPlayerInputBinding_Axis_Key>   Keys;                                              // 0x0010(0x0010)(ZeroConstructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(FPlayerInputBinding_Axis) == 0x000008, "Wrong alignment on FPlayerInputBinding_Axis");
static_assert(sizeof(FPlayerInputBinding_Axis) == 0x000020, "Wrong size on FPlayerInputBinding_Axis");
static_assert(offsetof(FPlayerInputBinding_Axis, RebindDataPath) == 0x000000, "Member 'FPlayerInputBinding_Axis::RebindDataPath' has a wrong offset!");
static_assert(offsetof(FPlayerInputBinding_Axis, Keys) == 0x000010, "Member 'FPlayerInputBinding_Axis::Keys' has a wrong offset!");

// ScriptStruct GbxGameSystemCore.EmitterVectorParam
// 0x0018 (0x0018 - 0x0000)
struct alignas(0x08) FEmitterVectorParam final
{
public:
	class FName                                   Name;                                              // 0x0000(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                Value;                                             // 0x0008(0x000C)(IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_14[0x4];                                       // 0x0014(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FEmitterVectorParam) == 0x000008, "Wrong alignment on FEmitterVectorParam");
static_assert(sizeof(FEmitterVectorParam) == 0x000018, "Wrong size on FEmitterVectorParam");
static_assert(offsetof(FEmitterVectorParam, Name) == 0x000000, "Member 'FEmitterVectorParam::Name' has a wrong offset!");
static_assert(offsetof(FEmitterVectorParam, Value) == 0x000008, "Member 'FEmitterVectorParam::Value' has a wrong offset!");

// ScriptStruct GbxGameSystemCore.ChallengeDataType
// 0x0010 (0x0010 - 0x0000)
struct FChallengeDataType final
{
public:
	class UEnum*                                  ChallengeDataTypeEnum;                             // 0x0000(0x0008)(Edit, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         ChallengeDataType;                                 // 0x0008(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_9[0x7];                                        // 0x0009(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FChallengeDataType) == 0x000008, "Wrong alignment on FChallengeDataType");
static_assert(sizeof(FChallengeDataType) == 0x000010, "Wrong size on FChallengeDataType");
static_assert(offsetof(FChallengeDataType, ChallengeDataTypeEnum) == 0x000000, "Member 'FChallengeDataType::ChallengeDataTypeEnum' has a wrong offset!");
static_assert(offsetof(FChallengeDataType, ChallengeDataType) == 0x000008, "Member 'FChallengeDataType::ChallengeDataType' has a wrong offset!");

// ScriptStruct GbxGameSystemCore.GbxQuery
// 0x03B0 (0x03B0 - 0x0000)
struct FGbxQuery final
{
public:
	class AActor*                                 Owner;                                             // 0x0000(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FEnvQueryParams                        Params;                                            // 0x0008(0x00B8)(ContainsInstancedReference, NativeAccessSpecifierPublic)
	struct FGbxQueryOptions                       Options;                                           // 0x00C0(0x0238)(NoDestructor, ContainsInstancedReference, NativeAccessSpecifierPublic)
	class AActor*                                 PrimaryContext;                                    // 0x02F8(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UBlackboardComponent*                   BlackboardComp;                                    // 0x0300(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UNavComponent*                          NavComp;                                           // 0x0308(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_310[0xA0];                                     // 0x0310(0x00A0)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FGbxQuery) == 0x000008, "Wrong alignment on FGbxQuery");
static_assert(sizeof(FGbxQuery) == 0x0003B0, "Wrong size on FGbxQuery");
static_assert(offsetof(FGbxQuery, Owner) == 0x000000, "Member 'FGbxQuery::Owner' has a wrong offset!");
static_assert(offsetof(FGbxQuery, Params) == 0x000008, "Member 'FGbxQuery::Params' has a wrong offset!");
static_assert(offsetof(FGbxQuery, Options) == 0x0000C0, "Member 'FGbxQuery::Options' has a wrong offset!");
static_assert(offsetof(FGbxQuery, PrimaryContext) == 0x0002F8, "Member 'FGbxQuery::PrimaryContext' has a wrong offset!");
static_assert(offsetof(FGbxQuery, BlackboardComp) == 0x000300, "Member 'FGbxQuery::BlackboardComp' has a wrong offset!");
static_assert(offsetof(FGbxQuery, NavComp) == 0x000308, "Member 'FGbxQuery::NavComp' has a wrong offset!");

// ScriptStruct GbxGameSystemCore.AttributeConditionalValue
// 0x0048 (0x0048 - 0x0000)
struct FAttributeConditionalValue final
{
public:
	struct FAttributeInitializationData           ValueIfAllConditionsAreTrue;                       // 0x0000(0x0038)(Edit, NoDestructor, NativeAccessSpecifierPublic)
	TArray<class UGbxCondition*>                  Conditions;                                        // 0x0038(0x0010)(Edit, ExportObject, ZeroConstructor, ContainsInstancedReference, NativeAccessSpecifierPublic)
};
static_assert(alignof(FAttributeConditionalValue) == 0x000008, "Wrong alignment on FAttributeConditionalValue");
static_assert(sizeof(FAttributeConditionalValue) == 0x000048, "Wrong size on FAttributeConditionalValue");
static_assert(offsetof(FAttributeConditionalValue, ValueIfAllConditionsAreTrue) == 0x000000, "Member 'FAttributeConditionalValue::ValueIfAllConditionsAreTrue' has a wrong offset!");
static_assert(offsetof(FAttributeConditionalValue, Conditions) == 0x000038, "Member 'FAttributeConditionalValue::Conditions' has a wrong offset!");

// ScriptStruct GbxGameSystemCore.ConditionalDamageDamageTypeConditional
// 0x0010 (0x0010 - 0x0000)
struct FConditionalDamageDamageTypeConditional final
{
public:
	class UGbxCondition*                          Condition;                                         // 0x0000(0x0008)(Edit, ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, PersistentInstance, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TSubclassOf<class UGbxDamageType>             DamageType;                                        // 0x0008(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FConditionalDamageDamageTypeConditional) == 0x000008, "Wrong alignment on FConditionalDamageDamageTypeConditional");
static_assert(sizeof(FConditionalDamageDamageTypeConditional) == 0x000010, "Wrong size on FConditionalDamageDamageTypeConditional");
static_assert(offsetof(FConditionalDamageDamageTypeConditional, Condition) == 0x000000, "Member 'FConditionalDamageDamageTypeConditional::Condition' has a wrong offset!");
static_assert(offsetof(FConditionalDamageDamageTypeConditional, DamageType) == 0x000008, "Member 'FConditionalDamageDamageTypeConditional::DamageType' has a wrong offset!");

// ScriptStruct GbxGameSystemCore.ConditionalDamageDamageConditionalValue
// 0x0040 (0x0040 - 0x0000)
struct FConditionalDamageDamageConditionalValue final
{
public:
	class UGbxCondition*                          Condition;                                         // 0x0000(0x0008)(Edit, ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, PersistentInstance, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FAttributeInitializationData           DamageValue;                                       // 0x0008(0x0038)(Edit, NoDestructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(FConditionalDamageDamageConditionalValue) == 0x000008, "Wrong alignment on FConditionalDamageDamageConditionalValue");
static_assert(sizeof(FConditionalDamageDamageConditionalValue) == 0x000040, "Wrong size on FConditionalDamageDamageConditionalValue");
static_assert(offsetof(FConditionalDamageDamageConditionalValue, Condition) == 0x000000, "Member 'FConditionalDamageDamageConditionalValue::Condition' has a wrong offset!");
static_assert(offsetof(FConditionalDamageDamageConditionalValue, DamageValue) == 0x000008, "Member 'FConditionalDamageDamageConditionalValue::DamageValue' has a wrong offset!");

// ScriptStruct GbxGameSystemCore.CMMotionData
// 0x0168 (0x0168 - 0x0000)
struct FCMMotionData final
{
public:
	struct FRuntimeFloatCurve                     X;                                                 // 0x0000(0x0078)(Edit, NativeAccessSpecifierPublic)
	struct FRuntimeFloatCurve                     Y;                                                 // 0x0078(0x0078)(Edit, NativeAccessSpecifierPublic)
	struct FRuntimeFloatCurve                     Z;                                                 // 0x00F0(0x0078)(Edit, NativeAccessSpecifierPublic)
};
static_assert(alignof(FCMMotionData) == 0x000008, "Wrong alignment on FCMMotionData");
static_assert(sizeof(FCMMotionData) == 0x000168, "Wrong size on FCMMotionData");
static_assert(offsetof(FCMMotionData, X) == 0x000000, "Member 'FCMMotionData::X' has a wrong offset!");
static_assert(offsetof(FCMMotionData, Y) == 0x000078, "Member 'FCMMotionData::Y' has a wrong offset!");
static_assert(offsetof(FCMMotionData, Z) == 0x0000F0, "Member 'FCMMotionData::Z' has a wrong offset!");

// ScriptStruct GbxGameSystemCore.GesaltOptionalPartData
// 0x0010 (0x0010 - 0x0000)
struct FGesaltOptionalPartData final
{
public:
	class UGestaltPartData*                       GestaltPart;                                       // 0x0000(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         Probability;                                       // 0x0008(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bSuppressChildParts;                               // 0x000C(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_D[0x3];                                        // 0x000D(0x0003)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FGesaltOptionalPartData) == 0x000008, "Wrong alignment on FGesaltOptionalPartData");
static_assert(sizeof(FGesaltOptionalPartData) == 0x000010, "Wrong size on FGesaltOptionalPartData");
static_assert(offsetof(FGesaltOptionalPartData, GestaltPart) == 0x000000, "Member 'FGesaltOptionalPartData::GestaltPart' has a wrong offset!");
static_assert(offsetof(FGesaltOptionalPartData, Probability) == 0x000008, "Member 'FGesaltOptionalPartData::Probability' has a wrong offset!");
static_assert(offsetof(FGesaltOptionalPartData, bSuppressChildParts) == 0x00000C, "Member 'FGesaltOptionalPartData::bSuppressChildParts' has a wrong offset!");

// ScriptStruct GbxGameSystemCore.DamagedActor
// 0x00E0 (0x00E0 - 0x0000)
struct FDamagedActor final
{
public:
	class AActor*                                 Actor;                                             // 0x0000(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UDamageComponent*                       DamageComponent;                                   // 0x0008(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_10[0xD0];                                      // 0x0010(0x00D0)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FDamagedActor) == 0x000008, "Wrong alignment on FDamagedActor");
static_assert(sizeof(FDamagedActor) == 0x0000E0, "Wrong size on FDamagedActor");
static_assert(offsetof(FDamagedActor, Actor) == 0x000000, "Member 'FDamagedActor::Actor' has a wrong offset!");
static_assert(offsetof(FDamagedActor, DamageComponent) == 0x000008, "Member 'FDamagedActor::DamageComponent' has a wrong offset!");

// ScriptStruct GbxGameSystemCore.DamageTargetResult
// 0x0190 (0x0190 - 0x0000)
struct FDamageTargetResult final
{
public:
	class UDamageComponent*                       DamageComponent;                                   // 0x0000(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_8[0x10];                                       // 0x0008(0x0010)(Fixing Size After Last Property [ Dumper-7 ])
	struct FDamagedActor                          AsyncDamagedActor;                                 // 0x0018(0x00E0)(ContainsInstancedReference, NativeAccessSpecifierPublic)
	uint8                                         Pad_F8[0x98];                                      // 0x00F8(0x0098)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FDamageTargetResult) == 0x000008, "Wrong alignment on FDamageTargetResult");
static_assert(sizeof(FDamageTargetResult) == 0x000190, "Wrong size on FDamageTargetResult");
static_assert(offsetof(FDamageTargetResult, DamageComponent) == 0x000000, "Member 'FDamageTargetResult::DamageComponent' has a wrong offset!");
static_assert(offsetof(FDamageTargetResult, AsyncDamagedActor) == 0x000018, "Member 'FDamageTargetResult::AsyncDamagedActor' has a wrong offset!");

// ScriptStruct GbxGameSystemCore.CauseDamageAsyncRequest
// 0x0230 (0x0230 - 0x0000)
struct alignas(0x10) FCauseDamageAsyncRequest
{
public:
	class UDamageData*                            DamageData;                                        // 0x0000(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FDamageContextSource                   DamageContext;                                     // 0x0008(0x0010)(NoDestructor, NativeAccessSpecifierPublic)
	class AActor*                                 DamageTarget;                                      // 0x0018(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_20[0x210];                                     // 0x0020(0x0210)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FCauseDamageAsyncRequest) == 0x000010, "Wrong alignment on FCauseDamageAsyncRequest");
static_assert(sizeof(FCauseDamageAsyncRequest) == 0x000230, "Wrong size on FCauseDamageAsyncRequest");
static_assert(offsetof(FCauseDamageAsyncRequest, DamageData) == 0x000000, "Member 'FCauseDamageAsyncRequest::DamageData' has a wrong offset!");
static_assert(offsetof(FCauseDamageAsyncRequest, DamageContext) == 0x000008, "Member 'FCauseDamageAsyncRequest::DamageContext' has a wrong offset!");
static_assert(offsetof(FCauseDamageAsyncRequest, DamageTarget) == 0x000018, "Member 'FCauseDamageAsyncRequest::DamageTarget' has a wrong offset!");

// ScriptStruct GbxGameSystemCore.RelativeDirectionData
// 0x0050 (0x0050 - 0x0000)
struct FRelativeDirectionData final
{
public:
	ERelativeDirectionType                        RelativeDirection;                                 // 0x0000(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1[0x7];                                        // 0x0001(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	struct FAttributeInitializationData           ConeAroundDirection;                               // 0x0008(0x0038)(Edit, NoDestructor, NativeAccessSpecifierPublic)
	struct FRotator                               AdditionalRotation;                                // 0x0040(0x000C)(Edit, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
	uint8                                         Pad_4C[0x4];                                       // 0x004C(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FRelativeDirectionData) == 0x000008, "Wrong alignment on FRelativeDirectionData");
static_assert(sizeof(FRelativeDirectionData) == 0x000050, "Wrong size on FRelativeDirectionData");
static_assert(offsetof(FRelativeDirectionData, RelativeDirection) == 0x000000, "Member 'FRelativeDirectionData::RelativeDirection' has a wrong offset!");
static_assert(offsetof(FRelativeDirectionData, ConeAroundDirection) == 0x000008, "Member 'FRelativeDirectionData::ConeAroundDirection' has a wrong offset!");
static_assert(offsetof(FRelativeDirectionData, AdditionalRotation) == 0x000040, "Member 'FRelativeDirectionData::AdditionalRotation' has a wrong offset!");

// ScriptStruct GbxGameSystemCore.CauseDamageAsyncRequestEntry
// 0x00B0 (0x02E0 - 0x0230)
struct FCauseDamageAsyncRequestEntry final : public FCauseDamageAsyncRequest
{
public:
	uint8                                         Pad_230[0x98];                                     // 0x0230(0x0098)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<struct FDamageTargetResult>            Results;                                           // 0x02C8(0x0010)(ZeroConstructor, ContainsInstancedReference, NativeAccessSpecifierPublic)
	uint8                                         Pad_2D8[0x8];                                      // 0x02D8(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FCauseDamageAsyncRequestEntry) == 0x000010, "Wrong alignment on FCauseDamageAsyncRequestEntry");
static_assert(sizeof(FCauseDamageAsyncRequestEntry) == 0x0002E0, "Wrong size on FCauseDamageAsyncRequestEntry");
static_assert(offsetof(FCauseDamageAsyncRequestEntry, Results) == 0x0002C8, "Member 'FCauseDamageAsyncRequestEntry::Results' has a wrong offset!");

// ScriptStruct GbxGameSystemCore.EmitterFloatParam
// 0x0010 (0x0010 - 0x0000)
struct alignas(0x08) FEmitterFloatParam final
{
public:
	class FName                                   Name;                                              // 0x0000(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         Value;                                             // 0x0008(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_C[0x4];                                        // 0x000C(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FEmitterFloatParam) == 0x000008, "Wrong alignment on FEmitterFloatParam");
static_assert(sizeof(FEmitterFloatParam) == 0x000010, "Wrong size on FEmitterFloatParam");
static_assert(offsetof(FEmitterFloatParam, Name) == 0x000000, "Member 'FEmitterFloatParam::Name' has a wrong offset!");
static_assert(offsetof(FEmitterFloatParam, Value) == 0x000008, "Member 'FEmitterFloatParam::Value' has a wrong offset!");

// ScriptStruct GbxGameSystemCore.SyncedHitReactionData
// 0x0040 (0x0040 - 0x0000)
struct FSyncedHitReactionData final
{
public:
	class UHitReactionTag*                        Tag;                                               // 0x0000(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TSubclassOf<class UGbxAction>                 Action;                                            // 0x0008(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TSubclassOf<class UGbxAction>                 CensoredAction;                                    // 0x0010(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         DamageAmount;                                      // 0x0018(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector_NetQuantizeNormal              Direction;                                         // 0x001C(0x000C)(NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         Force;                                             // 0x0028(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         HitBoneIndex;                                      // 0x002C(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector_NetQuantize100                 HitLocation;                                       // 0x0030(0x000C)(NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint32                                        Flags;                                             // 0x003C(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FSyncedHitReactionData) == 0x000008, "Wrong alignment on FSyncedHitReactionData");
static_assert(sizeof(FSyncedHitReactionData) == 0x000040, "Wrong size on FSyncedHitReactionData");
static_assert(offsetof(FSyncedHitReactionData, Tag) == 0x000000, "Member 'FSyncedHitReactionData::Tag' has a wrong offset!");
static_assert(offsetof(FSyncedHitReactionData, Action) == 0x000008, "Member 'FSyncedHitReactionData::Action' has a wrong offset!");
static_assert(offsetof(FSyncedHitReactionData, CensoredAction) == 0x000010, "Member 'FSyncedHitReactionData::CensoredAction' has a wrong offset!");
static_assert(offsetof(FSyncedHitReactionData, DamageAmount) == 0x000018, "Member 'FSyncedHitReactionData::DamageAmount' has a wrong offset!");
static_assert(offsetof(FSyncedHitReactionData, Direction) == 0x00001C, "Member 'FSyncedHitReactionData::Direction' has a wrong offset!");
static_assert(offsetof(FSyncedHitReactionData, Force) == 0x000028, "Member 'FSyncedHitReactionData::Force' has a wrong offset!");
static_assert(offsetof(FSyncedHitReactionData, HitBoneIndex) == 0x00002C, "Member 'FSyncedHitReactionData::HitBoneIndex' has a wrong offset!");
static_assert(offsetof(FSyncedHitReactionData, HitLocation) == 0x000030, "Member 'FSyncedHitReactionData::HitLocation' has a wrong offset!");
static_assert(offsetof(FSyncedHitReactionData, Flags) == 0x00003C, "Member 'FSyncedHitReactionData::Flags' has a wrong offset!");

// ScriptStruct GbxGameSystemCore.OverrideMeleeSocket
// 0x0018 (0x0018 - 0x0000)
struct FOverrideMeleeSocket final
{
public:
	class UGbxCondition*                          OverrideCondition;                                 // 0x0000(0x0008)(Edit, ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, PersistentInstance, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TArray<class FName>                           OverrideSockets;                                   // 0x0008(0x0010)(Edit, ZeroConstructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(FOverrideMeleeSocket) == 0x000008, "Wrong alignment on FOverrideMeleeSocket");
static_assert(sizeof(FOverrideMeleeSocket) == 0x000018, "Wrong size on FOverrideMeleeSocket");
static_assert(offsetof(FOverrideMeleeSocket, OverrideCondition) == 0x000000, "Member 'FOverrideMeleeSocket::OverrideCondition' has a wrong offset!");
static_assert(offsetof(FOverrideMeleeSocket, OverrideSockets) == 0x000008, "Member 'FOverrideMeleeSocket::OverrideSockets' has a wrong offset!");

// ScriptStruct GbxGameSystemCore.SimpleHealthInfo
// 0x0058 (0x0058 - 0x0000)
struct FSimpleHealthInfo final
{
public:
	struct FAttributeInitializationData           MaxHealthFormula;                                  // 0x0000(0x0038)(Edit, RepSkip, NoDestructor, NativeAccessSpecifierPublic)
	class UHealthTypeData*                        HealthType;                                        // 0x0038(0x0008)(Edit, ZeroConstructor, IsPlainOldData, RepSkip, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FGbxAttributeFloat                     MaxHealth;                                         // 0x0040(0x000C)(Transient, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         CurrentHealth;                                     // 0x004C(0x0004)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_50[0x8];                                       // 0x0050(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FSimpleHealthInfo) == 0x000008, "Wrong alignment on FSimpleHealthInfo");
static_assert(sizeof(FSimpleHealthInfo) == 0x000058, "Wrong size on FSimpleHealthInfo");
static_assert(offsetof(FSimpleHealthInfo, MaxHealthFormula) == 0x000000, "Member 'FSimpleHealthInfo::MaxHealthFormula' has a wrong offset!");
static_assert(offsetof(FSimpleHealthInfo, HealthType) == 0x000038, "Member 'FSimpleHealthInfo::HealthType' has a wrong offset!");
static_assert(offsetof(FSimpleHealthInfo, MaxHealth) == 0x000040, "Member 'FSimpleHealthInfo::MaxHealth' has a wrong offset!");
static_assert(offsetof(FSimpleHealthInfo, CurrentHealth) == 0x00004C, "Member 'FSimpleHealthInfo::CurrentHealth' has a wrong offset!");

// ScriptStruct GbxGameSystemCore.DamageLocalizationSettings
// 0x0018 (0x0018 - 0x0000)
struct FDamageLocalizationSettings final
{
public:
	class UTexture2D*                             CriticalTexture;                                   // 0x0000(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UTexture2D*                             ResistTexture;                                     // 0x0008(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UTexture2D*                             ImmuneTexture;                                     // 0x0010(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FDamageLocalizationSettings) == 0x000008, "Wrong alignment on FDamageLocalizationSettings");
static_assert(sizeof(FDamageLocalizationSettings) == 0x000018, "Wrong size on FDamageLocalizationSettings");
static_assert(offsetof(FDamageLocalizationSettings, CriticalTexture) == 0x000000, "Member 'FDamageLocalizationSettings::CriticalTexture' has a wrong offset!");
static_assert(offsetof(FDamageLocalizationSettings, ResistTexture) == 0x000008, "Member 'FDamageLocalizationSettings::ResistTexture' has a wrong offset!");
static_assert(offsetof(FDamageLocalizationSettings, ImmuneTexture) == 0x000010, "Member 'FDamageLocalizationSettings::ImmuneTexture' has a wrong offset!");

// ScriptStruct GbxGameSystemCore.ProtectionTimerSettings
// 0x000C (0x000C - 0x0000)
struct FProtectionTimerSettings final
{
public:
	float                                         TimerDuration;                                     // 0x0000(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         Threshold;                                         // 0x0004(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         MaintainedMaxHealthPct;                            // 0x0008(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FProtectionTimerSettings) == 0x000004, "Wrong alignment on FProtectionTimerSettings");
static_assert(sizeof(FProtectionTimerSettings) == 0x00000C, "Wrong size on FProtectionTimerSettings");
static_assert(offsetof(FProtectionTimerSettings, TimerDuration) == 0x000000, "Member 'FProtectionTimerSettings::TimerDuration' has a wrong offset!");
static_assert(offsetof(FProtectionTimerSettings, Threshold) == 0x000004, "Member 'FProtectionTimerSettings::Threshold' has a wrong offset!");
static_assert(offsetof(FProtectionTimerSettings, MaintainedMaxHealthPct) == 0x000008, "Member 'FProtectionTimerSettings::MaintainedMaxHealthPct' has a wrong offset!");

// ScriptStruct GbxGameSystemCore.DamageModifierAttributeCollection
// 0x0010 (0x0010 - 0x0000)
struct FDamageModifierAttributeCollection final
{
public:
	class UGbxAttributeData*                      InstigatedModifier;                                // 0x0000(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UGbxAttributeData*                      ReceivedModifier;                                  // 0x0008(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
};
static_assert(alignof(FDamageModifierAttributeCollection) == 0x000008, "Wrong alignment on FDamageModifierAttributeCollection");
static_assert(sizeof(FDamageModifierAttributeCollection) == 0x000010, "Wrong size on FDamageModifierAttributeCollection");
static_assert(offsetof(FDamageModifierAttributeCollection, InstigatedModifier) == 0x000000, "Member 'FDamageModifierAttributeCollection::InstigatedModifier' has a wrong offset!");
static_assert(offsetof(FDamageModifierAttributeCollection, ReceivedModifier) == 0x000008, "Member 'FDamageModifierAttributeCollection::ReceivedModifier' has a wrong offset!");

// ScriptStruct GbxGameSystemCore.DamageOverTimeInstance
// 0x0270 (0x0270 - 0x0000)
struct alignas(0x10) FDamageOverTimeInstance final
{
public:
	uint8                                         Pad_0[0x220];                                      // 0x0000(0x0220)(Fixing Size After Last Property [ Dumper-7 ])
	class UDamageData*                            DamageData;                                        // 0x0220(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_228[0x48];                                     // 0x0228(0x0048)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FDamageOverTimeInstance) == 0x000010, "Wrong alignment on FDamageOverTimeInstance");
static_assert(sizeof(FDamageOverTimeInstance) == 0x000270, "Wrong size on FDamageOverTimeInstance");
static_assert(offsetof(FDamageOverTimeInstance, DamageData) == 0x000220, "Member 'FDamageOverTimeInstance::DamageData' has a wrong offset!");

// ScriptStruct GbxGameSystemCore.DynamicPhysicalAnimationTickFunction
// 0x0030 (0x0080 - 0x0050)
struct alignas(0x10) FDynamicPhysicalAnimationTickFunction final : public FTickFunction
{
public:
	uint8                                         Pad_50[0x30];                                      // 0x0050(0x0030)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FDynamicPhysicalAnimationTickFunction) == 0x000010, "Wrong alignment on FDynamicPhysicalAnimationTickFunction");
static_assert(sizeof(FDynamicPhysicalAnimationTickFunction) == 0x000080, "Wrong size on FDynamicPhysicalAnimationTickFunction");

// ScriptStruct GbxGameSystemCore.DamageTypeExplosionAssociation
// 0x0010 (0x0010 - 0x0000)
struct FDamageTypeExplosionAssociation final
{
public:
	TSubclassOf<class UDamageType>                DamageType;                                        // 0x0000(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UExplosionSizeSelectionData*            ExplosionSizeData;                                 // 0x0008(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FDamageTypeExplosionAssociation) == 0x000008, "Wrong alignment on FDamageTypeExplosionAssociation");
static_assert(sizeof(FDamageTypeExplosionAssociation) == 0x000010, "Wrong size on FDamageTypeExplosionAssociation");
static_assert(offsetof(FDamageTypeExplosionAssociation, DamageType) == 0x000000, "Member 'FDamageTypeExplosionAssociation::DamageType' has a wrong offset!");
static_assert(offsetof(FDamageTypeExplosionAssociation, ExplosionSizeData) == 0x000008, "Member 'FDamageTypeExplosionAssociation::ExplosionSizeData' has a wrong offset!");

// ScriptStruct GbxGameSystemCore.LoopingShakeInfo
// 0x0038 (0x0038 - 0x0000)
struct FLoopingShakeInfo final
{
public:
	class APlayerController*                      AssociatedController;                              // 0x0000(0x0008)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         Scale;                                             // 0x0008(0x0004)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_C[0x4];                                        // 0x000C(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class UObject*                                ContextObject;                                     // 0x0010(0x0008)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FTimerHandle                           TimerHandle;                                       // 0x0018(0x0008)(Transient, NoDestructor, NativeAccessSpecifierPublic)
	struct FVector                                FeedbackLocation;                                  // 0x0020(0x000C)(Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2C[0xC];                                       // 0x002C(0x000C)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FLoopingShakeInfo) == 0x000008, "Wrong alignment on FLoopingShakeInfo");
static_assert(sizeof(FLoopingShakeInfo) == 0x000038, "Wrong size on FLoopingShakeInfo");
static_assert(offsetof(FLoopingShakeInfo, AssociatedController) == 0x000000, "Member 'FLoopingShakeInfo::AssociatedController' has a wrong offset!");
static_assert(offsetof(FLoopingShakeInfo, Scale) == 0x000008, "Member 'FLoopingShakeInfo::Scale' has a wrong offset!");
static_assert(offsetof(FLoopingShakeInfo, ContextObject) == 0x000010, "Member 'FLoopingShakeInfo::ContextObject' has a wrong offset!");
static_assert(offsetof(FLoopingShakeInfo, TimerHandle) == 0x000018, "Member 'FLoopingShakeInfo::TimerHandle' has a wrong offset!");
static_assert(offsetof(FLoopingShakeInfo, FeedbackLocation) == 0x000020, "Member 'FLoopingShakeInfo::FeedbackLocation' has a wrong offset!");

// ScriptStruct GbxGameSystemCore.ShakeScaleAssociation
// 0x0170 (0x0170 - 0x0000)
struct FShakeScaleAssociation final
{
public:
	TSubclassOf<class UCameraShake>               CameraShake;                                       // 0x0000(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FAttributeInitializationData           BaseScale;                                         // 0x0008(0x0038)(Edit, NoDestructor, NativeAccessSpecifierPublic)
	bool                                          bContinuous;                                       // 0x0040(0x0001)(Edit, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bScaleDownOverTime;                                // 0x0041(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bUseScaleOverTimeCurve;                            // 0x0042(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_43[0x5];                                       // 0x0043(0x0005)(Fixing Size After Last Property [ Dumper-7 ])
	struct FRuntimeFloatCurve                     ScaleOverTimeCurve;                                // 0x0048(0x0078)(Edit, NativeAccessSpecifierPublic)
	struct FAttributeInitializationData           ContinuousScale;                                   // 0x00C0(0x0038)(Edit, NoDestructor, NativeAccessSpecifierPublic)
	struct FRuntimeFloatCurve                     ContinuousScaleCurve;                              // 0x00F8(0x0078)(Edit, NativeAccessSpecifierPublic)
};
static_assert(alignof(FShakeScaleAssociation) == 0x000008, "Wrong alignment on FShakeScaleAssociation");
static_assert(sizeof(FShakeScaleAssociation) == 0x000170, "Wrong size on FShakeScaleAssociation");
static_assert(offsetof(FShakeScaleAssociation, CameraShake) == 0x000000, "Member 'FShakeScaleAssociation::CameraShake' has a wrong offset!");
static_assert(offsetof(FShakeScaleAssociation, BaseScale) == 0x000008, "Member 'FShakeScaleAssociation::BaseScale' has a wrong offset!");
static_assert(offsetof(FShakeScaleAssociation, bContinuous) == 0x000040, "Member 'FShakeScaleAssociation::bContinuous' has a wrong offset!");
static_assert(offsetof(FShakeScaleAssociation, bScaleDownOverTime) == 0x000041, "Member 'FShakeScaleAssociation::bScaleDownOverTime' has a wrong offset!");
static_assert(offsetof(FShakeScaleAssociation, bUseScaleOverTimeCurve) == 0x000042, "Member 'FShakeScaleAssociation::bUseScaleOverTimeCurve' has a wrong offset!");
static_assert(offsetof(FShakeScaleAssociation, ScaleOverTimeCurve) == 0x000048, "Member 'FShakeScaleAssociation::ScaleOverTimeCurve' has a wrong offset!");
static_assert(offsetof(FShakeScaleAssociation, ContinuousScale) == 0x0000C0, "Member 'FShakeScaleAssociation::ContinuousScale' has a wrong offset!");
static_assert(offsetof(FShakeScaleAssociation, ContinuousScaleCurve) == 0x0000F8, "Member 'FShakeScaleAssociation::ContinuousScaleCurve' has a wrong offset!");

// ScriptStruct GbxGameSystemCore.HapticFeedbackData
// 0x0010 (0x0010 - 0x0000)
struct FHapticFeedbackData final
{
public:
	class UHapticFeedbackEffect_Curve*            HapticFeedbackEffect;                              // 0x0000(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EControllerHand                               Hand;                                              // 0x0008(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_9[0x7];                                        // 0x0009(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FHapticFeedbackData) == 0x000008, "Wrong alignment on FHapticFeedbackData");
static_assert(sizeof(FHapticFeedbackData) == 0x000010, "Wrong size on FHapticFeedbackData");
static_assert(offsetof(FHapticFeedbackData, HapticFeedbackEffect) == 0x000000, "Member 'FHapticFeedbackData::HapticFeedbackEffect' has a wrong offset!");
static_assert(offsetof(FHapticFeedbackData, Hand) == 0x000008, "Member 'FHapticFeedbackData::Hand' has a wrong offset!");

// ScriptStruct GbxGameSystemCore.FeedbackTableRowHandle
// 0x0000 (0x0010 - 0x0010)
struct FFeedbackTableRowHandle final : public FDataTableRowHandle
{
};
static_assert(alignof(FFeedbackTableRowHandle) == 0x000008, "Wrong alignment on FFeedbackTableRowHandle");
static_assert(sizeof(FFeedbackTableRowHandle) == 0x000010, "Wrong size on FFeedbackTableRowHandle");

// ScriptStruct GbxGameSystemCore.FeedbackAssociationRow
// 0x0008 (0x0010 - 0x0008)
struct FFeedbackAssociationRow final : public FTableRowBase
{
public:
	class UFeedbackData*                          Feedback;                                          // 0x0008(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FFeedbackAssociationRow) == 0x000008, "Wrong alignment on FFeedbackAssociationRow");
static_assert(sizeof(FFeedbackAssociationRow) == 0x000010, "Wrong size on FFeedbackAssociationRow");
static_assert(offsetof(FFeedbackAssociationRow, Feedback) == 0x000008, "Member 'FFeedbackAssociationRow::Feedback' has a wrong offset!");

// ScriptStruct GbxGameSystemCore.TrackedFirstPersonComponent
// 0x0040 (0x0040 - 0x0000)
struct alignas(0x10) FTrackedFirstPersonComponent final
{
public:
	class USceneComponent*                        Component;                                         // 0x0000(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_8[0x38];                                       // 0x0008(0x0038)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FTrackedFirstPersonComponent) == 0x000010, "Wrong alignment on FTrackedFirstPersonComponent");
static_assert(sizeof(FTrackedFirstPersonComponent) == 0x000040, "Wrong size on FTrackedFirstPersonComponent");
static_assert(offsetof(FTrackedFirstPersonComponent, Component) == 0x000000, "Member 'FTrackedFirstPersonComponent::Component' has a wrong offset!");

// ScriptStruct GbxGameSystemCore.GameplayTagToValueMap
// 0x0040 (0x0040 - 0x0000)
struct FGameplayTagToValueMap final
{
public:
	struct FGameplayTag                           Tag;                                               // 0x0000(0x0008)(Edit, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FAttributeInitializationData           ValueIfContextHasTag;                              // 0x0008(0x0038)(Edit, NoDestructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(FGameplayTagToValueMap) == 0x000008, "Wrong alignment on FGameplayTagToValueMap");
static_assert(sizeof(FGameplayTagToValueMap) == 0x000040, "Wrong size on FGameplayTagToValueMap");
static_assert(offsetof(FGameplayTagToValueMap, Tag) == 0x000000, "Member 'FGameplayTagToValueMap::Tag' has a wrong offset!");
static_assert(offsetof(FGameplayTagToValueMap, ValueIfContextHasTag) == 0x000008, "Member 'FGameplayTagToValueMap::ValueIfContextHasTag' has a wrong offset!");

// ScriptStruct GbxGameSystemCore.GameResourcePool
// 0x00F8 (0x00F8 - 0x0000)
struct FGameResourcePool final
{
public:
	uint8                                         Pad_0[0x8];                                        // 0x0000(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	class UGameResourcePoolData*                  ResourcePoolData;                                  // 0x0008(0x0008)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FGbxAttributeFloat                     MinValue;                                          // 0x0010(0x000C)(Transient, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FGbxAttributeFloat                     MaxValue;                                          // 0x001C(0x000C)(Transient, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FGbxAttributeFloat                     PercentOfMaxValueReserved;                         // 0x0028(0x000C)(Transient, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FGbxAttributeFloat                     ConsumptionRate;                                   // 0x0034(0x000C)(Transient, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FGbxAttributeFloat                     ActiveRegenerationRate;                            // 0x0040(0x000C)(Transient, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FGbxAttributeFloat                     OnIdleRegenerationRate;                            // 0x004C(0x000C)(Transient, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FGbxAttributeFloat                     OnIdleRegenerationDelay;                           // 0x0058(0x000C)(Transient, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FGbxAttributeFloat                     OnDepletedIdleRegenerationDelay;                   // 0x0064(0x000C)(Transient, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FGbxAttributeFloat                     PassiveRegenerationRate;                           // 0x0070(0x000C)(Transient, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FGbxAttributeFloat                     PassivePercentRegenerationRate;                    // 0x007C(0x000C)(Transient, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FGbxAttributeFloat                     PassiveMissingPercentRegenerationRate;             // 0x0088(0x000C)(Transient, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FGbxAttributeInteger                   RegenerationDisabled;                              // 0x0094(0x000C)(Transient, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         CurrentValue;                                      // 0x00A0(0x0004)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         LastTotalRegenerationRateValue;                    // 0x00A4(0x0004)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         LastTotalPercentRegenerationRateValue;             // 0x00A8(0x0004)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         LastEffectiveMaxValue;                             // 0x00AC(0x0004)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	struct FGbxAttributeFloat                     PostAddedRegenerationRate;                         // 0x00B0(0x000C)(Transient, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	struct FGbxAttributeFloat                     PostAddedPercentRegenerationRate;                  // 0x00BC(0x000C)(Transient, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_C8[0x30];                                      // 0x00C8(0x0030)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FGameResourcePool) == 0x000008, "Wrong alignment on FGameResourcePool");
static_assert(sizeof(FGameResourcePool) == 0x0000F8, "Wrong size on FGameResourcePool");
static_assert(offsetof(FGameResourcePool, ResourcePoolData) == 0x000008, "Member 'FGameResourcePool::ResourcePoolData' has a wrong offset!");
static_assert(offsetof(FGameResourcePool, MinValue) == 0x000010, "Member 'FGameResourcePool::MinValue' has a wrong offset!");
static_assert(offsetof(FGameResourcePool, MaxValue) == 0x00001C, "Member 'FGameResourcePool::MaxValue' has a wrong offset!");
static_assert(offsetof(FGameResourcePool, PercentOfMaxValueReserved) == 0x000028, "Member 'FGameResourcePool::PercentOfMaxValueReserved' has a wrong offset!");
static_assert(offsetof(FGameResourcePool, ConsumptionRate) == 0x000034, "Member 'FGameResourcePool::ConsumptionRate' has a wrong offset!");
static_assert(offsetof(FGameResourcePool, ActiveRegenerationRate) == 0x000040, "Member 'FGameResourcePool::ActiveRegenerationRate' has a wrong offset!");
static_assert(offsetof(FGameResourcePool, OnIdleRegenerationRate) == 0x00004C, "Member 'FGameResourcePool::OnIdleRegenerationRate' has a wrong offset!");
static_assert(offsetof(FGameResourcePool, OnIdleRegenerationDelay) == 0x000058, "Member 'FGameResourcePool::OnIdleRegenerationDelay' has a wrong offset!");
static_assert(offsetof(FGameResourcePool, OnDepletedIdleRegenerationDelay) == 0x000064, "Member 'FGameResourcePool::OnDepletedIdleRegenerationDelay' has a wrong offset!");
static_assert(offsetof(FGameResourcePool, PassiveRegenerationRate) == 0x000070, "Member 'FGameResourcePool::PassiveRegenerationRate' has a wrong offset!");
static_assert(offsetof(FGameResourcePool, PassivePercentRegenerationRate) == 0x00007C, "Member 'FGameResourcePool::PassivePercentRegenerationRate' has a wrong offset!");
static_assert(offsetof(FGameResourcePool, PassiveMissingPercentRegenerationRate) == 0x000088, "Member 'FGameResourcePool::PassiveMissingPercentRegenerationRate' has a wrong offset!");
static_assert(offsetof(FGameResourcePool, RegenerationDisabled) == 0x000094, "Member 'FGameResourcePool::RegenerationDisabled' has a wrong offset!");
static_assert(offsetof(FGameResourcePool, CurrentValue) == 0x0000A0, "Member 'FGameResourcePool::CurrentValue' has a wrong offset!");
static_assert(offsetof(FGameResourcePool, LastTotalRegenerationRateValue) == 0x0000A4, "Member 'FGameResourcePool::LastTotalRegenerationRateValue' has a wrong offset!");
static_assert(offsetof(FGameResourcePool, LastTotalPercentRegenerationRateValue) == 0x0000A8, "Member 'FGameResourcePool::LastTotalPercentRegenerationRateValue' has a wrong offset!");
static_assert(offsetof(FGameResourcePool, LastEffectiveMaxValue) == 0x0000AC, "Member 'FGameResourcePool::LastEffectiveMaxValue' has a wrong offset!");
static_assert(offsetof(FGameResourcePool, PostAddedRegenerationRate) == 0x0000B0, "Member 'FGameResourcePool::PostAddedRegenerationRate' has a wrong offset!");
static_assert(offsetof(FGameResourcePool, PostAddedPercentRegenerationRate) == 0x0000BC, "Member 'FGameResourcePool::PostAddedPercentRegenerationRate' has a wrong offset!");

// ScriptStruct GbxGameSystemCore.HitRegionHealthParams
// 0x0018 (0x0018 - 0x0000)
struct FHitRegionHealthParams final
{
public:
	float                                         OwnerHealthPercent;                                // 0x0000(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_4[0x4];                                        // 0x0004(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class UGameResourcePoolData*                  ResourcePool;                                      // 0x0008(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EHitRegionDamageRule                          DamageRule;                                        // 0x0010(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_11[0x7];                                       // 0x0011(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FHitRegionHealthParams) == 0x000008, "Wrong alignment on FHitRegionHealthParams");
static_assert(sizeof(FHitRegionHealthParams) == 0x000018, "Wrong size on FHitRegionHealthParams");
static_assert(offsetof(FHitRegionHealthParams, OwnerHealthPercent) == 0x000000, "Member 'FHitRegionHealthParams::OwnerHealthPercent' has a wrong offset!");
static_assert(offsetof(FHitRegionHealthParams, ResourcePool) == 0x000008, "Member 'FHitRegionHealthParams::ResourcePool' has a wrong offset!");
static_assert(offsetof(FHitRegionHealthParams, DamageRule) == 0x000010, "Member 'FHitRegionHealthParams::DamageRule' has a wrong offset!");

// ScriptStruct GbxGameSystemCore.GameResourceUserEvent
// 0x0098 (0x0098 - 0x0000)
struct FGameResourceUserEvent final
{
public:
	class UGameResourceData*                      ResourceData;                                      // 0x0000(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	UMulticastDelegateProperty_                   OnResourceNowDepleted;                             // 0x0008(0x0010)(Edit, ZeroConstructor, DisableEditOnTemplate, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	UMulticastDelegateProperty_                   OnResourceNowNotDepleted;                          // 0x0018(0x0010)(Edit, ZeroConstructor, DisableEditOnTemplate, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	UMulticastDelegateProperty_                   OnResourceNowFilled;                               // 0x0028(0x0010)(Edit, ZeroConstructor, DisableEditOnTemplate, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	UMulticastDelegateProperty_                   OnResourceNowNotFilled;                            // 0x0038(0x0010)(Edit, ZeroConstructor, DisableEditOnTemplate, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	UMulticastDelegateProperty_                   OnResourceNowRegenerating;                         // 0x0048(0x0010)(Edit, ZeroConstructor, DisableEditOnTemplate, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	UMulticastDelegateProperty_                   OnResourceNowNotRegenerating;                      // 0x0058(0x0010)(Edit, ZeroConstructor, DisableEditOnTemplate, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	UMulticastDelegateProperty_                   OnResourceNowDepleting;                            // 0x0068(0x0010)(Edit, ZeroConstructor, DisableEditOnTemplate, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	UMulticastDelegateProperty_                   OnResourceNowNotDepleting;                         // 0x0078(0x0010)(Edit, ZeroConstructor, DisableEditOnTemplate, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	UMulticastDelegateProperty_                   OnResourceNowIdle;                                 // 0x0088(0x0010)(Edit, ZeroConstructor, DisableEditOnTemplate, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
};
static_assert(alignof(FGameResourceUserEvent) == 0x000008, "Wrong alignment on FGameResourceUserEvent");
static_assert(sizeof(FGameResourceUserEvent) == 0x000098, "Wrong size on FGameResourceUserEvent");
static_assert(offsetof(FGameResourceUserEvent, ResourceData) == 0x000000, "Member 'FGameResourceUserEvent::ResourceData' has a wrong offset!");
static_assert(offsetof(FGameResourceUserEvent, OnResourceNowDepleted) == 0x000008, "Member 'FGameResourceUserEvent::OnResourceNowDepleted' has a wrong offset!");
static_assert(offsetof(FGameResourceUserEvent, OnResourceNowNotDepleted) == 0x000018, "Member 'FGameResourceUserEvent::OnResourceNowNotDepleted' has a wrong offset!");
static_assert(offsetof(FGameResourceUserEvent, OnResourceNowFilled) == 0x000028, "Member 'FGameResourceUserEvent::OnResourceNowFilled' has a wrong offset!");
static_assert(offsetof(FGameResourceUserEvent, OnResourceNowNotFilled) == 0x000038, "Member 'FGameResourceUserEvent::OnResourceNowNotFilled' has a wrong offset!");
static_assert(offsetof(FGameResourceUserEvent, OnResourceNowRegenerating) == 0x000048, "Member 'FGameResourceUserEvent::OnResourceNowRegenerating' has a wrong offset!");
static_assert(offsetof(FGameResourceUserEvent, OnResourceNowNotRegenerating) == 0x000058, "Member 'FGameResourceUserEvent::OnResourceNowNotRegenerating' has a wrong offset!");
static_assert(offsetof(FGameResourceUserEvent, OnResourceNowDepleting) == 0x000068, "Member 'FGameResourceUserEvent::OnResourceNowDepleting' has a wrong offset!");
static_assert(offsetof(FGameResourceUserEvent, OnResourceNowNotDepleting) == 0x000078, "Member 'FGameResourceUserEvent::OnResourceNowNotDepleting' has a wrong offset!");
static_assert(offsetof(FGameResourceUserEvent, OnResourceNowIdle) == 0x000088, "Member 'FGameResourceUserEvent::OnResourceNowIdle' has a wrong offset!");

// ScriptStruct GbxGameSystemCore.GameResourcePoolNet
// 0x0010 (0x0010 - 0x0000)
struct FGameResourcePoolNet final
{
public:
	class UGameResourcePoolManagerComponent*      Manager;                                           // 0x0000(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_8[0x8];                                        // 0x0008(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FGameResourcePoolNet) == 0x000008, "Wrong alignment on FGameResourcePoolNet");
static_assert(sizeof(FGameResourcePoolNet) == 0x000010, "Wrong size on FGameResourcePoolNet");
static_assert(offsetof(FGameResourcePoolNet, Manager) == 0x000000, "Member 'FGameResourcePoolNet::Manager' has a wrong offset!");

// ScriptStruct GbxGameSystemCore.GameStat
// 0x0010 (0x0010 - 0x0000)
struct FGameStat final
{
public:
	class UGameStatData*                          GameStat;                                          // 0x0000(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         StatValue;                                         // 0x0008(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_C[0x4];                                        // 0x000C(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FGameStat) == 0x000008, "Wrong alignment on FGameStat");
static_assert(sizeof(FGameStat) == 0x000010, "Wrong size on FGameStat");
static_assert(offsetof(FGameStat, GameStat) == 0x000000, "Member 'FGameStat::GameStat' has a wrong offset!");
static_assert(offsetof(FGameStat, StatValue) == 0x000008, "Member 'FGameStat::StatValue' has a wrong offset!");

// ScriptStruct GbxGameSystemCore.PawnSceneAttachmentInfo
// 0x0028 (0x0028 - 0x0000)
struct alignas(0x08) FPawnSceneAttachmentInfo final
{
public:
	bool                                          bAttachToBaseOwner;                                // 0x0000(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bMaintainWorldLocation;                            // 0x0001(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bApplyMeshOffset;                                  // 0x0002(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_3[0x5];                                        // 0x0003(0x0005)(Fixing Size After Last Property [ Dumper-7 ])
	class FName                                   SocketName;                                        // 0x0008(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                AttachOffset;                                      // 0x0010(0x000C)(Edit, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bAddOffsetFromSocket;                              // 0x001C(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1D[0x3];                                       // 0x001D(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	class FName                                   SocketNameForAdditionalOffset;                     // 0x0020(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FPawnSceneAttachmentInfo) == 0x000008, "Wrong alignment on FPawnSceneAttachmentInfo");
static_assert(sizeof(FPawnSceneAttachmentInfo) == 0x000028, "Wrong size on FPawnSceneAttachmentInfo");
static_assert(offsetof(FPawnSceneAttachmentInfo, bAttachToBaseOwner) == 0x000000, "Member 'FPawnSceneAttachmentInfo::bAttachToBaseOwner' has a wrong offset!");
static_assert(offsetof(FPawnSceneAttachmentInfo, bMaintainWorldLocation) == 0x000001, "Member 'FPawnSceneAttachmentInfo::bMaintainWorldLocation' has a wrong offset!");
static_assert(offsetof(FPawnSceneAttachmentInfo, bApplyMeshOffset) == 0x000002, "Member 'FPawnSceneAttachmentInfo::bApplyMeshOffset' has a wrong offset!");
static_assert(offsetof(FPawnSceneAttachmentInfo, SocketName) == 0x000008, "Member 'FPawnSceneAttachmentInfo::SocketName' has a wrong offset!");
static_assert(offsetof(FPawnSceneAttachmentInfo, AttachOffset) == 0x000010, "Member 'FPawnSceneAttachmentInfo::AttachOffset' has a wrong offset!");
static_assert(offsetof(FPawnSceneAttachmentInfo, bAddOffsetFromSocket) == 0x00001C, "Member 'FPawnSceneAttachmentInfo::bAddOffsetFromSocket' has a wrong offset!");
static_assert(offsetof(FPawnSceneAttachmentInfo, SocketNameForAdditionalOffset) == 0x000020, "Member 'FPawnSceneAttachmentInfo::SocketNameForAdditionalOffset' has a wrong offset!");

// ScriptStruct GbxGameSystemCore.PawnAttachmentTransition
// 0x0048 (0x0048 - 0x0000)
struct FPawnAttachmentTransition
{
public:
	TSubclassOf<class UGbxAction>                 BaseAction;                                        // 0x0000(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TSubclassOf<class UGbxAction>                 PawnAction;                                        // 0x0008(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bForceStopTransitionActions;                       // 0x0010(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EAttachmentTransitionTiming                   AttachTiming;                                      // 0x0011(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bOverrideAttachInfo;                               // 0x0012(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_13[0x5];                                       // 0x0013(0x0005)(Fixing Size After Last Property [ Dumper-7 ])
	struct FPawnSceneAttachmentInfo               AttachInfo;                                        // 0x0018(0x0028)(Edit, NoDestructor, NativeAccessSpecifierPublic)
	class UGbxCondition*                          Conditions;                                        // 0x0040(0x0008)(Edit, ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, PersistentInstance, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FPawnAttachmentTransition) == 0x000008, "Wrong alignment on FPawnAttachmentTransition");
static_assert(sizeof(FPawnAttachmentTransition) == 0x000048, "Wrong size on FPawnAttachmentTransition");
static_assert(offsetof(FPawnAttachmentTransition, BaseAction) == 0x000000, "Member 'FPawnAttachmentTransition::BaseAction' has a wrong offset!");
static_assert(offsetof(FPawnAttachmentTransition, PawnAction) == 0x000008, "Member 'FPawnAttachmentTransition::PawnAction' has a wrong offset!");
static_assert(offsetof(FPawnAttachmentTransition, bForceStopTransitionActions) == 0x000010, "Member 'FPawnAttachmentTransition::bForceStopTransitionActions' has a wrong offset!");
static_assert(offsetof(FPawnAttachmentTransition, AttachTiming) == 0x000011, "Member 'FPawnAttachmentTransition::AttachTiming' has a wrong offset!");
static_assert(offsetof(FPawnAttachmentTransition, bOverrideAttachInfo) == 0x000012, "Member 'FPawnAttachmentTransition::bOverrideAttachInfo' has a wrong offset!");
static_assert(offsetof(FPawnAttachmentTransition, AttachInfo) == 0x000018, "Member 'FPawnAttachmentTransition::AttachInfo' has a wrong offset!");
static_assert(offsetof(FPawnAttachmentTransition, Conditions) == 0x000040, "Member 'FPawnAttachmentTransition::Conditions' has a wrong offset!");

// ScriptStruct GbxGameSystemCore.QueuedGameStatEvent
// 0x0018 (0x0018 - 0x0000)
struct FQueuedGameStatEvent final
{
public:
	TWeakObjectPtr<class AActor>                  StatContext;                                       // 0x0000(0x0008)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TWeakObjectPtr<class UGameStatData>           GameStat;                                          // 0x0008(0x0008)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_10[0x8];                                       // 0x0010(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FQueuedGameStatEvent) == 0x000004, "Wrong alignment on FQueuedGameStatEvent");
static_assert(sizeof(FQueuedGameStatEvent) == 0x000018, "Wrong size on FQueuedGameStatEvent");
static_assert(offsetof(FQueuedGameStatEvent, StatContext) == 0x000000, "Member 'FQueuedGameStatEvent::StatContext' has a wrong offset!");
static_assert(offsetof(FQueuedGameStatEvent, GameStat) == 0x000008, "Member 'FQueuedGameStatEvent::GameStat' has a wrong offset!");

// ScriptStruct GbxGameSystemCore.CustomizationInheritedTextureBaseMaterial
// 0x0018 (0x0018 - 0x0000)
struct FCustomizationInheritedTextureBaseMaterial final
{
public:
	class UGbxCustomizationTargetData*            Target;                                            // 0x0000(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         MaterialIndex;                                     // 0x0008(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_C[0x4];                                        // 0x000C(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class UMaterialInterface*                     BaseMaterial;                                      // 0x0010(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FCustomizationInheritedTextureBaseMaterial) == 0x000008, "Wrong alignment on FCustomizationInheritedTextureBaseMaterial");
static_assert(sizeof(FCustomizationInheritedTextureBaseMaterial) == 0x000018, "Wrong size on FCustomizationInheritedTextureBaseMaterial");
static_assert(offsetof(FCustomizationInheritedTextureBaseMaterial, Target) == 0x000000, "Member 'FCustomizationInheritedTextureBaseMaterial::Target' has a wrong offset!");
static_assert(offsetof(FCustomizationInheritedTextureBaseMaterial, MaterialIndex) == 0x000008, "Member 'FCustomizationInheritedTextureBaseMaterial::MaterialIndex' has a wrong offset!");
static_assert(offsetof(FCustomizationInheritedTextureBaseMaterial, BaseMaterial) == 0x000010, "Member 'FCustomizationInheritedTextureBaseMaterial::BaseMaterial' has a wrong offset!");

// ScriptStruct GbxGameSystemCore.InheritedCustomizationTextureExtraParam
// 0x0018 (0x0018 - 0x0000)
struct FInheritedCustomizationTextureExtraParam final
{
public:
	class UGbxCustomizationTargetData*            Target;                                            // 0x0000(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   ParamName;                                         // 0x0008(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UTexture*                               Texture;                                           // 0x0010(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FInheritedCustomizationTextureExtraParam) == 0x000008, "Wrong alignment on FInheritedCustomizationTextureExtraParam");
static_assert(sizeof(FInheritedCustomizationTextureExtraParam) == 0x000018, "Wrong size on FInheritedCustomizationTextureExtraParam");
static_assert(offsetof(FInheritedCustomizationTextureExtraParam, Target) == 0x000000, "Member 'FInheritedCustomizationTextureExtraParam::Target' has a wrong offset!");
static_assert(offsetof(FInheritedCustomizationTextureExtraParam, ParamName) == 0x000008, "Member 'FInheritedCustomizationTextureExtraParam::ParamName' has a wrong offset!");
static_assert(offsetof(FInheritedCustomizationTextureExtraParam, Texture) == 0x000010, "Member 'FInheritedCustomizationTextureExtraParam::Texture' has a wrong offset!");

// ScriptStruct GbxGameSystemCore.CustomizationTextureInheritanceSettings
// 0x0038 (0x0038 - 0x0000)
struct FCustomizationTextureInheritanceSettings final
{
public:
	TArray<class FName>                           OnlyInheritCustomizationTextureParameters;         // 0x0000(0x0010)(Edit, ZeroConstructor, NativeAccessSpecifierPublic)
	class UMaterialInterface*                     BaseMaterial;                                      // 0x0010(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TArray<struct FCustomizationInheritedTextureBaseMaterial> CustomizationTargetSpecificBaseMaterials;          // 0x0018(0x0010)(Edit, ZeroConstructor, NativeAccessSpecifierPublic)
	TArray<struct FInheritedCustomizationTextureExtraParam> ExtraParams;                                       // 0x0028(0x0010)(Edit, ZeroConstructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(FCustomizationTextureInheritanceSettings) == 0x000008, "Wrong alignment on FCustomizationTextureInheritanceSettings");
static_assert(sizeof(FCustomizationTextureInheritanceSettings) == 0x000038, "Wrong size on FCustomizationTextureInheritanceSettings");
static_assert(offsetof(FCustomizationTextureInheritanceSettings, OnlyInheritCustomizationTextureParameters) == 0x000000, "Member 'FCustomizationTextureInheritanceSettings::OnlyInheritCustomizationTextureParameters' has a wrong offset!");
static_assert(offsetof(FCustomizationTextureInheritanceSettings, BaseMaterial) == 0x000010, "Member 'FCustomizationTextureInheritanceSettings::BaseMaterial' has a wrong offset!");
static_assert(offsetof(FCustomizationTextureInheritanceSettings, CustomizationTargetSpecificBaseMaterials) == 0x000018, "Member 'FCustomizationTextureInheritanceSettings::CustomizationTargetSpecificBaseMaterials' has a wrong offset!");
static_assert(offsetof(FCustomizationTextureInheritanceSettings, ExtraParams) == 0x000028, "Member 'FCustomizationTextureInheritanceSettings::ExtraParams' has a wrong offset!");

// ScriptStruct GbxGameSystemCore.ActionState_AICharge
// 0x0020 (0x0488 - 0x0468)
struct FActionState_AICharge final : public FActionState_SimpleAnim
{
public:
	uint8                                         Pad_468[0x20];                                     // 0x0468(0x0020)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FActionState_AICharge) == 0x000008, "Wrong alignment on FActionState_AICharge");
static_assert(sizeof(FActionState_AICharge) == 0x000488, "Wrong size on FActionState_AICharge");

// ScriptStruct GbxGameSystemCore.ImpactEffectEventInfo
// 0x0028 (0x0028 - 0x0000)
struct FImpactEffectEventInfo final
{
public:
	class AActor*                                 InstigatorActor;                                   // 0x0000(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class AActor*                                 HitActor;                                          // 0x0008(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UPhysicalMaterial*                      HitMaterial;                                       // 0x0010(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_18[0x10];                                      // 0x0018(0x0010)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FImpactEffectEventInfo) == 0x000008, "Wrong alignment on FImpactEffectEventInfo");
static_assert(sizeof(FImpactEffectEventInfo) == 0x000028, "Wrong size on FImpactEffectEventInfo");
static_assert(offsetof(FImpactEffectEventInfo, InstigatorActor) == 0x000000, "Member 'FImpactEffectEventInfo::InstigatorActor' has a wrong offset!");
static_assert(offsetof(FImpactEffectEventInfo, HitActor) == 0x000008, "Member 'FImpactEffectEventInfo::HitActor' has a wrong offset!");
static_assert(offsetof(FImpactEffectEventInfo, HitMaterial) == 0x000010, "Member 'FImpactEffectEventInfo::HitMaterial' has a wrong offset!");

// ScriptStruct GbxGameSystemCore.ExtraAnimationSettings
// 0x0030 (0x0030 - 0x0000)
struct FExtraAnimationSettings final
{
public:
	class FName                                   SkeletalMeshComponentName;                         // 0x0000(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FAnimActionDef                         AnimDef;                                           // 0x0008(0x0018)(Edit, NoDestructor, NativeAccessSpecifierPublic)
	class FName                                   AnimSlotOverride;                                  // 0x0020(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bHasAnimSlotOverride;                              // 0x0028(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_29[0x7];                                       // 0x0029(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FExtraAnimationSettings) == 0x000008, "Wrong alignment on FExtraAnimationSettings");
static_assert(sizeof(FExtraAnimationSettings) == 0x000030, "Wrong size on FExtraAnimationSettings");
static_assert(offsetof(FExtraAnimationSettings, SkeletalMeshComponentName) == 0x000000, "Member 'FExtraAnimationSettings::SkeletalMeshComponentName' has a wrong offset!");
static_assert(offsetof(FExtraAnimationSettings, AnimDef) == 0x000008, "Member 'FExtraAnimationSettings::AnimDef' has a wrong offset!");
static_assert(offsetof(FExtraAnimationSettings, AnimSlotOverride) == 0x000020, "Member 'FExtraAnimationSettings::AnimSlotOverride' has a wrong offset!");
static_assert(offsetof(FExtraAnimationSettings, bHasAnimSlotOverride) == 0x000028, "Member 'FExtraAnimationSettings::bHasAnimSlotOverride' has a wrong offset!");

// ScriptStruct GbxGameSystemCore.ActionState_BlueprintBase
// 0x0000 (0x00C8 - 0x00C8)
struct FActionState_BlueprintBase final : public FActionState_Base
{
};
static_assert(alignof(FActionState_BlueprintBase) == 0x000008, "Wrong alignment on FActionState_BlueprintBase");
static_assert(sizeof(FActionState_BlueprintBase) == 0x0000C8, "Wrong size on FActionState_BlueprintBase");

// ScriptStruct GbxGameSystemCore.CoordinatedAppliedMesh
// 0x0010 (0x0010 - 0x0000)
struct alignas(0x08) FCoordinatedAppliedMesh final
{
public:
	uint8                                         Pad_0[0x10];                                       // 0x0000(0x0010)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FCoordinatedAppliedMesh) == 0x000008, "Wrong alignment on FCoordinatedAppliedMesh");
static_assert(sizeof(FCoordinatedAppliedMesh) == 0x000010, "Wrong size on FCoordinatedAppliedMesh");

// ScriptStruct GbxGameSystemCore.CoordinatedConditionalMaterialData
// 0x0030 (0x0030 - 0x0000)
struct FCoordinatedConditionalMaterialData final
{
public:
	class UMaterial*                              BaseMaterial;                                      // 0x0000(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         MeshElementIndex;                                  // 0x0008(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_C[0x4];                                        // 0x000C(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class UMaterialInterface*                     OverrideMaterial;                                  // 0x0010(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         bMatchMaterialStaticParameters : 1;                // 0x0018(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (Edit, DisableEditOnInstance, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         bUseGlobalInheritedMaterialParameters : 1;         // 0x0018(0x0001)(BitIndex: 0x01, PropSize: 0x0001 (Edit, DisableEditOnInstance, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         bInheritAllMaterialParameters : 1;                 // 0x0018(0x0001)(BitIndex: 0x02, PropSize: 0x0001 (Edit, DisableEditOnInstance, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         Pad_19[0x7];                                       // 0x0019(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<class FName>                           InheritedMaterialParameters;                       // 0x0020(0x0010)(Edit, ZeroConstructor, DisableEditOnInstance, NativeAccessSpecifierPublic)
};
static_assert(alignof(FCoordinatedConditionalMaterialData) == 0x000008, "Wrong alignment on FCoordinatedConditionalMaterialData");
static_assert(sizeof(FCoordinatedConditionalMaterialData) == 0x000030, "Wrong size on FCoordinatedConditionalMaterialData");
static_assert(offsetof(FCoordinatedConditionalMaterialData, BaseMaterial) == 0x000000, "Member 'FCoordinatedConditionalMaterialData::BaseMaterial' has a wrong offset!");
static_assert(offsetof(FCoordinatedConditionalMaterialData, MeshElementIndex) == 0x000008, "Member 'FCoordinatedConditionalMaterialData::MeshElementIndex' has a wrong offset!");
static_assert(offsetof(FCoordinatedConditionalMaterialData, OverrideMaterial) == 0x000010, "Member 'FCoordinatedConditionalMaterialData::OverrideMaterial' has a wrong offset!");
static_assert(offsetof(FCoordinatedConditionalMaterialData, InheritedMaterialParameters) == 0x000020, "Member 'FCoordinatedConditionalMaterialData::InheritedMaterialParameters' has a wrong offset!");

// ScriptStruct GbxGameSystemCore.UIStatPriorityData
// 0x0010 (0x0010 - 0x0000)
struct FUIStatPriorityData final
{
public:
	class UUIStatData*                            UIStat;                                            // 0x0000(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         PriorityIncrease;                                  // 0x0008(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_C[0x4];                                        // 0x000C(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FUIStatPriorityData) == 0x000008, "Wrong alignment on FUIStatPriorityData");
static_assert(sizeof(FUIStatPriorityData) == 0x000010, "Wrong size on FUIStatPriorityData");
static_assert(offsetof(FUIStatPriorityData, UIStat) == 0x000000, "Member 'FUIStatPriorityData::UIStat' has a wrong offset!");
static_assert(offsetof(FUIStatPriorityData, PriorityIncrease) == 0x000008, "Member 'FUIStatPriorityData::PriorityIncrease' has a wrong offset!");

// ScriptStruct GbxGameSystemCore.CoordinatedAudioData
// 0x0098 (0x0098 - 0x0000)
struct FCoordinatedAudioData final
{
public:
	class UWwiseEvent*                            WwiseEvent;                                        // 0x0000(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   AttachmentName;                                    // 0x0008(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         StartTime;                                         // 0x0010(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         DeactivateTime;                                    // 0x0014(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UWwiseRtpc*                             RtpcParam;                                         // 0x0018(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FRuntimeFloatCurve                     RtpcValueOverTime;                                 // 0x0020(0x0078)(Edit, DisableEditOnInstance, NativeAccessSpecifierPublic)
};
static_assert(alignof(FCoordinatedAudioData) == 0x000008, "Wrong alignment on FCoordinatedAudioData");
static_assert(sizeof(FCoordinatedAudioData) == 0x000098, "Wrong size on FCoordinatedAudioData");
static_assert(offsetof(FCoordinatedAudioData, WwiseEvent) == 0x000000, "Member 'FCoordinatedAudioData::WwiseEvent' has a wrong offset!");
static_assert(offsetof(FCoordinatedAudioData, AttachmentName) == 0x000008, "Member 'FCoordinatedAudioData::AttachmentName' has a wrong offset!");
static_assert(offsetof(FCoordinatedAudioData, StartTime) == 0x000010, "Member 'FCoordinatedAudioData::StartTime' has a wrong offset!");
static_assert(offsetof(FCoordinatedAudioData, DeactivateTime) == 0x000014, "Member 'FCoordinatedAudioData::DeactivateTime' has a wrong offset!");
static_assert(offsetof(FCoordinatedAudioData, RtpcParam) == 0x000018, "Member 'FCoordinatedAudioData::RtpcParam' has a wrong offset!");
static_assert(offsetof(FCoordinatedAudioData, RtpcValueOverTime) == 0x000020, "Member 'FCoordinatedAudioData::RtpcValueOverTime' has a wrong offset!");

// ScriptStruct GbxGameSystemCore.CoordinatedParticleSystemParameterData
// 0x0030 (0x0030 - 0x0000)
struct FCoordinatedParticleSystemParameterData final
{
public:
	class FName                                   Name;                                              // 0x0000(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UParticleSystem*                        ParticleSystem;                                    // 0x0008(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TArray<struct FCoordinatedScalarParameter>    ScalarParameters;                                  // 0x0010(0x0010)(Edit, ZeroConstructor, DisableEditOnInstance, NativeAccessSpecifierPublic)
	TArray<struct FCoordinatedVectorParameter>    VectorParameters;                                  // 0x0020(0x0010)(Edit, ZeroConstructor, DisableEditOnInstance, NativeAccessSpecifierPublic)
};
static_assert(alignof(FCoordinatedParticleSystemParameterData) == 0x000008, "Wrong alignment on FCoordinatedParticleSystemParameterData");
static_assert(sizeof(FCoordinatedParticleSystemParameterData) == 0x000030, "Wrong size on FCoordinatedParticleSystemParameterData");
static_assert(offsetof(FCoordinatedParticleSystemParameterData, Name) == 0x000000, "Member 'FCoordinatedParticleSystemParameterData::Name' has a wrong offset!");
static_assert(offsetof(FCoordinatedParticleSystemParameterData, ParticleSystem) == 0x000008, "Member 'FCoordinatedParticleSystemParameterData::ParticleSystem' has a wrong offset!");
static_assert(offsetof(FCoordinatedParticleSystemParameterData, ScalarParameters) == 0x000010, "Member 'FCoordinatedParticleSystemParameterData::ScalarParameters' has a wrong offset!");
static_assert(offsetof(FCoordinatedParticleSystemParameterData, VectorParameters) == 0x000020, "Member 'FCoordinatedParticleSystemParameterData::VectorParameters' has a wrong offset!");

// ScriptStruct GbxGameSystemCore.ActionState_Launch
// 0x0018 (0x0480 - 0x0468)
struct FActionState_Launch final : public FActionState_SimpleAnim
{
public:
	uint8                                         Pad_468[0x18];                                     // 0x0468(0x0018)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FActionState_Launch) == 0x000008, "Wrong alignment on FActionState_Launch");
static_assert(sizeof(FActionState_Launch) == 0x000480, "Wrong size on FActionState_Launch");

// ScriptStruct GbxGameSystemCore.LoopAnimData
// 0x0018 (0x0018 - 0x0000)
struct FLoopAnimData final
{
public:
	class UAnimSequenceBase*                      AnimStart;                                         // 0x0000(0x0008)(ZeroConstructor, Deprecated, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UAnimSequenceBase*                      AnimLoop;                                          // 0x0008(0x0008)(ZeroConstructor, Deprecated, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UAnimSequenceBase*                      AnimStop;                                          // 0x0010(0x0008)(ZeroConstructor, Deprecated, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FLoopAnimData) == 0x000008, "Wrong alignment on FLoopAnimData");
static_assert(sizeof(FLoopAnimData) == 0x000018, "Wrong size on FLoopAnimData");
static_assert(offsetof(FLoopAnimData, AnimStart) == 0x000000, "Member 'FLoopAnimData::AnimStart' has a wrong offset!");
static_assert(offsetof(FLoopAnimData, AnimLoop) == 0x000008, "Member 'FLoopAnimData::AnimLoop' has a wrong offset!");
static_assert(offsetof(FLoopAnimData, AnimStop) == 0x000010, "Member 'FLoopAnimData::AnimStop' has a wrong offset!");

// ScriptStruct GbxGameSystemCore.PlayerInputBinding_Button
// 0x0020 (0x0020 - 0x0000)
struct FPlayerInputBinding_Button final
{
public:
	class FString                                 RebindDataPath;                                    // 0x0000(0x0010)(ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TArray<class FName>                           KeyNames;                                          // 0x0010(0x0010)(ZeroConstructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(FPlayerInputBinding_Button) == 0x000008, "Wrong alignment on FPlayerInputBinding_Button");
static_assert(sizeof(FPlayerInputBinding_Button) == 0x000020, "Wrong size on FPlayerInputBinding_Button");
static_assert(offsetof(FPlayerInputBinding_Button, RebindDataPath) == 0x000000, "Member 'FPlayerInputBinding_Button::RebindDataPath' has a wrong offset!");
static_assert(offsetof(FPlayerInputBinding_Button, KeyNames) == 0x000010, "Member 'FPlayerInputBinding_Button::KeyNames' has a wrong offset!");

// ScriptStruct GbxGameSystemCore.ActionState_Ragdoll
// 0x0148 (0x05B0 - 0x0468)
struct alignas(0x10) FActionState_Ragdoll final : public FActionState_SimpleAnim
{
public:
	uint8                                         Pad_468[0x148];                                    // 0x0468(0x0148)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FActionState_Ragdoll) == 0x000010, "Wrong alignment on FActionState_Ragdoll");
static_assert(sizeof(FActionState_Ragdoll) == 0x0005B0, "Wrong size on FActionState_Ragdoll");

// ScriptStruct GbxGameSystemCore.AttachedObjectCache
// 0x0050 (0x0050 - 0x0000)
struct alignas(0x10) FAttachedObjectCache final
{
public:
	uint8                                         Pad_0[0x50];                                       // 0x0000(0x0050)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FAttachedObjectCache) == 0x000010, "Wrong alignment on FAttachedObjectCache");
static_assert(sizeof(FAttachedObjectCache) == 0x000050, "Wrong size on FAttachedObjectCache");

// ScriptStruct GbxGameSystemCore.AttachedObjectFollow
// 0x0018 (0x0018 - 0x0000)
struct alignas(0x08) FAttachedObjectFollow final
{
public:
	class FName                                   ObjectBoneName;                                    // 0x0000(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   ObjectHoldBoneName;                                // 0x0008(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   ObjectHoldBodyName;                                // 0x0010(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FAttachedObjectFollow) == 0x000008, "Wrong alignment on FAttachedObjectFollow");
static_assert(sizeof(FAttachedObjectFollow) == 0x000018, "Wrong size on FAttachedObjectFollow");
static_assert(offsetof(FAttachedObjectFollow, ObjectBoneName) == 0x000000, "Member 'FAttachedObjectFollow::ObjectBoneName' has a wrong offset!");
static_assert(offsetof(FAttachedObjectFollow, ObjectHoldBoneName) == 0x000008, "Member 'FAttachedObjectFollow::ObjectHoldBoneName' has a wrong offset!");
static_assert(offsetof(FAttachedObjectFollow, ObjectHoldBodyName) == 0x000010, "Member 'FAttachedObjectFollow::ObjectHoldBodyName' has a wrong offset!");

// ScriptStruct GbxGameSystemCore.MotionMatchedAnimationRow
// 0x0060 (0x0080 - 0x0020)
struct FMotionMatchedAnimationRow final : public FGbxAnimTableRow
{
public:
	struct FVector                                Forward;                                           // 0x0020(0x000C)(IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                Up;                                                // 0x002C(0x000C)(IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                Velocity;                                          // 0x0038(0x000C)(IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                AngularVelocity;                                   // 0x0044(0x000C)(IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                OverrideForward;                                   // 0x0050(0x000C)(Edit, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bOverrideForward;                                  // 0x005C(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_5D[0x3];                                       // 0x005D(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	struct FVector                                OverrideUp;                                        // 0x0060(0x000C)(Edit, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bOverrideUp;                                       // 0x006C(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_6D[0x3];                                       // 0x006D(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         RootBoneToRootBodyOffset;                          // 0x0070(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EAxis                                         OffsetCalculationAxis;                             // 0x0074(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bOffsetCalculationAxisIsNegative;                  // 0x0075(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_76[0x2];                                       // 0x0076(0x0002)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         SampleTime;                                        // 0x0078(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         PoseDriverStrength;                                // 0x007C(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FMotionMatchedAnimationRow) == 0x000008, "Wrong alignment on FMotionMatchedAnimationRow");
static_assert(sizeof(FMotionMatchedAnimationRow) == 0x000080, "Wrong size on FMotionMatchedAnimationRow");
static_assert(offsetof(FMotionMatchedAnimationRow, Forward) == 0x000020, "Member 'FMotionMatchedAnimationRow::Forward' has a wrong offset!");
static_assert(offsetof(FMotionMatchedAnimationRow, Up) == 0x00002C, "Member 'FMotionMatchedAnimationRow::Up' has a wrong offset!");
static_assert(offsetof(FMotionMatchedAnimationRow, Velocity) == 0x000038, "Member 'FMotionMatchedAnimationRow::Velocity' has a wrong offset!");
static_assert(offsetof(FMotionMatchedAnimationRow, AngularVelocity) == 0x000044, "Member 'FMotionMatchedAnimationRow::AngularVelocity' has a wrong offset!");
static_assert(offsetof(FMotionMatchedAnimationRow, OverrideForward) == 0x000050, "Member 'FMotionMatchedAnimationRow::OverrideForward' has a wrong offset!");
static_assert(offsetof(FMotionMatchedAnimationRow, bOverrideForward) == 0x00005C, "Member 'FMotionMatchedAnimationRow::bOverrideForward' has a wrong offset!");
static_assert(offsetof(FMotionMatchedAnimationRow, OverrideUp) == 0x000060, "Member 'FMotionMatchedAnimationRow::OverrideUp' has a wrong offset!");
static_assert(offsetof(FMotionMatchedAnimationRow, bOverrideUp) == 0x00006C, "Member 'FMotionMatchedAnimationRow::bOverrideUp' has a wrong offset!");
static_assert(offsetof(FMotionMatchedAnimationRow, RootBoneToRootBodyOffset) == 0x000070, "Member 'FMotionMatchedAnimationRow::RootBoneToRootBodyOffset' has a wrong offset!");
static_assert(offsetof(FMotionMatchedAnimationRow, OffsetCalculationAxis) == 0x000074, "Member 'FMotionMatchedAnimationRow::OffsetCalculationAxis' has a wrong offset!");
static_assert(offsetof(FMotionMatchedAnimationRow, bOffsetCalculationAxisIsNegative) == 0x000075, "Member 'FMotionMatchedAnimationRow::bOffsetCalculationAxisIsNegative' has a wrong offset!");
static_assert(offsetof(FMotionMatchedAnimationRow, SampleTime) == 0x000078, "Member 'FMotionMatchedAnimationRow::SampleTime' has a wrong offset!");
static_assert(offsetof(FMotionMatchedAnimationRow, PoseDriverStrength) == 0x00007C, "Member 'FMotionMatchedAnimationRow::PoseDriverStrength' has a wrong offset!");

// ScriptStruct GbxGameSystemCore.ActionState_StretchBones
// 0x0000 (0x0468 - 0x0468)
struct FActionState_StretchBones final : public FActionState_SimpleAnim
{
};
static_assert(alignof(FActionState_StretchBones) == 0x000008, "Wrong alignment on FActionState_StretchBones");
static_assert(sizeof(FActionState_StretchBones) == 0x000468, "Wrong size on FActionState_StretchBones");

// ScriptStruct GbxGameSystemCore.GbxActionRegister
// 0x0038 (0x0038 - 0x0000)
struct FGbxActionRegister final
{
public:
	class FName                                   Name;                                              // 0x0000(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EActionRegisterType                           Type;                                              // 0x0008(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_9[0x3];                                        // 0x0009(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         Value;                                             // 0x000C(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         IntValue;                                          // 0x0010(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_14[0x4];                                       // 0x0014(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class UObject*                                ObjectValue;                                       // 0x0018(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   NameValue;                                         // 0x0020(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                VecValue;                                          // 0x0028(0x000C)(IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_34[0x4];                                       // 0x0034(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FGbxActionRegister) == 0x000008, "Wrong alignment on FGbxActionRegister");
static_assert(sizeof(FGbxActionRegister) == 0x000038, "Wrong size on FGbxActionRegister");
static_assert(offsetof(FGbxActionRegister, Name) == 0x000000, "Member 'FGbxActionRegister::Name' has a wrong offset!");
static_assert(offsetof(FGbxActionRegister, Type) == 0x000008, "Member 'FGbxActionRegister::Type' has a wrong offset!");
static_assert(offsetof(FGbxActionRegister, Value) == 0x00000C, "Member 'FGbxActionRegister::Value' has a wrong offset!");
static_assert(offsetof(FGbxActionRegister, IntValue) == 0x000010, "Member 'FGbxActionRegister::IntValue' has a wrong offset!");
static_assert(offsetof(FGbxActionRegister, ObjectValue) == 0x000018, "Member 'FGbxActionRegister::ObjectValue' has a wrong offset!");
static_assert(offsetof(FGbxActionRegister, NameValue) == 0x000020, "Member 'FGbxActionRegister::NameValue' has a wrong offset!");
static_assert(offsetof(FGbxActionRegister, VecValue) == 0x000028, "Member 'FGbxActionRegister::VecValue' has a wrong offset!");

// ScriptStruct GbxGameSystemCore.GbxActionSlot
// 0x0018 (0x0018 - 0x0000)
struct alignas(0x08) FGbxActionSlot final
{
public:
	class FName                                   Name;                                              // 0x0000(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_8[0x10];                                       // 0x0008(0x0010)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FGbxActionSlot) == 0x000008, "Wrong alignment on FGbxActionSlot");
static_assert(sizeof(FGbxActionSlot) == 0x000018, "Wrong size on FGbxActionSlot");
static_assert(offsetof(FGbxActionSlot, Name) == 0x000000, "Member 'FGbxActionSlot::Name' has a wrong offset!");

// ScriptStruct GbxGameSystemCore.GbxAnimNode_ApplyBoneModifyProfile
// 0x0040 (0x0180 - 0x0140)
struct FGbxAnimNode_ApplyBoneModifyProfile final : public FAnimNode_SkeletalControlBase
{
public:
	class UGbxBoneModifyProfile*                  Config;                                            // 0x0140(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_148[0x38];                                     // 0x0148(0x0038)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FGbxAnimNode_ApplyBoneModifyProfile) == 0x000008, "Wrong alignment on FGbxAnimNode_ApplyBoneModifyProfile");
static_assert(sizeof(FGbxAnimNode_ApplyBoneModifyProfile) == 0x000180, "Wrong size on FGbxAnimNode_ApplyBoneModifyProfile");
static_assert(offsetof(FGbxAnimNode_ApplyBoneModifyProfile, Config) == 0x000140, "Member 'FGbxAnimNode_ApplyBoneModifyProfile::Config' has a wrong offset!");

// ScriptStruct GbxGameSystemCore.GlobalBMPCachedTransform
// 0x0020 (0x0020 - 0x0000)
struct alignas(0x08) FGlobalBMPCachedTransform final
{
public:
	uint8                                         Pad_0[0x20];                                       // 0x0000(0x0020)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FGlobalBMPCachedTransform) == 0x000008, "Wrong alignment on FGlobalBMPCachedTransform");
static_assert(sizeof(FGlobalBMPCachedTransform) == 0x000020, "Wrong size on FGlobalBMPCachedTransform");

// ScriptStruct GbxGameSystemCore.StatusEffectStackingStrategyData_DurationRefundData
// 0x0008 (0x0008 - 0x0000)
struct FStatusEffectStackingStrategyData_DurationRefundData final
{
public:
	bool                                          bApplyReplacementRefund;                           // 0x0000(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1[0x3];                                        // 0x0001(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         RefundPercent;                                     // 0x0004(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FStatusEffectStackingStrategyData_DurationRefundData) == 0x000004, "Wrong alignment on FStatusEffectStackingStrategyData_DurationRefundData");
static_assert(sizeof(FStatusEffectStackingStrategyData_DurationRefundData) == 0x000008, "Wrong size on FStatusEffectStackingStrategyData_DurationRefundData");
static_assert(offsetof(FStatusEffectStackingStrategyData_DurationRefundData, bApplyReplacementRefund) == 0x000000, "Member 'FStatusEffectStackingStrategyData_DurationRefundData::bApplyReplacementRefund' has a wrong offset!");
static_assert(offsetof(FStatusEffectStackingStrategyData_DurationRefundData, RefundPercent) == 0x000004, "Member 'FStatusEffectStackingStrategyData_DurationRefundData::RefundPercent' has a wrong offset!");

// ScriptStruct GbxGameSystemCore.GbxAnimNode_CachedPoseBlend
// 0x0060 (0x01A0 - 0x0140)
struct alignas(0x10) FGbxAnimNode_CachedPoseBlend final : public FAnimNode_SkeletalControlBase
{
public:
	uint8                                         Pad_140[0x60];                                     // 0x0140(0x0060)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FGbxAnimNode_CachedPoseBlend) == 0x000010, "Wrong alignment on FGbxAnimNode_CachedPoseBlend");
static_assert(sizeof(FGbxAnimNode_CachedPoseBlend) == 0x0001A0, "Wrong size on FGbxAnimNode_CachedPoseBlend");

// ScriptStruct GbxGameSystemCore.BoneModifyInfo
// 0x0030 (0x0030 - 0x0000)
struct alignas(0x08) FBoneModifyInfo final
{
public:
	class FName                                   BoneName;                                          // 0x0000(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                Translation;                                       // 0x0008(0x000C)(Edit, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FRotator                               Rotation;                                          // 0x0014(0x000C)(Edit, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
	struct FVector                                Scale;                                             // 0x0020(0x000C)(Edit, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2C[0x4];                                       // 0x002C(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FBoneModifyInfo) == 0x000008, "Wrong alignment on FBoneModifyInfo");
static_assert(sizeof(FBoneModifyInfo) == 0x000030, "Wrong size on FBoneModifyInfo");
static_assert(offsetof(FBoneModifyInfo, BoneName) == 0x000000, "Member 'FBoneModifyInfo::BoneName' has a wrong offset!");
static_assert(offsetof(FBoneModifyInfo, Translation) == 0x000008, "Member 'FBoneModifyInfo::Translation' has a wrong offset!");
static_assert(offsetof(FBoneModifyInfo, Rotation) == 0x000014, "Member 'FBoneModifyInfo::Rotation' has a wrong offset!");
static_assert(offsetof(FBoneModifyInfo, Scale) == 0x000020, "Member 'FBoneModifyInfo::Scale' has a wrong offset!");

// ScriptStruct GbxGameSystemCore.BoneModifyState
// 0x0058 (0x0058 - 0x0000)
struct FBoneModifyState final
{
public:
	class FName                                   Name;                                              // 0x0000(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EGbxBoneModifyProfile_PoseMode                PoseMode;                                          // 0x0008(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, AdvancedDisplay, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bStartActive;                                      // 0x0009(0x0001)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_A[0x6];                                        // 0x000A(0x0006)(Fixing Size After Last Property [ Dumper-7 ])
	struct FAlphaBlend                            Blend;                                             // 0x0010(0x0038)(Edit, DisableEditOnInstance, NoDestructor, NativeAccessSpecifierPublic)
	TArray<struct FBoneModifyInfo>                Bones;                                             // 0x0048(0x0010)(Edit, ZeroConstructor, DisableEditOnInstance, NativeAccessSpecifierPublic)
};
static_assert(alignof(FBoneModifyState) == 0x000008, "Wrong alignment on FBoneModifyState");
static_assert(sizeof(FBoneModifyState) == 0x000058, "Wrong size on FBoneModifyState");
static_assert(offsetof(FBoneModifyState, Name) == 0x000000, "Member 'FBoneModifyState::Name' has a wrong offset!");
static_assert(offsetof(FBoneModifyState, PoseMode) == 0x000008, "Member 'FBoneModifyState::PoseMode' has a wrong offset!");
static_assert(offsetof(FBoneModifyState, bStartActive) == 0x000009, "Member 'FBoneModifyState::bStartActive' has a wrong offset!");
static_assert(offsetof(FBoneModifyState, Blend) == 0x000010, "Member 'FBoneModifyState::Blend' has a wrong offset!");
static_assert(offsetof(FBoneModifyState, Bones) == 0x000048, "Member 'FBoneModifyState::Bones' has a wrong offset!");

// ScriptStruct GbxGameSystemCore.GbxAnimNode_ForwardDynamics
// 0x0170 (0x0730 - 0x05C0)
struct FGbxAnimNode_ForwardDynamics final : public FAnimNode_RigidBody
{
public:
	class UPhysicalAnimationProfileAsset*         ForwardDynamicsProfile;                            // 0x05C0(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EForwardDynamicsActivation                    ForwardDynamicsActivation;                         // 0x05C8(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_5CC[0x4];                                      // 0x05CC(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class FName                                   PhysicsAssetStrengthDefinitionProfileName;         // 0x05D0(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         TargetSimulationFrequency;                         // 0x05D8(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         MaxSubstepCount;                                   // 0x05DC(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         MaxTranslationDistanceUntilReset;                  // 0x05E0(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         WorldSpaceVelocityBlend;                           // 0x05E4(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         WorldSpaceAngularVelocityBlend;                    // 0x05E8(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         JointAnchorPoseAlpha;                              // 0x05EC(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         LinearJointDivergentTolerence;                     // 0x05F0(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bBypassSkelMeshSimulatePhysOption;                 // 0x05F4(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bStripAnimationFromNonSimulationRelevantBones;     // 0x05F5(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_5F6[0x13A];                                    // 0x05F6(0x013A)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FGbxAnimNode_ForwardDynamics) == 0x000010, "Wrong alignment on FGbxAnimNode_ForwardDynamics");
static_assert(sizeof(FGbxAnimNode_ForwardDynamics) == 0x000730, "Wrong size on FGbxAnimNode_ForwardDynamics");
static_assert(offsetof(FGbxAnimNode_ForwardDynamics, ForwardDynamicsProfile) == 0x0005C0, "Member 'FGbxAnimNode_ForwardDynamics::ForwardDynamicsProfile' has a wrong offset!");
static_assert(offsetof(FGbxAnimNode_ForwardDynamics, ForwardDynamicsActivation) == 0x0005C8, "Member 'FGbxAnimNode_ForwardDynamics::ForwardDynamicsActivation' has a wrong offset!");
static_assert(offsetof(FGbxAnimNode_ForwardDynamics, PhysicsAssetStrengthDefinitionProfileName) == 0x0005D0, "Member 'FGbxAnimNode_ForwardDynamics::PhysicsAssetStrengthDefinitionProfileName' has a wrong offset!");
static_assert(offsetof(FGbxAnimNode_ForwardDynamics, TargetSimulationFrequency) == 0x0005D8, "Member 'FGbxAnimNode_ForwardDynamics::TargetSimulationFrequency' has a wrong offset!");
static_assert(offsetof(FGbxAnimNode_ForwardDynamics, MaxSubstepCount) == 0x0005DC, "Member 'FGbxAnimNode_ForwardDynamics::MaxSubstepCount' has a wrong offset!");
static_assert(offsetof(FGbxAnimNode_ForwardDynamics, MaxTranslationDistanceUntilReset) == 0x0005E0, "Member 'FGbxAnimNode_ForwardDynamics::MaxTranslationDistanceUntilReset' has a wrong offset!");
static_assert(offsetof(FGbxAnimNode_ForwardDynamics, WorldSpaceVelocityBlend) == 0x0005E4, "Member 'FGbxAnimNode_ForwardDynamics::WorldSpaceVelocityBlend' has a wrong offset!");
static_assert(offsetof(FGbxAnimNode_ForwardDynamics, WorldSpaceAngularVelocityBlend) == 0x0005E8, "Member 'FGbxAnimNode_ForwardDynamics::WorldSpaceAngularVelocityBlend' has a wrong offset!");
static_assert(offsetof(FGbxAnimNode_ForwardDynamics, JointAnchorPoseAlpha) == 0x0005EC, "Member 'FGbxAnimNode_ForwardDynamics::JointAnchorPoseAlpha' has a wrong offset!");
static_assert(offsetof(FGbxAnimNode_ForwardDynamics, LinearJointDivergentTolerence) == 0x0005F0, "Member 'FGbxAnimNode_ForwardDynamics::LinearJointDivergentTolerence' has a wrong offset!");
static_assert(offsetof(FGbxAnimNode_ForwardDynamics, bBypassSkelMeshSimulatePhysOption) == 0x0005F4, "Member 'FGbxAnimNode_ForwardDynamics::bBypassSkelMeshSimulatePhysOption' has a wrong offset!");
static_assert(offsetof(FGbxAnimNode_ForwardDynamics, bStripAnimationFromNonSimulationRelevantBones) == 0x0005F5, "Member 'FGbxAnimNode_ForwardDynamics::bStripAnimationFromNonSimulationRelevantBones' has a wrong offset!");

// ScriptStruct GbxGameSystemCore.GbxAnimNode_SimpleMotionBoneControl
// 0x0208 (0x0348 - 0x0140)
struct FGbxAnimNode_SimpleMotionBoneControl final : public FAnimNode_SkeletalControlBase
{
public:
	float                                         ControlValue;                                      // 0x0140(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bIsActive;                                         // 0x0144(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bAutoActivate;                                     // 0x0145(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bPaused;                                           // 0x0146(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bActivateAfterRecovery;                            // 0x0147(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FBoneReference                         BoneToModify;                                      // 0x0148(0x0018)(Edit, NoDestructor, NativeAccessSpecifierPublic)
	float                                         IdleSpeedControlValue;                             // 0x0160(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         ActiveSpeedControlValue;                           // 0x0164(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         RecoverySpeedControlValue;                         // 0x0168(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EBoneModificationMode                         TranslationMode;                                   // 0x016C(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EBoneControlSpace                             TranslationSpace;                                  // 0x016D(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_16E[0x2];                                      // 0x016E(0x0002)(Fixing Size After Last Property [ Dumper-7 ])
	struct FVector                                IdleTranslation;                                   // 0x0170(0x000C)(Edit, BlueprintVisible, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                ActiveTranslation;                                 // 0x017C(0x000C)(Edit, BlueprintVisible, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FSimpleMotionState                     IdleTranslationState;                              // 0x0188(0x0020)(Edit, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
	struct FSimpleMotionState                     ActiveTranslationState;                            // 0x01A8(0x0020)(Edit, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
	struct FSimpleMotionState                     RecoveryTranslationState;                          // 0x01C8(0x0020)(Edit, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
	EBoneModificationMode                         RotationMode;                                      // 0x01E8(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EBoneControlSpace                             RotationSpace;                                     // 0x01E9(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1EA[0x2];                                      // 0x01EA(0x0002)(Fixing Size After Last Property [ Dumper-7 ])
	struct FRotator                               IdleRotation;                                      // 0x01EC(0x000C)(Edit, BlueprintVisible, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
	struct FRotator                               ActiveRotation;                                    // 0x01F8(0x000C)(Edit, BlueprintVisible, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
	uint8                                         Pad_204[0x4];                                      // 0x0204(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	struct FSimpleMotionState                     IdleRotationState;                                 // 0x0208(0x0020)(Edit, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
	struct FSimpleMotionState                     ActiveRotationState;                               // 0x0228(0x0020)(Edit, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
	struct FSimpleMotionState                     RecoveryRotationState;                             // 0x0248(0x0020)(Edit, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
	EBoneModificationMode                         ScaleMode;                                         // 0x0268(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EBoneControlSpace                             ScaleSpace;                                        // 0x0269(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_26A[0x2];                                      // 0x026A(0x0002)(Fixing Size After Last Property [ Dumper-7 ])
	struct FVector                                IdleScale;                                         // 0x026C(0x000C)(Edit, BlueprintVisible, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                ActiveScale;                                       // 0x0278(0x000C)(Edit, BlueprintVisible, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_284[0x4];                                      // 0x0284(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	struct FSimpleMotionState                     IdleScaleState;                                    // 0x0288(0x0020)(Edit, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
	struct FSimpleMotionState                     ActiveScaleState;                                  // 0x02A8(0x0020)(Edit, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
	struct FSimpleMotionState                     RecoveryScaleState;                                // 0x02C8(0x0020)(Edit, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
	float                                         ControlImpulseSpeed;                               // 0x02E8(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         ControlImpulseMaxValue;                            // 0x02EC(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         ControlImpulseDecayDelay;                          // 0x02F0(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         ControlImpulseDecaySpeed;                          // 0x02F4(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2F8[0x50];                                     // 0x02F8(0x0050)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FGbxAnimNode_SimpleMotionBoneControl) == 0x000008, "Wrong alignment on FGbxAnimNode_SimpleMotionBoneControl");
static_assert(sizeof(FGbxAnimNode_SimpleMotionBoneControl) == 0x000348, "Wrong size on FGbxAnimNode_SimpleMotionBoneControl");
static_assert(offsetof(FGbxAnimNode_SimpleMotionBoneControl, ControlValue) == 0x000140, "Member 'FGbxAnimNode_SimpleMotionBoneControl::ControlValue' has a wrong offset!");
static_assert(offsetof(FGbxAnimNode_SimpleMotionBoneControl, bIsActive) == 0x000144, "Member 'FGbxAnimNode_SimpleMotionBoneControl::bIsActive' has a wrong offset!");
static_assert(offsetof(FGbxAnimNode_SimpleMotionBoneControl, bAutoActivate) == 0x000145, "Member 'FGbxAnimNode_SimpleMotionBoneControl::bAutoActivate' has a wrong offset!");
static_assert(offsetof(FGbxAnimNode_SimpleMotionBoneControl, bPaused) == 0x000146, "Member 'FGbxAnimNode_SimpleMotionBoneControl::bPaused' has a wrong offset!");
static_assert(offsetof(FGbxAnimNode_SimpleMotionBoneControl, bActivateAfterRecovery) == 0x000147, "Member 'FGbxAnimNode_SimpleMotionBoneControl::bActivateAfterRecovery' has a wrong offset!");
static_assert(offsetof(FGbxAnimNode_SimpleMotionBoneControl, BoneToModify) == 0x000148, "Member 'FGbxAnimNode_SimpleMotionBoneControl::BoneToModify' has a wrong offset!");
static_assert(offsetof(FGbxAnimNode_SimpleMotionBoneControl, IdleSpeedControlValue) == 0x000160, "Member 'FGbxAnimNode_SimpleMotionBoneControl::IdleSpeedControlValue' has a wrong offset!");
static_assert(offsetof(FGbxAnimNode_SimpleMotionBoneControl, ActiveSpeedControlValue) == 0x000164, "Member 'FGbxAnimNode_SimpleMotionBoneControl::ActiveSpeedControlValue' has a wrong offset!");
static_assert(offsetof(FGbxAnimNode_SimpleMotionBoneControl, RecoverySpeedControlValue) == 0x000168, "Member 'FGbxAnimNode_SimpleMotionBoneControl::RecoverySpeedControlValue' has a wrong offset!");
static_assert(offsetof(FGbxAnimNode_SimpleMotionBoneControl, TranslationMode) == 0x00016C, "Member 'FGbxAnimNode_SimpleMotionBoneControl::TranslationMode' has a wrong offset!");
static_assert(offsetof(FGbxAnimNode_SimpleMotionBoneControl, TranslationSpace) == 0x00016D, "Member 'FGbxAnimNode_SimpleMotionBoneControl::TranslationSpace' has a wrong offset!");
static_assert(offsetof(FGbxAnimNode_SimpleMotionBoneControl, IdleTranslation) == 0x000170, "Member 'FGbxAnimNode_SimpleMotionBoneControl::IdleTranslation' has a wrong offset!");
static_assert(offsetof(FGbxAnimNode_SimpleMotionBoneControl, ActiveTranslation) == 0x00017C, "Member 'FGbxAnimNode_SimpleMotionBoneControl::ActiveTranslation' has a wrong offset!");
static_assert(offsetof(FGbxAnimNode_SimpleMotionBoneControl, IdleTranslationState) == 0x000188, "Member 'FGbxAnimNode_SimpleMotionBoneControl::IdleTranslationState' has a wrong offset!");
static_assert(offsetof(FGbxAnimNode_SimpleMotionBoneControl, ActiveTranslationState) == 0x0001A8, "Member 'FGbxAnimNode_SimpleMotionBoneControl::ActiveTranslationState' has a wrong offset!");
static_assert(offsetof(FGbxAnimNode_SimpleMotionBoneControl, RecoveryTranslationState) == 0x0001C8, "Member 'FGbxAnimNode_SimpleMotionBoneControl::RecoveryTranslationState' has a wrong offset!");
static_assert(offsetof(FGbxAnimNode_SimpleMotionBoneControl, RotationMode) == 0x0001E8, "Member 'FGbxAnimNode_SimpleMotionBoneControl::RotationMode' has a wrong offset!");
static_assert(offsetof(FGbxAnimNode_SimpleMotionBoneControl, RotationSpace) == 0x0001E9, "Member 'FGbxAnimNode_SimpleMotionBoneControl::RotationSpace' has a wrong offset!");
static_assert(offsetof(FGbxAnimNode_SimpleMotionBoneControl, IdleRotation) == 0x0001EC, "Member 'FGbxAnimNode_SimpleMotionBoneControl::IdleRotation' has a wrong offset!");
static_assert(offsetof(FGbxAnimNode_SimpleMotionBoneControl, ActiveRotation) == 0x0001F8, "Member 'FGbxAnimNode_SimpleMotionBoneControl::ActiveRotation' has a wrong offset!");
static_assert(offsetof(FGbxAnimNode_SimpleMotionBoneControl, IdleRotationState) == 0x000208, "Member 'FGbxAnimNode_SimpleMotionBoneControl::IdleRotationState' has a wrong offset!");
static_assert(offsetof(FGbxAnimNode_SimpleMotionBoneControl, ActiveRotationState) == 0x000228, "Member 'FGbxAnimNode_SimpleMotionBoneControl::ActiveRotationState' has a wrong offset!");
static_assert(offsetof(FGbxAnimNode_SimpleMotionBoneControl, RecoveryRotationState) == 0x000248, "Member 'FGbxAnimNode_SimpleMotionBoneControl::RecoveryRotationState' has a wrong offset!");
static_assert(offsetof(FGbxAnimNode_SimpleMotionBoneControl, ScaleMode) == 0x000268, "Member 'FGbxAnimNode_SimpleMotionBoneControl::ScaleMode' has a wrong offset!");
static_assert(offsetof(FGbxAnimNode_SimpleMotionBoneControl, ScaleSpace) == 0x000269, "Member 'FGbxAnimNode_SimpleMotionBoneControl::ScaleSpace' has a wrong offset!");
static_assert(offsetof(FGbxAnimNode_SimpleMotionBoneControl, IdleScale) == 0x00026C, "Member 'FGbxAnimNode_SimpleMotionBoneControl::IdleScale' has a wrong offset!");
static_assert(offsetof(FGbxAnimNode_SimpleMotionBoneControl, ActiveScale) == 0x000278, "Member 'FGbxAnimNode_SimpleMotionBoneControl::ActiveScale' has a wrong offset!");
static_assert(offsetof(FGbxAnimNode_SimpleMotionBoneControl, IdleScaleState) == 0x000288, "Member 'FGbxAnimNode_SimpleMotionBoneControl::IdleScaleState' has a wrong offset!");
static_assert(offsetof(FGbxAnimNode_SimpleMotionBoneControl, ActiveScaleState) == 0x0002A8, "Member 'FGbxAnimNode_SimpleMotionBoneControl::ActiveScaleState' has a wrong offset!");
static_assert(offsetof(FGbxAnimNode_SimpleMotionBoneControl, RecoveryScaleState) == 0x0002C8, "Member 'FGbxAnimNode_SimpleMotionBoneControl::RecoveryScaleState' has a wrong offset!");
static_assert(offsetof(FGbxAnimNode_SimpleMotionBoneControl, ControlImpulseSpeed) == 0x0002E8, "Member 'FGbxAnimNode_SimpleMotionBoneControl::ControlImpulseSpeed' has a wrong offset!");
static_assert(offsetof(FGbxAnimNode_SimpleMotionBoneControl, ControlImpulseMaxValue) == 0x0002EC, "Member 'FGbxAnimNode_SimpleMotionBoneControl::ControlImpulseMaxValue' has a wrong offset!");
static_assert(offsetof(FGbxAnimNode_SimpleMotionBoneControl, ControlImpulseDecayDelay) == 0x0002F0, "Member 'FGbxAnimNode_SimpleMotionBoneControl::ControlImpulseDecayDelay' has a wrong offset!");
static_assert(offsetof(FGbxAnimNode_SimpleMotionBoneControl, ControlImpulseDecaySpeed) == 0x0002F4, "Member 'FGbxAnimNode_SimpleMotionBoneControl::ControlImpulseDecaySpeed' has a wrong offset!");

// ScriptStruct GbxGameSystemCore.GbxAnimNode_StretchBones
// 0x0190 (0x02D0 - 0x0140)
struct alignas(0x10) FGbxAnimNode_StretchBones final : public FAnimNode_SkeletalControlBase
{
public:
	struct FBoneReference                         StartBone;                                         // 0x0140(0x0018)(Edit, BlueprintVisible, NoDestructor, NativeAccessSpecifierPublic)
	struct FBoneReference                         EndBone;                                           // 0x0158(0x0018)(Edit, BlueprintVisible, NoDestructor, NativeAccessSpecifierPublic)
	bool                                          bUniformStretch;                                   // 0x0170(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_171[0x3];                                      // 0x0171(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         AnimatedTargetDistance;                            // 0x0174(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         EndAnimatedTargetDistance;                         // 0x0178(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                TargetOffset;                                      // 0x017C(0x000C)(Edit, BlueprintVisible, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_188[0x8];                                      // 0x0188(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	bool                                          bUsingStretchDistance;                             // 0x0190(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_191[0x3];                                      // 0x0191(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         StretchDistance;                                   // 0x0194(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bTraceToGround;                                    // 0x0198(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_199[0x3];                                      // 0x0199(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         TraceToGroundDistance;                             // 0x019C(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EStretchBonesMarkerMode                       MarkerMode;                                        // 0x01A0(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1A1[0x7];                                      // 0x01A1(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	struct FBoneReference                         BoneToModify;                                      // 0x01A8(0x0018)(Edit, BlueprintVisible, NoDestructor, NativeAccessSpecifierPublic)
	struct FBoneReference                         LookAtBone;                                        // 0x01C0(0x0018)(Edit, BlueprintVisible, NoDestructor, NativeAccessSpecifierPublic)
	class FName                                   LookAtSocket;                                      // 0x01D8(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                LookAtLocation;                                    // 0x01E0(0x000C)(Edit, BlueprintVisible, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FAXIS                                  LookAt_Axis;                                       // 0x01EC(0x0010)(Edit, BlueprintVisible, NoDestructor, NativeAccessSpecifierPublic)
	struct FAXIS                                  EndLookAt_Axis;                                    // 0x01FC(0x0010)(Edit, BlueprintVisible, NoDestructor, NativeAccessSpecifierPublic)
	bool                                          bUseLookUpAxis;                                    // 0x020C(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_20D[0x3];                                      // 0x020D(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	struct FAXIS                                  LookUp_Axis;                                       // 0x0210(0x0010)(Edit, BlueprintVisible, NoDestructor, NativeAccessSpecifierPublic)
	float                                         LookAtClamp;                                       // 0x0220(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EInterpolationBlend                           InterpolationType;                                 // 0x0224(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_225[0x3];                                      // 0x0225(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         InterpolationTime;                                 // 0x0228(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         InterpolationTriggerThreashold;                    // 0x022C(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_230[0xA0];                                     // 0x0230(0x00A0)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FGbxAnimNode_StretchBones) == 0x000010, "Wrong alignment on FGbxAnimNode_StretchBones");
static_assert(sizeof(FGbxAnimNode_StretchBones) == 0x0002D0, "Wrong size on FGbxAnimNode_StretchBones");
static_assert(offsetof(FGbxAnimNode_StretchBones, StartBone) == 0x000140, "Member 'FGbxAnimNode_StretchBones::StartBone' has a wrong offset!");
static_assert(offsetof(FGbxAnimNode_StretchBones, EndBone) == 0x000158, "Member 'FGbxAnimNode_StretchBones::EndBone' has a wrong offset!");
static_assert(offsetof(FGbxAnimNode_StretchBones, bUniformStretch) == 0x000170, "Member 'FGbxAnimNode_StretchBones::bUniformStretch' has a wrong offset!");
static_assert(offsetof(FGbxAnimNode_StretchBones, AnimatedTargetDistance) == 0x000174, "Member 'FGbxAnimNode_StretchBones::AnimatedTargetDistance' has a wrong offset!");
static_assert(offsetof(FGbxAnimNode_StretchBones, EndAnimatedTargetDistance) == 0x000178, "Member 'FGbxAnimNode_StretchBones::EndAnimatedTargetDistance' has a wrong offset!");
static_assert(offsetof(FGbxAnimNode_StretchBones, TargetOffset) == 0x00017C, "Member 'FGbxAnimNode_StretchBones::TargetOffset' has a wrong offset!");
static_assert(offsetof(FGbxAnimNode_StretchBones, bUsingStretchDistance) == 0x000190, "Member 'FGbxAnimNode_StretchBones::bUsingStretchDistance' has a wrong offset!");
static_assert(offsetof(FGbxAnimNode_StretchBones, StretchDistance) == 0x000194, "Member 'FGbxAnimNode_StretchBones::StretchDistance' has a wrong offset!");
static_assert(offsetof(FGbxAnimNode_StretchBones, bTraceToGround) == 0x000198, "Member 'FGbxAnimNode_StretchBones::bTraceToGround' has a wrong offset!");
static_assert(offsetof(FGbxAnimNode_StretchBones, TraceToGroundDistance) == 0x00019C, "Member 'FGbxAnimNode_StretchBones::TraceToGroundDistance' has a wrong offset!");
static_assert(offsetof(FGbxAnimNode_StretchBones, MarkerMode) == 0x0001A0, "Member 'FGbxAnimNode_StretchBones::MarkerMode' has a wrong offset!");
static_assert(offsetof(FGbxAnimNode_StretchBones, BoneToModify) == 0x0001A8, "Member 'FGbxAnimNode_StretchBones::BoneToModify' has a wrong offset!");
static_assert(offsetof(FGbxAnimNode_StretchBones, LookAtBone) == 0x0001C0, "Member 'FGbxAnimNode_StretchBones::LookAtBone' has a wrong offset!");
static_assert(offsetof(FGbxAnimNode_StretchBones, LookAtSocket) == 0x0001D8, "Member 'FGbxAnimNode_StretchBones::LookAtSocket' has a wrong offset!");
static_assert(offsetof(FGbxAnimNode_StretchBones, LookAtLocation) == 0x0001E0, "Member 'FGbxAnimNode_StretchBones::LookAtLocation' has a wrong offset!");
static_assert(offsetof(FGbxAnimNode_StretchBones, LookAt_Axis) == 0x0001EC, "Member 'FGbxAnimNode_StretchBones::LookAt_Axis' has a wrong offset!");
static_assert(offsetof(FGbxAnimNode_StretchBones, EndLookAt_Axis) == 0x0001FC, "Member 'FGbxAnimNode_StretchBones::EndLookAt_Axis' has a wrong offset!");
static_assert(offsetof(FGbxAnimNode_StretchBones, bUseLookUpAxis) == 0x00020C, "Member 'FGbxAnimNode_StretchBones::bUseLookUpAxis' has a wrong offset!");
static_assert(offsetof(FGbxAnimNode_StretchBones, LookUp_Axis) == 0x000210, "Member 'FGbxAnimNode_StretchBones::LookUp_Axis' has a wrong offset!");
static_assert(offsetof(FGbxAnimNode_StretchBones, LookAtClamp) == 0x000220, "Member 'FGbxAnimNode_StretchBones::LookAtClamp' has a wrong offset!");
static_assert(offsetof(FGbxAnimNode_StretchBones, InterpolationType) == 0x000224, "Member 'FGbxAnimNode_StretchBones::InterpolationType' has a wrong offset!");
static_assert(offsetof(FGbxAnimNode_StretchBones, InterpolationTime) == 0x000228, "Member 'FGbxAnimNode_StretchBones::InterpolationTime' has a wrong offset!");
static_assert(offsetof(FGbxAnimNode_StretchBones, InterpolationTriggerThreashold) == 0x00022C, "Member 'FGbxAnimNode_StretchBones::InterpolationTriggerThreashold' has a wrong offset!");

// ScriptStruct GbxGameSystemCore.AnimStateGroup
// 0x0018 (0x0018 - 0x0000)
struct FAnimStateGroup final
{
public:
	class FName                                   GroupName;                                         // 0x0000(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TArray<class FName>                           States;                                            // 0x0008(0x0010)(Edit, ZeroConstructor, DisableEditOnInstance, NativeAccessSpecifierPublic)
};
static_assert(alignof(FAnimStateGroup) == 0x000008, "Wrong alignment on FAnimStateGroup");
static_assert(sizeof(FAnimStateGroup) == 0x000018, "Wrong size on FAnimStateGroup");
static_assert(offsetof(FAnimStateGroup, GroupName) == 0x000000, "Member 'FAnimStateGroup::GroupName' has a wrong offset!");
static_assert(offsetof(FAnimStateGroup, States) == 0x000008, "Member 'FAnimStateGroup::States' has a wrong offset!");

// ScriptStruct GbxGameSystemCore.RuntimeStateMachineData
// 0x0018 (0x0018 - 0x0000)
struct alignas(0x08) FRuntimeStateMachineData final
{
public:
	uint8                                         Pad_0[0x18];                                       // 0x0000(0x0018)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FRuntimeStateMachineData) == 0x000008, "Wrong alignment on FRuntimeStateMachineData");
static_assert(sizeof(FRuntimeStateMachineData) == 0x000018, "Wrong size on FRuntimeStateMachineData");

// ScriptStruct GbxGameSystemCore.BakedMachineInfo
// 0x0020 (0x0020 - 0x0000)
struct alignas(0x08) FBakedMachineInfo final
{
public:
	uint8                                         Pad_0[0x20];                                       // 0x0000(0x0020)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FBakedMachineInfo) == 0x000008, "Wrong alignment on FBakedMachineInfo");
static_assert(sizeof(FBakedMachineInfo) == 0x000020, "Wrong size on FBakedMachineInfo");

// ScriptStruct GbxGameSystemCore.GbxAnimTableMapItem
// 0x0018 (0x0018 - 0x0000)
struct FGbxAnimTableMapItem final
{
public:
	bool                                          bCanUse;                                           // 0x0000(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1[0x7];                                        // 0x0001(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	uint64                                        LastFrame;                                         // 0x0008(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_10[0x8];                                       // 0x0010(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FGbxAnimTableMapItem) == 0x000008, "Wrong alignment on FGbxAnimTableMapItem");
static_assert(sizeof(FGbxAnimTableMapItem) == 0x000018, "Wrong size on FGbxAnimTableMapItem");
static_assert(offsetof(FGbxAnimTableMapItem, bCanUse) == 0x000000, "Member 'FGbxAnimTableMapItem::bCanUse' has a wrong offset!");
static_assert(offsetof(FGbxAnimTableMapItem, LastFrame) == 0x000008, "Member 'FGbxAnimTableMapItem::LastFrame' has a wrong offset!");

// ScriptStruct GbxGameSystemCore.StartupAssetTypeData
// 0x0038 (0x0038 - 0x0000)
struct FStartupAssetTypeData final
{
public:
	class FName                                   Path;                                              // 0x0000(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FSoftObjectPath                        ClassType;                                         // 0x0008(0x0018)(HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UClass*                                 ResolvedClassType;                                 // 0x0020(0x0008)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	bool                                          bBlueprint;                                        // 0x0028(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_29[0x7];                                       // 0x0029(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	class FName                                   AssetCategory;                                     // 0x0030(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FStartupAssetTypeData) == 0x000008, "Wrong alignment on FStartupAssetTypeData");
static_assert(sizeof(FStartupAssetTypeData) == 0x000038, "Wrong size on FStartupAssetTypeData");
static_assert(offsetof(FStartupAssetTypeData, Path) == 0x000000, "Member 'FStartupAssetTypeData::Path' has a wrong offset!");
static_assert(offsetof(FStartupAssetTypeData, ClassType) == 0x000008, "Member 'FStartupAssetTypeData::ClassType' has a wrong offset!");
static_assert(offsetof(FStartupAssetTypeData, ResolvedClassType) == 0x000020, "Member 'FStartupAssetTypeData::ResolvedClassType' has a wrong offset!");
static_assert(offsetof(FStartupAssetTypeData, bBlueprint) == 0x000028, "Member 'FStartupAssetTypeData::bBlueprint' has a wrong offset!");
static_assert(offsetof(FStartupAssetTypeData, AssetCategory) == 0x000030, "Member 'FStartupAssetTypeData::AssetCategory' has a wrong offset!");

// ScriptStruct GbxGameSystemCore.PropertyToAttributeMapping
// 0x0030 (0x0030 - 0x0000)
struct FPropertyToAttributeMapping final
{
public:
	class FName                                   PropertyName;                                      // 0x0000(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FGuid                                  PropertyGuid;                                      // 0x0008(0x0010)(Edit, DisableEditOnInstance, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FSoftObjectPath                        AttributeDataReference;                            // 0x0018(0x0018)(Edit, DisableEditOnInstance, EditConst, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
};
static_assert(alignof(FPropertyToAttributeMapping) == 0x000008, "Wrong alignment on FPropertyToAttributeMapping");
static_assert(sizeof(FPropertyToAttributeMapping) == 0x000030, "Wrong size on FPropertyToAttributeMapping");
static_assert(offsetof(FPropertyToAttributeMapping, PropertyName) == 0x000000, "Member 'FPropertyToAttributeMapping::PropertyName' has a wrong offset!");
static_assert(offsetof(FPropertyToAttributeMapping, PropertyGuid) == 0x000008, "Member 'FPropertyToAttributeMapping::PropertyGuid' has a wrong offset!");
static_assert(offsetof(FPropertyToAttributeMapping, AttributeDataReference) == 0x000018, "Member 'FPropertyToAttributeMapping::AttributeDataReference' has a wrong offset!");

// ScriptStruct GbxGameSystemCore.BoneModifyTransition
// 0x0070 (0x0070 - 0x0000)
struct FBoneModifyTransition final
{
public:
	struct FBoneReference                         BoneRef;                                           // 0x0000(0x0018)(NoDestructor, NativeAccessSpecifierPublic)
	EBoneModifyTransition_TransformType           Type;                                              // 0x0018(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_19[0x7];                                       // 0x0019(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	struct FAlphaBlend                            Blend;                                             // 0x0020(0x0038)(NoDestructor, NativeAccessSpecifierPublic)
	struct FVector                                Base;                                              // 0x0058(0x000C)(IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                Desired;                                           // 0x0064(0x000C)(IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FBoneModifyTransition) == 0x000008, "Wrong alignment on FBoneModifyTransition");
static_assert(sizeof(FBoneModifyTransition) == 0x000070, "Wrong size on FBoneModifyTransition");
static_assert(offsetof(FBoneModifyTransition, BoneRef) == 0x000000, "Member 'FBoneModifyTransition::BoneRef' has a wrong offset!");
static_assert(offsetof(FBoneModifyTransition, Type) == 0x000018, "Member 'FBoneModifyTransition::Type' has a wrong offset!");
static_assert(offsetof(FBoneModifyTransition, Blend) == 0x000020, "Member 'FBoneModifyTransition::Blend' has a wrong offset!");
static_assert(offsetof(FBoneModifyTransition, Base) == 0x000058, "Member 'FBoneModifyTransition::Base' has a wrong offset!");
static_assert(offsetof(FBoneModifyTransition, Desired) == 0x000064, "Member 'FBoneModifyTransition::Desired' has a wrong offset!");

// ScriptStruct GbxGameSystemCore.MantleCheckTypeData
// 0x00B8 (0x00B8 - 0x0000)
struct alignas(0x04) FMantleCheckTypeData
{
public:
	uint8                                         Pad_0[0xB8];                                       // 0x0000(0x00B8)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FMantleCheckTypeData) == 0x000004, "Wrong alignment on FMantleCheckTypeData");
static_assert(sizeof(FMantleCheckTypeData) == 0x0000B8, "Wrong size on FMantleCheckTypeData");

// ScriptStruct GbxGameSystemCore.MantleCheckTypeData_MantleUp
// 0x0004 (0x00BC - 0x00B8)
struct FMantleCheckTypeData_MantleUp final : public FMantleCheckTypeData
{
public:
	uint8                                         Pad_B8[0x4];                                       // 0x00B8(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FMantleCheckTypeData_MantleUp) == 0x000004, "Wrong alignment on FMantleCheckTypeData_MantleUp");
static_assert(sizeof(FMantleCheckTypeData_MantleUp) == 0x0000BC, "Wrong size on FMantleCheckTypeData_MantleUp");

// ScriptStruct GbxGameSystemCore.MantleStandData
// 0x003C (0x003C - 0x0000)
struct alignas(0x04) FMantleStandData final
{
public:
	uint8                                         Pad_0[0x3C];                                       // 0x0000(0x003C)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FMantleStandData) == 0x000004, "Wrong alignment on FMantleStandData");
static_assert(sizeof(FMantleStandData) == 0x00003C, "Wrong size on FMantleStandData");

// ScriptStruct GbxGameSystemCore.CachedStoppingInfo
// 0x0014 (0x0014 - 0x0000)
struct alignas(0x04) FCachedStoppingInfo final
{
public:
	uint8                                         Pad_0[0x14];                                       // 0x0000(0x0014)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FCachedStoppingInfo) == 0x000004, "Wrong alignment on FCachedStoppingInfo");
static_assert(sizeof(FCachedStoppingInfo) == 0x000014, "Wrong size on FCachedStoppingInfo");

// ScriptStruct GbxGameSystemCore.StopDistanceMatchingInfo
// 0x0050 (0x00C0 - 0x0070)
struct FStopDistanceMatchingInfo final : public FDistanceMatchingInfo
{
public:
	TMap<int32, struct FCachedStoppingInfo>       StoppingInfoMap;                                   // 0x0070(0x0050)(ZeroConstructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(FStopDistanceMatchingInfo) == 0x000008, "Wrong alignment on FStopDistanceMatchingInfo");
static_assert(sizeof(FStopDistanceMatchingInfo) == 0x0000C0, "Wrong size on FStopDistanceMatchingInfo");
static_assert(offsetof(FStopDistanceMatchingInfo, StoppingInfoMap) == 0x000070, "Member 'FStopDistanceMatchingInfo::StoppingInfoMap' has a wrong offset!");

// ScriptStruct GbxGameSystemCore.MaterialArray
// 0x0010 (0x0010 - 0x0000)
struct FMaterialArray final
{
public:
	TArray<class UMaterialInterface*>             Materials;                                         // 0x0000(0x0010)(ZeroConstructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(FMaterialArray) == 0x000008, "Wrong alignment on FMaterialArray");
static_assert(sizeof(FMaterialArray) == 0x000010, "Wrong size on FMaterialArray");
static_assert(offsetof(FMaterialArray, Materials) == 0x000000, "Member 'FMaterialArray::Materials' has a wrong offset!");

// ScriptStruct GbxGameSystemCore.CustomizationLinkedParameterEntry
// 0x0030 (0x0030 - 0x0000)
struct FCustomizationLinkedParameterEntry final
{
public:
	TArray<struct FCustomizationLinkedParameter>  LinkedParameters;                                  // 0x0000(0x0010)(Edit, ZeroConstructor, NativeAccessSpecifierPublic)
	class UGbxCustomizationTargetData*            LinkedParameterSource;                             // 0x0010(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UGbxCustomizationTargetData*            LinkedParameterTarget;                             // 0x0018(0x0008)(ZeroConstructor, Deprecated, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TArray<class UGbxCustomizationTargetData*>    LinkedParameterTargets;                            // 0x0020(0x0010)(Edit, ZeroConstructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(FCustomizationLinkedParameterEntry) == 0x000008, "Wrong alignment on FCustomizationLinkedParameterEntry");
static_assert(sizeof(FCustomizationLinkedParameterEntry) == 0x000030, "Wrong size on FCustomizationLinkedParameterEntry");
static_assert(offsetof(FCustomizationLinkedParameterEntry, LinkedParameters) == 0x000000, "Member 'FCustomizationLinkedParameterEntry::LinkedParameters' has a wrong offset!");
static_assert(offsetof(FCustomizationLinkedParameterEntry, LinkedParameterSource) == 0x000010, "Member 'FCustomizationLinkedParameterEntry::LinkedParameterSource' has a wrong offset!");
static_assert(offsetof(FCustomizationLinkedParameterEntry, LinkedParameterTarget) == 0x000018, "Member 'FCustomizationLinkedParameterEntry::LinkedParameterTarget' has a wrong offset!");
static_assert(offsetof(FCustomizationLinkedParameterEntry, LinkedParameterTargets) == 0x000020, "Member 'FCustomizationLinkedParameterEntry::LinkedParameterTargets' has a wrong offset!");

// ScriptStruct GbxGameSystemCore.CustomizationColorEntry
// 0x0038 (0x0038 - 0x0000)
struct FCustomizationColorEntry final
{
public:
	TArray<class UGbxCustomizationTargetData*>    ColorCustomizationTargets;                         // 0x0000(0x0010)(Edit, ZeroConstructor, NativeAccessSpecifierPublic)
	class FName                                   ColorCustomizationParameter;                       // 0x0010(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   SplitColorCustomizationParameter;                  // 0x0018(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FText                                   ColorCustomizationDisplayName;                     // 0x0020(0x0018)(Edit, NativeAccessSpecifierPublic)
};
static_assert(alignof(FCustomizationColorEntry) == 0x000008, "Wrong alignment on FCustomizationColorEntry");
static_assert(sizeof(FCustomizationColorEntry) == 0x000038, "Wrong size on FCustomizationColorEntry");
static_assert(offsetof(FCustomizationColorEntry, ColorCustomizationTargets) == 0x000000, "Member 'FCustomizationColorEntry::ColorCustomizationTargets' has a wrong offset!");
static_assert(offsetof(FCustomizationColorEntry, ColorCustomizationParameter) == 0x000010, "Member 'FCustomizationColorEntry::ColorCustomizationParameter' has a wrong offset!");
static_assert(offsetof(FCustomizationColorEntry, SplitColorCustomizationParameter) == 0x000018, "Member 'FCustomizationColorEntry::SplitColorCustomizationParameter' has a wrong offset!");
static_assert(offsetof(FCustomizationColorEntry, ColorCustomizationDisplayName) == 0x000020, "Member 'FCustomizationColorEntry::ColorCustomizationDisplayName' has a wrong offset!");

// ScriptStruct GbxGameSystemCore.GbxCustomizationCacheEntry
// 0x0018 (0x0018 - 0x0000)
struct FGbxCustomizationCacheEntry final
{
public:
	TArray<class UObject*>                        AssetRefs;                                         // 0x0000(0x0010)(ZeroConstructor, NativeAccessSpecifierPublic)
	class UGbxCustomizationData*                  CustomizationData;                                 // 0x0010(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FGbxCustomizationCacheEntry) == 0x000008, "Wrong alignment on FGbxCustomizationCacheEntry");
static_assert(sizeof(FGbxCustomizationCacheEntry) == 0x000018, "Wrong size on FGbxCustomizationCacheEntry");
static_assert(offsetof(FGbxCustomizationCacheEntry, AssetRefs) == 0x000000, "Member 'FGbxCustomizationCacheEntry::AssetRefs' has a wrong offset!");
static_assert(offsetof(FGbxCustomizationCacheEntry, CustomizationData) == 0x000010, "Member 'FGbxCustomizationCacheEntry::CustomizationData' has a wrong offset!");

// ScriptStruct GbxGameSystemCore.GbxCustomizationContainer
// 0x0028 (0x00D8 - 0x00B0)
struct FGbxCustomizationContainer final : public FFastArraySerializer
{
public:
	TArray<struct FGbxCustomizationContainerEntry> Customizations;                                    // 0x00B0(0x0010)(ZeroConstructor, NativeAccessSpecifierPublic)
	TArray<struct FGbxCustomizationCacheEntry>    CustomizationCache;                                // 0x00C0(0x0010)(ZeroConstructor, RepSkip, NativeAccessSpecifierPublic)
	class UGbxCustomizationComponent*             Owner;                                             // 0x00D0(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, RepSkip, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FGbxCustomizationContainer) == 0x000008, "Wrong alignment on FGbxCustomizationContainer");
static_assert(sizeof(FGbxCustomizationContainer) == 0x0000D8, "Wrong size on FGbxCustomizationContainer");
static_assert(offsetof(FGbxCustomizationContainer, Customizations) == 0x0000B0, "Member 'FGbxCustomizationContainer::Customizations' has a wrong offset!");
static_assert(offsetof(FGbxCustomizationContainer, CustomizationCache) == 0x0000C0, "Member 'FGbxCustomizationContainer::CustomizationCache' has a wrong offset!");
static_assert(offsetof(FGbxCustomizationContainer, Owner) == 0x0000D0, "Member 'FGbxCustomizationContainer::Owner' has a wrong offset!");

// ScriptStruct GbxGameSystemCore.CustomizationAssetInfo
// 0x0020 (0x0020 - 0x0000)
struct FCustomizationAssetInfo final
{
public:
	class FName                                   AssetReferenceTargetName;                          // 0x0000(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FSoftObjectPath                        AssetReference;                                    // 0x0008(0x0018)(Edit, DisableEditOnInstance, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FCustomizationAssetInfo) == 0x000008, "Wrong alignment on FCustomizationAssetInfo");
static_assert(sizeof(FCustomizationAssetInfo) == 0x000020, "Wrong size on FCustomizationAssetInfo");
static_assert(offsetof(FCustomizationAssetInfo, AssetReferenceTargetName) == 0x000000, "Member 'FCustomizationAssetInfo::AssetReferenceTargetName' has a wrong offset!");
static_assert(offsetof(FCustomizationAssetInfo, AssetReference) == 0x000008, "Member 'FCustomizationAssetInfo::AssetReference' has a wrong offset!");

// ScriptStruct GbxGameSystemCore.CustomizationAssetEntry
// 0x0040 (0x0040 - 0x0000)
struct FCustomizationAssetEntry final
{
public:
	class UGbxCustomizationTargetData*            CustomizationTarget;                               // 0x0000(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TArray<struct FSoftObjectPath>                CustomizationAssetReferences;                      // 0x0008(0x0010)(ZeroConstructor, Deprecated, NativeAccessSpecifierPublic)
	TArray<struct FCustomizationAssetInfo>        CustomizationAssetInfoReferences;                  // 0x0018(0x0010)(Edit, ZeroConstructor, DisableEditOnInstance, NativeAccessSpecifierPublic)
	TArray<struct FSoftClassPath>                 CustomizationClassReferences;                      // 0x0028(0x0010)(Edit, ZeroConstructor, DisableEditOnInstance, NativeAccessSpecifierPublic)
	bool                                          LoadForPreview;                                    // 0x0038(0x0001)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_39[0x7];                                       // 0x0039(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FCustomizationAssetEntry) == 0x000008, "Wrong alignment on FCustomizationAssetEntry");
static_assert(sizeof(FCustomizationAssetEntry) == 0x000040, "Wrong size on FCustomizationAssetEntry");
static_assert(offsetof(FCustomizationAssetEntry, CustomizationTarget) == 0x000000, "Member 'FCustomizationAssetEntry::CustomizationTarget' has a wrong offset!");
static_assert(offsetof(FCustomizationAssetEntry, CustomizationAssetReferences) == 0x000008, "Member 'FCustomizationAssetEntry::CustomizationAssetReferences' has a wrong offset!");
static_assert(offsetof(FCustomizationAssetEntry, CustomizationAssetInfoReferences) == 0x000018, "Member 'FCustomizationAssetEntry::CustomizationAssetInfoReferences' has a wrong offset!");
static_assert(offsetof(FCustomizationAssetEntry, CustomizationClassReferences) == 0x000028, "Member 'FCustomizationAssetEntry::CustomizationClassReferences' has a wrong offset!");
static_assert(offsetof(FCustomizationAssetEntry, LoadForPreview) == 0x000038, "Member 'FCustomizationAssetEntry::LoadForPreview' has a wrong offset!");

// ScriptStruct GbxGameSystemCore.DamageSurfaceModifier
// 0x0040 (0x0040 - 0x0000)
struct FDamageSurfaceModifier final
{
public:
	EDamageSurfaceType                            PhysicalSurface;                                   // 0x0000(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1[0x7];                                        // 0x0001(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	struct FAttributeInitializationData           Modifier;                                          // 0x0008(0x0038)(Edit, NoDestructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(FDamageSurfaceModifier) == 0x000008, "Wrong alignment on FDamageSurfaceModifier");
static_assert(sizeof(FDamageSurfaceModifier) == 0x000040, "Wrong size on FDamageSurfaceModifier");
static_assert(offsetof(FDamageSurfaceModifier, PhysicalSurface) == 0x000000, "Member 'FDamageSurfaceModifier::PhysicalSurface' has a wrong offset!");
static_assert(offsetof(FDamageSurfaceModifier, Modifier) == 0x000008, "Member 'FDamageSurfaceModifier::Modifier' has a wrong offset!");

// ScriptStruct GbxGameSystemCore.ActiveGbxFeedbackEffect
// 0x0068 (0x0068 - 0x0000)
struct FActiveGbxFeedbackEffect final
{
public:
	class UGbxFeedbackData*                       ActiveData;                                        // 0x0000(0x0008)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TWeakObjectPtr<class AGbxPlayerController>    Controller;                                        // 0x0008(0x0008)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_10[0x38];                                      // 0x0010(0x0038)(Fixing Size After Last Property [ Dumper-7 ])
	TWeakObjectPtr<class UObject>                 SourceContext;                                     // 0x0048(0x0008)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_50[0x18];                                      // 0x0050(0x0018)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FActiveGbxFeedbackEffect) == 0x000008, "Wrong alignment on FActiveGbxFeedbackEffect");
static_assert(sizeof(FActiveGbxFeedbackEffect) == 0x000068, "Wrong size on FActiveGbxFeedbackEffect");
static_assert(offsetof(FActiveGbxFeedbackEffect, ActiveData) == 0x000000, "Member 'FActiveGbxFeedbackEffect::ActiveData' has a wrong offset!");
static_assert(offsetof(FActiveGbxFeedbackEffect, Controller) == 0x000008, "Member 'FActiveGbxFeedbackEffect::Controller' has a wrong offset!");
static_assert(offsetof(FActiveGbxFeedbackEffect, SourceContext) == 0x000048, "Member 'FActiveGbxFeedbackEffect::SourceContext' has a wrong offset!");

// ScriptStruct GbxGameSystemCore.GbxFlag
// 0x000C (0x000C - 0x0000)
struct alignas(0x04) FGbxFlag final
{
public:
	uint8                                         Pad_0[0xC];                                        // 0x0000(0x000C)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FGbxFlag) == 0x000004, "Wrong alignment on FGbxFlag");
static_assert(sizeof(FGbxFlag) == 0x00000C, "Wrong size on FGbxFlag");

// ScriptStruct GbxGameSystemCore.GbxFlagEval
// 0x0048 (0x0048 - 0x0000)
struct FGbxFlagEval final
{
public:
	class UGbxFlagData*                           FlagData;                                          // 0x0000(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	EGbxFlagEval                                  EvalType;                                          // 0x0008(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_9[0x7];                                        // 0x0009(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	struct FAttributeInitializationData           TimeSeconds;                                       // 0x0010(0x0038)(Edit, NoDestructor, NativeAccessSpecifierPrivate)
};
static_assert(alignof(FGbxFlagEval) == 0x000008, "Wrong alignment on FGbxFlagEval");
static_assert(sizeof(FGbxFlagEval) == 0x000048, "Wrong size on FGbxFlagEval");
static_assert(offsetof(FGbxFlagEval, FlagData) == 0x000000, "Member 'FGbxFlagEval::FlagData' has a wrong offset!");
static_assert(offsetof(FGbxFlagEval, EvalType) == 0x000008, "Member 'FGbxFlagEval::EvalType' has a wrong offset!");
static_assert(offsetof(FGbxFlagEval, TimeSeconds) == 0x000010, "Member 'FGbxFlagEval::TimeSeconds' has a wrong offset!");

// ScriptStruct GbxGameSystemCore.FlagPropertyTestStruct
// 0x000C (0x000C - 0x0000)
struct FFlagPropertyTestStruct final
{
public:
	struct FGbxFlag                               TestFlag;                                          // 0x0000(0x000C)(NoDestructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(FFlagPropertyTestStruct) == 0x000004, "Wrong alignment on FFlagPropertyTestStruct");
static_assert(sizeof(FFlagPropertyTestStruct) == 0x00000C, "Wrong size on FFlagPropertyTestStruct");
static_assert(offsetof(FFlagPropertyTestStruct, TestFlag) == 0x000000, "Member 'FFlagPropertyTestStruct::TestFlag' has a wrong offset!");

// ScriptStruct GbxGameSystemCore.SharedPickupInventoryActor
// 0x0010 (0x0010 - 0x0000)
struct FSharedPickupInventoryActor final
{
public:
	class AActor*                                 Actor;                                             // 0x0000(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_8[0x8];                                        // 0x0008(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FSharedPickupInventoryActor) == 0x000008, "Wrong alignment on FSharedPickupInventoryActor");
static_assert(sizeof(FSharedPickupInventoryActor) == 0x000010, "Wrong size on FSharedPickupInventoryActor");
static_assert(offsetof(FSharedPickupInventoryActor, Actor) == 0x000000, "Member 'FSharedPickupInventoryActor::Actor' has a wrong offset!");

// ScriptStruct GbxGameSystemCore.MenuStash
// 0x0010 (0x0010 - 0x0000)
struct FMenuStash final
{
public:
	TArray<class UBaseMenuStackMenuInfo*>         StashedMenus;                                      // 0x0000(0x0010)(ZeroConstructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(FMenuStash) == 0x000008, "Wrong alignment on FMenuStash");
static_assert(sizeof(FMenuStash) == 0x000010, "Wrong size on FMenuStash");
static_assert(offsetof(FMenuStash, StashedMenus) == 0x000000, "Member 'FMenuStash::StashedMenus' has a wrong offset!");

// ScriptStruct GbxGameSystemCore.GbxHUDFeedbackImpulse
// 0x0060 (0x0060 - 0x0000)
struct alignas(0x08) FGbxHUDFeedbackImpulse final
{
public:
	struct FVector                                Velocity;                                          // 0x0000(0x000C)(Edit, BlueprintVisible, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         RotationalVelocity;                                // 0x000C(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         Springiness;                                       // 0x0010(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         Damping;                                           // 0x0014(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bCircularMotion;                                   // 0x0018(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bApplyCameraTranslation;                           // 0x0019(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1A[0x2];                                       // 0x001A(0x0002)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         CameraTranslationWeight;                           // 0x001C(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bApplyCameraRotation;                              // 0x0020(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_21[0x3];                                       // 0x0021(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         CameraRotationWeight;                              // 0x0024(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bApplyOriginWorldSpace;                            // 0x0028(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_29[0x3];                                       // 0x0029(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	struct FVector                                OriginWorldSpace;                                  // 0x002C(0x000C)(Edit, BlueprintVisible, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         OriginWorldSpaceWeight;                            // 0x0038(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_3C[0x4];                                       // 0x003C(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class FName                                   Tag;                                               // 0x0040(0x0008)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_48[0x18];                                      // 0x0048(0x0018)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FGbxHUDFeedbackImpulse) == 0x000008, "Wrong alignment on FGbxHUDFeedbackImpulse");
static_assert(sizeof(FGbxHUDFeedbackImpulse) == 0x000060, "Wrong size on FGbxHUDFeedbackImpulse");
static_assert(offsetof(FGbxHUDFeedbackImpulse, Velocity) == 0x000000, "Member 'FGbxHUDFeedbackImpulse::Velocity' has a wrong offset!");
static_assert(offsetof(FGbxHUDFeedbackImpulse, RotationalVelocity) == 0x00000C, "Member 'FGbxHUDFeedbackImpulse::RotationalVelocity' has a wrong offset!");
static_assert(offsetof(FGbxHUDFeedbackImpulse, Springiness) == 0x000010, "Member 'FGbxHUDFeedbackImpulse::Springiness' has a wrong offset!");
static_assert(offsetof(FGbxHUDFeedbackImpulse, Damping) == 0x000014, "Member 'FGbxHUDFeedbackImpulse::Damping' has a wrong offset!");
static_assert(offsetof(FGbxHUDFeedbackImpulse, bCircularMotion) == 0x000018, "Member 'FGbxHUDFeedbackImpulse::bCircularMotion' has a wrong offset!");
static_assert(offsetof(FGbxHUDFeedbackImpulse, bApplyCameraTranslation) == 0x000019, "Member 'FGbxHUDFeedbackImpulse::bApplyCameraTranslation' has a wrong offset!");
static_assert(offsetof(FGbxHUDFeedbackImpulse, CameraTranslationWeight) == 0x00001C, "Member 'FGbxHUDFeedbackImpulse::CameraTranslationWeight' has a wrong offset!");
static_assert(offsetof(FGbxHUDFeedbackImpulse, bApplyCameraRotation) == 0x000020, "Member 'FGbxHUDFeedbackImpulse::bApplyCameraRotation' has a wrong offset!");
static_assert(offsetof(FGbxHUDFeedbackImpulse, CameraRotationWeight) == 0x000024, "Member 'FGbxHUDFeedbackImpulse::CameraRotationWeight' has a wrong offset!");
static_assert(offsetof(FGbxHUDFeedbackImpulse, bApplyOriginWorldSpace) == 0x000028, "Member 'FGbxHUDFeedbackImpulse::bApplyOriginWorldSpace' has a wrong offset!");
static_assert(offsetof(FGbxHUDFeedbackImpulse, OriginWorldSpace) == 0x00002C, "Member 'FGbxHUDFeedbackImpulse::OriginWorldSpace' has a wrong offset!");
static_assert(offsetof(FGbxHUDFeedbackImpulse, OriginWorldSpaceWeight) == 0x000038, "Member 'FGbxHUDFeedbackImpulse::OriginWorldSpaceWeight' has a wrong offset!");
static_assert(offsetof(FGbxHUDFeedbackImpulse, Tag) == 0x000040, "Member 'FGbxHUDFeedbackImpulse::Tag' has a wrong offset!");

// ScriptStruct GbxGameSystemCore.RigidBodyImpactSettings
// 0x00B0 (0x00B0 - 0x0000)
struct FRigidBodyImpactSettings final
{
public:
	TMap<struct FPhysicalMaterialImpactPair, class UImpactData*> RigidBodyImpactData;                               // 0x0000(0x0050)(Edit, ZeroConstructor, NativeAccessSpecifierPublic)
	TMap<class UPhysicalMaterial*, class UImpactData*> DefaultRigidBodyImpactData;                        // 0x0050(0x0050)(Edit, ZeroConstructor, NativeAccessSpecifierPublic)
	class UWwiseRtpc*                             ImpactSpeedAudioParameter;                         // 0x00A0(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UWwiseRtpc*                             ImpactMassAudioParameter;                          // 0x00A8(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FRigidBodyImpactSettings) == 0x000008, "Wrong alignment on FRigidBodyImpactSettings");
static_assert(sizeof(FRigidBodyImpactSettings) == 0x0000B0, "Wrong size on FRigidBodyImpactSettings");
static_assert(offsetof(FRigidBodyImpactSettings, RigidBodyImpactData) == 0x000000, "Member 'FRigidBodyImpactSettings::RigidBodyImpactData' has a wrong offset!");
static_assert(offsetof(FRigidBodyImpactSettings, DefaultRigidBodyImpactData) == 0x000050, "Member 'FRigidBodyImpactSettings::DefaultRigidBodyImpactData' has a wrong offset!");
static_assert(offsetof(FRigidBodyImpactSettings, ImpactSpeedAudioParameter) == 0x0000A0, "Member 'FRigidBodyImpactSettings::ImpactSpeedAudioParameter' has a wrong offset!");
static_assert(offsetof(FRigidBodyImpactSettings, ImpactMassAudioParameter) == 0x0000A8, "Member 'FRigidBodyImpactSettings::ImpactMassAudioParameter' has a wrong offset!");

// ScriptStruct GbxGameSystemCore.DestructionForceSmoothing
// 0x000C (0x000C - 0x0000)
struct FDestructionForceSmoothing final
{
public:
	float                                         MaxResultantVelocity;                              // 0x0000(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         NormalizationFactor;                               // 0x0004(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         GlobalScale;                                       // 0x0008(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FDestructionForceSmoothing) == 0x000004, "Wrong alignment on FDestructionForceSmoothing");
static_assert(sizeof(FDestructionForceSmoothing) == 0x00000C, "Wrong size on FDestructionForceSmoothing");
static_assert(offsetof(FDestructionForceSmoothing, MaxResultantVelocity) == 0x000000, "Member 'FDestructionForceSmoothing::MaxResultantVelocity' has a wrong offset!");
static_assert(offsetof(FDestructionForceSmoothing, NormalizationFactor) == 0x000004, "Member 'FDestructionForceSmoothing::NormalizationFactor' has a wrong offset!");
static_assert(offsetof(FDestructionForceSmoothing, GlobalScale) == 0x000008, "Member 'FDestructionForceSmoothing::GlobalScale' has a wrong offset!");

// ScriptStruct GbxGameSystemCore.HitRegionState
// 0x0070 (0x0070 - 0x0000)
struct FHitRegionState final
{
public:
	class UHitRegionData*                         HitRegion;                                         // 0x0000(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TArray<class FName>                           AssociatedComponentNames;                          // 0x0008(0x0010)(Edit, ZeroConstructor, DisableEditOnInstance, NativeAccessSpecifierPublic)
	TArray<struct FDamageReactionEvent>           DamageEvents;                                      // 0x0018(0x0010)(Edit, ZeroConstructor, DisableEditOnInstance, ContainsInstancedReference, NativeAccessSpecifierPublic)
	int32                                         StateIndex;                                        // 0x0028(0x0004)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2C[0x4];                                       // 0x002C(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<class UPrimitiveComponent*>            AssociatedPrimitives;                              // 0x0030(0x0010)(ExportObject, ZeroConstructor, Transient, ContainsInstancedReference, NativeAccessSpecifierPublic)
	TArray<class UChildActorComponent*>           AssociatedChildActorComponents;                    // 0x0040(0x0010)(ExportObject, ZeroConstructor, Transient, ContainsInstancedReference, NativeAccessSpecifierPublic)
	float                                         MaxHealth;                                         // 0x0050(0x0004)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	float                                         CurrentHealth;                                     // 0x0054(0x0004)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	struct FGameResourcePoolReference             ResourcePool;                                      // 0x0058(0x0018)(Transient, NoDestructor, ContainsInstancedReference, NativeAccessSpecifierPrivate)
};
static_assert(alignof(FHitRegionState) == 0x000008, "Wrong alignment on FHitRegionState");
static_assert(sizeof(FHitRegionState) == 0x000070, "Wrong size on FHitRegionState");
static_assert(offsetof(FHitRegionState, HitRegion) == 0x000000, "Member 'FHitRegionState::HitRegion' has a wrong offset!");
static_assert(offsetof(FHitRegionState, AssociatedComponentNames) == 0x000008, "Member 'FHitRegionState::AssociatedComponentNames' has a wrong offset!");
static_assert(offsetof(FHitRegionState, DamageEvents) == 0x000018, "Member 'FHitRegionState::DamageEvents' has a wrong offset!");
static_assert(offsetof(FHitRegionState, StateIndex) == 0x000028, "Member 'FHitRegionState::StateIndex' has a wrong offset!");
static_assert(offsetof(FHitRegionState, AssociatedPrimitives) == 0x000030, "Member 'FHitRegionState::AssociatedPrimitives' has a wrong offset!");
static_assert(offsetof(FHitRegionState, AssociatedChildActorComponents) == 0x000040, "Member 'FHitRegionState::AssociatedChildActorComponents' has a wrong offset!");
static_assert(offsetof(FHitRegionState, MaxHealth) == 0x000050, "Member 'FHitRegionState::MaxHealth' has a wrong offset!");
static_assert(offsetof(FHitRegionState, CurrentHealth) == 0x000054, "Member 'FHitRegionState::CurrentHealth' has a wrong offset!");
static_assert(offsetof(FHitRegionState, ResourcePool) == 0x000058, "Member 'FHitRegionState::ResourcePool' has a wrong offset!");

// ScriptStruct GbxGameSystemCore.SurfaceTypeInfo
// 0x0010 (0x0010 - 0x0000)
struct FSurfaceTypeInfo final
{
public:
	EDamageSurfaceType                            DamageSurfaceType;                                 // 0x0000(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1[0x7];                                        // 0x0001(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	class UWwiseSwitch*                           AudioMaterialSwitch;                               // 0x0008(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FSurfaceTypeInfo) == 0x000008, "Wrong alignment on FSurfaceTypeInfo");
static_assert(sizeof(FSurfaceTypeInfo) == 0x000010, "Wrong size on FSurfaceTypeInfo");
static_assert(offsetof(FSurfaceTypeInfo, DamageSurfaceType) == 0x000000, "Member 'FSurfaceTypeInfo::DamageSurfaceType' has a wrong offset!");
static_assert(offsetof(FSurfaceTypeInfo, AudioMaterialSwitch) == 0x000008, "Member 'FSurfaceTypeInfo::AudioMaterialSwitch' has a wrong offset!");

// ScriptStruct GbxGameSystemCore.RecentlyMetPlayer
// 0x0058 (0x0058 - 0x0000)
struct FRecentlyMetPlayer final
{
public:
	struct FUniqueNetIdRepl                       FirstPartyPlayerId;                                // 0x0000(0x0028)(HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FUniqueNetIdRepl                       ShiftPlayerId;                                     // 0x0028(0x0028)(HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bUseShiftId;                                       // 0x0050(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_51[0x7];                                       // 0x0051(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FRecentlyMetPlayer) == 0x000008, "Wrong alignment on FRecentlyMetPlayer");
static_assert(sizeof(FRecentlyMetPlayer) == 0x000058, "Wrong size on FRecentlyMetPlayer");
static_assert(offsetof(FRecentlyMetPlayer, FirstPartyPlayerId) == 0x000000, "Member 'FRecentlyMetPlayer::FirstPartyPlayerId' has a wrong offset!");
static_assert(offsetof(FRecentlyMetPlayer, ShiftPlayerId) == 0x000028, "Member 'FRecentlyMetPlayer::ShiftPlayerId' has a wrong offset!");
static_assert(offsetof(FRecentlyMetPlayer, bUseShiftId) == 0x000050, "Member 'FRecentlyMetPlayer::bUseShiftId' has a wrong offset!");

// ScriptStruct GbxGameSystemCore.PlayerInputBinding_Category
// 0x0040 (0x0040 - 0x0000)
struct FPlayerInputBinding_Category final
{
public:
	class FString                                 CategoryDataPath;                                  // 0x0000(0x0010)(ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FString                                 ContextDataPath;                                   // 0x0010(0x0010)(ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TArray<struct FPlayerInputBinding_Button>     ButtonBindings;                                    // 0x0020(0x0010)(ZeroConstructor, NativeAccessSpecifierPublic)
	TArray<struct FPlayerInputBinding_Axis>       AxisBindings;                                      // 0x0030(0x0010)(ZeroConstructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(FPlayerInputBinding_Category) == 0x000008, "Wrong alignment on FPlayerInputBinding_Category");
static_assert(sizeof(FPlayerInputBinding_Category) == 0x000040, "Wrong size on FPlayerInputBinding_Category");
static_assert(offsetof(FPlayerInputBinding_Category, CategoryDataPath) == 0x000000, "Member 'FPlayerInputBinding_Category::CategoryDataPath' has a wrong offset!");
static_assert(offsetof(FPlayerInputBinding_Category, ContextDataPath) == 0x000010, "Member 'FPlayerInputBinding_Category::ContextDataPath' has a wrong offset!");
static_assert(offsetof(FPlayerInputBinding_Category, ButtonBindings) == 0x000020, "Member 'FPlayerInputBinding_Category::ButtonBindings' has a wrong offset!");
static_assert(offsetof(FPlayerInputBinding_Category, AxisBindings) == 0x000030, "Member 'FPlayerInputBinding_Category::AxisBindings' has a wrong offset!");

// ScriptStruct GbxGameSystemCore.PlayerInputBindings
// 0x0010 (0x0010 - 0x0000)
struct FPlayerInputBindings final
{
public:
	TArray<struct FPlayerInputBinding_Category>   Categories;                                        // 0x0000(0x0010)(ZeroConstructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(FPlayerInputBindings) == 0x000008, "Wrong alignment on FPlayerInputBindings");
static_assert(sizeof(FPlayerInputBindings) == 0x000010, "Wrong size on FPlayerInputBindings");
static_assert(offsetof(FPlayerInputBindings, Categories) == 0x000000, "Member 'FPlayerInputBindings::Categories' has a wrong offset!");

// ScriptStruct GbxGameSystemCore.GbxSignificanceEventData
// 0x0018 (0x0018 - 0x0000)
struct FGbxSignificanceEventData final
{
public:
	bool                                          bTestVisibility;                                   // 0x0000(0x0001)(Edit, ZeroConstructor, Config, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1[0x3];                                        // 0x0001(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         AlwaysSignificantDistance;                         // 0x0004(0x0004)(Edit, ZeroConstructor, Config, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         MaxDistance;                                       // 0x0008(0x0004)(Edit, ZeroConstructor, Config, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         MinScreenPercent;                                  // 0x000C(0x0004)(Edit, ZeroConstructor, Config, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         DistantThreshold;                                  // 0x0010(0x0004)(Edit, ZeroConstructor, Config, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         PlayerSourceInfluence;                             // 0x0014(0x0004)(Edit, ZeroConstructor, Config, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FGbxSignificanceEventData) == 0x000004, "Wrong alignment on FGbxSignificanceEventData");
static_assert(sizeof(FGbxSignificanceEventData) == 0x000018, "Wrong size on FGbxSignificanceEventData");
static_assert(offsetof(FGbxSignificanceEventData, bTestVisibility) == 0x000000, "Member 'FGbxSignificanceEventData::bTestVisibility' has a wrong offset!");
static_assert(offsetof(FGbxSignificanceEventData, AlwaysSignificantDistance) == 0x000004, "Member 'FGbxSignificanceEventData::AlwaysSignificantDistance' has a wrong offset!");
static_assert(offsetof(FGbxSignificanceEventData, MaxDistance) == 0x000008, "Member 'FGbxSignificanceEventData::MaxDistance' has a wrong offset!");
static_assert(offsetof(FGbxSignificanceEventData, MinScreenPercent) == 0x00000C, "Member 'FGbxSignificanceEventData::MinScreenPercent' has a wrong offset!");
static_assert(offsetof(FGbxSignificanceEventData, DistantThreshold) == 0x000010, "Member 'FGbxSignificanceEventData::DistantThreshold' has a wrong offset!");
static_assert(offsetof(FGbxSignificanceEventData, PlayerSourceInfluence) == 0x000014, "Member 'FGbxSignificanceEventData::PlayerSourceInfluence' has a wrong offset!");

// ScriptStruct GbxGameSystemCore.SimpleMotionInstanceState
// 0x0008 (0x0008 - 0x0000)
struct FSimpleMotionInstanceState final
{
public:
	float                                         Speed;                                             // 0x0000(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         bMotionReversed : 1;                               // 0x0004(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (BlueprintVisible, BlueprintReadOnly, Transient, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         bReachedTarget : 1;                                // 0x0004(0x0001)(BitIndex: 0x01, PropSize: 0x0001 (BlueprintVisible, BlueprintReadOnly, Transient, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         bReachedMaxSpeed : 1;                              // 0x0004(0x0001)(BitIndex: 0x02, PropSize: 0x0001 (BlueprintVisible, BlueprintReadOnly, Transient, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         bInTransition : 1;                                 // 0x0004(0x0001)(BitIndex: 0x03, PropSize: 0x0001 (BlueprintVisible, BlueprintReadOnly, Transient, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         Pad_5[0x3];                                        // 0x0005(0x0003)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FSimpleMotionInstanceState) == 0x000004, "Wrong alignment on FSimpleMotionInstanceState");
static_assert(sizeof(FSimpleMotionInstanceState) == 0x000008, "Wrong size on FSimpleMotionInstanceState");
static_assert(offsetof(FSimpleMotionInstanceState, Speed) == 0x000000, "Member 'FSimpleMotionInstanceState::Speed' has a wrong offset!");

// ScriptStruct GbxGameSystemCore.GestaltChildPartData
// 0x0010 (0x0010 - 0x0000)
struct FGestaltChildPartData final
{
public:
	class UGestaltPartData*                       GestaltPart;                                       // 0x0000(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         Probability;                                       // 0x0008(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_C[0x4];                                        // 0x000C(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FGestaltChildPartData) == 0x000008, "Wrong alignment on FGestaltChildPartData");
static_assert(sizeof(FGestaltChildPartData) == 0x000010, "Wrong size on FGestaltChildPartData");
static_assert(offsetof(FGestaltChildPartData, GestaltPart) == 0x000000, "Member 'FGestaltChildPartData::GestaltPart' has a wrong offset!");
static_assert(offsetof(FGestaltChildPartData, Probability) == 0x000008, "Member 'FGestaltChildPartData::Probability' has a wrong offset!");

// ScriptStruct GbxGameSystemCore.GestaltRandomPartData
// 0x0010 (0x0010 - 0x0000)
struct FGestaltRandomPartData final
{
public:
	class UGestaltPartData*                       GestaltPart;                                       // 0x0000(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         Weight;                                            // 0x0008(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_C[0x4];                                        // 0x000C(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FGestaltRandomPartData) == 0x000008, "Wrong alignment on FGestaltRandomPartData");
static_assert(sizeof(FGestaltRandomPartData) == 0x000010, "Wrong size on FGestaltRandomPartData");
static_assert(offsetof(FGestaltRandomPartData, GestaltPart) == 0x000000, "Member 'FGestaltRandomPartData::GestaltPart' has a wrong offset!");
static_assert(offsetof(FGestaltRandomPartData, Weight) == 0x000008, "Member 'FGestaltRandomPartData::Weight' has a wrong offset!");

// ScriptStruct GbxGameSystemCore.BMPOverrideBone
// 0x0020 (0x0020 - 0x0000)
struct FBMPOverrideBone final
{
public:
	struct FBoneReference                         BoneRef;                                           // 0x0000(0x0018)(Edit, NoDestructor, NativeAccessSpecifierPublic)
	float                                         Scale;                                             // 0x0018(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1C[0x4];                                       // 0x001C(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FBMPOverrideBone) == 0x000008, "Wrong alignment on FBMPOverrideBone");
static_assert(sizeof(FBMPOverrideBone) == 0x000020, "Wrong size on FBMPOverrideBone");
static_assert(offsetof(FBMPOverrideBone, BoneRef) == 0x000000, "Member 'FBMPOverrideBone::BoneRef' has a wrong offset!");
static_assert(offsetof(FBMPOverrideBone, Scale) == 0x000018, "Member 'FBMPOverrideBone::Scale' has a wrong offset!");

// ScriptStruct GbxGameSystemCore.BMPOverride
// 0x0018 (0x0018 - 0x0000)
struct FBMPOverride final
{
public:
	TArray<struct FBMPOverrideBone>               Bones;                                             // 0x0000(0x0010)(Edit, ZeroConstructor, NativeAccessSpecifierPublic)
	EGlobalBoneModifyProfile_PoseMode             PoseMode;                                          // 0x0010(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_11[0x7];                                       // 0x0011(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FBMPOverride) == 0x000008, "Wrong alignment on FBMPOverride");
static_assert(sizeof(FBMPOverride) == 0x000018, "Wrong size on FBMPOverride");
static_assert(offsetof(FBMPOverride, Bones) == 0x000000, "Member 'FBMPOverride::Bones' has a wrong offset!");
static_assert(offsetof(FBMPOverride, PoseMode) == 0x000010, "Member 'FBMPOverride::PoseMode' has a wrong offset!");

// ScriptStruct GbxGameSystemCore.HitReactionPair
// 0x0010 (0x0010 - 0x0000)
struct FHitReactionPair final
{
public:
	class UHitReactionTag*                        Tag;                                               // 0x0000(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TSubclassOf<class UGbxAction>                 Action;                                            // 0x0008(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FHitReactionPair) == 0x000008, "Wrong alignment on FHitReactionPair");
static_assert(sizeof(FHitReactionPair) == 0x000010, "Wrong size on FHitReactionPair");
static_assert(offsetof(FHitReactionPair, Tag) == 0x000000, "Member 'FHitReactionPair::Tag' has a wrong offset!");
static_assert(offsetof(FHitReactionPair, Action) == 0x000008, "Member 'FHitReactionPair::Action' has a wrong offset!");

// ScriptStruct GbxGameSystemCore.HitReactionCondition
// 0x0010 (0x0010 - 0x0000)
struct FHitReactionCondition final
{
public:
	class UGbxCondition*                          Condition;                                         // 0x0000(0x0008)(Edit, ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, PersistentInstance, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EHitReactionConditionContext                  Context;                                           // 0x0008(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EHitReactionConditionContext                  OptionalContext;                                   // 0x0009(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_A[0x6];                                        // 0x000A(0x0006)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FHitReactionCondition) == 0x000008, "Wrong alignment on FHitReactionCondition");
static_assert(sizeof(FHitReactionCondition) == 0x000010, "Wrong size on FHitReactionCondition");
static_assert(offsetof(FHitReactionCondition, Condition) == 0x000000, "Member 'FHitReactionCondition::Condition' has a wrong offset!");
static_assert(offsetof(FHitReactionCondition, Context) == 0x000008, "Member 'FHitReactionCondition::Context' has a wrong offset!");
static_assert(offsetof(FHitReactionCondition, OptionalContext) == 0x000009, "Member 'FHitReactionCondition::OptionalContext' has a wrong offset!");

// ScriptStruct GbxGameSystemCore.TeamAttitudeSetEntry
// 0x0010 (0x0010 - 0x0000)
struct FTeamAttitudeSetEntry final
{
public:
	class UTeam*                                  OtherTeam;                                         // 0x0000(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	ETeamAttitude                                 Attitude;                                          // 0x0008(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_9[0x7];                                        // 0x0009(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FTeamAttitudeSetEntry) == 0x000008, "Wrong alignment on FTeamAttitudeSetEntry");
static_assert(sizeof(FTeamAttitudeSetEntry) == 0x000010, "Wrong size on FTeamAttitudeSetEntry");
static_assert(offsetof(FTeamAttitudeSetEntry, OtherTeam) == 0x000000, "Member 'FTeamAttitudeSetEntry::OtherTeam' has a wrong offset!");
static_assert(offsetof(FTeamAttitudeSetEntry, Attitude) == 0x000008, "Member 'FTeamAttitudeSetEntry::Attitude' has a wrong offset!");

// ScriptStruct GbxGameSystemCore.HitReactionCooldownData
// 0x0020 (0x0020 - 0x0000)
struct FHitReactionCooldownData final
{
public:
	class UHitReactionTag*                        Tag;                                               // 0x0000(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         Cooldown;                                          // 0x0008(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_C[0x4];                                        // 0x000C(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class UHitReactionTag*                        TagFallback;                                       // 0x0010(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bCooldownFromStartTime;                            // 0x0018(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_19[0x7];                                       // 0x0019(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FHitReactionCooldownData) == 0x000008, "Wrong alignment on FHitReactionCooldownData");
static_assert(sizeof(FHitReactionCooldownData) == 0x000020, "Wrong size on FHitReactionCooldownData");
static_assert(offsetof(FHitReactionCooldownData, Tag) == 0x000000, "Member 'FHitReactionCooldownData::Tag' has a wrong offset!");
static_assert(offsetof(FHitReactionCooldownData, Cooldown) == 0x000008, "Member 'FHitReactionCooldownData::Cooldown' has a wrong offset!");
static_assert(offsetof(FHitReactionCooldownData, TagFallback) == 0x000010, "Member 'FHitReactionCooldownData::TagFallback' has a wrong offset!");
static_assert(offsetof(FHitReactionCooldownData, bCooldownFromStartTime) == 0x000018, "Member 'FHitReactionCooldownData::bCooldownFromStartTime' has a wrong offset!");

// ScriptStruct GbxGameSystemCore.HitReactionMapItem
// 0x0010 (0x0010 - 0x0000)
struct FHitReactionMapItem final
{
public:
	class UHitReactionTag*                        FromTag;                                           // 0x0000(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UHitReactionTag*                        ToTag;                                             // 0x0008(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FHitReactionMapItem) == 0x000008, "Wrong alignment on FHitReactionMapItem");
static_assert(sizeof(FHitReactionMapItem) == 0x000010, "Wrong size on FHitReactionMapItem");
static_assert(offsetof(FHitReactionMapItem, FromTag) == 0x000000, "Member 'FHitReactionMapItem::FromTag' has a wrong offset!");
static_assert(offsetof(FHitReactionMapItem, ToTag) == 0x000008, "Member 'FHitReactionMapItem::ToTag' has a wrong offset!");

// ScriptStruct GbxGameSystemCore.HomingTargetedActorInfo
// 0x0010 (0x0010 - 0x0000)
struct FHomingTargetedActorInfo final
{
public:
	class AActor*                                 Target;                                            // 0x0000(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         ProjectileCount;                                   // 0x0008(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_C[0x4];                                        // 0x000C(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FHomingTargetedActorInfo) == 0x000008, "Wrong alignment on FHomingTargetedActorInfo");
static_assert(sizeof(FHomingTargetedActorInfo) == 0x000010, "Wrong size on FHomingTargetedActorInfo");
static_assert(offsetof(FHomingTargetedActorInfo, Target) == 0x000000, "Member 'FHomingTargetedActorInfo::Target' has a wrong offset!");
static_assert(offsetof(FHomingTargetedActorInfo, ProjectileCount) == 0x000008, "Member 'FHomingTargetedActorInfo::ProjectileCount' has a wrong offset!");

// ScriptStruct GbxGameSystemCore.InspectionInfo
// 0x0020 (0x0020 - 0x0000)
struct alignas(0x08) FInspectionInfo final
{
public:
	uint8                                         Pad_0[0x20];                                       // 0x0000(0x0020)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FInspectionInfo) == 0x000008, "Wrong alignment on FInspectionInfo");
static_assert(sizeof(FInspectionInfo) == 0x000020, "Wrong size on FInspectionInfo");

// ScriptStruct GbxGameSystemCore.ImpactTriggerInfo
// 0x0008 (0x0008 - 0x0000)
struct FImpactTriggerInfo final
{
public:
	float                                         RigidBodyRefireDelay;                              // 0x0000(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         RigidBodyMinimumVelocity;                          // 0x0004(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FImpactTriggerInfo) == 0x000004, "Wrong alignment on FImpactTriggerInfo");
static_assert(sizeof(FImpactTriggerInfo) == 0x000008, "Wrong size on FImpactTriggerInfo");
static_assert(offsetof(FImpactTriggerInfo, RigidBodyRefireDelay) == 0x000000, "Member 'FImpactTriggerInfo::RigidBodyRefireDelay' has a wrong offset!");
static_assert(offsetof(FImpactTriggerInfo, RigidBodyMinimumVelocity) == 0x000004, "Member 'FImpactTriggerInfo::RigidBodyMinimumVelocity' has a wrong offset!");

// ScriptStruct GbxGameSystemCore.ImpactFXManagerTrackingData
// 0x0010 (0x0010 - 0x0000)
struct FImpactFXManagerTrackingData final
{
public:
	class USceneComponent*                        Component;                                         // 0x0000(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UPhysicalMaterial*                      PhysicalMaterial;                                  // 0x0008(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FImpactFXManagerTrackingData) == 0x000008, "Wrong alignment on FImpactFXManagerTrackingData");
static_assert(sizeof(FImpactFXManagerTrackingData) == 0x000010, "Wrong size on FImpactFXManagerTrackingData");
static_assert(offsetof(FImpactFXManagerTrackingData, Component) == 0x000000, "Member 'FImpactFXManagerTrackingData::Component' has a wrong offset!");
static_assert(offsetof(FImpactFXManagerTrackingData, PhysicalMaterial) == 0x000008, "Member 'FImpactFXManagerTrackingData::PhysicalMaterial' has a wrong offset!");

// ScriptStruct GbxGameSystemCore.ModifierMathAttributeValueResolverStackEntry
// 0x0040 (0x0040 - 0x0000)
struct FModifierMathAttributeValueResolverStackEntry final
{
public:
	EGbxAttributeModifierType                     ModifierType;                                      // 0x0000(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1[0x7];                                        // 0x0001(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	struct FAttributeInitializationData           ModifierValue;                                     // 0x0008(0x0038)(Edit, NoDestructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(FModifierMathAttributeValueResolverStackEntry) == 0x000008, "Wrong alignment on FModifierMathAttributeValueResolverStackEntry");
static_assert(sizeof(FModifierMathAttributeValueResolverStackEntry) == 0x000040, "Wrong size on FModifierMathAttributeValueResolverStackEntry");
static_assert(offsetof(FModifierMathAttributeValueResolverStackEntry, ModifierType) == 0x000000, "Member 'FModifierMathAttributeValueResolverStackEntry::ModifierType' has a wrong offset!");
static_assert(offsetof(FModifierMathAttributeValueResolverStackEntry, ModifierValue) == 0x000008, "Member 'FModifierMathAttributeValueResolverStackEntry::ModifierValue' has a wrong offset!");

// ScriptStruct GbxGameSystemCore.OrbitOscillationInfo
// 0x0080 (0x0080 - 0x0000)
struct FOrbitOscillationInfo final
{
public:
	struct FRuntimeFloatCurve                     Cycle;                                             // 0x0000(0x0078)(Edit, NativeAccessSpecifierPublic)
	float                                         OverrideDuration;                                  // 0x0078(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         CurrentTime;                                       // 0x007C(0x0004)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FOrbitOscillationInfo) == 0x000008, "Wrong alignment on FOrbitOscillationInfo");
static_assert(sizeof(FOrbitOscillationInfo) == 0x000080, "Wrong size on FOrbitOscillationInfo");
static_assert(offsetof(FOrbitOscillationInfo, Cycle) == 0x000000, "Member 'FOrbitOscillationInfo::Cycle' has a wrong offset!");
static_assert(offsetof(FOrbitOscillationInfo, OverrideDuration) == 0x000078, "Member 'FOrbitOscillationInfo::OverrideDuration' has a wrong offset!");
static_assert(offsetof(FOrbitOscillationInfo, CurrentTime) == 0x00007C, "Member 'FOrbitOscillationInfo::CurrentTime' has a wrong offset!");

// ScriptStruct GbxGameSystemCore.PawnAttachmentQueryResult
// 0x0018 (0x0018 - 0x0000)
struct FPawnAttachmentQueryResult final
{
public:
	class APawn*                                  Pawn;                                              // 0x0000(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   SlotName;                                          // 0x0008(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class AActor*                                 AttachBase;                                        // 0x0010(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FPawnAttachmentQueryResult) == 0x000008, "Wrong alignment on FPawnAttachmentQueryResult");
static_assert(sizeof(FPawnAttachmentQueryResult) == 0x000018, "Wrong size on FPawnAttachmentQueryResult");
static_assert(offsetof(FPawnAttachmentQueryResult, Pawn) == 0x000000, "Member 'FPawnAttachmentQueryResult::Pawn' has a wrong offset!");
static_assert(offsetof(FPawnAttachmentQueryResult, SlotName) == 0x000008, "Member 'FPawnAttachmentQueryResult::SlotName' has a wrong offset!");
static_assert(offsetof(FPawnAttachmentQueryResult, AttachBase) == 0x000010, "Member 'FPawnAttachmentQueryResult::AttachBase' has a wrong offset!");

// ScriptStruct GbxGameSystemCore.PawnDetachTransition
// 0x0020 (0x0068 - 0x0048)
struct FPawnDetachTransition final : public FPawnAttachmentTransition
{
public:
	bool                                          bValidateDetachLocation;                           // 0x0048(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_49[0x3];                                       // 0x0049(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         ValidationMaxOffset;                               // 0x004C(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         ValidationToleranceSize;                           // 0x0050(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bComputeDetachLocationFromAction;                  // 0x0054(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bAbsoluteDetachLocation;                           // 0x0055(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_56[0x2];                                       // 0x0056(0x0002)(Fixing Size After Last Property [ Dumper-7 ])
	struct FVector                                DetachLocationOffset;                              // 0x0058(0x000C)(Edit, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_64[0x4];                                       // 0x0064(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FPawnDetachTransition) == 0x000008, "Wrong alignment on FPawnDetachTransition");
static_assert(sizeof(FPawnDetachTransition) == 0x000068, "Wrong size on FPawnDetachTransition");
static_assert(offsetof(FPawnDetachTransition, bValidateDetachLocation) == 0x000048, "Member 'FPawnDetachTransition::bValidateDetachLocation' has a wrong offset!");
static_assert(offsetof(FPawnDetachTransition, ValidationMaxOffset) == 0x00004C, "Member 'FPawnDetachTransition::ValidationMaxOffset' has a wrong offset!");
static_assert(offsetof(FPawnDetachTransition, ValidationToleranceSize) == 0x000050, "Member 'FPawnDetachTransition::ValidationToleranceSize' has a wrong offset!");
static_assert(offsetof(FPawnDetachTransition, bComputeDetachLocationFromAction) == 0x000054, "Member 'FPawnDetachTransition::bComputeDetachLocationFromAction' has a wrong offset!");
static_assert(offsetof(FPawnDetachTransition, bAbsoluteDetachLocation) == 0x000055, "Member 'FPawnDetachTransition::bAbsoluteDetachLocation' has a wrong offset!");
static_assert(offsetof(FPawnDetachTransition, DetachLocationOffset) == 0x000058, "Member 'FPawnDetachTransition::DetachLocationOffset' has a wrong offset!");

// ScriptStruct GbxGameSystemCore.PawnAttachTransition
// 0x0000 (0x0048 - 0x0048)
struct FPawnAttachTransition final : public FPawnAttachmentTransition
{
};
static_assert(alignof(FPawnAttachTransition) == 0x000008, "Wrong alignment on FPawnAttachTransition");
static_assert(sizeof(FPawnAttachTransition) == 0x000048, "Wrong size on FPawnAttachTransition");

// ScriptStruct GbxGameSystemCore.PropertyUtilsTestStruct
// 0x0078 (0x0078 - 0x0000)
struct FPropertyUtilsTestStruct final
{
public:
	float                                         FloatProp;                                         // 0x0000(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         FloatPropStaticArray[0x3];                         // 0x0004(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TArray<float>                                 FloatPropDynamicArray;                             // 0x0010(0x0010)(ZeroConstructor, NativeAccessSpecifierPublic)
	class UPropertyUtilsTestContext*              ObjectProp;                                        // 0x0020(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UPropertyUtilsTestContext*              ObjectPropStaticArray[0x3];                        // 0x0028(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TArray<class UPropertyUtilsTestContext*>      ObjectPropDynamicArray;                            // 0x0040(0x0010)(ZeroConstructor, NativeAccessSpecifierPublic)
	double                                        DoubleProp;                                        // 0x0050(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int8                                          Int8Prop;                                          // 0x0058(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         UInt8Prop;                                         // 0x0059(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int16                                         Int16Prop;                                         // 0x005A(0x0002)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint16                                        UInt16Prop;                                        // 0x005C(0x0002)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_5E[0x2];                                       // 0x005E(0x0002)(Fixing Size After Last Property [ Dumper-7 ])
	int32                                         Int32Prop;                                         // 0x0060(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint32                                        UInt32Prop;                                        // 0x0064(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int64                                         Int64Prop;                                         // 0x0068(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint64                                        UInt64Prop;                                        // 0x0070(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FPropertyUtilsTestStruct) == 0x000008, "Wrong alignment on FPropertyUtilsTestStruct");
static_assert(sizeof(FPropertyUtilsTestStruct) == 0x000078, "Wrong size on FPropertyUtilsTestStruct");
static_assert(offsetof(FPropertyUtilsTestStruct, FloatProp) == 0x000000, "Member 'FPropertyUtilsTestStruct::FloatProp' has a wrong offset!");
static_assert(offsetof(FPropertyUtilsTestStruct, FloatPropStaticArray) == 0x000004, "Member 'FPropertyUtilsTestStruct::FloatPropStaticArray' has a wrong offset!");
static_assert(offsetof(FPropertyUtilsTestStruct, FloatPropDynamicArray) == 0x000010, "Member 'FPropertyUtilsTestStruct::FloatPropDynamicArray' has a wrong offset!");
static_assert(offsetof(FPropertyUtilsTestStruct, ObjectProp) == 0x000020, "Member 'FPropertyUtilsTestStruct::ObjectProp' has a wrong offset!");
static_assert(offsetof(FPropertyUtilsTestStruct, ObjectPropStaticArray) == 0x000028, "Member 'FPropertyUtilsTestStruct::ObjectPropStaticArray' has a wrong offset!");
static_assert(offsetof(FPropertyUtilsTestStruct, ObjectPropDynamicArray) == 0x000040, "Member 'FPropertyUtilsTestStruct::ObjectPropDynamicArray' has a wrong offset!");
static_assert(offsetof(FPropertyUtilsTestStruct, DoubleProp) == 0x000050, "Member 'FPropertyUtilsTestStruct::DoubleProp' has a wrong offset!");
static_assert(offsetof(FPropertyUtilsTestStruct, Int8Prop) == 0x000058, "Member 'FPropertyUtilsTestStruct::Int8Prop' has a wrong offset!");
static_assert(offsetof(FPropertyUtilsTestStruct, UInt8Prop) == 0x000059, "Member 'FPropertyUtilsTestStruct::UInt8Prop' has a wrong offset!");
static_assert(offsetof(FPropertyUtilsTestStruct, Int16Prop) == 0x00005A, "Member 'FPropertyUtilsTestStruct::Int16Prop' has a wrong offset!");
static_assert(offsetof(FPropertyUtilsTestStruct, UInt16Prop) == 0x00005C, "Member 'FPropertyUtilsTestStruct::UInt16Prop' has a wrong offset!");
static_assert(offsetof(FPropertyUtilsTestStruct, Int32Prop) == 0x000060, "Member 'FPropertyUtilsTestStruct::Int32Prop' has a wrong offset!");
static_assert(offsetof(FPropertyUtilsTestStruct, UInt32Prop) == 0x000064, "Member 'FPropertyUtilsTestStruct::UInt32Prop' has a wrong offset!");
static_assert(offsetof(FPropertyUtilsTestStruct, Int64Prop) == 0x000068, "Member 'FPropertyUtilsTestStruct::Int64Prop' has a wrong offset!");
static_assert(offsetof(FPropertyUtilsTestStruct, UInt64Prop) == 0x000070, "Member 'FPropertyUtilsTestStruct::UInt64Prop' has a wrong offset!");

// ScriptStruct GbxGameSystemCore.ReferenceActorClasses
// 0x0020 (0x0020 - 0x0000)
struct FReferenceActorClasses final
{
public:
	class FName                                   Name;                                              // 0x0000(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FSoftObjectPath                        ActorAsset;                                        // 0x0008(0x0018)(HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FReferenceActorClasses) == 0x000008, "Wrong alignment on FReferenceActorClasses");
static_assert(sizeof(FReferenceActorClasses) == 0x000020, "Wrong size on FReferenceActorClasses");
static_assert(offsetof(FReferenceActorClasses, Name) == 0x000000, "Member 'FReferenceActorClasses::Name' has a wrong offset!");
static_assert(offsetof(FReferenceActorClasses, ActorAsset) == 0x000008, "Member 'FReferenceActorClasses::ActorAsset' has a wrong offset!");

// ScriptStruct GbxGameSystemCore.EmitterColorParam
// 0x0010 (0x0010 - 0x0000)
struct alignas(0x08) FEmitterColorParam final
{
public:
	class FName                                   Name;                                              // 0x0000(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FColor                                 Value;                                             // 0x0008(0x0004)(IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_C[0x4];                                        // 0x000C(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FEmitterColorParam) == 0x000008, "Wrong alignment on FEmitterColorParam");
static_assert(sizeof(FEmitterColorParam) == 0x000010, "Wrong size on FEmitterColorParam");
static_assert(offsetof(FEmitterColorParam, Name) == 0x000000, "Member 'FEmitterColorParam::Name' has a wrong offset!");
static_assert(offsetof(FEmitterColorParam, Value) == 0x000008, "Member 'FEmitterColorParam::Value' has a wrong offset!");

// ScriptStruct GbxGameSystemCore.ReplicatedEmitterTemplateOptions
// 0x0018 (0x0018 - 0x0000)
struct FReplicatedEmitterTemplateOptions final
{
public:
	class UParticleSystem*                        DefaultTemplate;                                   // 0x0000(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UParticleSystem*                        CensoredTemplate;                                  // 0x0008(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bEligibleForCensoring;                             // 0x0010(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_11[0x7];                                       // 0x0011(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FReplicatedEmitterTemplateOptions) == 0x000008, "Wrong alignment on FReplicatedEmitterTemplateOptions");
static_assert(sizeof(FReplicatedEmitterTemplateOptions) == 0x000018, "Wrong size on FReplicatedEmitterTemplateOptions");
static_assert(offsetof(FReplicatedEmitterTemplateOptions, DefaultTemplate) == 0x000000, "Member 'FReplicatedEmitterTemplateOptions::DefaultTemplate' has a wrong offset!");
static_assert(offsetof(FReplicatedEmitterTemplateOptions, CensoredTemplate) == 0x000008, "Member 'FReplicatedEmitterTemplateOptions::CensoredTemplate' has a wrong offset!");
static_assert(offsetof(FReplicatedEmitterTemplateOptions, bEligibleForCensoring) == 0x000010, "Member 'FReplicatedEmitterTemplateOptions::bEligibleForCensoring' has a wrong offset!");

// ScriptStruct GbxGameSystemCore.ScreenParticleRecord
// 0x0030 (0x0030 - 0x0000)
struct FScreenParticleRecord final
{
public:
	uint8                                         Pad_0[0x8];                                        // 0x0000(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	class UParticleSystem*                        Template;                                          // 0x0008(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UParticleSystemComponent*               Component;                                         // 0x0010(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_18[0x18];                                      // 0x0018(0x0018)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FScreenParticleRecord) == 0x000008, "Wrong alignment on FScreenParticleRecord");
static_assert(sizeof(FScreenParticleRecord) == 0x000030, "Wrong size on FScreenParticleRecord");
static_assert(offsetof(FScreenParticleRecord, Template) == 0x000008, "Member 'FScreenParticleRecord::Template' has a wrong offset!");
static_assert(offsetof(FScreenParticleRecord, Component) == 0x000010, "Member 'FScreenParticleRecord::Component' has a wrong offset!");

// ScriptStruct GbxGameSystemCore.SharedAnimInstanceData
// 0x0020 (0x0020 - 0x0000)
struct alignas(0x08) FSharedAnimInstanceData final
{
public:
	uint8                                         Pad_0[0x20];                                       // 0x0000(0x0020)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FSharedAnimInstanceData) == 0x000008, "Wrong alignment on FSharedAnimInstanceData");
static_assert(sizeof(FSharedAnimInstanceData) == 0x000020, "Wrong size on FSharedAnimInstanceData");

// ScriptStruct GbxGameSystemCore.SpawnPatternInputs
// 0x0038 (0x0038 - 0x0000)
struct FSpawnPatternInputs final
{
public:
	class AActor*                                 SourceActor;                                       // 0x0000(0x0008)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   SocketName;                                        // 0x0008(0x0008)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                BaseLocation;                                      // 0x0010(0x000C)(BlueprintVisible, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FRotator                               BaseRotation;                                      // 0x001C(0x000C)(BlueprintVisible, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
	struct FVector                                IncomingImpulse;                                   // 0x0028(0x000C)(BlueprintVisible, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_34[0x4];                                       // 0x0034(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FSpawnPatternInputs) == 0x000008, "Wrong alignment on FSpawnPatternInputs");
static_assert(sizeof(FSpawnPatternInputs) == 0x000038, "Wrong size on FSpawnPatternInputs");
static_assert(offsetof(FSpawnPatternInputs, SourceActor) == 0x000000, "Member 'FSpawnPatternInputs::SourceActor' has a wrong offset!");
static_assert(offsetof(FSpawnPatternInputs, SocketName) == 0x000008, "Member 'FSpawnPatternInputs::SocketName' has a wrong offset!");
static_assert(offsetof(FSpawnPatternInputs, BaseLocation) == 0x000010, "Member 'FSpawnPatternInputs::BaseLocation' has a wrong offset!");
static_assert(offsetof(FSpawnPatternInputs, BaseRotation) == 0x00001C, "Member 'FSpawnPatternInputs::BaseRotation' has a wrong offset!");
static_assert(offsetof(FSpawnPatternInputs, IncomingImpulse) == 0x000028, "Member 'FSpawnPatternInputs::IncomingImpulse' has a wrong offset!");

// ScriptStruct GbxGameSystemCore.StanceVectorValue
// 0x0010 (0x0010 - 0x0000)
struct FStanceVectorValue final
{
public:
	EStanceValueOverrideType                      ValueType;                                         // 0x0000(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1[0x3];                                        // 0x0001(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	struct FVector                                Value;                                             // 0x0004(0x000C)(Edit, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FStanceVectorValue) == 0x000004, "Wrong alignment on FStanceVectorValue");
static_assert(sizeof(FStanceVectorValue) == 0x000010, "Wrong size on FStanceVectorValue");
static_assert(offsetof(FStanceVectorValue, ValueType) == 0x000000, "Member 'FStanceVectorValue::ValueType' has a wrong offset!");
static_assert(offsetof(FStanceVectorValue, Value) == 0x000004, "Member 'FStanceVectorValue::Value' has a wrong offset!");

// ScriptStruct GbxGameSystemCore.ConditionalStance
// 0x0010 (0x0010 - 0x0000)
struct FConditionalStance final
{
public:
	class UGbxCondition*                          Condition;                                         // 0x0000(0x0008)(Edit, ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, PersistentInstance, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UStanceDataProvider*                    StanceProvider;                                    // 0x0008(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FConditionalStance) == 0x000008, "Wrong alignment on FConditionalStance");
static_assert(sizeof(FConditionalStance) == 0x000010, "Wrong size on FConditionalStance");
static_assert(offsetof(FConditionalStance, Condition) == 0x000000, "Member 'FConditionalStance::Condition' has a wrong offset!");
static_assert(offsetof(FConditionalStance, StanceProvider) == 0x000008, "Member 'FConditionalStance::StanceProvider' has a wrong offset!");

// ScriptStruct GbxGameSystemCore.StanceStack
// 0x0050 (0x0050 - 0x0000)
struct FStanceStack final
{
public:
	uint8                                         Pad_0[0x10];                                       // 0x0000(0x0010)(Fixing Size After Last Property [ Dumper-7 ])
	class AActor*                                 Owner;                                             // 0x0010(0x0008)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	EStanceStackLayer                             Top;                                               // 0x0018(0x0001)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_19[0x7];                                       // 0x0019(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	class UStanceDataProvider*                    Stack[0x4];                                        // 0x0020(0x0008)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	EStanceStackLayer                             LayerCurr;                                         // 0x0040(0x0001)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_41[0x7];                                       // 0x0041(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	class UStanceData*                            StanceCurr;                                        // 0x0048(0x0008)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
};
static_assert(alignof(FStanceStack) == 0x000008, "Wrong alignment on FStanceStack");
static_assert(sizeof(FStanceStack) == 0x000050, "Wrong size on FStanceStack");
static_assert(offsetof(FStanceStack, Owner) == 0x000010, "Member 'FStanceStack::Owner' has a wrong offset!");
static_assert(offsetof(FStanceStack, Top) == 0x000018, "Member 'FStanceStack::Top' has a wrong offset!");
static_assert(offsetof(FStanceStack, Stack) == 0x000020, "Member 'FStanceStack::Stack' has a wrong offset!");
static_assert(offsetof(FStanceStack, LayerCurr) == 0x000040, "Member 'FStanceStack::LayerCurr' has a wrong offset!");
static_assert(offsetof(FStanceStack, StanceCurr) == 0x000048, "Member 'FStanceStack::StanceCurr' has a wrong offset!");

// ScriptStruct GbxGameSystemCore.BalanceFormulaDefinedValueRow
// 0x0118 (0x0120 - 0x0008)
struct FBalanceFormulaDefinedValueRow final : public FAttributeDefinedValueRow
{
public:
	struct FAttributeInitializationData           Multiplier;                                        // 0x0008(0x0038)(Edit, NoDestructor, Protected, NativeAccessSpecifierProtected)
	struct FAttributeInitializationData           Level;                                             // 0x0040(0x0038)(Edit, NoDestructor, Protected, NativeAccessSpecifierProtected)
	struct FAttributeInitializationData           Power;                                             // 0x0078(0x0038)(Edit, NoDestructor, Protected, NativeAccessSpecifierProtected)
	struct FAttributeInitializationData           Offset;                                            // 0x00B0(0x0038)(Edit, NoDestructor, Protected, NativeAccessSpecifierProtected)
	struct FAttributeInitializationData           Scalar;                                            // 0x00E8(0x0038)(Edit, NoDestructor, Protected, NativeAccessSpecifierProtected)
};
static_assert(alignof(FBalanceFormulaDefinedValueRow) == 0x000008, "Wrong alignment on FBalanceFormulaDefinedValueRow");
static_assert(sizeof(FBalanceFormulaDefinedValueRow) == 0x000120, "Wrong size on FBalanceFormulaDefinedValueRow");
static_assert(offsetof(FBalanceFormulaDefinedValueRow, Multiplier) == 0x000008, "Member 'FBalanceFormulaDefinedValueRow::Multiplier' has a wrong offset!");
static_assert(offsetof(FBalanceFormulaDefinedValueRow, Level) == 0x000040, "Member 'FBalanceFormulaDefinedValueRow::Level' has a wrong offset!");
static_assert(offsetof(FBalanceFormulaDefinedValueRow, Power) == 0x000078, "Member 'FBalanceFormulaDefinedValueRow::Power' has a wrong offset!");
static_assert(offsetof(FBalanceFormulaDefinedValueRow, Offset) == 0x0000B0, "Member 'FBalanceFormulaDefinedValueRow::Offset' has a wrong offset!");
static_assert(offsetof(FBalanceFormulaDefinedValueRow, Scalar) == 0x0000E8, "Member 'FBalanceFormulaDefinedValueRow::Scalar' has a wrong offset!");

// ScriptStruct GbxGameSystemCore.RandomValueRow
// 0x00F8 (0x0100 - 0x0008)
struct FRandomValueRow final : public FAttributeDefinedValueRow
{
public:
	struct FAttributeInitializationData           RNG_LowerBound;                                    // 0x0008(0x0038)(Edit, NoDestructor, NativeAccessSpecifierPublic)
	struct FAttributeInitializationData           RNG_UpperBound;                                    // 0x0040(0x0038)(Edit, NoDestructor, NativeAccessSpecifierPublic)
	bool                                          bIntegerOnlyValues;                                // 0x0078(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_79[0x7];                                       // 0x0079(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	struct FAttributeInitializationData           OptionalOutputMinValue;                            // 0x0080(0x0038)(Edit, NoDestructor, NativeAccessSpecifierPublic)
	bool                                          bClampToOutputMinValue;                            // 0x00B8(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_B9[0x7];                                       // 0x00B9(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	struct FAttributeInitializationData           OptionalOutputMaxValue;                            // 0x00C0(0x0038)(Edit, NoDestructor, NativeAccessSpecifierPublic)
	bool                                          bClampToOutputMaxValue;                            // 0x00F8(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_F9[0x7];                                       // 0x00F9(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FRandomValueRow) == 0x000008, "Wrong alignment on FRandomValueRow");
static_assert(sizeof(FRandomValueRow) == 0x000100, "Wrong size on FRandomValueRow");
static_assert(offsetof(FRandomValueRow, RNG_LowerBound) == 0x000008, "Member 'FRandomValueRow::RNG_LowerBound' has a wrong offset!");
static_assert(offsetof(FRandomValueRow, RNG_UpperBound) == 0x000040, "Member 'FRandomValueRow::RNG_UpperBound' has a wrong offset!");
static_assert(offsetof(FRandomValueRow, bIntegerOnlyValues) == 0x000078, "Member 'FRandomValueRow::bIntegerOnlyValues' has a wrong offset!");
static_assert(offsetof(FRandomValueRow, OptionalOutputMinValue) == 0x000080, "Member 'FRandomValueRow::OptionalOutputMinValue' has a wrong offset!");
static_assert(offsetof(FRandomValueRow, bClampToOutputMinValue) == 0x0000B8, "Member 'FRandomValueRow::bClampToOutputMinValue' has a wrong offset!");
static_assert(offsetof(FRandomValueRow, OptionalOutputMaxValue) == 0x0000C0, "Member 'FRandomValueRow::OptionalOutputMaxValue' has a wrong offset!");
static_assert(offsetof(FRandomValueRow, bClampToOutputMaxValue) == 0x0000F8, "Member 'FRandomValueRow::bClampToOutputMaxValue' has a wrong offset!");

// ScriptStruct GbxGameSystemCore.GbxParamDefinedSingleValueRow
// 0x0080 (0x0088 - 0x0008)
struct FGbxParamDefinedSingleValueRow final : public FAttributeDefinedValueRow
{
public:
	struct FGbxParam                              Value;                                             // 0x0008(0x0080)(Edit, NoDestructor, ContainsInstancedReference, NativeAccessSpecifierPublic)
};
static_assert(alignof(FGbxParamDefinedSingleValueRow) == 0x000008, "Wrong alignment on FGbxParamDefinedSingleValueRow");
static_assert(sizeof(FGbxParamDefinedSingleValueRow) == 0x000088, "Wrong size on FGbxParamDefinedSingleValueRow");
static_assert(offsetof(FGbxParamDefinedSingleValueRow, Value) == 0x000008, "Member 'FGbxParamDefinedSingleValueRow::Value' has a wrong offset!");

// ScriptStruct GbxGameSystemCore.AttributeEffectValueContextHardRef
// 0x0018 (0x0018 - 0x0000)
struct FAttributeEffectValueContextHardRef final
{
public:
	class UObject*                                Context;                                           // 0x0000(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UObject*                                ContextResolverOverride;                           // 0x0008(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_10[0x8];                                       // 0x0010(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FAttributeEffectValueContextHardRef) == 0x000008, "Wrong alignment on FAttributeEffectValueContextHardRef");
static_assert(sizeof(FAttributeEffectValueContextHardRef) == 0x000018, "Wrong size on FAttributeEffectValueContextHardRef");
static_assert(offsetof(FAttributeEffectValueContextHardRef, Context) == 0x000000, "Member 'FAttributeEffectValueContextHardRef::Context' has a wrong offset!");
static_assert(offsetof(FAttributeEffectValueContextHardRef, ContextResolverOverride) == 0x000008, "Member 'FAttributeEffectValueContextHardRef::ContextResolverOverride' has a wrong offset!");

// ScriptStruct GbxGameSystemCore.StretchBonesInstance
// 0x00A0 (0x00A0 - 0x0000)
struct alignas(0x10) FStretchBonesInstance final
{
public:
	class FName                                   StartBoneName;                                     // 0x0000(0x0008)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   EndBoneName;                                       // 0x0008(0x0008)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bUniformStretch;                                   // 0x0010(0x0001)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_11[0x7];                                       // 0x0011(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	class AActor*                                 TargetActor;                                       // 0x0018(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_20[0x4];                                       // 0x0020(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	struct FVector                                TargetPosition;                                    // 0x0024(0x000C)(BlueprintVisible, BlueprintReadOnly, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         Distance;                                          // 0x0030(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_34[0x6C];                                      // 0x0034(0x006C)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FStretchBonesInstance) == 0x000010, "Wrong alignment on FStretchBonesInstance");
static_assert(sizeof(FStretchBonesInstance) == 0x0000A0, "Wrong size on FStretchBonesInstance");
static_assert(offsetof(FStretchBonesInstance, StartBoneName) == 0x000000, "Member 'FStretchBonesInstance::StartBoneName' has a wrong offset!");
static_assert(offsetof(FStretchBonesInstance, EndBoneName) == 0x000008, "Member 'FStretchBonesInstance::EndBoneName' has a wrong offset!");
static_assert(offsetof(FStretchBonesInstance, bUniformStretch) == 0x000010, "Member 'FStretchBonesInstance::bUniformStretch' has a wrong offset!");
static_assert(offsetof(FStretchBonesInstance, TargetActor) == 0x000018, "Member 'FStretchBonesInstance::TargetActor' has a wrong offset!");
static_assert(offsetof(FStretchBonesInstance, TargetPosition) == 0x000024, "Member 'FStretchBonesInstance::TargetPosition' has a wrong offset!");
static_assert(offsetof(FStretchBonesInstance, Distance) == 0x000030, "Member 'FStretchBonesInstance::Distance' has a wrong offset!");

// ScriptStruct GbxGameSystemCore.TargetLocationData
// 0x0020 (0x0020 - 0x0000)
struct FTargetLocationData final
{
public:
	struct FVector                                TargetLocation;                                    // 0x0000(0x000C)(Edit, BlueprintVisible, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                TargetBoundsCenter;                                // 0x000C(0x000C)(Edit, BlueprintVisible, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         TargetBoundsRadius;                                // 0x0018(0x0004)(Edit, BlueprintVisible, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         TargetBoundsHalfHeight;                            // 0x001C(0x0004)(Edit, BlueprintVisible, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FTargetLocationData) == 0x000004, "Wrong alignment on FTargetLocationData");
static_assert(sizeof(FTargetLocationData) == 0x000020, "Wrong size on FTargetLocationData");
static_assert(offsetof(FTargetLocationData, TargetLocation) == 0x000000, "Member 'FTargetLocationData::TargetLocation' has a wrong offset!");
static_assert(offsetof(FTargetLocationData, TargetBoundsCenter) == 0x00000C, "Member 'FTargetLocationData::TargetBoundsCenter' has a wrong offset!");
static_assert(offsetof(FTargetLocationData, TargetBoundsRadius) == 0x000018, "Member 'FTargetLocationData::TargetBoundsRadius' has a wrong offset!");
static_assert(offsetof(FTargetLocationData, TargetBoundsHalfHeight) == 0x00001C, "Member 'FTargetLocationData::TargetBoundsHalfHeight' has a wrong offset!");

// ScriptStruct GbxGameSystemCore.TargetActorInfo
// 0x0390 (0x0390 - 0x0000)
struct alignas(0x08) FTargetActorInfo final
{
public:
	TWeakObjectPtr<class AActor>                  Target;                                            // 0x0000(0x0008)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	TWeakObjectPtr<class USceneComponent>         Proxy;                                             // 0x0008(0x0008)(ExportObject, ZeroConstructor, Transient, InstancedReference, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TWeakObjectPtr<class UTargetableComponent>    TargetableComponent;                               // 0x0010(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TWeakObjectPtr<class UTargetingComponent>     OwnerTargetingComponent;                           // 0x0018(0x0008)(ExportObject, ZeroConstructor, Transient, InstancedReference, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_20[0x35C];                                     // 0x0020(0x035C)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         TargetScore;                                       // 0x037C(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	ETeamAttitude                                 AttitudeTowardTarget;                              // 0x0380(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	ETeamAttitude                                 AttitudeFromTarget;                                // 0x0381(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_382[0x2];                                      // 0x0382(0x0002)(Fixing Size After Last Property [ Dumper-7 ])
	int32                                         TargetListIndex;                                   // 0x0384(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_388[0x8];                                      // 0x0388(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FTargetActorInfo) == 0x000008, "Wrong alignment on FTargetActorInfo");
static_assert(sizeof(FTargetActorInfo) == 0x000390, "Wrong size on FTargetActorInfo");
static_assert(offsetof(FTargetActorInfo, Target) == 0x000000, "Member 'FTargetActorInfo::Target' has a wrong offset!");
static_assert(offsetof(FTargetActorInfo, Proxy) == 0x000008, "Member 'FTargetActorInfo::Proxy' has a wrong offset!");
static_assert(offsetof(FTargetActorInfo, TargetableComponent) == 0x000010, "Member 'FTargetActorInfo::TargetableComponent' has a wrong offset!");
static_assert(offsetof(FTargetActorInfo, OwnerTargetingComponent) == 0x000018, "Member 'FTargetActorInfo::OwnerTargetingComponent' has a wrong offset!");
static_assert(offsetof(FTargetActorInfo, TargetScore) == 0x00037C, "Member 'FTargetActorInfo::TargetScore' has a wrong offset!");
static_assert(offsetof(FTargetActorInfo, AttitudeTowardTarget) == 0x000380, "Member 'FTargetActorInfo::AttitudeTowardTarget' has a wrong offset!");
static_assert(offsetof(FTargetActorInfo, AttitudeFromTarget) == 0x000381, "Member 'FTargetActorInfo::AttitudeFromTarget' has a wrong offset!");
static_assert(offsetof(FTargetActorInfo, TargetListIndex) == 0x000384, "Member 'FTargetActorInfo::TargetListIndex' has a wrong offset!");

// ScriptStruct GbxGameSystemCore.TargetQueryDebugDesc
// 0x0038 (0x0038 - 0x0000)
struct FTargetQueryDebugDesc final
{
public:
	class FString                                 DebugGroup;                                        // 0x0000(0x0010)(ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class AActor*                                 Actor;                                             // 0x0010(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UTeam*                                  Team;                                              // 0x0018(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         Score;                                             // 0x0020(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_24[0x4];                                       // 0x0024(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class FString                                 FailReason;                                        // 0x0028(0x0010)(ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FTargetQueryDebugDesc) == 0x000008, "Wrong alignment on FTargetQueryDebugDesc");
static_assert(sizeof(FTargetQueryDebugDesc) == 0x000038, "Wrong size on FTargetQueryDebugDesc");
static_assert(offsetof(FTargetQueryDebugDesc, DebugGroup) == 0x000000, "Member 'FTargetQueryDebugDesc::DebugGroup' has a wrong offset!");
static_assert(offsetof(FTargetQueryDebugDesc, Actor) == 0x000010, "Member 'FTargetQueryDebugDesc::Actor' has a wrong offset!");
static_assert(offsetof(FTargetQueryDebugDesc, Team) == 0x000018, "Member 'FTargetQueryDebugDesc::Team' has a wrong offset!");
static_assert(offsetof(FTargetQueryDebugDesc, Score) == 0x000020, "Member 'FTargetQueryDebugDesc::Score' has a wrong offset!");
static_assert(offsetof(FTargetQueryDebugDesc, FailReason) == 0x000028, "Member 'FTargetQueryDebugDesc::FailReason' has a wrong offset!");

// ScriptStruct GbxGameSystemCore.TargetPersistentNotes
// 0x0048 (0x0048 - 0x0000)
struct alignas(0x08) FTargetPersistentNotes final
{
public:
	uint8                                         Pad_0[0x48];                                       // 0x0000(0x0048)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FTargetPersistentNotes) == 0x000008, "Wrong alignment on FTargetPersistentNotes");
static_assert(sizeof(FTargetPersistentNotes) == 0x000048, "Wrong size on FTargetPersistentNotes");

// ScriptStruct GbxGameSystemCore.UIStatCollector
// 0x0590 (0x0590 - 0x0000)
struct alignas(0x08) FUIStatCollector final
{
public:
	uint8                                         Pad_0[0x590];                                      // 0x0000(0x0590)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FUIStatCollector) == 0x000008, "Wrong alignment on FUIStatCollector");
static_assert(sizeof(FUIStatCollector) == 0x000590, "Wrong size on FUIStatCollector");

// ScriptStruct GbxGameSystemCore.ReplicatedUIStatCollectionData
// 0x0010 (0x0010 - 0x0000)
struct alignas(0x08) FReplicatedUIStatCollectionData final
{
public:
	uint8                                         Pad_0[0x10];                                       // 0x0000(0x0010)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FReplicatedUIStatCollectionData) == 0x000008, "Wrong alignment on FReplicatedUIStatCollectionData");
static_assert(sizeof(FReplicatedUIStatCollectionData) == 0x000010, "Wrong size on FReplicatedUIStatCollectionData");

// ScriptStruct GbxGameSystemCore.ViewModelOffsetImpulseInfo
// 0x0038 (0x0038 - 0x0000)
struct FViewModelOffsetImpulseInfo final
{
public:
	float                                         EaseInDuration;                                    // 0x0000(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FGbxEasingFunc                         EaseInFunc;                                        // 0x0004(0x000C)(Edit, NoDestructor, NativeAccessSpecifierPublic)
	float                                         EaseOutDuration;                                   // 0x0010(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FGbxEasingFunc                         EaseOutFunc;                                       // 0x0014(0x000C)(Edit, NoDestructor, NativeAccessSpecifierPublic)
	struct FRotator                               RotationExtent;                                    // 0x0020(0x000C)(Edit, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
	struct FVector                                TranslationExtent;                                 // 0x002C(0x000C)(Edit, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FViewModelOffsetImpulseInfo) == 0x000004, "Wrong alignment on FViewModelOffsetImpulseInfo");
static_assert(sizeof(FViewModelOffsetImpulseInfo) == 0x000038, "Wrong size on FViewModelOffsetImpulseInfo");
static_assert(offsetof(FViewModelOffsetImpulseInfo, EaseInDuration) == 0x000000, "Member 'FViewModelOffsetImpulseInfo::EaseInDuration' has a wrong offset!");
static_assert(offsetof(FViewModelOffsetImpulseInfo, EaseInFunc) == 0x000004, "Member 'FViewModelOffsetImpulseInfo::EaseInFunc' has a wrong offset!");
static_assert(offsetof(FViewModelOffsetImpulseInfo, EaseOutDuration) == 0x000010, "Member 'FViewModelOffsetImpulseInfo::EaseOutDuration' has a wrong offset!");
static_assert(offsetof(FViewModelOffsetImpulseInfo, EaseOutFunc) == 0x000014, "Member 'FViewModelOffsetImpulseInfo::EaseOutFunc' has a wrong offset!");
static_assert(offsetof(FViewModelOffsetImpulseInfo, RotationExtent) == 0x000020, "Member 'FViewModelOffsetImpulseInfo::RotationExtent' has a wrong offset!");
static_assert(offsetof(FViewModelOffsetImpulseInfo, TranslationExtent) == 0x00002C, "Member 'FViewModelOffsetImpulseInfo::TranslationExtent' has a wrong offset!");

// ScriptStruct GbxGameSystemCore.Vector2DWaveform
// 0x0018 (0x0018 - 0x0000)
struct FVector2DWaveform final
{
public:
	struct FFloatWaveform                         X;                                                 // 0x0000(0x000C)(Edit, NoDestructor, NativeAccessSpecifierPublic)
	struct FFloatWaveform                         Y;                                                 // 0x000C(0x000C)(Edit, NoDestructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(FVector2DWaveform) == 0x000004, "Wrong alignment on FVector2DWaveform");
static_assert(sizeof(FVector2DWaveform) == 0x000018, "Wrong size on FVector2DWaveform");
static_assert(offsetof(FVector2DWaveform, X) == 0x000000, "Member 'FVector2DWaveform::X' has a wrong offset!");
static_assert(offsetof(FVector2DWaveform, Y) == 0x00000C, "Member 'FVector2DWaveform::Y' has a wrong offset!");

}

