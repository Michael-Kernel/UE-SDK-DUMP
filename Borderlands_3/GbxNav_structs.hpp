#pragma once

/*
* SDK generated by Dumper-7
*
* https://github.com/Encryqed/Dumper-7
*/

// Package: GbxNav

#include "Basic.hpp"

#include "CoreUObject_structs.hpp"
#include "GbxGameSystemCore_structs.hpp"
#include "GbxRuntime_structs.hpp"
#include "Engine_structs.hpp"


namespace SDK
{

// Enum GbxNav.EGbxNavMoveStyleDefault
// NumValues: 0x0003
enum class EGbxNavMoveStyleDefault : uint8
{
	Strafe                                   = 0,
	Forward                                  = 1,
	EGbxNavMoveStyleDefault_MAX              = 2,
};

// Enum GbxNav.EFlightMovementState
// NumValues: 0x0006
enum class EFlightMovementState : uint8
{
	Approach                                 = 0,
	Descent                                  = 1,
	Ascent                                   = 2,
	Exit                                     = 3,
	DigistructingOut                         = 4,
	EFlightMovementState_MAX                 = 5,
};

// Enum GbxNav.EGbxNavAnimTableType
// NumValues: 0x0005
enum class EGbxNavAnimTableType : uint8
{
	Start                                    = 0,
	Stop                                     = 1,
	TurnIdle                                 = 2,
	TurnMove                                 = 3,
	EGbxNavAnimTableType_MAX                 = 4,
};

// Enum GbxNav.EAvoidWhileIdle
// NumValues: 0x0004
enum class EAvoidWhileIdle : uint8
{
	Default                                  = 0,
	AvoidWhileIdle                           = 1,
	OnlyAvoidWhileMoving                     = 2,
	EAvoidWhileIdle_MAX                      = 3,
};

// Enum GbxNav.EGbxNavState
// NumValues: 0x0005
enum class EGbxNavState : uint8
{
	Idle                                     = 0,
	WaitingGoal                              = 1,
	WaitingPath                              = 2,
	Moving                                   = 3,
	EGbxNavState_MAX                         = 4,
};

// Enum GbxNav.EGbxGoalResult
// NumValues: 0x0004
enum class EGbxGoalResult : uint8
{
	Failed                                   = 0,
	Reached                                  = 1,
	Success                                  = 2,
	EGbxGoalResult_MAX                       = 3,
};

// Enum GbxNav.EGbxNavFlyRoundingMode
// NumValues: 0x0003
enum class EGbxNavFlyRoundingMode : uint8
{
	RoundToZero                              = 0,
	RoundToNearest                           = 1,
	EGbxNavFlyRoundingMode_MAX               = 2,
};

// Enum GbxNav.EGbxNavGoalCheats
// NumValues: 0x0004
enum class EGbxNavGoalCheats : uint32
{
	None                                     = 0,
	MoveEvenIfUnreachable                    = 1,
	ValidEvenIfNoNav                         = 2,
	EGbxNavGoalCheats_MAX                    = 3,
};

// Enum GbxNav.EGbxOffsetType
// NumValues: 0x0003
enum class EGbxOffsetType : uint8
{
	Local                                    = 0,
	World                                    = 1,
	EGbxOffsetType_MAX                       = 2,
};

// Enum GbxNav.EGbxStrafeType
// NumValues: 0x0004
enum class EGbxStrafeType : uint8
{
	Default                                  = 0,
	Strafe                                   = 1,
	Forward                                  = 2,
	EGbxStrafeType_MAX                       = 3,
};

// Enum GbxNav.EGbxNavGoalReach
// NumValues: 0x0003
enum class EGbxNavGoalReach : uint8
{
	Exact                                    = 0,
	Pass                                     = 1,
	EGbxNavGoalReach_MAX                     = 2,
};

// Enum GbxNav.EGbxPainterType
// NumValues: 0x0004
enum class EGbxPainterType : uint8
{
	Static                                   = 0,
	Dynamic                                  = 1,
	StaticAndDynamic                         = 2,
	EGbxPainterType_MAX                      = 3,
};

// Enum GbxNav.EGbxPathType
// NumValues: 0x0004
enum class EGbxPathType : uint8
{
	None                                     = 0,
	Walk                                     = 1,
	Fly                                      = 2,
	EGbxPathType_MAX                         = 3,
};

// Enum GbxNav.EGbxUserEdgeDirection
// NumValues: 0x0005
enum class EGbxUserEdgeDirection : uint8
{
	Blocked                                  = 0,
	AToB                                     = 1,
	BToA                                     = 2,
	Bidirectional                            = 3,
	EGbxUserEdgeDirection_MAX                = 4,
};

// ScriptStruct GbxNav.HavokUserEdgeTeleportItem
// 0x0030 (0x0030 - 0x0000)
struct FHavokUserEdgeTeleportItem final
{
public:
	class UGbxUserEdge*                           EntryUserEdge;                                     // 0x0000(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UGbxUserEdge*                           ExitUserEdge;                                      // 0x0008(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         CostScale;                                         // 0x0010(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_14[0x4];                                       // 0x0014(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	TSubclassOf<class UGbxAction>                 TeleportAction;                                    // 0x0018(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TSubclassOf<class UHavokUserEdge>             EntryEdge;                                         // 0x0020(0x0008)(ZeroConstructor, Deprecated, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TSubclassOf<class UHavokUserEdge>             ExitEdge;                                          // 0x0028(0x0008)(ZeroConstructor, Deprecated, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FHavokUserEdgeTeleportItem) == 0x000008, "Wrong alignment on FHavokUserEdgeTeleportItem");
static_assert(sizeof(FHavokUserEdgeTeleportItem) == 0x000030, "Wrong size on FHavokUserEdgeTeleportItem");
static_assert(offsetof(FHavokUserEdgeTeleportItem, EntryUserEdge) == 0x000000, "Member 'FHavokUserEdgeTeleportItem::EntryUserEdge' has a wrong offset!");
static_assert(offsetof(FHavokUserEdgeTeleportItem, ExitUserEdge) == 0x000008, "Member 'FHavokUserEdgeTeleportItem::ExitUserEdge' has a wrong offset!");
static_assert(offsetof(FHavokUserEdgeTeleportItem, CostScale) == 0x000010, "Member 'FHavokUserEdgeTeleportItem::CostScale' has a wrong offset!");
static_assert(offsetof(FHavokUserEdgeTeleportItem, TeleportAction) == 0x000018, "Member 'FHavokUserEdgeTeleportItem::TeleportAction' has a wrong offset!");
static_assert(offsetof(FHavokUserEdgeTeleportItem, EntryEdge) == 0x000020, "Member 'FHavokUserEdgeTeleportItem::EntryEdge' has a wrong offset!");
static_assert(offsetof(FHavokUserEdgeTeleportItem, ExitEdge) == 0x000028, "Member 'FHavokUserEdgeTeleportItem::ExitEdge' has a wrong offset!");

// ScriptStruct GbxNav.GbxNavSlowdownData
// 0x0014 (0x0014 - 0x0000)
struct FGbxNavSlowdownData final
{
public:
	bool                                          bSlowdownNearGoal;                                 // 0x0000(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1[0x3];                                        // 0x0001(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	struct FStanceFloatValue                      SlowdownSpeed;                                     // 0x0004(0x0008)(Edit, NoDestructor, NativeAccessSpecifierPublic)
	float                                         SlowdownDistanceMin;                               // 0x000C(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         SlowdownDistanceMax;                               // 0x0010(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FGbxNavSlowdownData) == 0x000004, "Wrong alignment on FGbxNavSlowdownData");
static_assert(sizeof(FGbxNavSlowdownData) == 0x000014, "Wrong size on FGbxNavSlowdownData");
static_assert(offsetof(FGbxNavSlowdownData, bSlowdownNearGoal) == 0x000000, "Member 'FGbxNavSlowdownData::bSlowdownNearGoal' has a wrong offset!");
static_assert(offsetof(FGbxNavSlowdownData, SlowdownSpeed) == 0x000004, "Member 'FGbxNavSlowdownData::SlowdownSpeed' has a wrong offset!");
static_assert(offsetof(FGbxNavSlowdownData, SlowdownDistanceMin) == 0x00000C, "Member 'FGbxNavSlowdownData::SlowdownDistanceMin' has a wrong offset!");
static_assert(offsetof(FGbxNavSlowdownData, SlowdownDistanceMax) == 0x000010, "Member 'FGbxNavSlowdownData::SlowdownDistanceMax' has a wrong offset!");

// ScriptStruct GbxNav.GbxNavPathingData
// 0x0010 (0x0010 - 0x0000)
struct FGbxNavPathingData final
{
public:
	class UGbxNavAreaData*                        Areas;                                             // 0x0000(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UHavokPathFindingData*                  UserEdges;                                         // 0x0008(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FGbxNavPathingData) == 0x000008, "Wrong alignment on FGbxNavPathingData");
static_assert(sizeof(FGbxNavPathingData) == 0x000010, "Wrong size on FGbxNavPathingData");
static_assert(offsetof(FGbxNavPathingData, Areas) == 0x000000, "Member 'FGbxNavPathingData::Areas' has a wrong offset!");
static_assert(offsetof(FGbxNavPathingData, UserEdges) == 0x000008, "Member 'FGbxNavPathingData::UserEdges' has a wrong offset!");

// ScriptStruct GbxNav.GbxNavAgentProperties
// 0x0060 (0x0060 - 0x0000)
struct FGbxNavAgentProperties final
{
public:
	uint8                                         Pad_0[0x50];                                       // 0x0000(0x0050)(Fixing Size After Last Property [ Dumper-7 ])
	struct FGbxNavPathingData                     PathingData;                                       // 0x0050(0x0010)(NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FGbxNavAgentProperties) == 0x000008, "Wrong alignment on FGbxNavAgentProperties");
static_assert(sizeof(FGbxNavAgentProperties) == 0x000060, "Wrong size on FGbxNavAgentProperties");
static_assert(offsetof(FGbxNavAgentProperties, PathingData) == 0x000050, "Member 'FGbxNavAgentProperties::PathingData' has a wrong offset!");

// ScriptStruct GbxNav.GbxNavAgent
// 0x00A8 (0x00A8 - 0x0000)
struct FGbxNavAgent final
{
public:
	struct FGbxNavAgentProperties                 Props;                                             // 0x0000(0x0060)(NoDestructor, NativeAccessSpecifierPublic)
	class AGbxNavWorld*                           GbxNavWorld;                                       // 0x0060(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class AActor*                                 Context;                                           // 0x0068(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_70[0x38];                                      // 0x0070(0x0038)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FGbxNavAgent) == 0x000008, "Wrong alignment on FGbxNavAgent");
static_assert(sizeof(FGbxNavAgent) == 0x0000A8, "Wrong size on FGbxNavAgent");
static_assert(offsetof(FGbxNavAgent, Props) == 0x000000, "Member 'FGbxNavAgent::Props' has a wrong offset!");
static_assert(offsetof(FGbxNavAgent, GbxNavWorld) == 0x000060, "Member 'FGbxNavAgent::GbxNavWorld' has a wrong offset!");
static_assert(offsetof(FGbxNavAgent, Context) == 0x000068, "Member 'FGbxNavAgent::Context' has a wrong offset!");

// ScriptStruct GbxNav.GbxAvoidanceProperties
// 0x0038 (0x0038 - 0x0000)
struct FGbxAvoidanceProperties final
{
public:
	float                                         WallFollowingAngle;                                // 0x0000(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         DodgingPenalty;                                    // 0x0004(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         VelocityHysteresis;                                // 0x0008(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         SidednessChangingPenalty;                          // 0x000C(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         CollisionPenalty;                                  // 0x0010(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         PenetrationPenalty;                                // 0x0014(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         Weight;                                            // 0x0018(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         Priority;                                          // 0x001C(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         MaxSpeedScale;                                     // 0x0020(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         SensorSizeScale;                                   // 0x0024(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         RadiusScale;                                       // 0x0028(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         GoalDistanceOffsetPct;                             // 0x002C(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         DirectionHysteresis;                               // 0x0030(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bUseSimplifiedAvoiance;                            // 0x0034(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_35[0x3];                                       // 0x0035(0x0003)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FGbxAvoidanceProperties) == 0x000004, "Wrong alignment on FGbxAvoidanceProperties");
static_assert(sizeof(FGbxAvoidanceProperties) == 0x000038, "Wrong size on FGbxAvoidanceProperties");
static_assert(offsetof(FGbxAvoidanceProperties, WallFollowingAngle) == 0x000000, "Member 'FGbxAvoidanceProperties::WallFollowingAngle' has a wrong offset!");
static_assert(offsetof(FGbxAvoidanceProperties, DodgingPenalty) == 0x000004, "Member 'FGbxAvoidanceProperties::DodgingPenalty' has a wrong offset!");
static_assert(offsetof(FGbxAvoidanceProperties, VelocityHysteresis) == 0x000008, "Member 'FGbxAvoidanceProperties::VelocityHysteresis' has a wrong offset!");
static_assert(offsetof(FGbxAvoidanceProperties, SidednessChangingPenalty) == 0x00000C, "Member 'FGbxAvoidanceProperties::SidednessChangingPenalty' has a wrong offset!");
static_assert(offsetof(FGbxAvoidanceProperties, CollisionPenalty) == 0x000010, "Member 'FGbxAvoidanceProperties::CollisionPenalty' has a wrong offset!");
static_assert(offsetof(FGbxAvoidanceProperties, PenetrationPenalty) == 0x000014, "Member 'FGbxAvoidanceProperties::PenetrationPenalty' has a wrong offset!");
static_assert(offsetof(FGbxAvoidanceProperties, Weight) == 0x000018, "Member 'FGbxAvoidanceProperties::Weight' has a wrong offset!");
static_assert(offsetof(FGbxAvoidanceProperties, Priority) == 0x00001C, "Member 'FGbxAvoidanceProperties::Priority' has a wrong offset!");
static_assert(offsetof(FGbxAvoidanceProperties, MaxSpeedScale) == 0x000020, "Member 'FGbxAvoidanceProperties::MaxSpeedScale' has a wrong offset!");
static_assert(offsetof(FGbxAvoidanceProperties, SensorSizeScale) == 0x000024, "Member 'FGbxAvoidanceProperties::SensorSizeScale' has a wrong offset!");
static_assert(offsetof(FGbxAvoidanceProperties, RadiusScale) == 0x000028, "Member 'FGbxAvoidanceProperties::RadiusScale' has a wrong offset!");
static_assert(offsetof(FGbxAvoidanceProperties, GoalDistanceOffsetPct) == 0x00002C, "Member 'FGbxAvoidanceProperties::GoalDistanceOffsetPct' has a wrong offset!");
static_assert(offsetof(FGbxAvoidanceProperties, DirectionHysteresis) == 0x000030, "Member 'FGbxAvoidanceProperties::DirectionHysteresis' has a wrong offset!");
static_assert(offsetof(FGbxAvoidanceProperties, bUseSimplifiedAvoiance) == 0x000034, "Member 'FGbxAvoidanceProperties::bUseSimplifiedAvoiance' has a wrong offset!");

// ScriptStruct GbxNav.GbxNavMovementOptions
// 0x0038 (0x0038 - 0x0000)
struct FGbxNavMovementOptions final
{
public:
	class UHavokPathFindingData*                  PathFindingData;                                   // 0x0000(0x0008)(ZeroConstructor, Deprecated, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FGbxNavPathingData                     PathingData;                                       // 0x0008(0x0010)(Edit, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EGbxNavMoveStyleDefault                       MoveStyleDefault;                                  // 0x0018(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bCanReverse;                                       // 0x0019(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1A[0x2];                                       // 0x001A(0x0002)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         ReverseGoalDistance;                               // 0x001C(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bCanChangePitchWhenStrafeFlying;                   // 0x0020(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_21[0x3];                                       // 0x0021(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         IdleDirectionTime;                                 // 0x0024(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         NearUserEdgeTimeThreshold;                         // 0x0028(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         UserEdgeEnterDistancePercent;                      // 0x002C(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bMustBeFacingUserEdgeBeforeEntering;               // 0x0030(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_31[0x7];                                       // 0x0031(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FGbxNavMovementOptions) == 0x000008, "Wrong alignment on FGbxNavMovementOptions");
static_assert(sizeof(FGbxNavMovementOptions) == 0x000038, "Wrong size on FGbxNavMovementOptions");
static_assert(offsetof(FGbxNavMovementOptions, PathFindingData) == 0x000000, "Member 'FGbxNavMovementOptions::PathFindingData' has a wrong offset!");
static_assert(offsetof(FGbxNavMovementOptions, PathingData) == 0x000008, "Member 'FGbxNavMovementOptions::PathingData' has a wrong offset!");
static_assert(offsetof(FGbxNavMovementOptions, MoveStyleDefault) == 0x000018, "Member 'FGbxNavMovementOptions::MoveStyleDefault' has a wrong offset!");
static_assert(offsetof(FGbxNavMovementOptions, bCanReverse) == 0x000019, "Member 'FGbxNavMovementOptions::bCanReverse' has a wrong offset!");
static_assert(offsetof(FGbxNavMovementOptions, ReverseGoalDistance) == 0x00001C, "Member 'FGbxNavMovementOptions::ReverseGoalDistance' has a wrong offset!");
static_assert(offsetof(FGbxNavMovementOptions, bCanChangePitchWhenStrafeFlying) == 0x000020, "Member 'FGbxNavMovementOptions::bCanChangePitchWhenStrafeFlying' has a wrong offset!");
static_assert(offsetof(FGbxNavMovementOptions, IdleDirectionTime) == 0x000024, "Member 'FGbxNavMovementOptions::IdleDirectionTime' has a wrong offset!");
static_assert(offsetof(FGbxNavMovementOptions, NearUserEdgeTimeThreshold) == 0x000028, "Member 'FGbxNavMovementOptions::NearUserEdgeTimeThreshold' has a wrong offset!");
static_assert(offsetof(FGbxNavMovementOptions, UserEdgeEnterDistancePercent) == 0x00002C, "Member 'FGbxNavMovementOptions::UserEdgeEnterDistancePercent' has a wrong offset!");
static_assert(offsetof(FGbxNavMovementOptions, bMustBeFacingUserEdgeBeforeEntering) == 0x000030, "Member 'FGbxNavMovementOptions::bMustBeFacingUserEdgeBeforeEntering' has a wrong offset!");

// ScriptStruct GbxNav.GbxReachabilityTracker
// 0x00D0 (0x00D0 - 0x0000)
struct FGbxReachabilityTracker final
{
public:
	class AGbxNavWorld*                           GbxNavWorld;                                       // 0x0000(0x0008)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class USceneComponent*                        CachedSourceRoot;                                  // 0x0008(0x0008)(ExportObject, ZeroConstructor, Transient, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class USceneComponent*                        CachedGoalRoot;                                    // 0x0010(0x0008)(ExportObject, ZeroConstructor, Transient, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_18[0xB8];                                      // 0x0018(0x00B8)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FGbxReachabilityTracker) == 0x000008, "Wrong alignment on FGbxReachabilityTracker");
static_assert(sizeof(FGbxReachabilityTracker) == 0x0000D0, "Wrong size on FGbxReachabilityTracker");
static_assert(offsetof(FGbxReachabilityTracker, GbxNavWorld) == 0x000000, "Member 'FGbxReachabilityTracker::GbxNavWorld' has a wrong offset!");
static_assert(offsetof(FGbxReachabilityTracker, CachedSourceRoot) == 0x000008, "Member 'FGbxReachabilityTracker::CachedSourceRoot' has a wrong offset!");
static_assert(offsetof(FGbxReachabilityTracker, CachedGoalRoot) == 0x000010, "Member 'FGbxReachabilityTracker::CachedGoalRoot' has a wrong offset!");

// ScriptStruct GbxNav.GbxNavAvoidanceOptions
// 0x003C (0x003C - 0x0000)
struct FGbxNavAvoidanceOptions final
{
public:
	bool                                          bAvoidanceSteering;                                // 0x0000(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bAvoidanceObstacle;                                // 0x0001(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bAvoidPawnsBehindMe;                               // 0x0002(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bAvoidWithNoGoal;                                  // 0x0003(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FGbxAvoidanceProperties                AvoidanceProperties;                               // 0x0004(0x0038)(Edit, NoDestructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(FGbxNavAvoidanceOptions) == 0x000004, "Wrong alignment on FGbxNavAvoidanceOptions");
static_assert(sizeof(FGbxNavAvoidanceOptions) == 0x00003C, "Wrong size on FGbxNavAvoidanceOptions");
static_assert(offsetof(FGbxNavAvoidanceOptions, bAvoidanceSteering) == 0x000000, "Member 'FGbxNavAvoidanceOptions::bAvoidanceSteering' has a wrong offset!");
static_assert(offsetof(FGbxNavAvoidanceOptions, bAvoidanceObstacle) == 0x000001, "Member 'FGbxNavAvoidanceOptions::bAvoidanceObstacle' has a wrong offset!");
static_assert(offsetof(FGbxNavAvoidanceOptions, bAvoidPawnsBehindMe) == 0x000002, "Member 'FGbxNavAvoidanceOptions::bAvoidPawnsBehindMe' has a wrong offset!");
static_assert(offsetof(FGbxNavAvoidanceOptions, bAvoidWithNoGoal) == 0x000003, "Member 'FGbxNavAvoidanceOptions::bAvoidWithNoGoal' has a wrong offset!");
static_assert(offsetof(FGbxNavAvoidanceOptions, AvoidanceProperties) == 0x000004, "Member 'FGbxNavAvoidanceOptions::AvoidanceProperties' has a wrong offset!");

// ScriptStruct GbxNav.GbxNavGoalModifiers
// 0x0028 (0x0028 - 0x0000)
struct FGbxNavGoalModifiers final
{
public:
	EGbxOffsetType                                OffsetType;                                        // 0x0000(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1[0x3];                                        // 0x0001(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	struct FVector                                Offset;                                            // 0x0004(0x000C)(Edit, BlueprintVisible, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_10[0xC];                                       // 0x0010(0x000C)(Fixing Size After Last Property [ Dumper-7 ])
	bool                                          bAddAgentRadius;                                   // 0x001C(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bAddAgentHeight;                                   // 0x001D(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bAddGoalRadius;                                    // 0x001E(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bAddGoalHeight;                                    // 0x001F(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bAdjustHeightForMelee;                             // 0x0020(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bCenterOnFloor;                                    // 0x0021(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_22[0x2];                                       // 0x0022(0x0002)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         VerticalFlyOffset;                                 // 0x0024(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FGbxNavGoalModifiers) == 0x000004, "Wrong alignment on FGbxNavGoalModifiers");
static_assert(sizeof(FGbxNavGoalModifiers) == 0x000028, "Wrong size on FGbxNavGoalModifiers");
static_assert(offsetof(FGbxNavGoalModifiers, OffsetType) == 0x000000, "Member 'FGbxNavGoalModifiers::OffsetType' has a wrong offset!");
static_assert(offsetof(FGbxNavGoalModifiers, Offset) == 0x000004, "Member 'FGbxNavGoalModifiers::Offset' has a wrong offset!");
static_assert(offsetof(FGbxNavGoalModifiers, bAddAgentRadius) == 0x00001C, "Member 'FGbxNavGoalModifiers::bAddAgentRadius' has a wrong offset!");
static_assert(offsetof(FGbxNavGoalModifiers, bAddAgentHeight) == 0x00001D, "Member 'FGbxNavGoalModifiers::bAddAgentHeight' has a wrong offset!");
static_assert(offsetof(FGbxNavGoalModifiers, bAddGoalRadius) == 0x00001E, "Member 'FGbxNavGoalModifiers::bAddGoalRadius' has a wrong offset!");
static_assert(offsetof(FGbxNavGoalModifiers, bAddGoalHeight) == 0x00001F, "Member 'FGbxNavGoalModifiers::bAddGoalHeight' has a wrong offset!");
static_assert(offsetof(FGbxNavGoalModifiers, bAdjustHeightForMelee) == 0x000020, "Member 'FGbxNavGoalModifiers::bAdjustHeightForMelee' has a wrong offset!");
static_assert(offsetof(FGbxNavGoalModifiers, bCenterOnFloor) == 0x000021, "Member 'FGbxNavGoalModifiers::bCenterOnFloor' has a wrong offset!");
static_assert(offsetof(FGbxNavGoalModifiers, VerticalFlyOffset) == 0x000024, "Member 'FGbxNavGoalModifiers::VerticalFlyOffset' has a wrong offset!");

// ScriptStruct GbxNav.FlightState
// 0x0028 (0x0028 - 0x0000)
struct FFlightState final
{
public:
	EFlightMovementState                          CurrentMovementState;                              // 0x0000(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1[0x7];                                        // 0x0001(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	class AActor*                                 VehicleSplineActor;                                // 0x0008(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class AActor*                                 DropOffSpawner;                                    // 0x0010(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         AscentTargetLocationZ;                             // 0x0018(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FRotator                               AscentTargetRotation;                              // 0x001C(0x000C)(IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(FFlightState) == 0x000008, "Wrong alignment on FFlightState");
static_assert(sizeof(FFlightState) == 0x000028, "Wrong size on FFlightState");
static_assert(offsetof(FFlightState, CurrentMovementState) == 0x000000, "Member 'FFlightState::CurrentMovementState' has a wrong offset!");
static_assert(offsetof(FFlightState, VehicleSplineActor) == 0x000008, "Member 'FFlightState::VehicleSplineActor' has a wrong offset!");
static_assert(offsetof(FFlightState, DropOffSpawner) == 0x000010, "Member 'FFlightState::DropOffSpawner' has a wrong offset!");
static_assert(offsetof(FFlightState, AscentTargetLocationZ) == 0x000018, "Member 'FFlightState::AscentTargetLocationZ' has a wrong offset!");
static_assert(offsetof(FFlightState, AscentTargetRotation) == 0x00001C, "Member 'FFlightState::AscentTargetRotation' has a wrong offset!");

// ScriptStruct GbxNav.GbxNavIdleTurnTableRow
// 0x0000 (0x0020 - 0x0020)
struct FGbxNavIdleTurnTableRow final : public FGbxAnimTableRow
{
};
static_assert(alignof(FGbxNavIdleTurnTableRow) == 0x000008, "Wrong alignment on FGbxNavIdleTurnTableRow");
static_assert(sizeof(FGbxNavIdleTurnTableRow) == 0x000020, "Wrong size on FGbxNavIdleTurnTableRow");

// ScriptStruct GbxNav.GbxNavAnimTableRow
// 0x0018 (0x0038 - 0x0020)
struct FGbxNavAnimTableRow final : public FGbxAnimTableRow
{
public:
	struct FNumericRange                          Angle;                                             // 0x0020(0x0008)(Edit, NoDestructor, NativeAccessSpecifierPublic)
	bool                                          bCorner;                                           // 0x0028(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_29[0x3];                                       // 0x0029(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         CornerMaxAngle;                                    // 0x002C(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bCanStretchRotation;                               // 0x0030(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bAutoFill;                                         // 0x0031(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_32[0x6];                                       // 0x0032(0x0006)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FGbxNavAnimTableRow) == 0x000008, "Wrong alignment on FGbxNavAnimTableRow");
static_assert(sizeof(FGbxNavAnimTableRow) == 0x000038, "Wrong size on FGbxNavAnimTableRow");
static_assert(offsetof(FGbxNavAnimTableRow, Angle) == 0x000020, "Member 'FGbxNavAnimTableRow::Angle' has a wrong offset!");
static_assert(offsetof(FGbxNavAnimTableRow, bCorner) == 0x000028, "Member 'FGbxNavAnimTableRow::bCorner' has a wrong offset!");
static_assert(offsetof(FGbxNavAnimTableRow, CornerMaxAngle) == 0x00002C, "Member 'FGbxNavAnimTableRow::CornerMaxAngle' has a wrong offset!");
static_assert(offsetof(FGbxNavAnimTableRow, bCanStretchRotation) == 0x000030, "Member 'FGbxNavAnimTableRow::bCanStretchRotation' has a wrong offset!");
static_assert(offsetof(FGbxNavAnimTableRow, bAutoFill) == 0x000031, "Member 'FGbxNavAnimTableRow::bAutoFill' has a wrong offset!");

// ScriptStruct GbxNav.GbxPainterData
// 0x0010 (0x0010 - 0x0000)
struct FGbxPainterData final
{
public:
	class UGbxNavMeshPainterComponent*            Painter;                                           // 0x0000(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_8[0x8];                                        // 0x0008(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FGbxPainterData) == 0x000008, "Wrong alignment on FGbxPainterData");
static_assert(sizeof(FGbxPainterData) == 0x000010, "Wrong size on FGbxPainterData");
static_assert(offsetof(FGbxPainterData, Painter) == 0x000000, "Member 'FGbxPainterData::Painter' has a wrong offset!");

// ScriptStruct GbxNav.GbxPainterManager
// 0x0020 (0x0020 - 0x0000)
struct FGbxPainterManager final
{
public:
	TArray<class UGbxNavArea*>                    NavAreas;                                          // 0x0000(0x0010)(ZeroConstructor, NativeAccessSpecifierPrivate)
	TArray<struct FGbxPainterData>                Painters;                                          // 0x0010(0x0010)(ZeroConstructor, Transient, ContainsInstancedReference, NativeAccessSpecifierPrivate)
};
static_assert(alignof(FGbxPainterManager) == 0x000008, "Wrong alignment on FGbxPainterManager");
static_assert(sizeof(FGbxPainterManager) == 0x000020, "Wrong size on FGbxPainterManager");
static_assert(offsetof(FGbxPainterManager, NavAreas) == 0x000000, "Member 'FGbxPainterManager::NavAreas' has a wrong offset!");
static_assert(offsetof(FGbxPainterManager, Painters) == 0x000010, "Member 'FGbxPainterManager::Painters' has a wrong offset!");

// ScriptStruct GbxNav.GbxNavAreaItem
// 0x0018 (0x0018 - 0x0000)
struct FGbxNavAreaItem final
{
public:
	class UGbxNavArea*                            GbxNavArea;                                        // 0x0000(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         CostScale;                                         // 0x0008(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_C[0x4];                                        // 0x000C(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	TSubclassOf<class UNavArea>                   NavArea;                                           // 0x0010(0x0008)(ZeroConstructor, Deprecated, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FGbxNavAreaItem) == 0x000008, "Wrong alignment on FGbxNavAreaItem");
static_assert(sizeof(FGbxNavAreaItem) == 0x000018, "Wrong size on FGbxNavAreaItem");
static_assert(offsetof(FGbxNavAreaItem, GbxNavArea) == 0x000000, "Member 'FGbxNavAreaItem::GbxNavArea' has a wrong offset!");
static_assert(offsetof(FGbxNavAreaItem, CostScale) == 0x000008, "Member 'FGbxNavAreaItem::CostScale' has a wrong offset!");
static_assert(offsetof(FGbxNavAreaItem, NavArea) == 0x000010, "Member 'FGbxNavAreaItem::NavArea' has a wrong offset!");

// ScriptStruct GbxNav.GbxNavBoundsTracker
// 0x0038 (0x0038 - 0x0000)
struct FGbxNavBoundsTracker final
{
public:
	struct FBox                                   Bounds;                                            // 0x0000(0x001C)(IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
	uint8                                         Pad_1C[0x4];                                       // 0x001C(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class UPrimitiveComponent*                    PrimitiveComponent;                                // 0x0020(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TArray<struct FVector>                        HullPoints;                                        // 0x0028(0x0010)(ZeroConstructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(FGbxNavBoundsTracker) == 0x000008, "Wrong alignment on FGbxNavBoundsTracker");
static_assert(sizeof(FGbxNavBoundsTracker) == 0x000038, "Wrong size on FGbxNavBoundsTracker");
static_assert(offsetof(FGbxNavBoundsTracker, Bounds) == 0x000000, "Member 'FGbxNavBoundsTracker::Bounds' has a wrong offset!");
static_assert(offsetof(FGbxNavBoundsTracker, PrimitiveComponent) == 0x000020, "Member 'FGbxNavBoundsTracker::PrimitiveComponent' has a wrong offset!");
static_assert(offsetof(FGbxNavBoundsTracker, HullPoints) == 0x000028, "Member 'FGbxNavBoundsTracker::HullPoints' has a wrong offset!");

// ScriptStruct GbxNav.GbxNavCorrecter
// 0x00B8 (0x00B8 - 0x0000)
struct FGbxNavCorrecter final
{
public:
	class UWorld*                                 World;                                             // 0x0000(0x0008)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class AGbxNavWorld*                           GbxNavWorld;                                       // 0x0008(0x0008)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UGbxNavComponent*                       NavComp;                                           // 0x0010(0x0008)(ExportObject, ZeroConstructor, Transient, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class AActor*                                 PathingActor;                                      // 0x0018(0x0008)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UGbxCharacterMovementComponent*         MoveComp;                                          // 0x0020(0x0008)(ExportObject, ZeroConstructor, Transient, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	struct FNavAgentProperties                    NavAgentProps;                                     // 0x0028(0x0030)(Transient, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	struct FSavedCollision                        SavedCollision;                                    // 0x0058(0x0020)(Transient, ContainsInstancedReference, NativeAccessSpecifierPrivate)
	uint8                                         Pad_78[0x40];                                      // 0x0078(0x0040)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FGbxNavCorrecter) == 0x000008, "Wrong alignment on FGbxNavCorrecter");
static_assert(sizeof(FGbxNavCorrecter) == 0x0000B8, "Wrong size on FGbxNavCorrecter");
static_assert(offsetof(FGbxNavCorrecter, World) == 0x000000, "Member 'FGbxNavCorrecter::World' has a wrong offset!");
static_assert(offsetof(FGbxNavCorrecter, GbxNavWorld) == 0x000008, "Member 'FGbxNavCorrecter::GbxNavWorld' has a wrong offset!");
static_assert(offsetof(FGbxNavCorrecter, NavComp) == 0x000010, "Member 'FGbxNavCorrecter::NavComp' has a wrong offset!");
static_assert(offsetof(FGbxNavCorrecter, PathingActor) == 0x000018, "Member 'FGbxNavCorrecter::PathingActor' has a wrong offset!");
static_assert(offsetof(FGbxNavCorrecter, MoveComp) == 0x000020, "Member 'FGbxNavCorrecter::MoveComp' has a wrong offset!");
static_assert(offsetof(FGbxNavCorrecter, NavAgentProps) == 0x000028, "Member 'FGbxNavCorrecter::NavAgentProps' has a wrong offset!");
static_assert(offsetof(FGbxNavCorrecter, SavedCollision) == 0x000058, "Member 'FGbxNavCorrecter::SavedCollision' has a wrong offset!");

// ScriptStruct GbxNav.GbxNavForwardState
// 0x0128 (0x0128 - 0x0000)
struct FGbxNavForwardState final
{
public:
	float                                         MinSpeedScale;                                     // 0x0000(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	bool                                          bScaleSpeed;                                       // 0x0004(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_5[0x3];                                        // 0x0005(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         MaxTurnScale;                                      // 0x0008(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	bool                                          bScaleRotation;                                    // 0x000C(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_D[0x3];                                        // 0x000D(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         ScaleInterpTime;                                   // 0x0010(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	struct FNumericRange                          DistanceRange;                                     // 0x0014(0x0008)(Edit, NoDestructor, NativeAccessSpecifierPrivate)
	float                                         WallCheckDegreesPerSegment;                        // 0x001C(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	float                                         MinTurnRadius;                                     // 0x0020(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_24[0x4];                                       // 0x0024(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class UWorld*                                 World;                                             // 0x0028(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class AGbxNavWorld*                           GbxNavWorld;                                       // 0x0030(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UGbxNavComponent*                       NavComponent;                                      // 0x0038(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UGbxCharacterMovementComponent*         MovementComponent;                                 // 0x0040(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UAIVehicleFlightComponent*              VehicleFlightComponent;                            // 0x0048(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_50[0xD8];                                      // 0x0050(0x00D8)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FGbxNavForwardState) == 0x000008, "Wrong alignment on FGbxNavForwardState");
static_assert(sizeof(FGbxNavForwardState) == 0x000128, "Wrong size on FGbxNavForwardState");
static_assert(offsetof(FGbxNavForwardState, MinSpeedScale) == 0x000000, "Member 'FGbxNavForwardState::MinSpeedScale' has a wrong offset!");
static_assert(offsetof(FGbxNavForwardState, bScaleSpeed) == 0x000004, "Member 'FGbxNavForwardState::bScaleSpeed' has a wrong offset!");
static_assert(offsetof(FGbxNavForwardState, MaxTurnScale) == 0x000008, "Member 'FGbxNavForwardState::MaxTurnScale' has a wrong offset!");
static_assert(offsetof(FGbxNavForwardState, bScaleRotation) == 0x00000C, "Member 'FGbxNavForwardState::bScaleRotation' has a wrong offset!");
static_assert(offsetof(FGbxNavForwardState, ScaleInterpTime) == 0x000010, "Member 'FGbxNavForwardState::ScaleInterpTime' has a wrong offset!");
static_assert(offsetof(FGbxNavForwardState, DistanceRange) == 0x000014, "Member 'FGbxNavForwardState::DistanceRange' has a wrong offset!");
static_assert(offsetof(FGbxNavForwardState, WallCheckDegreesPerSegment) == 0x00001C, "Member 'FGbxNavForwardState::WallCheckDegreesPerSegment' has a wrong offset!");
static_assert(offsetof(FGbxNavForwardState, MinTurnRadius) == 0x000020, "Member 'FGbxNavForwardState::MinTurnRadius' has a wrong offset!");
static_assert(offsetof(FGbxNavForwardState, World) == 0x000028, "Member 'FGbxNavForwardState::World' has a wrong offset!");
static_assert(offsetof(FGbxNavForwardState, GbxNavWorld) == 0x000030, "Member 'FGbxNavForwardState::GbxNavWorld' has a wrong offset!");
static_assert(offsetof(FGbxNavForwardState, NavComponent) == 0x000038, "Member 'FGbxNavForwardState::NavComponent' has a wrong offset!");
static_assert(offsetof(FGbxNavForwardState, MovementComponent) == 0x000040, "Member 'FGbxNavForwardState::MovementComponent' has a wrong offset!");
static_assert(offsetof(FGbxNavForwardState, VehicleFlightComponent) == 0x000048, "Member 'FGbxNavForwardState::VehicleFlightComponent' has a wrong offset!");

// ScriptStruct GbxNav.GbxNavLayerItem
// 0x0020 (0x0020 - 0x0000)
struct FGbxNavLayerItem final
{
public:
	class UGbxNavLayer*                           NavLayer;                                          // 0x0000(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         Radius;                                            // 0x0008(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         HalfHeight;                                        // 0x000C(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         LayerIdx;                                          // 0x0010(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FColor                                 Color;                                             // 0x0014(0x0004)(IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TSubclassOf<class UHavokNavLayer>             Layer;                                             // 0x0018(0x0008)(ZeroConstructor, Deprecated, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FGbxNavLayerItem) == 0x000008, "Wrong alignment on FGbxNavLayerItem");
static_assert(sizeof(FGbxNavLayerItem) == 0x000020, "Wrong size on FGbxNavLayerItem");
static_assert(offsetof(FGbxNavLayerItem, NavLayer) == 0x000000, "Member 'FGbxNavLayerItem::NavLayer' has a wrong offset!");
static_assert(offsetof(FGbxNavLayerItem, Radius) == 0x000008, "Member 'FGbxNavLayerItem::Radius' has a wrong offset!");
static_assert(offsetof(FGbxNavLayerItem, HalfHeight) == 0x00000C, "Member 'FGbxNavLayerItem::HalfHeight' has a wrong offset!");
static_assert(offsetof(FGbxNavLayerItem, LayerIdx) == 0x000010, "Member 'FGbxNavLayerItem::LayerIdx' has a wrong offset!");
static_assert(offsetof(FGbxNavLayerItem, Color) == 0x000014, "Member 'FGbxNavLayerItem::Color' has a wrong offset!");
static_assert(offsetof(FGbxNavLayerItem, Layer) == 0x000018, "Member 'FGbxNavLayerItem::Layer' has a wrong offset!");

// ScriptStruct GbxNav.GbxNavLayerState
// 0x0018 (0x0018 - 0x0000)
struct FGbxNavLayerState final
{
public:
	TArray<struct FGbxNavLayerItem>               Layers;                                            // 0x0000(0x0010)(ZeroConstructor, NativeAccessSpecifierPrivate)
	class AGbxNavWorld*                           GbxNavWorld;                                       // 0x0010(0x0008)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
};
static_assert(alignof(FGbxNavLayerState) == 0x000008, "Wrong alignment on FGbxNavLayerState");
static_assert(sizeof(FGbxNavLayerState) == 0x000018, "Wrong size on FGbxNavLayerState");
static_assert(offsetof(FGbxNavLayerState, Layers) == 0x000000, "Member 'FGbxNavLayerState::Layers' has a wrong offset!");
static_assert(offsetof(FGbxNavLayerState, GbxNavWorld) == 0x000010, "Member 'FGbxNavLayerState::GbxNavWorld' has a wrong offset!");

// ScriptStruct GbxNav.TeleportUserEdgeData
// 0x0050 (0x0050 - 0x0000)
struct FTeleportUserEdgeData final
{
public:
	uint8                                         Pad_0[0x38];                                       // 0x0000(0x0038)(Fixing Size After Last Property [ Dumper-7 ])
	TSubclassOf<class UGbxAction>                 EntryAction;                                       // 0x0038(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TSubclassOf<class UGbxAction>                 TeleportAction;                                    // 0x0040(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TSubclassOf<class UGbxAction>                 ExitAction;                                        // 0x0048(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FTeleportUserEdgeData) == 0x000008, "Wrong alignment on FTeleportUserEdgeData");
static_assert(sizeof(FTeleportUserEdgeData) == 0x000050, "Wrong size on FTeleportUserEdgeData");
static_assert(offsetof(FTeleportUserEdgeData, EntryAction) == 0x000038, "Member 'FTeleportUserEdgeData::EntryAction' has a wrong offset!");
static_assert(offsetof(FTeleportUserEdgeData, TeleportAction) == 0x000040, "Member 'FTeleportUserEdgeData::TeleportAction' has a wrong offset!");
static_assert(offsetof(FTeleportUserEdgeData, ExitAction) == 0x000048, "Member 'FTeleportUserEdgeData::ExitAction' has a wrong offset!");

// ScriptStruct GbxNav.GbxPainterItem
// 0x0020 (0x0020 - 0x0000)
struct FGbxPainterItem final
{
public:
	uint8                                         Pad_0[0x18];                                       // 0x0000(0x0018)(Fixing Size After Last Property [ Dumper-7 ])
	class UPrimitiveComponent*                    Component;                                         // 0x0018(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FGbxPainterItem) == 0x000008, "Wrong alignment on FGbxPainterItem");
static_assert(sizeof(FGbxPainterItem) == 0x000020, "Wrong size on FGbxPainterItem");
static_assert(offsetof(FGbxPainterItem, Component) == 0x000018, "Member 'FGbxPainterItem::Component' has a wrong offset!");

// ScriptStruct GbxNav.GbxNavSectionBounds
// 0x0040 (0x0040 - 0x0000)
struct FGbxNavSectionBounds final
{
public:
	struct FBox                                   WorldBoxBound;                                     // 0x0000(0x001C)(IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
	uint8                                         Pad_1C[0x4];                                       // 0x001C(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<struct FVector>                        WorldConvexHullPoints;                             // 0x0020(0x0010)(ZeroConstructor, NativeAccessSpecifierPublic)
	struct FGuid                                  DominationGuid;                                    // 0x0030(0x0010)(IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FGbxNavSectionBounds) == 0x000008, "Wrong alignment on FGbxNavSectionBounds");
static_assert(sizeof(FGbxNavSectionBounds) == 0x000040, "Wrong size on FGbxNavSectionBounds");
static_assert(offsetof(FGbxNavSectionBounds, WorldBoxBound) == 0x000000, "Member 'FGbxNavSectionBounds::WorldBoxBound' has a wrong offset!");
static_assert(offsetof(FGbxNavSectionBounds, WorldConvexHullPoints) == 0x000020, "Member 'FGbxNavSectionBounds::WorldConvexHullPoints' has a wrong offset!");
static_assert(offsetof(FGbxNavSectionBounds, DominationGuid) == 0x000030, "Member 'FGbxNavSectionBounds::DominationGuid' has a wrong offset!");

// ScriptStruct GbxNav.GbxNavStreamingData
// 0x0020 (0x0020 - 0x0000)
struct FGbxNavStreamingData final
{
public:
	struct FGuid                                  Guid;                                              // 0x0000(0x0010)(IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	TArray<class UHavokStreamingSet*>             Sets;                                              // 0x0010(0x0010)(ZeroConstructor, NativeAccessSpecifierPrivate)
};
static_assert(alignof(FGbxNavStreamingData) == 0x000008, "Wrong alignment on FGbxNavStreamingData");
static_assert(sizeof(FGbxNavStreamingData) == 0x000020, "Wrong size on FGbxNavStreamingData");
static_assert(offsetof(FGbxNavStreamingData, Guid) == 0x000000, "Member 'FGbxNavStreamingData::Guid' has a wrong offset!");
static_assert(offsetof(FGbxNavStreamingData, Sets) == 0x000010, "Member 'FGbxNavStreamingData::Sets' has a wrong offset!");

// ScriptStruct GbxNav.GbxNavStuckState
// 0x0068 (0x0068 - 0x0000)
struct FGbxNavStuckState final
{
public:
	class UWorld*                                 World;                                             // 0x0000(0x0008)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UGbxNavComponent*                       NavComp;                                           // 0x0008(0x0008)(ExportObject, ZeroConstructor, Transient, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class AActor*                                 PathingActor;                                      // 0x0010(0x0008)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UGbxCharacterMovementComponent*         GbxMoveComp;                                       // 0x0018(0x0008)(ExportObject, ZeroConstructor, Transient, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_20[0x24];                                      // 0x0020(0x0024)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         StuckDistance;                                     // 0x0044(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	float                                         StuckVelocity;                                     // 0x0048(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	float                                         StuckWaitTime;                                     // 0x004C(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	bool                                          bStuckFixEnabled;                                  // 0x0050(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_51[0x3];                                       // 0x0051(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         StuckFixStartTime;                                 // 0x0054(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	float                                         StuckFixStopTime;                                  // 0x0058(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_5C[0xC];                                       // 0x005C(0x000C)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FGbxNavStuckState) == 0x000008, "Wrong alignment on FGbxNavStuckState");
static_assert(sizeof(FGbxNavStuckState) == 0x000068, "Wrong size on FGbxNavStuckState");
static_assert(offsetof(FGbxNavStuckState, World) == 0x000000, "Member 'FGbxNavStuckState::World' has a wrong offset!");
static_assert(offsetof(FGbxNavStuckState, NavComp) == 0x000008, "Member 'FGbxNavStuckState::NavComp' has a wrong offset!");
static_assert(offsetof(FGbxNavStuckState, PathingActor) == 0x000010, "Member 'FGbxNavStuckState::PathingActor' has a wrong offset!");
static_assert(offsetof(FGbxNavStuckState, GbxMoveComp) == 0x000018, "Member 'FGbxNavStuckState::GbxMoveComp' has a wrong offset!");
static_assert(offsetof(FGbxNavStuckState, StuckDistance) == 0x000044, "Member 'FGbxNavStuckState::StuckDistance' has a wrong offset!");
static_assert(offsetof(FGbxNavStuckState, StuckVelocity) == 0x000048, "Member 'FGbxNavStuckState::StuckVelocity' has a wrong offset!");
static_assert(offsetof(FGbxNavStuckState, StuckWaitTime) == 0x00004C, "Member 'FGbxNavStuckState::StuckWaitTime' has a wrong offset!");
static_assert(offsetof(FGbxNavStuckState, bStuckFixEnabled) == 0x000050, "Member 'FGbxNavStuckState::bStuckFixEnabled' has a wrong offset!");
static_assert(offsetof(FGbxNavStuckState, StuckFixStartTime) == 0x000054, "Member 'FGbxNavStuckState::StuckFixStartTime' has a wrong offset!");
static_assert(offsetof(FGbxNavStuckState, StuckFixStopTime) == 0x000058, "Member 'FGbxNavStuckState::StuckFixStopTime' has a wrong offset!");

// ScriptStruct GbxNav.GbxReachabilityState
// 0x0090 (0x0090 - 0x0000)
struct FGbxReachabilityState final
{
public:
	class AGbxNavWorld*                           GbxNavWorld;                                       // 0x0000(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UGbxNavComponent*                       NavComp;                                           // 0x0008(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_10[0x80];                                      // 0x0010(0x0080)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FGbxReachabilityState) == 0x000008, "Wrong alignment on FGbxReachabilityState");
static_assert(sizeof(FGbxReachabilityState) == 0x000090, "Wrong size on FGbxReachabilityState");
static_assert(offsetof(FGbxReachabilityState, GbxNavWorld) == 0x000000, "Member 'FGbxReachabilityState::GbxNavWorld' has a wrong offset!");
static_assert(offsetof(FGbxReachabilityState, NavComp) == 0x000008, "Member 'FGbxReachabilityState::NavComp' has a wrong offset!");

// ScriptStruct GbxNav.GbxUserEdgeTeleportType
// 0x0020 (0x0020 - 0x0000)
struct FGbxUserEdgeTeleportType final
{
public:
	class UGbxUserEdge*                           EntryEdge;                                         // 0x0000(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UGbxUserEdge*                           ExitEdge;                                          // 0x0008(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TSubclassOf<class UHavokUserEdge>             Entry;                                             // 0x0010(0x0008)(ZeroConstructor, Deprecated, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TSubclassOf<class UHavokUserEdge>             Exit;                                              // 0x0018(0x0008)(ZeroConstructor, Deprecated, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FGbxUserEdgeTeleportType) == 0x000008, "Wrong alignment on FGbxUserEdgeTeleportType");
static_assert(sizeof(FGbxUserEdgeTeleportType) == 0x000020, "Wrong size on FGbxUserEdgeTeleportType");
static_assert(offsetof(FGbxUserEdgeTeleportType, EntryEdge) == 0x000000, "Member 'FGbxUserEdgeTeleportType::EntryEdge' has a wrong offset!");
static_assert(offsetof(FGbxUserEdgeTeleportType, ExitEdge) == 0x000008, "Member 'FGbxUserEdgeTeleportType::ExitEdge' has a wrong offset!");
static_assert(offsetof(FGbxUserEdgeTeleportType, Entry) == 0x000010, "Member 'FGbxUserEdgeTeleportType::Entry' has a wrong offset!");
static_assert(offsetof(FGbxUserEdgeTeleportType, Exit) == 0x000018, "Member 'FGbxUserEdgeTeleportType::Exit' has a wrong offset!");

// ScriptStruct GbxNav.GbxDynamicUserEdgeInfo
// 0x0050 (0x0050 - 0x0000)
struct FGbxDynamicUserEdgeInfo final
{
public:
	class UGbxNavUserEdgeTrailComponent*          Component;                                         // 0x0000(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_8[0x48];                                       // 0x0008(0x0048)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FGbxDynamicUserEdgeInfo) == 0x000008, "Wrong alignment on FGbxDynamicUserEdgeInfo");
static_assert(sizeof(FGbxDynamicUserEdgeInfo) == 0x000050, "Wrong size on FGbxDynamicUserEdgeInfo");
static_assert(offsetof(FGbxDynamicUserEdgeInfo, Component) == 0x000000, "Member 'FGbxDynamicUserEdgeInfo::Component' has a wrong offset!");

// ScriptStruct GbxNav.GbxUserEdgeData
// 0x0010 (0x0010 - 0x0000)
struct FGbxUserEdgeData final
{
public:
	class UHavokUserEdgeComponent*                Edge;                                              // 0x0000(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_8[0x8];                                        // 0x0008(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FGbxUserEdgeData) == 0x000008, "Wrong alignment on FGbxUserEdgeData");
static_assert(sizeof(FGbxUserEdgeData) == 0x000010, "Wrong size on FGbxUserEdgeData");
static_assert(offsetof(FGbxUserEdgeData, Edge) == 0x000000, "Member 'FGbxUserEdgeData::Edge' has a wrong offset!");

// ScriptStruct GbxNav.GbxUserEdgeManager
// 0x0060 (0x0060 - 0x0000)
struct FGbxUserEdgeManager final
{
public:
	TArray<class UGbxUserEdge*>                   NormalEdgeTypes;                                   // 0x0000(0x0010)(ZeroConstructor, NativeAccessSpecifierPrivate)
	TArray<struct FGbxUserEdgeTeleportType>       TeleportTypes;                                     // 0x0010(0x0010)(ZeroConstructor, NativeAccessSpecifierPrivate)
	TArray<struct FGbxUserEdgeData>               Edges;                                             // 0x0020(0x0010)(ZeroConstructor, Transient, ContainsInstancedReference, NativeAccessSpecifierPrivate)
	TArray<struct FGbxDynamicUserEdgeInfo>        UserEdgesToAdd;                                    // 0x0030(0x0010)(ZeroConstructor, Transient, ContainsInstancedReference, NativeAccessSpecifierPrivate)
	TArray<uint32>                                UserEdgesToRemove;                                 // 0x0040(0x0010)(ZeroConstructor, Transient, NativeAccessSpecifierPrivate)
	TArray<TSubclassOf<class UHavokUserEdge>>     NormalTypes;                                       // 0x0050(0x0010)(ZeroConstructor, Deprecated, UObjectWrapper, NativeAccessSpecifierPrivate)
};
static_assert(alignof(FGbxUserEdgeManager) == 0x000008, "Wrong alignment on FGbxUserEdgeManager");
static_assert(sizeof(FGbxUserEdgeManager) == 0x000060, "Wrong size on FGbxUserEdgeManager");
static_assert(offsetof(FGbxUserEdgeManager, NormalEdgeTypes) == 0x000000, "Member 'FGbxUserEdgeManager::NormalEdgeTypes' has a wrong offset!");
static_assert(offsetof(FGbxUserEdgeManager, TeleportTypes) == 0x000010, "Member 'FGbxUserEdgeManager::TeleportTypes' has a wrong offset!");
static_assert(offsetof(FGbxUserEdgeManager, Edges) == 0x000020, "Member 'FGbxUserEdgeManager::Edges' has a wrong offset!");
static_assert(offsetof(FGbxUserEdgeManager, UserEdgesToAdd) == 0x000030, "Member 'FGbxUserEdgeManager::UserEdgesToAdd' has a wrong offset!");
static_assert(offsetof(FGbxUserEdgeManager, UserEdgesToRemove) == 0x000040, "Member 'FGbxUserEdgeManager::UserEdgesToRemove' has a wrong offset!");
static_assert(offsetof(FGbxUserEdgeManager, NormalTypes) == 0x000050, "Member 'FGbxUserEdgeManager::NormalTypes' has a wrong offset!");

// ScriptStruct GbxNav.GbxUserEdgeState
// 0x01A0 (0x01A0 - 0x0000)
struct FGbxUserEdgeState final
{
public:
	uint8                                         Pad_0[0x40];                                       // 0x0000(0x0040)(Fixing Size After Last Property [ Dumper-7 ])
	struct FBasedPosition                         EntryPosition;                                     // 0x0040(0x0038)(Transient, NoDestructor, NativeAccessSpecifierPrivate)
	struct FBasedPosition                         ExitPosition;                                      // 0x0078(0x0038)(Transient, NoDestructor, NativeAccessSpecifierPrivate)
	struct FTeleportUserEdgeData                  TeleportData;                                      // 0x00B0(0x0050)(Transient, NoDestructor, NativeAccessSpecifierPrivate)
	class AGbxNavWorld*                           GbxNavWorld;                                       // 0x0100(0x0008)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UGbxNavComponent*                       NavComp;                                           // 0x0108(0x0008)(ExportObject, ZeroConstructor, Transient, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UGbxActionComponent*                    GbxActionComp;                                     // 0x0110(0x0008)(ExportObject, ZeroConstructor, Transient, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class AAIController*                          AIController;                                      // 0x0118(0x0008)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_120[0x80];                                     // 0x0120(0x0080)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FGbxUserEdgeState) == 0x000008, "Wrong alignment on FGbxUserEdgeState");
static_assert(sizeof(FGbxUserEdgeState) == 0x0001A0, "Wrong size on FGbxUserEdgeState");
static_assert(offsetof(FGbxUserEdgeState, EntryPosition) == 0x000040, "Member 'FGbxUserEdgeState::EntryPosition' has a wrong offset!");
static_assert(offsetof(FGbxUserEdgeState, ExitPosition) == 0x000078, "Member 'FGbxUserEdgeState::ExitPosition' has a wrong offset!");
static_assert(offsetof(FGbxUserEdgeState, TeleportData) == 0x0000B0, "Member 'FGbxUserEdgeState::TeleportData' has a wrong offset!");
static_assert(offsetof(FGbxUserEdgeState, GbxNavWorld) == 0x000100, "Member 'FGbxUserEdgeState::GbxNavWorld' has a wrong offset!");
static_assert(offsetof(FGbxUserEdgeState, NavComp) == 0x000108, "Member 'FGbxUserEdgeState::NavComp' has a wrong offset!");
static_assert(offsetof(FGbxUserEdgeState, GbxActionComp) == 0x000110, "Member 'FGbxUserEdgeState::GbxActionComp' has a wrong offset!");
static_assert(offsetof(FGbxUserEdgeState, AIController) == 0x000118, "Member 'FGbxUserEdgeState::AIController' has a wrong offset!");

// ScriptStruct GbxNav.HavokUserEdgeItem
// 0x0020 (0x0020 - 0x0000)
struct FHavokUserEdgeItem final
{
public:
	class UGbxUserEdge*                           GbxUserEdge;                                       // 0x0000(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         CostScale;                                         // 0x0008(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         MaxDistance;                                       // 0x000C(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TSubclassOf<class UGbxAction>                 Action;                                            // 0x0010(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TSubclassOf<class UHavokUserEdge>             UserEdge;                                          // 0x0018(0x0008)(ZeroConstructor, Deprecated, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FHavokUserEdgeItem) == 0x000008, "Wrong alignment on FHavokUserEdgeItem");
static_assert(sizeof(FHavokUserEdgeItem) == 0x000020, "Wrong size on FHavokUserEdgeItem");
static_assert(offsetof(FHavokUserEdgeItem, GbxUserEdge) == 0x000000, "Member 'FHavokUserEdgeItem::GbxUserEdge' has a wrong offset!");
static_assert(offsetof(FHavokUserEdgeItem, CostScale) == 0x000008, "Member 'FHavokUserEdgeItem::CostScale' has a wrong offset!");
static_assert(offsetof(FHavokUserEdgeItem, MaxDistance) == 0x00000C, "Member 'FHavokUserEdgeItem::MaxDistance' has a wrong offset!");
static_assert(offsetof(FHavokUserEdgeItem, Action) == 0x000010, "Member 'FHavokUserEdgeItem::Action' has a wrong offset!");
static_assert(offsetof(FHavokUserEdgeItem, UserEdge) == 0x000018, "Member 'FHavokUserEdgeItem::UserEdge' has a wrong offset!");

// ScriptStruct GbxNav.HavokUserEdgePreviewItem
// 0x0018 (0x0018 - 0x0000)
struct FHavokUserEdgePreviewItem final
{
public:
	TSubclassOf<class AActor>                     ActorClass;                                        // 0x0000(0x0008)(Edit, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TSubclassOf<class UGbxAction>                 ForwardAction;                                     // 0x0008(0x0008)(Edit, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TSubclassOf<class UGbxAction>                 ReverseAction;                                     // 0x0010(0x0008)(Edit, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FHavokUserEdgePreviewItem) == 0x000008, "Wrong alignment on FHavokUserEdgePreviewItem");
static_assert(sizeof(FHavokUserEdgePreviewItem) == 0x000018, "Wrong size on FHavokUserEdgePreviewItem");
static_assert(offsetof(FHavokUserEdgePreviewItem, ActorClass) == 0x000000, "Member 'FHavokUserEdgePreviewItem::ActorClass' has a wrong offset!");
static_assert(offsetof(FHavokUserEdgePreviewItem, ForwardAction) == 0x000008, "Member 'FHavokUserEdgePreviewItem::ForwardAction' has a wrong offset!");
static_assert(offsetof(FHavokUserEdgePreviewItem, ReverseAction) == 0x000010, "Member 'FHavokUserEdgePreviewItem::ReverseAction' has a wrong offset!");

}

