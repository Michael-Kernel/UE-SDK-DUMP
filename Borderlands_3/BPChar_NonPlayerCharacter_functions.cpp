#pragma once

/*
* SDK generated by Dumper-7
*
* https://github.com/Encryqed/Dumper-7
*/

// Package: BPChar_NonPlayerCharacter

#include "Basic.hpp"

#include "BPChar_NonPlayerCharacter_classes.hpp"
#include "BPChar_NonPlayerCharacter_parameters.hpp"


namespace SDK
{

// Function BPChar_NonPlayerCharacter.BPChar_NonPlayerCharacter_C.NPCEngageRange
// (Public, BlueprintCallable, BlueprintEvent)
// Parameters:
// float                                   UnitIn                                                 (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)

void ABPChar_NonPlayerCharacter_C::NPCEngageRange(float UnitIn)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BPChar_NonPlayerCharacter_C", "NPCEngageRange");

	Params::BPChar_NonPlayerCharacter_C_NPCEngageRange Parms{};

	Parms.UnitIn = UnitIn;

	UObject::ProcessEvent(Func, &Parms);
}


// Function BPChar_NonPlayerCharacter.BPChar_NonPlayerCharacter_C.OnRep_ItemPoolInfo
// (BlueprintCallable, BlueprintEvent)

void ABPChar_NonPlayerCharacter_C::OnRep_ItemPoolInfo()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BPChar_NonPlayerCharacter_C", "OnRep_ItemPoolInfo");

	UObject::ProcessEvent(Func, nullptr);
}


// Function BPChar_NonPlayerCharacter.BPChar_NonPlayerCharacter_C.NPCIgnoreEnemies
// (Public, BlueprintCallable, BlueprintEvent)
// Parameters:
// bool                                    BoolValue                                              (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor)

void ABPChar_NonPlayerCharacter_C::NPCIgnoreEnemies(bool BoolValue)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BPChar_NonPlayerCharacter_C", "NPCIgnoreEnemies");

	Params::BPChar_NonPlayerCharacter_C_NPCIgnoreEnemies Parms{};

	Parms.BoolValue = BoolValue;

	UObject::ProcessEvent(Func, &Parms);
}


// Function BPChar_NonPlayerCharacter.BPChar_NonPlayerCharacter_C.NPCUseSmartObjects
// (Public, BlueprintCallable, BlueprintEvent)
// Parameters:
// bool                                    UseSmartObjects                                        (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor)

void ABPChar_NonPlayerCharacter_C::NPCUseSmartObjects(bool UseSmartObjects)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BPChar_NonPlayerCharacter_C", "NPCUseSmartObjects");

	Params::BPChar_NonPlayerCharacter_C_NPCUseSmartObjects Parms{};

	Parms.UseSmartObjects = UseSmartObjects;

	UObject::ProcessEvent(Func, &Parms);
}


// Function BPChar_NonPlayerCharacter.BPChar_NonPlayerCharacter_C.NPCCanPatrol
// (Public, BlueprintCallable, BlueprintEvent)
// Parameters:
// bool                                    CanPatrol                                              (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor)

void ABPChar_NonPlayerCharacter_C::NPCCanPatrol(bool CanPatrol)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BPChar_NonPlayerCharacter_C", "NPCCanPatrol");

	Params::BPChar_NonPlayerCharacter_C_NPCCanPatrol Parms{};

	Parms.CanPatrol = CanPatrol;

	UObject::ProcessEvent(Func, &Parms);
}


// Function BPChar_NonPlayerCharacter.BPChar_NonPlayerCharacter_C.NPCEngagePlayerWhenIdle
// (Public, BlueprintCallable, BlueprintEvent)
// Parameters:
// bool                                    LookAtPlayer                                           (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor)

void ABPChar_NonPlayerCharacter_C::NPCEngagePlayerWhenIdle(bool LookAtPlayer)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BPChar_NonPlayerCharacter_C", "NPCEngagePlayerWhenIdle");

	Params::BPChar_NonPlayerCharacter_C_NPCEngagePlayerWhenIdle Parms{};

	Parms.LookAtPlayer = LookAtPlayer;

	UObject::ProcessEvent(Func, &Parms);
}


// Function BPChar_NonPlayerCharacter.BPChar_NonPlayerCharacter_C.NPCEngageInCombat
// (Public, BlueprintCallable, BlueprintEvent)
// Parameters:
// bool                                    EngageInCombat                                         (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor)

void ABPChar_NonPlayerCharacter_C::NPCEngageInCombat(bool EngageInCombat)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BPChar_NonPlayerCharacter_C", "NPCEngageInCombat");

	Params::BPChar_NonPlayerCharacter_C_NPCEngageInCombat Parms{};

	Parms.EngageInCombat = EngageInCombat;

	UObject::ProcessEvent(Func, &Parms);
}


// Function BPChar_NonPlayerCharacter.BPChar_NonPlayerCharacter_C.ChangeBehaviorTree_LookAt
// (Public, BlueprintCallable, BlueprintEvent)
// Parameters:
// class AAIController*                    NPC_AIController                                       (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// bool                                    Enable                                                 (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor)

void ABPChar_NonPlayerCharacter_C::ChangeBehaviorTree_LookAt(class AAIController* NPC_AIController, bool Enable)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BPChar_NonPlayerCharacter_C", "ChangeBehaviorTree_LookAt");

	Params::BPChar_NonPlayerCharacter_C_ChangeBehaviorTree_LookAt Parms{};

	Parms.NPC_AIController = NPC_AIController;
	Parms.Enable = Enable;

	UObject::ProcessEvent(Func, &Parms);
}


// Function BPChar_NonPlayerCharacter.BPChar_NonPlayerCharacter_C.PlayerUsedMe
// (Protected, HasDefaults, BlueprintCallable, BlueprintEvent)
// Parameters:
// struct FUseEvent                        UseEvent                                               (BlueprintVisible, BlueprintReadOnly, Parm, NoDestructor, ContainsInstancedReference)

void ABPChar_NonPlayerCharacter_C::PlayerUsedMe(const struct FUseEvent& UseEvent)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BPChar_NonPlayerCharacter_C", "PlayerUsedMe");

	Params::BPChar_NonPlayerCharacter_C_PlayerUsedMe Parms{};

	Parms.UseEvent = std::move(UseEvent);

	UObject::ProcessEvent(Func, &Parms);
}


// Function BPChar_NonPlayerCharacter.BPChar_NonPlayerCharacter_C.ClearText
// (Public, HasDefaults, BlueprintCallable, BlueprintEvent)

void ABPChar_NonPlayerCharacter_C::ClearText()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BPChar_NonPlayerCharacter_C", "ClearText");

	UObject::ProcessEvent(Func, nullptr);
}


// Function BPChar_NonPlayerCharacter.BPChar_NonPlayerCharacter_C.SetText
// (Public, HasDefaults, BlueprintCallable, BlueprintEvent)
// Parameters:
// class FText                             Text_0                                                 (BlueprintVisible, BlueprintReadOnly, Parm)
// float                                   TextSize_0                                             (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// float                                   Duration                                               (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// struct FLinearColor                     TextColor_0                                            (BlueprintVisible, BlueprintReadOnly, Parm, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// bool                                    FacePlayer_0                                           (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor)

void ABPChar_NonPlayerCharacter_C::SetText(const class FText& Text_0, float TextSize_0, float Duration, const struct FLinearColor& TextColor_0, bool FacePlayer_0)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BPChar_NonPlayerCharacter_C", "SetText");

	Params::BPChar_NonPlayerCharacter_C_SetText Parms{};

	Parms.Text_0 = std::move(Text_0);
	Parms.TextSize_0 = TextSize_0;
	Parms.Duration = Duration;
	Parms.TextColor_0 = std::move(TextColor_0);
	Parms.FacePlayer_0 = FacePlayer_0;

	UObject::ProcessEvent(Func, &Parms);
}


// Function BPChar_NonPlayerCharacter.BPChar_NonPlayerCharacter_C.UserConstructionScript
// (Event, Public, BlueprintCallable, BlueprintEvent)

void ABPChar_NonPlayerCharacter_C::UserConstructionScript()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BPChar_NonPlayerCharacter_C", "UserConstructionScript");

	UObject::ProcessEvent(Func, nullptr);
}


// Function BPChar_NonPlayerCharacter.BPChar_NonPlayerCharacter_C.GbxAsyncRequest_PickupSpawned_57F45FEF4D675ABCF62E0A81821A5187
// (BlueprintCallable, BlueprintEvent)
// Parameters:
// class ADroppedInventoryItemPickup*      Pickup                                                 (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)

void ABPChar_NonPlayerCharacter_C::GbxAsyncRequest_PickupSpawned_57F45FEF4D675ABCF62E0A81821A5187(class ADroppedInventoryItemPickup* Pickup)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BPChar_NonPlayerCharacter_C", "GbxAsyncRequest_PickupSpawned_57F45FEF4D675ABCF62E0A81821A5187");

	Params::BPChar_NonPlayerCharacter_C_GbxAsyncRequest_PickupSpawned_57F45FEF4D675ABCF62E0A81821A5187 Parms{};

	Parms.Pickup = Pickup;

	UObject::ProcessEvent(Func, &Parms);
}


// Function BPChar_NonPlayerCharacter.BPChar_NonPlayerCharacter_C.NPCUnhideSword
// (Public, BlueprintCallable, BlueprintEvent)

void ABPChar_NonPlayerCharacter_C::NPCUnhideSword()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BPChar_NonPlayerCharacter_C", "NPCUnhideSword");

	UObject::ProcessEvent(Func, nullptr);
}


// Function BPChar_NonPlayerCharacter.BPChar_NonPlayerCharacter_C.NPCHideSword
// (Public, BlueprintCallable, BlueprintEvent)

void ABPChar_NonPlayerCharacter_C::NPCHideSword()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BPChar_NonPlayerCharacter_C", "NPCHideSword");

	UObject::ProcessEvent(Func, nullptr);
}


// Function BPChar_NonPlayerCharacter.BPChar_NonPlayerCharacter_C.NPCConstrainUsable
// (Public, BlueprintCallable, BlueprintEvent)

void ABPChar_NonPlayerCharacter_C::NPCConstrainUsable()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BPChar_NonPlayerCharacter_C", "NPCConstrainUsable");

	UObject::ProcessEvent(Func, nullptr);
}


// Function BPChar_NonPlayerCharacter.BPChar_NonPlayerCharacter_C.NPCResetUsable
// (Public, BlueprintCallable, BlueprintEvent)

void ABPChar_NonPlayerCharacter_C::NPCResetUsable()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BPChar_NonPlayerCharacter_C", "NPCResetUsable");

	UObject::ProcessEvent(Func, nullptr);
}


// Function BPChar_NonPlayerCharacter.BPChar_NonPlayerCharacter_C.ForceDefaultCombatNPCDownstate
// (Public, BlueprintCallable, BlueprintEvent)

void ABPChar_NonPlayerCharacter_C::ForceDefaultCombatNPCDownstate()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BPChar_NonPlayerCharacter_C", "ForceDefaultCombatNPCDownstate");

	UObject::ProcessEvent(Func, nullptr);
}


// Function BPChar_NonPlayerCharacter.BPChar_NonPlayerCharacter_C.ForceNPCRevive
// (Public, BlueprintCallable, BlueprintEvent)

void ABPChar_NonPlayerCharacter_C::ForceNPCRevive()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BPChar_NonPlayerCharacter_C", "ForceNPCRevive");

	UObject::ProcessEvent(Func, nullptr);
}


// Function BPChar_NonPlayerCharacter.BPChar_NonPlayerCharacter_C.HoldHandOutToTakeSomething
// (Public, BlueprintCallable, BlueprintEvent)

void ABPChar_NonPlayerCharacter_C::HoldHandOutToTakeSomething()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BPChar_NonPlayerCharacter_C", "HoldHandOutToTakeSomething");

	UObject::ProcessEvent(Func, nullptr);
}


// Function BPChar_NonPlayerCharacter.BPChar_NonPlayerCharacter_C.GiveSomethingToThePlayer
// (Public, BlueprintCallable, BlueprintEvent)

void ABPChar_NonPlayerCharacter_C::GiveSomethingToThePlayer()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BPChar_NonPlayerCharacter_C", "GiveSomethingToThePlayer");

	UObject::ProcessEvent(Func, nullptr);
}


// Function BPChar_NonPlayerCharacter.BPChar_NonPlayerCharacter_C.BeingUsed
// (BlueprintCallable, BlueprintEvent)
// Parameters:
// struct FUseEvent                        UseEvent                                               (BlueprintVisible, BlueprintReadOnly, Parm, NoDestructor, ContainsInstancedReference)

void ABPChar_NonPlayerCharacter_C::BeingUsed(const struct FUseEvent& UseEvent)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BPChar_NonPlayerCharacter_C", "BeingUsed");

	Params::BPChar_NonPlayerCharacter_C_BeingUsed Parms{};

	Parms.UseEvent = std::move(UseEvent);

	UObject::ProcessEvent(Func, &Parms);
}


// Function BPChar_NonPlayerCharacter.BPChar_NonPlayerCharacter_C.LootableTaken
// (BlueprintCallable, BlueprintEvent)
// Parameters:
// class AActor*                           DestroyedActor                                         (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)

void ABPChar_NonPlayerCharacter_C::LootableTaken(class AActor* DestroyedActor)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BPChar_NonPlayerCharacter_C", "LootableTaken");

	Params::BPChar_NonPlayerCharacter_C_LootableTaken Parms{};

	Parms.DestroyedActor = DestroyedActor;

	UObject::ProcessEvent(Func, &Parms);
}


// Function BPChar_NonPlayerCharacter.BPChar_NonPlayerCharacter_C.HoldHandTakeAll
// (BlueprintCallable, BlueprintEvent)

void ABPChar_NonPlayerCharacter_C::HoldHandTakeAll()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BPChar_NonPlayerCharacter_C", "HoldHandTakeAll");

	UObject::ProcessEvent(Func, nullptr);
}


// Function BPChar_NonPlayerCharacter.BPChar_NonPlayerCharacter_C.HoldHandGiveAll
// (BlueprintCallable, BlueprintEvent)

void ABPChar_NonPlayerCharacter_C::HoldHandGiveAll()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BPChar_NonPlayerCharacter_C", "HoldHandGiveAll");

	UObject::ProcessEvent(Func, nullptr);
}


// Function BPChar_NonPlayerCharacter.BPChar_NonPlayerCharacter_C.TakingThingAll
// (BlueprintCallable, BlueprintEvent)

void ABPChar_NonPlayerCharacter_C::TakingThingAll()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BPChar_NonPlayerCharacter_C", "TakingThingAll");

	UObject::ProcessEvent(Func, nullptr);
}


// Function BPChar_NonPlayerCharacter.BPChar_NonPlayerCharacter_C.PlayerTakingAll
// (BlueprintCallable, BlueprintEvent)

void ABPChar_NonPlayerCharacter_C::PlayerTakingAll()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BPChar_NonPlayerCharacter_C", "PlayerTakingAll");

	UObject::ProcessEvent(Func, nullptr);
}


// Function BPChar_NonPlayerCharacter.BPChar_NonPlayerCharacter_C.LockNPCAI
// (BlueprintCallable, BlueprintEvent)

void ABPChar_NonPlayerCharacter_C::LockNPCAI()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BPChar_NonPlayerCharacter_C", "LockNPCAI");

	UObject::ProcessEvent(Func, nullptr);
}


// Function BPChar_NonPlayerCharacter.BPChar_NonPlayerCharacter_C.UnlockNPCAI
// (BlueprintCallable, BlueprintEvent)

void ABPChar_NonPlayerCharacter_C::UnlockNPCAI()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BPChar_NonPlayerCharacter_C", "UnlockNPCAI");

	UObject::ProcessEvent(Func, nullptr);
}


// Function BPChar_NonPlayerCharacter.BPChar_NonPlayerCharacter_C.TakeThingThenGiveBack
// (Public, BlueprintCallable, BlueprintEvent)

void ABPChar_NonPlayerCharacter_C::TakeThingThenGiveBack()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BPChar_NonPlayerCharacter_C", "TakeThingThenGiveBack");

	UObject::ProcessEvent(Func, nullptr);
}


// Function BPChar_NonPlayerCharacter.BPChar_NonPlayerCharacter_C.ExamineAll
// (BlueprintCallable, BlueprintEvent)

void ABPChar_NonPlayerCharacter_C::ExamineAll()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BPChar_NonPlayerCharacter_C", "ExamineAll");

	UObject::ProcessEvent(Func, nullptr);
}


// Function BPChar_NonPlayerCharacter.BPChar_NonPlayerCharacter_C.EngageInCombat
// (Public, BlueprintCallable, BlueprintEvent)
// Parameters:
// bool                                    EngageInCombat_0                                       (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor)

void ABPChar_NonPlayerCharacter_C::EngageInCombat(bool EngageInCombat_0)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BPChar_NonPlayerCharacter_C", "EngageInCombat");

	Params::BPChar_NonPlayerCharacter_C_EngageInCombat Parms{};

	Parms.EngageInCombat_0 = EngageInCombat_0;

	UObject::ProcessEvent(Func, &Parms);
}


// Function BPChar_NonPlayerCharacter.BPChar_NonPlayerCharacter_C.CanPatrol
// (Public, BlueprintCallable, BlueprintEvent)
// Parameters:
// bool                                    CanPatrol_0                                            (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor)

void ABPChar_NonPlayerCharacter_C::CanPatrol(bool CanPatrol_0)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BPChar_NonPlayerCharacter_C", "CanPatrol");

	Params::BPChar_NonPlayerCharacter_C_CanPatrol Parms{};

	Parms.CanPatrol_0 = CanPatrol_0;

	UObject::ProcessEvent(Func, &Parms);
}


// Function BPChar_NonPlayerCharacter.BPChar_NonPlayerCharacter_C.UseSmartObjects
// (Public, BlueprintCallable, BlueprintEvent)
// Parameters:
// bool                                    UseSmartObjects_0                                      (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor)

void ABPChar_NonPlayerCharacter_C::UseSmartObjects(bool UseSmartObjects_0)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BPChar_NonPlayerCharacter_C", "UseSmartObjects");

	Params::BPChar_NonPlayerCharacter_C_UseSmartObjects Parms{};

	Parms.UseSmartObjects_0 = UseSmartObjects_0;

	UObject::ProcessEvent(Func, &Parms);
}


// Function BPChar_NonPlayerCharacter.BPChar_NonPlayerCharacter_C.ThingToHold
// (Public, BlueprintCallable, BlueprintEvent)
// Parameters:
// class UStaticMesh*                      TheThingToHold                                         (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// struct FItemPoolInfo                    ThePickupToHold                                        (BlueprintVisible, BlueprintReadOnly, Parm)
// struct FTransform                       OffsetTransform                                        (BlueprintVisible, BlueprintReadOnly, Parm, IsPlainOldData, NoDestructor)
// float                                   PutAwayOffset                                          (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// float                                   TakeOutOffset                                          (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// bool                                    UseAltAnimation                                        (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor)

void ABPChar_NonPlayerCharacter_C::ThingToHold(class UStaticMesh* TheThingToHold, const struct FItemPoolInfo& ThePickupToHold, const struct FTransform& OffsetTransform, float PutAwayOffset, float TakeOutOffset, bool UseAltAnimation)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BPChar_NonPlayerCharacter_C", "ThingToHold");

	Params::BPChar_NonPlayerCharacter_C_ThingToHold Parms{};

	Parms.TheThingToHold = TheThingToHold;
	Parms.ThePickupToHold = std::move(ThePickupToHold);
	Parms.OffsetTransform = std::move(OffsetTransform);
	Parms.PutAwayOffset = PutAwayOffset;
	Parms.TakeOutOffset = TakeOutOffset;
	Parms.UseAltAnimation = UseAltAnimation;

	UObject::ProcessEvent(Func, &Parms);
}


// Function BPChar_NonPlayerCharacter.BPChar_NonPlayerCharacter_C.NPCHideWeapon
// (Public, BlueprintCallable, BlueprintEvent)

void ABPChar_NonPlayerCharacter_C::NPCHideWeapon()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BPChar_NonPlayerCharacter_C", "NPCHideWeapon");

	UObject::ProcessEvent(Func, nullptr);
}


// Function BPChar_NonPlayerCharacter.BPChar_NonPlayerCharacter_C.NPCUnhideWeapon
// (Public, BlueprintCallable, BlueprintEvent)

void ABPChar_NonPlayerCharacter_C::NPCUnhideWeapon()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BPChar_NonPlayerCharacter_C", "NPCUnhideWeapon");

	UObject::ProcessEvent(Func, nullptr);
}


// Function BPChar_NonPlayerCharacter.BPChar_NonPlayerCharacter_C.IgnoreEnemies
// (Public, BlueprintCallable, BlueprintEvent)
// Parameters:
// bool                                    IgnoreEnemies_0                                        (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor)

void ABPChar_NonPlayerCharacter_C::IgnoreEnemies(bool IgnoreEnemies_0)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BPChar_NonPlayerCharacter_C", "IgnoreEnemies");

	Params::BPChar_NonPlayerCharacter_C_IgnoreEnemies Parms{};

	Parms.IgnoreEnemies_0 = IgnoreEnemies_0;

	UObject::ProcessEvent(Func, &Parms);
}


// Function BPChar_NonPlayerCharacter.BPChar_NonPlayerCharacter_C.NPCCanReviveOthers
// (Public, BlueprintCallable, BlueprintEvent)
// Parameters:
// bool                                    CanReviveOthers_0                                      (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor)

void ABPChar_NonPlayerCharacter_C::NPCCanReviveOthers(bool CanReviveOthers_0)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BPChar_NonPlayerCharacter_C", "NPCCanReviveOthers");

	Params::BPChar_NonPlayerCharacter_C_NPCCanReviveOthers Parms{};

	Parms.CanReviveOthers_0 = CanReviveOthers_0;

	UObject::ProcessEvent(Func, &Parms);
}


// Function BPChar_NonPlayerCharacter.BPChar_NonPlayerCharacter_C.BndEvt__Stance_K2Node_ComponentBoundEvent_0_StanceChangedEvent__DelegateSignature_BPChar_NonPlayerCharacter
// (BlueprintEvent)
// Parameters:
// struct FStanceChangedEventArgs          Args                                                   (BlueprintVisible, BlueprintReadOnly, Parm, IsPlainOldData, NoDestructor)

void ABPChar_NonPlayerCharacter_C::BndEvt__Stance_K2Node_ComponentBoundEvent_0_StanceChangedEvent__DelegateSignature_BPChar_NonPlayerCharacter(const struct FStanceChangedEventArgs& Args)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BPChar_NonPlayerCharacter_C", "BndEvt__Stance_K2Node_ComponentBoundEvent_0_StanceChangedEvent__DelegateSignature_BPChar_NonPlayerCharacter");

	Params::BPChar_NonPlayerCharacter_C_BndEvt__Stance_K2Node_ComponentBoundEvent_0_StanceChangedEvent__DelegateSignature_BPChar_NonPlayerCharacter Parms{};

	Parms.Args = std::move(Args);

	UObject::ProcessEvent(Func, &Parms);
}


// Function BPChar_NonPlayerCharacter.BPChar_NonPlayerCharacter_C.EngagePlayerWhenIdle
// (Public, BlueprintCallable, BlueprintEvent)
// Parameters:
// bool                                    LookAtPlayer                                           (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor)

void ABPChar_NonPlayerCharacter_C::EngagePlayerWhenIdle(bool LookAtPlayer)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BPChar_NonPlayerCharacter_C", "EngagePlayerWhenIdle");

	Params::BPChar_NonPlayerCharacter_C_EngagePlayerWhenIdle Parms{};

	Parms.LookAtPlayer = LookAtPlayer;

	UObject::ProcessEvent(Func, &Parms);
}


// Function BPChar_NonPlayerCharacter.BPChar_NonPlayerCharacter_C.SetNPCEngagePlayerRange
// (Public, BlueprintCallable, BlueprintEvent)
// Parameters:
// float                                   Units                                                  (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)

void ABPChar_NonPlayerCharacter_C::SetNPCEngagePlayerRange(float Units)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BPChar_NonPlayerCharacter_C", "SetNPCEngagePlayerRange");

	Params::BPChar_NonPlayerCharacter_C_SetNPCEngagePlayerRange Parms{};

	Parms.Units = Units;

	UObject::ProcessEvent(Func, &Parms);
}


// Function BPChar_NonPlayerCharacter.BPChar_NonPlayerCharacter_C.BndEvt__Usable_K2Node_ComponentBoundEvent_24_UsableUsedOnChannelSignature__DelegateSignature_BPChar_Typhon_UNIX1509007700
// (BlueprintEvent)
// Parameters:
// class AController*                      UserController                                         (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// class UPrimitiveComponent*              UsedComponent                                          (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash)

void ABPChar_NonPlayerCharacter_C::BndEvt__Usable_K2Node_ComponentBoundEvent_24_UsableUsedOnChannelSignature__DelegateSignature_BPChar_Typhon_UNIX1509007700(class AController* UserController, class UPrimitiveComponent* UsedComponent)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BPChar_NonPlayerCharacter_C", "BndEvt__Usable_K2Node_ComponentBoundEvent_24_UsableUsedOnChannelSignature__DelegateSignature_BPChar_Typhon_UNIX1509007700");

	Params::BPChar_NonPlayerCharacter_C_BndEvt__Usable_K2Node_ComponentBoundEvent_24_UsableUsedOnChannelSignature__DelegateSignature_BPChar_Typhon_UNIX1509007700 Parms{};

	Parms.UserController = UserController;
	Parms.UsedComponent = UsedComponent;

	UObject::ProcessEvent(Func, &Parms);
}


// Function BPChar_NonPlayerCharacter.BPChar_NonPlayerCharacter_C.DisableMissionBrain
// (BlueprintCallable, BlueprintEvent)

void ABPChar_NonPlayerCharacter_C::DisableMissionBrain()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BPChar_NonPlayerCharacter_C", "DisableMissionBrain");

	UObject::ProcessEvent(Func, nullptr);
}


// Function BPChar_NonPlayerCharacter.BPChar_NonPlayerCharacter_C.BndEvt__Usable_K2Node_ComponentBoundEvent_0_UsableUsedSignature__DelegateSignature_BPChar_NonPlayerCharacter
// (HasOutParams, BlueprintEvent)
// Parameters:
// struct FUseEvent                        UseEvent                                               (ConstParm, BlueprintVisible, BlueprintReadOnly, Parm, OutParm, ReferenceParm, NoDestructor, ContainsInstancedReference)

void ABPChar_NonPlayerCharacter_C::BndEvt__Usable_K2Node_ComponentBoundEvent_0_UsableUsedSignature__DelegateSignature_BPChar_NonPlayerCharacter(const struct FUseEvent& UseEvent)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BPChar_NonPlayerCharacter_C", "BndEvt__Usable_K2Node_ComponentBoundEvent_0_UsableUsedSignature__DelegateSignature_BPChar_NonPlayerCharacter");

	Params::BPChar_NonPlayerCharacter_C_BndEvt__Usable_K2Node_ComponentBoundEvent_0_UsableUsedSignature__DelegateSignature_BPChar_NonPlayerCharacter Parms{};

	Parms.UseEvent = std::move(UseEvent);

	UObject::ProcessEvent(Func, &Parms);
}


// Function BPChar_NonPlayerCharacter.BPChar_NonPlayerCharacter_C.InitializeGenericDialog
// (BlueprintCallable, BlueprintEvent)

void ABPChar_NonPlayerCharacter_C::InitializeGenericDialog()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BPChar_NonPlayerCharacter_C", "InitializeGenericDialog");

	UObject::ProcessEvent(Func, nullptr);
}


// Function BPChar_NonPlayerCharacter.BPChar_NonPlayerCharacter_C.OpenGate
// (BlueprintCallable, BlueprintEvent)

void ABPChar_NonPlayerCharacter_C::OpenGate()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BPChar_NonPlayerCharacter_C", "OpenGate");

	UObject::ProcessEvent(Func, nullptr);
}


// Function BPChar_NonPlayerCharacter.BPChar_NonPlayerCharacter_C.TextClear
// (BlueprintCallable, BlueprintEvent)
// Parameters:
// float                                   Time                                                   (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)

void ABPChar_NonPlayerCharacter_C::TextClear(float Time)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BPChar_NonPlayerCharacter_C", "TextClear");

	Params::BPChar_NonPlayerCharacter_C_TextClear Parms{};

	Parms.Time = Time;

	UObject::ProcessEvent(Func, &Parms);
}


// Function BPChar_NonPlayerCharacter.BPChar_NonPlayerCharacter_C.CloseGate
// (BlueprintCallable, BlueprintEvent)

void ABPChar_NonPlayerCharacter_C::CloseGate()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BPChar_NonPlayerCharacter_C", "CloseGate");

	UObject::ProcessEvent(Func, nullptr);
}


// Function BPChar_NonPlayerCharacter.BPChar_NonPlayerCharacter_C.TempMissionTextTck
// (BlueprintCallable, BlueprintEvent)

void ABPChar_NonPlayerCharacter_C::TempMissionTextTck()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BPChar_NonPlayerCharacter_C", "TempMissionTextTck");

	UObject::ProcessEvent(Func, nullptr);
}


// Function BPChar_NonPlayerCharacter.BPChar_NonPlayerCharacter_C.SetMissionDebugText
// (Public, BlueprintCallable, BlueprintEvent)
// Parameters:
// class FText                             Text_0                                                 (BlueprintVisible, BlueprintReadOnly, Parm)
// float                                   TextSize_0                                             (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// float                                   Duration                                               (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// struct FLinearColor                     TextColor_0                                            (BlueprintVisible, BlueprintReadOnly, Parm, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// bool                                    FacePlayer_0                                           (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor)

void ABPChar_NonPlayerCharacter_C::SetMissionDebugText(const class FText& Text_0, float TextSize_0, float Duration, const struct FLinearColor& TextColor_0, bool FacePlayer_0)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BPChar_NonPlayerCharacter_C", "SetMissionDebugText");

	Params::BPChar_NonPlayerCharacter_C_SetMissionDebugText Parms{};

	Parms.Text_0 = std::move(Text_0);
	Parms.TextSize_0 = TextSize_0;
	Parms.Duration = Duration;
	Parms.TextColor_0 = std::move(TextColor_0);
	Parms.FacePlayer_0 = FacePlayer_0;

	UObject::ProcessEvent(Func, &Parms);
}


// Function BPChar_NonPlayerCharacter.BPChar_NonPlayerCharacter_C.TextUpdating
// (BlueprintCallable, BlueprintEvent)

void ABPChar_NonPlayerCharacter_C::TextUpdating()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BPChar_NonPlayerCharacter_C", "TextUpdating");

	UObject::ProcessEvent(Func, nullptr);
}


// Function BPChar_NonPlayerCharacter.BPChar_NonPlayerCharacter_C.SawThePlayer
// (BlueprintCallable, BlueprintEvent)

void ABPChar_NonPlayerCharacter_C::SawThePlayer()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BPChar_NonPlayerCharacter_C", "SawThePlayer");

	UObject::ProcessEvent(Func, nullptr);
}


// Function BPChar_NonPlayerCharacter.BPChar_NonPlayerCharacter_C.DespawnActivate
// (BlueprintCallable, BlueprintEvent)

void ABPChar_NonPlayerCharacter_C::DespawnActivate()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BPChar_NonPlayerCharacter_C", "DespawnActivate");

	UObject::ProcessEvent(Func, nullptr);
}


// Function BPChar_NonPlayerCharacter.BPChar_NonPlayerCharacter_C.ReceiveBeginPlay
// (Event, Protected, BlueprintEvent)

void ABPChar_NonPlayerCharacter_C::ReceiveBeginPlay()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BPChar_NonPlayerCharacter_C", "ReceiveBeginPlay");

	UObject::ProcessEvent(Func, nullptr);
}


// Function BPChar_NonPlayerCharacter.BPChar_NonPlayerCharacter_C.ExecuteUbergraph_BPChar_NonPlayerCharacter
// (HasDefaults)
// Parameters:
// int32                                   EntryPoint                                             (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)

void ABPChar_NonPlayerCharacter_C::ExecuteUbergraph_BPChar_NonPlayerCharacter(int32 EntryPoint)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BPChar_NonPlayerCharacter_C", "ExecuteUbergraph_BPChar_NonPlayerCharacter");

	Params::BPChar_NonPlayerCharacter_C_ExecuteUbergraph_BPChar_NonPlayerCharacter Parms{};

	Parms.EntryPoint = EntryPoint;

	UObject::ProcessEvent(Func, &Parms);
}


// Function BPChar_NonPlayerCharacter.BPChar_NonPlayerCharacter_C.SpawnedLootToGive__DelegateSignature
// (Public, Delegate, BlueprintCallable, BlueprintEvent)
// Parameters:
// class ADroppedInventoryItemPickup*      Loot                                                   (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)

void ABPChar_NonPlayerCharacter_C::SpawnedLootToGive__DelegateSignature(class ADroppedInventoryItemPickup* Loot)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BPChar_NonPlayerCharacter_C", "SpawnedLootToGive__DelegateSignature");

	Params::BPChar_NonPlayerCharacter_C_SpawnedLootToGive__DelegateSignature Parms{};

	Parms.Loot = Loot;

	UObject::ProcessEvent(Func, &Parms);
}


// Function BPChar_NonPlayerCharacter.BPChar_NonPlayerCharacter_C.ItemTakenByPlayer__DelegateSignature
// (Public, Delegate, BlueprintCallable, BlueprintEvent)
// Parameters:
// class AOakCharacter_Player*             Player                                                 (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)

void ABPChar_NonPlayerCharacter_C::ItemTakenByPlayer__DelegateSignature(class AOakCharacter_Player* Player)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BPChar_NonPlayerCharacter_C", "ItemTakenByPlayer__DelegateSignature");

	Params::BPChar_NonPlayerCharacter_C_ItemTakenByPlayer__DelegateSignature Parms{};

	Parms.Player = Player;

	UObject::ProcessEvent(Func, &Parms);
}


// Function BPChar_NonPlayerCharacter.BPChar_NonPlayerCharacter_C.NPCSawThePlayer__DelegateSignature
// (Public, Delegate, BlueprintCallable, BlueprintEvent)

void ABPChar_NonPlayerCharacter_C::NPCSawThePlayer__DelegateSignature()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BPChar_NonPlayerCharacter_C", "NPCSawThePlayer__DelegateSignature");

	UObject::ProcessEvent(Func, nullptr);
}


// Function BPChar_NonPlayerCharacter.BPChar_NonPlayerCharacter_C.OnUsed__DelegateSignature
// (Public, Delegate, BlueprintCallable, BlueprintEvent)
// Parameters:
// struct FUseEvent                        UseEvent                                               (BlueprintVisible, BlueprintReadOnly, Parm, NoDestructor, ContainsInstancedReference)

void ABPChar_NonPlayerCharacter_C::OnUsed__DelegateSignature(const struct FUseEvent& UseEvent)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BPChar_NonPlayerCharacter_C", "OnUsed__DelegateSignature");

	Params::BPChar_NonPlayerCharacter_C_OnUsed__DelegateSignature Parms{};

	Parms.UseEvent = std::move(UseEvent);

	UObject::ProcessEvent(Func, &Parms);
}

}

