#pragma once

/*
* SDK generated by Dumper-7
*
* https://github.com/Encryqed/Dumper-7
*/

// Package: GbxAbilities

#include "Basic.hpp"

#include "GbxGameSystemCore_structs.hpp"


namespace SDK
{

// Enum GbxAbilities.EAbilityResourceDelegateType
// NumValues: 0x000B
enum class EAbilityResourceDelegateType : uint8
{
	None                                     = 0,
	OnResourceNowDepleted                    = 1,
	OnResourceNowNotDepleted                 = 2,
	OnResourceNowFilled                      = 3,
	OnResourceNowNotFilled                   = 4,
	OnResourceNowRegenerating                = 5,
	OnResourceNowNotRegenerating             = 6,
	OnResourceNowDepleting                   = 7,
	OnResourceNowNotDepleting                = 8,
	OnResourceNowIdle                        = 9,
	EAbilityResourceDelegateType_MAX         = 10,
};

// Enum GbxAbilities.EGbxAbilityState
// NumValues: 0x0005
enum class EGbxAbilityState : uint8
{
	Unactivated                              = 0,
	Deactivated                              = 1,
	Paused                                   = 2,
	Active                                   = 3,
	EGbxAbilityState_MAX                     = 4,
};

// Enum GbxAbilities.EGbxAbilityDurationType
// NumValues: 0x0004
enum class EGbxAbilityDurationType : uint8
{
	Timed                                    = 0,
	Indefinite                               = 1,
	Infinite                                 = 2,
	EGbxAbilityDurationType_MAX              = 3,
};

// ScriptStruct GbxAbilities.GbxAbilityResourceController
// 0x0018 (0x0018 - 0x0000)
struct FGbxAbilityResourceController
{
public:
	uint8                                         Pad_0[0x8];                                        // 0x0000(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	class UGbxAbility*                            Owner;                                             // 0x0008(0x0008)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_10[0x8];                                       // 0x0010(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FGbxAbilityResourceController) == 0x000008, "Wrong alignment on FGbxAbilityResourceController");
static_assert(sizeof(FGbxAbilityResourceController) == 0x000018, "Wrong size on FGbxAbilityResourceController");
static_assert(offsetof(FGbxAbilityResourceController, Owner) == 0x000008, "Member 'FGbxAbilityResourceController::Owner' has a wrong offset!");

// ScriptStruct GbxAbilities.GbxAbilityResourceSpec
// 0x0010 (0x0010 - 0x0000)
struct FGbxAbilityResourceSpec
{
public:
	class UGbxAbility*                            AbilityContext;                                    // 0x0000(0x0008)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bWhenActive;                                       // 0x0008(0x0001)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bWhenPaused;                                       // 0x0009(0x0001)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_A[0x6];                                        // 0x000A(0x0006)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FGbxAbilityResourceSpec) == 0x000008, "Wrong alignment on FGbxAbilityResourceSpec");
static_assert(sizeof(FGbxAbilityResourceSpec) == 0x000010, "Wrong size on FGbxAbilityResourceSpec");
static_assert(offsetof(FGbxAbilityResourceSpec, AbilityContext) == 0x000000, "Member 'FGbxAbilityResourceSpec::AbilityContext' has a wrong offset!");
static_assert(offsetof(FGbxAbilityResourceSpec, bWhenActive) == 0x000008, "Member 'FGbxAbilityResourceSpec::bWhenActive' has a wrong offset!");
static_assert(offsetof(FGbxAbilityResourceSpec, bWhenPaused) == 0x000009, "Member 'FGbxAbilityResourceSpec::bWhenPaused' has a wrong offset!");

// ScriptStruct GbxAbilities.GbxAbilityEffectInstanceTarget
// 0x0030 (0x0030 - 0x0000)
struct FGbxAbilityEffectInstanceTarget final
{
public:
	class AActor*                                 TargetActor;                                       // 0x0000(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UStatusEffectManagerComponent*          TargetStatusEffectManagerComponent;                // 0x0008(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FStatusEffectInstanceReference         StatusEffectInstanceReference;                     // 0x0010(0x0018)(NoDestructor, ContainsInstancedReference, NativeAccessSpecifierPublic)
	uint8                                         Pad_28[0x8];                                       // 0x0028(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FGbxAbilityEffectInstanceTarget) == 0x000008, "Wrong alignment on FGbxAbilityEffectInstanceTarget");
static_assert(sizeof(FGbxAbilityEffectInstanceTarget) == 0x000030, "Wrong size on FGbxAbilityEffectInstanceTarget");
static_assert(offsetof(FGbxAbilityEffectInstanceTarget, TargetActor) == 0x000000, "Member 'FGbxAbilityEffectInstanceTarget::TargetActor' has a wrong offset!");
static_assert(offsetof(FGbxAbilityEffectInstanceTarget, TargetStatusEffectManagerComponent) == 0x000008, "Member 'FGbxAbilityEffectInstanceTarget::TargetStatusEffectManagerComponent' has a wrong offset!");
static_assert(offsetof(FGbxAbilityEffectInstanceTarget, StatusEffectInstanceReference) == 0x000010, "Member 'FGbxAbilityEffectInstanceTarget::StatusEffectInstanceReference' has a wrong offset!");

// ScriptStruct GbxAbilities.GbxAbilityEffectInstance
// 0x0070 (0x0070 - 0x0000)
struct FGbxAbilityEffectInstance final
{
public:
	class UGbxAbility*                            Owner;                                             // 0x0000(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FStatusEffectSpec                      StatusEffectSpec;                                  // 0x0008(0x0038)(NoDestructor, NativeAccessSpecifierPublic)
	TArray<struct FGbxAbilityEffectInstanceTarget> Targets;                                           // 0x0040(0x0010)(ZeroConstructor, ContainsInstancedReference, NativeAccessSpecifierPublic)
	class UGbxCondition*                          Condition;                                         // 0x0050(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TArray<class UGbxAbilityEffectTargetResolutionData*> TargetResolutionStrategies;                        // 0x0058(0x0010)(ZeroConstructor, NativeAccessSpecifierPublic)
	uint8                                         Pad_68[0x8];                                       // 0x0068(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FGbxAbilityEffectInstance) == 0x000008, "Wrong alignment on FGbxAbilityEffectInstance");
static_assert(sizeof(FGbxAbilityEffectInstance) == 0x000070, "Wrong size on FGbxAbilityEffectInstance");
static_assert(offsetof(FGbxAbilityEffectInstance, Owner) == 0x000000, "Member 'FGbxAbilityEffectInstance::Owner' has a wrong offset!");
static_assert(offsetof(FGbxAbilityEffectInstance, StatusEffectSpec) == 0x000008, "Member 'FGbxAbilityEffectInstance::StatusEffectSpec' has a wrong offset!");
static_assert(offsetof(FGbxAbilityEffectInstance, Targets) == 0x000040, "Member 'FGbxAbilityEffectInstance::Targets' has a wrong offset!");
static_assert(offsetof(FGbxAbilityEffectInstance, Condition) == 0x000050, "Member 'FGbxAbilityEffectInstance::Condition' has a wrong offset!");
static_assert(offsetof(FGbxAbilityEffectInstance, TargetResolutionStrategies) == 0x000058, "Member 'FGbxAbilityEffectInstance::TargetResolutionStrategies' has a wrong offset!");

// ScriptStruct GbxAbilities.GbxAbilitySpec
// 0x0010 (0x0010 - 0x0000)
struct FGbxAbilitySpec final
{
public:
	TSubclassOf<class UGbxAbility>                AbilityClass;                                      // 0x0000(0x0008)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EGbxAbilityDurationType                       DurationType;                                      // 0x0008(0x0001)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_9[0x3];                                        // 0x0009(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         DurationInitializerData;                           // 0x000C(0x0004)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FGbxAbilitySpec) == 0x000008, "Wrong alignment on FGbxAbilitySpec");
static_assert(sizeof(FGbxAbilitySpec) == 0x000010, "Wrong size on FGbxAbilitySpec");
static_assert(offsetof(FGbxAbilitySpec, AbilityClass) == 0x000000, "Member 'FGbxAbilitySpec::AbilityClass' has a wrong offset!");
static_assert(offsetof(FGbxAbilitySpec, DurationType) == 0x000008, "Member 'FGbxAbilitySpec::DurationType' has a wrong offset!");
static_assert(offsetof(FGbxAbilitySpec, DurationInitializerData) == 0x00000C, "Member 'FGbxAbilitySpec::DurationInitializerData' has a wrong offset!");

// ScriptStruct GbxAbilities.GbxAbilityManagerComponentDeferredOperation
// 0x0028 (0x0028 - 0x0000)
struct FGbxAbilityManagerComponentDeferredOperation final
{
public:
	uint8                                         Pad_0[0x8];                                        // 0x0000(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	struct FGbxAbilitySpec                        AddSpec;                                           // 0x0008(0x0010)(NoDestructor, NativeAccessSpecifierPublic)
	uint8                                         Pad_18[0x8];                                       // 0x0018(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	TSubclassOf<class UGbxAbility>                RemoveSpec;                                        // 0x0020(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FGbxAbilityManagerComponentDeferredOperation) == 0x000008, "Wrong alignment on FGbxAbilityManagerComponentDeferredOperation");
static_assert(sizeof(FGbxAbilityManagerComponentDeferredOperation) == 0x000028, "Wrong size on FGbxAbilityManagerComponentDeferredOperation");
static_assert(offsetof(FGbxAbilityManagerComponentDeferredOperation, AddSpec) == 0x000008, "Member 'FGbxAbilityManagerComponentDeferredOperation::AddSpec' has a wrong offset!");
static_assert(offsetof(FGbxAbilityManagerComponentDeferredOperation, RemoveSpec) == 0x000020, "Member 'FGbxAbilityManagerComponentDeferredOperation::RemoveSpec' has a wrong offset!");

// ScriptStruct GbxAbilities.GbxAbilityEffect
// 0x0020 (0x0020 - 0x0000)
struct FGbxAbilityEffect final
{
public:
	class UStatusEffectData*                      StatusEffectData;                                  // 0x0000(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TArray<class UGbxAbilityEffectTargetResolutionData*> TargetResolutionStrategies;                        // 0x0008(0x0010)(Edit, ZeroConstructor, NativeAccessSpecifierPublic)
	class UGbxCondition*                          Condition;                                         // 0x0018(0x0008)(Edit, ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, PersistentInstance, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FGbxAbilityEffect) == 0x000008, "Wrong alignment on FGbxAbilityEffect");
static_assert(sizeof(FGbxAbilityEffect) == 0x000020, "Wrong size on FGbxAbilityEffect");
static_assert(offsetof(FGbxAbilityEffect, StatusEffectData) == 0x000000, "Member 'FGbxAbilityEffect::StatusEffectData' has a wrong offset!");
static_assert(offsetof(FGbxAbilityEffect, TargetResolutionStrategies) == 0x000008, "Member 'FGbxAbilityEffect::TargetResolutionStrategies' has a wrong offset!");
static_assert(offsetof(FGbxAbilityEffect, Condition) == 0x000018, "Member 'FGbxAbilityEffect::Condition' has a wrong offset!");

// ScriptStruct GbxAbilities.GbxAbilityManagerComponentListLock
// 0x0020 (0x0020 - 0x0000)
struct FGbxAbilityManagerComponentListLock final
{
public:
	class UGbxAbilityManagerComponent*            Owner;                                             // 0x0000(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	TArray<struct FGbxAbilityManagerComponentDeferredOperation> DeferredOps;                                       // 0x0008(0x0010)(ZeroConstructor, NativeAccessSpecifierPrivate)
	uint8                                         Pad_18[0x8];                                       // 0x0018(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FGbxAbilityManagerComponentListLock) == 0x000008, "Wrong alignment on FGbxAbilityManagerComponentListLock");
static_assert(sizeof(FGbxAbilityManagerComponentListLock) == 0x000020, "Wrong size on FGbxAbilityManagerComponentListLock");
static_assert(offsetof(FGbxAbilityManagerComponentListLock, Owner) == 0x000000, "Member 'FGbxAbilityManagerComponentListLock::Owner' has a wrong offset!");
static_assert(offsetof(FGbxAbilityManagerComponentListLock, DeferredOps) == 0x000008, "Member 'FGbxAbilityManagerComponentListLock::DeferredOps' has a wrong offset!");

// ScriptStruct GbxAbilities.GbxAbilityResourceController_ConditionalDamageModifier
// 0x0010 (0x0028 - 0x0018)
struct FGbxAbilityResourceController_ConditionalDamageModifier final : public FGbxAbilityResourceController
{
public:
	uint8                                         Pad_18[0x10];                                      // 0x0018(0x0010)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FGbxAbilityResourceController_ConditionalDamageModifier) == 0x000008, "Wrong alignment on FGbxAbilityResourceController_ConditionalDamageModifier");
static_assert(sizeof(FGbxAbilityResourceController_ConditionalDamageModifier) == 0x000028, "Wrong size on FGbxAbilityResourceController_ConditionalDamageModifier");

// ScriptStruct GbxAbilities.GbxAbilityResourceSpec_ConditionalDamageModifier
// 0x0018 (0x0028 - 0x0010)
struct FGbxAbilityResourceSpec_ConditionalDamageModifier final : public FGbxAbilityResourceSpec
{
public:
	class UDamageBaseComponent*                   DamageComponent;                                   // 0x0010(0x0008)(BlueprintVisible, ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UConditionalDamageModifier*             DamageModifier;                                    // 0x0018(0x0008)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UObject*                                ContextOverride;                                   // 0x0020(0x0008)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FGbxAbilityResourceSpec_ConditionalDamageModifier) == 0x000008, "Wrong alignment on FGbxAbilityResourceSpec_ConditionalDamageModifier");
static_assert(sizeof(FGbxAbilityResourceSpec_ConditionalDamageModifier) == 0x000028, "Wrong size on FGbxAbilityResourceSpec_ConditionalDamageModifier");
static_assert(offsetof(FGbxAbilityResourceSpec_ConditionalDamageModifier, DamageComponent) == 0x000010, "Member 'FGbxAbilityResourceSpec_ConditionalDamageModifier::DamageComponent' has a wrong offset!");
static_assert(offsetof(FGbxAbilityResourceSpec_ConditionalDamageModifier, DamageModifier) == 0x000018, "Member 'FGbxAbilityResourceSpec_ConditionalDamageModifier::DamageModifier' has a wrong offset!");
static_assert(offsetof(FGbxAbilityResourceSpec_ConditionalDamageModifier, ContextOverride) == 0x000020, "Member 'FGbxAbilityResourceSpec_ConditionalDamageModifier::ContextOverride' has a wrong offset!");

// ScriptStruct GbxAbilities.GbxAbilityResourceController_ResourcePoolDelegate
// 0x0010 (0x0028 - 0x0018)
struct FGbxAbilityResourceController_ResourcePoolDelegate final : public FGbxAbilityResourceController
{
public:
	uint8                                         Pad_18[0x10];                                      // 0x0018(0x0010)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FGbxAbilityResourceController_ResourcePoolDelegate) == 0x000008, "Wrong alignment on FGbxAbilityResourceController_ResourcePoolDelegate");
static_assert(sizeof(FGbxAbilityResourceController_ResourcePoolDelegate) == 0x000028, "Wrong size on FGbxAbilityResourceController_ResourcePoolDelegate");

// ScriptStruct GbxAbilities.GbxAbilityResourceSpec_ResourcePoolDelegate
// 0x0020 (0x0030 - 0x0010)
struct FGbxAbilityResourceSpec_ResourcePoolDelegate final : public FGbxAbilityResourceSpec
{
public:
	class UGameResourcePoolManagerComponent*      ResourcePoolComponent;                             // 0x0010(0x0008)(BlueprintVisible, ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UGameResourcePoolData*                  ResourcePoolData;                                  // 0x0018(0x0008)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EAbilityResourceDelegateType                  DelegateType;                                      // 0x0020(0x0001)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_21[0x7];                                       // 0x0021(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	class UDelegateProperty*                      DelegateEventProperty;                             // 0x0028(0x0008)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FGbxAbilityResourceSpec_ResourcePoolDelegate) == 0x000008, "Wrong alignment on FGbxAbilityResourceSpec_ResourcePoolDelegate");
static_assert(sizeof(FGbxAbilityResourceSpec_ResourcePoolDelegate) == 0x000030, "Wrong size on FGbxAbilityResourceSpec_ResourcePoolDelegate");
static_assert(offsetof(FGbxAbilityResourceSpec_ResourcePoolDelegate, ResourcePoolComponent) == 0x000010, "Member 'FGbxAbilityResourceSpec_ResourcePoolDelegate::ResourcePoolComponent' has a wrong offset!");
static_assert(offsetof(FGbxAbilityResourceSpec_ResourcePoolDelegate, ResourcePoolData) == 0x000018, "Member 'FGbxAbilityResourceSpec_ResourcePoolDelegate::ResourcePoolData' has a wrong offset!");
static_assert(offsetof(FGbxAbilityResourceSpec_ResourcePoolDelegate, DelegateType) == 0x000020, "Member 'FGbxAbilityResourceSpec_ResourcePoolDelegate::DelegateType' has a wrong offset!");
static_assert(offsetof(FGbxAbilityResourceSpec_ResourcePoolDelegate, DelegateEventProperty) == 0x000028, "Member 'FGbxAbilityResourceSpec_ResourcePoolDelegate::DelegateEventProperty' has a wrong offset!");

// ScriptStruct GbxAbilities.GbxAbilityResourceController_ScriptDelegate
// 0x0010 (0x0028 - 0x0018)
struct FGbxAbilityResourceController_ScriptDelegate final : public FGbxAbilityResourceController
{
public:
	uint8                                         Pad_18[0x10];                                      // 0x0018(0x0010)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FGbxAbilityResourceController_ScriptDelegate) == 0x000008, "Wrong alignment on FGbxAbilityResourceController_ScriptDelegate");
static_assert(sizeof(FGbxAbilityResourceController_ScriptDelegate) == 0x000028, "Wrong size on FGbxAbilityResourceController_ScriptDelegate");

// ScriptStruct GbxAbilities.GbxAbilityResourceSpec_ScriptDelegate
// 0x0018 (0x0028 - 0x0010)
struct FGbxAbilityResourceSpec_ScriptDelegate final : public FGbxAbilityResourceSpec
{
public:
	class UObject*                                TargetContext;                                     // 0x0010(0x0008)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UMulticastDelegateProperty*             TargetProperty;                                    // 0x0018(0x0008)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UDelegateProperty*                      DelegateEventProperty;                             // 0x0020(0x0008)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FGbxAbilityResourceSpec_ScriptDelegate) == 0x000008, "Wrong alignment on FGbxAbilityResourceSpec_ScriptDelegate");
static_assert(sizeof(FGbxAbilityResourceSpec_ScriptDelegate) == 0x000028, "Wrong size on FGbxAbilityResourceSpec_ScriptDelegate");
static_assert(offsetof(FGbxAbilityResourceSpec_ScriptDelegate, TargetContext) == 0x000010, "Member 'FGbxAbilityResourceSpec_ScriptDelegate::TargetContext' has a wrong offset!");
static_assert(offsetof(FGbxAbilityResourceSpec_ScriptDelegate, TargetProperty) == 0x000018, "Member 'FGbxAbilityResourceSpec_ScriptDelegate::TargetProperty' has a wrong offset!");
static_assert(offsetof(FGbxAbilityResourceSpec_ScriptDelegate, DelegateEventProperty) == 0x000020, "Member 'FGbxAbilityResourceSpec_ScriptDelegate::DelegateEventProperty' has a wrong offset!");

}

