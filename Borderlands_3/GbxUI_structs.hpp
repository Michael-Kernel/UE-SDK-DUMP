#pragma once

/*
* SDK generated by Dumper-7
*
* https://github.com/Encryqed/Dumper-7
*/

// Package: GbxUI

#include "Basic.hpp"

#include "GbxGameSystemCore_structs.hpp"
#include "CoreUObject_structs.hpp"
#include "Engine_structs.hpp"
#include "SlateCore_structs.hpp"
#include "InputCore_structs.hpp"


namespace SDK
{

// Enum GbxUI.EGbxFocusableWidgetState
// NumValues: 0x0009
enum class EGbxFocusableWidgetState : uint8
{
	Unknown                                  = 0,
	Disabled                                 = 1,
	NotFocused                               = 2,
	NotFocused_MouseHovered                  = 3,
	NotFocused_MouseDown                     = 4,
	Focused                                  = 5,
	Focused_MouseHovered                     = 6,
	Focused_MouseDown                        = 7,
	EGbxFocusableWidgetState_MAX             = 8,
};

// Enum GbxUI.EGbxFocusableWidgetMouseBehavior
// NumValues: 0x0005
enum class EGbxFocusableWidgetMouseBehavior : uint8
{
	None                                     = 0,
	SelectOnHover                            = 1,
	SelectOnClick                            = 2,
	InheritFromOwner                         = 3,
	EGbxFocusableWidgetMouseBehavior_MAX     = 4,
};

// Enum GbxUI.EGbxGFxButtonType
// NumValues: 0x0005
enum class EGbxGFxButtonType : uint8
{
	Standard                                 = 0,
	Checkbox                                 = 1,
	Radio                                    = 2,
	UserCheckbox                             = 3,
	EGbxGFxButtonType_MAX                    = 4,
};

// Enum GbxUI.EGbxGFxButtonCheckedState
// NumValues: 0x0003
enum class EGbxGFxButtonCheckedState : uint8
{
	Unchecked                                = 0,
	Checked                                  = 1,
	EGbxGFxButtonCheckedState_MAX            = 2,
};

// Enum GbxUI.EGbxGFxButtonLockedState
// NumValues: 0x0003
enum class EGbxGFxButtonLockedState : uint8
{
	Unlocked                                 = 0,
	Locked                                   = 1,
	EGbxGFxButtonLockedState_MAX             = 2,
};

// Enum GbxUI.EMenuTransition
// NumValues: 0x000F
enum class EMenuTransition : uint8
{
	CreateCharacterMenu_MainMenu             = 0,
	LoadCharacterMenu_MainMenu               = 1,
	MainMenu_LoadCharacterMenu               = 2,
	MainMenu_NewGameSettingMenu              = 3,
	MainMenu_OptionMenu                      = 4,
	NewGameSettingsMenu_MainMenu             = 5,
	OptionMenu_MainMenu                      = 6,
	TitleScreen_MainMenu                     = 7,
	TitleScreen_FirstBoot                    = 8,
	FirstBoot_MainMenu                       = 9,
	PlaythroughSelectionMenu_MainMenu        = 10,
	MainMenu_PlaythroughSelectionMenu        = 11,
	Invalid                                  = 12,
	None                                     = 13,
	EMenuTransition_MAX                      = 14,
};

// Enum GbxUI.EGbxMenuInputDevice
// NumValues: 0x0004
enum class EGbxMenuInputDevice : uint8
{
	Unknown                                  = 0,
	Gamepad                                  = 1,
	KeyboardMouse                            = 2,
	EGbxMenuInputDevice_MAX                  = 3,
};

// Enum GbxUI.EBindingType
// NumValues: 0x0004
enum class EBindingType : uint8
{
	Walking                                  = 0,
	Common                                   = 1,
	Driving                                  = 2,
	EBindingType_MAX                         = 3,
};

// Enum GbxUI.EGbxProgressBarFillDirection
// NumValues: 0x0003
enum class EGbxProgressBarFillDirection : uint8
{
	LeftToRight                              = 0,
	RightToLeft                              = 1,
	EGbxProgressBarFillDirection_MAX         = 2,
};

// Enum GbxUI.EHUDInitializationAnimationSet
// NumValues: 0x0008
enum class EHUDInitializationAnimationSet : uint8
{
	None                                     = 0,
	InitialSet                               = 1,
	AmmoBar                                  = 2,
	ShieldBar                                = 3,
	MissionTracker                           = 4,
	GrenadeBar                               = 5,
	Full                                     = 6,
	EHUDInitializationAnimationSet_MAX       = 7,
};

// Enum GbxUI.EUIAudioSettingOperation
// NumValues: 0x0004
enum class EUIAudioSettingOperation : uint8
{
	Delete                                   = 0,
	Replace                                  = 1,
	Preserve                                 = 2,
	EUIAudioSettingOperation_MAX             = 3,
};

// Enum GbxUI.EGbxGFxListAlignment
// NumValues: 0x0004
enum class EGbxGFxListAlignment : uint8
{
	Left                                     = 0,
	Right                                    = 1,
	Center                                   = 2,
	EGbxGFxListAlignment_MAX                 = 3,
};

// Enum GbxUI.EGFxHUDWidgetAnchorType
// NumValues: 0x0003
enum class EGFxHUDWidgetAnchorType : uint8
{
	Viewport                                 = 0,
	Crosshair                                = 1,
	EGFxHUDWidgetAnchorType_MAX              = 2,
};

// Enum GbxUI.EGbxDialogBoxHelpersDialogTemplate
// NumValues: 0x0004
enum class EGbxDialogBoxHelpersDialogTemplate : uint8
{
	Default                                  = 0,
	Warning                                  = 1,
	Error                                    = 2,
	EGbxDialogBoxHelpersDialogTemplate_MAX   = 3,
};

// Enum GbxUI.EChargeClipState
// NumValues: 0x0004
enum class EChargeClipState : uint8
{
	NOCHARGE                                 = 0,
	SPREADCLIP                               = 1,
	ACCURACYCLIP                             = 2,
	EChargeClipState_MAX                     = 3,
};

// Enum GbxUI.EContextualMenuEntryType
// NumValues: 0x001B
enum class EContextualMenuEntryType : uint8
{
	Invite                                   = 0,
	Join                                     = 1,
	SendItem                                 = 2,
	Favorite                                 = 3,
	Unfavorite                               = 4,
	Mute                                     = 5,
	Unmute                                   = 6,
	Delete                                   = 7,
	KickOut                                  = 8,
	Inspect                                  = 9,
	ViewProfile                              = 10,
	AddFriend                                = 11,
	RemoveFriend                             = 12,
	NetworkOption_Anyone                     = 13,
	NetworkOption_FriendsOnly                = 14,
	NetworkOption_InviteOnly                 = 15,
	LootMode_Classic                         = 16,
	LootMode_Shared                          = 17,
	Shift_SecondaryIdentity                  = 18,
	Shift_AddFriend                          = 19,
	Shift_RemoveFriend                       = 20,
	Shift_Block                              = 21,
	Shift_Unblock                            = 22,
	Shift_Report                             = 23,
	None                                     = 24,
	Count                                    = 25,
	EContextualMenuEntryType_MAX             = 26,
};

// Enum GbxUI.EContextualMenuExpandDirection
// NumValues: 0x0004
enum class EContextualMenuExpandDirection : uint8
{
	Unknown                                  = 0,
	Down                                     = 1,
	Up                                       = 2,
	EContextualMenuExpandDirection_MAX       = 3,
};

// Enum GbxUI.EContextualMenuLayout
// NumValues: 0x0004
enum class EContextualMenuLayout : uint8
{
	RosterMenu                               = 0,
	MailMenuSendTo                           = 1,
	MailMenuRecieved                         = 2,
	EContextualMenuLayout_MAX                = 3,
};

// Enum GbxUI.GFxVirtualKeyboardType
// NumValues: 0x0007
enum class EGFxVirtualKeyboardType : uint8
{
	Default                                  = 0,
	Number                                   = 1,
	Web                                      = 2,
	Email                                    = 3,
	Password                                 = 4,
	AlphaNumeric                             = 5,
	GFxVirtualKeyboardType_MAX               = 6,
};

// Enum GbxUI.EGbxGFxListConfigType
// NumValues: 0x0003
enum class EGbxGFxListConfigType : uint8
{
	All                                      = 0,
	PreserveLayout                           = 1,
	EGbxGFxListConfigType_MAX                = 2,
};

// Enum GbxUI.EGbxGFxScrollListAddedItemPriority
// NumValues: 0x0003
enum class EGbxGFxScrollListAddedItemPriority : uint8
{
	NewestOnTop                              = 0,
	OldestOnTop                              = 1,
	EGbxGFxScrollListAddedItemPriority_MAX   = 2,
};

// Enum GbxUI.EGbxGFxScrollListFocusOrderPriority
// NumValues: 0x0005
enum class EGbxGFxScrollListFocusOrderPriority : uint8
{
	BringToFront                             = 0,
	LeaveUnchanged                           = 1,
	BringToFrontWithEverythingElseInOrder    = 2,
	BringToFrontWithEverythingElseInReverseOrder = 3,
	EGbxGFxScrollListFocusOrderPriority_MAX  = 4,
};

// Enum GbxUI.EGFxHUDWidgetTransitionType
// NumValues: 0x0003
enum class EGFxHUDWidgetTransitionType : uint8
{
	Animate                                  = 0,
	Instant                                  = 1,
	EGFxHUDWidgetTransitionType_MAX          = 2,
};

// Enum GbxUI.EGbxGFxListOrientation
// NumValues: 0x0003
enum class EGbxGFxListOrientation : uint8
{
	Vertical                                 = 0,
	Horizontal                               = 1,
	EGbxGFxListOrientation_MAX               = 2,
};

// Enum GbxUI.EGbxGFxScrollListFocusChangedAction
// NumValues: 0x0004
enum class EGbxGFxScrollListFocusChangedAction : uint8
{
	DoNotChangeSelection                     = 0,
	SelectNoneOnLossSelectFirstOnGain        = 1,
	SelectNoneOnLossRestorePreviousOnGain    = 2,
	EGbxGFxScrollListFocusChangedAction_MAX  = 3,
};

// Enum GbxUI.EGbxGFxScrollListWrapMode
// NumValues: 0x0003
enum class EGbxGFxScrollListWrapMode : uint8
{
	Stick                                    = 0,
	Wrap                                     = 1,
	EGbxGFxScrollListWrapMode_MAX            = 2,
};

// Enum GbxUI.EGbxGFxMenuSwitcherSubmenuInitReason
// NumValues: 0x0006
enum class EGbxGFxMenuSwitcherSubmenuInitReason : uint8
{
	Unknown                                  = 0,
	Pushed                                   = 1,
	NextPage                                 = 2,
	PrevPage                                 = 3,
	Switched                                 = 4,
	EGbxGFxMenuSwitcherSubmenuInitReason_MAX = 5,
};

// Enum GbxUI.EGbxGFxMenuSwitchNavWidgetType
// NumValues: 0x0004
enum class EGbxGFxMenuSwitchNavWidgetType : uint32
{
	Unknown                                  = 0,
	MenuSwitcher                             = 1,
	CustomSwitcher                           = 2,
	EGbxGFxMenuSwitchNavWidgetType_MAX       = 3,
};

// Enum GbxUI.EEdgeFlashType
// NumValues: 0x0004
enum class EEdgeFlashType : uint8
{
	None                                     = 0,
	InterpolatedDecreaseOnly                 = 1,
	All                                      = 2,
	EEdgeFlashType_MAX                       = 3,
};

// Enum GbxUI.EGbxGFxSliderState
// NumValues: 0x0004
enum class EGbxGFxSliderState : uint8
{
	NotScrolling                             = 0,
	ScrollingLeft                            = 1,
	ScrollingRight                           = 2,
	EGbxGFxSliderState_MAX                   = 3,
};

// Enum GbxUI.EGbxGFxSliderDirection
// NumValues: 0x0003
enum class EGbxGFxSliderDirection : uint8
{
	Horizontal                               = 0,
	Vertical                                 = 1,
	EGbxGFxSliderDirection_MAX               = 2,
};

// Enum GbxUI.EGbxGridWidgetFill
// NumValues: 0x0003
enum class EGbxGridWidgetFill : uint8
{
	FillRow                                  = 0,
	FillColumn                               = 1,
	EGbxGridWidgetFill_MAX                   = 2,
};

// Enum GbxUI.EGbxHUDStateListType
// NumValues: 0x0003
enum class EGbxHUDStateListType : uint8
{
	WhiteList                                = 0,
	BlackList                                = 1,
	EGbxHUDStateListType_MAX                 = 2,
};

// Enum GbxUI.EHUDStateManagerVisibility
// NumValues: 0x0004
enum class EHUDStateManagerVisibility : uint8
{
	Unknown                                  = 0,
	Visible                                  = 1,
	NotVisible                               = 2,
	EHUDStateManagerVisibility_MAX           = 3,
};

// Enum GbxUI.EGbxListFocusChangedAction
// NumValues: 0x0004
enum class EGbxListFocusChangedAction : uint8
{
	DoNotChangeSelection                     = 0,
	SelectNoneOnLossSelectFirstOnGain        = 1,
	SelectNoneOnLossRestorePreviousOnGain    = 2,
	EGbxListFocusChangedAction_MAX           = 3,
};

// Enum GbxUI.EGbxListWrapMode
// NumValues: 0x0003
enum class EGbxListWrapMode : uint8
{
	Stick                                    = 0,
	Wrap                                     = 1,
	EGbxListWrapMode_MAX                     = 2,
};

// Enum GbxUI.EGbxMenuInputMode
// NumValues: 0x0007
enum class EGbxMenuInputMode : uint8
{
	None                                     = 0,
	OwnerPlayer                              = 1,
	OwnerPlayer_DontConsumeInput             = 2,
	AnyLocalPlayer                           = 3,
	AnyController                            = 4,
	Inherit                                  = 5,
	EGbxMenuInputMode_MAX                    = 6,
};

// Enum GbxUI.EGbxMenuParentType
// NumValues: 0x0004
enum class EGbxMenuParentType : uint8
{
	Viewport                                 = 0,
	PlayerScreen                             = 1,
	Inherit                                  = 2,
	EGbxMenuParentType_MAX                   = 3,
};

// Enum GbxUI.EGbxMenuInputActionTrigger
// NumValues: 0x0005
enum class EGbxMenuInputActionTrigger : uint8
{
	Pressed                                  = 0,
	Held                                     = 1,
	HeldLong                                 = 2,
	Released                                 = 3,
	EGbxMenuInputActionTrigger_MAX           = 4,
};

// Enum GbxUI.EGbxMenuSwitcherSubmenuInitReason
// NumValues: 0x0006
enum class EGbxMenuSwitcherSubmenuInitReason : uint8
{
	Unknown                                  = 0,
	Pushed                                   = 1,
	NextPage                                 = 2,
	PrevPage                                 = 3,
	Switched                                 = 4,
	EGbxMenuSwitcherSubmenuInitReason_MAX    = 5,
};

// Enum GbxUI.EMenuTransitionOperation
// NumValues: 0x0005
enum class EMenuTransitionOperation : uint8
{
	Push                                     = 0,
	Pop                                      = 1,
	Invalid                                  = 2,
	None                                     = 3,
	EMenuTransitionOperation_MAX             = 4,
};

// Enum GbxUI.EGbxScrollBoxListFocusChangedAction
// NumValues: 0x0004
enum class EGbxScrollBoxListFocusChangedAction : uint8
{
	DoNotChangeSelection                     = 0,
	SelectNoneOnLossSelectFirstOnGain        = 1,
	SelectNoneOnLossRestorePreviousOnGain    = 2,
	EGbxScrollBoxListFocusChangedAction_MAX  = 3,
};

// Enum GbxUI.EGbxScrollBoxListWrapMode
// NumValues: 0x0003
enum class EGbxScrollBoxListWrapMode : uint8
{
	Stick                                    = 0,
	Wrap                                     = 1,
	EGbxScrollBoxListWrapMode_MAX            = 2,
};

// Enum GbxUI.EVerticalTextAutoSizeType
// NumValues: 0x0005
enum class EVerticalTextAutoSizeType : uint8
{
	None                                     = 0,
	Top                                      = 1,
	Center                                   = 2,
	bottom                                   = 3,
	EVerticalTextAutoSizeType_MAX            = 4,
};

// Enum GbxUI.EHoldToPressGlyphType
// NumValues: 0x0006
enum class EHoldToPressGlyphType : uint8
{
	None                                     = 0,
	Gamepad                                  = 1,
	Keyboard                                 = 2,
	KeyboardWide                             = 3,
	KeyboardXWide                            = 4,
	EHoldToPressGlyphType_MAX                = 5,
};

// Enum GbxUI.EGbxInputGlyphType
// NumValues: 0x0009
enum class EGbxInputGlyphType : uint8
{
	KeyboardMouse                            = 0,
	PS4                                      = 1,
	XboxOne                                  = 2,
	GenericGamepad                           = 3,
	SwitchPro                                = 4,
	Stadia                                   = 5,
	DPX                                      = 6,
	MPX                                      = 7,
	EGbxInputGlyphType_MAX                   = 8,
};

// Enum GbxUI.EGbxActionToTextType
// NumValues: 0x0004
enum class EGbxActionToTextType : uint8
{
	PlayerController                         = 0,
	KeyboardMouse                            = 1,
	Gamepad                                  = 2,
	EGbxActionToTextType_MAX                 = 3,
};

// Enum GbxUI.EGbxSpinnerWidgetGoToMethod
// NumValues: 0x0003
enum class EGbxSpinnerWidgetGoToMethod : uint8
{
	FromCurrent                              = 0,
	Immediately                              = 1,
	EGbxSpinnerWidgetGoToMethod_MAX          = 2,
};

// ScriptStruct GbxUI.GbxDialogBoxChoiceInfo
// 0x0028 (0x0028 - 0x0000)
struct FGbxDialogBoxChoiceInfo final
{
public:
	class FText                                   LabelText;                                         // 0x0000(0x0018)(BlueprintVisible, NativeAccessSpecifierPublic)
	class FName                                   ChoiceNameId;                                      // 0x0018(0x0008)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bCloseDialogOnSelection;                           // 0x0020(0x0001)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_21[0x7];                                       // 0x0021(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FGbxDialogBoxChoiceInfo) == 0x000008, "Wrong alignment on FGbxDialogBoxChoiceInfo");
static_assert(sizeof(FGbxDialogBoxChoiceInfo) == 0x000028, "Wrong size on FGbxDialogBoxChoiceInfo");
static_assert(offsetof(FGbxDialogBoxChoiceInfo, LabelText) == 0x000000, "Member 'FGbxDialogBoxChoiceInfo::LabelText' has a wrong offset!");
static_assert(offsetof(FGbxDialogBoxChoiceInfo, ChoiceNameId) == 0x000018, "Member 'FGbxDialogBoxChoiceInfo::ChoiceNameId' has a wrong offset!");
static_assert(offsetof(FGbxDialogBoxChoiceInfo, bCloseDialogOnSelection) == 0x000020, "Member 'FGbxDialogBoxChoiceInfo::bCloseDialogOnSelection' has a wrong offset!");

// ScriptStruct GbxUI.GbxGFxMediaPlayerConfig
// 0x0030 (0x0030 - 0x0000)
struct FGbxGFxMediaPlayerConfig final
{
public:
	class UMediaPlayer*                           MediaPlayer;                                       // 0x0000(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UGbxMediaData*                          MediaData;                                         // 0x0008(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UMaterialInterface*                     MediaMaterial;                                     // 0x0010(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector2D                              MediaDimensions;                                   // 0x0018(0x0008)(Edit, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FString                                 ExternalTextureName;                               // 0x0020(0x0010)(Edit, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FGbxGFxMediaPlayerConfig) == 0x000008, "Wrong alignment on FGbxGFxMediaPlayerConfig");
static_assert(sizeof(FGbxGFxMediaPlayerConfig) == 0x000030, "Wrong size on FGbxGFxMediaPlayerConfig");
static_assert(offsetof(FGbxGFxMediaPlayerConfig, MediaPlayer) == 0x000000, "Member 'FGbxGFxMediaPlayerConfig::MediaPlayer' has a wrong offset!");
static_assert(offsetof(FGbxGFxMediaPlayerConfig, MediaData) == 0x000008, "Member 'FGbxGFxMediaPlayerConfig::MediaData' has a wrong offset!");
static_assert(offsetof(FGbxGFxMediaPlayerConfig, MediaMaterial) == 0x000010, "Member 'FGbxGFxMediaPlayerConfig::MediaMaterial' has a wrong offset!");
static_assert(offsetof(FGbxGFxMediaPlayerConfig, MediaDimensions) == 0x000018, "Member 'FGbxGFxMediaPlayerConfig::MediaDimensions' has a wrong offset!");
static_assert(offsetof(FGbxGFxMediaPlayerConfig, ExternalTextureName) == 0x000020, "Member 'FGbxGFxMediaPlayerConfig::ExternalTextureName' has a wrong offset!");

// ScriptStruct GbxUI.GbxMenuInputEvent
// 0x0030 (0x0030 - 0x0000)
struct alignas(0x08) FGbxMenuInputEvent final
{
public:
	uint8                                         Pad_0[0x30];                                       // 0x0000(0x0030)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FGbxMenuInputEvent) == 0x000008, "Wrong alignment on FGbxMenuInputEvent");
static_assert(sizeof(FGbxMenuInputEvent) == 0x000030, "Wrong size on FGbxMenuInputEvent");

// ScriptStruct GbxUI.GbxCascadingListItemData
// 0x0038 (0x0038 - 0x0000)
struct FGbxCascadingListItemData final
{
public:
	class FName                                   ItemId;                                            // 0x0000(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FText                                   Label;                                             // 0x0008(0x0018)(Edit, BlueprintVisible, NativeAccessSpecifierPublic)
	bool                                          bHasChildren;                                      // 0x0020(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_21[0x17];                                      // 0x0021(0x0017)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FGbxCascadingListItemData) == 0x000008, "Wrong alignment on FGbxCascadingListItemData");
static_assert(sizeof(FGbxCascadingListItemData) == 0x000038, "Wrong size on FGbxCascadingListItemData");
static_assert(offsetof(FGbxCascadingListItemData, ItemId) == 0x000000, "Member 'FGbxCascadingListItemData::ItemId' has a wrong offset!");
static_assert(offsetof(FGbxCascadingListItemData, Label) == 0x000008, "Member 'FGbxCascadingListItemData::Label' has a wrong offset!");
static_assert(offsetof(FGbxCascadingListItemData, bHasChildren) == 0x000020, "Member 'FGbxCascadingListItemData::bHasChildren' has a wrong offset!");

// ScriptStruct GbxUI.GbxComboBoxItemInfo
// 0x0020 (0x0020 - 0x0000)
struct FGbxComboBoxItemInfo final
{
public:
	class FText                                   DisplayName;                                       // 0x0000(0x0018)(Edit, NativeAccessSpecifierPublic)
	int32                                         ReferenceIndex;                                    // 0x0018(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1C[0x4];                                       // 0x001C(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FGbxComboBoxItemInfo) == 0x000008, "Wrong alignment on FGbxComboBoxItemInfo");
static_assert(sizeof(FGbxComboBoxItemInfo) == 0x000020, "Wrong size on FGbxComboBoxItemInfo");
static_assert(offsetof(FGbxComboBoxItemInfo, DisplayName) == 0x000000, "Member 'FGbxComboBoxItemInfo::DisplayName' has a wrong offset!");
static_assert(offsetof(FGbxComboBoxItemInfo, ReferenceIndex) == 0x000018, "Member 'FGbxComboBoxItemInfo::ReferenceIndex' has a wrong offset!");

// ScriptStruct GbxUI.GbxProgressBarInterpolator
// 0x0028 (0x0028 - 0x0000)
struct FGbxProgressBarInterpolator final
{
public:
	float                                         Delay;                                             // 0x0000(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         Duration;                                          // 0x0004(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FGbxEasingFunc                         EasingFunc;                                        // 0x0008(0x000C)(Edit, BlueprintVisible, NoDestructor, NativeAccessSpecifierPublic)
	float                                         StartValue;                                        // 0x0014(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         CurrentValue;                                      // 0x0018(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         EndValue;                                          // 0x001C(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         ElapsedTime;                                       // 0x0020(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         DeltaEndOverride;                                  // 0x0024(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FGbxProgressBarInterpolator) == 0x000004, "Wrong alignment on FGbxProgressBarInterpolator");
static_assert(sizeof(FGbxProgressBarInterpolator) == 0x000028, "Wrong size on FGbxProgressBarInterpolator");
static_assert(offsetof(FGbxProgressBarInterpolator, Delay) == 0x000000, "Member 'FGbxProgressBarInterpolator::Delay' has a wrong offset!");
static_assert(offsetof(FGbxProgressBarInterpolator, Duration) == 0x000004, "Member 'FGbxProgressBarInterpolator::Duration' has a wrong offset!");
static_assert(offsetof(FGbxProgressBarInterpolator, EasingFunc) == 0x000008, "Member 'FGbxProgressBarInterpolator::EasingFunc' has a wrong offset!");
static_assert(offsetof(FGbxProgressBarInterpolator, StartValue) == 0x000014, "Member 'FGbxProgressBarInterpolator::StartValue' has a wrong offset!");
static_assert(offsetof(FGbxProgressBarInterpolator, CurrentValue) == 0x000018, "Member 'FGbxProgressBarInterpolator::CurrentValue' has a wrong offset!");
static_assert(offsetof(FGbxProgressBarInterpolator, EndValue) == 0x00001C, "Member 'FGbxProgressBarInterpolator::EndValue' has a wrong offset!");
static_assert(offsetof(FGbxProgressBarInterpolator, ElapsedTime) == 0x000020, "Member 'FGbxProgressBarInterpolator::ElapsedTime' has a wrong offset!");
static_assert(offsetof(FGbxProgressBarInterpolator, DeltaEndOverride) == 0x000024, "Member 'FGbxProgressBarInterpolator::DeltaEndOverride' has a wrong offset!");

// ScriptStruct GbxUI.GbxGFxMaterialRenderer
// 0x0018 (0x0018 - 0x0000)
struct FGbxGFxMaterialRenderer final
{
public:
	class UMaterialInterface*                     Material;                                          // 0x0000(0x0008)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UTextureRenderTarget2D*                 RenderTarget;                                      // 0x0008(0x0008)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	TWeakObjectPtr<class UGbxGFxMovie>            OwningMovie;                                       // 0x0010(0x0008)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
};
static_assert(alignof(FGbxGFxMaterialRenderer) == 0x000008, "Wrong alignment on FGbxGFxMaterialRenderer");
static_assert(sizeof(FGbxGFxMaterialRenderer) == 0x000018, "Wrong size on FGbxGFxMaterialRenderer");
static_assert(offsetof(FGbxGFxMaterialRenderer, Material) == 0x000000, "Member 'FGbxGFxMaterialRenderer::Material' has a wrong offset!");
static_assert(offsetof(FGbxGFxMaterialRenderer, RenderTarget) == 0x000008, "Member 'FGbxGFxMaterialRenderer::RenderTarget' has a wrong offset!");
static_assert(offsetof(FGbxGFxMaterialRenderer, OwningMovie) == 0x000010, "Member 'FGbxGFxMaterialRenderer::OwningMovie' has a wrong offset!");

// ScriptStruct GbxUI.GbxGFxMouseCapturePanelMouseButtonInfo
// 0x001C (0x001C - 0x0000)
struct alignas(0x04) FGbxGFxMouseCapturePanelMouseButtonInfo final
{
public:
	uint8                                         Pad_0[0x1C];                                       // 0x0000(0x001C)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FGbxGFxMouseCapturePanelMouseButtonInfo) == 0x000004, "Wrong alignment on FGbxGFxMouseCapturePanelMouseButtonInfo");
static_assert(sizeof(FGbxGFxMouseCapturePanelMouseButtonInfo) == 0x00001C, "Wrong size on FGbxGFxMouseCapturePanelMouseButtonInfo");

// ScriptStruct GbxUI.GbxGFxMenuSwitcherNavWidgetCustomItem
// 0x0038 (0x0038 - 0x0000)
struct FGbxGFxMenuSwitcherNavWidgetCustomItem final
{
public:
	class FName                                   ItemId;                                            // 0x0000(0x0008)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FString                                 IconFrameName;                                     // 0x0008(0x0010)(ZeroConstructor, Transient, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FText                                   TitleText;                                         // 0x0018(0x0018)(Transient, NativeAccessSpecifierPublic)
	bool                                          bDisabled;                                         // 0x0030(0x0001)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_31[0x7];                                       // 0x0031(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FGbxGFxMenuSwitcherNavWidgetCustomItem) == 0x000008, "Wrong alignment on FGbxGFxMenuSwitcherNavWidgetCustomItem");
static_assert(sizeof(FGbxGFxMenuSwitcherNavWidgetCustomItem) == 0x000038, "Wrong size on FGbxGFxMenuSwitcherNavWidgetCustomItem");
static_assert(offsetof(FGbxGFxMenuSwitcherNavWidgetCustomItem, ItemId) == 0x000000, "Member 'FGbxGFxMenuSwitcherNavWidgetCustomItem::ItemId' has a wrong offset!");
static_assert(offsetof(FGbxGFxMenuSwitcherNavWidgetCustomItem, IconFrameName) == 0x000008, "Member 'FGbxGFxMenuSwitcherNavWidgetCustomItem::IconFrameName' has a wrong offset!");
static_assert(offsetof(FGbxGFxMenuSwitcherNavWidgetCustomItem, TitleText) == 0x000018, "Member 'FGbxGFxMenuSwitcherNavWidgetCustomItem::TitleText' has a wrong offset!");
static_assert(offsetof(FGbxGFxMenuSwitcherNavWidgetCustomItem, bDisabled) == 0x000030, "Member 'FGbxGFxMenuSwitcherNavWidgetCustomItem::bDisabled' has a wrong offset!");

// ScriptStruct GbxUI.GbxGFxListCellUpdateInfo
// 0x0010 (0x0010 - 0x0000)
struct FGbxGFxListCellUpdateInfo final
{
public:
	class UGbxGFxListCell*                        Cell;                                              // 0x0000(0x0008)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         ListIndex;                                         // 0x0008(0x0004)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bIsSelected;                                       // 0x000C(0x0001)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bIsNewSelection;                                   // 0x000D(0x0001)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bIsNewInView;                                      // 0x000E(0x0001)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_F[0x1];                                        // 0x000F(0x0001)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FGbxGFxListCellUpdateInfo) == 0x000008, "Wrong alignment on FGbxGFxListCellUpdateInfo");
static_assert(sizeof(FGbxGFxListCellUpdateInfo) == 0x000010, "Wrong size on FGbxGFxListCellUpdateInfo");
static_assert(offsetof(FGbxGFxListCellUpdateInfo, Cell) == 0x000000, "Member 'FGbxGFxListCellUpdateInfo::Cell' has a wrong offset!");
static_assert(offsetof(FGbxGFxListCellUpdateInfo, ListIndex) == 0x000008, "Member 'FGbxGFxListCellUpdateInfo::ListIndex' has a wrong offset!");
static_assert(offsetof(FGbxGFxListCellUpdateInfo, bIsSelected) == 0x00000C, "Member 'FGbxGFxListCellUpdateInfo::bIsSelected' has a wrong offset!");
static_assert(offsetof(FGbxGFxListCellUpdateInfo, bIsNewSelection) == 0x00000D, "Member 'FGbxGFxListCellUpdateInfo::bIsNewSelection' has a wrong offset!");
static_assert(offsetof(FGbxGFxListCellUpdateInfo, bIsNewInView) == 0x00000E, "Member 'FGbxGFxListCellUpdateInfo::bIsNewInView' has a wrong offset!");

// ScriptStruct GbxUI.GbxGFxListConfig
// 0x0090 (0x0090 - 0x0000)
struct FGbxGFxListConfig final
{
public:
	EGbxGFxListConfigType                         ConfigType;                                        // 0x0000(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EGbxGFxListOrientation                        ListOrientation;                                   // 0x0001(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EGbxGFxListAlignment                          ListAlignment;                                     // 0x0002(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_3[0x1];                                        // 0x0003(0x0001)(Fixing Size After Last Property [ Dumper-7 ])
	int32                                         FillSize;                                          // 0x0004(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         VertCellSpacing;                                   // 0x0008(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         HorzCellSpacing;                                   // 0x000C(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bAutoHideScrollBar;                                // 0x0010(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_11[0x7];                                       // 0x0011(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	class FString                                 ScrollBarName;                                     // 0x0018(0x0010)(Edit, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EGbxGFxScrollListWrapMode                     WrapMode;                                          // 0x0028(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EGbxFocusableWidgetMouseBehavior              DefaultItemSelectionBehavior;                      // 0x0029(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EGbxGFxScrollListFocusChangedAction           FocusChangeAction;                                 // 0x002A(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bMustHaveOneFocusableCellToReceiveFocus;           // 0x002B(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2C[0x4];                                       // 0x002C(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class FString                                 EntryPrefix;                                       // 0x0030(0x0010)(Edit, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FString                                 GridAreaName;                                      // 0x0040(0x0010)(Edit, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FString                                 GridMaskName;                                      // 0x0050(0x0010)(Edit, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EGbxGFxScrollListFocusOrderPriority           FocusOrderPriority;                                // 0x0060(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EGbxGFxScrollListAddedItemPriority            AddedItemPriority;                                 // 0x0061(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bUseFixedCellBounds;                               // 0x0062(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_63[0x1];                                       // 0x0063(0x0001)(Fixing Size After Last Property [ Dumper-7 ])
	struct FVector2D                              FixedCellBoundsDemensions;                         // 0x0064(0x0008)(Edit, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bMoveSelectionScrollIntoView;                      // 0x006C(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bMoveSelectionAnimateScroll;                       // 0x006D(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bKeepScrollbarOnTop;                               // 0x006E(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bAlwaysConsumeDirectionInput;                      // 0x006F(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bAllowScrolling;                                   // 0x0070(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bReverseScrollDirection;                           // 0x0071(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_72[0x6];                                       // 0x0072(0x0006)(Fixing Size After Last Property [ Dumper-7 ])
	class FName                                   DefaultItemSelectedAudioEventName;                 // 0x0078(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   DefaultItemClickedAudioEventName;                  // 0x0080(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bCanBeNavigatedIfMouseDisabled;                    // 0x0088(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bFocusListIfCellGetsFocused;                       // 0x0089(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_8A[0x6];                                       // 0x008A(0x0006)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FGbxGFxListConfig) == 0x000008, "Wrong alignment on FGbxGFxListConfig");
static_assert(sizeof(FGbxGFxListConfig) == 0x000090, "Wrong size on FGbxGFxListConfig");
static_assert(offsetof(FGbxGFxListConfig, ConfigType) == 0x000000, "Member 'FGbxGFxListConfig::ConfigType' has a wrong offset!");
static_assert(offsetof(FGbxGFxListConfig, ListOrientation) == 0x000001, "Member 'FGbxGFxListConfig::ListOrientation' has a wrong offset!");
static_assert(offsetof(FGbxGFxListConfig, ListAlignment) == 0x000002, "Member 'FGbxGFxListConfig::ListAlignment' has a wrong offset!");
static_assert(offsetof(FGbxGFxListConfig, FillSize) == 0x000004, "Member 'FGbxGFxListConfig::FillSize' has a wrong offset!");
static_assert(offsetof(FGbxGFxListConfig, VertCellSpacing) == 0x000008, "Member 'FGbxGFxListConfig::VertCellSpacing' has a wrong offset!");
static_assert(offsetof(FGbxGFxListConfig, HorzCellSpacing) == 0x00000C, "Member 'FGbxGFxListConfig::HorzCellSpacing' has a wrong offset!");
static_assert(offsetof(FGbxGFxListConfig, bAutoHideScrollBar) == 0x000010, "Member 'FGbxGFxListConfig::bAutoHideScrollBar' has a wrong offset!");
static_assert(offsetof(FGbxGFxListConfig, ScrollBarName) == 0x000018, "Member 'FGbxGFxListConfig::ScrollBarName' has a wrong offset!");
static_assert(offsetof(FGbxGFxListConfig, WrapMode) == 0x000028, "Member 'FGbxGFxListConfig::WrapMode' has a wrong offset!");
static_assert(offsetof(FGbxGFxListConfig, DefaultItemSelectionBehavior) == 0x000029, "Member 'FGbxGFxListConfig::DefaultItemSelectionBehavior' has a wrong offset!");
static_assert(offsetof(FGbxGFxListConfig, FocusChangeAction) == 0x00002A, "Member 'FGbxGFxListConfig::FocusChangeAction' has a wrong offset!");
static_assert(offsetof(FGbxGFxListConfig, bMustHaveOneFocusableCellToReceiveFocus) == 0x00002B, "Member 'FGbxGFxListConfig::bMustHaveOneFocusableCellToReceiveFocus' has a wrong offset!");
static_assert(offsetof(FGbxGFxListConfig, EntryPrefix) == 0x000030, "Member 'FGbxGFxListConfig::EntryPrefix' has a wrong offset!");
static_assert(offsetof(FGbxGFxListConfig, GridAreaName) == 0x000040, "Member 'FGbxGFxListConfig::GridAreaName' has a wrong offset!");
static_assert(offsetof(FGbxGFxListConfig, GridMaskName) == 0x000050, "Member 'FGbxGFxListConfig::GridMaskName' has a wrong offset!");
static_assert(offsetof(FGbxGFxListConfig, FocusOrderPriority) == 0x000060, "Member 'FGbxGFxListConfig::FocusOrderPriority' has a wrong offset!");
static_assert(offsetof(FGbxGFxListConfig, AddedItemPriority) == 0x000061, "Member 'FGbxGFxListConfig::AddedItemPriority' has a wrong offset!");
static_assert(offsetof(FGbxGFxListConfig, bUseFixedCellBounds) == 0x000062, "Member 'FGbxGFxListConfig::bUseFixedCellBounds' has a wrong offset!");
static_assert(offsetof(FGbxGFxListConfig, FixedCellBoundsDemensions) == 0x000064, "Member 'FGbxGFxListConfig::FixedCellBoundsDemensions' has a wrong offset!");
static_assert(offsetof(FGbxGFxListConfig, bMoveSelectionScrollIntoView) == 0x00006C, "Member 'FGbxGFxListConfig::bMoveSelectionScrollIntoView' has a wrong offset!");
static_assert(offsetof(FGbxGFxListConfig, bMoveSelectionAnimateScroll) == 0x00006D, "Member 'FGbxGFxListConfig::bMoveSelectionAnimateScroll' has a wrong offset!");
static_assert(offsetof(FGbxGFxListConfig, bKeepScrollbarOnTop) == 0x00006E, "Member 'FGbxGFxListConfig::bKeepScrollbarOnTop' has a wrong offset!");
static_assert(offsetof(FGbxGFxListConfig, bAlwaysConsumeDirectionInput) == 0x00006F, "Member 'FGbxGFxListConfig::bAlwaysConsumeDirectionInput' has a wrong offset!");
static_assert(offsetof(FGbxGFxListConfig, bAllowScrolling) == 0x000070, "Member 'FGbxGFxListConfig::bAllowScrolling' has a wrong offset!");
static_assert(offsetof(FGbxGFxListConfig, bReverseScrollDirection) == 0x000071, "Member 'FGbxGFxListConfig::bReverseScrollDirection' has a wrong offset!");
static_assert(offsetof(FGbxGFxListConfig, DefaultItemSelectedAudioEventName) == 0x000078, "Member 'FGbxGFxListConfig::DefaultItemSelectedAudioEventName' has a wrong offset!");
static_assert(offsetof(FGbxGFxListConfig, DefaultItemClickedAudioEventName) == 0x000080, "Member 'FGbxGFxListConfig::DefaultItemClickedAudioEventName' has a wrong offset!");
static_assert(offsetof(FGbxGFxListConfig, bCanBeNavigatedIfMouseDisabled) == 0x000088, "Member 'FGbxGFxListConfig::bCanBeNavigatedIfMouseDisabled' has a wrong offset!");
static_assert(offsetof(FGbxGFxListConfig, bFocusListIfCellGetsFocused) == 0x000089, "Member 'FGbxGFxListConfig::bFocusListIfCellGetsFocused' has a wrong offset!");

// ScriptStruct GbxUI.GbxFocusableWidgetAdjacencyInfo
// 0x0020 (0x0020 - 0x0000)
struct FGbxFocusableWidgetAdjacencyInfo final
{
public:
	TWeakObjectPtr<class UObject>                 WidgetUp;                                          // 0x0000(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TWeakObjectPtr<class UObject>                 WidgetDown;                                        // 0x0008(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TWeakObjectPtr<class UObject>                 WidgetLeft;                                        // 0x0010(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TWeakObjectPtr<class UObject>                 WidgetRight;                                       // 0x0018(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FGbxFocusableWidgetAdjacencyInfo) == 0x000004, "Wrong alignment on FGbxFocusableWidgetAdjacencyInfo");
static_assert(sizeof(FGbxFocusableWidgetAdjacencyInfo) == 0x000020, "Wrong size on FGbxFocusableWidgetAdjacencyInfo");
static_assert(offsetof(FGbxFocusableWidgetAdjacencyInfo, WidgetUp) == 0x000000, "Member 'FGbxFocusableWidgetAdjacencyInfo::WidgetUp' has a wrong offset!");
static_assert(offsetof(FGbxFocusableWidgetAdjacencyInfo, WidgetDown) == 0x000008, "Member 'FGbxFocusableWidgetAdjacencyInfo::WidgetDown' has a wrong offset!");
static_assert(offsetof(FGbxFocusableWidgetAdjacencyInfo, WidgetLeft) == 0x000010, "Member 'FGbxFocusableWidgetAdjacencyInfo::WidgetLeft' has a wrong offset!");
static_assert(offsetof(FGbxFocusableWidgetAdjacencyInfo, WidgetRight) == 0x000018, "Member 'FGbxFocusableWidgetAdjacencyInfo::WidgetRight' has a wrong offset!");

// ScriptStruct GbxUI.GbxGFxSliderAcceleration
// 0x0010 (0x0010 - 0x0000)
struct FGbxGFxSliderAcceleration final
{
public:
	int32                                         RepeatsNeededToAcclerate;                          // 0x0000(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         RepeatAdder;                                       // 0x0004(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         MaxIncreases;                                      // 0x0008(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         TimeToResetMouseWheelRepeat;                       // 0x000C(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FGbxGFxSliderAcceleration) == 0x000004, "Wrong alignment on FGbxGFxSliderAcceleration");
static_assert(sizeof(FGbxGFxSliderAcceleration) == 0x000010, "Wrong size on FGbxGFxSliderAcceleration");
static_assert(offsetof(FGbxGFxSliderAcceleration, RepeatsNeededToAcclerate) == 0x000000, "Member 'FGbxGFxSliderAcceleration::RepeatsNeededToAcclerate' has a wrong offset!");
static_assert(offsetof(FGbxGFxSliderAcceleration, RepeatAdder) == 0x000004, "Member 'FGbxGFxSliderAcceleration::RepeatAdder' has a wrong offset!");
static_assert(offsetof(FGbxGFxSliderAcceleration, MaxIncreases) == 0x000008, "Member 'FGbxGFxSliderAcceleration::MaxIncreases' has a wrong offset!");
static_assert(offsetof(FGbxGFxSliderAcceleration, TimeToResetMouseWheelRepeat) == 0x00000C, "Member 'FGbxGFxSliderAcceleration::TimeToResetMouseWheelRepeat' has a wrong offset!");

// ScriptStruct GbxUI.GbxHUDLayoutTableRow
// 0x0028 (0x0030 - 0x0008)
struct FGbxHUDLayoutTableRow final : public FTableRowBase
{
public:
	struct FVector2D                              AnchorPosition;                                    // 0x0008(0x0008)(Edit, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector2D                              Offset;                                            // 0x0010(0x0008)(Edit, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector2D                              Scale;                                             // 0x0018(0x0008)(Edit, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FString                                 LibraryMovieString;                                // 0x0020(0x0010)(Edit, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FGbxHUDLayoutTableRow) == 0x000008, "Wrong alignment on FGbxHUDLayoutTableRow");
static_assert(sizeof(FGbxHUDLayoutTableRow) == 0x000030, "Wrong size on FGbxHUDLayoutTableRow");
static_assert(offsetof(FGbxHUDLayoutTableRow, AnchorPosition) == 0x000008, "Member 'FGbxHUDLayoutTableRow::AnchorPosition' has a wrong offset!");
static_assert(offsetof(FGbxHUDLayoutTableRow, Offset) == 0x000010, "Member 'FGbxHUDLayoutTableRow::Offset' has a wrong offset!");
static_assert(offsetof(FGbxHUDLayoutTableRow, Scale) == 0x000018, "Member 'FGbxHUDLayoutTableRow::Scale' has a wrong offset!");
static_assert(offsetof(FGbxHUDLayoutTableRow, LibraryMovieString) == 0x000020, "Member 'FGbxHUDLayoutTableRow::LibraryMovieString' has a wrong offset!");

// ScriptStruct GbxUI.GbxProgressBarRange
// 0x0018 (0x0018 - 0x0000)
struct alignas(0x08) FGbxProgressBarRange final
{
public:
	class FName                                   Name;                                              // 0x0000(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         Min;                                               // 0x0008(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         Max;                                               // 0x000C(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bIncreasing;                                       // 0x0010(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bDecreasing;                                       // 0x0011(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_12[0x6];                                       // 0x0012(0x0006)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FGbxProgressBarRange) == 0x000008, "Wrong alignment on FGbxProgressBarRange");
static_assert(sizeof(FGbxProgressBarRange) == 0x000018, "Wrong size on FGbxProgressBarRange");
static_assert(offsetof(FGbxProgressBarRange, Name) == 0x000000, "Member 'FGbxProgressBarRange::Name' has a wrong offset!");
static_assert(offsetof(FGbxProgressBarRange, Min) == 0x000008, "Member 'FGbxProgressBarRange::Min' has a wrong offset!");
static_assert(offsetof(FGbxProgressBarRange, Max) == 0x00000C, "Member 'FGbxProgressBarRange::Max' has a wrong offset!");
static_assert(offsetof(FGbxProgressBarRange, bIncreasing) == 0x000010, "Member 'FGbxProgressBarRange::bIncreasing' has a wrong offset!");
static_assert(offsetof(FGbxProgressBarRange, bDecreasing) == 0x000011, "Member 'FGbxProgressBarRange::bDecreasing' has a wrong offset!");

// ScriptStruct GbxUI.GbxHUDStateManager
// 0x0040 (0x0040 - 0x0000)
struct FGbxHUDStateManager final
{
public:
	UMulticastDelegateProperty_                   OnStateChanged;                                    // 0x0000(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	TArray<class UGbxHUDStateData*>               StateStack;                                        // 0x0010(0x0010)(ZeroConstructor, Transient, NativeAccessSpecifierPublic)
	uint8                                         Pad_20[0x8];                                       // 0x0020(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<class UGbxGFxHUDWidget*>               Widgets;                                           // 0x0028(0x0010)(ZeroConstructor, Transient, NativeAccessSpecifierPublic)
	uint8                                         Pad_38[0x8];                                       // 0x0038(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FGbxHUDStateManager) == 0x000008, "Wrong alignment on FGbxHUDStateManager");
static_assert(sizeof(FGbxHUDStateManager) == 0x000040, "Wrong size on FGbxHUDStateManager");
static_assert(offsetof(FGbxHUDStateManager, OnStateChanged) == 0x000000, "Member 'FGbxHUDStateManager::OnStateChanged' has a wrong offset!");
static_assert(offsetof(FGbxHUDStateManager, StateStack) == 0x000010, "Member 'FGbxHUDStateManager::StateStack' has a wrong offset!");
static_assert(offsetof(FGbxHUDStateManager, Widgets) == 0x000028, "Member 'FGbxHUDStateManager::Widgets' has a wrong offset!");

// ScriptStruct GbxUI.TextDebugData
// 0x0030 (0x0030 - 0x0000)
struct FTextDebugData final
{
public:
	class FText                                   DisplayText;                                       // 0x0000(0x0018)(Edit, NativeAccessSpecifierPublic)
	float                                         DisplayTime;                                       // 0x0018(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         DisplaySize;                                       // 0x001C(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FLinearColor                           DisplayColor;                                      // 0x0020(0x0010)(Edit, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FTextDebugData) == 0x000008, "Wrong alignment on FTextDebugData");
static_assert(sizeof(FTextDebugData) == 0x000030, "Wrong size on FTextDebugData");
static_assert(offsetof(FTextDebugData, DisplayText) == 0x000000, "Member 'FTextDebugData::DisplayText' has a wrong offset!");
static_assert(offsetof(FTextDebugData, DisplayTime) == 0x000018, "Member 'FTextDebugData::DisplayTime' has a wrong offset!");
static_assert(offsetof(FTextDebugData, DisplaySize) == 0x00001C, "Member 'FTextDebugData::DisplaySize' has a wrong offset!");
static_assert(offsetof(FTextDebugData, DisplayColor) == 0x000020, "Member 'FTextDebugData::DisplayColor' has a wrong offset!");

// ScriptStruct GbxUI.GbxGFxHUDWidgetInfo
// 0x0020 (0x0020 - 0x0000)
struct FGbxGFxHUDWidgetInfo final
{
public:
	TSubclassOf<class UGbxGFxHUDWidget>           WidgetClass;                                       // 0x0000(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FString                                 InstanceString;                                    // 0x0008(0x0010)(Edit, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Priority;                                          // 0x0018(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_19[0x7];                                       // 0x0019(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FGbxGFxHUDWidgetInfo) == 0x000008, "Wrong alignment on FGbxGFxHUDWidgetInfo");
static_assert(sizeof(FGbxGFxHUDWidgetInfo) == 0x000020, "Wrong size on FGbxGFxHUDWidgetInfo");
static_assert(offsetof(FGbxGFxHUDWidgetInfo, WidgetClass) == 0x000000, "Member 'FGbxGFxHUDWidgetInfo::WidgetClass' has a wrong offset!");
static_assert(offsetof(FGbxGFxHUDWidgetInfo, InstanceString) == 0x000008, "Member 'FGbxGFxHUDWidgetInfo::InstanceString' has a wrong offset!");
static_assert(offsetof(FGbxGFxHUDWidgetInfo, Priority) == 0x000018, "Member 'FGbxGFxHUDWidgetInfo::Priority' has a wrong offset!");

// ScriptStruct GbxUI.GbxGFxPooledGridListConfig
// 0x0030 (0x0030 - 0x0000)
struct FGbxGFxPooledGridListConfig final
{
public:
	TSubclassOf<class UGbxGFxListCell>            ItemNativeClass;                                   // 0x0000(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FString                                 ItemASClass;                                       // 0x0008(0x0010)(Edit, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector2D                              ItemSize;                                          // 0x0018(0x0008)(Edit, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector2D                              ItemRootOffset;                                    // 0x0020(0x0008)(Edit, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         VisibleRows;                                       // 0x0028(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         VisibleCols;                                       // 0x002C(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FGbxGFxPooledGridListConfig) == 0x000008, "Wrong alignment on FGbxGFxPooledGridListConfig");
static_assert(sizeof(FGbxGFxPooledGridListConfig) == 0x000030, "Wrong size on FGbxGFxPooledGridListConfig");
static_assert(offsetof(FGbxGFxPooledGridListConfig, ItemNativeClass) == 0x000000, "Member 'FGbxGFxPooledGridListConfig::ItemNativeClass' has a wrong offset!");
static_assert(offsetof(FGbxGFxPooledGridListConfig, ItemASClass) == 0x000008, "Member 'FGbxGFxPooledGridListConfig::ItemASClass' has a wrong offset!");
static_assert(offsetof(FGbxGFxPooledGridListConfig, ItemSize) == 0x000018, "Member 'FGbxGFxPooledGridListConfig::ItemSize' has a wrong offset!");
static_assert(offsetof(FGbxGFxPooledGridListConfig, ItemRootOffset) == 0x000020, "Member 'FGbxGFxPooledGridListConfig::ItemRootOffset' has a wrong offset!");
static_assert(offsetof(FGbxGFxPooledGridListConfig, VisibleRows) == 0x000028, "Member 'FGbxGFxPooledGridListConfig::VisibleRows' has a wrong offset!");
static_assert(offsetof(FGbxGFxPooledGridListConfig, VisibleCols) == 0x00002C, "Member 'FGbxGFxPooledGridListConfig::VisibleCols' has a wrong offset!");

// ScriptStruct GbxUI.GbxGFxPooledGridListFullConfig
// 0x00C0 (0x00C0 - 0x0000)
struct FGbxGFxPooledGridListFullConfig final
{
public:
	struct FGbxGFxListConfig                      BaseListConfig;                                    // 0x0000(0x0090)(Edit, NativeAccessSpecifierPublic)
	struct FGbxGFxPooledGridListConfig            PoolListConfig;                                    // 0x0090(0x0030)(Edit, NativeAccessSpecifierPublic)
};
static_assert(alignof(FGbxGFxPooledGridListFullConfig) == 0x000008, "Wrong alignment on FGbxGFxPooledGridListFullConfig");
static_assert(sizeof(FGbxGFxPooledGridListFullConfig) == 0x0000C0, "Wrong size on FGbxGFxPooledGridListFullConfig");
static_assert(offsetof(FGbxGFxPooledGridListFullConfig, BaseListConfig) == 0x000000, "Member 'FGbxGFxPooledGridListFullConfig::BaseListConfig' has a wrong offset!");
static_assert(offsetof(FGbxGFxPooledGridListFullConfig, PoolListConfig) == 0x000090, "Member 'FGbxGFxPooledGridListFullConfig::PoolListConfig' has a wrong offset!");

// ScriptStruct GbxUI.GbxGFxAnchor
// 0x0018 (0x0018 - 0x0000)
struct FGbxGFxAnchor final
{
public:
	struct FVector2D                              NormalizedPosition;                                // 0x0000(0x0008)(Edit, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector2D                              Offset;                                            // 0x0008(0x0008)(Edit, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector2D                              Scale;                                             // 0x0010(0x0008)(Edit, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FGbxGFxAnchor) == 0x000004, "Wrong alignment on FGbxGFxAnchor");
static_assert(sizeof(FGbxGFxAnchor) == 0x000018, "Wrong size on FGbxGFxAnchor");
static_assert(offsetof(FGbxGFxAnchor, NormalizedPosition) == 0x000000, "Member 'FGbxGFxAnchor::NormalizedPosition' has a wrong offset!");
static_assert(offsetof(FGbxGFxAnchor, Offset) == 0x000008, "Member 'FGbxGFxAnchor::Offset' has a wrong offset!");
static_assert(offsetof(FGbxGFxAnchor, Scale) == 0x000010, "Member 'FGbxGFxAnchor::Scale' has a wrong offset!");

// ScriptStruct GbxUI.GbxGFxmovieClipAppendixItem
// 0x0010 (0x0010 - 0x0000)
struct FGbxGFxmovieClipAppendixItem final
{
public:
	TArray<class FString>                         ClipPaths;                                         // 0x0000(0x0010)(Edit, ZeroConstructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(FGbxGFxmovieClipAppendixItem) == 0x000008, "Wrong alignment on FGbxGFxmovieClipAppendixItem");
static_assert(sizeof(FGbxGFxmovieClipAppendixItem) == 0x000010, "Wrong size on FGbxGFxmovieClipAppendixItem");
static_assert(offsetof(FGbxGFxmovieClipAppendixItem, ClipPaths) == 0x000000, "Member 'FGbxGFxmovieClipAppendixItem::ClipPaths' has a wrong offset!");

// ScriptStruct GbxUI.GbxGFxMovieClipAppendix
// 0x0060 (0x0060 - 0x0000)
struct FGbxGFxMovieClipAppendix final
{
public:
	struct FGbxGFxmovieClipAppendixItem           DefaultRetVal;                                     // 0x0000(0x0010)(Transient, NativeAccessSpecifierPublic)
	TMap<class FString, struct FGbxGFxmovieClipAppendixItem> AppendixMap;                                       // 0x0010(0x0050)(Edit, ZeroConstructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(FGbxGFxMovieClipAppendix) == 0x000008, "Wrong alignment on FGbxGFxMovieClipAppendix");
static_assert(sizeof(FGbxGFxMovieClipAppendix) == 0x000060, "Wrong size on FGbxGFxMovieClipAppendix");
static_assert(offsetof(FGbxGFxMovieClipAppendix, DefaultRetVal) == 0x000000, "Member 'FGbxGFxMovieClipAppendix::DefaultRetVal' has a wrong offset!");
static_assert(offsetof(FGbxGFxMovieClipAppendix, AppendixMap) == 0x000010, "Member 'FGbxGFxMovieClipAppendix::AppendixMap' has a wrong offset!");

// ScriptStruct GbxUI.GbxInputToGlyphSpecialActionItem
// 0x0508 (0x0508 - 0x0000)
struct FGbxInputToGlyphSpecialActionItem final
{
public:
	class FName                                   InputAction;                                       // 0x0000(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FText                                   KeyboardMouseGlyph;                                // 0x0008(0x0018)(Edit, NativeAccessSpecifierPublic)
	class FText                                   PS4Glyph;                                          // 0x0020(0x0018)(Edit, NativeAccessSpecifierPublic)
	class FText                                   XboxOneGlyph;                                      // 0x0038(0x0018)(Edit, NativeAccessSpecifierPublic)
	class FText                                   DPXGlyph;                                          // 0x0050(0x0018)(Edit, NativeAccessSpecifierPublic)
	class FText                                   MPXGlyph;                                          // 0x0068(0x0018)(Edit, NativeAccessSpecifierPublic)
	class FText                                   GenericGamepadGlyph;                               // 0x0080(0x0018)(Edit, NativeAccessSpecifierPublic)
	class FText                                   SwitchProGlyph;                                    // 0x0098(0x0018)(Edit, NativeAccessSpecifierPublic)
	class FText                                   StadiaGlyph;                                       // 0x00B0(0x0018)(Edit, NativeAccessSpecifierPublic)
	struct FSlateBrush                            KeyboardMouseGlyphBrush;                           // 0x00C8(0x0088)(Edit, NativeAccessSpecifierPublic)
	struct FSlateBrush                            PS4GlyphBrush;                                     // 0x0150(0x0088)(Edit, NativeAccessSpecifierPublic)
	struct FSlateBrush                            XboxOneGlyphBrush;                                 // 0x01D8(0x0088)(Edit, NativeAccessSpecifierPublic)
	struct FSlateBrush                            DPXGlyphBrush;                                     // 0x0260(0x0088)(Edit, NativeAccessSpecifierPublic)
	struct FSlateBrush                            MPXGlyphBrush;                                     // 0x02E8(0x0088)(Edit, NativeAccessSpecifierPublic)
	struct FSlateBrush                            GenericGamepadGlyphBrush;                          // 0x0370(0x0088)(Edit, NativeAccessSpecifierPublic)
	struct FSlateBrush                            SwitchProGlyphBrush;                               // 0x03F8(0x0088)(Edit, NativeAccessSpecifierPublic)
	struct FSlateBrush                            StadiaGlyphBrush;                                  // 0x0480(0x0088)(Edit, NativeAccessSpecifierPublic)
};
static_assert(alignof(FGbxInputToGlyphSpecialActionItem) == 0x000008, "Wrong alignment on FGbxInputToGlyphSpecialActionItem");
static_assert(sizeof(FGbxInputToGlyphSpecialActionItem) == 0x000508, "Wrong size on FGbxInputToGlyphSpecialActionItem");
static_assert(offsetof(FGbxInputToGlyphSpecialActionItem, InputAction) == 0x000000, "Member 'FGbxInputToGlyphSpecialActionItem::InputAction' has a wrong offset!");
static_assert(offsetof(FGbxInputToGlyphSpecialActionItem, KeyboardMouseGlyph) == 0x000008, "Member 'FGbxInputToGlyphSpecialActionItem::KeyboardMouseGlyph' has a wrong offset!");
static_assert(offsetof(FGbxInputToGlyphSpecialActionItem, PS4Glyph) == 0x000020, "Member 'FGbxInputToGlyphSpecialActionItem::PS4Glyph' has a wrong offset!");
static_assert(offsetof(FGbxInputToGlyphSpecialActionItem, XboxOneGlyph) == 0x000038, "Member 'FGbxInputToGlyphSpecialActionItem::XboxOneGlyph' has a wrong offset!");
static_assert(offsetof(FGbxInputToGlyphSpecialActionItem, DPXGlyph) == 0x000050, "Member 'FGbxInputToGlyphSpecialActionItem::DPXGlyph' has a wrong offset!");
static_assert(offsetof(FGbxInputToGlyphSpecialActionItem, MPXGlyph) == 0x000068, "Member 'FGbxInputToGlyphSpecialActionItem::MPXGlyph' has a wrong offset!");
static_assert(offsetof(FGbxInputToGlyphSpecialActionItem, GenericGamepadGlyph) == 0x000080, "Member 'FGbxInputToGlyphSpecialActionItem::GenericGamepadGlyph' has a wrong offset!");
static_assert(offsetof(FGbxInputToGlyphSpecialActionItem, SwitchProGlyph) == 0x000098, "Member 'FGbxInputToGlyphSpecialActionItem::SwitchProGlyph' has a wrong offset!");
static_assert(offsetof(FGbxInputToGlyphSpecialActionItem, StadiaGlyph) == 0x0000B0, "Member 'FGbxInputToGlyphSpecialActionItem::StadiaGlyph' has a wrong offset!");
static_assert(offsetof(FGbxInputToGlyphSpecialActionItem, KeyboardMouseGlyphBrush) == 0x0000C8, "Member 'FGbxInputToGlyphSpecialActionItem::KeyboardMouseGlyphBrush' has a wrong offset!");
static_assert(offsetof(FGbxInputToGlyphSpecialActionItem, PS4GlyphBrush) == 0x000150, "Member 'FGbxInputToGlyphSpecialActionItem::PS4GlyphBrush' has a wrong offset!");
static_assert(offsetof(FGbxInputToGlyphSpecialActionItem, XboxOneGlyphBrush) == 0x0001D8, "Member 'FGbxInputToGlyphSpecialActionItem::XboxOneGlyphBrush' has a wrong offset!");
static_assert(offsetof(FGbxInputToGlyphSpecialActionItem, DPXGlyphBrush) == 0x000260, "Member 'FGbxInputToGlyphSpecialActionItem::DPXGlyphBrush' has a wrong offset!");
static_assert(offsetof(FGbxInputToGlyphSpecialActionItem, MPXGlyphBrush) == 0x0002E8, "Member 'FGbxInputToGlyphSpecialActionItem::MPXGlyphBrush' has a wrong offset!");
static_assert(offsetof(FGbxInputToGlyphSpecialActionItem, GenericGamepadGlyphBrush) == 0x000370, "Member 'FGbxInputToGlyphSpecialActionItem::GenericGamepadGlyphBrush' has a wrong offset!");
static_assert(offsetof(FGbxInputToGlyphSpecialActionItem, SwitchProGlyphBrush) == 0x0003F8, "Member 'FGbxInputToGlyphSpecialActionItem::SwitchProGlyphBrush' has a wrong offset!");
static_assert(offsetof(FGbxInputToGlyphSpecialActionItem, StadiaGlyphBrush) == 0x000480, "Member 'FGbxInputToGlyphSpecialActionItem::StadiaGlyphBrush' has a wrong offset!");

// ScriptStruct GbxUI.GbxFocusableWidgetAdjacencyNames
// 0x0040 (0x0040 - 0x0000)
struct FGbxFocusableWidgetAdjacencyNames final
{
public:
	class FString                                 WidgetUpName;                                      // 0x0000(0x0010)(Edit, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FString                                 WidgetDownName;                                    // 0x0010(0x0010)(Edit, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FString                                 WidgetLeftName;                                    // 0x0020(0x0010)(Edit, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FString                                 WidgetRightName;                                   // 0x0030(0x0010)(Edit, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FGbxFocusableWidgetAdjacencyNames) == 0x000008, "Wrong alignment on FGbxFocusableWidgetAdjacencyNames");
static_assert(sizeof(FGbxFocusableWidgetAdjacencyNames) == 0x000040, "Wrong size on FGbxFocusableWidgetAdjacencyNames");
static_assert(offsetof(FGbxFocusableWidgetAdjacencyNames, WidgetUpName) == 0x000000, "Member 'FGbxFocusableWidgetAdjacencyNames::WidgetUpName' has a wrong offset!");
static_assert(offsetof(FGbxFocusableWidgetAdjacencyNames, WidgetDownName) == 0x000010, "Member 'FGbxFocusableWidgetAdjacencyNames::WidgetDownName' has a wrong offset!");
static_assert(offsetof(FGbxFocusableWidgetAdjacencyNames, WidgetLeftName) == 0x000020, "Member 'FGbxFocusableWidgetAdjacencyNames::WidgetLeftName' has a wrong offset!");
static_assert(offsetof(FGbxFocusableWidgetAdjacencyNames, WidgetRightName) == 0x000030, "Member 'FGbxFocusableWidgetAdjacencyNames::WidgetRightName' has a wrong offset!");

// ScriptStruct GbxUI.GbxDialogBoxTemplateMapItem
// 0x0010 (0x0010 - 0x0000)
struct FGbxDialogBoxTemplateMapItem final
{
public:
	class FName                                   NameId;                                            // 0x0000(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TSubclassOf<class UGbxDialogBox>              DialogClass;                                       // 0x0008(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FGbxDialogBoxTemplateMapItem) == 0x000008, "Wrong alignment on FGbxDialogBoxTemplateMapItem");
static_assert(sizeof(FGbxDialogBoxTemplateMapItem) == 0x000010, "Wrong size on FGbxDialogBoxTemplateMapItem");
static_assert(offsetof(FGbxDialogBoxTemplateMapItem, NameId) == 0x000000, "Member 'FGbxDialogBoxTemplateMapItem::NameId' has a wrong offset!");
static_assert(offsetof(FGbxDialogBoxTemplateMapItem, DialogClass) == 0x000008, "Member 'FGbxDialogBoxTemplateMapItem::DialogClass' has a wrong offset!");

// ScriptStruct GbxUI.GbxDialogBoxInfo
// 0x0060 (0x0060 - 0x0000)
struct FGbxDialogBoxInfo final
{
public:
	class FText                                   HeaderText;                                        // 0x0000(0x0018)(BlueprintVisible, NativeAccessSpecifierPublic)
	class FText                                   BodyText;                                          // 0x0018(0x0018)(BlueprintVisible, NativeAccessSpecifierPublic)
	TArray<struct FGbxDialogBoxChoiceInfo>        Choices;                                           // 0x0030(0x0010)(BlueprintVisible, ZeroConstructor, NativeAccessSpecifierPublic)
	bool                                          bCanCancel;                                        // 0x0040(0x0001)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bAnyUserCanInteract;                               // 0x0041(0x0001)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_42[0x6];                                       // 0x0042(0x0006)(Fixing Size After Last Property [ Dumper-7 ])
	TDelegate<void(class UGbxDialogBox* SourceDialog, class FName ChoiceNameId)> OnChoiceMadeDelegate;                              // 0x0048(0x0010)(BlueprintVisible, ZeroConstructor, InstancedReference, NoDestructor, NativeAccessSpecifierPublic)
	class FName                                   TemplateNameId;                                    // 0x0058(0x0008)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FGbxDialogBoxInfo) == 0x000008, "Wrong alignment on FGbxDialogBoxInfo");
static_assert(sizeof(FGbxDialogBoxInfo) == 0x000060, "Wrong size on FGbxDialogBoxInfo");
static_assert(offsetof(FGbxDialogBoxInfo, HeaderText) == 0x000000, "Member 'FGbxDialogBoxInfo::HeaderText' has a wrong offset!");
static_assert(offsetof(FGbxDialogBoxInfo, BodyText) == 0x000018, "Member 'FGbxDialogBoxInfo::BodyText' has a wrong offset!");
static_assert(offsetof(FGbxDialogBoxInfo, Choices) == 0x000030, "Member 'FGbxDialogBoxInfo::Choices' has a wrong offset!");
static_assert(offsetof(FGbxDialogBoxInfo, bCanCancel) == 0x000040, "Member 'FGbxDialogBoxInfo::bCanCancel' has a wrong offset!");
static_assert(offsetof(FGbxDialogBoxInfo, bAnyUserCanInteract) == 0x000041, "Member 'FGbxDialogBoxInfo::bAnyUserCanInteract' has a wrong offset!");
static_assert(offsetof(FGbxDialogBoxInfo, OnChoiceMadeDelegate) == 0x000048, "Member 'FGbxDialogBoxInfo::OnChoiceMadeDelegate' has a wrong offset!");
static_assert(offsetof(FGbxDialogBoxInfo, TemplateNameId) == 0x000058, "Member 'FGbxDialogBoxInfo::TemplateNameId' has a wrong offset!");

// ScriptStruct GbxUI.GbxDLCMenuSplitscreenLayouts
// 0x0080 (0x0080 - 0x0000)
struct FGbxDLCMenuSplitscreenLayouts final
{
public:
	TSoftClassPtr<class UClass>                   VerticalLayout;                                    // 0x0000(0x0028)(Edit, Transient, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TSoftClassPtr<class UClass>                   QuarterLayout;                                     // 0x0028(0x0028)(Edit, Transient, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FSoftObjectPath                        SoftVerticalLayout;                                // 0x0050(0x0018)(HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FSoftObjectPath                        SoftQuarterLayout;                                 // 0x0068(0x0018)(HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FGbxDLCMenuSplitscreenLayouts) == 0x000008, "Wrong alignment on FGbxDLCMenuSplitscreenLayouts");
static_assert(sizeof(FGbxDLCMenuSplitscreenLayouts) == 0x000080, "Wrong size on FGbxDLCMenuSplitscreenLayouts");
static_assert(offsetof(FGbxDLCMenuSplitscreenLayouts, VerticalLayout) == 0x000000, "Member 'FGbxDLCMenuSplitscreenLayouts::VerticalLayout' has a wrong offset!");
static_assert(offsetof(FGbxDLCMenuSplitscreenLayouts, QuarterLayout) == 0x000028, "Member 'FGbxDLCMenuSplitscreenLayouts::QuarterLayout' has a wrong offset!");
static_assert(offsetof(FGbxDLCMenuSplitscreenLayouts, SoftVerticalLayout) == 0x000050, "Member 'FGbxDLCMenuSplitscreenLayouts::SoftVerticalLayout' has a wrong offset!");
static_assert(offsetof(FGbxDLCMenuSplitscreenLayouts, SoftQuarterLayout) == 0x000068, "Member 'FGbxDLCMenuSplitscreenLayouts::SoftQuarterLayout' has a wrong offset!");

// ScriptStruct GbxUI.GbxFocusableWidgetItemStyle
// 0x00C0 (0x00C0 - 0x0000)
struct FGbxFocusableWidgetItemStyle final
{
public:
	EGbxFocusableWidgetState                      State;                                             // 0x0000(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bUseTextColor;                                     // 0x0001(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bUseTextSize;                                      // 0x0002(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bUseIndicatorBrush;                                // 0x0003(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_4[0x4];                                        // 0x0004(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	struct FSlateColor                            TextColor;                                         // 0x0008(0x0028)(Edit, NativeAccessSpecifierPublic)
	int32                                         TextSize;                                          // 0x0030(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_34[0x4];                                       // 0x0034(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	struct FSlateBrush                            IndicatorBrush;                                    // 0x0038(0x0088)(Edit, NativeAccessSpecifierPublic)
};
static_assert(alignof(FGbxFocusableWidgetItemStyle) == 0x000008, "Wrong alignment on FGbxFocusableWidgetItemStyle");
static_assert(sizeof(FGbxFocusableWidgetItemStyle) == 0x0000C0, "Wrong size on FGbxFocusableWidgetItemStyle");
static_assert(offsetof(FGbxFocusableWidgetItemStyle, State) == 0x000000, "Member 'FGbxFocusableWidgetItemStyle::State' has a wrong offset!");
static_assert(offsetof(FGbxFocusableWidgetItemStyle, bUseTextColor) == 0x000001, "Member 'FGbxFocusableWidgetItemStyle::bUseTextColor' has a wrong offset!");
static_assert(offsetof(FGbxFocusableWidgetItemStyle, bUseTextSize) == 0x000002, "Member 'FGbxFocusableWidgetItemStyle::bUseTextSize' has a wrong offset!");
static_assert(offsetof(FGbxFocusableWidgetItemStyle, bUseIndicatorBrush) == 0x000003, "Member 'FGbxFocusableWidgetItemStyle::bUseIndicatorBrush' has a wrong offset!");
static_assert(offsetof(FGbxFocusableWidgetItemStyle, TextColor) == 0x000008, "Member 'FGbxFocusableWidgetItemStyle::TextColor' has a wrong offset!");
static_assert(offsetof(FGbxFocusableWidgetItemStyle, TextSize) == 0x000030, "Member 'FGbxFocusableWidgetItemStyle::TextSize' has a wrong offset!");
static_assert(offsetof(FGbxFocusableWidgetItemStyle, IndicatorBrush) == 0x000038, "Member 'FGbxFocusableWidgetItemStyle::IndicatorBrush' has a wrong offset!");

// ScriptStruct GbxUI.GbxGFxContextualMenuLocTableData
// 0x0030 (0x0030 - 0x0000)
struct FGbxGFxContextualMenuLocTableData final
{
public:
	EContextualMenuEntryType                      Type;                                              // 0x0000(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1[0x7];                                        // 0x0001(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	class FText                                   ItemText;                                          // 0x0008(0x0018)(Edit, NativeAccessSpecifierPublic)
	class FString                                 FrameString;                                       // 0x0020(0x0010)(Edit, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FGbxGFxContextualMenuLocTableData) == 0x000008, "Wrong alignment on FGbxGFxContextualMenuLocTableData");
static_assert(sizeof(FGbxGFxContextualMenuLocTableData) == 0x000030, "Wrong size on FGbxGFxContextualMenuLocTableData");
static_assert(offsetof(FGbxGFxContextualMenuLocTableData, Type) == 0x000000, "Member 'FGbxGFxContextualMenuLocTableData::Type' has a wrong offset!");
static_assert(offsetof(FGbxGFxContextualMenuLocTableData, ItemText) == 0x000008, "Member 'FGbxGFxContextualMenuLocTableData::ItemText' has a wrong offset!");
static_assert(offsetof(FGbxGFxContextualMenuLocTableData, FrameString) == 0x000020, "Member 'FGbxGFxContextualMenuLocTableData::FrameString' has a wrong offset!");

// ScriptStruct GbxUI.GbxFocusableWidgetInfo
// 0x0028 (0x0028 - 0x0000)
struct FGbxFocusableWidgetInfo final
{
public:
	TWeakObjectPtr<class UObject>                 Widget;                                            // 0x0000(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FGbxFocusableWidgetAdjacencyInfo       AdjacencyInfo;                                     // 0x0008(0x0020)(NoDestructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(FGbxFocusableWidgetInfo) == 0x000004, "Wrong alignment on FGbxFocusableWidgetInfo");
static_assert(sizeof(FGbxFocusableWidgetInfo) == 0x000028, "Wrong size on FGbxFocusableWidgetInfo");
static_assert(offsetof(FGbxFocusableWidgetInfo, Widget) == 0x000000, "Member 'FGbxFocusableWidgetInfo::Widget' has a wrong offset!");
static_assert(offsetof(FGbxFocusableWidgetInfo, AdjacencyInfo) == 0x000008, "Member 'FGbxFocusableWidgetInfo::AdjacencyInfo' has a wrong offset!");

// ScriptStruct GbxUI.ContextualMenuInfo
// 0x0080 (0x0080 - 0x0000)
struct alignas(0x08) FContextualMenuInfo final
{
public:
	uint8                                         Pad_0[0x80];                                       // 0x0000(0x0080)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FContextualMenuInfo) == 0x000008, "Wrong alignment on FContextualMenuInfo");
static_assert(sizeof(FContextualMenuInfo) == 0x000080, "Wrong size on FContextualMenuInfo");

// ScriptStruct GbxUI.ContextualMenuEntryInfo
// 0x0020 (0x0020 - 0x0000)
struct alignas(0x08) FContextualMenuEntryInfo final
{
public:
	uint8                                         Pad_0[0x20];                                       // 0x0000(0x0020)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FContextualMenuEntryInfo) == 0x000008, "Wrong alignment on FContextualMenuEntryInfo");
static_assert(sizeof(FContextualMenuEntryInfo) == 0x000020, "Wrong size on FContextualMenuEntryInfo");

// ScriptStruct GbxUI.GbxScrollingListCellInfo
// 0x0020 (0x0020 - 0x0000)
struct FGbxScrollingListCellInfo final
{
public:
	class FString                                 LibraryName;                                       // 0x0000(0x0010)(ZeroConstructor, Transient, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TSubclassOf<class UGbxGFxListCell>            CellClass;                                         // 0x0010(0x0008)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UGbxGFxListCell*                        Cell;                                              // 0x0018(0x0008)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FGbxScrollingListCellInfo) == 0x000008, "Wrong alignment on FGbxScrollingListCellInfo");
static_assert(sizeof(FGbxScrollingListCellInfo) == 0x000020, "Wrong size on FGbxScrollingListCellInfo");
static_assert(offsetof(FGbxScrollingListCellInfo, LibraryName) == 0x000000, "Member 'FGbxScrollingListCellInfo::LibraryName' has a wrong offset!");
static_assert(offsetof(FGbxScrollingListCellInfo, CellClass) == 0x000010, "Member 'FGbxScrollingListCellInfo::CellClass' has a wrong offset!");
static_assert(offsetof(FGbxScrollingListCellInfo, Cell) == 0x000018, "Member 'FGbxScrollingListCellInfo::Cell' has a wrong offset!");

// ScriptStruct GbxUI.GbxMenuInputRawMousePos
// 0x0018 (0x0018 - 0x0000)
struct FGbxMenuInputRawMousePos final
{
public:
	struct FVector2D                              PrevMousePos;                                      // 0x0000(0x0008)(Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector2D                              NewMousePos;                                       // 0x0008(0x0008)(Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         ControllerId;                                      // 0x0010(0x0004)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         IgnoreMouseMoveFrames;                             // 0x0014(0x0004)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FGbxMenuInputRawMousePos) == 0x000004, "Wrong alignment on FGbxMenuInputRawMousePos");
static_assert(sizeof(FGbxMenuInputRawMousePos) == 0x000018, "Wrong size on FGbxMenuInputRawMousePos");
static_assert(offsetof(FGbxMenuInputRawMousePos, PrevMousePos) == 0x000000, "Member 'FGbxMenuInputRawMousePos::PrevMousePos' has a wrong offset!");
static_assert(offsetof(FGbxMenuInputRawMousePos, NewMousePos) == 0x000008, "Member 'FGbxMenuInputRawMousePos::NewMousePos' has a wrong offset!");
static_assert(offsetof(FGbxMenuInputRawMousePos, ControllerId) == 0x000010, "Member 'FGbxMenuInputRawMousePos::ControllerId' has a wrong offset!");
static_assert(offsetof(FGbxMenuInputRawMousePos, IgnoreMouseMoveFrames) == 0x000014, "Member 'FGbxMenuInputRawMousePos::IgnoreMouseMoveFrames' has a wrong offset!");

// ScriptStruct GbxUI.GbxGFxMenuSwitcherSubmenuInfo
// 0x0058 (0x0058 - 0x0000)
struct FGbxGFxMenuSwitcherSubmenuInfo final
{
public:
	class FName                                   MenuID;                                            // 0x0000(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FText                                   MenuName;                                          // 0x0008(0x0018)(Edit, NativeAccessSpecifierPublic)
	class FText                                   MenuDescription;                                   // 0x0020(0x0018)(Edit, NativeAccessSpecifierPublic)
	class UGbxGFxMenuData*                        MenuData;                                          // 0x0038(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UGbxGFxMenuData*                        MenuData_NoCrossplay;                              // 0x0040(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TSubclassOf<class UGbxGFxMenuSwitcherSubmenu> MenuClass;                                         // 0x0048(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bAddToNav;                                         // 0x0050(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_51[0x7];                                       // 0x0051(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FGbxGFxMenuSwitcherSubmenuInfo) == 0x000008, "Wrong alignment on FGbxGFxMenuSwitcherSubmenuInfo");
static_assert(sizeof(FGbxGFxMenuSwitcherSubmenuInfo) == 0x000058, "Wrong size on FGbxGFxMenuSwitcherSubmenuInfo");
static_assert(offsetof(FGbxGFxMenuSwitcherSubmenuInfo, MenuID) == 0x000000, "Member 'FGbxGFxMenuSwitcherSubmenuInfo::MenuID' has a wrong offset!");
static_assert(offsetof(FGbxGFxMenuSwitcherSubmenuInfo, MenuName) == 0x000008, "Member 'FGbxGFxMenuSwitcherSubmenuInfo::MenuName' has a wrong offset!");
static_assert(offsetof(FGbxGFxMenuSwitcherSubmenuInfo, MenuDescription) == 0x000020, "Member 'FGbxGFxMenuSwitcherSubmenuInfo::MenuDescription' has a wrong offset!");
static_assert(offsetof(FGbxGFxMenuSwitcherSubmenuInfo, MenuData) == 0x000038, "Member 'FGbxGFxMenuSwitcherSubmenuInfo::MenuData' has a wrong offset!");
static_assert(offsetof(FGbxGFxMenuSwitcherSubmenuInfo, MenuData_NoCrossplay) == 0x000040, "Member 'FGbxGFxMenuSwitcherSubmenuInfo::MenuData_NoCrossplay' has a wrong offset!");
static_assert(offsetof(FGbxGFxMenuSwitcherSubmenuInfo, MenuClass) == 0x000048, "Member 'FGbxGFxMenuSwitcherSubmenuInfo::MenuClass' has a wrong offset!");
static_assert(offsetof(FGbxGFxMenuSwitcherSubmenuInfo, bAddToNav) == 0x000050, "Member 'FGbxGFxMenuSwitcherSubmenuInfo::bAddToNav' has a wrong offset!");

// ScriptStruct GbxUI.GbxMenuAxisInputEvent
// 0x0028 (0x0028 - 0x0000)
struct alignas(0x08) FGbxMenuAxisInputEvent final
{
public:
	uint8                                         Pad_0[0x28];                                       // 0x0000(0x0028)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FGbxMenuAxisInputEvent) == 0x000008, "Wrong alignment on FGbxMenuAxisInputEvent");
static_assert(sizeof(FGbxMenuAxisInputEvent) == 0x000028, "Wrong size on FGbxMenuAxisInputEvent");

// ScriptStruct GbxUI.UIEventAudioPairRow
// 0x0008 (0x0010 - 0x0008)
struct FUIEventAudioPairRow final : public FTableRowBase
{
public:
	class UWwiseEvent*                            WwiseSound;                                        // 0x0008(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FUIEventAudioPairRow) == 0x000008, "Wrong alignment on FUIEventAudioPairRow");
static_assert(sizeof(FUIEventAudioPairRow) == 0x000010, "Wrong size on FUIEventAudioPairRow");
static_assert(offsetof(FUIEventAudioPairRow, WwiseSound) == 0x000008, "Member 'FUIEventAudioPairRow::WwiseSound' has a wrong offset!");

// ScriptStruct GbxUI.GbxGFxPooledGridPoolInfo
// 0x0030 (0x0030 - 0x0000)
struct FGbxGFxPooledGridPoolInfo final
{
public:
	struct FGbxScrollingListCellInfo              CellInfo;                                          // 0x0000(0x0020)(Transient, NativeAccessSpecifierPublic)
	TWeakObjectPtr<class UGbxGFxPooledGridList>   OwningList;                                        // 0x0020(0x0008)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         ListIndex;                                         // 0x0028(0x0004)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         VisibleIndexOffset;                                // 0x002C(0x0004)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FGbxGFxPooledGridPoolInfo) == 0x000008, "Wrong alignment on FGbxGFxPooledGridPoolInfo");
static_assert(sizeof(FGbxGFxPooledGridPoolInfo) == 0x000030, "Wrong size on FGbxGFxPooledGridPoolInfo");
static_assert(offsetof(FGbxGFxPooledGridPoolInfo, CellInfo) == 0x000000, "Member 'FGbxGFxPooledGridPoolInfo::CellInfo' has a wrong offset!");
static_assert(offsetof(FGbxGFxPooledGridPoolInfo, OwningList) == 0x000020, "Member 'FGbxGFxPooledGridPoolInfo::OwningList' has a wrong offset!");
static_assert(offsetof(FGbxGFxPooledGridPoolInfo, ListIndex) == 0x000028, "Member 'FGbxGFxPooledGridPoolInfo::ListIndex' has a wrong offset!");
static_assert(offsetof(FGbxGFxPooledGridPoolInfo, VisibleIndexOffset) == 0x00002C, "Member 'FGbxGFxPooledGridPoolInfo::VisibleIndexOffset' has a wrong offset!");

// ScriptStruct GbxUI.GbxInputToGlyphMapItem
// 0x0518 (0x0518 - 0x0000)
struct FGbxInputToGlyphMapItem final
{
public:
	struct FKey                                   Key;                                               // 0x0000(0x0018)(Edit, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FText                                   KeyboardMouseGlyph;                                // 0x0018(0x0018)(Edit, NativeAccessSpecifierPublic)
	class FText                                   PS4Glyph;                                          // 0x0030(0x0018)(Edit, NativeAccessSpecifierPublic)
	class FText                                   XboxOneGlyph;                                      // 0x0048(0x0018)(Edit, NativeAccessSpecifierPublic)
	class FText                                   DPXGlyph;                                          // 0x0060(0x0018)(Edit, NativeAccessSpecifierPublic)
	class FText                                   MPXGlyph;                                          // 0x0078(0x0018)(Edit, NativeAccessSpecifierPublic)
	class FText                                   GenericGamepadGlyph;                               // 0x0090(0x0018)(Edit, NativeAccessSpecifierPublic)
	class FText                                   SwitchProGlyph;                                    // 0x00A8(0x0018)(Edit, NativeAccessSpecifierPublic)
	class FText                                   StadiaGlyph;                                       // 0x00C0(0x0018)(Edit, NativeAccessSpecifierPublic)
	struct FSlateBrush                            KeyboardMouseGlyphBrush;                           // 0x00D8(0x0088)(Edit, NativeAccessSpecifierPublic)
	struct FSlateBrush                            PS4GlyphBrush;                                     // 0x0160(0x0088)(Edit, NativeAccessSpecifierPublic)
	struct FSlateBrush                            XboxOneGlyphBrush;                                 // 0x01E8(0x0088)(Edit, NativeAccessSpecifierPublic)
	struct FSlateBrush                            DPXGlyphBrush;                                     // 0x0270(0x0088)(Edit, NativeAccessSpecifierPublic)
	struct FSlateBrush                            MPXGlyphBrush;                                     // 0x02F8(0x0088)(Edit, NativeAccessSpecifierPublic)
	struct FSlateBrush                            GenericGamepadGlyphBrush;                          // 0x0380(0x0088)(Edit, NativeAccessSpecifierPublic)
	struct FSlateBrush                            SwitchProGlyphBrush;                               // 0x0408(0x0088)(Edit, NativeAccessSpecifierPublic)
	struct FSlateBrush                            StadiaGlyphBrush;                                  // 0x0490(0x0088)(Edit, NativeAccessSpecifierPublic)
};
static_assert(alignof(FGbxInputToGlyphMapItem) == 0x000008, "Wrong alignment on FGbxInputToGlyphMapItem");
static_assert(sizeof(FGbxInputToGlyphMapItem) == 0x000518, "Wrong size on FGbxInputToGlyphMapItem");
static_assert(offsetof(FGbxInputToGlyphMapItem, Key) == 0x000000, "Member 'FGbxInputToGlyphMapItem::Key' has a wrong offset!");
static_assert(offsetof(FGbxInputToGlyphMapItem, KeyboardMouseGlyph) == 0x000018, "Member 'FGbxInputToGlyphMapItem::KeyboardMouseGlyph' has a wrong offset!");
static_assert(offsetof(FGbxInputToGlyphMapItem, PS4Glyph) == 0x000030, "Member 'FGbxInputToGlyphMapItem::PS4Glyph' has a wrong offset!");
static_assert(offsetof(FGbxInputToGlyphMapItem, XboxOneGlyph) == 0x000048, "Member 'FGbxInputToGlyphMapItem::XboxOneGlyph' has a wrong offset!");
static_assert(offsetof(FGbxInputToGlyphMapItem, DPXGlyph) == 0x000060, "Member 'FGbxInputToGlyphMapItem::DPXGlyph' has a wrong offset!");
static_assert(offsetof(FGbxInputToGlyphMapItem, MPXGlyph) == 0x000078, "Member 'FGbxInputToGlyphMapItem::MPXGlyph' has a wrong offset!");
static_assert(offsetof(FGbxInputToGlyphMapItem, GenericGamepadGlyph) == 0x000090, "Member 'FGbxInputToGlyphMapItem::GenericGamepadGlyph' has a wrong offset!");
static_assert(offsetof(FGbxInputToGlyphMapItem, SwitchProGlyph) == 0x0000A8, "Member 'FGbxInputToGlyphMapItem::SwitchProGlyph' has a wrong offset!");
static_assert(offsetof(FGbxInputToGlyphMapItem, StadiaGlyph) == 0x0000C0, "Member 'FGbxInputToGlyphMapItem::StadiaGlyph' has a wrong offset!");
static_assert(offsetof(FGbxInputToGlyphMapItem, KeyboardMouseGlyphBrush) == 0x0000D8, "Member 'FGbxInputToGlyphMapItem::KeyboardMouseGlyphBrush' has a wrong offset!");
static_assert(offsetof(FGbxInputToGlyphMapItem, PS4GlyphBrush) == 0x000160, "Member 'FGbxInputToGlyphMapItem::PS4GlyphBrush' has a wrong offset!");
static_assert(offsetof(FGbxInputToGlyphMapItem, XboxOneGlyphBrush) == 0x0001E8, "Member 'FGbxInputToGlyphMapItem::XboxOneGlyphBrush' has a wrong offset!");
static_assert(offsetof(FGbxInputToGlyphMapItem, DPXGlyphBrush) == 0x000270, "Member 'FGbxInputToGlyphMapItem::DPXGlyphBrush' has a wrong offset!");
static_assert(offsetof(FGbxInputToGlyphMapItem, MPXGlyphBrush) == 0x0002F8, "Member 'FGbxInputToGlyphMapItem::MPXGlyphBrush' has a wrong offset!");
static_assert(offsetof(FGbxInputToGlyphMapItem, GenericGamepadGlyphBrush) == 0x000380, "Member 'FGbxInputToGlyphMapItem::GenericGamepadGlyphBrush' has a wrong offset!");
static_assert(offsetof(FGbxInputToGlyphMapItem, SwitchProGlyphBrush) == 0x000408, "Member 'FGbxInputToGlyphMapItem::SwitchProGlyphBrush' has a wrong offset!");
static_assert(offsetof(FGbxInputToGlyphMapItem, StadiaGlyphBrush) == 0x000490, "Member 'FGbxInputToGlyphMapItem::StadiaGlyphBrush' has a wrong offset!");

// ScriptStruct GbxUI.GbxMenuInputAxisBind
// 0x0020 (0x0020 - 0x0000)
struct FGbxMenuInputAxisBind final
{
public:
	struct FKey                                   Key;                                               // 0x0000(0x0018)(Edit, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         Scale;                                             // 0x0018(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1C[0x4];                                       // 0x001C(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FGbxMenuInputAxisBind) == 0x000008, "Wrong alignment on FGbxMenuInputAxisBind");
static_assert(sizeof(FGbxMenuInputAxisBind) == 0x000020, "Wrong size on FGbxMenuInputAxisBind");
static_assert(offsetof(FGbxMenuInputAxisBind, Key) == 0x000000, "Member 'FGbxMenuInputAxisBind::Key' has a wrong offset!");
static_assert(offsetof(FGbxMenuInputAxisBind, Scale) == 0x000018, "Member 'FGbxMenuInputAxisBind::Scale' has a wrong offset!");

// ScriptStruct GbxUI.GbxHintWidgetMapItem
// 0x0030 (0x0030 - 0x0000)
struct FGbxHintWidgetMapItem final
{
public:
	TArray<class FName>                           InputActions;                                      // 0x0000(0x0010)(ZeroConstructor, NativeAccessSpecifierPublic)
	bool                                          bIsEnabled;                                        // 0x0010(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_11[0x7];                                       // 0x0011(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	class UObject*                                HintWidget;                                        // 0x0018(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TScriptInterface<class IGbxHintWidget>        HintWidgetInterface;                               // 0x0020(0x0010)(ZeroConstructor, IsPlainOldData, NoDestructor, UObjectWrapper, NativeAccessSpecifierPublic)
};
static_assert(alignof(FGbxHintWidgetMapItem) == 0x000008, "Wrong alignment on FGbxHintWidgetMapItem");
static_assert(sizeof(FGbxHintWidgetMapItem) == 0x000030, "Wrong size on FGbxHintWidgetMapItem");
static_assert(offsetof(FGbxHintWidgetMapItem, InputActions) == 0x000000, "Member 'FGbxHintWidgetMapItem::InputActions' has a wrong offset!");
static_assert(offsetof(FGbxHintWidgetMapItem, bIsEnabled) == 0x000010, "Member 'FGbxHintWidgetMapItem::bIsEnabled' has a wrong offset!");
static_assert(offsetof(FGbxHintWidgetMapItem, HintWidget) == 0x000018, "Member 'FGbxHintWidgetMapItem::HintWidget' has a wrong offset!");
static_assert(offsetof(FGbxHintWidgetMapItem, HintWidgetInterface) == 0x000020, "Member 'FGbxHintWidgetMapItem::HintWidgetInterface' has a wrong offset!");

// ScriptStruct GbxUI.GbxHintInfo
// 0x0040 (0x0040 - 0x0000)
struct FGbxHintInfo final
{
public:
	TArray<class FName>                           InputActions;                                      // 0x0000(0x0010)(Edit, BlueprintVisible, ZeroConstructor, NativeAccessSpecifierPublic)
	class FText                                   HelpText;                                          // 0x0010(0x0018)(Edit, BlueprintVisible, NativeAccessSpecifierPublic)
	bool                                          bStagePlaced;                                      // 0x0028(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_29[0x7];                                       // 0x0029(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	class UObject*                                StagePlacedWidget;                                 // 0x0030(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bClickable;                                        // 0x0038(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bForceRefreshText;                                 // 0x0039(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_3A[0x6];                                       // 0x003A(0x0006)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FGbxHintInfo) == 0x000008, "Wrong alignment on FGbxHintInfo");
static_assert(sizeof(FGbxHintInfo) == 0x000040, "Wrong size on FGbxHintInfo");
static_assert(offsetof(FGbxHintInfo, InputActions) == 0x000000, "Member 'FGbxHintInfo::InputActions' has a wrong offset!");
static_assert(offsetof(FGbxHintInfo, HelpText) == 0x000010, "Member 'FGbxHintInfo::HelpText' has a wrong offset!");
static_assert(offsetof(FGbxHintInfo, bStagePlaced) == 0x000028, "Member 'FGbxHintInfo::bStagePlaced' has a wrong offset!");
static_assert(offsetof(FGbxHintInfo, StagePlacedWidget) == 0x000030, "Member 'FGbxHintInfo::StagePlacedWidget' has a wrong offset!");
static_assert(offsetof(FGbxHintInfo, bClickable) == 0x000038, "Member 'FGbxHintInfo::bClickable' has a wrong offset!");
static_assert(offsetof(FGbxHintInfo, bForceRefreshText) == 0x000039, "Member 'FGbxHintInfo::bForceRefreshText' has a wrong offset!");

// ScriptStruct GbxUI.GbxMenuSwitcherSubmenuInfo
// 0x0030 (0x0030 - 0x0000)
struct FGbxMenuSwitcherSubmenuInfo final
{
public:
	class FName                                   MenuID;                                            // 0x0000(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FText                                   MenuName;                                          // 0x0008(0x0018)(Edit, NativeAccessSpecifierPublic)
	class UGbxMenuData*                           MenuData;                                          // 0x0020(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TSubclassOf<class UGbxMenuSwitcherSubmenu>    MenuClass;                                         // 0x0028(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FGbxMenuSwitcherSubmenuInfo) == 0x000008, "Wrong alignment on FGbxMenuSwitcherSubmenuInfo");
static_assert(sizeof(FGbxMenuSwitcherSubmenuInfo) == 0x000030, "Wrong size on FGbxMenuSwitcherSubmenuInfo");
static_assert(offsetof(FGbxMenuSwitcherSubmenuInfo, MenuID) == 0x000000, "Member 'FGbxMenuSwitcherSubmenuInfo::MenuID' has a wrong offset!");
static_assert(offsetof(FGbxMenuSwitcherSubmenuInfo, MenuName) == 0x000008, "Member 'FGbxMenuSwitcherSubmenuInfo::MenuName' has a wrong offset!");
static_assert(offsetof(FGbxMenuSwitcherSubmenuInfo, MenuData) == 0x000020, "Member 'FGbxMenuSwitcherSubmenuInfo::MenuData' has a wrong offset!");
static_assert(offsetof(FGbxMenuSwitcherSubmenuInfo, MenuClass) == 0x000028, "Member 'FGbxMenuSwitcherSubmenuInfo::MenuClass' has a wrong offset!");

// ScriptStruct GbxUI.GbxHUDLayoutData
// 0x0010 (0x0010 - 0x0000)
struct FGbxHUDLayoutData final
{
public:
	class UDataTable*                             Layout;                                            // 0x0000(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         Scale;                                             // 0x0008(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_C[0x4];                                        // 0x000C(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FGbxHUDLayoutData) == 0x000008, "Wrong alignment on FGbxHUDLayoutData");
static_assert(sizeof(FGbxHUDLayoutData) == 0x000010, "Wrong size on FGbxHUDLayoutData");
static_assert(offsetof(FGbxHUDLayoutData, Layout) == 0x000000, "Member 'FGbxHUDLayoutData::Layout' has a wrong offset!");
static_assert(offsetof(FGbxHUDLayoutData, Scale) == 0x000008, "Member 'FGbxHUDLayoutData::Scale' has a wrong offset!");

// ScriptStruct GbxUI.GbxHUDFeedbackManager
// 0x0068 (0x0068 - 0x0000)
struct FGbxHUDFeedbackManager final
{
public:
	class UGbxGFxHUDFeedbackData*                 FeedbackData;                                      // 0x0000(0x0008)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_8[0x8];                                        // 0x0008(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<class UGbxGFxMovie*>                   Widgets;                                           // 0x0010(0x0010)(ZeroConstructor, Transient, NativeAccessSpecifierPrivate)
	TWeakObjectPtr<class AGbxPlayerController>    OwningPlayer;                                      // 0x0020(0x0008)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	TWeakObjectPtr<class APawn>                   OwningPawn;                                        // 0x0028(0x0008)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	TWeakObjectPtr<class APlayerCameraManager>    OwningPlayerCameraManager;                         // 0x0030(0x0008)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_38[0x30];                                      // 0x0038(0x0030)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FGbxHUDFeedbackManager) == 0x000008, "Wrong alignment on FGbxHUDFeedbackManager");
static_assert(sizeof(FGbxHUDFeedbackManager) == 0x000068, "Wrong size on FGbxHUDFeedbackManager");
static_assert(offsetof(FGbxHUDFeedbackManager, FeedbackData) == 0x000000, "Member 'FGbxHUDFeedbackManager::FeedbackData' has a wrong offset!");
static_assert(offsetof(FGbxHUDFeedbackManager, Widgets) == 0x000010, "Member 'FGbxHUDFeedbackManager::Widgets' has a wrong offset!");
static_assert(offsetof(FGbxHUDFeedbackManager, OwningPlayer) == 0x000020, "Member 'FGbxHUDFeedbackManager::OwningPlayer' has a wrong offset!");
static_assert(offsetof(FGbxHUDFeedbackManager, OwningPawn) == 0x000028, "Member 'FGbxHUDFeedbackManager::OwningPawn' has a wrong offset!");
static_assert(offsetof(FGbxHUDFeedbackManager, OwningPlayerCameraManager) == 0x000030, "Member 'FGbxHUDFeedbackManager::OwningPlayerCameraManager' has a wrong offset!");

// ScriptStruct GbxUI.GbxMenuInputAxisAction
// 0x0038 (0x0038 - 0x0000)
struct FGbxMenuInputAxisAction final
{
public:
	class FName                                   ActionName;                                        // 0x0000(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TArray<struct FGbxMenuInputAxisBind>          Binds;                                             // 0x0008(0x0010)(Edit, ZeroConstructor, NativeAccessSpecifierPublic)
	bool                                          bTreatAsButtonPress;                               // 0x0018(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_19[0x7];                                       // 0x0019(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	class FName                                   PositiveAxisAction;                                // 0x0020(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   NegativeAxisAction;                                // 0x0028(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bWantsRepeat;                                      // 0x0030(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_31[0x7];                                       // 0x0031(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FGbxMenuInputAxisAction) == 0x000008, "Wrong alignment on FGbxMenuInputAxisAction");
static_assert(sizeof(FGbxMenuInputAxisAction) == 0x000038, "Wrong size on FGbxMenuInputAxisAction");
static_assert(offsetof(FGbxMenuInputAxisAction, ActionName) == 0x000000, "Member 'FGbxMenuInputAxisAction::ActionName' has a wrong offset!");
static_assert(offsetof(FGbxMenuInputAxisAction, Binds) == 0x000008, "Member 'FGbxMenuInputAxisAction::Binds' has a wrong offset!");
static_assert(offsetof(FGbxMenuInputAxisAction, bTreatAsButtonPress) == 0x000018, "Member 'FGbxMenuInputAxisAction::bTreatAsButtonPress' has a wrong offset!");
static_assert(offsetof(FGbxMenuInputAxisAction, PositiveAxisAction) == 0x000020, "Member 'FGbxMenuInputAxisAction::PositiveAxisAction' has a wrong offset!");
static_assert(offsetof(FGbxMenuInputAxisAction, NegativeAxisAction) == 0x000028, "Member 'FGbxMenuInputAxisAction::NegativeAxisAction' has a wrong offset!");
static_assert(offsetof(FGbxMenuInputAxisAction, bWantsRepeat) == 0x000030, "Member 'FGbxMenuInputAxisAction::bWantsRepeat' has a wrong offset!");

// ScriptStruct GbxUI.GbxMenuInputAction
// 0x0020 (0x0020 - 0x0000)
struct FGbxMenuInputAction final
{
public:
	class FName                                   ActionName;                                        // 0x0000(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TArray<struct FKey>                           Keys;                                              // 0x0008(0x0010)(Edit, ZeroConstructor, NativeAccessSpecifierPublic)
	EGbxMenuInputActionTrigger                    ActionTrigger;                                     // 0x0018(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bWantsRepeat;                                      // 0x0019(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1A[0x6];                                       // 0x001A(0x0006)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FGbxMenuInputAction) == 0x000008, "Wrong alignment on FGbxMenuInputAction");
static_assert(sizeof(FGbxMenuInputAction) == 0x000020, "Wrong size on FGbxMenuInputAction");
static_assert(offsetof(FGbxMenuInputAction, ActionName) == 0x000000, "Member 'FGbxMenuInputAction::ActionName' has a wrong offset!");
static_assert(offsetof(FGbxMenuInputAction, Keys) == 0x000008, "Member 'FGbxMenuInputAction::Keys' has a wrong offset!");
static_assert(offsetof(FGbxMenuInputAction, ActionTrigger) == 0x000018, "Member 'FGbxMenuInputAction::ActionTrigger' has a wrong offset!");
static_assert(offsetof(FGbxMenuInputAction, bWantsRepeat) == 0x000019, "Member 'FGbxMenuInputAction::bWantsRepeat' has a wrong offset!");

// ScriptStruct GbxUI.GbxMenuInputActionInfo
// 0x000C (0x000C - 0x0000)
struct FGbxMenuInputActionInfo final
{
public:
	bool                                          bIsHeld;                                           // 0x0000(0x0001)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bIsPressToHold;                                    // 0x0001(0x0001)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2[0x2];                                        // 0x0002(0x0002)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         PressToHoldDuration;                               // 0x0004(0x0004)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         PressToHoldProgress;                               // 0x0008(0x0004)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FGbxMenuInputActionInfo) == 0x000004, "Wrong alignment on FGbxMenuInputActionInfo");
static_assert(sizeof(FGbxMenuInputActionInfo) == 0x00000C, "Wrong size on FGbxMenuInputActionInfo");
static_assert(offsetof(FGbxMenuInputActionInfo, bIsHeld) == 0x000000, "Member 'FGbxMenuInputActionInfo::bIsHeld' has a wrong offset!");
static_assert(offsetof(FGbxMenuInputActionInfo, bIsPressToHold) == 0x000001, "Member 'FGbxMenuInputActionInfo::bIsPressToHold' has a wrong offset!");
static_assert(offsetof(FGbxMenuInputActionInfo, PressToHoldDuration) == 0x000004, "Member 'FGbxMenuInputActionInfo::PressToHoldDuration' has a wrong offset!");
static_assert(offsetof(FGbxMenuInputActionInfo, PressToHoldProgress) == 0x000008, "Member 'FGbxMenuInputActionInfo::PressToHoldProgress' has a wrong offset!");

// ScriptStruct GbxUI.GbxMenuKeyRepeatInfo
// 0x0018 (0x0018 - 0x0000)
struct FGbxMenuKeyRepeatInfo final
{
public:
	float                                         InitialButtonRepeatDelay;                          // 0x0000(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         RepeatDelayStart;                                  // 0x0004(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         RepeatDelayEnd;                                    // 0x0008(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         RepeatDelayDelta;                                  // 0x000C(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         HoldToPressDuration;                               // 0x0010(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         HoldToPressDurationLong;                           // 0x0014(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FGbxMenuKeyRepeatInfo) == 0x000004, "Wrong alignment on FGbxMenuKeyRepeatInfo");
static_assert(sizeof(FGbxMenuKeyRepeatInfo) == 0x000018, "Wrong size on FGbxMenuKeyRepeatInfo");
static_assert(offsetof(FGbxMenuKeyRepeatInfo, InitialButtonRepeatDelay) == 0x000000, "Member 'FGbxMenuKeyRepeatInfo::InitialButtonRepeatDelay' has a wrong offset!");
static_assert(offsetof(FGbxMenuKeyRepeatInfo, RepeatDelayStart) == 0x000004, "Member 'FGbxMenuKeyRepeatInfo::RepeatDelayStart' has a wrong offset!");
static_assert(offsetof(FGbxMenuKeyRepeatInfo, RepeatDelayEnd) == 0x000008, "Member 'FGbxMenuKeyRepeatInfo::RepeatDelayEnd' has a wrong offset!");
static_assert(offsetof(FGbxMenuKeyRepeatInfo, RepeatDelayDelta) == 0x00000C, "Member 'FGbxMenuKeyRepeatInfo::RepeatDelayDelta' has a wrong offset!");
static_assert(offsetof(FGbxMenuKeyRepeatInfo, HoldToPressDuration) == 0x000010, "Member 'FGbxMenuKeyRepeatInfo::HoldToPressDuration' has a wrong offset!");
static_assert(offsetof(FGbxMenuKeyRepeatInfo, HoldToPressDurationLong) == 0x000014, "Member 'FGbxMenuKeyRepeatInfo::HoldToPressDurationLong' has a wrong offset!");

// ScriptStruct GbxUI.GbxMenuSplitscreenLayouts
// 0x0070 (0x0070 - 0x0000)
struct FGbxMenuSplitscreenLayouts final
{
public:
	uint8                                         Pad_0[0x8];                                        // 0x0000(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	TSoftClassPtr<class UClass>                   VerticalLayout;                                    // 0x0008(0x0028)(Edit, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TSoftClassPtr<class UClass>                   QuarterLayout;                                     // 0x0030(0x0028)(Edit, Transient, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FSoftObjectPath                        QuarterLayoutPath;                                 // 0x0058(0x0018)(HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FGbxMenuSplitscreenLayouts) == 0x000008, "Wrong alignment on FGbxMenuSplitscreenLayouts");
static_assert(sizeof(FGbxMenuSplitscreenLayouts) == 0x000070, "Wrong size on FGbxMenuSplitscreenLayouts");
static_assert(offsetof(FGbxMenuSplitscreenLayouts, VerticalLayout) == 0x000008, "Member 'FGbxMenuSplitscreenLayouts::VerticalLayout' has a wrong offset!");
static_assert(offsetof(FGbxMenuSplitscreenLayouts, QuarterLayout) == 0x000030, "Member 'FGbxMenuSplitscreenLayouts::QuarterLayout' has a wrong offset!");
static_assert(offsetof(FGbxMenuSplitscreenLayouts, QuarterLayoutPath) == 0x000058, "Member 'FGbxMenuSplitscreenLayouts::QuarterLayoutPath' has a wrong offset!");

// ScriptStruct GbxUI.TextMarkupDictionaryEntry
// 0x0018 (0x0018 - 0x0000)
struct FTextMarkupDictionaryEntry final
{
public:
	class FString                                 OutputText;                                        // 0x0000(0x0010)(Edit, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bRequiresEndSection;                               // 0x0010(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_11[0x7];                                       // 0x0011(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FTextMarkupDictionaryEntry) == 0x000008, "Wrong alignment on FTextMarkupDictionaryEntry");
static_assert(sizeof(FTextMarkupDictionaryEntry) == 0x000018, "Wrong size on FTextMarkupDictionaryEntry");
static_assert(offsetof(FTextMarkupDictionaryEntry, OutputText) == 0x000000, "Member 'FTextMarkupDictionaryEntry::OutputText' has a wrong offset!");
static_assert(offsetof(FTextMarkupDictionaryEntry, bRequiresEndSection) == 0x000010, "Member 'FTextMarkupDictionaryEntry::bRequiresEndSection' has a wrong offset!");

// ScriptStruct GbxUI.GbxUIScroller
// 0x0034 (0x0034 - 0x0000)
struct FGbxUIScroller final
{
public:
	float                                         Acceleration;                                      // 0x0000(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         ItemSize;                                          // 0x0004(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         MaxVelocity;                                       // 0x0008(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         MinVelocity;                                       // 0x000C(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bUseFixedVelocity;                                 // 0x0010(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_11[0x3];                                       // 0x0011(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         FixedVelocity;                                     // 0x0014(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         ScrollPosition;                                    // 0x0018(0x0004)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	float                                         DesiredPosition;                                   // 0x001C(0x0004)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	float                                         WindowSize;                                        // 0x0020(0x0004)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	float                                         FullSize;                                          // 0x0024(0x0004)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	float                                         CurVelocity;                                       // 0x0028(0x0004)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	float                                         DesiredVelocity;                                   // 0x002C(0x0004)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	bool                                          bHasMoved;                                         // 0x0030(0x0001)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	bool                                          bIsMoving;                                         // 0x0031(0x0001)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	bool                                          bHasSlowedDown;                                    // 0x0032(0x0001)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_33[0x1];                                       // 0x0033(0x0001)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FGbxUIScroller) == 0x000004, "Wrong alignment on FGbxUIScroller");
static_assert(sizeof(FGbxUIScroller) == 0x000034, "Wrong size on FGbxUIScroller");
static_assert(offsetof(FGbxUIScroller, Acceleration) == 0x000000, "Member 'FGbxUIScroller::Acceleration' has a wrong offset!");
static_assert(offsetof(FGbxUIScroller, ItemSize) == 0x000004, "Member 'FGbxUIScroller::ItemSize' has a wrong offset!");
static_assert(offsetof(FGbxUIScroller, MaxVelocity) == 0x000008, "Member 'FGbxUIScroller::MaxVelocity' has a wrong offset!");
static_assert(offsetof(FGbxUIScroller, MinVelocity) == 0x00000C, "Member 'FGbxUIScroller::MinVelocity' has a wrong offset!");
static_assert(offsetof(FGbxUIScroller, bUseFixedVelocity) == 0x000010, "Member 'FGbxUIScroller::bUseFixedVelocity' has a wrong offset!");
static_assert(offsetof(FGbxUIScroller, FixedVelocity) == 0x000014, "Member 'FGbxUIScroller::FixedVelocity' has a wrong offset!");
static_assert(offsetof(FGbxUIScroller, ScrollPosition) == 0x000018, "Member 'FGbxUIScroller::ScrollPosition' has a wrong offset!");
static_assert(offsetof(FGbxUIScroller, DesiredPosition) == 0x00001C, "Member 'FGbxUIScroller::DesiredPosition' has a wrong offset!");
static_assert(offsetof(FGbxUIScroller, WindowSize) == 0x000020, "Member 'FGbxUIScroller::WindowSize' has a wrong offset!");
static_assert(offsetof(FGbxUIScroller, FullSize) == 0x000024, "Member 'FGbxUIScroller::FullSize' has a wrong offset!");
static_assert(offsetof(FGbxUIScroller, CurVelocity) == 0x000028, "Member 'FGbxUIScroller::CurVelocity' has a wrong offset!");
static_assert(offsetof(FGbxUIScroller, DesiredVelocity) == 0x00002C, "Member 'FGbxUIScroller::DesiredVelocity' has a wrong offset!");
static_assert(offsetof(FGbxUIScroller, bHasMoved) == 0x000030, "Member 'FGbxUIScroller::bHasMoved' has a wrong offset!");
static_assert(offsetof(FGbxUIScroller, bIsMoving) == 0x000031, "Member 'FGbxUIScroller::bIsMoving' has a wrong offset!");
static_assert(offsetof(FGbxUIScroller, bHasSlowedDown) == 0x000032, "Member 'FGbxUIScroller::bHasSlowedDown' has a wrong offset!");

// ScriptStruct GbxUI.DamageAnimationPairing
// 0x0028 (0x0028 - 0x0000)
struct FDamageAnimationPairing final
{
public:
	ERecentDamageFlags                            DamageTypeFlag;                                    // 0x0000(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1[0x7];                                        // 0x0001(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<class UWidgetAnimation*>               LeftAnimations;                                    // 0x0008(0x0010)(Edit, BlueprintVisible, ExportObject, ZeroConstructor, ContainsInstancedReference, NativeAccessSpecifierPublic)
	TArray<class UWidgetAnimation*>               RightAnimations;                                   // 0x0018(0x0010)(Edit, BlueprintVisible, ExportObject, ZeroConstructor, ContainsInstancedReference, NativeAccessSpecifierPublic)
};
static_assert(alignof(FDamageAnimationPairing) == 0x000008, "Wrong alignment on FDamageAnimationPairing");
static_assert(sizeof(FDamageAnimationPairing) == 0x000028, "Wrong size on FDamageAnimationPairing");
static_assert(offsetof(FDamageAnimationPairing, DamageTypeFlag) == 0x000000, "Member 'FDamageAnimationPairing::DamageTypeFlag' has a wrong offset!");
static_assert(offsetof(FDamageAnimationPairing, LeftAnimations) == 0x000008, "Member 'FDamageAnimationPairing::LeftAnimations' has a wrong offset!");
static_assert(offsetof(FDamageAnimationPairing, RightAnimations) == 0x000018, "Member 'FDamageAnimationPairing::RightAnimations' has a wrong offset!");

}

