#pragma once

/*
* SDK generated by Dumper-7
*
* https://github.com/Encryqed/Dumper-7
*/

// Package: GbxAI

#include "Basic.hpp"

#include "AIModule_structs.hpp"
#include "AIModule_classes.hpp"
#include "GbxAI_structs.hpp"
#include "GbxGameSystemCore_structs.hpp"
#include "GbxGameSystemCore_classes.hpp"
#include "CoreUObject_structs.hpp"
#include "CoreUObject_classes.hpp"
#include "GbxNav_structs.hpp"
#include "GbxNav_classes.hpp"
#include "GbxSpawn_classes.hpp"
#include "Engine_structs.hpp"
#include "Engine_classes.hpp"
#include "GameplayTasks_classes.hpp"
#include "GameplayTags_structs.hpp"
#include "GbxRuntime_structs.hpp"
#include "GbxRuntime_classes.hpp"


namespace SDK
{

// Class GbxAI.AIActionBase
// 0x00D0 (0x00F8 - 0x0028)
class UAIActionBase : public UObject
{
public:
	uint8                                         Pad_28[0x8];                                       // 0x0028(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	UMulticastDelegateProperty_                   OnInitializeInstanceEventBP;                       // 0x0030(0x0010)(ZeroConstructor, Transient, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	uint8                                         Pad_40[0x18];                                      // 0x0040(0x0018)(Fixing Size After Last Property [ Dumper-7 ])
	UMulticastDelegateProperty_                   OnCleanupInstanceEventBP;                          // 0x0058(0x0010)(ZeroConstructor, Transient, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	uint8                                         Pad_68[0x18];                                      // 0x0068(0x0018)(Fixing Size After Last Property [ Dumper-7 ])
	UMulticastDelegateProperty_                   OnStartedEventBP;                                  // 0x0080(0x0010)(ZeroConstructor, Transient, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	uint8                                         Pad_90[0x18];                                      // 0x0090(0x0018)(Fixing Size After Last Property [ Dumper-7 ])
	UMulticastDelegateProperty_                   OnStoppedEventBP;                                  // 0x00A8(0x0010)(ZeroConstructor, Transient, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	uint8                                         Pad_B8[0x18];                                      // 0x00B8(0x0018)(Fixing Size After Last Property [ Dumper-7 ])
	struct FAIActionExecutionSettings             ExecutionSettings;                                 // 0x00D0(0x0008)(Edit, NoDestructor, NativeAccessSpecifierPublic)
	uint8                                         Pad_D8[0x10];                                      // 0x00D8(0x0010)(Fixing Size After Last Property [ Dumper-7 ])
	uint8                                         BaseVersion;                                       // 0x00E8(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_E9[0x3];                                       // 0x00E9(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	uint32                                        Version;                                           // 0x00EC(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	EAIActionCreationMethod                       CreationMethod;                                    // 0x00F0(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_F1[0x7];                                       // 0x00F1(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static void StopBP(class UAIActionBase* Action, const struct FAIActionBlueprintContext& Context, bool bSucceeded);

	class UObject* CreateSubobjectNoName(class UClass* Class_0);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"AIActionBase">();
	}
	static class UAIActionBase* GetDefaultObj()
	{
		return GetDefaultObjImpl<UAIActionBase>();
	}
};
static_assert(alignof(UAIActionBase) == 0x000008, "Wrong alignment on UAIActionBase");
static_assert(sizeof(UAIActionBase) == 0x0000F8, "Wrong size on UAIActionBase");
static_assert(offsetof(UAIActionBase, OnInitializeInstanceEventBP) == 0x000030, "Member 'UAIActionBase::OnInitializeInstanceEventBP' has a wrong offset!");
static_assert(offsetof(UAIActionBase, OnCleanupInstanceEventBP) == 0x000058, "Member 'UAIActionBase::OnCleanupInstanceEventBP' has a wrong offset!");
static_assert(offsetof(UAIActionBase, OnStartedEventBP) == 0x000080, "Member 'UAIActionBase::OnStartedEventBP' has a wrong offset!");
static_assert(offsetof(UAIActionBase, OnStoppedEventBP) == 0x0000A8, "Member 'UAIActionBase::OnStoppedEventBP' has a wrong offset!");
static_assert(offsetof(UAIActionBase, ExecutionSettings) == 0x0000D0, "Member 'UAIActionBase::ExecutionSettings' has a wrong offset!");
static_assert(offsetof(UAIActionBase, BaseVersion) == 0x0000E8, "Member 'UAIActionBase::BaseVersion' has a wrong offset!");
static_assert(offsetof(UAIActionBase, Version) == 0x0000EC, "Member 'UAIActionBase::Version' has a wrong offset!");
static_assert(offsetof(UAIActionBase, CreationMethod) == 0x0000F0, "Member 'UAIActionBase::CreationMethod' has a wrong offset!");

// Class GbxAI.AIActionBlueprint
// 0x0018 (0x0100 - 0x00E8)
class UAIActionBlueprint final : public UBlueprint
{
public:
	class UAIActionBlueprint*                     ParentBlueprint;                                   // 0x00E8(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UBlackboardData*                        Blackboard;                                        // 0x00F0(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_F8[0x8];                                       // 0x00F8(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static bool ShouldSkipBlackboardProperty(class UProperty* Property);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"AIActionBlueprint">();
	}
	static class UAIActionBlueprint* GetDefaultObj()
	{
		return GetDefaultObjImpl<UAIActionBlueprint>();
	}
};
static_assert(alignof(UAIActionBlueprint) == 0x000008, "Wrong alignment on UAIActionBlueprint");
static_assert(sizeof(UAIActionBlueprint) == 0x000100, "Wrong size on UAIActionBlueprint");
static_assert(offsetof(UAIActionBlueprint, ParentBlueprint) == 0x0000E8, "Member 'UAIActionBlueprint::ParentBlueprint' has a wrong offset!");
static_assert(offsetof(UAIActionBlueprint, Blackboard) == 0x0000F0, "Member 'UAIActionBlueprint::Blackboard' has a wrong offset!");

// Class GbxAI.AIAction
// 0x0050 (0x0148 - 0x00F8)
class UAIAction : public UAIActionBase
{
public:
	class UBlackboardData*                        Blackboard;                                        // 0x00F8(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bWaitForAllAspects;                                // 0x0100(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_101[0x7];                                      // 0x0101(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<class UAIAspect*>                      Aspects;                                           // 0x0108(0x0010)(Edit, ExportObject, ZeroConstructor, ContainsInstancedReference, NativeAccessSpecifierPublic)
	TArray<class UAIAspect*>                      BuiltInAspects;                                    // 0x0118(0x0010)(ExportObject, ZeroConstructor, ContainsInstancedReference, NativeAccessSpecifierPublic)
	bool                                          bIsChildAction;                                    // 0x0128(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_129[0x7];                                      // 0x0129(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<class UAIAction*>                      SubActions;                                        // 0x0130(0x0010)(ExportObject, ZeroConstructor, ContainsInstancedReference, NativeAccessSpecifierPublic)
	uint8                                         Pad_140[0x1];                                      // 0x0140(0x0001)(Fixing Size After Last Property [ Dumper-7 ])
	uint8                                         ActionVersion;                                     // 0x0141(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_142[0x6];                                      // 0x0142(0x0006)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	class UAIAction* CreateSubAction(class UClass* ActionClass, class FName Name_0);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"AIAction">();
	}
	static class UAIAction* GetDefaultObj()
	{
		return GetDefaultObjImpl<UAIAction>();
	}
};
static_assert(alignof(UAIAction) == 0x000008, "Wrong alignment on UAIAction");
static_assert(sizeof(UAIAction) == 0x000148, "Wrong size on UAIAction");
static_assert(offsetof(UAIAction, Blackboard) == 0x0000F8, "Member 'UAIAction::Blackboard' has a wrong offset!");
static_assert(offsetof(UAIAction, bWaitForAllAspects) == 0x000100, "Member 'UAIAction::bWaitForAllAspects' has a wrong offset!");
static_assert(offsetof(UAIAction, Aspects) == 0x000108, "Member 'UAIAction::Aspects' has a wrong offset!");
static_assert(offsetof(UAIAction, BuiltInAspects) == 0x000118, "Member 'UAIAction::BuiltInAspects' has a wrong offset!");
static_assert(offsetof(UAIAction, bIsChildAction) == 0x000128, "Member 'UAIAction::bIsChildAction' has a wrong offset!");
static_assert(offsetof(UAIAction, SubActions) == 0x000130, "Member 'UAIAction::SubActions' has a wrong offset!");
static_assert(offsetof(UAIAction, ActionVersion) == 0x000141, "Member 'UAIAction::ActionVersion' has a wrong offset!");

// Class GbxAI.BTTask_AIAction
// 0x0008 (0x0078 - 0x0070)
class UBTTask_AIAction : public UBTTaskNode
{
public:
	class UBTDecorator_AIAction*                  ActionDecorator;                                   // 0x0070(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, PersistentInstance, HasGetValueTypeHash, NativeAccessSpecifierPrivate)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"BTTask_AIAction">();
	}
	static class UBTTask_AIAction* GetDefaultObj()
	{
		return GetDefaultObjImpl<UBTTask_AIAction>();
	}
};
static_assert(alignof(UBTTask_AIAction) == 0x000008, "Wrong alignment on UBTTask_AIAction");
static_assert(sizeof(UBTTask_AIAction) == 0x000078, "Wrong size on UBTTask_AIAction");
static_assert(offsetof(UBTTask_AIAction, ActionDecorator) == 0x000070, "Member 'UBTTask_AIAction::ActionDecorator' has a wrong offset!");

// Class GbxAI.EnvQueryGenerator_Cover
// 0x0050 (0x00B0 - 0x0060)
class UEnvQueryGenerator_Cover final : public UEnvQueryGenerator
{
public:
	TArray<class UCoverSlotData*>                 SlotTypes;                                         // 0x0060(0x0010)(Edit, ZeroConstructor, NativeAccessSpecifierPrivate)
	struct FAIDataProviderFloatValue              SearchRadius;                                      // 0x0070(0x0030)(Edit, DisableEditOnInstance, ContainsInstancedReference, NativeAccessSpecifierPrivate)
	TSubclassOf<class UEnvQueryContext>           SearchCenter;                                      // 0x00A0(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UCoverSlotData*                         SlotType;                                          // 0x00A8(0x0008)(ZeroConstructor, Deprecated, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"EnvQueryGenerator_Cover">();
	}
	static class UEnvQueryGenerator_Cover* GetDefaultObj()
	{
		return GetDefaultObjImpl<UEnvQueryGenerator_Cover>();
	}
};
static_assert(alignof(UEnvQueryGenerator_Cover) == 0x000008, "Wrong alignment on UEnvQueryGenerator_Cover");
static_assert(sizeof(UEnvQueryGenerator_Cover) == 0x0000B0, "Wrong size on UEnvQueryGenerator_Cover");
static_assert(offsetof(UEnvQueryGenerator_Cover, SlotTypes) == 0x000060, "Member 'UEnvQueryGenerator_Cover::SlotTypes' has a wrong offset!");
static_assert(offsetof(UEnvQueryGenerator_Cover, SearchRadius) == 0x000070, "Member 'UEnvQueryGenerator_Cover::SearchRadius' has a wrong offset!");
static_assert(offsetof(UEnvQueryGenerator_Cover, SearchCenter) == 0x0000A0, "Member 'UEnvQueryGenerator_Cover::SearchCenter' has a wrong offset!");
static_assert(offsetof(UEnvQueryGenerator_Cover, SlotType) == 0x0000A8, "Member 'UEnvQueryGenerator_Cover::SlotType' has a wrong offset!");

// Class GbxAI.AIAction_Composite
// 0x0018 (0x0160 - 0x0148)
class UAIAction_Composite : public UAIAction
{
public:
	TArray<class UAIAction_CompositeChild*>       Children;                                          // 0x0148(0x0010)(ExportObject, ZeroConstructor, ContainsInstancedReference, NativeAccessSpecifierPublic)
	uint8                                         CompositeVersion;                                  // 0x0158(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_159[0x7];                                      // 0x0159(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	class UAIAction_CompositeChild* CreateChild(class FName ChildName);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"AIAction_Composite">();
	}
	static class UAIAction_Composite* GetDefaultObj()
	{
		return GetDefaultObjImpl<UAIAction_Composite>();
	}
};
static_assert(alignof(UAIAction_Composite) == 0x000008, "Wrong alignment on UAIAction_Composite");
static_assert(sizeof(UAIAction_Composite) == 0x000160, "Wrong size on UAIAction_Composite");
static_assert(offsetof(UAIAction_Composite, Children) == 0x000148, "Member 'UAIAction_Composite::Children' has a wrong offset!");
static_assert(offsetof(UAIAction_Composite, CompositeVersion) == 0x000158, "Member 'UAIAction_Composite::CompositeVersion' has a wrong offset!");

// Class GbxAI.AIAction_Selector
// 0x0000 (0x0160 - 0x0160)
class UAIAction_Selector : public UAIAction_Composite
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"AIAction_Selector">();
	}
	static class UAIAction_Selector* GetDefaultObj()
	{
		return GetDefaultObjImpl<UAIAction_Selector>();
	}
};
static_assert(alignof(UAIAction_Selector) == 0x000008, "Wrong alignment on UAIAction_Selector");
static_assert(sizeof(UAIAction_Selector) == 0x000160, "Wrong size on UAIAction_Selector");

// Class GbxAI.AIAction_Sequence
// 0x0088 (0x01E8 - 0x0160)
class UAIAction_Sequence : public UAIAction_Selector
{
public:
	EAIActionSequenceCanStartCheck                CanStartChecks;                                    // 0x0160(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_161[0x7];                                      // 0x0161(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	struct FGbxParam                              CanBeInterrupted;                                  // 0x0168(0x0080)(Edit, BlueprintVisible, NoDestructor, ContainsInstancedReference, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"AIAction_Sequence">();
	}
	static class UAIAction_Sequence* GetDefaultObj()
	{
		return GetDefaultObjImpl<UAIAction_Sequence>();
	}
};
static_assert(alignof(UAIAction_Sequence) == 0x000008, "Wrong alignment on UAIAction_Sequence");
static_assert(sizeof(UAIAction_Sequence) == 0x0001E8, "Wrong size on UAIAction_Sequence");
static_assert(offsetof(UAIAction_Sequence, CanStartChecks) == 0x000160, "Member 'UAIAction_Sequence::CanStartChecks' has a wrong offset!");
static_assert(offsetof(UAIAction_Sequence, CanBeInterrupted) == 0x000168, "Member 'UAIAction_Sequence::CanBeInterrupted' has a wrong offset!");

// Class GbxAI.AIAction_GoToPoint
// 0x0DB8 (0x0FA0 - 0x01E8)
class UAIAction_GoToPoint : public UAIAction_Sequence
{
public:
	struct FAIAspectSettings_Location             LocationSettings;                                  // 0x01E8(0x01E0)(ContainsInstancedReference, NativeAccessSpecifierPublic)
	struct FGbxBlackboardKeySelector              GoalKey;                                           // 0x03C8(0x0010)(Edit, NoDestructor, NativeAccessSpecifierPublic)
	struct FAIAspectSettings_Navigation           NavSettings;                                       // 0x03D8(0x0140)(Edit, NoDestructor, ContainsInstancedReference, NativeAccessSpecifierPublic)
	bool                                          bUseNavSettings;                                   // 0x0518(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_519[0x7];                                      // 0x0519(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	class UAITicketDataAsset*                     MoveTicket;                                        // 0x0520(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FGbxParam                              MoveTicketHoldDuration;                            // 0x0528(0x0080)(Edit, NoDestructor, ContainsInstancedReference, NativeAccessSpecifierPublic)
	struct FGbxParam                              MoveFailTimeLimit;                                 // 0x05A8(0x0080)(Edit, NoDestructor, ContainsInstancedReference, NativeAccessSpecifierPublic)
	bool                                          bUseMoveFailTimeLimit;                             // 0x0628(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_629[0x7];                                      // 0x0629(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	struct FGbxBlackboardKeySelector              QueryKey;                                          // 0x0630(0x0010)(NoDestructor, NativeAccessSpecifierPublic)
	struct FAIAspectSettings_EnvQuery             QuerySettings;                                     // 0x0640(0x03A0)(Edit, ContainsInstancedReference, NativeAccessSpecifierPublic)
	bool                                          bUseQuery;                                         // 0x09E0(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_9E1[0x3];                                      // 0x09E1(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         MinOffsetInFrontOfTarget;                          // 0x09E4(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         MaxOffsetInFrontOfTarget;                          // 0x09E8(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         OffsetAngle;                                       // 0x09EC(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bUseOffsetInFrontOfTarget;                         // 0x09F0(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_9F1[0x3];                                      // 0x09F1(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         CirclingDistance;                                  // 0x09F4(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	ECircleDirection                              Direction;                                         // 0x09F8(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bRotateAroundTarget;                               // 0x09F9(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_9FA[0x6];                                      // 0x09FA(0x0006)(Fixing Size After Last Property [ Dumper-7 ])
	struct FGbxBlackboardKeySelector              CustomRotationTarget;                              // 0x0A00(0x0010)(Edit, NoDestructor, NativeAccessSpecifierPublic)
	bool                                          bUseCustomRotationTarget;                          // 0x0A10(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_A11[0x7];                                      // 0x0A11(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	struct FAIAspectSettings_Rotation             RotationSettings;                                  // 0x0A18(0x0550)(Edit, NoDestructor, ContainsInstancedReference, NativeAccessSpecifierPublic)
	bool                                          bUseRotation;                                      // 0x0F68(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bTestDirectPath;                                   // 0x0F69(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bDebugTestDirectPath;                              // 0x0F6A(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_F6B[0x5];                                      // 0x0F6B(0x0005)(Fixing Size After Last Property [ Dumper-7 ])
	UMulticastDelegateProperty_                   OnArrivedEventBP;                                  // 0x0F70(0x0010)(ZeroConstructor, Transient, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	uint8                                         Pad_F80[0x18];                                     // 0x0F80(0x0018)(Fixing Size After Last Property [ Dumper-7 ])
	uint8                                         GoToPointVersion;                                  // 0x0F98(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_F99[0x7];                                      // 0x0F99(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"AIAction_GoToPoint">();
	}
	static class UAIAction_GoToPoint* GetDefaultObj()
	{
		return GetDefaultObjImpl<UAIAction_GoToPoint>();
	}
};
static_assert(alignof(UAIAction_GoToPoint) == 0x000008, "Wrong alignment on UAIAction_GoToPoint");
static_assert(sizeof(UAIAction_GoToPoint) == 0x000FA0, "Wrong size on UAIAction_GoToPoint");
static_assert(offsetof(UAIAction_GoToPoint, LocationSettings) == 0x0001E8, "Member 'UAIAction_GoToPoint::LocationSettings' has a wrong offset!");
static_assert(offsetof(UAIAction_GoToPoint, GoalKey) == 0x0003C8, "Member 'UAIAction_GoToPoint::GoalKey' has a wrong offset!");
static_assert(offsetof(UAIAction_GoToPoint, NavSettings) == 0x0003D8, "Member 'UAIAction_GoToPoint::NavSettings' has a wrong offset!");
static_assert(offsetof(UAIAction_GoToPoint, bUseNavSettings) == 0x000518, "Member 'UAIAction_GoToPoint::bUseNavSettings' has a wrong offset!");
static_assert(offsetof(UAIAction_GoToPoint, MoveTicket) == 0x000520, "Member 'UAIAction_GoToPoint::MoveTicket' has a wrong offset!");
static_assert(offsetof(UAIAction_GoToPoint, MoveTicketHoldDuration) == 0x000528, "Member 'UAIAction_GoToPoint::MoveTicketHoldDuration' has a wrong offset!");
static_assert(offsetof(UAIAction_GoToPoint, MoveFailTimeLimit) == 0x0005A8, "Member 'UAIAction_GoToPoint::MoveFailTimeLimit' has a wrong offset!");
static_assert(offsetof(UAIAction_GoToPoint, bUseMoveFailTimeLimit) == 0x000628, "Member 'UAIAction_GoToPoint::bUseMoveFailTimeLimit' has a wrong offset!");
static_assert(offsetof(UAIAction_GoToPoint, QueryKey) == 0x000630, "Member 'UAIAction_GoToPoint::QueryKey' has a wrong offset!");
static_assert(offsetof(UAIAction_GoToPoint, QuerySettings) == 0x000640, "Member 'UAIAction_GoToPoint::QuerySettings' has a wrong offset!");
static_assert(offsetof(UAIAction_GoToPoint, bUseQuery) == 0x0009E0, "Member 'UAIAction_GoToPoint::bUseQuery' has a wrong offset!");
static_assert(offsetof(UAIAction_GoToPoint, MinOffsetInFrontOfTarget) == 0x0009E4, "Member 'UAIAction_GoToPoint::MinOffsetInFrontOfTarget' has a wrong offset!");
static_assert(offsetof(UAIAction_GoToPoint, MaxOffsetInFrontOfTarget) == 0x0009E8, "Member 'UAIAction_GoToPoint::MaxOffsetInFrontOfTarget' has a wrong offset!");
static_assert(offsetof(UAIAction_GoToPoint, OffsetAngle) == 0x0009EC, "Member 'UAIAction_GoToPoint::OffsetAngle' has a wrong offset!");
static_assert(offsetof(UAIAction_GoToPoint, bUseOffsetInFrontOfTarget) == 0x0009F0, "Member 'UAIAction_GoToPoint::bUseOffsetInFrontOfTarget' has a wrong offset!");
static_assert(offsetof(UAIAction_GoToPoint, CirclingDistance) == 0x0009F4, "Member 'UAIAction_GoToPoint::CirclingDistance' has a wrong offset!");
static_assert(offsetof(UAIAction_GoToPoint, Direction) == 0x0009F8, "Member 'UAIAction_GoToPoint::Direction' has a wrong offset!");
static_assert(offsetof(UAIAction_GoToPoint, bRotateAroundTarget) == 0x0009F9, "Member 'UAIAction_GoToPoint::bRotateAroundTarget' has a wrong offset!");
static_assert(offsetof(UAIAction_GoToPoint, CustomRotationTarget) == 0x000A00, "Member 'UAIAction_GoToPoint::CustomRotationTarget' has a wrong offset!");
static_assert(offsetof(UAIAction_GoToPoint, bUseCustomRotationTarget) == 0x000A10, "Member 'UAIAction_GoToPoint::bUseCustomRotationTarget' has a wrong offset!");
static_assert(offsetof(UAIAction_GoToPoint, RotationSettings) == 0x000A18, "Member 'UAIAction_GoToPoint::RotationSettings' has a wrong offset!");
static_assert(offsetof(UAIAction_GoToPoint, bUseRotation) == 0x000F68, "Member 'UAIAction_GoToPoint::bUseRotation' has a wrong offset!");
static_assert(offsetof(UAIAction_GoToPoint, bTestDirectPath) == 0x000F69, "Member 'UAIAction_GoToPoint::bTestDirectPath' has a wrong offset!");
static_assert(offsetof(UAIAction_GoToPoint, bDebugTestDirectPath) == 0x000F6A, "Member 'UAIAction_GoToPoint::bDebugTestDirectPath' has a wrong offset!");
static_assert(offsetof(UAIAction_GoToPoint, OnArrivedEventBP) == 0x000F70, "Member 'UAIAction_GoToPoint::OnArrivedEventBP' has a wrong offset!");
static_assert(offsetof(UAIAction_GoToPoint, GoToPointVersion) == 0x000F98, "Member 'UAIAction_GoToPoint::GoToPointVersion' has a wrong offset!");

// Class GbxAI.EnvQueryGenerator_FindPerch
// 0x0040 (0x00A0 - 0x0060)
class UEnvQueryGenerator_FindPerch final : public UEnvQueryGenerator
{
public:
	class UPerchType*                             PerchType;                                         // 0x0060(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	struct FAIDataProviderFloatValue              SearchRadius;                                      // 0x0068(0x0030)(Edit, DisableEditOnInstance, ContainsInstancedReference, NativeAccessSpecifierPrivate)
	TSubclassOf<class UEnvQueryContext>           SearchCenter;                                      // 0x0098(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"EnvQueryGenerator_FindPerch">();
	}
	static class UEnvQueryGenerator_FindPerch* GetDefaultObj()
	{
		return GetDefaultObjImpl<UEnvQueryGenerator_FindPerch>();
	}
};
static_assert(alignof(UEnvQueryGenerator_FindPerch) == 0x000008, "Wrong alignment on UEnvQueryGenerator_FindPerch");
static_assert(sizeof(UEnvQueryGenerator_FindPerch) == 0x0000A0, "Wrong size on UEnvQueryGenerator_FindPerch");
static_assert(offsetof(UEnvQueryGenerator_FindPerch, PerchType) == 0x000060, "Member 'UEnvQueryGenerator_FindPerch::PerchType' has a wrong offset!");
static_assert(offsetof(UEnvQueryGenerator_FindPerch, SearchRadius) == 0x000068, "Member 'UEnvQueryGenerator_FindPerch::SearchRadius' has a wrong offset!");
static_assert(offsetof(UEnvQueryGenerator_FindPerch, SearchCenter) == 0x000098, "Member 'UEnvQueryGenerator_FindPerch::SearchCenter' has a wrong offset!");

// Class GbxAI.AIAction_ActionAtPoint
// 0x0798 (0x1738 - 0x0FA0)
class UAIAction_ActionAtPoint : public UAIAction_GoToPoint
{
public:
	struct FAIAspectSettings_GbxAction            ActionSettings;                                    // 0x0FA0(0x0238)(Edit, NoDestructor, ContainsInstancedReference, NativeAccessSpecifierPublic)
	bool                                          bCheckLocationDuringAction;                        // 0x11D8(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bUseRotationDuringAction;                          // 0x11D9(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bUseRotationTargetDuringAction;                    // 0x11DA(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_11DB[0x5];                                     // 0x11DB(0x0005)(Fixing Size After Last Property [ Dumper-7 ])
	struct FAIAspectSettings_Rotation             ActionRotationSettings;                            // 0x11E0(0x0550)(Edit, NoDestructor, ContainsInstancedReference, NativeAccessSpecifierPublic)
	bool                                          bUseActionRotation;                                // 0x1730(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         ActionAtPointVersion;                              // 0x1731(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_1732[0x6];                                     // 0x1732(0x0006)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"AIAction_ActionAtPoint">();
	}
	static class UAIAction_ActionAtPoint* GetDefaultObj()
	{
		return GetDefaultObjImpl<UAIAction_ActionAtPoint>();
	}
};
static_assert(alignof(UAIAction_ActionAtPoint) == 0x000008, "Wrong alignment on UAIAction_ActionAtPoint");
static_assert(sizeof(UAIAction_ActionAtPoint) == 0x001738, "Wrong size on UAIAction_ActionAtPoint");
static_assert(offsetof(UAIAction_ActionAtPoint, ActionSettings) == 0x000FA0, "Member 'UAIAction_ActionAtPoint::ActionSettings' has a wrong offset!");
static_assert(offsetof(UAIAction_ActionAtPoint, bCheckLocationDuringAction) == 0x0011D8, "Member 'UAIAction_ActionAtPoint::bCheckLocationDuringAction' has a wrong offset!");
static_assert(offsetof(UAIAction_ActionAtPoint, bUseRotationDuringAction) == 0x0011D9, "Member 'UAIAction_ActionAtPoint::bUseRotationDuringAction' has a wrong offset!");
static_assert(offsetof(UAIAction_ActionAtPoint, bUseRotationTargetDuringAction) == 0x0011DA, "Member 'UAIAction_ActionAtPoint::bUseRotationTargetDuringAction' has a wrong offset!");
static_assert(offsetof(UAIAction_ActionAtPoint, ActionRotationSettings) == 0x0011E0, "Member 'UAIAction_ActionAtPoint::ActionRotationSettings' has a wrong offset!");
static_assert(offsetof(UAIAction_ActionAtPoint, bUseActionRotation) == 0x001730, "Member 'UAIAction_ActionAtPoint::bUseActionRotation' has a wrong offset!");
static_assert(offsetof(UAIAction_ActionAtPoint, ActionAtPointVersion) == 0x001731, "Member 'UAIAction_ActionAtPoint::ActionAtPointVersion' has a wrong offset!");

// Class GbxAI.BTTask_AIAction_ActionAtPoint
// 0x0008 (0x0080 - 0x0078)
class UBTTask_AIAction_ActionAtPoint final : public UBTTask_AIAction
{
public:
	class UAIAction_ActionAtPoint*                Action;                                            // 0x0078(0x0008)(Edit, ExportObject, ZeroConstructor, EditConst, InstancedReference, IsPlainOldData, NoDestructor, PersistentInstance, HasGetValueTypeHash, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"BTTask_AIAction_ActionAtPoint">();
	}
	static class UBTTask_AIAction_ActionAtPoint* GetDefaultObj()
	{
		return GetDefaultObjImpl<UBTTask_AIAction_ActionAtPoint>();
	}
};
static_assert(alignof(UBTTask_AIAction_ActionAtPoint) == 0x000008, "Wrong alignment on UBTTask_AIAction_ActionAtPoint");
static_assert(sizeof(UBTTask_AIAction_ActionAtPoint) == 0x000080, "Wrong size on UBTTask_AIAction_ActionAtPoint");
static_assert(offsetof(UBTTask_AIAction_ActionAtPoint, Action) == 0x000078, "Member 'UBTTask_AIAction_ActionAtPoint::Action' has a wrong offset!");

// Class GbxAI.GameplayTask_RunScriptedAIAction
// 0x0040 (0x00A8 - 0x0068)
class UGameplayTask_RunScriptedAIAction final : public UGameplayTask
{
public:
	class UAIActionComponent*                     ActionComponent;                                   // 0x0068(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TSubclassOf<class UAIAction>                  ActionToRun;                                       // 0x0070(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	UMulticastDelegateProperty_                   Succeeded;                                         // 0x0078(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	UMulticastDelegateProperty_                   Failed;                                            // 0x0088(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	UMulticastDelegateProperty_                   Aborted;                                           // 0x0098(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)

public:
	static class UGameplayTask_RunScriptedAIAction* RunScriptedAIAction_Actor(class AActor* Actor, TSubclassOf<class UAIAction> Action);
	static class UGameplayTask_RunScriptedAIAction* RunScriptedAIAction_AIActionComponent(class UAIActionComponent* AIActionComponent, TSubclassOf<class UAIAction> Action);
	static class UGameplayTask_RunScriptedAIAction* RunScriptedAIAction_Controller(class AGbxAIController* Controller, TSubclassOf<class UAIAction> Action);
	static class UGameplayTask_RunScriptedAIAction* RunScriptedAIAction_Object(class UObject* Object, TSubclassOf<class UAIAction> Action);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"GameplayTask_RunScriptedAIAction">();
	}
	static class UGameplayTask_RunScriptedAIAction* GetDefaultObj()
	{
		return GetDefaultObjImpl<UGameplayTask_RunScriptedAIAction>();
	}
};
static_assert(alignof(UGameplayTask_RunScriptedAIAction) == 0x000008, "Wrong alignment on UGameplayTask_RunScriptedAIAction");
static_assert(sizeof(UGameplayTask_RunScriptedAIAction) == 0x0000A8, "Wrong size on UGameplayTask_RunScriptedAIAction");
static_assert(offsetof(UGameplayTask_RunScriptedAIAction, ActionComponent) == 0x000068, "Member 'UGameplayTask_RunScriptedAIAction::ActionComponent' has a wrong offset!");
static_assert(offsetof(UGameplayTask_RunScriptedAIAction, ActionToRun) == 0x000070, "Member 'UGameplayTask_RunScriptedAIAction::ActionToRun' has a wrong offset!");
static_assert(offsetof(UGameplayTask_RunScriptedAIAction, Succeeded) == 0x000078, "Member 'UGameplayTask_RunScriptedAIAction::Succeeded' has a wrong offset!");
static_assert(offsetof(UGameplayTask_RunScriptedAIAction, Failed) == 0x000088, "Member 'UGameplayTask_RunScriptedAIAction::Failed' has a wrong offset!");
static_assert(offsetof(UGameplayTask_RunScriptedAIAction, Aborted) == 0x000098, "Member 'UGameplayTask_RunScriptedAIAction::Aborted' has a wrong offset!");

// Class GbxAI.AIAction_Priority
// 0x0010 (0x0170 - 0x0160)
class UAIAction_Priority : public UAIAction_Selector
{
public:
	float                                         TryInterruptPeriod;                                // 0x0160(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         TryInterruptInsignificantPeriod;                   // 0x0164(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bInterruptWhileInsignificant;                      // 0x0168(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_169[0x7];                                      // 0x0169(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"AIAction_Priority">();
	}
	static class UAIAction_Priority* GetDefaultObj()
	{
		return GetDefaultObjImpl<UAIAction_Priority>();
	}
};
static_assert(alignof(UAIAction_Priority) == 0x000008, "Wrong alignment on UAIAction_Priority");
static_assert(sizeof(UAIAction_Priority) == 0x000170, "Wrong size on UAIAction_Priority");
static_assert(offsetof(UAIAction_Priority, TryInterruptPeriod) == 0x000160, "Member 'UAIAction_Priority::TryInterruptPeriod' has a wrong offset!");
static_assert(offsetof(UAIAction_Priority, TryInterruptInsignificantPeriod) == 0x000164, "Member 'UAIAction_Priority::TryInterruptInsignificantPeriod' has a wrong offset!");
static_assert(offsetof(UAIAction_Priority, bInterruptWhileInsignificant) == 0x000168, "Member 'UAIAction_Priority::bInterruptWhileInsignificant' has a wrong offset!");

// Class GbxAI.AIAction_AITree
// 0x0000 (0x0170 - 0x0170)
class UAIAction_AITree : public UAIAction_Priority
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"AIAction_AITree">();
	}
	static class UAIAction_AITree* GetDefaultObj()
	{
		return GetDefaultObjImpl<UAIAction_AITree>();
	}
};
static_assert(alignof(UAIAction_AITree) == 0x000008, "Wrong alignment on UAIAction_AITree");
static_assert(sizeof(UAIAction_AITree) == 0x000170, "Wrong size on UAIAction_AITree");

// Class GbxAI.GbxAISystem
// 0x0010 (0x0140 - 0x0130)
class UGbxAISystem final : public UGbxAISystemBase
{
public:
	class UAIActionManager*                       AIActionManager;                                   // 0x0130(0x0008)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UAIGroupState*                          PlayerAIGroupState;                                // 0x0138(0x0008)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"GbxAISystem">();
	}
	static class UGbxAISystem* GetDefaultObj()
	{
		return GetDefaultObjImpl<UGbxAISystem>();
	}
};
static_assert(alignof(UGbxAISystem) == 0x000008, "Wrong alignment on UGbxAISystem");
static_assert(sizeof(UGbxAISystem) == 0x000140, "Wrong size on UGbxAISystem");
static_assert(offsetof(UGbxAISystem, AIActionManager) == 0x000130, "Member 'UGbxAISystem::AIActionManager' has a wrong offset!");
static_assert(offsetof(UGbxAISystem, PlayerAIGroupState) == 0x000138, "Member 'UGbxAISystem::PlayerAIGroupState' has a wrong offset!");

// Class GbxAI.AIActionComponent
// 0x0338 (0x0510 - 0x01D8)
class UAIActionComponent : public UBrainComponent
{
public:
	uint8                                         Pad_1D8[0x48];                                     // 0x01D8(0x0048)(Fixing Size After Last Property [ Dumper-7 ])
	TSubclassOf<class UAIAction>                  MainAction;                                        // 0x0220(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TSubclassOf<class UAIAction>                  ScriptedMoveAction;                                // 0x0228(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TSubclassOf<class UAIAction>                  ScriptedMoveSplineAction;                          // 0x0230(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TSubclassOf<class UAIAction>                  ScriptedMoveToLevelSequenceAction;                 // 0x0238(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TSubclassOf<class UAIAction>                  ScriptedLookAction;                                // 0x0240(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TSubclassOf<class UAIAction>                  ScriptedWaitAction;                                // 0x0248(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TSubclassOf<class UAIAction>                  ScriptedUseAction;                                 // 0x0250(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TSubclassOf<class UAIAction>                  ScriptedCoverAction;                               // 0x0258(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TSubclassOf<class UAIAction>                  ScriptedFollowAction;                              // 0x0260(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TSubclassOf<class UAIAction>                  ScriptedRouteAction;                               // 0x0268(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TSubclassOf<class UAIAction>                  ScriptedLeadAction;                                // 0x0270(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TSubclassOf<class UAIAction>                  ScriptedLandAction;                                // 0x0278(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TMap<struct FGameplayTag, TSubclassOf<class UAIAction>> TaggedActionTable;                                 // 0x0280(0x0050)(Edit, ZeroConstructor, Protected, UObjectWrapper, NativeAccessSpecifierProtected)
	struct FAIActionInstance                      ActionStack[0x2];                                  // 0x02D0(0x0030)(Transient, IsPlainOldData, NoDestructor, Protected, NativeAccessSpecifierProtected)
	uint8                                         Pad_330[0x1E0];                                    // 0x0330(0x01E0)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void AbortScriptedAIAction(bool bStopImmediately);
	void ReplaceMainAIAction(TSubclassOf<class UAIAction> Action);

	class UBlackboardData* GetBlackboardData() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"AIActionComponent">();
	}
	static class UAIActionComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UAIActionComponent>();
	}
};
static_assert(alignof(UAIActionComponent) == 0x000008, "Wrong alignment on UAIActionComponent");
static_assert(sizeof(UAIActionComponent) == 0x000510, "Wrong size on UAIActionComponent");
static_assert(offsetof(UAIActionComponent, MainAction) == 0x000220, "Member 'UAIActionComponent::MainAction' has a wrong offset!");
static_assert(offsetof(UAIActionComponent, ScriptedMoveAction) == 0x000228, "Member 'UAIActionComponent::ScriptedMoveAction' has a wrong offset!");
static_assert(offsetof(UAIActionComponent, ScriptedMoveSplineAction) == 0x000230, "Member 'UAIActionComponent::ScriptedMoveSplineAction' has a wrong offset!");
static_assert(offsetof(UAIActionComponent, ScriptedMoveToLevelSequenceAction) == 0x000238, "Member 'UAIActionComponent::ScriptedMoveToLevelSequenceAction' has a wrong offset!");
static_assert(offsetof(UAIActionComponent, ScriptedLookAction) == 0x000240, "Member 'UAIActionComponent::ScriptedLookAction' has a wrong offset!");
static_assert(offsetof(UAIActionComponent, ScriptedWaitAction) == 0x000248, "Member 'UAIActionComponent::ScriptedWaitAction' has a wrong offset!");
static_assert(offsetof(UAIActionComponent, ScriptedUseAction) == 0x000250, "Member 'UAIActionComponent::ScriptedUseAction' has a wrong offset!");
static_assert(offsetof(UAIActionComponent, ScriptedCoverAction) == 0x000258, "Member 'UAIActionComponent::ScriptedCoverAction' has a wrong offset!");
static_assert(offsetof(UAIActionComponent, ScriptedFollowAction) == 0x000260, "Member 'UAIActionComponent::ScriptedFollowAction' has a wrong offset!");
static_assert(offsetof(UAIActionComponent, ScriptedRouteAction) == 0x000268, "Member 'UAIActionComponent::ScriptedRouteAction' has a wrong offset!");
static_assert(offsetof(UAIActionComponent, ScriptedLeadAction) == 0x000270, "Member 'UAIActionComponent::ScriptedLeadAction' has a wrong offset!");
static_assert(offsetof(UAIActionComponent, ScriptedLandAction) == 0x000278, "Member 'UAIActionComponent::ScriptedLandAction' has a wrong offset!");
static_assert(offsetof(UAIActionComponent, TaggedActionTable) == 0x000280, "Member 'UAIActionComponent::TaggedActionTable' has a wrong offset!");
static_assert(offsetof(UAIActionComponent, ActionStack) == 0x0002D0, "Member 'UAIActionComponent::ActionStack' has a wrong offset!");

// Class GbxAI.EnvQueryTest_ActorHealth
// 0x0008 (0x01E0 - 0x01D8)
class UEnvQueryTest_ActorHealth final : public UEnvQueryTest
{
public:
	bool                                          bHealthPercentage;                                 // 0x01D8(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bHealthConsumed;                                   // 0x01D9(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1DA[0x6];                                      // 0x01DA(0x0006)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"EnvQueryTest_ActorHealth">();
	}
	static class UEnvQueryTest_ActorHealth* GetDefaultObj()
	{
		return GetDefaultObjImpl<UEnvQueryTest_ActorHealth>();
	}
};
static_assert(alignof(UEnvQueryTest_ActorHealth) == 0x000008, "Wrong alignment on UEnvQueryTest_ActorHealth");
static_assert(sizeof(UEnvQueryTest_ActorHealth) == 0x0001E0, "Wrong size on UEnvQueryTest_ActorHealth");
static_assert(offsetof(UEnvQueryTest_ActorHealth, bHealthPercentage) == 0x0001D8, "Member 'UEnvQueryTest_ActorHealth::bHealthPercentage' has a wrong offset!");
static_assert(offsetof(UEnvQueryTest_ActorHealth, bHealthConsumed) == 0x0001D9, "Member 'UEnvQueryTest_ActorHealth::bHealthConsumed' has a wrong offset!");

// Class GbxAI.AIAction_Charge
// 0x0018 (0x0FB8 - 0x0FA0)
class UAIAction_Charge final : public UAIAction_GoToPoint
{
public:
	struct FAIAspectSettings_Charge               ChargeSettings;                                    // 0x0FA0(0x0018)(Edit, NoDestructor, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"AIAction_Charge">();
	}
	static class UAIAction_Charge* GetDefaultObj()
	{
		return GetDefaultObjImpl<UAIAction_Charge>();
	}
};
static_assert(alignof(UAIAction_Charge) == 0x000008, "Wrong alignment on UAIAction_Charge");
static_assert(sizeof(UAIAction_Charge) == 0x000FB8, "Wrong size on UAIAction_Charge");
static_assert(offsetof(UAIAction_Charge, ChargeSettings) == 0x000FA0, "Member 'UAIAction_Charge::ChargeSettings' has a wrong offset!");

// Class GbxAI.BTTask_AIAction_Charge
// 0x0008 (0x0080 - 0x0078)
class UBTTask_AIAction_Charge final : public UBTTask_AIAction
{
public:
	class UAIAction_Charge*                       Action;                                            // 0x0078(0x0008)(Edit, ExportObject, ZeroConstructor, EditConst, InstancedReference, IsPlainOldData, NoDestructor, PersistentInstance, HasGetValueTypeHash, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"BTTask_AIAction_Charge">();
	}
	static class UBTTask_AIAction_Charge* GetDefaultObj()
	{
		return GetDefaultObjImpl<UBTTask_AIAction_Charge>();
	}
};
static_assert(alignof(UBTTask_AIAction_Charge) == 0x000008, "Wrong alignment on UBTTask_AIAction_Charge");
static_assert(sizeof(UBTTask_AIAction_Charge) == 0x000080, "Wrong size on UBTTask_AIAction_Charge");
static_assert(offsetof(UBTTask_AIAction_Charge, Action) == 0x000078, "Member 'UBTTask_AIAction_Charge::Action' has a wrong offset!");

// Class GbxAI.AIAction_CompositeChild
// 0x0010 (0x0158 - 0x0148)
class UAIAction_CompositeChild : public UAIAction
{
public:
	class UAIAction*                              Action;                                            // 0x0148(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bCanCauseParentToStop;                             // 0x0150(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_151[0x7];                                      // 0x0151(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	class UAIAction* CreateAction(class UClass* ActionClass);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"AIAction_CompositeChild">();
	}
	static class UAIAction_CompositeChild* GetDefaultObj()
	{
		return GetDefaultObjImpl<UAIAction_CompositeChild>();
	}
};
static_assert(alignof(UAIAction_CompositeChild) == 0x000008, "Wrong alignment on UAIAction_CompositeChild");
static_assert(sizeof(UAIAction_CompositeChild) == 0x000158, "Wrong size on UAIAction_CompositeChild");
static_assert(offsetof(UAIAction_CompositeChild, Action) == 0x000148, "Member 'UAIAction_CompositeChild::Action' has a wrong offset!");
static_assert(offsetof(UAIAction_CompositeChild, bCanCauseParentToStop) == 0x000150, "Member 'UAIAction_CompositeChild::bCanCauseParentToStop' has a wrong offset!");

// Class GbxAI.AIAction_Decorator
// 0x0000 (0x0148 - 0x0148)
class UAIAction_Decorator final : public UAIAction
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"AIAction_Decorator">();
	}
	static class UAIAction_Decorator* GetDefaultObj()
	{
		return GetDefaultObjImpl<UAIAction_Decorator>();
	}
};
static_assert(alignof(UAIAction_Decorator) == 0x000008, "Wrong alignment on UAIAction_Decorator");
static_assert(sizeof(UAIAction_Decorator) == 0x000148, "Wrong size on UAIAction_Decorator");

// Class GbxAI.AIAction_MoveNode
// 0x0158 (0x02C8 - 0x0170)
class UAIAction_MoveNode : public UAIAction_Priority
{
public:
	struct FGbxBlackboardKeySelector              NodeKey;                                           // 0x0170(0x0010)(Edit, NoDestructor, NativeAccessSpecifierPublic)
	struct FAIAspectSettings_Navigation           NavSettings;                                       // 0x0180(0x0140)(Edit, NoDestructor, ContainsInstancedReference, NativeAccessSpecifierPublic)
	uint8                                         MoveNodeVersion;                                   // 0x02C0(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_2C1[0x7];                                      // 0x02C1(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"AIAction_MoveNode">();
	}
	static class UAIAction_MoveNode* GetDefaultObj()
	{
		return GetDefaultObjImpl<UAIAction_MoveNode>();
	}
};
static_assert(alignof(UAIAction_MoveNode) == 0x000008, "Wrong alignment on UAIAction_MoveNode");
static_assert(sizeof(UAIAction_MoveNode) == 0x0002C8, "Wrong size on UAIAction_MoveNode");
static_assert(offsetof(UAIAction_MoveNode, NodeKey) == 0x000170, "Member 'UAIAction_MoveNode::NodeKey' has a wrong offset!");
static_assert(offsetof(UAIAction_MoveNode, NavSettings) == 0x000180, "Member 'UAIAction_MoveNode::NavSettings' has a wrong offset!");
static_assert(offsetof(UAIAction_MoveNode, MoveNodeVersion) == 0x0002C0, "Member 'UAIAction_MoveNode::MoveNodeVersion' has a wrong offset!");

// Class GbxAI.LookAtPointTag
// 0x01B0 (0x01E0 - 0x0030)
class ULookAtPointTag final : public UGbxDataAsset
{
public:
	ELookAtPointType                              LookAtPointType;                                   // 0x0030(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EFacingChannel                                FacingStyle;                                       // 0x0031(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_32[0x6];                                       // 0x0032(0x0006)(Fixing Size After Last Property [ Dumper-7 ])
	struct FGameplayTag                           ActionType;                                        // 0x0038(0x0008)(Edit, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         SearchHeight;                                      // 0x0040(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         SearchRadius;                                      // 0x0044(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FGbxParam                              UseChance;                                         // 0x0048(0x0080)(Edit, NoDestructor, ContainsInstancedReference, NativeAccessSpecifierPublic)
	class UGbxCondition*                          UseCondition;                                      // 0x00C8(0x0008)(Edit, ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, PersistentInstance, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bGetInCloser;                                      // 0x00D0(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_D1[0x3];                                       // 0x00D1(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         UseRadius;                                         // 0x00D4(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FGbxParam                              UsageTime;                                         // 0x00D8(0x0080)(Edit, NoDestructor, ContainsInstancedReference, NativeAccessSpecifierPublic)
	struct FGbxParam                              UserCooldownTime;                                  // 0x0158(0x0080)(Edit, NoDestructor, ContainsInstancedReference, NativeAccessSpecifierPublic)
	bool                                          bMaxUsers;                                         // 0x01D8(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1D9[0x3];                                      // 0x01D9(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	int32                                         MaxUsers;                                          // 0x01DC(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"LookAtPointTag">();
	}
	static class ULookAtPointTag* GetDefaultObj()
	{
		return GetDefaultObjImpl<ULookAtPointTag>();
	}
};
static_assert(alignof(ULookAtPointTag) == 0x000008, "Wrong alignment on ULookAtPointTag");
static_assert(sizeof(ULookAtPointTag) == 0x0001E0, "Wrong size on ULookAtPointTag");
static_assert(offsetof(ULookAtPointTag, LookAtPointType) == 0x000030, "Member 'ULookAtPointTag::LookAtPointType' has a wrong offset!");
static_assert(offsetof(ULookAtPointTag, FacingStyle) == 0x000031, "Member 'ULookAtPointTag::FacingStyle' has a wrong offset!");
static_assert(offsetof(ULookAtPointTag, ActionType) == 0x000038, "Member 'ULookAtPointTag::ActionType' has a wrong offset!");
static_assert(offsetof(ULookAtPointTag, SearchHeight) == 0x000040, "Member 'ULookAtPointTag::SearchHeight' has a wrong offset!");
static_assert(offsetof(ULookAtPointTag, SearchRadius) == 0x000044, "Member 'ULookAtPointTag::SearchRadius' has a wrong offset!");
static_assert(offsetof(ULookAtPointTag, UseChance) == 0x000048, "Member 'ULookAtPointTag::UseChance' has a wrong offset!");
static_assert(offsetof(ULookAtPointTag, UseCondition) == 0x0000C8, "Member 'ULookAtPointTag::UseCondition' has a wrong offset!");
static_assert(offsetof(ULookAtPointTag, bGetInCloser) == 0x0000D0, "Member 'ULookAtPointTag::bGetInCloser' has a wrong offset!");
static_assert(offsetof(ULookAtPointTag, UseRadius) == 0x0000D4, "Member 'ULookAtPointTag::UseRadius' has a wrong offset!");
static_assert(offsetof(ULookAtPointTag, UsageTime) == 0x0000D8, "Member 'ULookAtPointTag::UsageTime' has a wrong offset!");
static_assert(offsetof(ULookAtPointTag, UserCooldownTime) == 0x000158, "Member 'ULookAtPointTag::UserCooldownTime' has a wrong offset!");
static_assert(offsetof(ULookAtPointTag, bMaxUsers) == 0x0001D8, "Member 'ULookAtPointTag::bMaxUsers' has a wrong offset!");
static_assert(offsetof(ULookAtPointTag, MaxUsers) == 0x0001DC, "Member 'ULookAtPointTag::MaxUsers' has a wrong offset!");

// Class GbxAI.AIAction_Dropship
// 0x0000 (0x02C8 - 0x02C8)
class UAIAction_Dropship final : public UAIAction_MoveNode
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"AIAction_Dropship">();
	}
	static class UAIAction_Dropship* GetDefaultObj()
	{
		return GetDefaultObjImpl<UAIAction_Dropship>();
	}
};
static_assert(alignof(UAIAction_Dropship) == 0x000008, "Wrong alignment on UAIAction_Dropship");
static_assert(sizeof(UAIAction_Dropship) == 0x0002C8, "Wrong size on UAIAction_Dropship");

// Class GbxAI.AIAction_Follow
// 0x01E8 (0x0358 - 0x0170)
class UAIAction_Follow final : public UAIAction_Priority
{
public:
	struct FAIAspectSettings_Follow               Settings;                                          // 0x0170(0x0038)(Edit, NoDestructor, Protected, NativeAccessSpecifierProtected)
	struct FAIAspectSettings_Navigation           NavSettings;                                       // 0x01A8(0x0140)(Edit, NoDestructor, ContainsInstancedReference, Protected, NativeAccessSpecifierProtected)
	struct FAIAspectSettings_FindClosestPlayer    FindClosestPlayerSettings;                         // 0x02E8(0x0020)(Edit, NoDestructor, Protected, NativeAccessSpecifierProtected)
	bool                                          bFindClosestPlayer;                                // 0x0308(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_309[0x7];                                      // 0x0309(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	struct FGbxBlackboardKeySelector              TeleportTarget;                                    // 0x0310(0x0010)(NoDestructor, Protected, NativeAccessSpecifierProtected)
	struct FGbxBlackboardKeySelector              MoveTarget;                                        // 0x0320(0x0010)(NoDestructor, Protected, NativeAccessSpecifierProtected)
	struct FGbxBlackboardKeySelector              Distance;                                          // 0x0330(0x0010)(NoDestructor, Protected, NativeAccessSpecifierProtected)
	struct FGbxBlackboardKeySelector              BodyDirection;                                     // 0x0340(0x0010)(NoDestructor, Protected, NativeAccessSpecifierProtected)
	uint8                                         FollowVersion;                                     // 0x0350(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_351[0x7];                                      // 0x0351(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"AIAction_Follow">();
	}
	static class UAIAction_Follow* GetDefaultObj()
	{
		return GetDefaultObjImpl<UAIAction_Follow>();
	}
};
static_assert(alignof(UAIAction_Follow) == 0x000008, "Wrong alignment on UAIAction_Follow");
static_assert(sizeof(UAIAction_Follow) == 0x000358, "Wrong size on UAIAction_Follow");
static_assert(offsetof(UAIAction_Follow, Settings) == 0x000170, "Member 'UAIAction_Follow::Settings' has a wrong offset!");
static_assert(offsetof(UAIAction_Follow, NavSettings) == 0x0001A8, "Member 'UAIAction_Follow::NavSettings' has a wrong offset!");
static_assert(offsetof(UAIAction_Follow, FindClosestPlayerSettings) == 0x0002E8, "Member 'UAIAction_Follow::FindClosestPlayerSettings' has a wrong offset!");
static_assert(offsetof(UAIAction_Follow, bFindClosestPlayer) == 0x000308, "Member 'UAIAction_Follow::bFindClosestPlayer' has a wrong offset!");
static_assert(offsetof(UAIAction_Follow, TeleportTarget) == 0x000310, "Member 'UAIAction_Follow::TeleportTarget' has a wrong offset!");
static_assert(offsetof(UAIAction_Follow, MoveTarget) == 0x000320, "Member 'UAIAction_Follow::MoveTarget' has a wrong offset!");
static_assert(offsetof(UAIAction_Follow, Distance) == 0x000330, "Member 'UAIAction_Follow::Distance' has a wrong offset!");
static_assert(offsetof(UAIAction_Follow, BodyDirection) == 0x000340, "Member 'UAIAction_Follow::BodyDirection' has a wrong offset!");
static_assert(offsetof(UAIAction_Follow, FollowVersion) == 0x000350, "Member 'UAIAction_Follow::FollowVersion' has a wrong offset!");

// Class GbxAI.BTTask_AIAction_GoToPoint
// 0x0008 (0x0080 - 0x0078)
class UBTTask_AIAction_GoToPoint final : public UBTTask_AIAction
{
public:
	class UAIAction_GoToPoint*                    Action;                                            // 0x0078(0x0008)(Edit, ExportObject, ZeroConstructor, EditConst, InstancedReference, IsPlainOldData, NoDestructor, PersistentInstance, HasGetValueTypeHash, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"BTTask_AIAction_GoToPoint">();
	}
	static class UBTTask_AIAction_GoToPoint* GetDefaultObj()
	{
		return GetDefaultObjImpl<UBTTask_AIAction_GoToPoint>();
	}
};
static_assert(alignof(UBTTask_AIAction_GoToPoint) == 0x000008, "Wrong alignment on UBTTask_AIAction_GoToPoint");
static_assert(sizeof(UBTTask_AIAction_GoToPoint) == 0x000080, "Wrong size on UBTTask_AIAction_GoToPoint");
static_assert(offsetof(UBTTask_AIAction_GoToPoint, Action) == 0x000078, "Member 'UBTTask_AIAction_GoToPoint::Action' has a wrong offset!");

// Class GbxAI.AIAction_Land
// 0x0388 (0x0570 - 0x01E8)
class UAIAction_Land final : public UAIAction_Sequence
{
public:
	struct FAIAspectSettings_FlyToNavMesh         FlyToNavMeshSettings;                              // 0x01E8(0x0010)(Edit, NoDestructor, NativeAccessSpecifierPublic)
	struct FAIAspectSettings_GbxAction            AnimSettings;                                      // 0x01F8(0x0238)(Edit, NoDestructor, ContainsInstancedReference, NativeAccessSpecifierPublic)
	struct FAIAspectSettings_Navigation           NavSettings;                                       // 0x0430(0x0140)(Edit, NoDestructor, ContainsInstancedReference, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"AIAction_Land">();
	}
	static class UAIAction_Land* GetDefaultObj()
	{
		return GetDefaultObjImpl<UAIAction_Land>();
	}
};
static_assert(alignof(UAIAction_Land) == 0x000008, "Wrong alignment on UAIAction_Land");
static_assert(sizeof(UAIAction_Land) == 0x000570, "Wrong size on UAIAction_Land");
static_assert(offsetof(UAIAction_Land, FlyToNavMeshSettings) == 0x0001E8, "Member 'UAIAction_Land::FlyToNavMeshSettings' has a wrong offset!");
static_assert(offsetof(UAIAction_Land, AnimSettings) == 0x0001F8, "Member 'UAIAction_Land::AnimSettings' has a wrong offset!");
static_assert(offsetof(UAIAction_Land, NavSettings) == 0x000430, "Member 'UAIAction_Land::NavSettings' has a wrong offset!");

// Class GbxAI.PerchType
// 0x0000 (0x0030 - 0x0030)
class UPerchType final : public UGbxDataAsset
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"PerchType">();
	}
	static class UPerchType* GetDefaultObj()
	{
		return GetDefaultObjImpl<UPerchType>();
	}
};
static_assert(alignof(UPerchType) == 0x000008, "Wrong alignment on UPerchType");
static_assert(sizeof(UPerchType) == 0x000030, "Wrong size on UPerchType");

// Class GbxAI.AIAction_LeadRoute
// 0x01F8 (0x0368 - 0x0170)
class UAIAction_LeadRoute final : public UAIAction_Priority
{
public:
	struct FAIAspectSettings_LeadRoute            LeadSettings;                                      // 0x0170(0x0050)(Edit, NoDestructor, Protected, NativeAccessSpecifierProtected)
	struct FAIAspectSettings_Navigation           NavSettings;                                       // 0x01C0(0x0140)(Edit, NoDestructor, ContainsInstancedReference, Protected, NativeAccessSpecifierProtected)
	struct FAIAspectSettings_FindClosestPlayer    FindClosestPlayerSettings;                         // 0x0300(0x0020)(Edit, NoDestructor, Protected, NativeAccessSpecifierProtected)
	struct FGbxBlackboardKeySelector              MoveTarget;                                        // 0x0320(0x0010)(NoDestructor, Protected, NativeAccessSpecifierProtected)
	struct FGbxBlackboardKeySelector              Distance;                                          // 0x0330(0x0010)(NoDestructor, Protected, NativeAccessSpecifierProtected)
	struct FGbxBlackboardKeySelector              TeleportTarget;                                    // 0x0340(0x0010)(NoDestructor, Protected, NativeAccessSpecifierProtected)
	struct FGbxBlackboardKeySelector              UnusedKey;                                         // 0x0350(0x0010)(NoDestructor, Protected, NativeAccessSpecifierProtected)
	uint8                                         LeadRouteVersion;                                  // 0x0360(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_361[0x7];                                      // 0x0361(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"AIAction_LeadRoute">();
	}
	static class UAIAction_LeadRoute* GetDefaultObj()
	{
		return GetDefaultObjImpl<UAIAction_LeadRoute>();
	}
};
static_assert(alignof(UAIAction_LeadRoute) == 0x000008, "Wrong alignment on UAIAction_LeadRoute");
static_assert(sizeof(UAIAction_LeadRoute) == 0x000368, "Wrong size on UAIAction_LeadRoute");
static_assert(offsetof(UAIAction_LeadRoute, LeadSettings) == 0x000170, "Member 'UAIAction_LeadRoute::LeadSettings' has a wrong offset!");
static_assert(offsetof(UAIAction_LeadRoute, NavSettings) == 0x0001C0, "Member 'UAIAction_LeadRoute::NavSettings' has a wrong offset!");
static_assert(offsetof(UAIAction_LeadRoute, FindClosestPlayerSettings) == 0x000300, "Member 'UAIAction_LeadRoute::FindClosestPlayerSettings' has a wrong offset!");
static_assert(offsetof(UAIAction_LeadRoute, MoveTarget) == 0x000320, "Member 'UAIAction_LeadRoute::MoveTarget' has a wrong offset!");
static_assert(offsetof(UAIAction_LeadRoute, Distance) == 0x000330, "Member 'UAIAction_LeadRoute::Distance' has a wrong offset!");
static_assert(offsetof(UAIAction_LeadRoute, TeleportTarget) == 0x000340, "Member 'UAIAction_LeadRoute::TeleportTarget' has a wrong offset!");
static_assert(offsetof(UAIAction_LeadRoute, UnusedKey) == 0x000350, "Member 'UAIAction_LeadRoute::UnusedKey' has a wrong offset!");
static_assert(offsetof(UAIAction_LeadRoute, LeadRouteVersion) == 0x000360, "Member 'UAIAction_LeadRoute::LeadRouteVersion' has a wrong offset!");

// Class GbxAI.BTTask_AIAction_LeadRoute
// 0x0008 (0x0080 - 0x0078)
class UBTTask_AIAction_LeadRoute final : public UBTTask_AIAction
{
public:
	class UAIAction_LeadRoute*                    Action;                                            // 0x0078(0x0008)(Edit, ExportObject, ZeroConstructor, EditConst, InstancedReference, IsPlainOldData, NoDestructor, PersistentInstance, HasGetValueTypeHash, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"BTTask_AIAction_LeadRoute">();
	}
	static class UBTTask_AIAction_LeadRoute* GetDefaultObj()
	{
		return GetDefaultObjImpl<UBTTask_AIAction_LeadRoute>();
	}
};
static_assert(alignof(UBTTask_AIAction_LeadRoute) == 0x000008, "Wrong alignment on UBTTask_AIAction_LeadRoute");
static_assert(sizeof(UBTTask_AIAction_LeadRoute) == 0x000080, "Wrong size on UBTTask_AIAction_LeadRoute");
static_assert(offsetof(UBTTask_AIAction_LeadRoute, Action) == 0x000078, "Member 'UBTTask_AIAction_LeadRoute::Action' has a wrong offset!");

// Class GbxAI.AIAction_Leap
// 0x0058 (0x0FF8 - 0x0FA0)
class UAIAction_Leap final : public UAIAction_GoToPoint
{
public:
	struct FAIAspectSettings_Leap                 LeapSettings;                                      // 0x0FA0(0x0058)(Edit, NoDestructor, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"AIAction_Leap">();
	}
	static class UAIAction_Leap* GetDefaultObj()
	{
		return GetDefaultObjImpl<UAIAction_Leap>();
	}
};
static_assert(alignof(UAIAction_Leap) == 0x000008, "Wrong alignment on UAIAction_Leap");
static_assert(sizeof(UAIAction_Leap) == 0x000FF8, "Wrong size on UAIAction_Leap");
static_assert(offsetof(UAIAction_Leap, LeapSettings) == 0x000FA0, "Member 'UAIAction_Leap::LeapSettings' has a wrong offset!");

// Class GbxAI.BTTask_AIAction_Leap
// 0x0008 (0x0080 - 0x0078)
class UBTTask_AIAction_Leap final : public UBTTask_AIAction
{
public:
	class UAIAction_Leap*                         Action;                                            // 0x0078(0x0008)(Edit, ExportObject, ZeroConstructor, EditConst, InstancedReference, IsPlainOldData, NoDestructor, PersistentInstance, HasGetValueTypeHash, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"BTTask_AIAction_Leap">();
	}
	static class UBTTask_AIAction_Leap* GetDefaultObj()
	{
		return GetDefaultObjImpl<UBTTask_AIAction_Leap>();
	}
};
static_assert(alignof(UBTTask_AIAction_Leap) == 0x000008, "Wrong alignment on UBTTask_AIAction_Leap");
static_assert(sizeof(UBTTask_AIAction_Leap) == 0x000080, "Wrong size on UBTTask_AIAction_Leap");
static_assert(offsetof(UBTTask_AIAction_Leap, Action) == 0x000078, "Member 'UBTTask_AIAction_Leap::Action' has a wrong offset!");

// Class GbxAI.SmartObjectInterface
// 0x0000 (0x0028 - 0x0028)
class ISmartObjectInterface final : public IInterface
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"SmartObjectInterface">();
	}
	static class ISmartObjectInterface* GetDefaultObj()
	{
		return GetDefaultObjImpl<ISmartObjectInterface>();
	}
};
static_assert(alignof(ISmartObjectInterface) == 0x000008, "Wrong alignment on ISmartObjectInterface");
static_assert(sizeof(ISmartObjectInterface) == 0x000028, "Wrong size on ISmartObjectInterface");

// Class GbxAI.AIAction_LeapDirect
// 0x0400 (0x0548 - 0x0148)
class UAIAction_LeapDirect final : public UAIAction
{
public:
	struct FAIAspectSettings_Leap                 LeapSettings;                                      // 0x0148(0x0058)(Edit, NoDestructor, NativeAccessSpecifierPublic)
	struct FAIAspectSettings_EnvQuery             QuerySettings;                                     // 0x01A0(0x03A0)(Edit, ContainsInstancedReference, NativeAccessSpecifierPublic)
	bool                                          bUseQuery;                                         // 0x0540(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_541[0x7];                                      // 0x0541(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"AIAction_LeapDirect">();
	}
	static class UAIAction_LeapDirect* GetDefaultObj()
	{
		return GetDefaultObjImpl<UAIAction_LeapDirect>();
	}
};
static_assert(alignof(UAIAction_LeapDirect) == 0x000008, "Wrong alignment on UAIAction_LeapDirect");
static_assert(sizeof(UAIAction_LeapDirect) == 0x000548, "Wrong size on UAIAction_LeapDirect");
static_assert(offsetof(UAIAction_LeapDirect, LeapSettings) == 0x000148, "Member 'UAIAction_LeapDirect::LeapSettings' has a wrong offset!");
static_assert(offsetof(UAIAction_LeapDirect, QuerySettings) == 0x0001A0, "Member 'UAIAction_LeapDirect::QuerySettings' has a wrong offset!");
static_assert(offsetof(UAIAction_LeapDirect, bUseQuery) == 0x000540, "Member 'UAIAction_LeapDirect::bUseQuery' has a wrong offset!");

// Class GbxAI.BTTask_AIAction_LeapDirect
// 0x0008 (0x0080 - 0x0078)
class UBTTask_AIAction_LeapDirect final : public UBTTask_AIAction
{
public:
	class UAIAction_LeapDirect*                   Action;                                            // 0x0078(0x0008)(Edit, ExportObject, ZeroConstructor, EditConst, InstancedReference, IsPlainOldData, NoDestructor, PersistentInstance, HasGetValueTypeHash, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"BTTask_AIAction_LeapDirect">();
	}
	static class UBTTask_AIAction_LeapDirect* GetDefaultObj()
	{
		return GetDefaultObjImpl<UBTTask_AIAction_LeapDirect>();
	}
};
static_assert(alignof(UBTTask_AIAction_LeapDirect) == 0x000008, "Wrong alignment on UBTTask_AIAction_LeapDirect");
static_assert(sizeof(UBTTask_AIAction_LeapDirect) == 0x000080, "Wrong size on UBTTask_AIAction_LeapDirect");
static_assert(offsetof(UBTTask_AIAction_LeapDirect, Action) == 0x000078, "Member 'UBTTask_AIAction_LeapDirect::Action' has a wrong offset!");

// Class GbxAI.AIAction_LookAroundRandomly
// 0x0020 (0x0168 - 0x0148)
class UAIAction_LookAroundRandomly final : public UAIAction
{
public:
	struct FLookAroundRandomlySettings            Settings;                                          // 0x0148(0x000C)(Edit, NoDestructor, NativeAccessSpecifierPrivate)
	uint8                                         Pad_154[0x14];                                     // 0x0154(0x0014)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"AIAction_LookAroundRandomly">();
	}
	static class UAIAction_LookAroundRandomly* GetDefaultObj()
	{
		return GetDefaultObjImpl<UAIAction_LookAroundRandomly>();
	}
};
static_assert(alignof(UAIAction_LookAroundRandomly) == 0x000008, "Wrong alignment on UAIAction_LookAroundRandomly");
static_assert(sizeof(UAIAction_LookAroundRandomly) == 0x000168, "Wrong size on UAIAction_LookAroundRandomly");
static_assert(offsetof(UAIAction_LookAroundRandomly, Settings) == 0x000148, "Member 'UAIAction_LookAroundRandomly::Settings' has a wrong offset!");

// Class GbxAI.BTTask_AIAction_MoveNode
// 0x0008 (0x0080 - 0x0078)
class UBTTask_AIAction_MoveNode final : public UBTTask_AIAction
{
public:
	class UAIAction_MoveNode*                     Action;                                            // 0x0078(0x0008)(Edit, ExportObject, ZeroConstructor, EditConst, InstancedReference, IsPlainOldData, NoDestructor, PersistentInstance, HasGetValueTypeHash, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"BTTask_AIAction_MoveNode">();
	}
	static class UBTTask_AIAction_MoveNode* GetDefaultObj()
	{
		return GetDefaultObjImpl<UBTTask_AIAction_MoveNode>();
	}
};
static_assert(alignof(UBTTask_AIAction_MoveNode) == 0x000008, "Wrong alignment on UBTTask_AIAction_MoveNode");
static_assert(sizeof(UBTTask_AIAction_MoveNode) == 0x000080, "Wrong size on UBTTask_AIAction_MoveNode");
static_assert(offsetof(UBTTask_AIAction_MoveNode, Action) == 0x000078, "Member 'UBTTask_AIAction_MoveNode::Action' has a wrong offset!");

// Class GbxAI.SmartObjectPreviewComponent
// 0x0048 (0x0830 - 0x07E8)
class USmartObjectPreviewComponent final : public UPreviewComponent
{
public:
	TArray<struct FSmartObjectPreviewState>       PreviewList;                                       // 0x07E8(0x0010)(ZeroConstructor, Transient, DuplicateTransient, ContainsInstancedReference, Protected, NativeAccessSpecifierProtected)
	int32                                         ActiveAISlotIdx;                                   // 0x07F8(0x0004)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_7FC[0x4];                                      // 0x07FC(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	TSubclassOf<class UGbxAction>                 PreviewAction;                                     // 0x0800(0x0008)(Edit, ZeroConstructor, Transient, EditConst, IsPlainOldData, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bAutoCycle;                                        // 0x0808(0x0001)(Edit, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	struct FGbxTriggerProperty                    CycleActor;                                        // 0x0809(0x0001)(Edit, Transient, IsPlainOldData, NoDestructor, Protected, NativeAccessSpecifierProtected)
	bool                                          bShowAction;                                       // 0x080A(0x0001)(Edit, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bRepeatAction;                                     // 0x080B(0x0001)(Edit, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	struct FGbxTriggerProperty                    ReplayAction;                                      // 0x080C(0x0001)(Edit, Transient, IsPlainOldData, NoDestructor, Protected, NativeAccessSpecifierProtected)
	uint8                                         Pad_80D[0x3];                                      // 0x080D(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	TWeakObjectPtr<class UGbxActionComponent>     ActionComponent;                                   // 0x0810(0x0008)(ExportObject, ZeroConstructor, Transient, InstancedReference, IsPlainOldData, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_818[0x18];                                     // 0x0818(0x0018)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void OnCycleActor(ECycleDirection Direction);
	void OnReplayAction();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"SmartObjectPreviewComponent">();
	}
	static class USmartObjectPreviewComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<USmartObjectPreviewComponent>();
	}
};
static_assert(alignof(USmartObjectPreviewComponent) == 0x000008, "Wrong alignment on USmartObjectPreviewComponent");
static_assert(sizeof(USmartObjectPreviewComponent) == 0x000830, "Wrong size on USmartObjectPreviewComponent");
static_assert(offsetof(USmartObjectPreviewComponent, PreviewList) == 0x0007E8, "Member 'USmartObjectPreviewComponent::PreviewList' has a wrong offset!");
static_assert(offsetof(USmartObjectPreviewComponent, ActiveAISlotIdx) == 0x0007F8, "Member 'USmartObjectPreviewComponent::ActiveAISlotIdx' has a wrong offset!");
static_assert(offsetof(USmartObjectPreviewComponent, PreviewAction) == 0x000800, "Member 'USmartObjectPreviewComponent::PreviewAction' has a wrong offset!");
static_assert(offsetof(USmartObjectPreviewComponent, bAutoCycle) == 0x000808, "Member 'USmartObjectPreviewComponent::bAutoCycle' has a wrong offset!");
static_assert(offsetof(USmartObjectPreviewComponent, CycleActor) == 0x000809, "Member 'USmartObjectPreviewComponent::CycleActor' has a wrong offset!");
static_assert(offsetof(USmartObjectPreviewComponent, bShowAction) == 0x00080A, "Member 'USmartObjectPreviewComponent::bShowAction' has a wrong offset!");
static_assert(offsetof(USmartObjectPreviewComponent, bRepeatAction) == 0x00080B, "Member 'USmartObjectPreviewComponent::bRepeatAction' has a wrong offset!");
static_assert(offsetof(USmartObjectPreviewComponent, ReplayAction) == 0x00080C, "Member 'USmartObjectPreviewComponent::ReplayAction' has a wrong offset!");
static_assert(offsetof(USmartObjectPreviewComponent, ActionComponent) == 0x000810, "Member 'USmartObjectPreviewComponent::ActionComponent' has a wrong offset!");

// Class GbxAI.AIAction_MoveSpline
// 0x0190 (0x02D8 - 0x0148)
class UAIAction_MoveSpline final : public UAIAction
{
public:
	struct FAIAspectSettings_MoveSpline           MoveSplineSettings;                                // 0x0148(0x0050)(Edit, NoDestructor, NativeAccessSpecifierPublic)
	struct FAIAspectSettings_Navigation           NavSettings;                                       // 0x0198(0x0140)(Edit, NoDestructor, ContainsInstancedReference, NativeAccessSpecifierPublic)

public:
	static bool ChangeSplineOffset(class AActor* TargetActor, float Offset);
	static bool SetupMoveSpline(class AActor* TargetActor, class UObject* TargetSpline, float Offset, bool bIsReverse);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"AIAction_MoveSpline">();
	}
	static class UAIAction_MoveSpline* GetDefaultObj()
	{
		return GetDefaultObjImpl<UAIAction_MoveSpline>();
	}
};
static_assert(alignof(UAIAction_MoveSpline) == 0x000008, "Wrong alignment on UAIAction_MoveSpline");
static_assert(sizeof(UAIAction_MoveSpline) == 0x0002D8, "Wrong size on UAIAction_MoveSpline");
static_assert(offsetof(UAIAction_MoveSpline, MoveSplineSettings) == 0x000148, "Member 'UAIAction_MoveSpline::MoveSplineSettings' has a wrong offset!");
static_assert(offsetof(UAIAction_MoveSpline, NavSettings) == 0x000198, "Member 'UAIAction_MoveSpline::NavSettings' has a wrong offset!");

// Class GbxAI.AIAction_OnAggro
// 0x0478 (0x0660 - 0x01E8)
class UAIAction_OnAggro : public UAIAction_Sequence
{
public:
	bool                                          bRotateBeforeAction;                               // 0x01E8(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	bool                                          bRotateDuringAction;                               // 0x01E9(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_1EA[0x6];                                      // 0x01EA(0x0006)(Fixing Size After Last Property [ Dumper-7 ])
	struct FAIAspectSettings_GbxAction            ActionWhenFirstNoticer;                            // 0x01F0(0x0238)(Edit, NoDestructor, ContainsInstancedReference, NativeAccessSpecifierPrivate)
	struct FAIAspectSettings_GbxAction            ActionWhenSecondNoticer;                           // 0x0428(0x0238)(Edit, NoDestructor, ContainsInstancedReference, NativeAccessSpecifierPrivate)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"AIAction_OnAggro">();
	}
	static class UAIAction_OnAggro* GetDefaultObj()
	{
		return GetDefaultObjImpl<UAIAction_OnAggro>();
	}
};
static_assert(alignof(UAIAction_OnAggro) == 0x000008, "Wrong alignment on UAIAction_OnAggro");
static_assert(sizeof(UAIAction_OnAggro) == 0x000660, "Wrong size on UAIAction_OnAggro");
static_assert(offsetof(UAIAction_OnAggro, bRotateBeforeAction) == 0x0001E8, "Member 'UAIAction_OnAggro::bRotateBeforeAction' has a wrong offset!");
static_assert(offsetof(UAIAction_OnAggro, bRotateDuringAction) == 0x0001E9, "Member 'UAIAction_OnAggro::bRotateDuringAction' has a wrong offset!");
static_assert(offsetof(UAIAction_OnAggro, ActionWhenFirstNoticer) == 0x0001F0, "Member 'UAIAction_OnAggro::ActionWhenFirstNoticer' has a wrong offset!");
static_assert(offsetof(UAIAction_OnAggro, ActionWhenSecondNoticer) == 0x000428, "Member 'UAIAction_OnAggro::ActionWhenSecondNoticer' has a wrong offset!");

// Class GbxAI.AIAction_Orbit
// 0x08B0 (0x09F8 - 0x0148)
class UAIAction_Orbit : public UAIAction
{
public:
	struct FAIAspectSettings_Orbit                OrbitSettings;                                     // 0x0148(0x0220)(Edit, NoDestructor, ContainsInstancedReference, NativeAccessSpecifierPublic)
	struct FAIAspectSettings_Navigation           NavSettings;                                       // 0x0368(0x0140)(Edit, NoDestructor, ContainsInstancedReference, NativeAccessSpecifierPublic)
	struct FAIAspectSettings_Rotation             RotationSettings;                                  // 0x04A8(0x0550)(Edit, NoDestructor, ContainsInstancedReference, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"AIAction_Orbit">();
	}
	static class UAIAction_Orbit* GetDefaultObj()
	{
		return GetDefaultObjImpl<UAIAction_Orbit>();
	}
};
static_assert(alignof(UAIAction_Orbit) == 0x000008, "Wrong alignment on UAIAction_Orbit");
static_assert(sizeof(UAIAction_Orbit) == 0x0009F8, "Wrong size on UAIAction_Orbit");
static_assert(offsetof(UAIAction_Orbit, OrbitSettings) == 0x000148, "Member 'UAIAction_Orbit::OrbitSettings' has a wrong offset!");
static_assert(offsetof(UAIAction_Orbit, NavSettings) == 0x000368, "Member 'UAIAction_Orbit::NavSettings' has a wrong offset!");
static_assert(offsetof(UAIAction_Orbit, RotationSettings) == 0x0004A8, "Member 'UAIAction_Orbit::RotationSettings' has a wrong offset!");

// Class GbxAI.AIAction_Parallel
// 0x0008 (0x0168 - 0x0160)
class UAIAction_Parallel final : public UAIAction_Composite
{
public:
	bool                                          bWaitForAllChildren;                               // 0x0160(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_161[0x7];                                      // 0x0161(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"AIAction_Parallel">();
	}
	static class UAIAction_Parallel* GetDefaultObj()
	{
		return GetDefaultObjImpl<UAIAction_Parallel>();
	}
};
static_assert(alignof(UAIAction_Parallel) == 0x000008, "Wrong alignment on UAIAction_Parallel");
static_assert(sizeof(UAIAction_Parallel) == 0x000168, "Wrong size on UAIAction_Parallel");
static_assert(offsetof(UAIAction_Parallel, bWaitForAllChildren) == 0x000160, "Member 'UAIAction_Parallel::bWaitForAllChildren' has a wrong offset!");

// Class GbxAI.AIAction_ParallelChild
// 0x0008 (0x0160 - 0x0158)
class UAIAction_ParallelChild final : public UAIAction_CompositeChild
{
public:
	bool                                          bCanPreventActionFromStarting;                     // 0x0158(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bCanCauseActionToSucceed;                          // 0x0159(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bCanCauseActionToFail;                             // 0x015A(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bMustFinish;                                       // 0x015B(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_15C[0x4];                                      // 0x015C(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"AIAction_ParallelChild">();
	}
	static class UAIAction_ParallelChild* GetDefaultObj()
	{
		return GetDefaultObjImpl<UAIAction_ParallelChild>();
	}
};
static_assert(alignof(UAIAction_ParallelChild) == 0x000008, "Wrong alignment on UAIAction_ParallelChild");
static_assert(sizeof(UAIAction_ParallelChild) == 0x000160, "Wrong size on UAIAction_ParallelChild");
static_assert(offsetof(UAIAction_ParallelChild, bCanPreventActionFromStarting) == 0x000158, "Member 'UAIAction_ParallelChild::bCanPreventActionFromStarting' has a wrong offset!");
static_assert(offsetof(UAIAction_ParallelChild, bCanCauseActionToSucceed) == 0x000159, "Member 'UAIAction_ParallelChild::bCanCauseActionToSucceed' has a wrong offset!");
static_assert(offsetof(UAIAction_ParallelChild, bCanCauseActionToFail) == 0x00015A, "Member 'UAIAction_ParallelChild::bCanCauseActionToFail' has a wrong offset!");
static_assert(offsetof(UAIAction_ParallelChild, bMustFinish) == 0x00015B, "Member 'UAIAction_ParallelChild::bMustFinish' has a wrong offset!");

// Class GbxAI.AIAction_Plan
// 0x0020 (0x0208 - 0x01E8)
class UAIAction_Plan final : public UAIAction_Sequence
{
public:
	struct FAIActionSettings_Plan                 Settings;                                          // 0x01E8(0x0020)(Edit, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"AIAction_Plan">();
	}
	static class UAIAction_Plan* GetDefaultObj()
	{
		return GetDefaultObjImpl<UAIAction_Plan>();
	}
};
static_assert(alignof(UAIAction_Plan) == 0x000008, "Wrong alignment on UAIAction_Plan");
static_assert(sizeof(UAIAction_Plan) == 0x000208, "Wrong size on UAIAction_Plan");
static_assert(offsetof(UAIAction_Plan, Settings) == 0x0001E8, "Member 'UAIAction_Plan::Settings' has a wrong offset!");

// Class GbxAI.AIAction_PlayGbxAction
// 0x0238 (0x0380 - 0x0148)
class UAIAction_PlayGbxAction final : public UAIAction
{
public:
	struct FAIAspectSettings_GbxAction            ActionSettings;                                    // 0x0148(0x0238)(Edit, NoDestructor, ContainsInstancedReference, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"AIAction_PlayGbxAction">();
	}
	static class UAIAction_PlayGbxAction* GetDefaultObj()
	{
		return GetDefaultObjImpl<UAIAction_PlayGbxAction>();
	}
};
static_assert(alignof(UAIAction_PlayGbxAction) == 0x000008, "Wrong alignment on UAIAction_PlayGbxAction");
static_assert(sizeof(UAIAction_PlayGbxAction) == 0x000380, "Wrong size on UAIAction_PlayGbxAction");
static_assert(offsetof(UAIAction_PlayGbxAction, ActionSettings) == 0x000148, "Member 'UAIAction_PlayGbxAction::ActionSettings' has a wrong offset!");

// Class GbxAI.BTTask_AIAction_PlayGbxAction
// 0x0008 (0x0080 - 0x0078)
class UBTTask_AIAction_PlayGbxAction final : public UBTTask_AIAction
{
public:
	class UAIAction_PlayGbxAction*                Action;                                            // 0x0078(0x0008)(Edit, ExportObject, ZeroConstructor, EditConst, InstancedReference, IsPlainOldData, NoDestructor, PersistentInstance, HasGetValueTypeHash, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"BTTask_AIAction_PlayGbxAction">();
	}
	static class UBTTask_AIAction_PlayGbxAction* GetDefaultObj()
	{
		return GetDefaultObjImpl<UBTTask_AIAction_PlayGbxAction>();
	}
};
static_assert(alignof(UBTTask_AIAction_PlayGbxAction) == 0x000008, "Wrong alignment on UBTTask_AIAction_PlayGbxAction");
static_assert(sizeof(UBTTask_AIAction_PlayGbxAction) == 0x000080, "Wrong size on UBTTask_AIAction_PlayGbxAction");
static_assert(offsetof(UBTTask_AIAction_PlayGbxAction, Action) == 0x000078, "Member 'UBTTask_AIAction_PlayGbxAction::Action' has a wrong offset!");

// Class GbxAI.AIAction_Random
// 0x0008 (0x0168 - 0x0160)
class UAIAction_Random : public UAIAction_Selector
{
public:
	bool                                          bUseCumulativeInverseWeight;                       // 0x0160(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_161[0x3];                                      // 0x0161(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         ResetRunCountTime;                                 // 0x0164(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"AIAction_Random">();
	}
	static class UAIAction_Random* GetDefaultObj()
	{
		return GetDefaultObjImpl<UAIAction_Random>();
	}
};
static_assert(alignof(UAIAction_Random) == 0x000008, "Wrong alignment on UAIAction_Random");
static_assert(sizeof(UAIAction_Random) == 0x000168, "Wrong size on UAIAction_Random");
static_assert(offsetof(UAIAction_Random, bUseCumulativeInverseWeight) == 0x000160, "Member 'UAIAction_Random::bUseCumulativeInverseWeight' has a wrong offset!");
static_assert(offsetof(UAIAction_Random, ResetRunCountTime) == 0x000164, "Member 'UAIAction_Random::ResetRunCountTime' has a wrong offset!");

// Class GbxAI.AIAction_RandomChild
// 0x0010 (0x0168 - 0x0158)
class UAIAction_RandomChild final : public UAIAction_CompositeChild
{
public:
	float                                         Weight;                                            // 0x0158(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         MaxRunCount;                                       // 0x015C(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bUseMaxRunCount;                                   // 0x0160(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_161[0x7];                                      // 0x0161(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"AIAction_RandomChild">();
	}
	static class UAIAction_RandomChild* GetDefaultObj()
	{
		return GetDefaultObjImpl<UAIAction_RandomChild>();
	}
};
static_assert(alignof(UAIAction_RandomChild) == 0x000008, "Wrong alignment on UAIAction_RandomChild");
static_assert(sizeof(UAIAction_RandomChild) == 0x000168, "Wrong size on UAIAction_RandomChild");
static_assert(offsetof(UAIAction_RandomChild, Weight) == 0x000158, "Member 'UAIAction_RandomChild::Weight' has a wrong offset!");
static_assert(offsetof(UAIAction_RandomChild, MaxRunCount) == 0x00015C, "Member 'UAIAction_RandomChild::MaxRunCount' has a wrong offset!");
static_assert(offsetof(UAIAction_RandomChild, bUseMaxRunCount) == 0x000160, "Member 'UAIAction_RandomChild::bUseMaxRunCount' has a wrong offset!");

// Class GbxAI.AIAction_Route
// 0x01E0 (0x03C8 - 0x01E8)
class UAIAction_Route final : public UAIAction_Sequence
{
public:
	struct FAIAspectSettings_Route                RouteSettings;                                     // 0x01E8(0x0028)(Edit, NoDestructor, Protected, NativeAccessSpecifierProtected)
	struct FAIAspectSettings_Navigation           NavSettings;                                       // 0x0210(0x0140)(Edit, NoDestructor, ContainsInstancedReference, Protected, NativeAccessSpecifierProtected)
	struct FGbxBlackboardKeySelector              SmartAction;                                       // 0x0350(0x0010)(NoDestructor, Protected, NativeAccessSpecifierProtected)
	struct FGbxBlackboardKeySelector              MoveTarget;                                        // 0x0360(0x0010)(NoDestructor, Protected, NativeAccessSpecifierProtected)
	struct FGbxBlackboardKeySelector              Distance;                                          // 0x0370(0x0010)(NoDestructor, Protected, NativeAccessSpecifierProtected)
	struct FGbxBlackboardKeySelector              BodyEnable;                                        // 0x0380(0x0010)(NoDestructor, Protected, NativeAccessSpecifierProtected)
	struct FGbxBlackboardKeySelector              BodyTarget;                                        // 0x0390(0x0010)(NoDestructor, Protected, NativeAccessSpecifierProtected)
	struct FGbxBlackboardKeySelector              LookEnable;                                        // 0x03A0(0x0010)(NoDestructor, Protected, NativeAccessSpecifierProtected)
	struct FGbxBlackboardKeySelector              LookTarget;                                        // 0x03B0(0x0010)(NoDestructor, Protected, NativeAccessSpecifierProtected)
	uint8                                         RouteVersion;                                      // 0x03C0(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_3C1[0x7];                                      // 0x03C1(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"AIAction_Route">();
	}
	static class UAIAction_Route* GetDefaultObj()
	{
		return GetDefaultObjImpl<UAIAction_Route>();
	}
};
static_assert(alignof(UAIAction_Route) == 0x000008, "Wrong alignment on UAIAction_Route");
static_assert(sizeof(UAIAction_Route) == 0x0003C8, "Wrong size on UAIAction_Route");
static_assert(offsetof(UAIAction_Route, RouteSettings) == 0x0001E8, "Member 'UAIAction_Route::RouteSettings' has a wrong offset!");
static_assert(offsetof(UAIAction_Route, NavSettings) == 0x000210, "Member 'UAIAction_Route::NavSettings' has a wrong offset!");
static_assert(offsetof(UAIAction_Route, SmartAction) == 0x000350, "Member 'UAIAction_Route::SmartAction' has a wrong offset!");
static_assert(offsetof(UAIAction_Route, MoveTarget) == 0x000360, "Member 'UAIAction_Route::MoveTarget' has a wrong offset!");
static_assert(offsetof(UAIAction_Route, Distance) == 0x000370, "Member 'UAIAction_Route::Distance' has a wrong offset!");
static_assert(offsetof(UAIAction_Route, BodyEnable) == 0x000380, "Member 'UAIAction_Route::BodyEnable' has a wrong offset!");
static_assert(offsetof(UAIAction_Route, BodyTarget) == 0x000390, "Member 'UAIAction_Route::BodyTarget' has a wrong offset!");
static_assert(offsetof(UAIAction_Route, LookEnable) == 0x0003A0, "Member 'UAIAction_Route::LookEnable' has a wrong offset!");
static_assert(offsetof(UAIAction_Route, LookTarget) == 0x0003B0, "Member 'UAIAction_Route::LookTarget' has a wrong offset!");
static_assert(offsetof(UAIAction_Route, RouteVersion) == 0x0003C0, "Member 'UAIAction_Route::RouteVersion' has a wrong offset!");

// Class GbxAI.BTTask_AIAction_Route
// 0x0008 (0x0080 - 0x0078)
class UBTTask_AIAction_Route final : public UBTTask_AIAction
{
public:
	class UAIAction_Route*                        Action;                                            // 0x0078(0x0008)(Edit, ExportObject, ZeroConstructor, EditConst, InstancedReference, IsPlainOldData, NoDestructor, PersistentInstance, HasGetValueTypeHash, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"BTTask_AIAction_Route">();
	}
	static class UBTTask_AIAction_Route* GetDefaultObj()
	{
		return GetDefaultObjImpl<UBTTask_AIAction_Route>();
	}
};
static_assert(alignof(UBTTask_AIAction_Route) == 0x000008, "Wrong alignment on UBTTask_AIAction_Route");
static_assert(sizeof(UBTTask_AIAction_Route) == 0x000080, "Wrong size on UBTTask_AIAction_Route");
static_assert(offsetof(UBTTask_AIAction_Route, Action) == 0x000078, "Member 'UBTTask_AIAction_Route::Action' has a wrong offset!");

// Class GbxAI.AIAction_UseCover
// 0x0E98 (0x1008 - 0x0170)
class UAIAction_UseCover : public UAIAction_Priority
{
public:
	bool                                          bCanShootWhileMoving;                              // 0x0170(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         UseCoverVersion;                                   // 0x0171(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_172[0x6];                                      // 0x0172(0x0006)(Fixing Size After Last Property [ Dumper-7 ])
	struct FAIAspectSettings_UseCover             CoverSettings;                                     // 0x0178(0x0138)(Edit, NoDestructor, ContainsInstancedReference, Protected, NativeAccessSpecifierProtected)
	struct FEnvQueryParams                        CoverQuery;                                        // 0x02B0(0x00B8)(Edit, ContainsInstancedReference, Protected, NativeAccessSpecifierProtected)
	struct FGbxQueryOptions                       CoverQueryOptions;                                 // 0x0368(0x0238)(Edit, NoDestructor, ContainsInstancedReference, Protected, NativeAccessSpecifierProtected)
	struct FAIAspectSettings_Weapon               WeaponSettings;                                    // 0x05A0(0x03D0)(Edit, ContainsInstancedReference, Protected, NativeAccessSpecifierProtected)
	struct FAIAspectSettings_Navigation           NavSettings;                                       // 0x0970(0x0140)(Edit, NoDestructor, ContainsInstancedReference, Protected, NativeAccessSpecifierProtected)
	struct FAIAspectSettings_Rotation             MovingRotationSettings;                            // 0x0AB0(0x0550)(Edit, NoDestructor, ContainsInstancedReference, Protected, NativeAccessSpecifierProtected)
	bool                                          bRotateDuringMovement;                             // 0x1000(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_1001[0x7];                                     // 0x1001(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"AIAction_UseCover">();
	}
	static class UAIAction_UseCover* GetDefaultObj()
	{
		return GetDefaultObjImpl<UAIAction_UseCover>();
	}
};
static_assert(alignof(UAIAction_UseCover) == 0x000008, "Wrong alignment on UAIAction_UseCover");
static_assert(sizeof(UAIAction_UseCover) == 0x001008, "Wrong size on UAIAction_UseCover");
static_assert(offsetof(UAIAction_UseCover, bCanShootWhileMoving) == 0x000170, "Member 'UAIAction_UseCover::bCanShootWhileMoving' has a wrong offset!");
static_assert(offsetof(UAIAction_UseCover, UseCoverVersion) == 0x000171, "Member 'UAIAction_UseCover::UseCoverVersion' has a wrong offset!");
static_assert(offsetof(UAIAction_UseCover, CoverSettings) == 0x000178, "Member 'UAIAction_UseCover::CoverSettings' has a wrong offset!");
static_assert(offsetof(UAIAction_UseCover, CoverQuery) == 0x0002B0, "Member 'UAIAction_UseCover::CoverQuery' has a wrong offset!");
static_assert(offsetof(UAIAction_UseCover, CoverQueryOptions) == 0x000368, "Member 'UAIAction_UseCover::CoverQueryOptions' has a wrong offset!");
static_assert(offsetof(UAIAction_UseCover, WeaponSettings) == 0x0005A0, "Member 'UAIAction_UseCover::WeaponSettings' has a wrong offset!");
static_assert(offsetof(UAIAction_UseCover, NavSettings) == 0x000970, "Member 'UAIAction_UseCover::NavSettings' has a wrong offset!");
static_assert(offsetof(UAIAction_UseCover, MovingRotationSettings) == 0x000AB0, "Member 'UAIAction_UseCover::MovingRotationSettings' has a wrong offset!");
static_assert(offsetof(UAIAction_UseCover, bRotateDuringMovement) == 0x001000, "Member 'UAIAction_UseCover::bRotateDuringMovement' has a wrong offset!");

// Class GbxAI.AIAction_SimpleCover
// 0x01B8 (0x11C0 - 0x1008)
class UAIAction_SimpleCover final : public UAIAction_UseCover
{
public:
	bool                                          bTakeRangesFromWeapon;                             // 0x1008(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_1009[0x7];                                     // 0x1009(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	struct FGbxParam                              MinRange;                                          // 0x1010(0x0080)(Edit, NoDestructor, ContainsInstancedReference, NativeAccessSpecifierPrivate)
	struct FGbxParam                              IdealRange;                                        // 0x1090(0x0080)(Edit, NoDestructor, ContainsInstancedReference, NativeAccessSpecifierPrivate)
	struct FGbxParam                              MaxRange;                                          // 0x1110(0x0080)(Edit, NoDestructor, ContainsInstancedReference, NativeAccessSpecifierPrivate)
	TArray<class UEnvQueryTestAsset*>             AdditionalTests;                                   // 0x1190(0x0010)(Edit, ZeroConstructor, NativeAccessSpecifierPrivate)
	struct FSoftObjectPath                        DefaultEnvQuery;                                   // 0x11A0(0x0018)(Config, GlobalConfig, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         SimpleCoverVersion;                                // 0x11B8(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_11B9[0x7];                                     // 0x11B9(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"AIAction_SimpleCover">();
	}
	static class UAIAction_SimpleCover* GetDefaultObj()
	{
		return GetDefaultObjImpl<UAIAction_SimpleCover>();
	}
};
static_assert(alignof(UAIAction_SimpleCover) == 0x000008, "Wrong alignment on UAIAction_SimpleCover");
static_assert(sizeof(UAIAction_SimpleCover) == 0x0011C0, "Wrong size on UAIAction_SimpleCover");
static_assert(offsetof(UAIAction_SimpleCover, bTakeRangesFromWeapon) == 0x001008, "Member 'UAIAction_SimpleCover::bTakeRangesFromWeapon' has a wrong offset!");
static_assert(offsetof(UAIAction_SimpleCover, MinRange) == 0x001010, "Member 'UAIAction_SimpleCover::MinRange' has a wrong offset!");
static_assert(offsetof(UAIAction_SimpleCover, IdealRange) == 0x001090, "Member 'UAIAction_SimpleCover::IdealRange' has a wrong offset!");
static_assert(offsetof(UAIAction_SimpleCover, MaxRange) == 0x001110, "Member 'UAIAction_SimpleCover::MaxRange' has a wrong offset!");
static_assert(offsetof(UAIAction_SimpleCover, AdditionalTests) == 0x001190, "Member 'UAIAction_SimpleCover::AdditionalTests' has a wrong offset!");
static_assert(offsetof(UAIAction_SimpleCover, DefaultEnvQuery) == 0x0011A0, "Member 'UAIAction_SimpleCover::DefaultEnvQuery' has a wrong offset!");
static_assert(offsetof(UAIAction_SimpleCover, SimpleCoverVersion) == 0x0011B8, "Member 'UAIAction_SimpleCover::SimpleCoverVersion' has a wrong offset!");

// Class GbxAI.AIAction_WeaponAtPoint
// 0x0460 (0x1400 - 0x0FA0)
class UAIAction_WeaponAtPoint : public UAIAction_GoToPoint
{
public:
	bool                                          bCanShootWhileMoving;                              // 0x0FA0(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_FA1[0x7];                                      // 0x0FA1(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	struct FAIAspectSettings_Weapon               WeaponSettings;                                    // 0x0FA8(0x03D0)(Edit, ContainsInstancedReference, NativeAccessSpecifierPublic)
	struct FGbxParam                              HoldDuration;                                      // 0x1378(0x0080)(Edit, NoDestructor, ContainsInstancedReference, NativeAccessSpecifierPublic)
	bool                                          bUseHoldDuration;                                  // 0x13F8(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         WeaponAtPointVersion;                              // 0x13F9(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_13FA[0x6];                                     // 0x13FA(0x0006)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"AIAction_WeaponAtPoint">();
	}
	static class UAIAction_WeaponAtPoint* GetDefaultObj()
	{
		return GetDefaultObjImpl<UAIAction_WeaponAtPoint>();
	}
};
static_assert(alignof(UAIAction_WeaponAtPoint) == 0x000008, "Wrong alignment on UAIAction_WeaponAtPoint");
static_assert(sizeof(UAIAction_WeaponAtPoint) == 0x001400, "Wrong size on UAIAction_WeaponAtPoint");
static_assert(offsetof(UAIAction_WeaponAtPoint, bCanShootWhileMoving) == 0x000FA0, "Member 'UAIAction_WeaponAtPoint::bCanShootWhileMoving' has a wrong offset!");
static_assert(offsetof(UAIAction_WeaponAtPoint, WeaponSettings) == 0x000FA8, "Member 'UAIAction_WeaponAtPoint::WeaponSettings' has a wrong offset!");
static_assert(offsetof(UAIAction_WeaponAtPoint, HoldDuration) == 0x001378, "Member 'UAIAction_WeaponAtPoint::HoldDuration' has a wrong offset!");
static_assert(offsetof(UAIAction_WeaponAtPoint, bUseHoldDuration) == 0x0013F8, "Member 'UAIAction_WeaponAtPoint::bUseHoldDuration' has a wrong offset!");
static_assert(offsetof(UAIAction_WeaponAtPoint, WeaponAtPointVersion) == 0x0013F9, "Member 'UAIAction_WeaponAtPoint::WeaponAtPointVersion' has a wrong offset!");

// Class GbxAI.AIAction_SimpleHide
// 0x05F8 (0x19F8 - 0x1400)
class UAIAction_SimpleHide final : public UAIAction_WeaponAtPoint
{
public:
	struct FGbxParam                              MinRange;                                          // 0x1400(0x0080)(Edit, NoDestructor, ContainsInstancedReference, NativeAccessSpecifierPrivate)
	struct FGbxParam                              IdealRange;                                        // 0x1480(0x0080)(Edit, NoDestructor, ContainsInstancedReference, NativeAccessSpecifierPrivate)
	struct FGbxParam                              MaxRange;                                          // 0x1500(0x0080)(Edit, NoDestructor, ContainsInstancedReference, NativeAccessSpecifierPrivate)
	struct FGbxParam                              FaceTarget;                                        // 0x1580(0x0080)(Edit, NoDestructor, ContainsInstancedReference, NativeAccessSpecifierPrivate)
	struct FGbxParam                              CanUseWeaponWhileMoving;                           // 0x1600(0x0080)(Edit, NoDestructor, ContainsInstancedReference, NativeAccessSpecifierPrivate)
	TArray<class UGbxWeaponSlotData*>             WeaponSlots;                                       // 0x1680(0x0010)(Edit, ZeroConstructor, NativeAccessSpecifierPrivate)
	struct FGbxParam                              WeaponUseModeIndex;                                // 0x1690(0x0080)(Edit, NoDestructor, ContainsInstancedReference, NativeAccessSpecifierPrivate)
	struct FGbxParam                              HideDuration;                                      // 0x1710(0x0080)(Edit, NoDestructor, ContainsInstancedReference, NativeAccessSpecifierPrivate)
	struct FAIAspectSettings_GbxAction            HideActionSettings;                                // 0x1790(0x0238)(Edit, NoDestructor, ContainsInstancedReference, NativeAccessSpecifierPrivate)
	bool                                          bUseHideAction;                                    // 0x19C8(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_19C9[0x7];                                     // 0x19C9(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	struct FSoftObjectPath                        DefaultEnvQuery;                                   // 0x19D0(0x0018)(Config, GlobalConfig, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UEnvQuery*                              DefaultEnvQueryAsset;                              // 0x19E8(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         SimpleHideVersion;                                 // 0x19F0(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_19F1[0x7];                                     // 0x19F1(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"AIAction_SimpleHide">();
	}
	static class UAIAction_SimpleHide* GetDefaultObj()
	{
		return GetDefaultObjImpl<UAIAction_SimpleHide>();
	}
};
static_assert(alignof(UAIAction_SimpleHide) == 0x000008, "Wrong alignment on UAIAction_SimpleHide");
static_assert(sizeof(UAIAction_SimpleHide) == 0x0019F8, "Wrong size on UAIAction_SimpleHide");
static_assert(offsetof(UAIAction_SimpleHide, MinRange) == 0x001400, "Member 'UAIAction_SimpleHide::MinRange' has a wrong offset!");
static_assert(offsetof(UAIAction_SimpleHide, IdealRange) == 0x001480, "Member 'UAIAction_SimpleHide::IdealRange' has a wrong offset!");
static_assert(offsetof(UAIAction_SimpleHide, MaxRange) == 0x001500, "Member 'UAIAction_SimpleHide::MaxRange' has a wrong offset!");
static_assert(offsetof(UAIAction_SimpleHide, FaceTarget) == 0x001580, "Member 'UAIAction_SimpleHide::FaceTarget' has a wrong offset!");
static_assert(offsetof(UAIAction_SimpleHide, CanUseWeaponWhileMoving) == 0x001600, "Member 'UAIAction_SimpleHide::CanUseWeaponWhileMoving' has a wrong offset!");
static_assert(offsetof(UAIAction_SimpleHide, WeaponSlots) == 0x001680, "Member 'UAIAction_SimpleHide::WeaponSlots' has a wrong offset!");
static_assert(offsetof(UAIAction_SimpleHide, WeaponUseModeIndex) == 0x001690, "Member 'UAIAction_SimpleHide::WeaponUseModeIndex' has a wrong offset!");
static_assert(offsetof(UAIAction_SimpleHide, HideDuration) == 0x001710, "Member 'UAIAction_SimpleHide::HideDuration' has a wrong offset!");
static_assert(offsetof(UAIAction_SimpleHide, HideActionSettings) == 0x001790, "Member 'UAIAction_SimpleHide::HideActionSettings' has a wrong offset!");
static_assert(offsetof(UAIAction_SimpleHide, bUseHideAction) == 0x0019C8, "Member 'UAIAction_SimpleHide::bUseHideAction' has a wrong offset!");
static_assert(offsetof(UAIAction_SimpleHide, DefaultEnvQuery) == 0x0019D0, "Member 'UAIAction_SimpleHide::DefaultEnvQuery' has a wrong offset!");
static_assert(offsetof(UAIAction_SimpleHide, DefaultEnvQueryAsset) == 0x0019E8, "Member 'UAIAction_SimpleHide::DefaultEnvQueryAsset' has a wrong offset!");
static_assert(offsetof(UAIAction_SimpleHide, SimpleHideVersion) == 0x0019F0, "Member 'UAIAction_SimpleHide::SimpleHideVersion' has a wrong offset!");

// Class GbxAI.AIAction_SimpleMelee
// 0x04E0 (0x1C18 - 0x1738)
class UAIAction_SimpleMelee final : public UAIAction_ActionAtPoint
{
public:
	TSubclassOf<class UGbxAction>                 MeleeAction;                                       // 0x1738(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	struct FAIAspectSettings_GbxAction            MeleeActionSettings;                               // 0x1740(0x0238)(Edit, NoDestructor, ContainsInstancedReference, NativeAccessSpecifierPrivate)
	bool                                          bCanMove;                                          // 0x1978(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_1979[0x7];                                     // 0x1979(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	struct FGbxParam                              ReachedHeight;                                     // 0x1980(0x0080)(Edit, NoDestructor, ContainsInstancedReference, NativeAccessSpecifierPrivate)
	struct FGbxParam                              ReachedDistance;                                   // 0x1A00(0x0080)(Edit, NoDestructor, ContainsInstancedReference, NativeAccessSpecifierPrivate)
	EMeleeRotationOption                          FacingPolicyDuringAction;                          // 0x1A80(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_1A81[0x7];                                     // 0x1A81(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	struct FGbxParam                              OverrideAngle;                                     // 0x1A88(0x0080)(Edit, NoDestructor, ContainsInstancedReference, NativeAccessSpecifierPrivate)
	bool                                          bUseOverrideAngle;                                 // 0x1B08(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	bool                                          bAlignBodyWithTarget;                              // 0x1B09(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	bool                                          bKeepFacingTargetOnStop;                           // 0x1B0A(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	bool                                          bStopWhenReached;                                  // 0x1B0B(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	bool                                          bCanStartWhenGoalIsUncertain;                      // 0x1B0C(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_1B0D[0x3];                                     // 0x1B0D(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	struct FGbxParam                              Count;                                             // 0x1B10(0x0080)(Edit, NoDestructor, ContainsInstancedReference, NativeAccessSpecifierPrivate)
	struct FGbxParam                              PlayRate;                                          // 0x1B90(0x0080)(Edit, NoDestructor, ContainsInstancedReference, NativeAccessSpecifierPrivate)
	bool                                          bCanBeInterrupted;                                 // 0x1C10(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         MeleeActionVersion;                                // 0x1C11(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_1C12[0x6];                                     // 0x1C12(0x0006)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"AIAction_SimpleMelee">();
	}
	static class UAIAction_SimpleMelee* GetDefaultObj()
	{
		return GetDefaultObjImpl<UAIAction_SimpleMelee>();
	}
};
static_assert(alignof(UAIAction_SimpleMelee) == 0x000008, "Wrong alignment on UAIAction_SimpleMelee");
static_assert(sizeof(UAIAction_SimpleMelee) == 0x001C18, "Wrong size on UAIAction_SimpleMelee");
static_assert(offsetof(UAIAction_SimpleMelee, MeleeAction) == 0x001738, "Member 'UAIAction_SimpleMelee::MeleeAction' has a wrong offset!");
static_assert(offsetof(UAIAction_SimpleMelee, MeleeActionSettings) == 0x001740, "Member 'UAIAction_SimpleMelee::MeleeActionSettings' has a wrong offset!");
static_assert(offsetof(UAIAction_SimpleMelee, bCanMove) == 0x001978, "Member 'UAIAction_SimpleMelee::bCanMove' has a wrong offset!");
static_assert(offsetof(UAIAction_SimpleMelee, ReachedHeight) == 0x001980, "Member 'UAIAction_SimpleMelee::ReachedHeight' has a wrong offset!");
static_assert(offsetof(UAIAction_SimpleMelee, ReachedDistance) == 0x001A00, "Member 'UAIAction_SimpleMelee::ReachedDistance' has a wrong offset!");
static_assert(offsetof(UAIAction_SimpleMelee, FacingPolicyDuringAction) == 0x001A80, "Member 'UAIAction_SimpleMelee::FacingPolicyDuringAction' has a wrong offset!");
static_assert(offsetof(UAIAction_SimpleMelee, OverrideAngle) == 0x001A88, "Member 'UAIAction_SimpleMelee::OverrideAngle' has a wrong offset!");
static_assert(offsetof(UAIAction_SimpleMelee, bUseOverrideAngle) == 0x001B08, "Member 'UAIAction_SimpleMelee::bUseOverrideAngle' has a wrong offset!");
static_assert(offsetof(UAIAction_SimpleMelee, bAlignBodyWithTarget) == 0x001B09, "Member 'UAIAction_SimpleMelee::bAlignBodyWithTarget' has a wrong offset!");
static_assert(offsetof(UAIAction_SimpleMelee, bKeepFacingTargetOnStop) == 0x001B0A, "Member 'UAIAction_SimpleMelee::bKeepFacingTargetOnStop' has a wrong offset!");
static_assert(offsetof(UAIAction_SimpleMelee, bStopWhenReached) == 0x001B0B, "Member 'UAIAction_SimpleMelee::bStopWhenReached' has a wrong offset!");
static_assert(offsetof(UAIAction_SimpleMelee, bCanStartWhenGoalIsUncertain) == 0x001B0C, "Member 'UAIAction_SimpleMelee::bCanStartWhenGoalIsUncertain' has a wrong offset!");
static_assert(offsetof(UAIAction_SimpleMelee, Count) == 0x001B10, "Member 'UAIAction_SimpleMelee::Count' has a wrong offset!");
static_assert(offsetof(UAIAction_SimpleMelee, PlayRate) == 0x001B90, "Member 'UAIAction_SimpleMelee::PlayRate' has a wrong offset!");
static_assert(offsetof(UAIAction_SimpleMelee, bCanBeInterrupted) == 0x001C10, "Member 'UAIAction_SimpleMelee::bCanBeInterrupted' has a wrong offset!");
static_assert(offsetof(UAIAction_SimpleMelee, MeleeActionVersion) == 0x001C11, "Member 'UAIAction_SimpleMelee::MeleeActionVersion' has a wrong offset!");

// Class GbxAI.AIAction_SimpleRangedAttack
// 0x03F0 (0x1B28 - 0x1738)
class UAIAction_SimpleRangedAttack final : public UAIAction_ActionAtPoint
{
public:
	struct FGbxParam                              MinRange;                                          // 0x1738(0x0080)(Edit, NoDestructor, ContainsInstancedReference, NativeAccessSpecifierPrivate)
	struct FGbxParam                              IdealRange;                                        // 0x17B8(0x0080)(Edit, NoDestructor, ContainsInstancedReference, NativeAccessSpecifierPrivate)
	struct FGbxParam                              MaxRange;                                          // 0x1838(0x0080)(Edit, NoDestructor, ContainsInstancedReference, NativeAccessSpecifierPrivate)
	struct FGbxParam                              MinRepositionDistance;                             // 0x18B8(0x0080)(Edit, NoDestructor, ContainsInstancedReference, NativeAccessSpecifierPrivate)
	TArray<class UEnvQueryTestAsset*>             AdditionalTests;                                   // 0x1938(0x0010)(Edit, ZeroConstructor, NativeAccessSpecifierPrivate)
	float                                         SphereTraceExtent;                                 // 0x1948(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	bool                                          bDoArcTrace;                                       // 0x194C(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_194D[0x3];                                     // 0x194D(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	struct FGbxParam                              ArcSpeed;                                          // 0x1950(0x0080)(Edit, NoDestructor, ContainsInstancedReference, NativeAccessSpecifierPrivate)
	struct FGbxParam                              ArcAnglePercent;                                   // 0x19D0(0x0080)(Edit, NoDestructor, ContainsInstancedReference, NativeAccessSpecifierPrivate)
	struct FGbxParam                              OverrideAngle;                                     // 0x1A50(0x0080)(Edit, NoDestructor, ContainsInstancedReference, NativeAccessSpecifierPrivate)
	bool                                          bUseOverrideAngle;                                 // 0x1AD0(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	EMeleeRotationOption                          FacingPolicyDuringAction;                          // 0x1AD1(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	bool                                          bAlignBodyWithTarget;                              // 0x1AD2(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	bool                                          bKeepFacingTargetOnStop;                           // 0x1AD3(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	bool                                          bDistanceToTargetTestShouldFilterOnly;             // 0x1AD4(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_1AD5[0x3];                                     // 0x1AD5(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	struct FSoftObjectPath                        DefaultEnvQuery;                                   // 0x1AD8(0x0018)(Config, GlobalConfig, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	struct FSoftObjectPath                        DefaultTraceTests;                                 // 0x1AF0(0x0018)(Config, GlobalConfig, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UEnvQuery*                              DefaultEnvQueryAsset;                              // 0x1B08(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UEnvQuery*                              DefaultTraceTestsAsset;                            // 0x1B10(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UEnvQueryTest_Trace*                    TraceTestInstance;                                 // 0x1B18(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         SimpleRangedAttackVersion;                         // 0x1B20(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_1B21[0x7];                                     // 0x1B21(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"AIAction_SimpleRangedAttack">();
	}
	static class UAIAction_SimpleRangedAttack* GetDefaultObj()
	{
		return GetDefaultObjImpl<UAIAction_SimpleRangedAttack>();
	}
};
static_assert(alignof(UAIAction_SimpleRangedAttack) == 0x000008, "Wrong alignment on UAIAction_SimpleRangedAttack");
static_assert(sizeof(UAIAction_SimpleRangedAttack) == 0x001B28, "Wrong size on UAIAction_SimpleRangedAttack");
static_assert(offsetof(UAIAction_SimpleRangedAttack, MinRange) == 0x001738, "Member 'UAIAction_SimpleRangedAttack::MinRange' has a wrong offset!");
static_assert(offsetof(UAIAction_SimpleRangedAttack, IdealRange) == 0x0017B8, "Member 'UAIAction_SimpleRangedAttack::IdealRange' has a wrong offset!");
static_assert(offsetof(UAIAction_SimpleRangedAttack, MaxRange) == 0x001838, "Member 'UAIAction_SimpleRangedAttack::MaxRange' has a wrong offset!");
static_assert(offsetof(UAIAction_SimpleRangedAttack, MinRepositionDistance) == 0x0018B8, "Member 'UAIAction_SimpleRangedAttack::MinRepositionDistance' has a wrong offset!");
static_assert(offsetof(UAIAction_SimpleRangedAttack, AdditionalTests) == 0x001938, "Member 'UAIAction_SimpleRangedAttack::AdditionalTests' has a wrong offset!");
static_assert(offsetof(UAIAction_SimpleRangedAttack, SphereTraceExtent) == 0x001948, "Member 'UAIAction_SimpleRangedAttack::SphereTraceExtent' has a wrong offset!");
static_assert(offsetof(UAIAction_SimpleRangedAttack, bDoArcTrace) == 0x00194C, "Member 'UAIAction_SimpleRangedAttack::bDoArcTrace' has a wrong offset!");
static_assert(offsetof(UAIAction_SimpleRangedAttack, ArcSpeed) == 0x001950, "Member 'UAIAction_SimpleRangedAttack::ArcSpeed' has a wrong offset!");
static_assert(offsetof(UAIAction_SimpleRangedAttack, ArcAnglePercent) == 0x0019D0, "Member 'UAIAction_SimpleRangedAttack::ArcAnglePercent' has a wrong offset!");
static_assert(offsetof(UAIAction_SimpleRangedAttack, OverrideAngle) == 0x001A50, "Member 'UAIAction_SimpleRangedAttack::OverrideAngle' has a wrong offset!");
static_assert(offsetof(UAIAction_SimpleRangedAttack, bUseOverrideAngle) == 0x001AD0, "Member 'UAIAction_SimpleRangedAttack::bUseOverrideAngle' has a wrong offset!");
static_assert(offsetof(UAIAction_SimpleRangedAttack, FacingPolicyDuringAction) == 0x001AD1, "Member 'UAIAction_SimpleRangedAttack::FacingPolicyDuringAction' has a wrong offset!");
static_assert(offsetof(UAIAction_SimpleRangedAttack, bAlignBodyWithTarget) == 0x001AD2, "Member 'UAIAction_SimpleRangedAttack::bAlignBodyWithTarget' has a wrong offset!");
static_assert(offsetof(UAIAction_SimpleRangedAttack, bKeepFacingTargetOnStop) == 0x001AD3, "Member 'UAIAction_SimpleRangedAttack::bKeepFacingTargetOnStop' has a wrong offset!");
static_assert(offsetof(UAIAction_SimpleRangedAttack, bDistanceToTargetTestShouldFilterOnly) == 0x001AD4, "Member 'UAIAction_SimpleRangedAttack::bDistanceToTargetTestShouldFilterOnly' has a wrong offset!");
static_assert(offsetof(UAIAction_SimpleRangedAttack, DefaultEnvQuery) == 0x001AD8, "Member 'UAIAction_SimpleRangedAttack::DefaultEnvQuery' has a wrong offset!");
static_assert(offsetof(UAIAction_SimpleRangedAttack, DefaultTraceTests) == 0x001AF0, "Member 'UAIAction_SimpleRangedAttack::DefaultTraceTests' has a wrong offset!");
static_assert(offsetof(UAIAction_SimpleRangedAttack, DefaultEnvQueryAsset) == 0x001B08, "Member 'UAIAction_SimpleRangedAttack::DefaultEnvQueryAsset' has a wrong offset!");
static_assert(offsetof(UAIAction_SimpleRangedAttack, DefaultTraceTestsAsset) == 0x001B10, "Member 'UAIAction_SimpleRangedAttack::DefaultTraceTestsAsset' has a wrong offset!");
static_assert(offsetof(UAIAction_SimpleRangedAttack, TraceTestInstance) == 0x001B18, "Member 'UAIAction_SimpleRangedAttack::TraceTestInstance' has a wrong offset!");
static_assert(offsetof(UAIAction_SimpleRangedAttack, SimpleRangedAttackVersion) == 0x001B20, "Member 'UAIAction_SimpleRangedAttack::SimpleRangedAttackVersion' has a wrong offset!");

// Class GbxAI.AIAction_SimpleWeapon
// 0x0620 (0x1A20 - 0x1400)
class UAIAction_SimpleWeapon final : public UAIAction_WeaponAtPoint
{
public:
	struct FGbxParam                              CanUseWeaponWhileMoving;                           // 0x1400(0x0080)(Edit, NoDestructor, ContainsInstancedReference, NativeAccessSpecifierPrivate)
	bool                                          bTakeRangesFromWeapon;                             // 0x1480(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_1481[0x7];                                     // 0x1481(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	struct FGbxParam                              MinRange;                                          // 0x1488(0x0080)(Edit, NoDestructor, ContainsInstancedReference, NativeAccessSpecifierPrivate)
	struct FGbxParam                              IdealRange;                                        // 0x1508(0x0080)(Edit, NoDestructor, ContainsInstancedReference, NativeAccessSpecifierPrivate)
	struct FGbxParam                              MaxRange;                                          // 0x1588(0x0080)(Edit, NoDestructor, ContainsInstancedReference, NativeAccessSpecifierPrivate)
	TArray<class UEnvQueryTestAsset*>             AdditionalTests;                                   // 0x1608(0x0010)(Edit, ZeroConstructor, NativeAccessSpecifierPrivate)
	TArray<class UGbxWeaponSlotData*>             WeaponSlots;                                       // 0x1618(0x0010)(Edit, ZeroConstructor, NativeAccessSpecifierPrivate)
	struct FGbxParam                              WeaponUseModeIndex;                                // 0x1628(0x0080)(Edit, NoDestructor, ContainsInstancedReference, NativeAccessSpecifierPrivate)
	struct FGbxParam                              BurstCountOverride;                                // 0x16A8(0x0080)(Edit, NoDestructor, ContainsInstancedReference, NativeAccessSpecifierPrivate)
	bool                                          bOverrideBurstCount;                               // 0x1728(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_1729[0x7];                                     // 0x1729(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	struct FGbxParam                              BurstDelayOverride;                                // 0x1730(0x0080)(Edit, NoDestructor, ContainsInstancedReference, NativeAccessSpecifierPrivate)
	bool                                          bOverrideBurstDelay;                               // 0x17B0(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_17B1[0x7];                                     // 0x17B1(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	struct FGbxParam                              AccuracyOverride;                                  // 0x17B8(0x0080)(Edit, NoDestructor, ContainsInstancedReference, NativeAccessSpecifierPrivate)
	bool                                          bOverrideAccuracy;                                 // 0x1838(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_1839[0x7];                                     // 0x1839(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	struct FGbxParam                              SuppressingFireTime;                               // 0x1840(0x0080)(Edit, NoDestructor, ContainsInstancedReference, NativeAccessSpecifierPrivate)
	bool                                          bUseSuppressingFireTime;                           // 0x18C0(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	bool                                          bUseRepositionTicket;                              // 0x18C1(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_18C2[0x6];                                     // 0x18C2(0x0006)(Fixing Size After Last Property [ Dumper-7 ])
	struct FGbxParam                              MinRepositionDistance;                             // 0x18C8(0x0080)(Edit, NoDestructor, ContainsInstancedReference, NativeAccessSpecifierPrivate)
	class UAITicketDataAsset*                     RepositionTicket;                                  // 0x1948(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	struct FGbxParam                              TimeToStayAtSpotWhileShooting;                     // 0x1950(0x0080)(Edit, NoDestructor, ContainsInstancedReference, NativeAccessSpecifierPrivate)
	bool                                          bDistanceToTargetTestShouldFilterOnly;             // 0x19D0(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_19D1[0x7];                                     // 0x19D1(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	struct FSoftObjectPath                        DefaultEnvQuery;                                   // 0x19D8(0x0018)(Config, GlobalConfig, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	struct FSoftObjectPath                        DefaultRepositionTicket;                           // 0x19F0(0x0018)(Config, GlobalConfig, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UEnvQuery*                              DefaultEnvQueryAsset;                              // 0x1A08(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UAITicketDataAsset*                     DefaultRepositionTicketAsset;                      // 0x1A10(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         SimpleWeaponVersion;                               // 0x1A18(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_1A19[0x7];                                     // 0x1A19(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"AIAction_SimpleWeapon">();
	}
	static class UAIAction_SimpleWeapon* GetDefaultObj()
	{
		return GetDefaultObjImpl<UAIAction_SimpleWeapon>();
	}
};
static_assert(alignof(UAIAction_SimpleWeapon) == 0x000008, "Wrong alignment on UAIAction_SimpleWeapon");
static_assert(sizeof(UAIAction_SimpleWeapon) == 0x001A20, "Wrong size on UAIAction_SimpleWeapon");
static_assert(offsetof(UAIAction_SimpleWeapon, CanUseWeaponWhileMoving) == 0x001400, "Member 'UAIAction_SimpleWeapon::CanUseWeaponWhileMoving' has a wrong offset!");
static_assert(offsetof(UAIAction_SimpleWeapon, bTakeRangesFromWeapon) == 0x001480, "Member 'UAIAction_SimpleWeapon::bTakeRangesFromWeapon' has a wrong offset!");
static_assert(offsetof(UAIAction_SimpleWeapon, MinRange) == 0x001488, "Member 'UAIAction_SimpleWeapon::MinRange' has a wrong offset!");
static_assert(offsetof(UAIAction_SimpleWeapon, IdealRange) == 0x001508, "Member 'UAIAction_SimpleWeapon::IdealRange' has a wrong offset!");
static_assert(offsetof(UAIAction_SimpleWeapon, MaxRange) == 0x001588, "Member 'UAIAction_SimpleWeapon::MaxRange' has a wrong offset!");
static_assert(offsetof(UAIAction_SimpleWeapon, AdditionalTests) == 0x001608, "Member 'UAIAction_SimpleWeapon::AdditionalTests' has a wrong offset!");
static_assert(offsetof(UAIAction_SimpleWeapon, WeaponSlots) == 0x001618, "Member 'UAIAction_SimpleWeapon::WeaponSlots' has a wrong offset!");
static_assert(offsetof(UAIAction_SimpleWeapon, WeaponUseModeIndex) == 0x001628, "Member 'UAIAction_SimpleWeapon::WeaponUseModeIndex' has a wrong offset!");
static_assert(offsetof(UAIAction_SimpleWeapon, BurstCountOverride) == 0x0016A8, "Member 'UAIAction_SimpleWeapon::BurstCountOverride' has a wrong offset!");
static_assert(offsetof(UAIAction_SimpleWeapon, bOverrideBurstCount) == 0x001728, "Member 'UAIAction_SimpleWeapon::bOverrideBurstCount' has a wrong offset!");
static_assert(offsetof(UAIAction_SimpleWeapon, BurstDelayOverride) == 0x001730, "Member 'UAIAction_SimpleWeapon::BurstDelayOverride' has a wrong offset!");
static_assert(offsetof(UAIAction_SimpleWeapon, bOverrideBurstDelay) == 0x0017B0, "Member 'UAIAction_SimpleWeapon::bOverrideBurstDelay' has a wrong offset!");
static_assert(offsetof(UAIAction_SimpleWeapon, AccuracyOverride) == 0x0017B8, "Member 'UAIAction_SimpleWeapon::AccuracyOverride' has a wrong offset!");
static_assert(offsetof(UAIAction_SimpleWeapon, bOverrideAccuracy) == 0x001838, "Member 'UAIAction_SimpleWeapon::bOverrideAccuracy' has a wrong offset!");
static_assert(offsetof(UAIAction_SimpleWeapon, SuppressingFireTime) == 0x001840, "Member 'UAIAction_SimpleWeapon::SuppressingFireTime' has a wrong offset!");
static_assert(offsetof(UAIAction_SimpleWeapon, bUseSuppressingFireTime) == 0x0018C0, "Member 'UAIAction_SimpleWeapon::bUseSuppressingFireTime' has a wrong offset!");
static_assert(offsetof(UAIAction_SimpleWeapon, bUseRepositionTicket) == 0x0018C1, "Member 'UAIAction_SimpleWeapon::bUseRepositionTicket' has a wrong offset!");
static_assert(offsetof(UAIAction_SimpleWeapon, MinRepositionDistance) == 0x0018C8, "Member 'UAIAction_SimpleWeapon::MinRepositionDistance' has a wrong offset!");
static_assert(offsetof(UAIAction_SimpleWeapon, RepositionTicket) == 0x001948, "Member 'UAIAction_SimpleWeapon::RepositionTicket' has a wrong offset!");
static_assert(offsetof(UAIAction_SimpleWeapon, TimeToStayAtSpotWhileShooting) == 0x001950, "Member 'UAIAction_SimpleWeapon::TimeToStayAtSpotWhileShooting' has a wrong offset!");
static_assert(offsetof(UAIAction_SimpleWeapon, bDistanceToTargetTestShouldFilterOnly) == 0x0019D0, "Member 'UAIAction_SimpleWeapon::bDistanceToTargetTestShouldFilterOnly' has a wrong offset!");
static_assert(offsetof(UAIAction_SimpleWeapon, DefaultEnvQuery) == 0x0019D8, "Member 'UAIAction_SimpleWeapon::DefaultEnvQuery' has a wrong offset!");
static_assert(offsetof(UAIAction_SimpleWeapon, DefaultRepositionTicket) == 0x0019F0, "Member 'UAIAction_SimpleWeapon::DefaultRepositionTicket' has a wrong offset!");
static_assert(offsetof(UAIAction_SimpleWeapon, DefaultEnvQueryAsset) == 0x001A08, "Member 'UAIAction_SimpleWeapon::DefaultEnvQueryAsset' has a wrong offset!");
static_assert(offsetof(UAIAction_SimpleWeapon, DefaultRepositionTicketAsset) == 0x001A10, "Member 'UAIAction_SimpleWeapon::DefaultRepositionTicketAsset' has a wrong offset!");
static_assert(offsetof(UAIAction_SimpleWeapon, SimpleWeaponVersion) == 0x001A18, "Member 'UAIAction_SimpleWeapon::SimpleWeaponVersion' has a wrong offset!");

// Class GbxAI.Cover
// 0x00B8 (0x0510 - 0x0458)
class ACover final : public AActor
{
public:
	struct FSoftObjectPath                        DefaultCoverSlotName;                              // 0x0458(0x0018)(Config, GlobalConfig, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UCoverSlotData*                         SlotType;                                          // 0x0470(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	float                                         SlotInterval;                                      // 0x0478(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	float                                         TotalWidth;                                        // 0x047C(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	bool                                          bSlotsAlwaysVisible;                               // 0x0480(0x0001)(Edit, ZeroConstructor, Config, GlobalConfig, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	bool                                          bDrawLineOfSight;                                  // 0x0481(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	bool                                          bDrawAreas;                                        // 0x0482(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	bool                                          bDrawInvalidViews;                                 // 0x0483(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	bool                                          bDrawLocationTests;                                // 0x0484(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_485[0x3];                                      // 0x0485(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<class UCoverSlotComponent*>            Slots;                                             // 0x0488(0x0010)(Edit, ExportObject, ZeroConstructor, ContainsInstancedReference, NativeAccessSpecifierPrivate)
	bool                                          bOverrideAutoAdjust;                               // 0x0498(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_499[0x3];                                      // 0x0499(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	struct FCoverAdjustParams                     AutoAdjustParamsOverride;                          // 0x049C(0x0040)(Edit, NoDestructor, NativeAccessSpecifierPrivate)
	uint8                                         Pad_4DC[0x4];                                      // 0x04DC(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class AActor*                                 TargetTestActor;                                   // 0x04E0(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class AActor*                                 HostileTestActor;                                  // 0x04E8(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	bool                                          bAutoAdjust;                                       // 0x04F0(0x0001)(Edit, ZeroConstructor, Config, GlobalConfig, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_4F1[0x1F];                                     // 0x04F1(0x001F)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void SetEnabled(bool bEnabled);

	bool IsEnabled() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"Cover">();
	}
	static class ACover* GetDefaultObj()
	{
		return GetDefaultObjImpl<ACover>();
	}
};
static_assert(alignof(ACover) == 0x000008, "Wrong alignment on ACover");
static_assert(sizeof(ACover) == 0x000510, "Wrong size on ACover");
static_assert(offsetof(ACover, DefaultCoverSlotName) == 0x000458, "Member 'ACover::DefaultCoverSlotName' has a wrong offset!");
static_assert(offsetof(ACover, SlotType) == 0x000470, "Member 'ACover::SlotType' has a wrong offset!");
static_assert(offsetof(ACover, SlotInterval) == 0x000478, "Member 'ACover::SlotInterval' has a wrong offset!");
static_assert(offsetof(ACover, TotalWidth) == 0x00047C, "Member 'ACover::TotalWidth' has a wrong offset!");
static_assert(offsetof(ACover, bSlotsAlwaysVisible) == 0x000480, "Member 'ACover::bSlotsAlwaysVisible' has a wrong offset!");
static_assert(offsetof(ACover, bDrawLineOfSight) == 0x000481, "Member 'ACover::bDrawLineOfSight' has a wrong offset!");
static_assert(offsetof(ACover, bDrawAreas) == 0x000482, "Member 'ACover::bDrawAreas' has a wrong offset!");
static_assert(offsetof(ACover, bDrawInvalidViews) == 0x000483, "Member 'ACover::bDrawInvalidViews' has a wrong offset!");
static_assert(offsetof(ACover, bDrawLocationTests) == 0x000484, "Member 'ACover::bDrawLocationTests' has a wrong offset!");
static_assert(offsetof(ACover, Slots) == 0x000488, "Member 'ACover::Slots' has a wrong offset!");
static_assert(offsetof(ACover, bOverrideAutoAdjust) == 0x000498, "Member 'ACover::bOverrideAutoAdjust' has a wrong offset!");
static_assert(offsetof(ACover, AutoAdjustParamsOverride) == 0x00049C, "Member 'ACover::AutoAdjustParamsOverride' has a wrong offset!");
static_assert(offsetof(ACover, TargetTestActor) == 0x0004E0, "Member 'ACover::TargetTestActor' has a wrong offset!");
static_assert(offsetof(ACover, HostileTestActor) == 0x0004E8, "Member 'ACover::HostileTestActor' has a wrong offset!");
static_assert(offsetof(ACover, bAutoAdjust) == 0x0004F0, "Member 'ACover::bAutoAdjust' has a wrong offset!");

// Class GbxAI.AIAction_StateMachine
// 0x0000 (0x0160 - 0x0160)
class UAIAction_StateMachine final : public UAIAction_Selector
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"AIAction_StateMachine">();
	}
	static class UAIAction_StateMachine* GetDefaultObj()
	{
		return GetDefaultObjImpl<UAIAction_StateMachine>();
	}
};
static_assert(alignof(UAIAction_StateMachine) == 0x000008, "Wrong alignment on UAIAction_StateMachine");
static_assert(sizeof(UAIAction_StateMachine) == 0x000160, "Wrong size on UAIAction_StateMachine");

// Class GbxAI.AIAction_StateMachineChild
// 0x0010 (0x0168 - 0x0158)
class UAIAction_StateMachineChild final : public UAIAction_CompositeChild
{
public:
	class UAIAction_StateMachineChild*            OnSuccess;                                         // 0x0158(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UAIAction_StateMachineChild*            OnFailure;                                         // 0x0160(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

public:
	void GetAvailableStates(TArray<class UAIAction_StateMachineChild*>* Array) const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"AIAction_StateMachineChild">();
	}
	static class UAIAction_StateMachineChild* GetDefaultObj()
	{
		return GetDefaultObjImpl<UAIAction_StateMachineChild>();
	}
};
static_assert(alignof(UAIAction_StateMachineChild) == 0x000008, "Wrong alignment on UAIAction_StateMachineChild");
static_assert(sizeof(UAIAction_StateMachineChild) == 0x000168, "Wrong size on UAIAction_StateMachineChild");
static_assert(offsetof(UAIAction_StateMachineChild, OnSuccess) == 0x000158, "Member 'UAIAction_StateMachineChild::OnSuccess' has a wrong offset!");
static_assert(offsetof(UAIAction_StateMachineChild, OnFailure) == 0x000160, "Member 'UAIAction_StateMachineChild::OnFailure' has a wrong offset!");

// Class GbxAI.AIAction_Sweep
// 0x00A8 (0x0AA0 - 0x09F8)
class UAIAction_Sweep final : public UAIAction_Orbit
{
public:
	struct FAIAspectSettings_Sweep                SweepSettings;                                     // 0x09F8(0x00A8)(NoDestructor, ContainsInstancedReference, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"AIAction_Sweep">();
	}
	static class UAIAction_Sweep* GetDefaultObj()
	{
		return GetDefaultObjImpl<UAIAction_Sweep>();
	}
};
static_assert(alignof(UAIAction_Sweep) == 0x000008, "Wrong alignment on UAIAction_Sweep");
static_assert(sizeof(UAIAction_Sweep) == 0x000AA0, "Wrong size on UAIAction_Sweep");
static_assert(offsetof(UAIAction_Sweep, SweepSettings) == 0x0009F8, "Member 'UAIAction_Sweep::SweepSettings' has a wrong offset!");

// Class GbxAI.AIAction_Swoop
// 0x1468 (0x1650 - 0x01E8)
class UAIAction_Swoop final : public UAIAction_Sequence
{
public:
	struct FAIAspectSettings_Swoop                SwoopSettings;                                     // 0x01E8(0x0320)(Edit, NoDestructor, ContainsInstancedReference, NativeAccessSpecifierPublic)
	struct FAIAspectSettings_Navigation           NavSettings;                                       // 0x0508(0x0140)(Edit, NoDestructor, ContainsInstancedReference, NativeAccessSpecifierPublic)
	struct FAIAspectSettings_Rotation             MoveFarRotationSettings;                           // 0x0648(0x0550)(Edit, NoDestructor, ContainsInstancedReference, NativeAccessSpecifierPublic)
	bool                                          bUseFarRotation;                                   // 0x0B98(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_B99[0x7];                                      // 0x0B99(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	struct FAIAspectSettings_Rotation             MoveNearRotationSettings;                          // 0x0BA0(0x0550)(Edit, NoDestructor, ContainsInstancedReference, NativeAccessSpecifierPublic)
	bool                                          bUseNearRotation;                                  // 0x10F0(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_10F1[0x7];                                     // 0x10F1(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	struct FAIAspectSettings_Rotation             MovePassRotationSettings;                          // 0x10F8(0x0550)(Edit, NoDestructor, ContainsInstancedReference, NativeAccessSpecifierPublic)
	bool                                          bUsePassRotation;                                  // 0x1648(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1649[0x7];                                     // 0x1649(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"AIAction_Swoop">();
	}
	static class UAIAction_Swoop* GetDefaultObj()
	{
		return GetDefaultObjImpl<UAIAction_Swoop>();
	}
};
static_assert(alignof(UAIAction_Swoop) == 0x000008, "Wrong alignment on UAIAction_Swoop");
static_assert(sizeof(UAIAction_Swoop) == 0x001650, "Wrong size on UAIAction_Swoop");
static_assert(offsetof(UAIAction_Swoop, SwoopSettings) == 0x0001E8, "Member 'UAIAction_Swoop::SwoopSettings' has a wrong offset!");
static_assert(offsetof(UAIAction_Swoop, NavSettings) == 0x000508, "Member 'UAIAction_Swoop::NavSettings' has a wrong offset!");
static_assert(offsetof(UAIAction_Swoop, MoveFarRotationSettings) == 0x000648, "Member 'UAIAction_Swoop::MoveFarRotationSettings' has a wrong offset!");
static_assert(offsetof(UAIAction_Swoop, bUseFarRotation) == 0x000B98, "Member 'UAIAction_Swoop::bUseFarRotation' has a wrong offset!");
static_assert(offsetof(UAIAction_Swoop, MoveNearRotationSettings) == 0x000BA0, "Member 'UAIAction_Swoop::MoveNearRotationSettings' has a wrong offset!");
static_assert(offsetof(UAIAction_Swoop, bUseNearRotation) == 0x0010F0, "Member 'UAIAction_Swoop::bUseNearRotation' has a wrong offset!");
static_assert(offsetof(UAIAction_Swoop, MovePassRotationSettings) == 0x0010F8, "Member 'UAIAction_Swoop::MovePassRotationSettings' has a wrong offset!");
static_assert(offsetof(UAIAction_Swoop, bUsePassRotation) == 0x001648, "Member 'UAIAction_Swoop::bUsePassRotation' has a wrong offset!");

// Class GbxAI.AIAction_TargetSequence
// 0x0198 (0x0380 - 0x01E8)
class UAIAction_TargetSequence final : public UAIAction_Sequence
{
public:
	struct FGbxParam                              TargetCountMin;                                    // 0x01E8(0x0080)(Edit, NoDestructor, ContainsInstancedReference, NativeAccessSpecifierPublic)
	bool                                          bUseTargetCountMin;                                // 0x0268(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_269[0x7];                                      // 0x0269(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	struct FGbxParam                              TargetCountMax;                                    // 0x0270(0x0080)(Edit, NoDestructor, ContainsInstancedReference, NativeAccessSpecifierPublic)
	bool                                          bUseTargetCountMax;                                // 0x02F0(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2F1[0x7];                                      // 0x02F1(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	struct FGbxParam                              TargetDistance;                                    // 0x02F8(0x0080)(Edit, NoDestructor, ContainsInstancedReference, NativeAccessSpecifierPublic)
	bool                                          bUseTargetDistance;                                // 0x0378(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bPlayersOnly;                                      // 0x0379(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_37A[0x6];                                      // 0x037A(0x0006)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"AIAction_TargetSequence">();
	}
	static class UAIAction_TargetSequence* GetDefaultObj()
	{
		return GetDefaultObjImpl<UAIAction_TargetSequence>();
	}
};
static_assert(alignof(UAIAction_TargetSequence) == 0x000008, "Wrong alignment on UAIAction_TargetSequence");
static_assert(sizeof(UAIAction_TargetSequence) == 0x000380, "Wrong size on UAIAction_TargetSequence");
static_assert(offsetof(UAIAction_TargetSequence, TargetCountMin) == 0x0001E8, "Member 'UAIAction_TargetSequence::TargetCountMin' has a wrong offset!");
static_assert(offsetof(UAIAction_TargetSequence, bUseTargetCountMin) == 0x000268, "Member 'UAIAction_TargetSequence::bUseTargetCountMin' has a wrong offset!");
static_assert(offsetof(UAIAction_TargetSequence, TargetCountMax) == 0x000270, "Member 'UAIAction_TargetSequence::TargetCountMax' has a wrong offset!");
static_assert(offsetof(UAIAction_TargetSequence, bUseTargetCountMax) == 0x0002F0, "Member 'UAIAction_TargetSequence::bUseTargetCountMax' has a wrong offset!");
static_assert(offsetof(UAIAction_TargetSequence, TargetDistance) == 0x0002F8, "Member 'UAIAction_TargetSequence::TargetDistance' has a wrong offset!");
static_assert(offsetof(UAIAction_TargetSequence, bUseTargetDistance) == 0x000378, "Member 'UAIAction_TargetSequence::bUseTargetDistance' has a wrong offset!");
static_assert(offsetof(UAIAction_TargetSequence, bPlayersOnly) == 0x000379, "Member 'UAIAction_TargetSequence::bPlayersOnly' has a wrong offset!");

// Class GbxAI.AIAction_Teleport
// 0x04F0 (0x0638 - 0x0148)
class UAIAction_Teleport final : public UAIAction
{
public:
	struct FGbxBlackboardKeySelector              GoalKey;                                           // 0x0148(0x0010)(Edit, NoDestructor, NativeAccessSpecifierPublic)
	struct FAIAspectSettings_Teleport             TeleportSettings;                                  // 0x0158(0x0138)(Edit, NoDestructor, ContainsInstancedReference, NativeAccessSpecifierPublic)
	struct FAIAspectSettings_EnvQuery             QuerySettings;                                     // 0x0290(0x03A0)(Edit, ContainsInstancedReference, NativeAccessSpecifierPublic)
	bool                                          bUseQuery;                                         // 0x0630(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_631[0x7];                                      // 0x0631(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"AIAction_Teleport">();
	}
	static class UAIAction_Teleport* GetDefaultObj()
	{
		return GetDefaultObjImpl<UAIAction_Teleport>();
	}
};
static_assert(alignof(UAIAction_Teleport) == 0x000008, "Wrong alignment on UAIAction_Teleport");
static_assert(sizeof(UAIAction_Teleport) == 0x000638, "Wrong size on UAIAction_Teleport");
static_assert(offsetof(UAIAction_Teleport, GoalKey) == 0x000148, "Member 'UAIAction_Teleport::GoalKey' has a wrong offset!");
static_assert(offsetof(UAIAction_Teleport, TeleportSettings) == 0x000158, "Member 'UAIAction_Teleport::TeleportSettings' has a wrong offset!");
static_assert(offsetof(UAIAction_Teleport, QuerySettings) == 0x000290, "Member 'UAIAction_Teleport::QuerySettings' has a wrong offset!");
static_assert(offsetof(UAIAction_Teleport, bUseQuery) == 0x000630, "Member 'UAIAction_Teleport::bUseQuery' has a wrong offset!");

// Class GbxAI.EnvQueryTest_GbxPath
// 0x0008 (0x01E0 - 0x01D8)
class UEnvQueryTest_GbxPath final : public UEnvQueryTest
{
public:
	TSubclassOf<class UEnvQueryContext>           Context;                                           // 0x01D8(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"EnvQueryTest_GbxPath">();
	}
	static class UEnvQueryTest_GbxPath* GetDefaultObj()
	{
		return GetDefaultObjImpl<UEnvQueryTest_GbxPath>();
	}
};
static_assert(alignof(UEnvQueryTest_GbxPath) == 0x000008, "Wrong alignment on UEnvQueryTest_GbxPath");
static_assert(sizeof(UEnvQueryTest_GbxPath) == 0x0001E0, "Wrong size on UEnvQueryTest_GbxPath");
static_assert(offsetof(UEnvQueryTest_GbxPath, Context) == 0x0001D8, "Member 'UEnvQueryTest_GbxPath::Context' has a wrong offset!");

// Class GbxAI.BTTask_AIAction_Teleport
// 0x0008 (0x0080 - 0x0078)
class UBTTask_AIAction_Teleport final : public UBTTask_AIAction
{
public:
	class UAIAction_Teleport*                     Action;                                            // 0x0078(0x0008)(Edit, ExportObject, ZeroConstructor, EditConst, InstancedReference, IsPlainOldData, NoDestructor, PersistentInstance, HasGetValueTypeHash, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"BTTask_AIAction_Teleport">();
	}
	static class UBTTask_AIAction_Teleport* GetDefaultObj()
	{
		return GetDefaultObjImpl<UBTTask_AIAction_Teleport>();
	}
};
static_assert(alignof(UBTTask_AIAction_Teleport) == 0x000008, "Wrong alignment on UBTTask_AIAction_Teleport");
static_assert(sizeof(UBTTask_AIAction_Teleport) == 0x000080, "Wrong size on UBTTask_AIAction_Teleport");
static_assert(offsetof(UBTTask_AIAction_Teleport, Action) == 0x000078, "Member 'UBTTask_AIAction_Teleport::Action' has a wrong offset!");

// Class GbxAI.BTTask_AIAction_UseCover
// 0x0008 (0x0080 - 0x0078)
class UBTTask_AIAction_UseCover final : public UBTTask_AIAction
{
public:
	class UAIAction_UseCover*                     Action;                                            // 0x0078(0x0008)(Edit, ExportObject, ZeroConstructor, EditConst, InstancedReference, IsPlainOldData, NoDestructor, PersistentInstance, HasGetValueTypeHash, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"BTTask_AIAction_UseCover">();
	}
	static class UBTTask_AIAction_UseCover* GetDefaultObj()
	{
		return GetDefaultObjImpl<UBTTask_AIAction_UseCover>();
	}
};
static_assert(alignof(UBTTask_AIAction_UseCover) == 0x000008, "Wrong alignment on UBTTask_AIAction_UseCover");
static_assert(sizeof(UBTTask_AIAction_UseCover) == 0x000080, "Wrong size on UBTTask_AIAction_UseCover");
static_assert(offsetof(UBTTask_AIAction_UseCover, Action) == 0x000078, "Member 'UBTTask_AIAction_UseCover::Action' has a wrong offset!");

// Class GbxAI.AIAction_UseSmartObject
// 0x0FD8 (0x11C0 - 0x01E8)
class UAIAction_UseSmartObject final : public UAIAction_Sequence
{
public:
	struct FAIAspectSettings_UseSmartObject       SmartObjectSettings;                               // 0x01E8(0x0478)(Edit, ContainsInstancedReference, Protected, NativeAccessSpecifierProtected)
	struct FAIAspectSettings_Navigation           NavSettings;                                       // 0x0660(0x0140)(Edit, NoDestructor, ContainsInstancedReference, Protected, NativeAccessSpecifierProtected)
	struct FAIAspectSettings_Rotation             MoveToRotationSettings;                            // 0x07A0(0x0550)(Edit, NoDestructor, ContainsInstancedReference, Protected, NativeAccessSpecifierProtected)
	struct FAIAspectSettings_EnvQuery             QuerySettings;                                     // 0x0CF0(0x03A0)(Edit, ContainsInstancedReference, Protected, NativeAccessSpecifierProtected)
	bool                                          bUseQuery;                                         // 0x1090(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_1091[0x7];                                     // 0x1091(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	struct FGbxBlackboardKeySelector              SmartAction;                                       // 0x1098(0x0010)(NoDestructor, Protected, NativeAccessSpecifierProtected)
	struct FGbxBlackboardKeySelector              MoveTarget;                                        // 0x10A8(0x0010)(NoDestructor, Protected, NativeAccessSpecifierProtected)
	struct FGbxBlackboardKeySelector              Distance;                                          // 0x10B8(0x0010)(NoDestructor, Protected, NativeAccessSpecifierProtected)
	struct FGbxBlackboardKeySelector              BodyTarget;                                        // 0x10C8(0x0010)(NoDestructor, Protected, NativeAccessSpecifierProtected)
	struct FGbxBlackboardKeySelector              LookTarget;                                        // 0x10D8(0x0010)(NoDestructor, Protected, NativeAccessSpecifierProtected)
	struct FGbxBlackboardKeySelector              LookEnabled;                                       // 0x10E8(0x0010)(NoDestructor, Protected, NativeAccessSpecifierProtected)
	struct FAIAspectSettings_Move                 MoveSettings;                                      // 0x10F8(0x0008)(NoDestructor, Protected, NativeAccessSpecifierProtected)
	struct FEnvQueryParams                        SmartObjectQuery;                                  // 0x1100(0x00B8)(ContainsInstancedReference, Protected, NativeAccessSpecifierProtected)
	uint8                                         UseSmartObjectVersion;                             // 0x11B8(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_11B9[0x7];                                     // 0x11B9(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"AIAction_UseSmartObject">();
	}
	static class UAIAction_UseSmartObject* GetDefaultObj()
	{
		return GetDefaultObjImpl<UAIAction_UseSmartObject>();
	}
};
static_assert(alignof(UAIAction_UseSmartObject) == 0x000008, "Wrong alignment on UAIAction_UseSmartObject");
static_assert(sizeof(UAIAction_UseSmartObject) == 0x0011C0, "Wrong size on UAIAction_UseSmartObject");
static_assert(offsetof(UAIAction_UseSmartObject, SmartObjectSettings) == 0x0001E8, "Member 'UAIAction_UseSmartObject::SmartObjectSettings' has a wrong offset!");
static_assert(offsetof(UAIAction_UseSmartObject, NavSettings) == 0x000660, "Member 'UAIAction_UseSmartObject::NavSettings' has a wrong offset!");
static_assert(offsetof(UAIAction_UseSmartObject, MoveToRotationSettings) == 0x0007A0, "Member 'UAIAction_UseSmartObject::MoveToRotationSettings' has a wrong offset!");
static_assert(offsetof(UAIAction_UseSmartObject, QuerySettings) == 0x000CF0, "Member 'UAIAction_UseSmartObject::QuerySettings' has a wrong offset!");
static_assert(offsetof(UAIAction_UseSmartObject, bUseQuery) == 0x001090, "Member 'UAIAction_UseSmartObject::bUseQuery' has a wrong offset!");
static_assert(offsetof(UAIAction_UseSmartObject, SmartAction) == 0x001098, "Member 'UAIAction_UseSmartObject::SmartAction' has a wrong offset!");
static_assert(offsetof(UAIAction_UseSmartObject, MoveTarget) == 0x0010A8, "Member 'UAIAction_UseSmartObject::MoveTarget' has a wrong offset!");
static_assert(offsetof(UAIAction_UseSmartObject, Distance) == 0x0010B8, "Member 'UAIAction_UseSmartObject::Distance' has a wrong offset!");
static_assert(offsetof(UAIAction_UseSmartObject, BodyTarget) == 0x0010C8, "Member 'UAIAction_UseSmartObject::BodyTarget' has a wrong offset!");
static_assert(offsetof(UAIAction_UseSmartObject, LookTarget) == 0x0010D8, "Member 'UAIAction_UseSmartObject::LookTarget' has a wrong offset!");
static_assert(offsetof(UAIAction_UseSmartObject, LookEnabled) == 0x0010E8, "Member 'UAIAction_UseSmartObject::LookEnabled' has a wrong offset!");
static_assert(offsetof(UAIAction_UseSmartObject, MoveSettings) == 0x0010F8, "Member 'UAIAction_UseSmartObject::MoveSettings' has a wrong offset!");
static_assert(offsetof(UAIAction_UseSmartObject, SmartObjectQuery) == 0x001100, "Member 'UAIAction_UseSmartObject::SmartObjectQuery' has a wrong offset!");
static_assert(offsetof(UAIAction_UseSmartObject, UseSmartObjectVersion) == 0x0011B8, "Member 'UAIAction_UseSmartObject::UseSmartObjectVersion' has a wrong offset!");

// Class GbxAI.BTTask_AIAction_UseSmartObject
// 0x0008 (0x0080 - 0x0078)
class UBTTask_AIAction_UseSmartObject final : public UBTTask_AIAction
{
public:
	class UAIAction_UseSmartObject*               Action;                                            // 0x0078(0x0008)(Edit, ExportObject, ZeroConstructor, EditConst, InstancedReference, IsPlainOldData, NoDestructor, PersistentInstance, HasGetValueTypeHash, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"BTTask_AIAction_UseSmartObject">();
	}
	static class UBTTask_AIAction_UseSmartObject* GetDefaultObj()
	{
		return GetDefaultObjImpl<UBTTask_AIAction_UseSmartObject>();
	}
};
static_assert(alignof(UBTTask_AIAction_UseSmartObject) == 0x000008, "Wrong alignment on UBTTask_AIAction_UseSmartObject");
static_assert(sizeof(UBTTask_AIAction_UseSmartObject) == 0x000080, "Wrong size on UBTTask_AIAction_UseSmartObject");
static_assert(offsetof(UBTTask_AIAction_UseSmartObject, Action) == 0x000078, "Member 'UBTTask_AIAction_UseSmartObject::Action' has a wrong offset!");

// Class GbxAI.BTTask_UseCover
// 0x0000 (0x0070 - 0x0070)
class UBTTask_UseCover final : public UBTTaskNode
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"BTTask_UseCover">();
	}
	static class UBTTask_UseCover* GetDefaultObj()
	{
		return GetDefaultObjImpl<UBTTask_UseCover>();
	}
};
static_assert(alignof(UBTTask_UseCover) == 0x000008, "Wrong alignment on UBTTask_UseCover");
static_assert(sizeof(UBTTask_UseCover) == 0x000070, "Wrong size on UBTTask_UseCover");

// Class GbxAI.BTTask_AIAction_WeaponAtPoint
// 0x0008 (0x0080 - 0x0078)
class UBTTask_AIAction_WeaponAtPoint final : public UBTTask_AIAction
{
public:
	class UAIAction_WeaponAtPoint*                Action;                                            // 0x0078(0x0008)(Edit, ExportObject, ZeroConstructor, EditConst, InstancedReference, IsPlainOldData, NoDestructor, PersistentInstance, HasGetValueTypeHash, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"BTTask_AIAction_WeaponAtPoint">();
	}
	static class UBTTask_AIAction_WeaponAtPoint* GetDefaultObj()
	{
		return GetDefaultObjImpl<UBTTask_AIAction_WeaponAtPoint>();
	}
};
static_assert(alignof(UBTTask_AIAction_WeaponAtPoint) == 0x000008, "Wrong alignment on UBTTask_AIAction_WeaponAtPoint");
static_assert(sizeof(UBTTask_AIAction_WeaponAtPoint) == 0x000080, "Wrong size on UBTTask_AIAction_WeaponAtPoint");
static_assert(offsetof(UBTTask_AIAction_WeaponAtPoint, Action) == 0x000078, "Member 'UBTTask_AIAction_WeaponAtPoint::Action' has a wrong offset!");

// Class GbxAI.AIAction_WeaponIdle
// 0x0920 (0x0A68 - 0x0148)
class UAIAction_WeaponIdle final : public UAIAction
{
public:
	struct FAIAspectSettings_Weapon               WeaponSettings;                                    // 0x0148(0x03D0)(Edit, ContainsInstancedReference, NativeAccessSpecifierPublic)
	struct FAIAspectSettings_Rotation             RotationSettings;                                  // 0x0518(0x0550)(Edit, NoDestructor, ContainsInstancedReference, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"AIAction_WeaponIdle">();
	}
	static class UAIAction_WeaponIdle* GetDefaultObj()
	{
		return GetDefaultObjImpl<UAIAction_WeaponIdle>();
	}
};
static_assert(alignof(UAIAction_WeaponIdle) == 0x000008, "Wrong alignment on UAIAction_WeaponIdle");
static_assert(sizeof(UAIAction_WeaponIdle) == 0x000A68, "Wrong size on UAIAction_WeaponIdle");
static_assert(offsetof(UAIAction_WeaponIdle, WeaponSettings) == 0x000148, "Member 'UAIAction_WeaponIdle::WeaponSettings' has a wrong offset!");
static_assert(offsetof(UAIAction_WeaponIdle, RotationSettings) == 0x000518, "Member 'UAIAction_WeaponIdle::RotationSettings' has a wrong offset!");

// Class GbxAI.EnvQueryContext_TargetActualLocation
// 0x0000 (0x0028 - 0x0028)
class UEnvQueryContext_TargetActualLocation final : public UEnvQueryContext
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"EnvQueryContext_TargetActualLocation">();
	}
	static class UEnvQueryContext_TargetActualLocation* GetDefaultObj()
	{
		return GetDefaultObjImpl<UEnvQueryContext_TargetActualLocation>();
	}
};
static_assert(alignof(UEnvQueryContext_TargetActualLocation) == 0x000008, "Wrong alignment on UEnvQueryContext_TargetActualLocation");
static_assert(sizeof(UEnvQueryContext_TargetActualLocation) == 0x000028, "Wrong size on UEnvQueryContext_TargetActualLocation");

// Class GbxAI.BTTask_AIAction_WeaponIdle
// 0x0008 (0x0080 - 0x0078)
class UBTTask_AIAction_WeaponIdle final : public UBTTask_AIAction
{
public:
	class UAIAction_WeaponIdle*                   Action;                                            // 0x0078(0x0008)(Edit, ExportObject, ZeroConstructor, EditConst, InstancedReference, IsPlainOldData, NoDestructor, PersistentInstance, HasGetValueTypeHash, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"BTTask_AIAction_WeaponIdle">();
	}
	static class UBTTask_AIAction_WeaponIdle* GetDefaultObj()
	{
		return GetDefaultObjImpl<UBTTask_AIAction_WeaponIdle>();
	}
};
static_assert(alignof(UBTTask_AIAction_WeaponIdle) == 0x000008, "Wrong alignment on UBTTask_AIAction_WeaponIdle");
static_assert(sizeof(UBTTask_AIAction_WeaponIdle) == 0x000080, "Wrong size on UBTTask_AIAction_WeaponIdle");
static_assert(offsetof(UBTTask_AIAction_WeaponIdle, Action) == 0x000078, "Member 'UBTTask_AIAction_WeaponIdle::Action' has a wrong offset!");

// Class GbxAI.AIActionBlueprintGeneratedClass
// 0x0000 (0x02E0 - 0x02E0)
class UAIActionBlueprintGeneratedClass final : public UBlueprintGeneratedClass
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"AIActionBlueprintGeneratedClass">();
	}
	static class UAIActionBlueprintGeneratedClass* GetDefaultObj()
	{
		return GetDefaultObjImpl<UAIActionBlueprintGeneratedClass>();
	}
};
static_assert(alignof(UAIActionBlueprintGeneratedClass) == 0x000008, "Wrong alignment on UAIActionBlueprintGeneratedClass");
static_assert(sizeof(UAIActionBlueprintGeneratedClass) == 0x0002E0, "Wrong size on UAIActionBlueprintGeneratedClass");

// Class GbxAI.AIActionManager
// 0x0030 (0x0058 - 0x0028)
class UAIActionManager final : public UObject
{
public:
	uint8                                         Pad_28[0x8];                                       // 0x0028(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         MaxTickTimeMs;                                     // 0x0030(0x0004)(ZeroConstructor, Config, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_34[0x24];                                      // 0x0034(0x0024)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"AIActionManager">();
	}
	static class UAIActionManager* GetDefaultObj()
	{
		return GetDefaultObjImpl<UAIActionManager>();
	}
};
static_assert(alignof(UAIActionManager) == 0x000008, "Wrong alignment on UAIActionManager");
static_assert(sizeof(UAIActionManager) == 0x000058, "Wrong size on UAIActionManager");
static_assert(offsetof(UAIActionManager, MaxTickTimeMs) == 0x000030, "Member 'UAIActionManager::MaxTickTimeMs' has a wrong offset!");

// Class GbxAI.CoverSlotData
// 0x0098 (0x00C8 - 0x0030)
class UCoverSlotData final : public UGbxDataAsset
{
public:
	float                                         SlotWidth;                                         // 0x0030(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         SlotHeightLow;                                     // 0x0034(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         SlotHeightHigh;                                    // 0x0038(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bOffGroundCover;                                   // 0x003C(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_3D[0x3];                                       // 0x003D(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	struct FCoverLineOfSightParams                ExposedParams;                                     // 0x0040(0x0028)(Edit, NoDestructor, NativeAccessSpecifierPublic)
	bool                                          bCheckExposure;                                    // 0x0068(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_69[0x3];                                       // 0x0069(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	struct FCoverAdjustParams                     AutoAdjustParams;                                  // 0x006C(0x0040)(Edit, NoDestructor, NativeAccessSpecifierPublic)
	uint8                                         Pad_AC[0x4];                                       // 0x00AC(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<class UCoverViewData*>                 Views;                                             // 0x00B0(0x0010)(Edit, ZeroConstructor, NativeAccessSpecifierPublic)
	struct FColor                                 ValidColor;                                        // 0x00C0(0x0004)(Edit, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         NavSearchRadius;                                   // 0x00C4(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"CoverSlotData">();
	}
	static class UCoverSlotData* GetDefaultObj()
	{
		return GetDefaultObjImpl<UCoverSlotData>();
	}
};
static_assert(alignof(UCoverSlotData) == 0x000008, "Wrong alignment on UCoverSlotData");
static_assert(sizeof(UCoverSlotData) == 0x0000C8, "Wrong size on UCoverSlotData");
static_assert(offsetof(UCoverSlotData, SlotWidth) == 0x000030, "Member 'UCoverSlotData::SlotWidth' has a wrong offset!");
static_assert(offsetof(UCoverSlotData, SlotHeightLow) == 0x000034, "Member 'UCoverSlotData::SlotHeightLow' has a wrong offset!");
static_assert(offsetof(UCoverSlotData, SlotHeightHigh) == 0x000038, "Member 'UCoverSlotData::SlotHeightHigh' has a wrong offset!");
static_assert(offsetof(UCoverSlotData, bOffGroundCover) == 0x00003C, "Member 'UCoverSlotData::bOffGroundCover' has a wrong offset!");
static_assert(offsetof(UCoverSlotData, ExposedParams) == 0x000040, "Member 'UCoverSlotData::ExposedParams' has a wrong offset!");
static_assert(offsetof(UCoverSlotData, bCheckExposure) == 0x000068, "Member 'UCoverSlotData::bCheckExposure' has a wrong offset!");
static_assert(offsetof(UCoverSlotData, AutoAdjustParams) == 0x00006C, "Member 'UCoverSlotData::AutoAdjustParams' has a wrong offset!");
static_assert(offsetof(UCoverSlotData, Views) == 0x0000B0, "Member 'UCoverSlotData::Views' has a wrong offset!");
static_assert(offsetof(UCoverSlotData, ValidColor) == 0x0000C0, "Member 'UCoverSlotData::ValidColor' has a wrong offset!");
static_assert(offsetof(UCoverSlotData, NavSearchRadius) == 0x0000C4, "Member 'UCoverSlotData::NavSearchRadius' has a wrong offset!");

// Class GbxAI.AIAspect
// 0x0008 (0x0100 - 0x00F8)
class UAIAspect : public UAIActionBase
{
public:
	struct FAIAspectExecutionSettings             AspectExecutionSettings;                           // 0x00F8(0x0005)(Edit, BlueprintVisible, NoDestructor, NativeAccessSpecifierPublic)
	uint8                                         Pad_FD[0x3];                                       // 0x00FD(0x0003)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"AIAspect">();
	}
	static class UAIAspect* GetDefaultObj()
	{
		return GetDefaultObjImpl<UAIAspect>();
	}
};
static_assert(alignof(UAIAspect) == 0x000008, "Wrong alignment on UAIAspect");
static_assert(sizeof(UAIAspect) == 0x000100, "Wrong size on UAIAspect");
static_assert(offsetof(UAIAspect, AspectExecutionSettings) == 0x0000F8, "Member 'UAIAspect::AspectExecutionSettings' has a wrong offset!");

// Class GbxAI.AIAspect_ActorCollision
// 0x0018 (0x0118 - 0x0100)
class UAIAspect_ActorCollision final : public UAIAspect
{
public:
	struct FAIAspectSettings_ActorCollision       Settings;                                          // 0x0100(0x0018)(Edit, NoDestructor, NativeAccessSpecifierPublic)

public:
	static void GetOnCollisionOptions(TArray<class FName>* Options);

	void OnPawnHit(class AActor* SelfActor, class AActor* OtherActor, const struct FVector& NormalImpulse, const struct FHitResult& Hit);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"AIAspect_ActorCollision">();
	}
	static class UAIAspect_ActorCollision* GetDefaultObj()
	{
		return GetDefaultObjImpl<UAIAspect_ActorCollision>();
	}
};
static_assert(alignof(UAIAspect_ActorCollision) == 0x000008, "Wrong alignment on UAIAspect_ActorCollision");
static_assert(sizeof(UAIAspect_ActorCollision) == 0x000118, "Wrong size on UAIAspect_ActorCollision");
static_assert(offsetof(UAIAspect_ActorCollision, Settings) == 0x000100, "Member 'UAIAspect_ActorCollision::Settings' has a wrong offset!");

// Class GbxAI.EnvQueryTest_ArcTrace
// 0x0068 (0x0308 - 0x02A0)
class UEnvQueryTest_ArcTrace final : public UEnvQueryTest_Trace
{
public:
	struct FAIDataProviderFloatValue              ArcSpeed;                                          // 0x02A0(0x0030)(Edit, DisableEditOnInstance, ContainsInstancedReference, NativeAccessSpecifierPublic)
	struct FAIDataProviderFloatValue              ArcAnglePercent;                                   // 0x02D0(0x0030)(Edit, DisableEditOnInstance, ContainsInstancedReference, NativeAccessSpecifierPublic)
	int32                                         NumSegments;                                       // 0x0300(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_304[0x4];                                      // 0x0304(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"EnvQueryTest_ArcTrace">();
	}
	static class UEnvQueryTest_ArcTrace* GetDefaultObj()
	{
		return GetDefaultObjImpl<UEnvQueryTest_ArcTrace>();
	}
};
static_assert(alignof(UEnvQueryTest_ArcTrace) == 0x000008, "Wrong alignment on UEnvQueryTest_ArcTrace");
static_assert(sizeof(UEnvQueryTest_ArcTrace) == 0x000308, "Wrong size on UEnvQueryTest_ArcTrace");
static_assert(offsetof(UEnvQueryTest_ArcTrace, ArcSpeed) == 0x0002A0, "Member 'UEnvQueryTest_ArcTrace::ArcSpeed' has a wrong offset!");
static_assert(offsetof(UEnvQueryTest_ArcTrace, ArcAnglePercent) == 0x0002D0, "Member 'UEnvQueryTest_ArcTrace::ArcAnglePercent' has a wrong offset!");
static_assert(offsetof(UEnvQueryTest_ArcTrace, NumSegments) == 0x000300, "Member 'UEnvQueryTest_ArcTrace::NumSegments' has a wrong offset!");

// Class GbxAI.AIAspect_Condition
// 0x0248 (0x0348 - 0x0100)
class UAIAspect_Condition : public UAIAspect
{
public:
	struct FAIAspectSettings_Condition            Settings;                                          // 0x0100(0x0248)(Edit, NoDestructor, ContainsInstancedReference, NativeAccessSpecifierPublic)

public:
	static class FString GetConditionDataDescription(const struct FAIAspectSettings_ConditionData& ConditionData);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"AIAspect_Condition">();
	}
	static class UAIAspect_Condition* GetDefaultObj()
	{
		return GetDefaultObjImpl<UAIAspect_Condition>();
	}
};
static_assert(alignof(UAIAspect_Condition) == 0x000008, "Wrong alignment on UAIAspect_Condition");
static_assert(sizeof(UAIAspect_Condition) == 0x000348, "Wrong size on UAIAspect_Condition");
static_assert(offsetof(UAIAspect_Condition, Settings) == 0x000100, "Member 'UAIAspect_Condition::Settings' has a wrong offset!");

// Class GbxAI.AIAspect_AIGroupCondition
// 0x0008 (0x0350 - 0x0348)
class UAIAspect_AIGroupCondition final : public UAIAspect_Condition
{
public:
	struct FAIAspectSettings_AIGroupCondition     GroupSettings;                                     // 0x0348(0x0008)(Edit, NoDestructor, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"AIAspect_AIGroupCondition">();
	}
	static class UAIAspect_AIGroupCondition* GetDefaultObj()
	{
		return GetDefaultObjImpl<UAIAspect_AIGroupCondition>();
	}
};
static_assert(alignof(UAIAspect_AIGroupCondition) == 0x000008, "Wrong alignment on UAIAspect_AIGroupCondition");
static_assert(sizeof(UAIAspect_AIGroupCondition) == 0x000350, "Wrong size on UAIAspect_AIGroupCondition");
static_assert(offsetof(UAIAspect_AIGroupCondition, GroupSettings) == 0x000348, "Member 'UAIAspect_AIGroupCondition::GroupSettings' has a wrong offset!");

// Class GbxAI.EnvQueryGenerator_SmartGrid
// 0x0010 (0x00A8 - 0x0098)
class UEnvQueryGenerator_SmartGrid final : public UEnvQueryGenerator_ProjectedPoints
{
public:
	TArray<struct FSmartGridSearchSet>            SearchSets;                                        // 0x0098(0x0010)(Edit, ZeroConstructor, ContainsInstancedReference, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"EnvQueryGenerator_SmartGrid">();
	}
	static class UEnvQueryGenerator_SmartGrid* GetDefaultObj()
	{
		return GetDefaultObjImpl<UEnvQueryGenerator_SmartGrid>();
	}
};
static_assert(alignof(UEnvQueryGenerator_SmartGrid) == 0x000008, "Wrong alignment on UEnvQueryGenerator_SmartGrid");
static_assert(sizeof(UEnvQueryGenerator_SmartGrid) == 0x0000A8, "Wrong size on UEnvQueryGenerator_SmartGrid");
static_assert(offsetof(UEnvQueryGenerator_SmartGrid, SearchSets) == 0x000098, "Member 'UEnvQueryGenerator_SmartGrid::SearchSets' has a wrong offset!");

// Class GbxAI.AIAspect_AvoidWhileIdle
// 0x0008 (0x0108 - 0x0100)
class UAIAspect_AvoidWhileIdle final : public UAIAspect
{
public:
	bool                                          bAvoidWhileIdle;                                   // 0x0100(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_101[0x7];                                      // 0x0101(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"AIAspect_AvoidWhileIdle">();
	}
	static class UAIAspect_AvoidWhileIdle* GetDefaultObj()
	{
		return GetDefaultObjImpl<UAIAspect_AvoidWhileIdle>();
	}
};
static_assert(alignof(UAIAspect_AvoidWhileIdle) == 0x000008, "Wrong alignment on UAIAspect_AvoidWhileIdle");
static_assert(sizeof(UAIAspect_AvoidWhileIdle) == 0x000108, "Wrong size on UAIAspect_AvoidWhileIdle");
static_assert(offsetof(UAIAspect_AvoidWhileIdle, bAvoidWhileIdle) == 0x000100, "Member 'UAIAspect_AvoidWhileIdle::bAvoidWhileIdle' has a wrong offset!");

// Class GbxAI.AIAspect_BlackboardKey
// 0x0018 (0x0118 - 0x0100)
class UAIAspect_BlackboardKey final : public UAIAspect
{
public:
	struct FAIAspectSettings_BlackboardKey        Settings;                                          // 0x0100(0x0018)(Edit, NoDestructor, NativeAccessSpecifierPublic)

public:
	static class FString GetSettingsDescription(const struct FAIAspectSettings_BlackboardKey& BBKeySettings);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"AIAspect_BlackboardKey">();
	}
	static class UAIAspect_BlackboardKey* GetDefaultObj()
	{
		return GetDefaultObjImpl<UAIAspect_BlackboardKey>();
	}
};
static_assert(alignof(UAIAspect_BlackboardKey) == 0x000008, "Wrong alignment on UAIAspect_BlackboardKey");
static_assert(sizeof(UAIAspect_BlackboardKey) == 0x000118, "Wrong size on UAIAspect_BlackboardKey");
static_assert(offsetof(UAIAspect_BlackboardKey, Settings) == 0x000100, "Member 'UAIAspect_BlackboardKey::Settings' has a wrong offset!");

// Class GbxAI.EnvQueryTest_CoverCurrent
// 0x0000 (0x01D8 - 0x01D8)
class UEnvQueryTest_CoverCurrent final : public UEnvQueryTest
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"EnvQueryTest_CoverCurrent">();
	}
	static class UEnvQueryTest_CoverCurrent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UEnvQueryTest_CoverCurrent>();
	}
};
static_assert(alignof(UEnvQueryTest_CoverCurrent) == 0x000008, "Wrong alignment on UEnvQueryTest_CoverCurrent");
static_assert(sizeof(UEnvQueryTest_CoverCurrent) == 0x0001D8, "Wrong size on UEnvQueryTest_CoverCurrent");

// Class GbxAI.AIAspect_Charge
// 0x0018 (0x0118 - 0x0100)
class UAIAspect_Charge final : public UAIAspect
{
public:
	struct FAIAspectSettings_Charge               Settings;                                          // 0x0100(0x0018)(Edit, NoDestructor, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"AIAspect_Charge">();
	}
	static class UAIAspect_Charge* GetDefaultObj()
	{
		return GetDefaultObjImpl<UAIAspect_Charge>();
	}
};
static_assert(alignof(UAIAspect_Charge) == 0x000008, "Wrong alignment on UAIAspect_Charge");
static_assert(sizeof(UAIAspect_Charge) == 0x000118, "Wrong size on UAIAspect_Charge");
static_assert(offsetof(UAIAspect_Charge, Settings) == 0x000100, "Member 'UAIAspect_Charge::Settings' has a wrong offset!");

// Class GbxAI.AIAspect_Navigation
// 0x0140 (0x0240 - 0x0100)
class UAIAspect_Navigation : public UAIAspect
{
public:
	struct FAIAspectSettings_Navigation           Settings;                                          // 0x0100(0x0140)(Edit, NoDestructor, ContainsInstancedReference, NativeAccessSpecifierPublic)

public:
	static class FString GetNavSettingsDescription(const struct FAIAspectSettings_Navigation& NavSettings, class UProperty* Property);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"AIAspect_Navigation">();
	}
	static class UAIAspect_Navigation* GetDefaultObj()
	{
		return GetDefaultObjImpl<UAIAspect_Navigation>();
	}
};
static_assert(alignof(UAIAspect_Navigation) == 0x000008, "Wrong alignment on UAIAspect_Navigation");
static_assert(sizeof(UAIAspect_Navigation) == 0x000240, "Wrong size on UAIAspect_Navigation");
static_assert(offsetof(UAIAspect_Navigation, Settings) == 0x000100, "Member 'UAIAspect_Navigation::Settings' has a wrong offset!");

// Class GbxAI.AIAspect_Circle
// 0x0030 (0x0270 - 0x0240)
class UAIAspect_Circle final : public UAIAspect_Navigation
{
public:
	struct FGbxBlackboardKeySelector              GoalKey;                                           // 0x0240(0x0010)(Edit, NoDestructor, NativeAccessSpecifierPublic)
	float                                         Distance;                                          // 0x0250(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	ECircleDirection                              Direction;                                         // 0x0254(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_255[0x3];                                      // 0x0255(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         MinOffsetInFrontOfTarget;                          // 0x0258(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         MaxOffsetInFrontOfTarget;                          // 0x025C(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         OffsetAngle;                                       // 0x0260(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         GoalUpdateDistance;                                // 0x0264(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bTestDirectPath;                                   // 0x0268(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bDebugTestDirectPath;                              // 0x0269(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EGbxNavGoalReach                              Reach;                                             // 0x026A(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_26B[0x5];                                      // 0x026B(0x0005)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"AIAspect_Circle">();
	}
	static class UAIAspect_Circle* GetDefaultObj()
	{
		return GetDefaultObjImpl<UAIAspect_Circle>();
	}
};
static_assert(alignof(UAIAspect_Circle) == 0x000008, "Wrong alignment on UAIAspect_Circle");
static_assert(sizeof(UAIAspect_Circle) == 0x000270, "Wrong size on UAIAspect_Circle");
static_assert(offsetof(UAIAspect_Circle, GoalKey) == 0x000240, "Member 'UAIAspect_Circle::GoalKey' has a wrong offset!");
static_assert(offsetof(UAIAspect_Circle, Distance) == 0x000250, "Member 'UAIAspect_Circle::Distance' has a wrong offset!");
static_assert(offsetof(UAIAspect_Circle, Direction) == 0x000254, "Member 'UAIAspect_Circle::Direction' has a wrong offset!");
static_assert(offsetof(UAIAspect_Circle, MinOffsetInFrontOfTarget) == 0x000258, "Member 'UAIAspect_Circle::MinOffsetInFrontOfTarget' has a wrong offset!");
static_assert(offsetof(UAIAspect_Circle, MaxOffsetInFrontOfTarget) == 0x00025C, "Member 'UAIAspect_Circle::MaxOffsetInFrontOfTarget' has a wrong offset!");
static_assert(offsetof(UAIAspect_Circle, OffsetAngle) == 0x000260, "Member 'UAIAspect_Circle::OffsetAngle' has a wrong offset!");
static_assert(offsetof(UAIAspect_Circle, GoalUpdateDistance) == 0x000264, "Member 'UAIAspect_Circle::GoalUpdateDistance' has a wrong offset!");
static_assert(offsetof(UAIAspect_Circle, bTestDirectPath) == 0x000268, "Member 'UAIAspect_Circle::bTestDirectPath' has a wrong offset!");
static_assert(offsetof(UAIAspect_Circle, bDebugTestDirectPath) == 0x000269, "Member 'UAIAspect_Circle::bDebugTestDirectPath' has a wrong offset!");
static_assert(offsetof(UAIAspect_Circle, Reach) == 0x00026A, "Member 'UAIAspect_Circle::Reach' has a wrong offset!");

// Class GbxAI.AIAspect_ClaimSmartObject
// 0x04D8 (0x05D8 - 0x0100)
class UAIAspect_ClaimSmartObject final : public UAIAspect
{
public:
	struct FAIAspectSettings_UseSmartObject       SmartObjectSettings;                               // 0x0100(0x0478)(Edit, ContainsInstancedReference, NativeAccessSpecifierPublic)
	struct FGbxBlackboardKeySelector              SmartAction;                                       // 0x0578(0x0010)(NoDestructor, NativeAccessSpecifierPublic)
	struct FGbxBlackboardKeySelector              MoveTarget;                                        // 0x0588(0x0010)(NoDestructor, NativeAccessSpecifierPublic)
	struct FGbxBlackboardKeySelector              Distance;                                          // 0x0598(0x0010)(NoDestructor, NativeAccessSpecifierPublic)
	struct FGbxBlackboardKeySelector              BodyTarget;                                        // 0x05A8(0x0010)(NoDestructor, NativeAccessSpecifierPublic)
	struct FGbxBlackboardKeySelector              LookTarget;                                        // 0x05B8(0x0010)(NoDestructor, NativeAccessSpecifierPublic)
	struct FGbxBlackboardKeySelector              LookEnabled;                                       // 0x05C8(0x0010)(NoDestructor, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"AIAspect_ClaimSmartObject">();
	}
	static class UAIAspect_ClaimSmartObject* GetDefaultObj()
	{
		return GetDefaultObjImpl<UAIAspect_ClaimSmartObject>();
	}
};
static_assert(alignof(UAIAspect_ClaimSmartObject) == 0x000008, "Wrong alignment on UAIAspect_ClaimSmartObject");
static_assert(sizeof(UAIAspect_ClaimSmartObject) == 0x0005D8, "Wrong size on UAIAspect_ClaimSmartObject");
static_assert(offsetof(UAIAspect_ClaimSmartObject, SmartObjectSettings) == 0x000100, "Member 'UAIAspect_ClaimSmartObject::SmartObjectSettings' has a wrong offset!");
static_assert(offsetof(UAIAspect_ClaimSmartObject, SmartAction) == 0x000578, "Member 'UAIAspect_ClaimSmartObject::SmartAction' has a wrong offset!");
static_assert(offsetof(UAIAspect_ClaimSmartObject, MoveTarget) == 0x000588, "Member 'UAIAspect_ClaimSmartObject::MoveTarget' has a wrong offset!");
static_assert(offsetof(UAIAspect_ClaimSmartObject, Distance) == 0x000598, "Member 'UAIAspect_ClaimSmartObject::Distance' has a wrong offset!");
static_assert(offsetof(UAIAspect_ClaimSmartObject, BodyTarget) == 0x0005A8, "Member 'UAIAspect_ClaimSmartObject::BodyTarget' has a wrong offset!");
static_assert(offsetof(UAIAspect_ClaimSmartObject, LookTarget) == 0x0005B8, "Member 'UAIAspect_ClaimSmartObject::LookTarget' has a wrong offset!");
static_assert(offsetof(UAIAspect_ClaimSmartObject, LookEnabled) == 0x0005C8, "Member 'UAIAspect_ClaimSmartObject::LookEnabled' has a wrong offset!");

// Class GbxAI.EnvQueryTest_CustomScoringBoost
// 0x0020 (0x01F8 - 0x01D8)
class UEnvQueryTest_CustomScoringBoost final : public UEnvQueryTest
{
public:
	float                                         ReductionExtreme;                                  // 0x01D8(0x0004)(Edit, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         ReductionModerate;                                 // 0x01DC(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         ReductionLight;                                    // 0x01E0(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         NoBoostWeighting;                                  // 0x01E4(0x0004)(Edit, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         AmplificationLight;                                // 0x01E8(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         AmplificationModerate;                             // 0x01EC(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         AmplificationExtreme;                              // 0x01F0(0x0004)(Edit, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1F4[0x4];                                      // 0x01F4(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"EnvQueryTest_CustomScoringBoost">();
	}
	static class UEnvQueryTest_CustomScoringBoost* GetDefaultObj()
	{
		return GetDefaultObjImpl<UEnvQueryTest_CustomScoringBoost>();
	}
};
static_assert(alignof(UEnvQueryTest_CustomScoringBoost) == 0x000008, "Wrong alignment on UEnvQueryTest_CustomScoringBoost");
static_assert(sizeof(UEnvQueryTest_CustomScoringBoost) == 0x0001F8, "Wrong size on UEnvQueryTest_CustomScoringBoost");
static_assert(offsetof(UEnvQueryTest_CustomScoringBoost, ReductionExtreme) == 0x0001D8, "Member 'UEnvQueryTest_CustomScoringBoost::ReductionExtreme' has a wrong offset!");
static_assert(offsetof(UEnvQueryTest_CustomScoringBoost, ReductionModerate) == 0x0001DC, "Member 'UEnvQueryTest_CustomScoringBoost::ReductionModerate' has a wrong offset!");
static_assert(offsetof(UEnvQueryTest_CustomScoringBoost, ReductionLight) == 0x0001E0, "Member 'UEnvQueryTest_CustomScoringBoost::ReductionLight' has a wrong offset!");
static_assert(offsetof(UEnvQueryTest_CustomScoringBoost, NoBoostWeighting) == 0x0001E4, "Member 'UEnvQueryTest_CustomScoringBoost::NoBoostWeighting' has a wrong offset!");
static_assert(offsetof(UEnvQueryTest_CustomScoringBoost, AmplificationLight) == 0x0001E8, "Member 'UEnvQueryTest_CustomScoringBoost::AmplificationLight' has a wrong offset!");
static_assert(offsetof(UEnvQueryTest_CustomScoringBoost, AmplificationModerate) == 0x0001EC, "Member 'UEnvQueryTest_CustomScoringBoost::AmplificationModerate' has a wrong offset!");
static_assert(offsetof(UEnvQueryTest_CustomScoringBoost, AmplificationExtreme) == 0x0001F0, "Member 'UEnvQueryTest_CustomScoringBoost::AmplificationExtreme' has a wrong offset!");

// Class GbxAI.AIAspect_Cooldown
// 0x0220 (0x0320 - 0x0100)
class UAIAspect_Cooldown final : public UAIAspect
{
public:
	struct FAIAspectSettings_Cooldown             Settings;                                          // 0x0100(0x0220)(Edit, NoDestructor, ContainsInstancedReference, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"AIAspect_Cooldown">();
	}
	static class UAIAspect_Cooldown* GetDefaultObj()
	{
		return GetDefaultObjImpl<UAIAspect_Cooldown>();
	}
};
static_assert(alignof(UAIAspect_Cooldown) == 0x000008, "Wrong alignment on UAIAspect_Cooldown");
static_assert(sizeof(UAIAspect_Cooldown) == 0x000320, "Wrong size on UAIAspect_Cooldown");
static_assert(offsetof(UAIAspect_Cooldown, Settings) == 0x000100, "Member 'UAIAspect_Cooldown::Settings' has a wrong offset!");

// Class GbxAI.AIAspect_Crouch
// 0x0108 (0x0208 - 0x0100)
class UAIAspect_Crouch final : public UAIAspect
{
public:
	struct FAIAspectSettings_Crouch               Settings;                                          // 0x0100(0x0108)(Edit, NoDestructor, ContainsInstancedReference, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"AIAspect_Crouch">();
	}
	static class UAIAspect_Crouch* GetDefaultObj()
	{
		return GetDefaultObjImpl<UAIAspect_Crouch>();
	}
};
static_assert(alignof(UAIAspect_Crouch) == 0x000008, "Wrong alignment on UAIAspect_Crouch");
static_assert(sizeof(UAIAspect_Crouch) == 0x000208, "Wrong size on UAIAspect_Crouch");
static_assert(offsetof(UAIAspect_Crouch, Settings) == 0x000100, "Member 'UAIAspect_Crouch::Settings' has a wrong offset!");

// Class GbxAI.EnvQueryTest_Angle
// 0x0108 (0x02E0 - 0x01D8)
class UEnvQueryTest_Angle final : public UEnvQueryTest
{
public:
	struct FEnvDirection                          LineA;                                             // 0x01D8(0x0020)(Edit, DisableEditOnInstance, NoDestructor, Protected, NativeAccessSpecifierProtected)
	struct FAIDataProviderFloatValue              LineAHeadingOffset;                                // 0x01F8(0x0030)(Edit, DisableEditOnInstance, ContainsInstancedReference, Protected, NativeAccessSpecifierProtected)
	struct FAIDataProviderFloatValue              LineAPitchOffset;                                  // 0x0228(0x0030)(Edit, DisableEditOnInstance, ContainsInstancedReference, Protected, NativeAccessSpecifierProtected)
	struct FEnvDirection                          LineB;                                             // 0x0258(0x0020)(Edit, DisableEditOnInstance, NoDestructor, Protected, NativeAccessSpecifierProtected)
	struct FAIDataProviderFloatValue              LineBHeadingOffset;                                // 0x0278(0x0030)(Edit, DisableEditOnInstance, ContainsInstancedReference, Protected, NativeAccessSpecifierProtected)
	struct FAIDataProviderFloatValue              LineBPitchOffset;                                  // 0x02A8(0x0030)(Edit, DisableEditOnInstance, ContainsInstancedReference, Protected, NativeAccessSpecifierProtected)
	bool                                          bTestHeading;                                      // 0x02D8(0x0001)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bTestPitch;                                        // 0x02D9(0x0001)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_2DA[0x6];                                      // 0x02DA(0x0006)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"EnvQueryTest_Angle">();
	}
	static class UEnvQueryTest_Angle* GetDefaultObj()
	{
		return GetDefaultObjImpl<UEnvQueryTest_Angle>();
	}
};
static_assert(alignof(UEnvQueryTest_Angle) == 0x000008, "Wrong alignment on UEnvQueryTest_Angle");
static_assert(sizeof(UEnvQueryTest_Angle) == 0x0002E0, "Wrong size on UEnvQueryTest_Angle");
static_assert(offsetof(UEnvQueryTest_Angle, LineA) == 0x0001D8, "Member 'UEnvQueryTest_Angle::LineA' has a wrong offset!");
static_assert(offsetof(UEnvQueryTest_Angle, LineAHeadingOffset) == 0x0001F8, "Member 'UEnvQueryTest_Angle::LineAHeadingOffset' has a wrong offset!");
static_assert(offsetof(UEnvQueryTest_Angle, LineAPitchOffset) == 0x000228, "Member 'UEnvQueryTest_Angle::LineAPitchOffset' has a wrong offset!");
static_assert(offsetof(UEnvQueryTest_Angle, LineB) == 0x000258, "Member 'UEnvQueryTest_Angle::LineB' has a wrong offset!");
static_assert(offsetof(UEnvQueryTest_Angle, LineBHeadingOffset) == 0x000278, "Member 'UEnvQueryTest_Angle::LineBHeadingOffset' has a wrong offset!");
static_assert(offsetof(UEnvQueryTest_Angle, LineBPitchOffset) == 0x0002A8, "Member 'UEnvQueryTest_Angle::LineBPitchOffset' has a wrong offset!");
static_assert(offsetof(UEnvQueryTest_Angle, bTestHeading) == 0x0002D8, "Member 'UEnvQueryTest_Angle::bTestHeading' has a wrong offset!");
static_assert(offsetof(UEnvQueryTest_Angle, bTestPitch) == 0x0002D9, "Member 'UEnvQueryTest_Angle::bTestPitch' has a wrong offset!");

// Class GbxAI.AIAspect_DisableAvoidance
// 0x0000 (0x0100 - 0x0100)
class UAIAspect_DisableAvoidance final : public UAIAspect
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"AIAspect_DisableAvoidance">();
	}
	static class UAIAspect_DisableAvoidance* GetDefaultObj()
	{
		return GetDefaultObjImpl<UAIAspect_DisableAvoidance>();
	}
};
static_assert(alignof(UAIAspect_DisableAvoidance) == 0x000008, "Wrong alignment on UAIAspect_DisableAvoidance");
static_assert(sizeof(UAIAspect_DisableAvoidance) == 0x000100, "Wrong size on UAIAspect_DisableAvoidance");

// Class GbxAI.AIAspect_MoveNode
// 0x0010 (0x0250 - 0x0240)
class UAIAspect_MoveNode : public UAIAspect_Navigation
{
public:
	struct FGbxBlackboardKeySelector              NodeKey;                                           // 0x0240(0x0010)(Edit, NoDestructor, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"AIAspect_MoveNode">();
	}
	static class UAIAspect_MoveNode* GetDefaultObj()
	{
		return GetDefaultObjImpl<UAIAspect_MoveNode>();
	}
};
static_assert(alignof(UAIAspect_MoveNode) == 0x000008, "Wrong alignment on UAIAspect_MoveNode");
static_assert(sizeof(UAIAspect_MoveNode) == 0x000250, "Wrong size on UAIAspect_MoveNode");
static_assert(offsetof(UAIAspect_MoveNode, NodeKey) == 0x000240, "Member 'UAIAspect_MoveNode::NodeKey' has a wrong offset!");

// Class GbxAI.EnvQueryTest_MyMasterIsAttackingTarget
// 0x0028 (0x0200 - 0x01D8)
class UEnvQueryTest_MyMasterIsAttackingTarget final : public UEnvQueryTest
{
public:
	float                                         DecayRate;                                         // 0x01D8(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_1DC[0x24];                                     // 0x01DC(0x0024)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"EnvQueryTest_MyMasterIsAttackingTarget">();
	}
	static class UEnvQueryTest_MyMasterIsAttackingTarget* GetDefaultObj()
	{
		return GetDefaultObjImpl<UEnvQueryTest_MyMasterIsAttackingTarget>();
	}
};
static_assert(alignof(UEnvQueryTest_MyMasterIsAttackingTarget) == 0x000008, "Wrong alignment on UEnvQueryTest_MyMasterIsAttackingTarget");
static_assert(sizeof(UEnvQueryTest_MyMasterIsAttackingTarget) == 0x000200, "Wrong size on UEnvQueryTest_MyMasterIsAttackingTarget");
static_assert(offsetof(UEnvQueryTest_MyMasterIsAttackingTarget, DecayRate) == 0x0001D8, "Member 'UEnvQueryTest_MyMasterIsAttackingTarget::DecayRate' has a wrong offset!");

// Class GbxAI.AIAspect_UseNode
// 0x0000 (0x0250 - 0x0250)
class UAIAspect_UseNode : public UAIAspect_MoveNode
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"AIAspect_UseNode">();
	}
	static class UAIAspect_UseNode* GetDefaultObj()
	{
		return GetDefaultObjImpl<UAIAspect_UseNode>();
	}
};
static_assert(alignof(UAIAspect_UseNode) == 0x000008, "Wrong alignment on UAIAspect_UseNode");
static_assert(sizeof(UAIAspect_UseNode) == 0x000250, "Wrong size on UAIAspect_UseNode");

// Class GbxAI.AIAspect_DropshipSpawn
// 0x0010 (0x0260 - 0x0250)
class UAIAspect_DropshipSpawn final : public UAIAspect_UseNode
{
public:
	struct FAIAspectSettings_DropshipSpawn        DropshipSettings;                                  // 0x0250(0x0010)(Edit, NoDestructor, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"AIAspect_DropshipSpawn">();
	}
	static class UAIAspect_DropshipSpawn* GetDefaultObj()
	{
		return GetDefaultObjImpl<UAIAspect_DropshipSpawn>();
	}
};
static_assert(alignof(UAIAspect_DropshipSpawn) == 0x000008, "Wrong alignment on UAIAspect_DropshipSpawn");
static_assert(sizeof(UAIAspect_DropshipSpawn) == 0x000260, "Wrong size on UAIAspect_DropshipSpawn");
static_assert(offsetof(UAIAspect_DropshipSpawn, DropshipSettings) == 0x000250, "Member 'UAIAspect_DropshipSpawn::DropshipSettings' has a wrong offset!");

// Class GbxAI.EnvQueryGenerator_DynamicPoints
// 0x0160 (0x01F8 - 0x0098)
class UEnvQueryGenerator_DynamicPoints final : public UEnvQueryGenerator_ProjectedPoints
{
public:
	struct FAIDataProviderFloatValue              InnerRadius;                                       // 0x0098(0x0030)(Edit, DisableEditOnInstance, ContainsInstancedReference, NativeAccessSpecifierPublic)
	struct FAIDataProviderFloatValue              OuterRadius;                                       // 0x00C8(0x0030)(Edit, DisableEditOnInstance, ContainsInstancedReference, NativeAccessSpecifierPublic)
	struct FEQSDynamicPointRange                  PointsPerRing;                                     // 0x00F8(0x0010)(Edit, DisableEditOnInstance, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
	struct FEQSDynamicPointRange                  NumberOfRings;                                     // 0x0108(0x0010)(Edit, DisableEditOnInstance, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
	struct FEQSDynamicPointRange                  NumberOfLayers;                                    // 0x0118(0x0010)(Edit, DisableEditOnInstance, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
	struct FAIDataProviderFloatValue              TopLayerHeight;                                    // 0x0128(0x0030)(Edit, DisableEditOnInstance, ContainsInstancedReference, NativeAccessSpecifierPublic)
	struct FAIDataProviderFloatValue              BottomLayerHeight;                                 // 0x0158(0x0030)(Edit, DisableEditOnInstance, ContainsInstancedReference, NativeAccessSpecifierPublic)
	uint8                                         bUseLayers : 1;                                    // 0x0188(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (Edit, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         Pad_189[0x3];                                      // 0x0189(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	int32                                         NumberOfPointsMin;                                 // 0x018C(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         NumberOfPointsMax;                                 // 0x0190(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_194[0x4];                                      // 0x0194(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	struct FEnvDirection                          ArcDirection;                                      // 0x0198(0x0020)(Edit, DisableEditOnInstance, NoDestructor, NativeAccessSpecifierPublic)
	struct FAIDataProviderFloatValue              ArcAngle;                                          // 0x01B8(0x0030)(Edit, DisableEditOnInstance, ContainsInstancedReference, NativeAccessSpecifierPublic)
	uint8                                         bDefineArc : 1;                                    // 0x01E8(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (Edit, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         Pad_1E9[0x7];                                      // 0x01E9(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	TSubclassOf<class UEnvQueryContext>           Center;                                            // 0x01F0(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"EnvQueryGenerator_DynamicPoints">();
	}
	static class UEnvQueryGenerator_DynamicPoints* GetDefaultObj()
	{
		return GetDefaultObjImpl<UEnvQueryGenerator_DynamicPoints>();
	}
};
static_assert(alignof(UEnvQueryGenerator_DynamicPoints) == 0x000008, "Wrong alignment on UEnvQueryGenerator_DynamicPoints");
static_assert(sizeof(UEnvQueryGenerator_DynamicPoints) == 0x0001F8, "Wrong size on UEnvQueryGenerator_DynamicPoints");
static_assert(offsetof(UEnvQueryGenerator_DynamicPoints, InnerRadius) == 0x000098, "Member 'UEnvQueryGenerator_DynamicPoints::InnerRadius' has a wrong offset!");
static_assert(offsetof(UEnvQueryGenerator_DynamicPoints, OuterRadius) == 0x0000C8, "Member 'UEnvQueryGenerator_DynamicPoints::OuterRadius' has a wrong offset!");
static_assert(offsetof(UEnvQueryGenerator_DynamicPoints, PointsPerRing) == 0x0000F8, "Member 'UEnvQueryGenerator_DynamicPoints::PointsPerRing' has a wrong offset!");
static_assert(offsetof(UEnvQueryGenerator_DynamicPoints, NumberOfRings) == 0x000108, "Member 'UEnvQueryGenerator_DynamicPoints::NumberOfRings' has a wrong offset!");
static_assert(offsetof(UEnvQueryGenerator_DynamicPoints, NumberOfLayers) == 0x000118, "Member 'UEnvQueryGenerator_DynamicPoints::NumberOfLayers' has a wrong offset!");
static_assert(offsetof(UEnvQueryGenerator_DynamicPoints, TopLayerHeight) == 0x000128, "Member 'UEnvQueryGenerator_DynamicPoints::TopLayerHeight' has a wrong offset!");
static_assert(offsetof(UEnvQueryGenerator_DynamicPoints, BottomLayerHeight) == 0x000158, "Member 'UEnvQueryGenerator_DynamicPoints::BottomLayerHeight' has a wrong offset!");
static_assert(offsetof(UEnvQueryGenerator_DynamicPoints, NumberOfPointsMin) == 0x00018C, "Member 'UEnvQueryGenerator_DynamicPoints::NumberOfPointsMin' has a wrong offset!");
static_assert(offsetof(UEnvQueryGenerator_DynamicPoints, NumberOfPointsMax) == 0x000190, "Member 'UEnvQueryGenerator_DynamicPoints::NumberOfPointsMax' has a wrong offset!");
static_assert(offsetof(UEnvQueryGenerator_DynamicPoints, ArcDirection) == 0x000198, "Member 'UEnvQueryGenerator_DynamicPoints::ArcDirection' has a wrong offset!");
static_assert(offsetof(UEnvQueryGenerator_DynamicPoints, ArcAngle) == 0x0001B8, "Member 'UEnvQueryGenerator_DynamicPoints::ArcAngle' has a wrong offset!");
static_assert(offsetof(UEnvQueryGenerator_DynamicPoints, Center) == 0x0001F0, "Member 'UEnvQueryGenerator_DynamicPoints::Center' has a wrong offset!");

// Class GbxAI.AIAspect_EnvQuery
// 0x03C0 (0x04C0 - 0x0100)
class UAIAspect_EnvQuery : public UAIAspect
{
public:
	struct FAIAspectSettings_EnvQuery             Settings;                                          // 0x0100(0x03A0)(Edit, ContainsInstancedReference, NativeAccessSpecifierPublic)
	uint8                                         Pad_4A0[0x10];                                     // 0x04A0(0x0010)(Fixing Size After Last Property [ Dumper-7 ])
	UMulticastDelegateProperty_                   OnValueUpdatedBP;                                  // 0x04B0(0x0010)(ZeroConstructor, Transient, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)

public:
	static class FString GetQuerySettingsDescription(const struct FAIAspectSettings_EnvQuery& QuerySettings, class UProperty* Property);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"AIAspect_EnvQuery">();
	}
	static class UAIAspect_EnvQuery* GetDefaultObj()
	{
		return GetDefaultObjImpl<UAIAspect_EnvQuery>();
	}
};
static_assert(alignof(UAIAspect_EnvQuery) == 0x000008, "Wrong alignment on UAIAspect_EnvQuery");
static_assert(sizeof(UAIAspect_EnvQuery) == 0x0004C0, "Wrong size on UAIAspect_EnvQuery");
static_assert(offsetof(UAIAspect_EnvQuery, Settings) == 0x000100, "Member 'UAIAspect_EnvQuery::Settings' has a wrong offset!");
static_assert(offsetof(UAIAspect_EnvQuery, OnValueUpdatedBP) == 0x0004B0, "Member 'UAIAspect_EnvQuery::OnValueUpdatedBP' has a wrong offset!");

// Class GbxAI.AIAspect_FaceNearbyCover
// 0x0010 (0x0110 - 0x0100)
class UAIAspect_FaceNearbyCover final : public UAIAspect
{
public:
	struct FGbxBlackboardKeySelector              CoverKey;                                          // 0x0100(0x0010)(Edit, NoDestructor, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"AIAspect_FaceNearbyCover">();
	}
	static class UAIAspect_FaceNearbyCover* GetDefaultObj()
	{
		return GetDefaultObjImpl<UAIAspect_FaceNearbyCover>();
	}
};
static_assert(alignof(UAIAspect_FaceNearbyCover) == 0x000008, "Wrong alignment on UAIAspect_FaceNearbyCover");
static_assert(sizeof(UAIAspect_FaceNearbyCover) == 0x000110, "Wrong size on UAIAspect_FaceNearbyCover");
static_assert(offsetof(UAIAspect_FaceNearbyCover, CoverKey) == 0x000100, "Member 'UAIAspect_FaceNearbyCover::CoverKey' has a wrong offset!");

// Class GbxAI.AIAspect_GbxAction
// 0x0238 (0x0338 - 0x0100)
class UAIAspect_GbxAction : public UAIAspect
{
public:
	struct FAIAspectSettings_GbxAction            Settings;                                          // 0x0100(0x0238)(Edit, NoDestructor, ContainsInstancedReference, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"AIAspect_GbxAction">();
	}
	static class UAIAspect_GbxAction* GetDefaultObj()
	{
		return GetDefaultObjImpl<UAIAspect_GbxAction>();
	}
};
static_assert(alignof(UAIAspect_GbxAction) == 0x000008, "Wrong alignment on UAIAspect_GbxAction");
static_assert(sizeof(UAIAspect_GbxAction) == 0x000338, "Wrong size on UAIAspect_GbxAction");
static_assert(offsetof(UAIAspect_GbxAction, Settings) == 0x000100, "Member 'UAIAspect_GbxAction::Settings' has a wrong offset!");

// Class GbxAI.AIAspect_FallToGround
// 0x0000 (0x0338 - 0x0338)
class UAIAspect_FallToGround final : public UAIAspect_GbxAction
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"AIAspect_FallToGround">();
	}
	static class UAIAspect_FallToGround* GetDefaultObj()
	{
		return GetDefaultObjImpl<UAIAspect_FallToGround>();
	}
};
static_assert(alignof(UAIAspect_FallToGround) == 0x000008, "Wrong alignment on UAIAspect_FallToGround");
static_assert(sizeof(UAIAspect_FallToGround) == 0x000338, "Wrong size on UAIAspect_FallToGround");

// Class GbxAI.EnvQueryTest_CoverView
// 0x0038 (0x0210 - 0x01D8)
class UEnvQueryTest_CoverView final : public UEnvQueryTest
{
public:
	TSubclassOf<class UEnvQueryContext>           Context;                                           // 0x01D8(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	struct FAIDataProviderBoolValue               DoViewTest;                                        // 0x01E0(0x0030)(Edit, DisableEditOnInstance, ContainsInstancedReference, NativeAccessSpecifierPrivate)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"EnvQueryTest_CoverView">();
	}
	static class UEnvQueryTest_CoverView* GetDefaultObj()
	{
		return GetDefaultObjImpl<UEnvQueryTest_CoverView>();
	}
};
static_assert(alignof(UEnvQueryTest_CoverView) == 0x000008, "Wrong alignment on UEnvQueryTest_CoverView");
static_assert(sizeof(UEnvQueryTest_CoverView) == 0x000210, "Wrong size on UEnvQueryTest_CoverView");
static_assert(offsetof(UEnvQueryTest_CoverView, Context) == 0x0001D8, "Member 'UEnvQueryTest_CoverView::Context' has a wrong offset!");
static_assert(offsetof(UEnvQueryTest_CoverView, DoViewTest) == 0x0001E0, "Member 'UEnvQueryTest_CoverView::DoViewTest' has a wrong offset!");

// Class GbxAI.AIAspect_FindClosestPlayer
// 0x0020 (0x0120 - 0x0100)
class UAIAspect_FindClosestPlayer final : public UAIAspect
{
public:
	struct FAIAspectSettings_FindClosestPlayer    Settings;                                          // 0x0100(0x0020)(Edit, NoDestructor, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"AIAspect_FindClosestPlayer">();
	}
	static class UAIAspect_FindClosestPlayer* GetDefaultObj()
	{
		return GetDefaultObjImpl<UAIAspect_FindClosestPlayer>();
	}
};
static_assert(alignof(UAIAspect_FindClosestPlayer) == 0x000008, "Wrong alignment on UAIAspect_FindClosestPlayer");
static_assert(sizeof(UAIAspect_FindClosestPlayer) == 0x000120, "Wrong size on UAIAspect_FindClosestPlayer");
static_assert(offsetof(UAIAspect_FindClosestPlayer, Settings) == 0x000100, "Member 'UAIAspect_FindClosestPlayer::Settings' has a wrong offset!");

// Class GbxAI.AIAspect_FindCover
// 0x0008 (0x04C8 - 0x04C0)
class UAIAspect_FindCover final : public UAIAspect_EnvQuery
{
public:
	bool                                          bCheckFlanking;                                    // 0x04C0(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_4C1[0x7];                                      // 0x04C1(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"AIAspect_FindCover">();
	}
	static class UAIAspect_FindCover* GetDefaultObj()
	{
		return GetDefaultObjImpl<UAIAspect_FindCover>();
	}
};
static_assert(alignof(UAIAspect_FindCover) == 0x000008, "Wrong alignment on UAIAspect_FindCover");
static_assert(sizeof(UAIAspect_FindCover) == 0x0004C8, "Wrong size on UAIAspect_FindCover");
static_assert(offsetof(UAIAspect_FindCover, bCheckFlanking) == 0x0004C0, "Member 'UAIAspect_FindCover::bCheckFlanking' has a wrong offset!");

// Class GbxAI.AIAspect_FlyToNavMesh
// 0x0010 (0x0250 - 0x0240)
class UAIAspect_FlyToNavMesh final : public UAIAspect_Navigation
{
public:
	struct FAIAspectSettings_FlyToNavMesh         FlyToNavMeshSettings;                              // 0x0240(0x0010)(Edit, NoDestructor, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"AIAspect_FlyToNavMesh">();
	}
	static class UAIAspect_FlyToNavMesh* GetDefaultObj()
	{
		return GetDefaultObjImpl<UAIAspect_FlyToNavMesh>();
	}
};
static_assert(alignof(UAIAspect_FlyToNavMesh) == 0x000008, "Wrong alignment on UAIAspect_FlyToNavMesh");
static_assert(sizeof(UAIAspect_FlyToNavMesh) == 0x000250, "Wrong size on UAIAspect_FlyToNavMesh");
static_assert(offsetof(UAIAspect_FlyToNavMesh, FlyToNavMeshSettings) == 0x000240, "Member 'UAIAspect_FlyToNavMesh::FlyToNavMeshSettings' has a wrong offset!");

// Class GbxAI.AIAspect_FollowUpdate
// 0x01A8 (0x02A8 - 0x0100)
class UAIAspect_FollowUpdate final : public UAIAspect
{
public:
	struct FAIAspectSettings_Follow               Settings;                                          // 0x0100(0x0038)(Edit, NoDestructor, NativeAccessSpecifierPublic)
	struct FAIAspectSettings_Navigation           NavSettings;                                       // 0x0138(0x0140)(NoDestructor, ContainsInstancedReference, NativeAccessSpecifierPublic)
	struct FGbxBlackboardKeySelector              TeleportTarget;                                    // 0x0278(0x0010)(NoDestructor, NativeAccessSpecifierPublic)
	struct FGbxBlackboardKeySelector              MoveTarget;                                        // 0x0288(0x0010)(NoDestructor, NativeAccessSpecifierPublic)
	struct FGbxBlackboardKeySelector              Distance;                                          // 0x0298(0x0010)(NoDestructor, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"AIAspect_FollowUpdate">();
	}
	static class UAIAspect_FollowUpdate* GetDefaultObj()
	{
		return GetDefaultObjImpl<UAIAspect_FollowUpdate>();
	}
};
static_assert(alignof(UAIAspect_FollowUpdate) == 0x000008, "Wrong alignment on UAIAspect_FollowUpdate");
static_assert(sizeof(UAIAspect_FollowUpdate) == 0x0002A8, "Wrong size on UAIAspect_FollowUpdate");
static_assert(offsetof(UAIAspect_FollowUpdate, Settings) == 0x000100, "Member 'UAIAspect_FollowUpdate::Settings' has a wrong offset!");
static_assert(offsetof(UAIAspect_FollowUpdate, NavSettings) == 0x000138, "Member 'UAIAspect_FollowUpdate::NavSettings' has a wrong offset!");
static_assert(offsetof(UAIAspect_FollowUpdate, TeleportTarget) == 0x000278, "Member 'UAIAspect_FollowUpdate::TeleportTarget' has a wrong offset!");
static_assert(offsetof(UAIAspect_FollowUpdate, MoveTarget) == 0x000288, "Member 'UAIAspect_FollowUpdate::MoveTarget' has a wrong offset!");
static_assert(offsetof(UAIAspect_FollowUpdate, Distance) == 0x000298, "Member 'UAIAspect_FollowUpdate::Distance' has a wrong offset!");

// Class GbxAI.EnvQueryItemType_SmartAction
// 0x0000 (0x0030 - 0x0030)
class UEnvQueryItemType_SmartAction final : public UEnvQueryItemType_VectorBase
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"EnvQueryItemType_SmartAction">();
	}
	static class UEnvQueryItemType_SmartAction* GetDefaultObj()
	{
		return GetDefaultObjImpl<UEnvQueryItemType_SmartAction>();
	}
};
static_assert(alignof(UEnvQueryItemType_SmartAction) == 0x000008, "Wrong alignment on UEnvQueryItemType_SmartAction");
static_assert(sizeof(UEnvQueryItemType_SmartAction) == 0x000030, "Wrong size on UEnvQueryItemType_SmartAction");

// Class GbxAI.AIAspect_GroupLocation
// 0x0098 (0x0198 - 0x0100)
class UAIAspect_GroupLocation final : public UAIAspect
{
public:
	struct FAIAspectSettings_GroupLocation        Settings;                                          // 0x0100(0x0098)(Edit, NoDestructor, ContainsInstancedReference, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"AIAspect_GroupLocation">();
	}
	static class UAIAspect_GroupLocation* GetDefaultObj()
	{
		return GetDefaultObjImpl<UAIAspect_GroupLocation>();
	}
};
static_assert(alignof(UAIAspect_GroupLocation) == 0x000008, "Wrong alignment on UAIAspect_GroupLocation");
static_assert(sizeof(UAIAspect_GroupLocation) == 0x000198, "Wrong size on UAIAspect_GroupLocation");
static_assert(offsetof(UAIAspect_GroupLocation, Settings) == 0x000100, "Member 'UAIAspect_GroupLocation::Settings' has a wrong offset!");

// Class GbxAI.AIAspect_IntCompare
// 0x00A0 (0x01A0 - 0x0100)
class UAIAspect_IntCompare final : public UAIAspect
{
public:
	struct FAIAspectSettings_IntCompare           Settings;                                          // 0x0100(0x00A0)(Edit, NoDestructor, ContainsInstancedReference, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"AIAspect_IntCompare">();
	}
	static class UAIAspect_IntCompare* GetDefaultObj()
	{
		return GetDefaultObjImpl<UAIAspect_IntCompare>();
	}
};
static_assert(alignof(UAIAspect_IntCompare) == 0x000008, "Wrong alignment on UAIAspect_IntCompare");
static_assert(sizeof(UAIAspect_IntCompare) == 0x0001A0, "Wrong size on UAIAspect_IntCompare");
static_assert(offsetof(UAIAspect_IntCompare, Settings) == 0x000100, "Member 'UAIAspect_IntCompare::Settings' has a wrong offset!");

// Class GbxAI.BTTask_AIAction_Custom
// 0x0008 (0x0080 - 0x0078)
class UBTTask_AIAction_Custom final : public UBTTask_AIAction
{
public:
	class UAIAction*                              Action;                                            // 0x0078(0x0008)(Edit, ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, PersistentInstance, HasGetValueTypeHash, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"BTTask_AIAction_Custom">();
	}
	static class UBTTask_AIAction_Custom* GetDefaultObj()
	{
		return GetDefaultObjImpl<UBTTask_AIAction_Custom>();
	}
};
static_assert(alignof(UBTTask_AIAction_Custom) == 0x000008, "Wrong alignment on UBTTask_AIAction_Custom");
static_assert(sizeof(UBTTask_AIAction_Custom) == 0x000080, "Wrong size on UBTTask_AIAction_Custom");
static_assert(offsetof(UBTTask_AIAction_Custom, Action) == 0x000078, "Member 'UBTTask_AIAction_Custom::Action' has a wrong offset!");

// Class GbxAI.AIAspect_IsInRange
// 0x0248 (0x0348 - 0x0100)
class UAIAspect_IsInRange final : public UAIAspect
{
public:
	struct FAIAspectSettings_IsInRange            Settings;                                          // 0x0100(0x0248)(Edit, NoDestructor, ContainsInstancedReference, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"AIAspect_IsInRange">();
	}
	static class UAIAspect_IsInRange* GetDefaultObj()
	{
		return GetDefaultObjImpl<UAIAspect_IsInRange>();
	}
};
static_assert(alignof(UAIAspect_IsInRange) == 0x000008, "Wrong alignment on UAIAspect_IsInRange");
static_assert(sizeof(UAIAspect_IsInRange) == 0x000348, "Wrong size on UAIAspect_IsInRange");
static_assert(offsetof(UAIAspect_IsInRange, Settings) == 0x000100, "Member 'UAIAspect_IsInRange::Settings' has a wrong offset!");

// Class GbxAI.AIAspect_IsInTerritory
// 0x0018 (0x0118 - 0x0100)
class UAIAspect_IsInTerritory final : public UAIAspect
{
public:
	struct FAIAspectSettings_IsInTerritory        Settings;                                          // 0x0100(0x0018)(Edit, NoDestructor, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"AIAspect_IsInTerritory">();
	}
	static class UAIAspect_IsInTerritory* GetDefaultObj()
	{
		return GetDefaultObjImpl<UAIAspect_IsInTerritory>();
	}
};
static_assert(alignof(UAIAspect_IsInTerritory) == 0x000008, "Wrong alignment on UAIAspect_IsInTerritory");
static_assert(sizeof(UAIAspect_IsInTerritory) == 0x000118, "Wrong size on UAIAspect_IsInTerritory");
static_assert(offsetof(UAIAspect_IsInTerritory, Settings) == 0x000100, "Member 'UAIAspect_IsInTerritory::Settings' has a wrong offset!");

// Class GbxAI.EnvQueryTest_PetOwnerDistance
// 0x0038 (0x0210 - 0x01D8)
class UEnvQueryTest_PetOwnerDistance final : public UEnvQueryTest
{
public:
	struct FAIDataProviderFloatValue              MaxDistanceToOwner;                                // 0x01D8(0x0030)(Edit, ContainsInstancedReference, NativeAccessSpecifierPrivate)
	struct FGameplayTag                           AnyDistanceTag;                                    // 0x0208(0x0008)(Edit, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"EnvQueryTest_PetOwnerDistance">();
	}
	static class UEnvQueryTest_PetOwnerDistance* GetDefaultObj()
	{
		return GetDefaultObjImpl<UEnvQueryTest_PetOwnerDistance>();
	}
};
static_assert(alignof(UEnvQueryTest_PetOwnerDistance) == 0x000008, "Wrong alignment on UEnvQueryTest_PetOwnerDistance");
static_assert(sizeof(UEnvQueryTest_PetOwnerDistance) == 0x000210, "Wrong size on UEnvQueryTest_PetOwnerDistance");
static_assert(offsetof(UEnvQueryTest_PetOwnerDistance, MaxDistanceToOwner) == 0x0001D8, "Member 'UEnvQueryTest_PetOwnerDistance::MaxDistanceToOwner' has a wrong offset!");
static_assert(offsetof(UEnvQueryTest_PetOwnerDistance, AnyDistanceTag) == 0x000208, "Member 'UEnvQueryTest_PetOwnerDistance::AnyDistanceTag' has a wrong offset!");

// Class GbxAI.AIAspect_Land
// 0x0010 (0x0250 - 0x0240)
class UAIAspect_Land final : public UAIAspect_Navigation
{
public:
	struct FAIAspectSettings_Land                 LandSettings;                                      // 0x0240(0x000C)(Edit, NoDestructor, NativeAccessSpecifierPublic)
	uint8                                         Pad_24C[0x4];                                      // 0x024C(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"AIAspect_Land">();
	}
	static class UAIAspect_Land* GetDefaultObj()
	{
		return GetDefaultObjImpl<UAIAspect_Land>();
	}
};
static_assert(alignof(UAIAspect_Land) == 0x000008, "Wrong alignment on UAIAspect_Land");
static_assert(sizeof(UAIAspect_Land) == 0x000250, "Wrong size on UAIAspect_Land");
static_assert(offsetof(UAIAspect_Land, LandSettings) == 0x000240, "Member 'UAIAspect_Land::LandSettings' has a wrong offset!");

// Class GbxAI.AIAspect_LeadUpdate
// 0x0080 (0x0180 - 0x0100)
class UAIAspect_LeadUpdate final : public UAIAspect
{
public:
	struct FAIAspectSettings_LeadRoute            LeadSettings;                                      // 0x0100(0x0050)(Edit, NoDestructor, NativeAccessSpecifierPublic)
	struct FGbxBlackboardKeySelector              MoveTarget;                                        // 0x0150(0x0010)(NoDestructor, NativeAccessSpecifierPublic)
	struct FGbxBlackboardKeySelector              Distance;                                          // 0x0160(0x0010)(NoDestructor, NativeAccessSpecifierPublic)
	struct FGbxBlackboardKeySelector              TeleportTarget;                                    // 0x0170(0x0010)(NoDestructor, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"AIAspect_LeadUpdate">();
	}
	static class UAIAspect_LeadUpdate* GetDefaultObj()
	{
		return GetDefaultObjImpl<UAIAspect_LeadUpdate>();
	}
};
static_assert(alignof(UAIAspect_LeadUpdate) == 0x000008, "Wrong alignment on UAIAspect_LeadUpdate");
static_assert(sizeof(UAIAspect_LeadUpdate) == 0x000180, "Wrong size on UAIAspect_LeadUpdate");
static_assert(offsetof(UAIAspect_LeadUpdate, LeadSettings) == 0x000100, "Member 'UAIAspect_LeadUpdate::LeadSettings' has a wrong offset!");
static_assert(offsetof(UAIAspect_LeadUpdate, MoveTarget) == 0x000150, "Member 'UAIAspect_LeadUpdate::MoveTarget' has a wrong offset!");
static_assert(offsetof(UAIAspect_LeadUpdate, Distance) == 0x000160, "Member 'UAIAspect_LeadUpdate::Distance' has a wrong offset!");
static_assert(offsetof(UAIAspect_LeadUpdate, TeleportTarget) == 0x000170, "Member 'UAIAspect_LeadUpdate::TeleportTarget' has a wrong offset!");

// Class GbxAI.AIAspect_Leap
// 0x0058 (0x0158 - 0x0100)
class UAIAspect_Leap final : public UAIAspect
{
public:
	struct FAIAspectSettings_Leap                 Settings;                                          // 0x0100(0x0058)(Edit, NoDestructor, NativeAccessSpecifierPublic)

public:
	static class FString GetQuerySettingsDescription(const struct FAIAspectSettings_Leap& LeapSettings, class UProperty* Property);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"AIAspect_Leap">();
	}
	static class UAIAspect_Leap* GetDefaultObj()
	{
		return GetDefaultObjImpl<UAIAspect_Leap>();
	}
};
static_assert(alignof(UAIAspect_Leap) == 0x000008, "Wrong alignment on UAIAspect_Leap");
static_assert(sizeof(UAIAspect_Leap) == 0x000158, "Wrong size on UAIAspect_Leap");
static_assert(offsetof(UAIAspect_Leap, Settings) == 0x000100, "Member 'UAIAspect_Leap::Settings' has a wrong offset!");

// Class GbxAI.AIAspect_Location
// 0x01E0 (0x02E0 - 0x0100)
class UAIAspect_Location final : public UAIAspect
{
public:
	struct FAIAspectSettings_Location             Settings;                                          // 0x0100(0x01E0)(Edit, ContainsInstancedReference, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"AIAspect_Location">();
	}
	static class UAIAspect_Location* GetDefaultObj()
	{
		return GetDefaultObjImpl<UAIAspect_Location>();
	}
};
static_assert(alignof(UAIAspect_Location) == 0x000008, "Wrong alignment on UAIAspect_Location");
static_assert(sizeof(UAIAspect_Location) == 0x0002E0, "Wrong size on UAIAspect_Location");
static_assert(offsetof(UAIAspect_Location, Settings) == 0x000100, "Member 'UAIAspect_Location::Settings' has a wrong offset!");

// Class GbxAI.EnvQueryTest_BlackboardKey
// 0x0010 (0x01E8 - 0x01D8)
class UEnvQueryTest_BlackboardKey final : public UEnvQueryTest
{
public:
	struct FGbxBlackboardKeySelector              BlackboardKey;                                     // 0x01D8(0x0010)(Edit, NoDestructor, NativeAccessSpecifierPrivate)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"EnvQueryTest_BlackboardKey">();
	}
	static class UEnvQueryTest_BlackboardKey* GetDefaultObj()
	{
		return GetDefaultObjImpl<UEnvQueryTest_BlackboardKey>();
	}
};
static_assert(alignof(UEnvQueryTest_BlackboardKey) == 0x000008, "Wrong alignment on UEnvQueryTest_BlackboardKey");
static_assert(sizeof(UEnvQueryTest_BlackboardKey) == 0x0001E8, "Wrong size on UEnvQueryTest_BlackboardKey");
static_assert(offsetof(UEnvQueryTest_BlackboardKey, BlackboardKey) == 0x0001D8, "Member 'UEnvQueryTest_BlackboardKey::BlackboardKey' has a wrong offset!");

// Class GbxAI.AIAspect_LockTarget
// 0x0008 (0x0108 - 0x0100)
class UAIAspect_LockTarget final : public UAIAspect
{
public:
	bool                                          bFailOnTargetChange;                               // 0x0100(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_101[0x7];                                      // 0x0101(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"AIAspect_LockTarget">();
	}
	static class UAIAspect_LockTarget* GetDefaultObj()
	{
		return GetDefaultObjImpl<UAIAspect_LockTarget>();
	}
};
static_assert(alignof(UAIAspect_LockTarget) == 0x000008, "Wrong alignment on UAIAspect_LockTarget");
static_assert(sizeof(UAIAspect_LockTarget) == 0x000108, "Wrong size on UAIAspect_LockTarget");
static_assert(offsetof(UAIAspect_LockTarget, bFailOnTargetChange) == 0x000100, "Member 'UAIAspect_LockTarget::bFailOnTargetChange' has a wrong offset!");

// Class GbxAI.AIAspect_LookAroundRandomly
// 0x0050 (0x0150 - 0x0100)
class UAIAspect_LookAroundRandomly final : public UAIAspect
{
public:
	uint8                                         Pad_100[0x50];                                     // 0x0100(0x0050)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"AIAspect_LookAroundRandomly">();
	}
	static class UAIAspect_LookAroundRandomly* GetDefaultObj()
	{
		return GetDefaultObjImpl<UAIAspect_LookAroundRandomly>();
	}
};
static_assert(alignof(UAIAspect_LookAroundRandomly) == 0x000008, "Wrong alignment on UAIAspect_LookAroundRandomly");
static_assert(sizeof(UAIAspect_LookAroundRandomly) == 0x000150, "Wrong size on UAIAspect_LookAroundRandomly");

// Class GbxAI.GameplayTask_ScriptedAction
// 0x0058 (0x00C0 - 0x0068)
class UGameplayTask_ScriptedAction : public UGameplayTask
{
public:
	uint8                                         Pad_68[0x18];                                      // 0x0068(0x0018)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<class AGbxAIController*>               Controllers;                                       // 0x0080(0x0010)(ZeroConstructor, Transient, NativeAccessSpecifierPrivate)
	TArray<class AGbxAIController*>               AbortingControllers;                               // 0x0090(0x0010)(ZeroConstructor, Transient, NativeAccessSpecifierPrivate)
	class UAIAction*                              ScriptedAIAction;                                  // 0x00A0(0x0008)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_A8[0x18];                                      // 0x00A8(0x0018)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void OnActorSpawned(class ASpawner* Spawner, class AActor* Actor);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"GameplayTask_ScriptedAction">();
	}
	static class UGameplayTask_ScriptedAction* GetDefaultObj()
	{
		return GetDefaultObjImpl<UGameplayTask_ScriptedAction>();
	}
};
static_assert(alignof(UGameplayTask_ScriptedAction) == 0x000008, "Wrong alignment on UGameplayTask_ScriptedAction");
static_assert(sizeof(UGameplayTask_ScriptedAction) == 0x0000C0, "Wrong size on UGameplayTask_ScriptedAction");
static_assert(offsetof(UGameplayTask_ScriptedAction, Controllers) == 0x000080, "Member 'UGameplayTask_ScriptedAction::Controllers' has a wrong offset!");
static_assert(offsetof(UGameplayTask_ScriptedAction, AbortingControllers) == 0x000090, "Member 'UGameplayTask_ScriptedAction::AbortingControllers' has a wrong offset!");
static_assert(offsetof(UGameplayTask_ScriptedAction, ScriptedAIAction) == 0x0000A0, "Member 'UGameplayTask_ScriptedAction::ScriptedAIAction' has a wrong offset!");

// Class GbxAI.GameplayTask_ScriptedMove
// 0x0040 (0x0100 - 0x00C0)
class UGameplayTask_ScriptedMove final : public UGameplayTask_ScriptedAction
{
public:
	UMulticastDelegateProperty_                   OnAborted;                                         // 0x00C0(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	UMulticastDelegateProperty_                   OnCompleted;                                       // 0x00D0(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	class AActor*                                 AINode;                                            // 0x00E0(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UStanceDataProvider*                    StanceProvider;                                    // 0x00E8(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class AActor*                                 LookAtActor;                                       // 0x00F0(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	bool                                          bTeleportOnFail;                                   // 0x00F8(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_F9[0x7];                                       // 0x00F9(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UGameplayTask_ScriptedMove* BeginScriptedMove(class AActor* Target, class AActor* StartNode, EScriptedActionRule SuccessRule, EScriptedActionRule FailRule, bool bAddSpawned, class UStanceDataProvider* OptionalStance, class AActor* OptionalLookAtActor, bool bTeleportOnFail_0);
	static class UGameplayTask_ScriptedMove* BeginScriptedMove2(class AActor* User, class AActor* StartAINode, class UStanceDataProvider* OptionalStance, class AActor* OptionalLookAtActor);
	static class UGameplayTask_ScriptedMove* BeginScriptedMoveActor(class AAIController* Target, class AActor* StartNode, class UStanceDataProvider* OptionalStance, class AActor* OptionalLookAtActor);

	void TaskScriptedMoveDelegate__DelegateSignature();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"GameplayTask_ScriptedMove">();
	}
	static class UGameplayTask_ScriptedMove* GetDefaultObj()
	{
		return GetDefaultObjImpl<UGameplayTask_ScriptedMove>();
	}
};
static_assert(alignof(UGameplayTask_ScriptedMove) == 0x000008, "Wrong alignment on UGameplayTask_ScriptedMove");
static_assert(sizeof(UGameplayTask_ScriptedMove) == 0x000100, "Wrong size on UGameplayTask_ScriptedMove");
static_assert(offsetof(UGameplayTask_ScriptedMove, OnAborted) == 0x0000C0, "Member 'UGameplayTask_ScriptedMove::OnAborted' has a wrong offset!");
static_assert(offsetof(UGameplayTask_ScriptedMove, OnCompleted) == 0x0000D0, "Member 'UGameplayTask_ScriptedMove::OnCompleted' has a wrong offset!");
static_assert(offsetof(UGameplayTask_ScriptedMove, AINode) == 0x0000E0, "Member 'UGameplayTask_ScriptedMove::AINode' has a wrong offset!");
static_assert(offsetof(UGameplayTask_ScriptedMove, StanceProvider) == 0x0000E8, "Member 'UGameplayTask_ScriptedMove::StanceProvider' has a wrong offset!");
static_assert(offsetof(UGameplayTask_ScriptedMove, LookAtActor) == 0x0000F0, "Member 'UGameplayTask_ScriptedMove::LookAtActor' has a wrong offset!");
static_assert(offsetof(UGameplayTask_ScriptedMove, bTeleportOnFail) == 0x0000F8, "Member 'UGameplayTask_ScriptedMove::bTeleportOnFail' has a wrong offset!");

// Class GbxAI.AIAspect_Loop
// 0x0198 (0x0298 - 0x0100)
class UAIAspect_Loop final : public UAIAspect
{
public:
	struct FAIAspectSettings_Loop                 Settings;                                          // 0x0100(0x0198)(Edit, NoDestructor, ContainsInstancedReference, NativeAccessSpecifierPublic)

public:
	static class FString GetSettingsDescription(const struct FAIAspectSettings_Loop& LoopSettings);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"AIAspect_Loop">();
	}
	static class UAIAspect_Loop* GetDefaultObj()
	{
		return GetDefaultObjImpl<UAIAspect_Loop>();
	}
};
static_assert(alignof(UAIAspect_Loop) == 0x000008, "Wrong alignment on UAIAspect_Loop");
static_assert(sizeof(UAIAspect_Loop) == 0x000298, "Wrong size on UAIAspect_Loop");
static_assert(offsetof(UAIAspect_Loop, Settings) == 0x000100, "Member 'UAIAspect_Loop::Settings' has a wrong offset!");

// Class GbxAI.AIAspect_MoveSpline
// 0x0050 (0x0290 - 0x0240)
class UAIAspect_MoveSpline final : public UAIAspect_Navigation
{
public:
	struct FAIAspectSettings_MoveSpline           MoveSplineSettings;                                // 0x0240(0x0050)(Edit, NoDestructor, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"AIAspect_MoveSpline">();
	}
	static class UAIAspect_MoveSpline* GetDefaultObj()
	{
		return GetDefaultObjImpl<UAIAspect_MoveSpline>();
	}
};
static_assert(alignof(UAIAspect_MoveSpline) == 0x000008, "Wrong alignment on UAIAspect_MoveSpline");
static_assert(sizeof(UAIAspect_MoveSpline) == 0x000290, "Wrong size on UAIAspect_MoveSpline");
static_assert(offsetof(UAIAspect_MoveSpline, MoveSplineSettings) == 0x000240, "Member 'UAIAspect_MoveSpline::MoveSplineSettings' has a wrong offset!");

// Class GbxAI.EnvQueryTest_TargetSensed
// 0x0028 (0x0200 - 0x01D8)
class UEnvQueryTest_TargetSensed final : public UEnvQueryTest
{
public:
	class FString                                 DevLabel;                                          // 0x01D8(0x0010)(Edit, ZeroConstructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TArray<TSubclassOf<class UAISense>>           SensesToTestFor;                                   // 0x01E8(0x0010)(Edit, ZeroConstructor, Protected, UObjectWrapper, NativeAccessSpecifierProtected)
	float                                         TimeToCareAboutStimuli;                            // 0x01F8(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_1FC[0x4];                                      // 0x01FC(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"EnvQueryTest_TargetSensed">();
	}
	static class UEnvQueryTest_TargetSensed* GetDefaultObj()
	{
		return GetDefaultObjImpl<UEnvQueryTest_TargetSensed>();
	}
};
static_assert(alignof(UEnvQueryTest_TargetSensed) == 0x000008, "Wrong alignment on UEnvQueryTest_TargetSensed");
static_assert(sizeof(UEnvQueryTest_TargetSensed) == 0x000200, "Wrong size on UEnvQueryTest_TargetSensed");
static_assert(offsetof(UEnvQueryTest_TargetSensed, DevLabel) == 0x0001D8, "Member 'UEnvQueryTest_TargetSensed::DevLabel' has a wrong offset!");
static_assert(offsetof(UEnvQueryTest_TargetSensed, SensesToTestFor) == 0x0001E8, "Member 'UEnvQueryTest_TargetSensed::SensesToTestFor' has a wrong offset!");
static_assert(offsetof(UEnvQueryTest_TargetSensed, TimeToCareAboutStimuli) == 0x0001F8, "Member 'UEnvQueryTest_TargetSensed::TimeToCareAboutStimuli' has a wrong offset!");

// Class GbxAI.AIAspect_NavBlackboard
// 0x0020 (0x0260 - 0x0240)
class UAIAspect_NavBlackboard final : public UAIAspect_Navigation
{
public:
	struct FGbxBlackboardKeySelector              GoalKey;                                           // 0x0240(0x0010)(Edit, NoDestructor, NativeAccessSpecifierPublic)
	float                                         MinOffsetInFrontOfTarget;                          // 0x0250(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         MaxOffsetInFrontOfTarget;                          // 0x0254(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         OffsetAngle;                                       // 0x0258(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EGbxNavGoalReach                              Reach;                                             // 0x025C(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_25D[0x3];                                      // 0x025D(0x0003)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"AIAspect_NavBlackboard">();
	}
	static class UAIAspect_NavBlackboard* GetDefaultObj()
	{
		return GetDefaultObjImpl<UAIAspect_NavBlackboard>();
	}
};
static_assert(alignof(UAIAspect_NavBlackboard) == 0x000008, "Wrong alignment on UAIAspect_NavBlackboard");
static_assert(sizeof(UAIAspect_NavBlackboard) == 0x000260, "Wrong size on UAIAspect_NavBlackboard");
static_assert(offsetof(UAIAspect_NavBlackboard, GoalKey) == 0x000240, "Member 'UAIAspect_NavBlackboard::GoalKey' has a wrong offset!");
static_assert(offsetof(UAIAspect_NavBlackboard, MinOffsetInFrontOfTarget) == 0x000250, "Member 'UAIAspect_NavBlackboard::MinOffsetInFrontOfTarget' has a wrong offset!");
static_assert(offsetof(UAIAspect_NavBlackboard, MaxOffsetInFrontOfTarget) == 0x000254, "Member 'UAIAspect_NavBlackboard::MaxOffsetInFrontOfTarget' has a wrong offset!");
static_assert(offsetof(UAIAspect_NavBlackboard, OffsetAngle) == 0x000258, "Member 'UAIAspect_NavBlackboard::OffsetAngle' has a wrong offset!");
static_assert(offsetof(UAIAspect_NavBlackboard, Reach) == 0x00025C, "Member 'UAIAspect_NavBlackboard::Reach' has a wrong offset!");

// Class GbxAI.AIAspect_NavCover
// 0x0010 (0x0250 - 0x0240)
class UAIAspect_NavCover final : public UAIAspect_Navigation
{
public:
	struct FGbxBlackboardKeySelector              GoalKey;                                           // 0x0240(0x0010)(Edit, NoDestructor, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"AIAspect_NavCover">();
	}
	static class UAIAspect_NavCover* GetDefaultObj()
	{
		return GetDefaultObjImpl<UAIAspect_NavCover>();
	}
};
static_assert(alignof(UAIAspect_NavCover) == 0x000008, "Wrong alignment on UAIAspect_NavCover");
static_assert(sizeof(UAIAspect_NavCover) == 0x000250, "Wrong size on UAIAspect_NavCover");
static_assert(offsetof(UAIAspect_NavCover, GoalKey) == 0x000240, "Member 'UAIAspect_NavCover::GoalKey' has a wrong offset!");

// Class GbxAI.GameplayTask_ScriptedRoute
// 0x0030 (0x00F0 - 0x00C0)
class UGameplayTask_ScriptedRoute final : public UGameplayTask_ScriptedAction
{
public:
	UMulticastDelegateProperty_                   OnAborted;                                         // 0x00C0(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	UMulticastDelegateProperty_                   OnCompleted;                                       // 0x00D0(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	class AActor*                                 AINode;                                            // 0x00E0(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UStanceDataProvider*                    StanceProvider;                                    // 0x00E8(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)

public:
	static class UGameplayTask_ScriptedRoute* BeginScriptedRoute(class AActor* User, class AActor* FirstAINode, class UStanceDataProvider* OptionalStance);
	static class UGameplayTask_ScriptedRoute* BeginScriptedRoute2(class AActor* Target, class AActor* FirstAINode, EScriptedActionRule SuccessRule, EScriptedActionRule FailRule, bool bAddSpawned, class UStanceDataProvider* OptionalStance);

	void TaskScriptedMoveDelegate__DelegateSignature();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"GameplayTask_ScriptedRoute">();
	}
	static class UGameplayTask_ScriptedRoute* GetDefaultObj()
	{
		return GetDefaultObjImpl<UGameplayTask_ScriptedRoute>();
	}
};
static_assert(alignof(UGameplayTask_ScriptedRoute) == 0x000008, "Wrong alignment on UGameplayTask_ScriptedRoute");
static_assert(sizeof(UGameplayTask_ScriptedRoute) == 0x0000F0, "Wrong size on UGameplayTask_ScriptedRoute");
static_assert(offsetof(UGameplayTask_ScriptedRoute, OnAborted) == 0x0000C0, "Member 'UGameplayTask_ScriptedRoute::OnAborted' has a wrong offset!");
static_assert(offsetof(UGameplayTask_ScriptedRoute, OnCompleted) == 0x0000D0, "Member 'UGameplayTask_ScriptedRoute::OnCompleted' has a wrong offset!");
static_assert(offsetof(UGameplayTask_ScriptedRoute, AINode) == 0x0000E0, "Member 'UGameplayTask_ScriptedRoute::AINode' has a wrong offset!");
static_assert(offsetof(UGameplayTask_ScriptedRoute, StanceProvider) == 0x0000E8, "Member 'UGameplayTask_ScriptedRoute::StanceProvider' has a wrong offset!");

// Class GbxAI.AIAspect_NavFlyOffset
// 0x0120 (0x0360 - 0x0240)
class UAIAspect_NavFlyOffset final : public UAIAspect_Navigation
{
public:
	struct FAIAspectSettings_NavFlyOffset         OffsetSettings;                                    // 0x0240(0x0120)(Edit, NoDestructor, ContainsInstancedReference, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"AIAspect_NavFlyOffset">();
	}
	static class UAIAspect_NavFlyOffset* GetDefaultObj()
	{
		return GetDefaultObjImpl<UAIAspect_NavFlyOffset>();
	}
};
static_assert(alignof(UAIAspect_NavFlyOffset) == 0x000008, "Wrong alignment on UAIAspect_NavFlyOffset");
static_assert(sizeof(UAIAspect_NavFlyOffset) == 0x000360, "Wrong size on UAIAspect_NavFlyOffset");
static_assert(offsetof(UAIAspect_NavFlyOffset, OffsetSettings) == 0x000240, "Member 'UAIAspect_NavFlyOffset::OffsetSettings' has a wrong offset!");

// Class GbxAI.AIAspect_Orbit
// 0x0220 (0x0460 - 0x0240)
class UAIAspect_Orbit : public UAIAspect_Navigation
{
public:
	struct FAIAspectSettings_Orbit                OrbitSettings;                                     // 0x0240(0x0220)(Edit, NoDestructor, ContainsInstancedReference, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"AIAspect_Orbit">();
	}
	static class UAIAspect_Orbit* GetDefaultObj()
	{
		return GetDefaultObjImpl<UAIAspect_Orbit>();
	}
};
static_assert(alignof(UAIAspect_Orbit) == 0x000008, "Wrong alignment on UAIAspect_Orbit");
static_assert(sizeof(UAIAspect_Orbit) == 0x000460, "Wrong size on UAIAspect_Orbit");
static_assert(offsetof(UAIAspect_Orbit, OrbitSettings) == 0x000240, "Member 'UAIAspect_Orbit::OrbitSettings' has a wrong offset!");

// Class GbxAI.GbxCondition_HasTargetsInRange
// 0x0100 (0x0188 - 0x0088)
class UGbxCondition_HasTargetsInRange final : public UGbxCondition
{
public:
	struct FGbxParam                              Range;                                             // 0x0088(0x0080)(Edit, BlueprintVisible, BlueprintReadOnly, NoDestructor, ContainsInstancedReference, NativeAccessSpecifierPublic)
	struct FGbxParam                              NumTargets;                                        // 0x0108(0x0080)(Edit, BlueprintVisible, BlueprintReadOnly, NoDestructor, ContainsInstancedReference, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"GbxCondition_HasTargetsInRange">();
	}
	static class UGbxCondition_HasTargetsInRange* GetDefaultObj()
	{
		return GetDefaultObjImpl<UGbxCondition_HasTargetsInRange>();
	}
};
static_assert(alignof(UGbxCondition_HasTargetsInRange) == 0x000008, "Wrong alignment on UGbxCondition_HasTargetsInRange");
static_assert(sizeof(UGbxCondition_HasTargetsInRange) == 0x000188, "Wrong size on UGbxCondition_HasTargetsInRange");
static_assert(offsetof(UGbxCondition_HasTargetsInRange, Range) == 0x000088, "Member 'UGbxCondition_HasTargetsInRange::Range' has a wrong offset!");
static_assert(offsetof(UGbxCondition_HasTargetsInRange, NumTargets) == 0x000108, "Member 'UGbxCondition_HasTargetsInRange::NumTargets' has a wrong offset!");

// Class GbxAI.AIAspect_Plan
// 0x0020 (0x0120 - 0x0100)
class UAIAspect_Plan final : public UAIAspect
{
public:
	struct FAIAspectSettings_Plan                 Settings;                                          // 0x0100(0x0020)(Edit, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"AIAspect_Plan">();
	}
	static class UAIAspect_Plan* GetDefaultObj()
	{
		return GetDefaultObjImpl<UAIAspect_Plan>();
	}
};
static_assert(alignof(UAIAspect_Plan) == 0x000008, "Wrong alignment on UAIAspect_Plan");
static_assert(sizeof(UAIAspect_Plan) == 0x000120, "Wrong size on UAIAspect_Plan");
static_assert(offsetof(UAIAspect_Plan, Settings) == 0x000100, "Member 'UAIAspect_Plan::Settings' has a wrong offset!");

// Class GbxAI.AIAspect_Rotation
// 0x0550 (0x0650 - 0x0100)
class UAIAspect_Rotation : public UAIAspect
{
public:
	struct FAIAspectSettings_Rotation             Settings;                                          // 0x0100(0x0550)(Edit, NoDestructor, ContainsInstancedReference, NativeAccessSpecifierPublic)

public:
	static class FString GetRotationChannelSettingsDescription(const struct FAIAspectSettings_RotationChannel& RotationChannelSettings, class UProperty* Property);
	static class FString GetRotationSettingsDescription(const struct FAIAspectSettings_Rotation& RotationSettings, class UProperty* Property);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"AIAspect_Rotation">();
	}
	static class UAIAspect_Rotation* GetDefaultObj()
	{
		return GetDefaultObjImpl<UAIAspect_Rotation>();
	}
};
static_assert(alignof(UAIAspect_Rotation) == 0x000008, "Wrong alignment on UAIAspect_Rotation");
static_assert(sizeof(UAIAspect_Rotation) == 0x000650, "Wrong size on UAIAspect_Rotation");
static_assert(offsetof(UAIAspect_Rotation, Settings) == 0x000100, "Member 'UAIAspect_Rotation::Settings' has a wrong offset!");

// Class GbxAI.GbxAction_CoverHitReaction
// 0x0018 (0x00D0 - 0x00B8)
class UGbxAction_CoverHitReaction final : public UGbxAction_SimpleAnim
{
public:
	TArray<struct FCoverHitReactionItem>          Styles;                                            // 0x00B8(0x0010)(Edit, ZeroConstructor, NativeAccessSpecifierPrivate)
	float                                         BlendInTime;                                       // 0x00C8(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	float                                         BlendOutTime;                                      // 0x00CC(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"GbxAction_CoverHitReaction">();
	}
	static class UGbxAction_CoverHitReaction* GetDefaultObj()
	{
		return GetDefaultObjImpl<UGbxAction_CoverHitReaction>();
	}
};
static_assert(alignof(UGbxAction_CoverHitReaction) == 0x000008, "Wrong alignment on UGbxAction_CoverHitReaction");
static_assert(sizeof(UGbxAction_CoverHitReaction) == 0x0000D0, "Wrong size on UGbxAction_CoverHitReaction");
static_assert(offsetof(UGbxAction_CoverHitReaction, Styles) == 0x0000B8, "Member 'UGbxAction_CoverHitReaction::Styles' has a wrong offset!");
static_assert(offsetof(UGbxAction_CoverHitReaction, BlendInTime) == 0x0000C8, "Member 'UGbxAction_CoverHitReaction::BlendInTime' has a wrong offset!");
static_assert(offsetof(UGbxAction_CoverHitReaction, BlendOutTime) == 0x0000CC, "Member 'UGbxAction_CoverHitReaction::BlendOutTime' has a wrong offset!");

// Class GbxAI.AIAspect_Route
// 0x0098 (0x0198 - 0x0100)
class UAIAspect_Route final : public UAIAspect
{
public:
	struct FAIAspectSettings_Route                RouteSettings;                                     // 0x0100(0x0028)(Edit, NoDestructor, NativeAccessSpecifierPublic)
	struct FGbxBlackboardKeySelector              MoveTarget;                                        // 0x0128(0x0010)(NoDestructor, NativeAccessSpecifierPublic)
	struct FGbxBlackboardKeySelector              Distance;                                          // 0x0138(0x0010)(NoDestructor, NativeAccessSpecifierPublic)
	struct FGbxBlackboardKeySelector              SmartAction;                                       // 0x0148(0x0010)(NoDestructor, NativeAccessSpecifierPublic)
	struct FGbxBlackboardKeySelector              BodyEnable;                                        // 0x0158(0x0010)(NoDestructor, NativeAccessSpecifierPublic)
	struct FGbxBlackboardKeySelector              BodyTarget;                                        // 0x0168(0x0010)(NoDestructor, NativeAccessSpecifierPublic)
	struct FGbxBlackboardKeySelector              LookEnable;                                        // 0x0178(0x0010)(NoDestructor, NativeAccessSpecifierPublic)
	struct FGbxBlackboardKeySelector              LookTarget;                                        // 0x0188(0x0010)(NoDestructor, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"AIAspect_Route">();
	}
	static class UAIAspect_Route* GetDefaultObj()
	{
		return GetDefaultObjImpl<UAIAspect_Route>();
	}
};
static_assert(alignof(UAIAspect_Route) == 0x000008, "Wrong alignment on UAIAspect_Route");
static_assert(sizeof(UAIAspect_Route) == 0x000198, "Wrong size on UAIAspect_Route");
static_assert(offsetof(UAIAspect_Route, RouteSettings) == 0x000100, "Member 'UAIAspect_Route::RouteSettings' has a wrong offset!");
static_assert(offsetof(UAIAspect_Route, MoveTarget) == 0x000128, "Member 'UAIAspect_Route::MoveTarget' has a wrong offset!");
static_assert(offsetof(UAIAspect_Route, Distance) == 0x000138, "Member 'UAIAspect_Route::Distance' has a wrong offset!");
static_assert(offsetof(UAIAspect_Route, SmartAction) == 0x000148, "Member 'UAIAspect_Route::SmartAction' has a wrong offset!");
static_assert(offsetof(UAIAspect_Route, BodyEnable) == 0x000158, "Member 'UAIAspect_Route::BodyEnable' has a wrong offset!");
static_assert(offsetof(UAIAspect_Route, BodyTarget) == 0x000168, "Member 'UAIAspect_Route::BodyTarget' has a wrong offset!");
static_assert(offsetof(UAIAspect_Route, LookEnable) == 0x000178, "Member 'UAIAspect_Route::LookEnable' has a wrong offset!");
static_assert(offsetof(UAIAspect_Route, LookTarget) == 0x000188, "Member 'UAIAspect_Route::LookTarget' has a wrong offset!");

// Class GbxAI.AIAspect_Stance
// 0x0010 (0x0110 - 0x0100)
class UAIAspect_Stance final : public UAIAspect
{
public:
	struct FAIAspectSettings_Stance               Settings;                                          // 0x0100(0x0010)(Edit, NoDestructor, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"AIAspect_Stance">();
	}
	static class UAIAspect_Stance* GetDefaultObj()
	{
		return GetDefaultObjImpl<UAIAspect_Stance>();
	}
};
static_assert(alignof(UAIAspect_Stance) == 0x000008, "Wrong alignment on UAIAspect_Stance");
static_assert(sizeof(UAIAspect_Stance) == 0x000110, "Wrong size on UAIAspect_Stance");
static_assert(offsetof(UAIAspect_Stance, Settings) == 0x000100, "Member 'UAIAspect_Stance::Settings' has a wrong offset!");

// Class GbxAI.GameplayTask_ScriptedLand
// 0x0020 (0x00E0 - 0x00C0)
class UGameplayTask_ScriptedLand final : public UGameplayTask_ScriptedAction
{
public:
	UMulticastDelegateProperty_                   OnAborted;                                         // 0x00C0(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	UMulticastDelegateProperty_                   OnCompleted;                                       // 0x00D0(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)

public:
	static class UGameplayTask_ScriptedLand* BeginScriptedLand(class AActor* Lander);

	void TaskScriptedLandDelegate__DelegateSignature();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"GameplayTask_ScriptedLand">();
	}
	static class UGameplayTask_ScriptedLand* GetDefaultObj()
	{
		return GetDefaultObjImpl<UGameplayTask_ScriptedLand>();
	}
};
static_assert(alignof(UGameplayTask_ScriptedLand) == 0x000008, "Wrong alignment on UGameplayTask_ScriptedLand");
static_assert(sizeof(UGameplayTask_ScriptedLand) == 0x0000E0, "Wrong size on UGameplayTask_ScriptedLand");
static_assert(offsetof(UGameplayTask_ScriptedLand, OnAborted) == 0x0000C0, "Member 'UGameplayTask_ScriptedLand::OnAborted' has a wrong offset!");
static_assert(offsetof(UGameplayTask_ScriptedLand, OnCompleted) == 0x0000D0, "Member 'UGameplayTask_ScriptedLand::OnCompleted' has a wrong offset!");

// Class GbxAI.AIAspect_Sweep
// 0x00A8 (0x0508 - 0x0460)
class UAIAspect_Sweep final : public UAIAspect_Orbit
{
public:
	struct FAIAspectSettings_Sweep                SweepSettings;                                     // 0x0460(0x00A8)(NoDestructor, ContainsInstancedReference, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"AIAspect_Sweep">();
	}
	static class UAIAspect_Sweep* GetDefaultObj()
	{
		return GetDefaultObjImpl<UAIAspect_Sweep>();
	}
};
static_assert(alignof(UAIAspect_Sweep) == 0x000008, "Wrong alignment on UAIAspect_Sweep");
static_assert(sizeof(UAIAspect_Sweep) == 0x000508, "Wrong size on UAIAspect_Sweep");
static_assert(offsetof(UAIAspect_Sweep, SweepSettings) == 0x000460, "Member 'UAIAspect_Sweep::SweepSettings' has a wrong offset!");

// Class GbxAI.AIAspect_Swoop
// 0x0340 (0x0580 - 0x0240)
class UAIAspect_Swoop final : public UAIAspect_Navigation
{
public:
	struct FAIAspectSettings_Swoop                SwoopSettings;                                     // 0x0240(0x0320)(Edit, NoDestructor, ContainsInstancedReference, NativeAccessSpecifierPublic)
	UMulticastDelegateProperty_                   OnReachedFarBP;                                    // 0x0560(0x0010)(ZeroConstructor, Transient, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPrivate)
	UMulticastDelegateProperty_                   OnReachedNearBP;                                   // 0x0570(0x0010)(ZeroConstructor, Transient, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPrivate)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"AIAspect_Swoop">();
	}
	static class UAIAspect_Swoop* GetDefaultObj()
	{
		return GetDefaultObjImpl<UAIAspect_Swoop>();
	}
};
static_assert(alignof(UAIAspect_Swoop) == 0x000008, "Wrong alignment on UAIAspect_Swoop");
static_assert(sizeof(UAIAspect_Swoop) == 0x000580, "Wrong size on UAIAspect_Swoop");
static_assert(offsetof(UAIAspect_Swoop, SwoopSettings) == 0x000240, "Member 'UAIAspect_Swoop::SwoopSettings' has a wrong offset!");
static_assert(offsetof(UAIAspect_Swoop, OnReachedFarBP) == 0x000560, "Member 'UAIAspect_Swoop::OnReachedFarBP' has a wrong offset!");
static_assert(offsetof(UAIAspect_Swoop, OnReachedNearBP) == 0x000570, "Member 'UAIAspect_Swoop::OnReachedNearBP' has a wrong offset!");

// Class GbxAI.GbxAction_Navigation
// 0x0008 (0x00C0 - 0x00B8)
class UGbxAction_Navigation : public UGbxAction_SimpleAnim
{
public:
	bool                                          bMaintainRootVelocity;                             // 0x00B8(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_B9[0x7];                                       // 0x00B9(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	struct FVector K2_GetEntryLocation() const;
	struct FVector K2_GetExitLocation() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"GbxAction_Navigation">();
	}
	static class UGbxAction_Navigation* GetDefaultObj()
	{
		return GetDefaultObjImpl<UGbxAction_Navigation>();
	}
};
static_assert(alignof(UGbxAction_Navigation) == 0x000008, "Wrong alignment on UGbxAction_Navigation");
static_assert(sizeof(UGbxAction_Navigation) == 0x0000C0, "Wrong size on UGbxAction_Navigation");
static_assert(offsetof(UGbxAction_Navigation, bMaintainRootVelocity) == 0x0000B8, "Member 'UGbxAction_Navigation::bMaintainRootVelocity' has a wrong offset!");

// Class GbxAI.GbxAction_NavJump
// 0x0228 (0x02E8 - 0x00C0)
class UGbxAction_NavJump : public UGbxAction_Navigation
{
public:
	struct FStretchBonesSettings                  StretchBonesSettings;                              // 0x00C0(0x0030)(Edit, DisableEditOnInstance, NoDestructor, NativeAccessSpecifierPublic)
	float                                         RotationTime;                                      // 0x00F0(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bCancelRotationOnActionStop;                       // 0x00F4(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bApplyRotationOnStart;                             // 0x00F5(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_F6[0x2];                                       // 0x00F6(0x0002)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         BlendInTime;                                       // 0x00F8(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         BlendOutTime;                                      // 0x00FC(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class FName                                   AnimSlot;                                          // 0x0100(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	struct FAnimMeshList                          JumpEnterAnims;                                    // 0x0108(0x0078)(Edit, Protected, NativeAccessSpecifierProtected)
	struct FAnimMeshList                          JumpExitAnims;                                     // 0x0180(0x0078)(Edit, Protected, NativeAccessSpecifierProtected)
	struct FAnimMeshList                          JumpIdleAnims;                                     // 0x01F8(0x0078)(Edit, Protected, NativeAccessSpecifierProtected)
	ENavJumpRotation                              RotationDirective;                                 // 0x0270(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bLockRotation;                                     // 0x0271(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	ENavJumpStage                                 DisablePhysicsStage;                               // 0x0272(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	ENavJumpStage                                 EnablePhysicsStage;                                // 0x0273(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         ArcSpeed;                                          // 0x0274(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         ArcAnglePercent;                                   // 0x0278(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         MaxPrediction;                                     // 0x027C(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         ArcTimeScale;                                      // 0x0280(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bLimitHitReactions;                                // 0x0284(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_285[0x3];                                      // 0x0285(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	class UAnimSequenceBase*                      JumpEnter;                                         // 0x0288(0x0008)(ZeroConstructor, Deprecated, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UAnimSequenceBase*                      JumpExit;                                          // 0x0290(0x0008)(ZeroConstructor, Deprecated, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UAnimSequenceBase*                      JumpIdle;                                          // 0x0298(0x0008)(ZeroConstructor, Deprecated, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	struct FAnimActionDef                         JumpEnterAnim;                                     // 0x02A0(0x0018)(Deprecated, NoDestructor, Protected, NativeAccessSpecifierProtected)
	struct FAnimActionDef                         JumpExitAnim;                                      // 0x02B8(0x0018)(Deprecated, NoDestructor, Protected, NativeAccessSpecifierProtected)
	struct FAnimActionDef                         JumpIdleAnim;                                      // 0x02D0(0x0018)(Deprecated, NoDestructor, Protected, NativeAccessSpecifierProtected)

public:
	void OnExit(class AActor* Actor) const;
	void OnIdle(class AActor* Actor) const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"GbxAction_NavJump">();
	}
	static class UGbxAction_NavJump* GetDefaultObj()
	{
		return GetDefaultObjImpl<UGbxAction_NavJump>();
	}
};
static_assert(alignof(UGbxAction_NavJump) == 0x000008, "Wrong alignment on UGbxAction_NavJump");
static_assert(sizeof(UGbxAction_NavJump) == 0x0002E8, "Wrong size on UGbxAction_NavJump");
static_assert(offsetof(UGbxAction_NavJump, StretchBonesSettings) == 0x0000C0, "Member 'UGbxAction_NavJump::StretchBonesSettings' has a wrong offset!");
static_assert(offsetof(UGbxAction_NavJump, RotationTime) == 0x0000F0, "Member 'UGbxAction_NavJump::RotationTime' has a wrong offset!");
static_assert(offsetof(UGbxAction_NavJump, bCancelRotationOnActionStop) == 0x0000F4, "Member 'UGbxAction_NavJump::bCancelRotationOnActionStop' has a wrong offset!");
static_assert(offsetof(UGbxAction_NavJump, bApplyRotationOnStart) == 0x0000F5, "Member 'UGbxAction_NavJump::bApplyRotationOnStart' has a wrong offset!");
static_assert(offsetof(UGbxAction_NavJump, BlendInTime) == 0x0000F8, "Member 'UGbxAction_NavJump::BlendInTime' has a wrong offset!");
static_assert(offsetof(UGbxAction_NavJump, BlendOutTime) == 0x0000FC, "Member 'UGbxAction_NavJump::BlendOutTime' has a wrong offset!");
static_assert(offsetof(UGbxAction_NavJump, AnimSlot) == 0x000100, "Member 'UGbxAction_NavJump::AnimSlot' has a wrong offset!");
static_assert(offsetof(UGbxAction_NavJump, JumpEnterAnims) == 0x000108, "Member 'UGbxAction_NavJump::JumpEnterAnims' has a wrong offset!");
static_assert(offsetof(UGbxAction_NavJump, JumpExitAnims) == 0x000180, "Member 'UGbxAction_NavJump::JumpExitAnims' has a wrong offset!");
static_assert(offsetof(UGbxAction_NavJump, JumpIdleAnims) == 0x0001F8, "Member 'UGbxAction_NavJump::JumpIdleAnims' has a wrong offset!");
static_assert(offsetof(UGbxAction_NavJump, RotationDirective) == 0x000270, "Member 'UGbxAction_NavJump::RotationDirective' has a wrong offset!");
static_assert(offsetof(UGbxAction_NavJump, bLockRotation) == 0x000271, "Member 'UGbxAction_NavJump::bLockRotation' has a wrong offset!");
static_assert(offsetof(UGbxAction_NavJump, DisablePhysicsStage) == 0x000272, "Member 'UGbxAction_NavJump::DisablePhysicsStage' has a wrong offset!");
static_assert(offsetof(UGbxAction_NavJump, EnablePhysicsStage) == 0x000273, "Member 'UGbxAction_NavJump::EnablePhysicsStage' has a wrong offset!");
static_assert(offsetof(UGbxAction_NavJump, ArcSpeed) == 0x000274, "Member 'UGbxAction_NavJump::ArcSpeed' has a wrong offset!");
static_assert(offsetof(UGbxAction_NavJump, ArcAnglePercent) == 0x000278, "Member 'UGbxAction_NavJump::ArcAnglePercent' has a wrong offset!");
static_assert(offsetof(UGbxAction_NavJump, MaxPrediction) == 0x00027C, "Member 'UGbxAction_NavJump::MaxPrediction' has a wrong offset!");
static_assert(offsetof(UGbxAction_NavJump, ArcTimeScale) == 0x000280, "Member 'UGbxAction_NavJump::ArcTimeScale' has a wrong offset!");
static_assert(offsetof(UGbxAction_NavJump, bLimitHitReactions) == 0x000284, "Member 'UGbxAction_NavJump::bLimitHitReactions' has a wrong offset!");
static_assert(offsetof(UGbxAction_NavJump, JumpEnter) == 0x000288, "Member 'UGbxAction_NavJump::JumpEnter' has a wrong offset!");
static_assert(offsetof(UGbxAction_NavJump, JumpExit) == 0x000290, "Member 'UGbxAction_NavJump::JumpExit' has a wrong offset!");
static_assert(offsetof(UGbxAction_NavJump, JumpIdle) == 0x000298, "Member 'UGbxAction_NavJump::JumpIdle' has a wrong offset!");
static_assert(offsetof(UGbxAction_NavJump, JumpEnterAnim) == 0x0002A0, "Member 'UGbxAction_NavJump::JumpEnterAnim' has a wrong offset!");
static_assert(offsetof(UGbxAction_NavJump, JumpExitAnim) == 0x0002B8, "Member 'UGbxAction_NavJump::JumpExitAnim' has a wrong offset!");
static_assert(offsetof(UGbxAction_NavJump, JumpIdleAnim) == 0x0002D0, "Member 'UGbxAction_NavJump::JumpIdleAnim' has a wrong offset!");

// Class GbxAI.AIAspect_TakeOff
// 0x0008 (0x0340 - 0x0338)
class UAIAspect_TakeOff final : public UAIAspect_GbxAction
{
public:
	float                                         NearFlightDistance;                                // 0x0338(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_33C[0x4];                                      // 0x033C(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"AIAspect_TakeOff">();
	}
	static class UAIAspect_TakeOff* GetDefaultObj()
	{
		return GetDefaultObjImpl<UAIAspect_TakeOff>();
	}
};
static_assert(alignof(UAIAspect_TakeOff) == 0x000008, "Wrong alignment on UAIAspect_TakeOff");
static_assert(sizeof(UAIAspect_TakeOff) == 0x000340, "Wrong size on UAIAspect_TakeOff");
static_assert(offsetof(UAIAspect_TakeOff, NearFlightDistance) == 0x000338, "Member 'UAIAspect_TakeOff::NearFlightDistance' has a wrong offset!");

// Class GbxAI.AIAspect_Teleport
// 0x0138 (0x0238 - 0x0100)
class UAIAspect_Teleport final : public UAIAspect
{
public:
	struct FAIAspectSettings_Teleport             Settings;                                          // 0x0100(0x0138)(Edit, NoDestructor, ContainsInstancedReference, NativeAccessSpecifierPublic)

public:
	static class FString GetTeleportSettingsDescription(const struct FAIAspectSettings_Teleport& TeleportSettings, class UProperty* Property);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"AIAspect_Teleport">();
	}
	static class UAIAspect_Teleport* GetDefaultObj()
	{
		return GetDefaultObjImpl<UAIAspect_Teleport>();
	}
};
static_assert(alignof(UAIAspect_Teleport) == 0x000008, "Wrong alignment on UAIAspect_Teleport");
static_assert(sizeof(UAIAspect_Teleport) == 0x000238, "Wrong size on UAIAspect_Teleport");
static_assert(offsetof(UAIAspect_Teleport, Settings) == 0x000100, "Member 'UAIAspect_Teleport::Settings' has a wrong offset!");

// Class GbxAI.EnvQueryTest_TargetIsCloseToMyMaster
// 0x0080 (0x0258 - 0x01D8)
class UEnvQueryTest_TargetIsCloseToMyMaster final : public UEnvQueryTest
{
public:
	struct FGbxParam                              DistanceThreshold;                                 // 0x01D8(0x0080)(Edit, NoDestructor, ContainsInstancedReference, Protected, NativeAccessSpecifierProtected)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"EnvQueryTest_TargetIsCloseToMyMaster">();
	}
	static class UEnvQueryTest_TargetIsCloseToMyMaster* GetDefaultObj()
	{
		return GetDefaultObjImpl<UEnvQueryTest_TargetIsCloseToMyMaster>();
	}
};
static_assert(alignof(UEnvQueryTest_TargetIsCloseToMyMaster) == 0x000008, "Wrong alignment on UEnvQueryTest_TargetIsCloseToMyMaster");
static_assert(sizeof(UEnvQueryTest_TargetIsCloseToMyMaster) == 0x000258, "Wrong size on UEnvQueryTest_TargetIsCloseToMyMaster");
static_assert(offsetof(UEnvQueryTest_TargetIsCloseToMyMaster, DistanceThreshold) == 0x0001D8, "Member 'UEnvQueryTest_TargetIsCloseToMyMaster::DistanceThreshold' has a wrong offset!");

// Class GbxAI.AIAspect_Territory
// 0x0010 (0x0110 - 0x0100)
class UAIAspect_Territory final : public UAIAspect
{
public:
	TArray<struct FGbxBlackboardKeySelector>      TerritoryKeys;                                     // 0x0100(0x0010)(Edit, ZeroConstructor, NativeAccessSpecifierPrivate)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"AIAspect_Territory">();
	}
	static class UAIAspect_Territory* GetDefaultObj()
	{
		return GetDefaultObjImpl<UAIAspect_Territory>();
	}
};
static_assert(alignof(UAIAspect_Territory) == 0x000008, "Wrong alignment on UAIAspect_Territory");
static_assert(sizeof(UAIAspect_Territory) == 0x000110, "Wrong size on UAIAspect_Territory");
static_assert(offsetof(UAIAspect_Territory, TerritoryKeys) == 0x000100, "Member 'UAIAspect_Territory::TerritoryKeys' has a wrong offset!");

// Class GbxAI.AIAspect_Ticket
// 0x0128 (0x0228 - 0x0100)
class UAIAspect_Ticket final : public UAIAspect
{
public:
	struct FAIAspectSettings_Ticket               Settings;                                          // 0x0100(0x0128)(Edit, NoDestructor, ContainsInstancedReference, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"AIAspect_Ticket">();
	}
	static class UAIAspect_Ticket* GetDefaultObj()
	{
		return GetDefaultObjImpl<UAIAspect_Ticket>();
	}
};
static_assert(alignof(UAIAspect_Ticket) == 0x000008, "Wrong alignment on UAIAspect_Ticket");
static_assert(sizeof(UAIAspect_Ticket) == 0x000228, "Wrong size on UAIAspect_Ticket");
static_assert(offsetof(UAIAspect_Ticket, Settings) == 0x000100, "Member 'UAIAspect_Ticket::Settings' has a wrong offset!");

// Class GbxAI.Territory
// 0x0008 (0x0460 - 0x0458)
class ATerritory final : public AInfo
{
public:
	class UTerritoryComponent*                    TerritoryComponent;                                // 0x0458(0x0008)(Edit, ExportObject, ZeroConstructor, EditConst, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)

public:
	class UTerritoryComponent* GetTerritoryComponent() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"Territory">();
	}
	static class ATerritory* GetDefaultObj()
	{
		return GetDefaultObjImpl<ATerritory>();
	}
};
static_assert(alignof(ATerritory) == 0x000008, "Wrong alignment on ATerritory");
static_assert(sizeof(ATerritory) == 0x000460, "Wrong size on ATerritory");
static_assert(offsetof(ATerritory, TerritoryComponent) == 0x000458, "Member 'ATerritory::TerritoryComponent' has a wrong offset!");

// Class GbxAI.AIAspect_TimedCondition
// 0x0118 (0x0218 - 0x0100)
class UAIAspect_TimedCondition final : public UAIAspect
{
public:
	struct FAIAspectSettings_TimedCondition       Settings;                                          // 0x0100(0x0118)(Edit, NoDestructor, ContainsInstancedReference, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"AIAspect_TimedCondition">();
	}
	static class UAIAspect_TimedCondition* GetDefaultObj()
	{
		return GetDefaultObjImpl<UAIAspect_TimedCondition>();
	}
};
static_assert(alignof(UAIAspect_TimedCondition) == 0x000008, "Wrong alignment on UAIAspect_TimedCondition");
static_assert(sizeof(UAIAspect_TimedCondition) == 0x000218, "Wrong size on UAIAspect_TimedCondition");
static_assert(offsetof(UAIAspect_TimedCondition, Settings) == 0x000100, "Member 'UAIAspect_TimedCondition::Settings' has a wrong offset!");

// Class GbxAI.AIAspect_TimeLimit
// 0x0108 (0x0208 - 0x0100)
class UAIAspect_TimeLimit final : public UAIAspect
{
public:
	struct FAIAspectSettings_TimeLimit            Settings;                                          // 0x0100(0x0108)(Edit, NoDestructor, ContainsInstancedReference, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"AIAspect_TimeLimit">();
	}
	static class UAIAspect_TimeLimit* GetDefaultObj()
	{
		return GetDefaultObjImpl<UAIAspect_TimeLimit>();
	}
};
static_assert(alignof(UAIAspect_TimeLimit) == 0x000008, "Wrong alignment on UAIAspect_TimeLimit");
static_assert(sizeof(UAIAspect_TimeLimit) == 0x000208, "Wrong size on UAIAspect_TimeLimit");
static_assert(offsetof(UAIAspect_TimeLimit, Settings) == 0x000100, "Member 'UAIAspect_TimeLimit::Settings' has a wrong offset!");

// Class GbxAI.AIAspect_Timer
// 0x04C8 (0x05C8 - 0x0100)
class UAIAspect_Timer final : public UAIAspect
{
public:
	struct FAIAspectSettings_Timer                Settings;                                          // 0x0100(0x04C8)(Edit, NoDestructor, ContainsInstancedReference, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"AIAspect_Timer">();
	}
	static class UAIAspect_Timer* GetDefaultObj()
	{
		return GetDefaultObjImpl<UAIAspect_Timer>();
	}
};
static_assert(alignof(UAIAspect_Timer) == 0x000008, "Wrong alignment on UAIAspect_Timer");
static_assert(sizeof(UAIAspect_Timer) == 0x0005C8, "Wrong size on UAIAspect_Timer");
static_assert(offsetof(UAIAspect_Timer, Settings) == 0x000100, "Member 'UAIAspect_Timer::Settings' has a wrong offset!");

// Class GbxAI.AIAspect_UseCover
// 0x0138 (0x0238 - 0x0100)
class UAIAspect_UseCover final : public UAIAspect
{
public:
	struct FAIAspectSettings_UseCover             Settings;                                          // 0x0100(0x0138)(Edit, NoDestructor, ContainsInstancedReference, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"AIAspect_UseCover">();
	}
	static class UAIAspect_UseCover* GetDefaultObj()
	{
		return GetDefaultObjImpl<UAIAspect_UseCover>();
	}
};
static_assert(alignof(UAIAspect_UseCover) == 0x000008, "Wrong alignment on UAIAspect_UseCover");
static_assert(sizeof(UAIAspect_UseCover) == 0x000238, "Wrong size on UAIAspect_UseCover");
static_assert(offsetof(UAIAspect_UseCover, Settings) == 0x000100, "Member 'UAIAspect_UseCover::Settings' has a wrong offset!");

// Class GbxAI.AIAspect_UseSmartObject
// 0x0000 (0x0338 - 0x0338)
class UAIAspect_UseSmartObject final : public UAIAspect_GbxAction
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"AIAspect_UseSmartObject">();
	}
	static class UAIAspect_UseSmartObject* GetDefaultObj()
	{
		return GetDefaultObjImpl<UAIAspect_UseSmartObject>();
	}
};
static_assert(alignof(UAIAspect_UseSmartObject) == 0x000008, "Wrong alignment on UAIAspect_UseSmartObject");
static_assert(sizeof(UAIAspect_UseSmartObject) == 0x000338, "Wrong size on UAIAspect_UseSmartObject");

// Class GbxAI.AIAspect_Weapon
// 0x03D0 (0x04D0 - 0x0100)
class UAIAspect_Weapon final : public UAIAspect
{
public:
	struct FAIAspectSettings_Weapon               Settings;                                          // 0x0100(0x03D0)(Edit, ContainsInstancedReference, NativeAccessSpecifierPublic)

public:
	static class FString GetWeaponSettingsDescription(const struct FAIAspectSettings_Weapon& WeaponSettings, class UProperty* Property);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"AIAspect_Weapon">();
	}
	static class UAIAspect_Weapon* GetDefaultObj()
	{
		return GetDefaultObjImpl<UAIAspect_Weapon>();
	}
};
static_assert(alignof(UAIAspect_Weapon) == 0x000008, "Wrong alignment on UAIAspect_Weapon");
static_assert(sizeof(UAIAspect_Weapon) == 0x0004D0, "Wrong size on UAIAspect_Weapon");
static_assert(offsetof(UAIAspect_Weapon, Settings) == 0x000100, "Member 'UAIAspect_Weapon::Settings' has a wrong offset!");

// Class GbxAI.AIResource_ScriptedAction
// 0x0000 (0x0038 - 0x0038)
class UAIResource_ScriptedAction final : public UGameplayTaskResource
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"AIResource_ScriptedAction">();
	}
	static class UAIResource_ScriptedAction* GetDefaultObj()
	{
		return GetDefaultObjImpl<UAIResource_ScriptedAction>();
	}
};
static_assert(alignof(UAIResource_ScriptedAction) == 0x000008, "Wrong alignment on UAIResource_ScriptedAction");
static_assert(sizeof(UAIResource_ScriptedAction) == 0x000038, "Wrong size on UAIResource_ScriptedAction");

// Class GbxAI.AIAspect_ZeroRotation
// 0x0010 (0x0110 - 0x0100)
class UAIAspect_ZeroRotation final : public UAIAspect
{
public:
	struct FAIAspectSettings_ZeroRotation         Settings;                                          // 0x0100(0x000C)(Edit, NoDestructor, NativeAccessSpecifierPublic)
	uint8                                         Pad_10C[0x4];                                      // 0x010C(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"AIAspect_ZeroRotation">();
	}
	static class UAIAspect_ZeroRotation* GetDefaultObj()
	{
		return GetDefaultObjImpl<UAIAspect_ZeroRotation>();
	}
};
static_assert(alignof(UAIAspect_ZeroRotation) == 0x000008, "Wrong alignment on UAIAspect_ZeroRotation");
static_assert(sizeof(UAIAspect_ZeroRotation) == 0x000110, "Wrong size on UAIAspect_ZeroRotation");
static_assert(offsetof(UAIAspect_ZeroRotation, Settings) == 0x000100, "Member 'UAIAspect_ZeroRotation::Settings' has a wrong offset!");

// Class GbxAI.AIAspectBlueprint
// 0x0008 (0x00F0 - 0x00E8)
class UAIAspectBlueprint final : public UBlueprint
{
public:
	class UAIAspectBlueprint*                     ParentBlueprint;                                   // 0x00E8(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"AIAspectBlueprint">();
	}
	static class UAIAspectBlueprint* GetDefaultObj()
	{
		return GetDefaultObjImpl<UAIAspectBlueprint>();
	}
};
static_assert(alignof(UAIAspectBlueprint) == 0x000008, "Wrong alignment on UAIAspectBlueprint");
static_assert(sizeof(UAIAspectBlueprint) == 0x0000F0, "Wrong size on UAIAspectBlueprint");
static_assert(offsetof(UAIAspectBlueprint, ParentBlueprint) == 0x0000E8, "Member 'UAIAspectBlueprint::ParentBlueprint' has a wrong offset!");

// Class GbxAI.AICloakData
// 0x0018 (0x0048 - 0x0030)
class UAICloakData final : public UDataAsset
{
public:
	TArray<struct FCloakCondition>                CloakPriorities;                                   // 0x0030(0x0010)(Edit, ZeroConstructor, ContainsInstancedReference, NativeAccessSpecifierPublic)
	bool                                          bDefaultCloaked;                                   // 0x0040(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_41[0x7];                                       // 0x0041(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"AICloakData">();
	}
	static class UAICloakData* GetDefaultObj()
	{
		return GetDefaultObjImpl<UAICloakData>();
	}
};
static_assert(alignof(UAICloakData) == 0x000008, "Wrong alignment on UAICloakData");
static_assert(sizeof(UAICloakData) == 0x000048, "Wrong size on UAICloakData");
static_assert(offsetof(UAICloakData, CloakPriorities) == 0x000030, "Member 'UAICloakData::CloakPriorities' has a wrong offset!");
static_assert(offsetof(UAICloakData, bDefaultCloaked) == 0x000040, "Member 'UAICloakData::bDefaultCloaked' has a wrong offset!");

// Class GbxAI.AICloakComponent
// 0x00F8 (0x0270 - 0x0178)
class UAICloakComponent final : public UActorComponent
{
public:
	UMulticastDelegateProperty_                   OnCloaked;                                         // 0x0178(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	UMulticastDelegateProperty_                   OnUncloaked;                                       // 0x0188(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	class UAICloakData*                           DefaultCloakData;                                  // 0x0198(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	bool                                          bRender;                                           // 0x01A0(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	bool                                          bCollide;                                          // 0x01A1(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	bool                                          bVisible;                                          // 0x01A2(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	bool                                          bTargetable;                                       // 0x01A3(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	bool                                          bGodMode;                                          // 0x01A4(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	bool                                          bDemigodMode;                                      // 0x01A5(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	bool                                          bAllowHitReactions;                                // 0x01A6(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	bool                                          bOnlyMoveWhileCloaked;                             // 0x01A7(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	bool                                          bCanCloakWithMovementHold;                         // 0x01A8(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	bool                                          bCloakedOnSpawn;                                   // 0x01A9(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_1AA[0x6];                                      // 0x01AA(0x0006)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<class FName>                           RenderExceptions;                                  // 0x01B0(0x0010)(Edit, ZeroConstructor, NativeAccessSpecifierPrivate)
	float                                         MinimumTransitionTime;                             // 0x01C0(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_1C4[0x4];                                      // 0x01C4(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class UStanceDataProvider*                    CloakedStance;                                     // 0x01C8(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	TSubclassOf<class UGbxAction>                 ActionCloak;                                       // 0x01D0(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	TSubclassOf<class UGbxAction>                 ActionUncloak;                                     // 0x01D8(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	bool                                          bCloakAfterAction;                                 // 0x01E0(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	bool                                          bUncloakAfterAction;                               // 0x01E1(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	bool                                          bCanInterruptActions;                              // 0x01E2(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	bool                                          bLockActions;                                      // 0x01E3(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_1E4[0x4];                                      // 0x01E4(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class UAICloakData*                           OverrideData;                                      // 0x01E8(0x0008)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UGbxActionComponent*                    ActionComp;                                        // 0x01F0(0x0008)(ExportObject, ZeroConstructor, Transient, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UTargetableComponent*                   TargetableComp;                                    // 0x01F8(0x0008)(ExportObject, ZeroConstructor, Transient, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UGbxNavComponent*                       NavComp;                                           // 0x0200(0x0008)(ExportObject, ZeroConstructor, Transient, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UGbxCharacterMovementComponent*         MoveComp;                                          // 0x0208(0x0008)(ExportObject, ZeroConstructor, Transient, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UStanceComponent*                       StanceComp;                                        // 0x0210(0x0008)(ExportObject, ZeroConstructor, Transient, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UDamageComponent*                       DamageComp;                                        // 0x0218(0x0008)(ExportObject, ZeroConstructor, Transient, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_220[0x10];                                     // 0x0220(0x0010)(Fixing Size After Last Property [ Dumper-7 ])
	struct FSavedCollision                        SavedCollision;                                    // 0x0230(0x0020)(Transient, ContainsInstancedReference, NativeAccessSpecifierPrivate)
	struct FCloakRepData                          RepData;                                           // 0x0250(0x0002)(Net, Transient, IsPlainOldData, RepNotify, NoDestructor, NativeAccessSpecifierPrivate)
	uint8                                         Pad_252[0x6];                                      // 0x0252(0x0006)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<struct FCloakPrimData>                 PrimCompData;                                      // 0x0258(0x0010)(ZeroConstructor, Transient, ContainsInstancedReference, NativeAccessSpecifierPrivate)
	uint8                                         Pad_268[0x8];                                      // 0x0268(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void ClearCloakData();
	void ClearForcedState();
	void ForceCloak(bool bInCanPlayActions);
	void ForceUncloak(bool bInCanPlayActions);
	void InterruptCloakAction();
	void OnRep_Cloaked();
	void SetCloakData(class UAICloakData* NewCloakData);

	class UAICloakData* GetCloakData() const;
	bool IsCloaked() const;
	bool IsCloakStateForced() const;
	bool IsPlayingAction() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"AICloakComponent">();
	}
	static class UAICloakComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UAICloakComponent>();
	}
};
static_assert(alignof(UAICloakComponent) == 0x000008, "Wrong alignment on UAICloakComponent");
static_assert(sizeof(UAICloakComponent) == 0x000270, "Wrong size on UAICloakComponent");
static_assert(offsetof(UAICloakComponent, OnCloaked) == 0x000178, "Member 'UAICloakComponent::OnCloaked' has a wrong offset!");
static_assert(offsetof(UAICloakComponent, OnUncloaked) == 0x000188, "Member 'UAICloakComponent::OnUncloaked' has a wrong offset!");
static_assert(offsetof(UAICloakComponent, DefaultCloakData) == 0x000198, "Member 'UAICloakComponent::DefaultCloakData' has a wrong offset!");
static_assert(offsetof(UAICloakComponent, bRender) == 0x0001A0, "Member 'UAICloakComponent::bRender' has a wrong offset!");
static_assert(offsetof(UAICloakComponent, bCollide) == 0x0001A1, "Member 'UAICloakComponent::bCollide' has a wrong offset!");
static_assert(offsetof(UAICloakComponent, bVisible) == 0x0001A2, "Member 'UAICloakComponent::bVisible' has a wrong offset!");
static_assert(offsetof(UAICloakComponent, bTargetable) == 0x0001A3, "Member 'UAICloakComponent::bTargetable' has a wrong offset!");
static_assert(offsetof(UAICloakComponent, bGodMode) == 0x0001A4, "Member 'UAICloakComponent::bGodMode' has a wrong offset!");
static_assert(offsetof(UAICloakComponent, bDemigodMode) == 0x0001A5, "Member 'UAICloakComponent::bDemigodMode' has a wrong offset!");
static_assert(offsetof(UAICloakComponent, bAllowHitReactions) == 0x0001A6, "Member 'UAICloakComponent::bAllowHitReactions' has a wrong offset!");
static_assert(offsetof(UAICloakComponent, bOnlyMoveWhileCloaked) == 0x0001A7, "Member 'UAICloakComponent::bOnlyMoveWhileCloaked' has a wrong offset!");
static_assert(offsetof(UAICloakComponent, bCanCloakWithMovementHold) == 0x0001A8, "Member 'UAICloakComponent::bCanCloakWithMovementHold' has a wrong offset!");
static_assert(offsetof(UAICloakComponent, bCloakedOnSpawn) == 0x0001A9, "Member 'UAICloakComponent::bCloakedOnSpawn' has a wrong offset!");
static_assert(offsetof(UAICloakComponent, RenderExceptions) == 0x0001B0, "Member 'UAICloakComponent::RenderExceptions' has a wrong offset!");
static_assert(offsetof(UAICloakComponent, MinimumTransitionTime) == 0x0001C0, "Member 'UAICloakComponent::MinimumTransitionTime' has a wrong offset!");
static_assert(offsetof(UAICloakComponent, CloakedStance) == 0x0001C8, "Member 'UAICloakComponent::CloakedStance' has a wrong offset!");
static_assert(offsetof(UAICloakComponent, ActionCloak) == 0x0001D0, "Member 'UAICloakComponent::ActionCloak' has a wrong offset!");
static_assert(offsetof(UAICloakComponent, ActionUncloak) == 0x0001D8, "Member 'UAICloakComponent::ActionUncloak' has a wrong offset!");
static_assert(offsetof(UAICloakComponent, bCloakAfterAction) == 0x0001E0, "Member 'UAICloakComponent::bCloakAfterAction' has a wrong offset!");
static_assert(offsetof(UAICloakComponent, bUncloakAfterAction) == 0x0001E1, "Member 'UAICloakComponent::bUncloakAfterAction' has a wrong offset!");
static_assert(offsetof(UAICloakComponent, bCanInterruptActions) == 0x0001E2, "Member 'UAICloakComponent::bCanInterruptActions' has a wrong offset!");
static_assert(offsetof(UAICloakComponent, bLockActions) == 0x0001E3, "Member 'UAICloakComponent::bLockActions' has a wrong offset!");
static_assert(offsetof(UAICloakComponent, OverrideData) == 0x0001E8, "Member 'UAICloakComponent::OverrideData' has a wrong offset!");
static_assert(offsetof(UAICloakComponent, ActionComp) == 0x0001F0, "Member 'UAICloakComponent::ActionComp' has a wrong offset!");
static_assert(offsetof(UAICloakComponent, TargetableComp) == 0x0001F8, "Member 'UAICloakComponent::TargetableComp' has a wrong offset!");
static_assert(offsetof(UAICloakComponent, NavComp) == 0x000200, "Member 'UAICloakComponent::NavComp' has a wrong offset!");
static_assert(offsetof(UAICloakComponent, MoveComp) == 0x000208, "Member 'UAICloakComponent::MoveComp' has a wrong offset!");
static_assert(offsetof(UAICloakComponent, StanceComp) == 0x000210, "Member 'UAICloakComponent::StanceComp' has a wrong offset!");
static_assert(offsetof(UAICloakComponent, DamageComp) == 0x000218, "Member 'UAICloakComponent::DamageComp' has a wrong offset!");
static_assert(offsetof(UAICloakComponent, SavedCollision) == 0x000230, "Member 'UAICloakComponent::SavedCollision' has a wrong offset!");
static_assert(offsetof(UAICloakComponent, RepData) == 0x000250, "Member 'UAICloakComponent::RepData' has a wrong offset!");
static_assert(offsetof(UAICloakComponent, PrimCompData) == 0x000258, "Member 'UAICloakComponent::PrimCompData' has a wrong offset!");

// Class GbxAI.GbxAction_NavLerp
// 0x0028 (0x00E8 - 0x00C0)
class UGbxAction_NavLerp : public UGbxAction_Navigation
{
public:
	bool                                          bWaitForDistance;                                  // 0x00C0(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_C1[0x3];                                       // 0x00C1(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         MaxHorizontalDistance;                             // 0x00C4(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	float                                         MaxVerticalDistance;                               // 0x00C8(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	bool                                          bWaitForVelocity;                                  // 0x00CC(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_CD[0x3];                                       // 0x00CD(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         MaxVelocity;                                       // 0x00D0(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	bool                                          bCallAlmostDone;                                   // 0x00D4(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_D5[0x3];                                       // 0x00D5(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         AlmostedDoneTime;                                  // 0x00D8(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	bool                                          bSpecifyLerpTime;                                  // 0x00DC(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_DD[0x3];                                       // 0x00DD(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         LerpTime;                                          // 0x00E0(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	bool                                          bVisible;                                          // 0x00E4(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_E5[0x3];                                       // 0x00E5(0x0003)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void OnAlmostDone(class AActor* Actor) const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"GbxAction_NavLerp">();
	}
	static class UGbxAction_NavLerp* GetDefaultObj()
	{
		return GetDefaultObjImpl<UGbxAction_NavLerp>();
	}
};
static_assert(alignof(UGbxAction_NavLerp) == 0x000008, "Wrong alignment on UGbxAction_NavLerp");
static_assert(sizeof(UGbxAction_NavLerp) == 0x0000E8, "Wrong size on UGbxAction_NavLerp");
static_assert(offsetof(UGbxAction_NavLerp, bWaitForDistance) == 0x0000C0, "Member 'UGbxAction_NavLerp::bWaitForDistance' has a wrong offset!");
static_assert(offsetof(UGbxAction_NavLerp, MaxHorizontalDistance) == 0x0000C4, "Member 'UGbxAction_NavLerp::MaxHorizontalDistance' has a wrong offset!");
static_assert(offsetof(UGbxAction_NavLerp, MaxVerticalDistance) == 0x0000C8, "Member 'UGbxAction_NavLerp::MaxVerticalDistance' has a wrong offset!");
static_assert(offsetof(UGbxAction_NavLerp, bWaitForVelocity) == 0x0000CC, "Member 'UGbxAction_NavLerp::bWaitForVelocity' has a wrong offset!");
static_assert(offsetof(UGbxAction_NavLerp, MaxVelocity) == 0x0000D0, "Member 'UGbxAction_NavLerp::MaxVelocity' has a wrong offset!");
static_assert(offsetof(UGbxAction_NavLerp, bCallAlmostDone) == 0x0000D4, "Member 'UGbxAction_NavLerp::bCallAlmostDone' has a wrong offset!");
static_assert(offsetof(UGbxAction_NavLerp, AlmostedDoneTime) == 0x0000D8, "Member 'UGbxAction_NavLerp::AlmostedDoneTime' has a wrong offset!");
static_assert(offsetof(UGbxAction_NavLerp, bSpecifyLerpTime) == 0x0000DC, "Member 'UGbxAction_NavLerp::bSpecifyLerpTime' has a wrong offset!");
static_assert(offsetof(UGbxAction_NavLerp, LerpTime) == 0x0000E0, "Member 'UGbxAction_NavLerp::LerpTime' has a wrong offset!");
static_assert(offsetof(UGbxAction_NavLerp, bVisible) == 0x0000E4, "Member 'UGbxAction_NavLerp::bVisible' has a wrong offset!");

// Class GbxAI.AIConstraint
// 0x0000 (0x0100 - 0x0100)
class UAIConstraint final : public UAIAspect
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"AIConstraint">();
	}
	static class UAIConstraint* GetDefaultObj()
	{
		return GetDefaultObjImpl<UAIConstraint>();
	}
};
static_assert(alignof(UAIConstraint) == 0x000008, "Wrong alignment on UAIConstraint");
static_assert(sizeof(UAIConstraint) == 0x000100, "Wrong size on UAIConstraint");

// Class GbxAI.AIGroupBlueprintLibrary
// 0x0000 (0x0028 - 0x0028)
class UAIGroupBlueprintLibrary final : public UBlueprintFunctionLibrary
{
public:
	static bool AddAITicket(struct FAITicketHandle* OutTicketHandle, class AAIController* AIUser, class UAITicketDataAsset* Ticket, float Value, float MaxDuration, bool bPriority, bool bInterruptible);
	static bool CanUseAITicket(class AAIController* AIUser, class UAITicketDataAsset* Ticket, float Value, bool bInterruptible);
	static void ClearAITicket(class AAIController* AIUser, class UAITicketDataAsset* Ticket, float HoldDuration);
	static void ClearTicket(struct FAITicketHandle& TicketHandle, float HoldDuration);
	static bool IsTicketValid(struct FAITicketHandle& TicketHandle);
	static bool IsUsingAITicket(class AAIController* AIUser, class UAITicketDataAsset* Ticket, bool bInterruptible);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"AIGroupBlueprintLibrary">();
	}
	static class UAIGroupBlueprintLibrary* GetDefaultObj()
	{
		return GetDefaultObjImpl<UAIGroupBlueprintLibrary>();
	}
};
static_assert(alignof(UAIGroupBlueprintLibrary) == 0x000008, "Wrong alignment on UAIGroupBlueprintLibrary");
static_assert(sizeof(UAIGroupBlueprintLibrary) == 0x000028, "Wrong size on UAIGroupBlueprintLibrary");

// Class GbxAI.AIGroupState
// 0x2818 (0x2840 - 0x0028)
class UAIGroupState final : public UObject
{
public:
	uint8                                         Pad_28[0x18];                                      // 0x0028(0x0018)(Fixing Size After Last Property [ Dumper-7 ])
	class USpawnerLinkComponent*                  LinkComponent;                                     // 0x0040(0x0008)(Edit, ExportObject, ZeroConstructor, Transient, EditConst, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	struct FAITicketManager                       TicketManager;                                     // 0x0048(0x2718)(Edit, EditConst, NativeAccessSpecifierPrivate)
	struct FAICommunicationManager                CommunicationManager;                              // 0x2760(0x0048)(Edit, EditConst, NativeAccessSpecifierPrivate)
	struct FAIPlanManager                         PlanManager;                                       // 0x27A8(0x0080)(Edit, EditConst, NativeAccessSpecifierPrivate)
	TArray<struct FTargetPersistentNotes>         TargetPersistentNotes;                             // 0x2828(0x0010)(ZeroConstructor, Transient, NativeAccessSpecifierPrivate)
	uint8                                         Pad_2838[0x8];                                     // 0x2838(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void OnThreatActorDied(class AActor* DamageReceiver, class AActor* DamageCauser);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"AIGroupState">();
	}
	static class UAIGroupState* GetDefaultObj()
	{
		return GetDefaultObjImpl<UAIGroupState>();
	}
};
static_assert(alignof(UAIGroupState) == 0x000008, "Wrong alignment on UAIGroupState");
static_assert(sizeof(UAIGroupState) == 0x002840, "Wrong size on UAIGroupState");
static_assert(offsetof(UAIGroupState, LinkComponent) == 0x000040, "Member 'UAIGroupState::LinkComponent' has a wrong offset!");
static_assert(offsetof(UAIGroupState, TicketManager) == 0x000048, "Member 'UAIGroupState::TicketManager' has a wrong offset!");
static_assert(offsetof(UAIGroupState, CommunicationManager) == 0x002760, "Member 'UAIGroupState::CommunicationManager' has a wrong offset!");
static_assert(offsetof(UAIGroupState, PlanManager) == 0x0027A8, "Member 'UAIGroupState::PlanManager' has a wrong offset!");
static_assert(offsetof(UAIGroupState, TargetPersistentNotes) == 0x002828, "Member 'UAIGroupState::TargetPersistentNotes' has a wrong offset!");

// Class GbxAI.AINode
// 0x0040 (0x0498 - 0x0458)
class AAINode final : public AActor
{
public:
	class UAINodeComponent*                       AINodeComponent;                                   // 0x0458(0x0008)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, EditConst, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	UMulticastDelegateProperty_                   OnPawnArrivedNode;                                 // 0x0460(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	UMulticastDelegateProperty_                   OnPawnDepartedNode;                                // 0x0470(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	uint8                                         Pad_480[0x18];                                     // 0x0480(0x0018)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void OnPawnArrivedNodeCB(class AActor* NodeActor, class APawn* ArrivedPawn);
	void OnPawnDepartedNodeCB(class AActor* NodeActor, class APawn* DepartedPawn);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"AINode">();
	}
	static class AAINode* GetDefaultObj()
	{
		return GetDefaultObjImpl<AAINode>();
	}
};
static_assert(alignof(AAINode) == 0x000008, "Wrong alignment on AAINode");
static_assert(sizeof(AAINode) == 0x000498, "Wrong size on AAINode");
static_assert(offsetof(AAINode, AINodeComponent) == 0x000458, "Member 'AAINode::AINodeComponent' has a wrong offset!");
static_assert(offsetof(AAINode, OnPawnArrivedNode) == 0x000460, "Member 'AAINode::OnPawnArrivedNode' has a wrong offset!");
static_assert(offsetof(AAINode, OnPawnDepartedNode) == 0x000470, "Member 'AAINode::OnPawnDepartedNode' has a wrong offset!");

// Class GbxAI.AIAction_MoveToLevelSequence
// 0x0000 (0x0FA0 - 0x0FA0)
class UAIAction_MoveToLevelSequence final : public UAIAction_GoToPoint
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"AIAction_MoveToLevelSequence">();
	}
	static class UAIAction_MoveToLevelSequence* GetDefaultObj()
	{
		return GetDefaultObjImpl<UAIAction_MoveToLevelSequence>();
	}
};
static_assert(alignof(UAIAction_MoveToLevelSequence) == 0x000008, "Wrong alignment on UAIAction_MoveToLevelSequence");
static_assert(sizeof(UAIAction_MoveToLevelSequence) == 0x000FA0, "Wrong size on UAIAction_MoveToLevelSequence");

// Class GbxAI.AINodeBlueprintLibrary
// 0x0000 (0x0028 - 0x0028)
class UAINodeBlueprintLibrary final : public UBlueprintFunctionLibrary
{
public:
	static class AActor* ChooseRandomNode(class UObject* WorldContextObject, bool bIncludeDisabled);
	static void FindAllNodes(TArray<class AActor*>* OutputNodes, class UObject* WorldContextObject, bool bIncludeDisabled);
	static class AActor* FindNearestNode(class UObject* WorldContextObject, const struct FVector& Location, bool bIncludeDisabled);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"AINodeBlueprintLibrary">();
	}
	static class UAINodeBlueprintLibrary* GetDefaultObj()
	{
		return GetDefaultObjImpl<UAINodeBlueprintLibrary>();
	}
};
static_assert(alignof(UAINodeBlueprintLibrary) == 0x000008, "Wrong alignment on UAINodeBlueprintLibrary");
static_assert(sizeof(UAINodeBlueprintLibrary) == 0x000028, "Wrong size on UAINodeBlueprintLibrary");

// Class GbxAI.AINodeComponent
// 0x0098 (0x0788 - 0x06F0)
#pragma pack(push, 0x1)
class alignas(0x08) UAINodeComponent : public UPrimitiveComponent
{
public:
	uint8                                         Pad_6F0[0x8];                                      // 0x06F0(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	bool                                          bEnabled;                                          // 0x06F8(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bUseRouteSystem;                                   // 0x06F9(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_6FA[0x2];                                      // 0x06FA(0x0002)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         RouteFindNavHeight;                                // 0x06FC(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bDrawRouteFindNavHeight;                           // 0x0700(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_701[0x3];                                      // 0x0701(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         ArrivalThreshold;                                  // 0x0704(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         ArrivalHeightThreshold;                            // 0x0708(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bSnapToGround;                                     // 0x070C(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_70D[0x3];                                      // 0x070D(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         MaxSnapDistance;                                   // 0x0710(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_714[0x4];                                      // 0x0714(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<struct FAINodeLink>                    LinksTo;                                           // 0x0718(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnTemplate, NativeAccessSpecifierPublic)
	TArray<class AActor*>                         EditCache;                                         // 0x0728(0x0010)(ZeroConstructor, Transient, DuplicateTransient, NativeAccessSpecifierPublic)
	TArray<class UAINodeComponent*>               LinksFrom;                                         // 0x0738(0x0010)(ExportObject, ZeroConstructor, Transient, ContainsInstancedReference, NativeAccessSpecifierPublic)
	UMulticastDelegateProperty_                   OnPawnArrivedNode;                                 // 0x0748(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	UMulticastDelegateProperty_                   OnPawnDepartedNode;                                // 0x0758(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	bool                                          bLinkOnAltDrag;                                    // 0x0768(0x0001)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bVisualizeWhileUnlinked;                           // 0x0769(0x0001)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bRouteSelected;                                    // 0x076A(0x0001)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bSelected;                                         // 0x076B(0x0001)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_76C[0x1C];                                     // 0x076C(0x001C)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	bool BreakLinkTo(class AActor* Node);
	void CreateLinkTo(class AActor* Node, float Weight);

	class AActor* GetLinkedNode(int32 I) const;
	int32 GetLinkedNodeNum() const;
	bool HasArrived(const struct FVector& Point, float Error) const;
	bool HasLinkFrom(class AActor* Node) const;
	bool HasLinkTo(class AActor* Node) const;
	class AActor* SelectNextNode() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"AINodeComponent">();
	}
	static class UAINodeComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UAINodeComponent>();
	}
};
#pragma pack(pop)
static_assert(alignof(UAINodeComponent) == 0x000008, "Wrong alignment on UAINodeComponent");
static_assert(sizeof(UAINodeComponent) == 0x000788, "Wrong size on UAINodeComponent");
static_assert(offsetof(UAINodeComponent, bEnabled) == 0x0006F8, "Member 'UAINodeComponent::bEnabled' has a wrong offset!");
static_assert(offsetof(UAINodeComponent, bUseRouteSystem) == 0x0006F9, "Member 'UAINodeComponent::bUseRouteSystem' has a wrong offset!");
static_assert(offsetof(UAINodeComponent, RouteFindNavHeight) == 0x0006FC, "Member 'UAINodeComponent::RouteFindNavHeight' has a wrong offset!");
static_assert(offsetof(UAINodeComponent, bDrawRouteFindNavHeight) == 0x000700, "Member 'UAINodeComponent::bDrawRouteFindNavHeight' has a wrong offset!");
static_assert(offsetof(UAINodeComponent, ArrivalThreshold) == 0x000704, "Member 'UAINodeComponent::ArrivalThreshold' has a wrong offset!");
static_assert(offsetof(UAINodeComponent, ArrivalHeightThreshold) == 0x000708, "Member 'UAINodeComponent::ArrivalHeightThreshold' has a wrong offset!");
static_assert(offsetof(UAINodeComponent, bSnapToGround) == 0x00070C, "Member 'UAINodeComponent::bSnapToGround' has a wrong offset!");
static_assert(offsetof(UAINodeComponent, MaxSnapDistance) == 0x000710, "Member 'UAINodeComponent::MaxSnapDistance' has a wrong offset!");
static_assert(offsetof(UAINodeComponent, LinksTo) == 0x000718, "Member 'UAINodeComponent::LinksTo' has a wrong offset!");
static_assert(offsetof(UAINodeComponent, EditCache) == 0x000728, "Member 'UAINodeComponent::EditCache' has a wrong offset!");
static_assert(offsetof(UAINodeComponent, LinksFrom) == 0x000738, "Member 'UAINodeComponent::LinksFrom' has a wrong offset!");
static_assert(offsetof(UAINodeComponent, OnPawnArrivedNode) == 0x000748, "Member 'UAINodeComponent::OnPawnArrivedNode' has a wrong offset!");
static_assert(offsetof(UAINodeComponent, OnPawnDepartedNode) == 0x000758, "Member 'UAINodeComponent::OnPawnDepartedNode' has a wrong offset!");
static_assert(offsetof(UAINodeComponent, bLinkOnAltDrag) == 0x000768, "Member 'UAINodeComponent::bLinkOnAltDrag' has a wrong offset!");
static_assert(offsetof(UAINodeComponent, bVisualizeWhileUnlinked) == 0x000769, "Member 'UAINodeComponent::bVisualizeWhileUnlinked' has a wrong offset!");
static_assert(offsetof(UAINodeComponent, bRouteSelected) == 0x00076A, "Member 'UAINodeComponent::bRouteSelected' has a wrong offset!");
static_assert(offsetof(UAINodeComponent, bSelected) == 0x00076B, "Member 'UAINodeComponent::bSelected' has a wrong offset!");

// Class GbxAI.GbxBehaviorTreeComponent
// 0x0000 (0x0328 - 0x0328)
class UGbxBehaviorTreeComponent final : public UBehaviorTreeComponent
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"GbxBehaviorTreeComponent">();
	}
	static class UGbxBehaviorTreeComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UGbxBehaviorTreeComponent>();
	}
};
static_assert(alignof(UGbxBehaviorTreeComponent) == 0x000008, "Wrong alignment on UGbxBehaviorTreeComponent");
static_assert(sizeof(UGbxBehaviorTreeComponent) == 0x000328, "Wrong size on UGbxBehaviorTreeComponent");

// Class GbxAI.AIPlanData
// 0x0090 (0x00C0 - 0x0030)
class UAIPlanData final : public UGbxDataAsset
{
public:
	struct FGbxParam                              MaxNumberOfInstances;                              // 0x0030(0x0080)(Edit, BlueprintVisible, BlueprintReadOnly, NoDestructor, ContainsInstancedReference, NativeAccessSpecifierPublic)
	TArray<struct FPlanRoleRequirements>          RoleRequirements;                                  // 0x00B0(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, ContainsInstancedReference, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"AIPlanData">();
	}
	static class UAIPlanData* GetDefaultObj()
	{
		return GetDefaultObjImpl<UAIPlanData>();
	}
};
static_assert(alignof(UAIPlanData) == 0x000008, "Wrong alignment on UAIPlanData");
static_assert(sizeof(UAIPlanData) == 0x0000C0, "Wrong size on UAIPlanData");
static_assert(offsetof(UAIPlanData, MaxNumberOfInstances) == 0x000030, "Member 'UAIPlanData::MaxNumberOfInstances' has a wrong offset!");
static_assert(offsetof(UAIPlanData, RoleRequirements) == 0x0000B0, "Member 'UAIPlanData::RoleRequirements' has a wrong offset!");

// Class GbxAI.AISense_Proximity
// 0x0068 (0x0100 - 0x0098)
class UAISense_Proximity final : public UAISense
{
public:
	uint8                                         Pad_98[0x68];                                      // 0x0098(0x0068)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"AISense_Proximity">();
	}
	static class UAISense_Proximity* GetDefaultObj()
	{
		return GetDefaultObjImpl<UAISense_Proximity>();
	}
};
static_assert(alignof(UAISense_Proximity) == 0x000008, "Wrong alignment on UAISense_Proximity");
static_assert(sizeof(UAISense_Proximity) == 0x000100, "Wrong size on UAISense_Proximity");

// Class GbxAI.AISense_Threat
// 0x0088 (0x0120 - 0x0098)
class UAISense_Threat final : public UAISense
{
public:
	uint8                                         Pad_98[0x70];                                      // 0x0098(0x0070)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<class UTargetingComponent*>            TargetingComponents;                               // 0x0108(0x0010)(ExportObject, ZeroConstructor, Transient, ContainsInstancedReference, Protected, NativeAccessSpecifierProtected)
	float                                         UpdatePeriod;                                      // 0x0118(0x0004)(Edit, ZeroConstructor, Config, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_11C[0x4];                                      // 0x011C(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"AISense_Threat">();
	}
	static class UAISense_Threat* GetDefaultObj()
	{
		return GetDefaultObjImpl<UAISense_Threat>();
	}
};
static_assert(alignof(UAISense_Threat) == 0x000008, "Wrong alignment on UAISense_Threat");
static_assert(sizeof(UAISense_Threat) == 0x000120, "Wrong size on UAISense_Threat");
static_assert(offsetof(UAISense_Threat, TargetingComponents) == 0x000108, "Member 'UAISense_Threat::TargetingComponents' has a wrong offset!");
static_assert(offsetof(UAISense_Threat, UpdatePeriod) == 0x000118, "Member 'UAISense_Threat::UpdatePeriod' has a wrong offset!");

// Class GbxAI.AISenseConfig_Proximity
// 0x0008 (0x0050 - 0x0048)
class UAISenseConfig_Proximity final : public UAISenseConfig
{
public:
	float                                         SenseEnemyDistance;                                // 0x0048(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Config, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FAISenseAffiliationFilter              DetectionByAffiliation;                            // 0x004C(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, Config, DisableEditOnInstance, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"AISenseConfig_Proximity">();
	}
	static class UAISenseConfig_Proximity* GetDefaultObj()
	{
		return GetDefaultObjImpl<UAISenseConfig_Proximity>();
	}
};
static_assert(alignof(UAISenseConfig_Proximity) == 0x000008, "Wrong alignment on UAISenseConfig_Proximity");
static_assert(sizeof(UAISenseConfig_Proximity) == 0x000050, "Wrong size on UAISenseConfig_Proximity");
static_assert(offsetof(UAISenseConfig_Proximity, SenseEnemyDistance) == 0x000048, "Member 'UAISenseConfig_Proximity::SenseEnemyDistance' has a wrong offset!");
static_assert(offsetof(UAISenseConfig_Proximity, DetectionByAffiliation) == 0x00004C, "Member 'UAISenseConfig_Proximity::DetectionByAffiliation' has a wrong offset!");

// Class GbxAI.EnvQueryContext_Friendlies
// 0x0000 (0x0028 - 0x0028)
class UEnvQueryContext_Friendlies final : public UEnvQueryContext
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"EnvQueryContext_Friendlies">();
	}
	static class UEnvQueryContext_Friendlies* GetDefaultObj()
	{
		return GetDefaultObjImpl<UEnvQueryContext_Friendlies>();
	}
};
static_assert(alignof(UEnvQueryContext_Friendlies) == 0x000008, "Wrong alignment on UEnvQueryContext_Friendlies");
static_assert(sizeof(UEnvQueryContext_Friendlies) == 0x000028, "Wrong size on UEnvQueryContext_Friendlies");

// Class GbxAI.AISenseConfig_Threat
// 0x0010 (0x0058 - 0x0048)
class UAISenseConfig_Threat final : public UAISenseConfig
{
public:
	struct FAISenseAffiliationFilter              DetectionByAffiliation;                            // 0x0048(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, Config, DisableEditOnInstance, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
	uint8                                         Pad_4C[0x4];                                       // 0x004C(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	TSubclassOf<class UAISense_Threat>            Implementation;                                    // 0x0050(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Config, DisableEditOnInstance, NoClear, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"AISenseConfig_Threat">();
	}
	static class UAISenseConfig_Threat* GetDefaultObj()
	{
		return GetDefaultObjImpl<UAISenseConfig_Threat>();
	}
};
static_assert(alignof(UAISenseConfig_Threat) == 0x000008, "Wrong alignment on UAISenseConfig_Threat");
static_assert(sizeof(UAISenseConfig_Threat) == 0x000058, "Wrong size on UAISenseConfig_Threat");
static_assert(offsetof(UAISenseConfig_Threat, DetectionByAffiliation) == 0x000048, "Member 'UAISenseConfig_Threat::DetectionByAffiliation' has a wrong offset!");
static_assert(offsetof(UAISenseConfig_Threat, Implementation) == 0x000050, "Member 'UAISenseConfig_Threat::Implementation' has a wrong offset!");

// Class GbxAI.GbxAnimStateManager_Cover
// 0x0048 (0x0080 - 0x0038)
class UGbxAnimStateManager_Cover final : public UGbxAnimStateManager
{
public:
	ECoverUserAnimState                           Type;                                              // 0x0038(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_39[0x7];                                       // 0x0039(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	class UCoverStyleData*                        Style;                                             // 0x0040(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	TArray<class UCoverViewData*>                 Views;                                             // 0x0048(0x0010)(Edit, ZeroConstructor, NativeAccessSpecifierPrivate)
	class UGbxCoverTransitionTable*               TransitionTable;                                   // 0x0058(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UCoverUserComponent*                    CoverUser;                                         // 0x0060(0x0008)(ExportObject, ZeroConstructor, Transient, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UGbxCharacterAnimInstance*              GbxCharAnimInstance;                               // 0x0068(0x0008)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UGbxCharacterMovementComponent*         GbxCharMoveComponent;                              // 0x0070(0x0008)(ExportObject, ZeroConstructor, Transient, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UAnimSequence*                          AnimSequence;                                      // 0x0078(0x0008)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)

public:
	void Owner_PostBeginPlay();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"GbxAnimStateManager_Cover">();
	}
	static class UGbxAnimStateManager_Cover* GetDefaultObj()
	{
		return GetDefaultObjImpl<UGbxAnimStateManager_Cover>();
	}
};
static_assert(alignof(UGbxAnimStateManager_Cover) == 0x000008, "Wrong alignment on UGbxAnimStateManager_Cover");
static_assert(sizeof(UGbxAnimStateManager_Cover) == 0x000080, "Wrong size on UGbxAnimStateManager_Cover");
static_assert(offsetof(UGbxAnimStateManager_Cover, Type) == 0x000038, "Member 'UGbxAnimStateManager_Cover::Type' has a wrong offset!");
static_assert(offsetof(UGbxAnimStateManager_Cover, Style) == 0x000040, "Member 'UGbxAnimStateManager_Cover::Style' has a wrong offset!");
static_assert(offsetof(UGbxAnimStateManager_Cover, Views) == 0x000048, "Member 'UGbxAnimStateManager_Cover::Views' has a wrong offset!");
static_assert(offsetof(UGbxAnimStateManager_Cover, TransitionTable) == 0x000058, "Member 'UGbxAnimStateManager_Cover::TransitionTable' has a wrong offset!");
static_assert(offsetof(UGbxAnimStateManager_Cover, CoverUser) == 0x000060, "Member 'UGbxAnimStateManager_Cover::CoverUser' has a wrong offset!");
static_assert(offsetof(UGbxAnimStateManager_Cover, GbxCharAnimInstance) == 0x000068, "Member 'UGbxAnimStateManager_Cover::GbxCharAnimInstance' has a wrong offset!");
static_assert(offsetof(UGbxAnimStateManager_Cover, GbxCharMoveComponent) == 0x000070, "Member 'UGbxAnimStateManager_Cover::GbxCharMoveComponent' has a wrong offset!");
static_assert(offsetof(UGbxAnimStateManager_Cover, AnimSequence) == 0x000078, "Member 'UGbxAnimStateManager_Cover::AnimSequence' has a wrong offset!");

// Class GbxAI.AIStanceData
// 0x0010 (0x00B8 - 0x00A8)
class UAIStanceData : public UStanceData
{
public:
	class UHavokPathFindingData*                  AIPathFindData;                                    // 0x00A8(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	EGbxStrafeType                                AIStrafeType;                                      // 0x00B0(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_B1[0x7];                                       // 0x00B1(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"AIStanceData">();
	}
	static class UAIStanceData* GetDefaultObj()
	{
		return GetDefaultObjImpl<UAIStanceData>();
	}
};
static_assert(alignof(UAIStanceData) == 0x000008, "Wrong alignment on UAIStanceData");
static_assert(sizeof(UAIStanceData) == 0x0000B8, "Wrong size on UAIStanceData");
static_assert(offsetof(UAIStanceData, AIPathFindData) == 0x0000A8, "Member 'UAIStanceData::AIPathFindData' has a wrong offset!");
static_assert(offsetof(UAIStanceData, AIStrafeType) == 0x0000B0, "Member 'UAIStanceData::AIStrafeType' has a wrong offset!");

// Class GbxAI.AITargetingBlueprintLibrary
// 0x0000 (0x0028 - 0x0028)
class UAITargetingBlueprintLibrary final : public UBlueprintFunctionLibrary
{
public:
	static bool AICanCommunicate(class AActor* AIActor, float Radius, float MinSenseAgeDelta);
	static class AActor* AIGetScriptedTarget(class AActor* AIActor);
	static void AIPlayerProvoke(class AActor* AITarget);
	static void AIProvoke(class AActor* AITarget, class AActor* Source);
	static void AIProvokeSpecificSense(class AActor* AITarget, class AActor* Source, TSubclassOf<class UAISense> SenseType, const struct FVector& StimulusLocation);
	static void AISendCommunication(class AActor* AIActor, float Radius);
	static void AISetScriptedTarget(class AActor* AIActor, class AActor* TargetActor);
	static void AISetTargetInBlackboard(class AActor* AIActor, const struct FGbxBlackboardKeySelector& Key, int32 TargetIndex);
	static void ApplyTargetScoringBoost(class AActor* TargetActor, class FName BoostName, EAITargetScoringBoost ScoringBoost, float DurationInSeconds);
	static bool CalcTargetGroupLocation(class AActor* AIActor, float GroupDistance, struct FVector* Result);
	static struct FVector GetBestKnownLocation(class AActor* AIActor, class AActor* TargetActor, class FName Socket);
	static int32 GetNumTargetsInRange(class AActor* AIActor, float Radius);
	static float GetTargetSenseAge(const struct FTargetActorInfo& TargetInfo, TSubclassOf<class UAISense> Sense);
	static bool IsThreatenedBy(class AActor* AIActor, class AActor* Target);
	static bool IsThreatenedByInfo(class AActor* AIActor, const struct FTargetActorInfo& TargetInfo);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"AITargetingBlueprintLibrary">();
	}
	static class UAITargetingBlueprintLibrary* GetDefaultObj()
	{
		return GetDefaultObjImpl<UAITargetingBlueprintLibrary>();
	}
};
static_assert(alignof(UAITargetingBlueprintLibrary) == 0x000008, "Wrong alignment on UAITargetingBlueprintLibrary");
static_assert(sizeof(UAITargetingBlueprintLibrary) == 0x000028, "Wrong size on UAITargetingBlueprintLibrary");

// Class GbxAI.AITask_UseLookAtPoint
// 0x0040 (0x00B0 - 0x0070)
class UAITask_UseLookAtPoint final : public UAITask
{
public:
	uint8                                         Pad_70[0x10];                                      // 0x0070(0x0010)(Fixing Size After Last Property [ Dumper-7 ])
	class ULookAtPointComponent*                  LookAtPointComponent;                              // 0x0080(0x0008)(ExportObject, ZeroConstructor, Transient, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class ULookAtPointTag*                        Tag;                                               // 0x0088(0x0008)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UAITask_MoveTo*                         MoveToTask;                                        // 0x0090(0x0008)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_98[0x10];                                      // 0x0098(0x0010)(Fixing Size After Last Property [ Dumper-7 ])
	ESmartObjectTaskState                         State;                                             // 0x00A8(0x0001)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_A9[0x7];                                       // 0x00A9(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"AITask_UseLookAtPoint">();
	}
	static class UAITask_UseLookAtPoint* GetDefaultObj()
	{
		return GetDefaultObjImpl<UAITask_UseLookAtPoint>();
	}
};
static_assert(alignof(UAITask_UseLookAtPoint) == 0x000008, "Wrong alignment on UAITask_UseLookAtPoint");
static_assert(sizeof(UAITask_UseLookAtPoint) == 0x0000B0, "Wrong size on UAITask_UseLookAtPoint");
static_assert(offsetof(UAITask_UseLookAtPoint, LookAtPointComponent) == 0x000080, "Member 'UAITask_UseLookAtPoint::LookAtPointComponent' has a wrong offset!");
static_assert(offsetof(UAITask_UseLookAtPoint, Tag) == 0x000088, "Member 'UAITask_UseLookAtPoint::Tag' has a wrong offset!");
static_assert(offsetof(UAITask_UseLookAtPoint, MoveToTask) == 0x000090, "Member 'UAITask_UseLookAtPoint::MoveToTask' has a wrong offset!");
static_assert(offsetof(UAITask_UseLookAtPoint, State) == 0x0000A8, "Member 'UAITask_UseLookAtPoint::State' has a wrong offset!");

// Class GbxAI.AITask_UsePerch
// 0x0040 (0x00B0 - 0x0070)
class UAITask_UsePerch final : public UAITask
{
public:
	uint8                                         Pad_70[0x10];                                      // 0x0070(0x0010)(Fixing Size After Last Property [ Dumper-7 ])
	class UPerchComponent*                        PerchComponent;                                    // 0x0080(0x0008)(ExportObject, ZeroConstructor, Transient, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UPerchTag*                              Tag;                                               // 0x0088(0x0008)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_90[0x10];                                      // 0x0090(0x0010)(Fixing Size After Last Property [ Dumper-7 ])
	class UAITask_MoveTo*                         MoveToTask;                                        // 0x00A0(0x0008)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	ESmartObjectTaskState                         State;                                             // 0x00A8(0x0001)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_A9[0x7];                                       // 0x00A9(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"AITask_UsePerch">();
	}
	static class UAITask_UsePerch* GetDefaultObj()
	{
		return GetDefaultObjImpl<UAITask_UsePerch>();
	}
};
static_assert(alignof(UAITask_UsePerch) == 0x000008, "Wrong alignment on UAITask_UsePerch");
static_assert(sizeof(UAITask_UsePerch) == 0x0000B0, "Wrong size on UAITask_UsePerch");
static_assert(offsetof(UAITask_UsePerch, PerchComponent) == 0x000080, "Member 'UAITask_UsePerch::PerchComponent' has a wrong offset!");
static_assert(offsetof(UAITask_UsePerch, Tag) == 0x000088, "Member 'UAITask_UsePerch::Tag' has a wrong offset!");
static_assert(offsetof(UAITask_UsePerch, MoveToTask) == 0x0000A0, "Member 'UAITask_UsePerch::MoveToTask' has a wrong offset!");
static_assert(offsetof(UAITask_UsePerch, State) == 0x0000A8, "Member 'UAITask_UsePerch::State' has a wrong offset!");

// Class GbxAI.AITask_UseSmartObject
// 0x0000 (0x0070 - 0x0070)
class UAITask_UseSmartObject final : public UAITask
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"AITask_UseSmartObject">();
	}
	static class UAITask_UseSmartObject* GetDefaultObj()
	{
		return GetDefaultObjImpl<UAITask_UseSmartObject>();
	}
};
static_assert(alignof(UAITask_UseSmartObject) == 0x000008, "Wrong alignment on UAITask_UseSmartObject");
static_assert(sizeof(UAITask_UseSmartObject) == 0x000070, "Wrong size on UAITask_UseSmartObject");

// Class GbxAI.EnvQueryTest_TacticalCover
// 0x0008 (0x01E0 - 0x01D8)
class UEnvQueryTest_TacticalCover final : public UEnvQueryTest
{
public:
	TSubclassOf<class UEnvQueryContext>           Context;                                           // 0x01D8(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"EnvQueryTest_TacticalCover">();
	}
	static class UEnvQueryTest_TacticalCover* GetDefaultObj()
	{
		return GetDefaultObjImpl<UEnvQueryTest_TacticalCover>();
	}
};
static_assert(alignof(UEnvQueryTest_TacticalCover) == 0x000008, "Wrong alignment on UEnvQueryTest_TacticalCover");
static_assert(sizeof(UEnvQueryTest_TacticalCover) == 0x0001E0, "Wrong size on UEnvQueryTest_TacticalCover");
static_assert(offsetof(UEnvQueryTest_TacticalCover, Context) == 0x0001D8, "Member 'UEnvQueryTest_TacticalCover::Context' has a wrong offset!");

// Class GbxAI.AITicketDataAsset
// 0x0110 (0x0140 - 0x0030)
class UAITicketDataAsset final : public UGbxDataAsset
{
public:
	struct FGbxParam                              MaxValue;                                          // 0x0030(0x0080)(Edit, BlueprintVisible, BlueprintReadOnly, NoDestructor, ContainsInstancedReference, NativeAccessSpecifierPublic)
	struct FGbxParam                              DefaultMaxHoldTime;                                // 0x00B0(0x0080)(Edit, BlueprintVisible, BlueprintReadOnly, NoDestructor, ContainsInstancedReference, NativeAccessSpecifierPublic)
	bool                                          bPerActor;                                         // 0x0130(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_131[0x7];                                      // 0x0131(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	class FName                                   ActorBlackboardKeyName;                            // 0x0138(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"AITicketDataAsset">();
	}
	static class UAITicketDataAsset* GetDefaultObj()
	{
		return GetDefaultObjImpl<UAITicketDataAsset>();
	}
};
static_assert(alignof(UAITicketDataAsset) == 0x000008, "Wrong alignment on UAITicketDataAsset");
static_assert(sizeof(UAITicketDataAsset) == 0x000140, "Wrong size on UAITicketDataAsset");
static_assert(offsetof(UAITicketDataAsset, MaxValue) == 0x000030, "Member 'UAITicketDataAsset::MaxValue' has a wrong offset!");
static_assert(offsetof(UAITicketDataAsset, DefaultMaxHoldTime) == 0x0000B0, "Member 'UAITicketDataAsset::DefaultMaxHoldTime' has a wrong offset!");
static_assert(offsetof(UAITicketDataAsset, bPerActor) == 0x000130, "Member 'UAITicketDataAsset::bPerActor' has a wrong offset!");
static_assert(offsetof(UAITicketDataAsset, ActorBlackboardKeyName) == 0x000138, "Member 'UAITicketDataAsset::ActorBlackboardKeyName' has a wrong offset!");

// Class GbxAI.AIUsableComponent
// 0x0038 (0x01B0 - 0x0178)
class UAIUsableComponent final : public UActorComponent
{
public:
	bool                                          bEnabled;                                          // 0x0178(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_179[0x7];                                      // 0x0179(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	class USmartObjectComponent*                  SmartObjectComponent;                              // 0x0180(0x0008)(ExportObject, ZeroConstructor, Transient, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	TArray<class UAIUseSlotComponent*>            UseSlots;                                          // 0x0188(0x0010)(ExportObject, ZeroConstructor, Transient, ContainsInstancedReference, NativeAccessSpecifierPrivate)
	uint8                                         Pad_198[0x18];                                     // 0x0198(0x0018)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"AIUsableComponent">();
	}
	static class UAIUsableComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UAIUsableComponent>();
	}
};
static_assert(alignof(UAIUsableComponent) == 0x000008, "Wrong alignment on UAIUsableComponent");
static_assert(sizeof(UAIUsableComponent) == 0x0001B0, "Wrong size on UAIUsableComponent");
static_assert(offsetof(UAIUsableComponent, bEnabled) == 0x000178, "Member 'UAIUsableComponent::bEnabled' has a wrong offset!");
static_assert(offsetof(UAIUsableComponent, SmartObjectComponent) == 0x000180, "Member 'UAIUsableComponent::SmartObjectComponent' has a wrong offset!");
static_assert(offsetof(UAIUsableComponent, UseSlots) == 0x000188, "Member 'UAIUsableComponent::UseSlots' has a wrong offset!");

// Class GbxAI.GbxCondition_CanFidgetNow
// 0x0000 (0x0088 - 0x0088)
class UGbxCondition_CanFidgetNow final : public UGbxCondition
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"GbxCondition_CanFidgetNow">();
	}
	static class UGbxCondition_CanFidgetNow* GetDefaultObj()
	{
		return GetDefaultObjImpl<UGbxCondition_CanFidgetNow>();
	}
};
static_assert(alignof(UGbxCondition_CanFidgetNow) == 0x000008, "Wrong alignment on UGbxCondition_CanFidgetNow");
static_assert(sizeof(UGbxCondition_CanFidgetNow) == 0x000088, "Wrong size on UGbxCondition_CanFidgetNow");

// Class GbxAI.AIUseComponent
// 0x0160 (0x02D8 - 0x0178)
class UAIUseComponent final : public UActorComponent
{
public:
	uint8                                         Pad_178[0x8];                                      // 0x0178(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	UMulticastDelegateProperty_                   ReserveEvent;                                      // 0x0180(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	UMulticastDelegateProperty_                   UnreserveEvent;                                    // 0x0190(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	UMulticastDelegateProperty_                   BeginEvent;                                        // 0x01A0(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	UMulticastDelegateProperty_                   InterruptEvent;                                    // 0x01B0(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	UMulticastDelegateProperty_                   SuccessEvent;                                      // 0x01C0(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	class APawn*                                  CachedPawn;                                        // 0x01D0(0x0008)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class AGbxAIController*                       CachedController;                                  // 0x01D8(0x0008)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UGbxActionComponent*                    CachedActionComponent;                             // 0x01E0(0x0008)(ExportObject, ZeroConstructor, Transient, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	struct FActionUseState                        UseState;                                          // 0x01E8(0x00C0)(Transient, ContainsInstancedReference, NativeAccessSpecifierPrivate)
	bool                                          bInitializingAction;                               // 0x02A8(0x0001)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_2A9[0x7];                                      // 0x02A9(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<struct FActionCooldownInfo>            GlobalCooldowns;                                   // 0x02B0(0x0010)(ZeroConstructor, Transient, NativeAccessSpecifierPrivate)
	uint8                                         Pad_2C0[0x18];                                     // 0x02C0(0x0018)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	class AActor* GetCurrentObject();
	void OnUseCompleted(class UAITask* Task, ESmartObjectTaskResult Result);
	bool RequestUse(class AActor* SmartObject, const struct FGameplayTag& ActionName, bool bAbortExisting, bool bUntilInterrupted);
	void StopUse(bool bSucceeded);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"AIUseComponent">();
	}
	static class UAIUseComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UAIUseComponent>();
	}
};
static_assert(alignof(UAIUseComponent) == 0x000008, "Wrong alignment on UAIUseComponent");
static_assert(sizeof(UAIUseComponent) == 0x0002D8, "Wrong size on UAIUseComponent");
static_assert(offsetof(UAIUseComponent, ReserveEvent) == 0x000180, "Member 'UAIUseComponent::ReserveEvent' has a wrong offset!");
static_assert(offsetof(UAIUseComponent, UnreserveEvent) == 0x000190, "Member 'UAIUseComponent::UnreserveEvent' has a wrong offset!");
static_assert(offsetof(UAIUseComponent, BeginEvent) == 0x0001A0, "Member 'UAIUseComponent::BeginEvent' has a wrong offset!");
static_assert(offsetof(UAIUseComponent, InterruptEvent) == 0x0001B0, "Member 'UAIUseComponent::InterruptEvent' has a wrong offset!");
static_assert(offsetof(UAIUseComponent, SuccessEvent) == 0x0001C0, "Member 'UAIUseComponent::SuccessEvent' has a wrong offset!");
static_assert(offsetof(UAIUseComponent, CachedPawn) == 0x0001D0, "Member 'UAIUseComponent::CachedPawn' has a wrong offset!");
static_assert(offsetof(UAIUseComponent, CachedController) == 0x0001D8, "Member 'UAIUseComponent::CachedController' has a wrong offset!");
static_assert(offsetof(UAIUseComponent, CachedActionComponent) == 0x0001E0, "Member 'UAIUseComponent::CachedActionComponent' has a wrong offset!");
static_assert(offsetof(UAIUseComponent, UseState) == 0x0001E8, "Member 'UAIUseComponent::UseState' has a wrong offset!");
static_assert(offsetof(UAIUseComponent, bInitializingAction) == 0x0002A8, "Member 'UAIUseComponent::bInitializingAction' has a wrong offset!");
static_assert(offsetof(UAIUseComponent, GlobalCooldowns) == 0x0002B0, "Member 'UAIUseComponent::GlobalCooldowns' has a wrong offset!");

// Class GbxAI.AIUseSlotComponent
// 0x0060 (0x0750 - 0x06F0)
class UAIUseSlotComponent final : public UPrimitiveComponent
{
public:
	bool                                          bEnabled;                                          // 0x06F0(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bSnapToGround;                                     // 0x06F1(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	ESlotAlignRule                                AlignRule;                                         // 0x06F2(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bInterpOnArrival;                                  // 0x06F3(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bInterpRotationOnArrival;                          // 0x06F4(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_6F5[0x3];                                      // 0x06F5(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         InterpOnArrivalTime;                               // 0x06F8(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	ESmartObjectLookAtRule                        LookAtRule;                                        // 0x06FC(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bOverrideLookAtRule;                               // 0x06FD(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_6FE[0x2];                                      // 0x06FE(0x0002)(Fixing Size After Last Property [ Dumper-7 ])
	class FName                                   LookAtSocket;                                      // 0x0700(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FGameplayTagContainer                  ActionTypes;                                       // 0x0708(0x0020)(Edit, NativeAccessSpecifierPublic)
	float                                         Radius;                                            // 0x0728(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bMaxUsers;                                         // 0x072C(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_72D[0x3];                                      // 0x072D(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	int32                                         MaxUsers;                                          // 0x0730(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bForceUsePhysNoneWithRootMotion;                   // 0x0734(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_735[0x3];                                      // 0x0735(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<class AController*>                    Users;                                             // 0x0738(0x0010)(ZeroConstructor, Transient, NativeAccessSpecifierPrivate)
	uint8                                         Pad_748[0x8];                                      // 0x0748(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void GetAvailableSocketNames(TArray<class FName>* Array) const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"AIUseSlotComponent">();
	}
	static class UAIUseSlotComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UAIUseSlotComponent>();
	}
};
static_assert(alignof(UAIUseSlotComponent) == 0x000008, "Wrong alignment on UAIUseSlotComponent");
static_assert(sizeof(UAIUseSlotComponent) == 0x000750, "Wrong size on UAIUseSlotComponent");
static_assert(offsetof(UAIUseSlotComponent, bEnabled) == 0x0006F0, "Member 'UAIUseSlotComponent::bEnabled' has a wrong offset!");
static_assert(offsetof(UAIUseSlotComponent, bSnapToGround) == 0x0006F1, "Member 'UAIUseSlotComponent::bSnapToGround' has a wrong offset!");
static_assert(offsetof(UAIUseSlotComponent, AlignRule) == 0x0006F2, "Member 'UAIUseSlotComponent::AlignRule' has a wrong offset!");
static_assert(offsetof(UAIUseSlotComponent, bInterpOnArrival) == 0x0006F3, "Member 'UAIUseSlotComponent::bInterpOnArrival' has a wrong offset!");
static_assert(offsetof(UAIUseSlotComponent, bInterpRotationOnArrival) == 0x0006F4, "Member 'UAIUseSlotComponent::bInterpRotationOnArrival' has a wrong offset!");
static_assert(offsetof(UAIUseSlotComponent, InterpOnArrivalTime) == 0x0006F8, "Member 'UAIUseSlotComponent::InterpOnArrivalTime' has a wrong offset!");
static_assert(offsetof(UAIUseSlotComponent, LookAtRule) == 0x0006FC, "Member 'UAIUseSlotComponent::LookAtRule' has a wrong offset!");
static_assert(offsetof(UAIUseSlotComponent, bOverrideLookAtRule) == 0x0006FD, "Member 'UAIUseSlotComponent::bOverrideLookAtRule' has a wrong offset!");
static_assert(offsetof(UAIUseSlotComponent, LookAtSocket) == 0x000700, "Member 'UAIUseSlotComponent::LookAtSocket' has a wrong offset!");
static_assert(offsetof(UAIUseSlotComponent, ActionTypes) == 0x000708, "Member 'UAIUseSlotComponent::ActionTypes' has a wrong offset!");
static_assert(offsetof(UAIUseSlotComponent, Radius) == 0x000728, "Member 'UAIUseSlotComponent::Radius' has a wrong offset!");
static_assert(offsetof(UAIUseSlotComponent, bMaxUsers) == 0x00072C, "Member 'UAIUseSlotComponent::bMaxUsers' has a wrong offset!");
static_assert(offsetof(UAIUseSlotComponent, MaxUsers) == 0x000730, "Member 'UAIUseSlotComponent::MaxUsers' has a wrong offset!");
static_assert(offsetof(UAIUseSlotComponent, bForceUsePhysNoneWithRootMotion) == 0x000734, "Member 'UAIUseSlotComponent::bForceUsePhysNoneWithRootMotion' has a wrong offset!");
static_assert(offsetof(UAIUseSlotComponent, Users) == 0x000738, "Member 'UAIUseSlotComponent::Users' has a wrong offset!");

// Class GbxAI.EnvQueryTest_TargetIsHurtingMe
// 0x0008 (0x01E0 - 0x01D8)
class UEnvQueryTest_TargetIsHurtingMe final : public UEnvQueryTest
{
public:
	float                                         DecayRate;                                         // 0x01D8(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_1DC[0x4];                                      // 0x01DC(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"EnvQueryTest_TargetIsHurtingMe">();
	}
	static class UEnvQueryTest_TargetIsHurtingMe* GetDefaultObj()
	{
		return GetDefaultObjImpl<UEnvQueryTest_TargetIsHurtingMe>();
	}
};
static_assert(alignof(UEnvQueryTest_TargetIsHurtingMe) == 0x000008, "Wrong alignment on UEnvQueryTest_TargetIsHurtingMe");
static_assert(sizeof(UEnvQueryTest_TargetIsHurtingMe) == 0x0001E0, "Wrong size on UEnvQueryTest_TargetIsHurtingMe");
static_assert(offsetof(UEnvQueryTest_TargetIsHurtingMe, DecayRate) == 0x0001D8, "Member 'UEnvQueryTest_TargetIsHurtingMe::DecayRate' has a wrong offset!");

// Class GbxAI.AIWeaponUserComponent
// 0x0738 (0x08B0 - 0x0178)
class UAIWeaponUserComponent : public UActorComponent
{
public:
	uint8                                         Pad_178[0x8];                                      // 0x0178(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	UMulticastDelegateProperty_                   ReloadEvent;                                       // 0x0180(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPrivate)
	UMulticastDelegateProperty_                   BeginFiringEvent;                                  // 0x0190(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPrivate)
	class AGbxAIController*                       AIController;                                      // 0x01A0(0x0008)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class AGbxCharacter*                          GbxCharacter;                                      // 0x01A8(0x0008)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_1B0[0x10];                                     // 0x01B0(0x0010)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         FireConeAngle;                                     // 0x01C0(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_1C4[0x2C];                                     // 0x01C4(0x002C)(Fixing Size After Last Property [ Dumper-7 ])
	TScriptInterface<class IWeaponUserInterface>  WeaponUser;                                        // 0x01F0(0x0010)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, UObjectWrapper, NativeAccessSpecifierPrivate)
	TScriptInterface<class IWeaponInterface>      Weapon;                                            // 0x0200(0x0010)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, UObjectWrapper, NativeAccessSpecifierPrivate)
	class UDamageComponent*                       DamageComponent;                                   // 0x0210(0x0008)(ExportObject, ZeroConstructor, Transient, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UCoverUserComponent*                    CoverUserComponent;                                // 0x0218(0x0008)(ExportObject, ZeroConstructor, Transient, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UBlackboardComponent*                   BlackboardComponent;                               // 0x0220(0x0008)(ExportObject, ZeroConstructor, Transient, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UAIPerceptionComponent*                 PerceptionComponent;                               // 0x0228(0x0008)(ExportObject, ZeroConstructor, Transient, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UTargetingComponent*                    TargetingComponent;                                // 0x0230(0x0008)(ExportObject, ZeroConstructor, Transient, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UGbxCondition*                          CanFireIf;                                         // 0x0238(0x0008)(Edit, ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, PersistentInstance, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	struct FAIWeaponUseSettings                   Settings;                                          // 0x0240(0x0238)(Edit, NoDestructor, ContainsInstancedReference, NativeAccessSpecifierPrivate)
	struct FAIWeaponUseSettings                   SettingsOverride;                                  // 0x0478(0x0238)(NoDestructor, ContainsInstancedReference, NativeAccessSpecifierPrivate)
	bool                                          bSuppressingFireTimeExpired;                       // 0x06B0(0x0001)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_6B1[0x7];                                      // 0x06B1(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	struct FGbxParam                              BurstCountOverride;                                // 0x06B8(0x0080)(NoDestructor, ContainsInstancedReference, NativeAccessSpecifierPrivate)
	bool                                          bOverrideBurstCount;                               // 0x0738(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_739[0x7];                                      // 0x0739(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	struct FGbxParam                              BurstDelayOverride;                                // 0x0740(0x0080)(NoDestructor, ContainsInstancedReference, NativeAccessSpecifierPrivate)
	bool                                          bOverrideBurstDelay;                               // 0x07C0(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_7C1[0x7];                                      // 0x07C1(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	struct FGbxParam                              AccuracyOverride;                                  // 0x07C8(0x0080)(NoDestructor, ContainsInstancedReference, NativeAccessSpecifierPrivate)
	bool                                          bOverrideAccuracy;                                 // 0x0848(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_849[0x3];                                      // 0x0849(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	struct FNumericRange                          DesiredRangeOverride;                              // 0x084C(0x0008)(NoDestructor, NativeAccessSpecifierPrivate)
	bool                                          bOverrideDesiredRange;                             // 0x0854(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_855[0x5B];                                     // 0x0855(0x005B)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void OnWeaponUsed();

	bool WantsToFire() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"AIWeaponUserComponent">();
	}
	static class UAIWeaponUserComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UAIWeaponUserComponent>();
	}
};
static_assert(alignof(UAIWeaponUserComponent) == 0x000008, "Wrong alignment on UAIWeaponUserComponent");
static_assert(sizeof(UAIWeaponUserComponent) == 0x0008B0, "Wrong size on UAIWeaponUserComponent");
static_assert(offsetof(UAIWeaponUserComponent, ReloadEvent) == 0x000180, "Member 'UAIWeaponUserComponent::ReloadEvent' has a wrong offset!");
static_assert(offsetof(UAIWeaponUserComponent, BeginFiringEvent) == 0x000190, "Member 'UAIWeaponUserComponent::BeginFiringEvent' has a wrong offset!");
static_assert(offsetof(UAIWeaponUserComponent, AIController) == 0x0001A0, "Member 'UAIWeaponUserComponent::AIController' has a wrong offset!");
static_assert(offsetof(UAIWeaponUserComponent, GbxCharacter) == 0x0001A8, "Member 'UAIWeaponUserComponent::GbxCharacter' has a wrong offset!");
static_assert(offsetof(UAIWeaponUserComponent, FireConeAngle) == 0x0001C0, "Member 'UAIWeaponUserComponent::FireConeAngle' has a wrong offset!");
static_assert(offsetof(UAIWeaponUserComponent, WeaponUser) == 0x0001F0, "Member 'UAIWeaponUserComponent::WeaponUser' has a wrong offset!");
static_assert(offsetof(UAIWeaponUserComponent, Weapon) == 0x000200, "Member 'UAIWeaponUserComponent::Weapon' has a wrong offset!");
static_assert(offsetof(UAIWeaponUserComponent, DamageComponent) == 0x000210, "Member 'UAIWeaponUserComponent::DamageComponent' has a wrong offset!");
static_assert(offsetof(UAIWeaponUserComponent, CoverUserComponent) == 0x000218, "Member 'UAIWeaponUserComponent::CoverUserComponent' has a wrong offset!");
static_assert(offsetof(UAIWeaponUserComponent, BlackboardComponent) == 0x000220, "Member 'UAIWeaponUserComponent::BlackboardComponent' has a wrong offset!");
static_assert(offsetof(UAIWeaponUserComponent, PerceptionComponent) == 0x000228, "Member 'UAIWeaponUserComponent::PerceptionComponent' has a wrong offset!");
static_assert(offsetof(UAIWeaponUserComponent, TargetingComponent) == 0x000230, "Member 'UAIWeaponUserComponent::TargetingComponent' has a wrong offset!");
static_assert(offsetof(UAIWeaponUserComponent, CanFireIf) == 0x000238, "Member 'UAIWeaponUserComponent::CanFireIf' has a wrong offset!");
static_assert(offsetof(UAIWeaponUserComponent, Settings) == 0x000240, "Member 'UAIWeaponUserComponent::Settings' has a wrong offset!");
static_assert(offsetof(UAIWeaponUserComponent, SettingsOverride) == 0x000478, "Member 'UAIWeaponUserComponent::SettingsOverride' has a wrong offset!");
static_assert(offsetof(UAIWeaponUserComponent, bSuppressingFireTimeExpired) == 0x0006B0, "Member 'UAIWeaponUserComponent::bSuppressingFireTimeExpired' has a wrong offset!");
static_assert(offsetof(UAIWeaponUserComponent, BurstCountOverride) == 0x0006B8, "Member 'UAIWeaponUserComponent::BurstCountOverride' has a wrong offset!");
static_assert(offsetof(UAIWeaponUserComponent, bOverrideBurstCount) == 0x000738, "Member 'UAIWeaponUserComponent::bOverrideBurstCount' has a wrong offset!");
static_assert(offsetof(UAIWeaponUserComponent, BurstDelayOverride) == 0x000740, "Member 'UAIWeaponUserComponent::BurstDelayOverride' has a wrong offset!");
static_assert(offsetof(UAIWeaponUserComponent, bOverrideBurstDelay) == 0x0007C0, "Member 'UAIWeaponUserComponent::bOverrideBurstDelay' has a wrong offset!");
static_assert(offsetof(UAIWeaponUserComponent, AccuracyOverride) == 0x0007C8, "Member 'UAIWeaponUserComponent::AccuracyOverride' has a wrong offset!");
static_assert(offsetof(UAIWeaponUserComponent, bOverrideAccuracy) == 0x000848, "Member 'UAIWeaponUserComponent::bOverrideAccuracy' has a wrong offset!");
static_assert(offsetof(UAIWeaponUserComponent, DesiredRangeOverride) == 0x00084C, "Member 'UAIWeaponUserComponent::DesiredRangeOverride' has a wrong offset!");
static_assert(offsetof(UAIWeaponUserComponent, bOverrideDesiredRange) == 0x000854, "Member 'UAIWeaponUserComponent::bOverrideDesiredRange' has a wrong offset!");

// Class GbxAI.AnimNotify_SmartObject
// 0x0008 (0x0038 - 0x0030)
class UAnimNotify_SmartObject final : public UAnimNotifyState
{
public:
	ESmartObjectNotify                            Action;                                            // 0x0030(0x0001)(Edit, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_31[0x7];                                       // 0x0031(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"AnimNotify_SmartObject">();
	}
	static class UAnimNotify_SmartObject* GetDefaultObj()
	{
		return GetDefaultObjImpl<UAnimNotify_SmartObject>();
	}
};
static_assert(alignof(UAnimNotify_SmartObject) == 0x000008, "Wrong alignment on UAnimNotify_SmartObject");
static_assert(sizeof(UAnimNotify_SmartObject) == 0x000038, "Wrong size on UAnimNotify_SmartObject");
static_assert(offsetof(UAnimNotify_SmartObject, Action) == 0x000030, "Member 'UAnimNotify_SmartObject::Action' has a wrong offset!");

// Class GbxAI.AnimNotify_UseSmartAction
// 0x0000 (0x0038 - 0x0038)
class UAnimNotify_UseSmartAction final : public UAnimNotify
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"AnimNotify_UseSmartAction">();
	}
	static class UAnimNotify_UseSmartAction* GetDefaultObj()
	{
		return GetDefaultObjImpl<UAnimNotify_UseSmartAction>();
	}
};
static_assert(alignof(UAnimNotify_UseSmartAction) == 0x000008, "Wrong alignment on UAnimNotify_UseSmartAction");
static_assert(sizeof(UAnimNotify_UseSmartAction) == 0x000038, "Wrong size on UAnimNotify_UseSmartAction");

// Class GbxAI.EnvQueryTest_WithinTerritory
// 0x0008 (0x01E0 - 0x01D8)
class UEnvQueryTest_WithinTerritory final : public UEnvQueryTest
{
public:
	ETerritoryType                                TerritoryArea;                                     // 0x01D8(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1D9[0x7];                                      // 0x01D9(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"EnvQueryTest_WithinTerritory">();
	}
	static class UEnvQueryTest_WithinTerritory* GetDefaultObj()
	{
		return GetDefaultObjImpl<UEnvQueryTest_WithinTerritory>();
	}
};
static_assert(alignof(UEnvQueryTest_WithinTerritory) == 0x000008, "Wrong alignment on UEnvQueryTest_WithinTerritory");
static_assert(sizeof(UEnvQueryTest_WithinTerritory) == 0x0001E0, "Wrong size on UEnvQueryTest_WithinTerritory");
static_assert(offsetof(UEnvQueryTest_WithinTerritory, TerritoryArea) == 0x0001D8, "Member 'UEnvQueryTest_WithinTerritory::TerritoryArea' has a wrong offset!");

// Class GbxAI.BlackboardKeyType_SmartAction
// 0x0000 (0x0030 - 0x0030)
class UBlackboardKeyType_SmartAction final : public UBlackboardKeyType
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"BlackboardKeyType_SmartAction">();
	}
	static class UBlackboardKeyType_SmartAction* GetDefaultObj()
	{
		return GetDefaultObjImpl<UBlackboardKeyType_SmartAction>();
	}
};
static_assert(alignof(UBlackboardKeyType_SmartAction) == 0x000008, "Wrong alignment on UBlackboardKeyType_SmartAction");
static_assert(sizeof(UBlackboardKeyType_SmartAction) == 0x000030, "Wrong size on UBlackboardKeyType_SmartAction");

// Class GbxAI.BTComposite_Random
// 0x0010 (0x00A0 - 0x0090)
class UBTComposite_Random final : public UBTComposite_Selector
{
public:
	TArray<struct FBTRandomEntrySettings>         Entries;                                           // 0x0090(0x0010)(Edit, EditFixedSize, ZeroConstructor, NoClear, ContainsInstancedReference, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"BTComposite_Random">();
	}
	static class UBTComposite_Random* GetDefaultObj()
	{
		return GetDefaultObjImpl<UBTComposite_Random>();
	}
};
static_assert(alignof(UBTComposite_Random) == 0x000008, "Wrong alignment on UBTComposite_Random");
static_assert(sizeof(UBTComposite_Random) == 0x0000A0, "Wrong size on UBTComposite_Random");
static_assert(offsetof(UBTComposite_Random, Entries) == 0x000090, "Member 'UBTComposite_Random::Entries' has a wrong offset!");

// Class GbxAI.GbxCondition_AI_IsInRange
// 0x0098 (0x0120 - 0x0088)
class UGbxCondition_AI_IsInRange final : public UGbxCondition
{
public:
	struct FGbxBlackboardKeySelector              Target;                                            // 0x0088(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, NoDestructor, NativeAccessSpecifierPublic)
	struct FGbxParam                              Range;                                             // 0x0098(0x0080)(Edit, BlueprintVisible, BlueprintReadOnly, NoDestructor, ContainsInstancedReference, NativeAccessSpecifierPublic)
	bool                                          bInvertRange;                                      // 0x0118(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_119[0x7];                                      // 0x0119(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"GbxCondition_AI_IsInRange">();
	}
	static class UGbxCondition_AI_IsInRange* GetDefaultObj()
	{
		return GetDefaultObjImpl<UGbxCondition_AI_IsInRange>();
	}
};
static_assert(alignof(UGbxCondition_AI_IsInRange) == 0x000008, "Wrong alignment on UGbxCondition_AI_IsInRange");
static_assert(sizeof(UGbxCondition_AI_IsInRange) == 0x000120, "Wrong size on UGbxCondition_AI_IsInRange");
static_assert(offsetof(UGbxCondition_AI_IsInRange, Target) == 0x000088, "Member 'UGbxCondition_AI_IsInRange::Target' has a wrong offset!");
static_assert(offsetof(UGbxCondition_AI_IsInRange, Range) == 0x000098, "Member 'UGbxCondition_AI_IsInRange::Range' has a wrong offset!");
static_assert(offsetof(UGbxCondition_AI_IsInRange, bInvertRange) == 0x000118, "Member 'UGbxCondition_AI_IsInRange::bInvertRange' has a wrong offset!");

// Class GbxAI.BTDecorator_AIAction
// 0x0000 (0x0068 - 0x0068)
class UBTDecorator_AIAction final : public UBTDecorator
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"BTDecorator_AIAction">();
	}
	static class UBTDecorator_AIAction* GetDefaultObj()
	{
		return GetDefaultObjImpl<UBTDecorator_AIAction>();
	}
};
static_assert(alignof(UBTDecorator_AIAction) == 0x000008, "Wrong alignment on UBTDecorator_AIAction");
static_assert(sizeof(UBTDecorator_AIAction) == 0x000068, "Wrong size on UBTDecorator_AIAction");

// Class GbxAI.UBTDecorator_AITicket
// 0x0000 (0x0068 - 0x0068)
class UUBTDecorator_AITicket final : public UBTDecorator
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"UBTDecorator_AITicket">();
	}
	static class UUBTDecorator_AITicket* GetDefaultObj()
	{
		return GetDefaultObjImpl<UUBTDecorator_AITicket>();
	}
};
static_assert(alignof(UUBTDecorator_AITicket) == 0x000008, "Wrong alignment on UUBTDecorator_AITicket");
static_assert(sizeof(UUBTDecorator_AITicket) == 0x000068, "Wrong size on UUBTDecorator_AITicket");

// Class GbxAI.BTDecorator_GbxLoop
// 0x0128 (0x0190 - 0x0068)
class UBTDecorator_GbxLoop final : public UBTDecorator
{
public:
	struct FGbxParam                              LoopCount;                                         // 0x0068(0x0080)(Edit, NoDestructor, ContainsInstancedReference, NativeAccessSpecifierPublic)
	bool                                          bUseLoopCount;                                     // 0x00E8(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_E9[0x7];                                       // 0x00E9(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	struct FGbxParam                              LoopTime;                                          // 0x00F0(0x0080)(Edit, NoDestructor, ContainsInstancedReference, NativeAccessSpecifierPublic)
	bool                                          bUseLoopTime;                                      // 0x0170(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_171[0x7];                                      // 0x0171(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	struct FBTGbxLoopConditionData                LoopCondition;                                     // 0x0178(0x0010)(Edit, IsPlainOldData, NoDestructor, ContainsInstancedReference, NativeAccessSpecifierPublic)
	bool                                          bUseLoopCondition;                                 // 0x0188(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_189[0x7];                                      // 0x0189(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"BTDecorator_GbxLoop">();
	}
	static class UBTDecorator_GbxLoop* GetDefaultObj()
	{
		return GetDefaultObjImpl<UBTDecorator_GbxLoop>();
	}
};
static_assert(alignof(UBTDecorator_GbxLoop) == 0x000008, "Wrong alignment on UBTDecorator_GbxLoop");
static_assert(sizeof(UBTDecorator_GbxLoop) == 0x000190, "Wrong size on UBTDecorator_GbxLoop");
static_assert(offsetof(UBTDecorator_GbxLoop, LoopCount) == 0x000068, "Member 'UBTDecorator_GbxLoop::LoopCount' has a wrong offset!");
static_assert(offsetof(UBTDecorator_GbxLoop, bUseLoopCount) == 0x0000E8, "Member 'UBTDecorator_GbxLoop::bUseLoopCount' has a wrong offset!");
static_assert(offsetof(UBTDecorator_GbxLoop, LoopTime) == 0x0000F0, "Member 'UBTDecorator_GbxLoop::LoopTime' has a wrong offset!");
static_assert(offsetof(UBTDecorator_GbxLoop, bUseLoopTime) == 0x000170, "Member 'UBTDecorator_GbxLoop::bUseLoopTime' has a wrong offset!");
static_assert(offsetof(UBTDecorator_GbxLoop, LoopCondition) == 0x000178, "Member 'UBTDecorator_GbxLoop::LoopCondition' has a wrong offset!");
static_assert(offsetof(UBTDecorator_GbxLoop, bUseLoopCondition) == 0x000188, "Member 'UBTDecorator_GbxLoop::bUseLoopCondition' has a wrong offset!");

// Class GbxAI.BTDecorator_IsInRange
// 0x0080 (0x0110 - 0x0090)
class UBTDecorator_IsInRange final : public UBTDecorator_BlackboardBase
{
public:
	struct FGbxParam                              Range;                                             // 0x0090(0x0080)(Edit, NoDestructor, ContainsInstancedReference, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"BTDecorator_IsInRange">();
	}
	static class UBTDecorator_IsInRange* GetDefaultObj()
	{
		return GetDefaultObjImpl<UBTDecorator_IsInRange>();
	}
};
static_assert(alignof(UBTDecorator_IsInRange) == 0x000008, "Wrong alignment on UBTDecorator_IsInRange");
static_assert(sizeof(UBTDecorator_IsInRange) == 0x000110, "Wrong size on UBTDecorator_IsInRange");
static_assert(offsetof(UBTDecorator_IsInRange, Range) == 0x000090, "Member 'UBTDecorator_IsInRange::Range' has a wrong offset!");

// Class GbxAI.BTService_GameFocus
// 0x0000 (0x00A0 - 0x00A0)
class UBTService_GameFocus final : public UBTService_DefaultFocus
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"BTService_GameFocus">();
	}
	static class UBTService_GameFocus* GetDefaultObj()
	{
		return GetDefaultObjImpl<UBTService_GameFocus>();
	}
};
static_assert(alignof(UBTService_GameFocus) == 0x000008, "Wrong alignment on UBTService_GameFocus");
static_assert(sizeof(UBTService_GameFocus) == 0x0000A0, "Wrong size on UBTService_GameFocus");

// Class GbxAI.BTService_GbxRunEQS
// 0x0000 (0x00F8 - 0x00F8)
class UBTService_GbxRunEQS final : public UBTService_RunEQS
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"BTService_GbxRunEQS">();
	}
	static class UBTService_GbxRunEQS* GetDefaultObj()
	{
		return GetDefaultObjImpl<UBTService_GbxRunEQS>();
	}
};
static_assert(alignof(UBTService_GbxRunEQS) == 0x000008, "Wrong alignment on UBTService_GbxRunEQS");
static_assert(sizeof(UBTService_GbxRunEQS) == 0x0000F8, "Wrong size on UBTService_GbxRunEQS");

// Class GbxAI.BTTask_LookAt
// 0x0058 (0x00C8 - 0x0070)
class UBTTask_LookAt final : public UBTTaskNode
{
public:
	float                                         AngleThresholdDegrees;                             // 0x0070(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_74[0x4];                                       // 0x0074(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	struct FBlackboardKeySelector                 TargetActorKey;                                    // 0x0078(0x0028)(Edit, NativeAccessSpecifierPrivate)
	struct FBlackboardKeySelector                 TurnSpeedKey;                                      // 0x00A0(0x0028)(Edit, NativeAccessSpecifierPrivate)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"BTTask_LookAt">();
	}
	static class UBTTask_LookAt* GetDefaultObj()
	{
		return GetDefaultObjImpl<UBTTask_LookAt>();
	}
};
static_assert(alignof(UBTTask_LookAt) == 0x000008, "Wrong alignment on UBTTask_LookAt");
static_assert(sizeof(UBTTask_LookAt) == 0x0000C8, "Wrong size on UBTTask_LookAt");
static_assert(offsetof(UBTTask_LookAt, AngleThresholdDegrees) == 0x000070, "Member 'UBTTask_LookAt::AngleThresholdDegrees' has a wrong offset!");
static_assert(offsetof(UBTTask_LookAt, TargetActorKey) == 0x000078, "Member 'UBTTask_LookAt::TargetActorKey' has a wrong offset!");
static_assert(offsetof(UBTTask_LookAt, TurnSpeedKey) == 0x0000A0, "Member 'UBTTask_LookAt::TurnSpeedKey' has a wrong offset!");

// Class GbxAI.BTTask_MoveToComponent
// 0x0008 (0x00A0 - 0x0098)
class UBTTask_MoveToComponent final : public UBTTask_BlackboardBase
{
public:
	float                                         AcceptableRadius;                                  // 0x0098(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	bool                                          bAllowStrafe;                                      // 0x009C(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	bool                                          bStopOnOverlap;                                    // 0x009D(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	bool                                          bAllowPartialPath;                                 // 0x009E(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, AdvancedDisplay, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	bool                                          bProjectGoalLocation;                              // 0x009F(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, AdvancedDisplay, HasGetValueTypeHash, NativeAccessSpecifierPrivate)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"BTTask_MoveToComponent">();
	}
	static class UBTTask_MoveToComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UBTTask_MoveToComponent>();
	}
};
static_assert(alignof(UBTTask_MoveToComponent) == 0x000008, "Wrong alignment on UBTTask_MoveToComponent");
static_assert(sizeof(UBTTask_MoveToComponent) == 0x0000A0, "Wrong size on UBTTask_MoveToComponent");
static_assert(offsetof(UBTTask_MoveToComponent, AcceptableRadius) == 0x000098, "Member 'UBTTask_MoveToComponent::AcceptableRadius' has a wrong offset!");
static_assert(offsetof(UBTTask_MoveToComponent, bAllowStrafe) == 0x00009C, "Member 'UBTTask_MoveToComponent::bAllowStrafe' has a wrong offset!");
static_assert(offsetof(UBTTask_MoveToComponent, bStopOnOverlap) == 0x00009D, "Member 'UBTTask_MoveToComponent::bStopOnOverlap' has a wrong offset!");
static_assert(offsetof(UBTTask_MoveToComponent, bAllowPartialPath) == 0x00009E, "Member 'UBTTask_MoveToComponent::bAllowPartialPath' has a wrong offset!");
static_assert(offsetof(UBTTask_MoveToComponent, bProjectGoalLocation) == 0x00009F, "Member 'UBTTask_MoveToComponent::bProjectGoalLocation' has a wrong offset!");

// Class GbxAI.BTTask_MoveToNode
// 0x0000 (0x00B0 - 0x00B0)
class UBTTask_MoveToNode final : public UBTTask_MoveTo
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"BTTask_MoveToNode">();
	}
	static class UBTTask_MoveToNode* GetDefaultObj()
	{
		return GetDefaultObjImpl<UBTTask_MoveToNode>();
	}
};
static_assert(alignof(UBTTask_MoveToNode) == 0x000008, "Wrong alignment on UBTTask_MoveToNode");
static_assert(sizeof(UBTTask_MoveToNode) == 0x0000B0, "Wrong size on UBTTask_MoveToNode");

// Class GbxAI.BTTask_UseSmartObject
// 0x0000 (0x0070 - 0x0070)
class UBTTask_UseSmartObject final : public UBTTaskNode
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"BTTask_UseSmartObject">();
	}
	static class UBTTask_UseSmartObject* GetDefaultObj()
	{
		return GetDefaultObjImpl<UBTTask_UseSmartObject>();
	}
};
static_assert(alignof(UBTTask_UseSmartObject) == 0x000008, "Wrong alignment on UBTTask_UseSmartObject");
static_assert(sizeof(UBTTask_UseSmartObject) == 0x000070, "Wrong size on UBTTask_UseSmartObject");

// Class GbxAI.CoverSlotComponent
// 0x0150 (0x0840 - 0x06F0)
class UCoverSlotComponent final : public UPrimitiveComponent
{
public:
	class UCoverSlotData*                         SlotType;                                          // 0x06F0(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	bool                                          bEnabled;                                          // 0x06F8(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	bool                                          bAutoDetect;                                       // 0x06F9(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	bool                                          bValid;                                            // 0x06FA(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_6FB[0x5];                                      // 0x06FB(0x0005)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<struct FCoverSlotViewData>             Views;                                             // 0x0700(0x0010)(Edit, ZeroConstructor, NativeAccessSpecifierPrivate)
	TArray<struct FCoverSlotViewFailData>         FailedViews;                                       // 0x0710(0x0010)(Edit, ZeroConstructor, EditConst, NativeAccessSpecifierPrivate)
	ECoverSlotHeight                              SlotHeight;                                        // 0x0720(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_721[0x7];                                      // 0x0721(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<class UCoverSlotComponent*>            OverlappingSlots;                                  // 0x0728(0x0010)(Edit, ExportObject, ZeroConstructor, EditConst, ContainsInstancedReference, NativeAccessSpecifierPrivate)
	uint8                                         Pad_738[0x8];                                      // 0x0738(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	struct FCoverLineOfSightData                  ExposedLosData;                                    // 0x0740(0x00B0)(NativeAccessSpecifierPrivate)
	class APawn*                                  SlotOwnerUsing;                                    // 0x07F0(0x0008)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class APawn*                                  SlotOwnerClaimed;                                  // 0x07F8(0x0008)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_800[0x40];                                     // 0x0800(0x0040)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void SetEnabled(bool bNewEnabled);

	bool IsEnabled() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"CoverSlotComponent">();
	}
	static class UCoverSlotComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UCoverSlotComponent>();
	}
};
static_assert(alignof(UCoverSlotComponent) == 0x000010, "Wrong alignment on UCoverSlotComponent");
static_assert(sizeof(UCoverSlotComponent) == 0x000840, "Wrong size on UCoverSlotComponent");
static_assert(offsetof(UCoverSlotComponent, SlotType) == 0x0006F0, "Member 'UCoverSlotComponent::SlotType' has a wrong offset!");
static_assert(offsetof(UCoverSlotComponent, bEnabled) == 0x0006F8, "Member 'UCoverSlotComponent::bEnabled' has a wrong offset!");
static_assert(offsetof(UCoverSlotComponent, bAutoDetect) == 0x0006F9, "Member 'UCoverSlotComponent::bAutoDetect' has a wrong offset!");
static_assert(offsetof(UCoverSlotComponent, bValid) == 0x0006FA, "Member 'UCoverSlotComponent::bValid' has a wrong offset!");
static_assert(offsetof(UCoverSlotComponent, Views) == 0x000700, "Member 'UCoverSlotComponent::Views' has a wrong offset!");
static_assert(offsetof(UCoverSlotComponent, FailedViews) == 0x000710, "Member 'UCoverSlotComponent::FailedViews' has a wrong offset!");
static_assert(offsetof(UCoverSlotComponent, SlotHeight) == 0x000720, "Member 'UCoverSlotComponent::SlotHeight' has a wrong offset!");
static_assert(offsetof(UCoverSlotComponent, OverlappingSlots) == 0x000728, "Member 'UCoverSlotComponent::OverlappingSlots' has a wrong offset!");
static_assert(offsetof(UCoverSlotComponent, ExposedLosData) == 0x000740, "Member 'UCoverSlotComponent::ExposedLosData' has a wrong offset!");
static_assert(offsetof(UCoverSlotComponent, SlotOwnerUsing) == 0x0007F0, "Member 'UCoverSlotComponent::SlotOwnerUsing' has a wrong offset!");
static_assert(offsetof(UCoverSlotComponent, SlotOwnerClaimed) == 0x0007F8, "Member 'UCoverSlotComponent::SlotOwnerClaimed' has a wrong offset!");

// Class GbxAI.CoverStyleData
// 0x0018 (0x0048 - 0x0030)
class UCoverStyleData final : public UGbxDataAsset
{
public:
	ECoverStyleAnimType                           AnimType;                                          // 0x0030(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_31[0x7];                                       // 0x0031(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	class UCoverViewData*                         View;                                              // 0x0038(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, NoClear, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bAllowLookAts;                                     // 0x0040(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bAllowAimOffsets;                                  // 0x0041(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bForceFiring;                                      // 0x0042(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_43[0x5];                                       // 0x0043(0x0005)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"CoverStyleData">();
	}
	static class UCoverStyleData* GetDefaultObj()
	{
		return GetDefaultObjImpl<UCoverStyleData>();
	}
};
static_assert(alignof(UCoverStyleData) == 0x000008, "Wrong alignment on UCoverStyleData");
static_assert(sizeof(UCoverStyleData) == 0x000048, "Wrong size on UCoverStyleData");
static_assert(offsetof(UCoverStyleData, AnimType) == 0x000030, "Member 'UCoverStyleData::AnimType' has a wrong offset!");
static_assert(offsetof(UCoverStyleData, View) == 0x000038, "Member 'UCoverStyleData::View' has a wrong offset!");
static_assert(offsetof(UCoverStyleData, bAllowLookAts) == 0x000040, "Member 'UCoverStyleData::bAllowLookAts' has a wrong offset!");
static_assert(offsetof(UCoverStyleData, bAllowAimOffsets) == 0x000041, "Member 'UCoverStyleData::bAllowAimOffsets' has a wrong offset!");
static_assert(offsetof(UCoverStyleData, bForceFiring) == 0x000042, "Member 'UCoverStyleData::bForceFiring' has a wrong offset!");

// Class GbxAI.GbxCoverTransitionTable
// 0x0060 (0x00A8 - 0x0048)
class UGbxCoverTransitionTable final : public UGbxAnimTable
{
public:
	class UGbxAnimSet*                            AnimSet;                                           // 0x0048(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	struct FCoverTransitionFilters                Filters;                                           // 0x0050(0x0050)(Edit, NativeAccessSpecifierPrivate)
	float                                         DefaultHeight;                                     // 0x00A0(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_A4[0x4];                                       // 0x00A4(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"GbxCoverTransitionTable">();
	}
	static class UGbxCoverTransitionTable* GetDefaultObj()
	{
		return GetDefaultObjImpl<UGbxCoverTransitionTable>();
	}
};
static_assert(alignof(UGbxCoverTransitionTable) == 0x000008, "Wrong alignment on UGbxCoverTransitionTable");
static_assert(sizeof(UGbxCoverTransitionTable) == 0x0000A8, "Wrong size on UGbxCoverTransitionTable");
static_assert(offsetof(UGbxCoverTransitionTable, AnimSet) == 0x000048, "Member 'UGbxCoverTransitionTable::AnimSet' has a wrong offset!");
static_assert(offsetof(UGbxCoverTransitionTable, Filters) == 0x000050, "Member 'UGbxCoverTransitionTable::Filters' has a wrong offset!");
static_assert(offsetof(UGbxCoverTransitionTable, DefaultHeight) == 0x0000A0, "Member 'UGbxCoverTransitionTable::DefaultHeight' has a wrong offset!");

// Class GbxAI.CoverUserComponent
// 0x0798 (0x0910 - 0x0178)
class UCoverUserComponent final : public UActorComponent
{
public:
	uint8                                         Pad_178[0x8];                                      // 0x0178(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	UMulticastDelegateProperty_                   OnCoverStateChanged;                               // 0x0180(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	uint8                                         Pad_190[0x50];                                     // 0x0190(0x0050)(Fixing Size After Last Property [ Dumper-7 ])
	struct FCoverAction                           DesiredAction;                                     // 0x01E0(0x0130)(Transient, NoDestructor, ContainsInstancedReference, NativeAccessSpecifierPrivate)
	struct FCoverAction                           CurrentAction;                                     // 0x0310(0x0130)(Transient, NoDestructor, ContainsInstancedReference, NativeAccessSpecifierPrivate)
	struct FCoverAction                           PreviousAction;                                    // 0x0440(0x0130)(Transient, NoDestructor, ContainsInstancedReference, NativeAccessSpecifierPrivate)
	ECoverUserState                               State;                                             // 0x0570(0x0001)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	ECoverUserState                               DesiredState;                                      // 0x0571(0x0001)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_572[0x6];                                      // 0x0572(0x0006)(Fixing Size After Last Property [ Dumper-7 ])
	class FName                                   TransitionName;                                    // 0x0578(0x0008)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class USkeletalMeshComponent*                 SkelMeshComponent;                                 // 0x0580(0x0008)(ExportObject, ZeroConstructor, Transient, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class AGbxCharacter*                          GbxCharacter;                                      // 0x0588(0x0008)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class AGbxAIController*                       GbxAIController;                                   // 0x0590(0x0008)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UDamageComponent*                       DamageComponent;                                   // 0x0598(0x0008)(ExportObject, ZeroConstructor, Transient, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UGbxNavComponent*                       GbxNavComponent;                                   // 0x05A0(0x0008)(ExportObject, ZeroConstructor, Transient, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UStanceComponent*                       StanceComponent;                                   // 0x05A8(0x0008)(ExportObject, ZeroConstructor, Transient, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UTargetingComponent*                    TargetingComponent;                                // 0x05B0(0x0008)(ExportObject, ZeroConstructor, Transient, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UAIWeaponUserComponent*                 WeaponUserComponent;                               // 0x05B8(0x0008)(ExportObject, ZeroConstructor, Transient, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UGbxNavCharacterMovementComponent*      MovementComponent;                                 // 0x05C0(0x0008)(ExportObject, ZeroConstructor, Transient, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	struct FSavedCollision                        SavedCollision;                                    // 0x05C8(0x0020)(Transient, ContainsInstancedReference, NativeAccessSpecifierPrivate)
	uint8                                         Pad_5E8[0x8];                                      // 0x05E8(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	struct FCoverClientData                       ClientData;                                        // 0x05F0(0x0028)(Net, Transient, RepNotify, NoDestructor, ContainsInstancedReference, NativeAccessSpecifierPrivate)
	bool                                          bFlanked;                                          // 0x0618(0x0001)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_619[0x3];                                      // 0x0619(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         MaxVerticalNavDistance;                            // 0x061C(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	float                                         MaxHorizontalNavDistance;                          // 0x0620(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	float                                         MaxDeltaLocationThreshold;                         // 0x0624(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	float                                         MaxDeltaRotationThreshold;                         // 0x0628(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	float                                         ExitInterpSearchDistance;                          // 0x062C(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	float                                         TransitionBetweenTraceHeight;                      // 0x0630(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	float                                         WidthAdjustment;                                   // 0x0634(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	float                                         HeightAdjustment;                                  // 0x0638(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	bool                                          bDisableFootIk;                                    // 0x063C(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_63D[0x3];                                      // 0x063D(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<struct FCoverStyleUserData>            Styles;                                            // 0x0640(0x0010)(Edit, ZeroConstructor, ContainsInstancedReference, NativeAccessSpecifierPrivate)
	TArray<class FString>                         FireToIdleStates;                                  // 0x0650(0x0010)(Edit, ZeroConstructor, NativeAccessSpecifierPrivate)
	struct FGbxParam                              DefaultIdleTime;                                   // 0x0660(0x0080)(Edit, NoDestructor, ContainsInstancedReference, NativeAccessSpecifierPrivate)
	struct FGbxParam                              DefaultFireTime;                                   // 0x06E0(0x0080)(Edit, NoDestructor, ContainsInstancedReference, NativeAccessSpecifierPrivate)
	struct FGbxParam                              DefaultWaitTimeBeforeSeekingBetterCover;           // 0x0760(0x0080)(Edit, NoDestructor, ContainsInstancedReference, NativeAccessSpecifierPrivate)
	struct FAITicketUseData                       TicketForAdvancingToBetterCover;                   // 0x07E0(0x0108)(Edit, NoDestructor, ContainsInstancedReference, NativeAccessSpecifierPrivate)
	struct FCoverFaceDirections                   FaceDirections;                                    // 0x08E8(0x0003)(Edit, NoDestructor, NativeAccessSpecifierPrivate)
	uint8                                         Pad_8EB[0x5];                                      // 0x08EB(0x0005)(Fixing Size After Last Property [ Dumper-7 ])
	TSubclassOf<class UHitReactionLayer>          HitReactionLayer;                                  // 0x08F0(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	float                                         TransitionBlendTime;                               // 0x08F8(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	float                                         NearCoverDistance;                                 // 0x08FC(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UGbxCoverTransitionTable*               EnterTransitionTable;                              // 0x0900(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UGbxCoverTransitionTable*               BetweenTransitionTable;                            // 0x0908(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)

public:
	void OnMovementModeChanged(class ACharacter* Character, EMovementMode PrevMovementMode, uint8 PreviousCustomMode);
	void OnRep_ClientData();
	void SetEnterTransitionTable(class UGbxCoverTransitionTable* NewTable);

	class UCoverStyleData* GetStyle() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"CoverUserComponent">();
	}
	static class UCoverUserComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UCoverUserComponent>();
	}
};
static_assert(alignof(UCoverUserComponent) == 0x000008, "Wrong alignment on UCoverUserComponent");
static_assert(sizeof(UCoverUserComponent) == 0x000910, "Wrong size on UCoverUserComponent");
static_assert(offsetof(UCoverUserComponent, OnCoverStateChanged) == 0x000180, "Member 'UCoverUserComponent::OnCoverStateChanged' has a wrong offset!");
static_assert(offsetof(UCoverUserComponent, DesiredAction) == 0x0001E0, "Member 'UCoverUserComponent::DesiredAction' has a wrong offset!");
static_assert(offsetof(UCoverUserComponent, CurrentAction) == 0x000310, "Member 'UCoverUserComponent::CurrentAction' has a wrong offset!");
static_assert(offsetof(UCoverUserComponent, PreviousAction) == 0x000440, "Member 'UCoverUserComponent::PreviousAction' has a wrong offset!");
static_assert(offsetof(UCoverUserComponent, State) == 0x000570, "Member 'UCoverUserComponent::State' has a wrong offset!");
static_assert(offsetof(UCoverUserComponent, DesiredState) == 0x000571, "Member 'UCoverUserComponent::DesiredState' has a wrong offset!");
static_assert(offsetof(UCoverUserComponent, TransitionName) == 0x000578, "Member 'UCoverUserComponent::TransitionName' has a wrong offset!");
static_assert(offsetof(UCoverUserComponent, SkelMeshComponent) == 0x000580, "Member 'UCoverUserComponent::SkelMeshComponent' has a wrong offset!");
static_assert(offsetof(UCoverUserComponent, GbxCharacter) == 0x000588, "Member 'UCoverUserComponent::GbxCharacter' has a wrong offset!");
static_assert(offsetof(UCoverUserComponent, GbxAIController) == 0x000590, "Member 'UCoverUserComponent::GbxAIController' has a wrong offset!");
static_assert(offsetof(UCoverUserComponent, DamageComponent) == 0x000598, "Member 'UCoverUserComponent::DamageComponent' has a wrong offset!");
static_assert(offsetof(UCoverUserComponent, GbxNavComponent) == 0x0005A0, "Member 'UCoverUserComponent::GbxNavComponent' has a wrong offset!");
static_assert(offsetof(UCoverUserComponent, StanceComponent) == 0x0005A8, "Member 'UCoverUserComponent::StanceComponent' has a wrong offset!");
static_assert(offsetof(UCoverUserComponent, TargetingComponent) == 0x0005B0, "Member 'UCoverUserComponent::TargetingComponent' has a wrong offset!");
static_assert(offsetof(UCoverUserComponent, WeaponUserComponent) == 0x0005B8, "Member 'UCoverUserComponent::WeaponUserComponent' has a wrong offset!");
static_assert(offsetof(UCoverUserComponent, MovementComponent) == 0x0005C0, "Member 'UCoverUserComponent::MovementComponent' has a wrong offset!");
static_assert(offsetof(UCoverUserComponent, SavedCollision) == 0x0005C8, "Member 'UCoverUserComponent::SavedCollision' has a wrong offset!");
static_assert(offsetof(UCoverUserComponent, ClientData) == 0x0005F0, "Member 'UCoverUserComponent::ClientData' has a wrong offset!");
static_assert(offsetof(UCoverUserComponent, bFlanked) == 0x000618, "Member 'UCoverUserComponent::bFlanked' has a wrong offset!");
static_assert(offsetof(UCoverUserComponent, MaxVerticalNavDistance) == 0x00061C, "Member 'UCoverUserComponent::MaxVerticalNavDistance' has a wrong offset!");
static_assert(offsetof(UCoverUserComponent, MaxHorizontalNavDistance) == 0x000620, "Member 'UCoverUserComponent::MaxHorizontalNavDistance' has a wrong offset!");
static_assert(offsetof(UCoverUserComponent, MaxDeltaLocationThreshold) == 0x000624, "Member 'UCoverUserComponent::MaxDeltaLocationThreshold' has a wrong offset!");
static_assert(offsetof(UCoverUserComponent, MaxDeltaRotationThreshold) == 0x000628, "Member 'UCoverUserComponent::MaxDeltaRotationThreshold' has a wrong offset!");
static_assert(offsetof(UCoverUserComponent, ExitInterpSearchDistance) == 0x00062C, "Member 'UCoverUserComponent::ExitInterpSearchDistance' has a wrong offset!");
static_assert(offsetof(UCoverUserComponent, TransitionBetweenTraceHeight) == 0x000630, "Member 'UCoverUserComponent::TransitionBetweenTraceHeight' has a wrong offset!");
static_assert(offsetof(UCoverUserComponent, WidthAdjustment) == 0x000634, "Member 'UCoverUserComponent::WidthAdjustment' has a wrong offset!");
static_assert(offsetof(UCoverUserComponent, HeightAdjustment) == 0x000638, "Member 'UCoverUserComponent::HeightAdjustment' has a wrong offset!");
static_assert(offsetof(UCoverUserComponent, bDisableFootIk) == 0x00063C, "Member 'UCoverUserComponent::bDisableFootIk' has a wrong offset!");
static_assert(offsetof(UCoverUserComponent, Styles) == 0x000640, "Member 'UCoverUserComponent::Styles' has a wrong offset!");
static_assert(offsetof(UCoverUserComponent, FireToIdleStates) == 0x000650, "Member 'UCoverUserComponent::FireToIdleStates' has a wrong offset!");
static_assert(offsetof(UCoverUserComponent, DefaultIdleTime) == 0x000660, "Member 'UCoverUserComponent::DefaultIdleTime' has a wrong offset!");
static_assert(offsetof(UCoverUserComponent, DefaultFireTime) == 0x0006E0, "Member 'UCoverUserComponent::DefaultFireTime' has a wrong offset!");
static_assert(offsetof(UCoverUserComponent, DefaultWaitTimeBeforeSeekingBetterCover) == 0x000760, "Member 'UCoverUserComponent::DefaultWaitTimeBeforeSeekingBetterCover' has a wrong offset!");
static_assert(offsetof(UCoverUserComponent, TicketForAdvancingToBetterCover) == 0x0007E0, "Member 'UCoverUserComponent::TicketForAdvancingToBetterCover' has a wrong offset!");
static_assert(offsetof(UCoverUserComponent, FaceDirections) == 0x0008E8, "Member 'UCoverUserComponent::FaceDirections' has a wrong offset!");
static_assert(offsetof(UCoverUserComponent, HitReactionLayer) == 0x0008F0, "Member 'UCoverUserComponent::HitReactionLayer' has a wrong offset!");
static_assert(offsetof(UCoverUserComponent, TransitionBlendTime) == 0x0008F8, "Member 'UCoverUserComponent::TransitionBlendTime' has a wrong offset!");
static_assert(offsetof(UCoverUserComponent, NearCoverDistance) == 0x0008FC, "Member 'UCoverUserComponent::NearCoverDistance' has a wrong offset!");
static_assert(offsetof(UCoverUserComponent, EnterTransitionTable) == 0x000900, "Member 'UCoverUserComponent::EnterTransitionTable' has a wrong offset!");
static_assert(offsetof(UCoverUserComponent, BetweenTransitionTable) == 0x000908, "Member 'UCoverUserComponent::BetweenTransitionTable' has a wrong offset!");

// Class GbxAI.CoverViewData
// 0x0048 (0x0078 - 0x0030)
class UCoverViewData final : public UGbxDataAsset
{
public:
	ECoverSlotHeight                              SlotHeight;                                        // 0x0030(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_31[0x3];                                       // 0x0031(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	struct FVector                                ViewOffset;                                        // 0x0034(0x000C)(Edit, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FCoverLineOfSightParams                TargetParams;                                      // 0x0040(0x0028)(Edit, NoDestructor, NativeAccessSpecifierPublic)
	float                                         ForwardCheckDistance;                              // 0x0068(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                ForwardCheckExtent;                                // 0x006C(0x000C)(Edit, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"CoverViewData">();
	}
	static class UCoverViewData* GetDefaultObj()
	{
		return GetDefaultObjImpl<UCoverViewData>();
	}
};
static_assert(alignof(UCoverViewData) == 0x000008, "Wrong alignment on UCoverViewData");
static_assert(sizeof(UCoverViewData) == 0x000078, "Wrong size on UCoverViewData");
static_assert(offsetof(UCoverViewData, SlotHeight) == 0x000030, "Member 'UCoverViewData::SlotHeight' has a wrong offset!");
static_assert(offsetof(UCoverViewData, ViewOffset) == 0x000034, "Member 'UCoverViewData::ViewOffset' has a wrong offset!");
static_assert(offsetof(UCoverViewData, TargetParams) == 0x000040, "Member 'UCoverViewData::TargetParams' has a wrong offset!");
static_assert(offsetof(UCoverViewData, ForwardCheckDistance) == 0x000068, "Member 'UCoverViewData::ForwardCheckDistance' has a wrong offset!");
static_assert(offsetof(UCoverViewData, ForwardCheckExtent) == 0x00006C, "Member 'UCoverViewData::ForwardCheckExtent' has a wrong offset!");

// Class GbxAI.EnvQueryContext_AllTargets
// 0x0000 (0x0028 - 0x0028)
class UEnvQueryContext_AllTargets final : public UEnvQueryContext
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"EnvQueryContext_AllTargets">();
	}
	static class UEnvQueryContext_AllTargets* GetDefaultObj()
	{
		return GetDefaultObjImpl<UEnvQueryContext_AllTargets>();
	}
};
static_assert(alignof(UEnvQueryContext_AllTargets) == 0x000008, "Wrong alignment on UEnvQueryContext_AllTargets");
static_assert(sizeof(UEnvQueryContext_AllTargets) == 0x000028, "Wrong size on UEnvQueryContext_AllTargets");

// Class GbxAI.EnvQueryContext_Target
// 0x0000 (0x0028 - 0x0028)
class UEnvQueryContext_Target final : public UEnvQueryContext
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"EnvQueryContext_Target">();
	}
	static class UEnvQueryContext_Target* GetDefaultObj()
	{
		return GetDefaultObjImpl<UEnvQueryContext_Target>();
	}
};
static_assert(alignof(UEnvQueryContext_Target) == 0x000008, "Wrong alignment on UEnvQueryContext_Target");
static_assert(sizeof(UEnvQueryContext_Target) == 0x000028, "Wrong size on UEnvQueryContext_Target");

// Class GbxAI.EnvQueryGenerator_AINodes
// 0x00A0 (0x0100 - 0x0060)
class UEnvQueryGenerator_AINodes final : public UEnvQueryGenerator
{
public:
	TSubclassOf<class UEnvQueryContext>           SearchCenter;                                      // 0x0060(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FAIDataProviderFloatValue              SearchRadius;                                      // 0x0068(0x0030)(Edit, ContainsInstancedReference, NativeAccessSpecifierPublic)
	struct FActorTagCompositeQuery                TagQuery;                                          // 0x0098(0x0010)(Edit, NativeAccessSpecifierPublic)
	TArray<TSoftClassPtr<class UClass>>           AllowedTypes;                                      // 0x00A8(0x0010)(Edit, ZeroConstructor, UObjectWrapper, NativeAccessSpecifierPublic)
	uint8                                         bUseAllowedTypes : 1;                              // 0x00B8(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (Edit, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         Pad_B9[0x7];                                       // 0x00B9(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<TSoftClassPtr<class UClass>>           DisallowedTypes;                                   // 0x00C0(0x0010)(Edit, ZeroConstructor, UObjectWrapper, NativeAccessSpecifierPublic)
	uint8                                         bUseDisallowedTypes : 1;                           // 0x00D0(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (Edit, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         Pad_D1[0x7];                                       // 0x00D1(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<class UClass*>                         AllowedTypesCache;                                 // 0x00D8(0x0010)(ZeroConstructor, Transient, NativeAccessSpecifierPublic)
	TArray<class UClass*>                         DisallowedTypesCache;                              // 0x00E8(0x0010)(ZeroConstructor, Transient, NativeAccessSpecifierPublic)
	uint8                                         Pad_F8[0x8];                                       // 0x00F8(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"EnvQueryGenerator_AINodes">();
	}
	static class UEnvQueryGenerator_AINodes* GetDefaultObj()
	{
		return GetDefaultObjImpl<UEnvQueryGenerator_AINodes>();
	}
};
static_assert(alignof(UEnvQueryGenerator_AINodes) == 0x000008, "Wrong alignment on UEnvQueryGenerator_AINodes");
static_assert(sizeof(UEnvQueryGenerator_AINodes) == 0x000100, "Wrong size on UEnvQueryGenerator_AINodes");
static_assert(offsetof(UEnvQueryGenerator_AINodes, SearchCenter) == 0x000060, "Member 'UEnvQueryGenerator_AINodes::SearchCenter' has a wrong offset!");
static_assert(offsetof(UEnvQueryGenerator_AINodes, SearchRadius) == 0x000068, "Member 'UEnvQueryGenerator_AINodes::SearchRadius' has a wrong offset!");
static_assert(offsetof(UEnvQueryGenerator_AINodes, TagQuery) == 0x000098, "Member 'UEnvQueryGenerator_AINodes::TagQuery' has a wrong offset!");
static_assert(offsetof(UEnvQueryGenerator_AINodes, AllowedTypes) == 0x0000A8, "Member 'UEnvQueryGenerator_AINodes::AllowedTypes' has a wrong offset!");
static_assert(offsetof(UEnvQueryGenerator_AINodes, DisallowedTypes) == 0x0000C0, "Member 'UEnvQueryGenerator_AINodes::DisallowedTypes' has a wrong offset!");
static_assert(offsetof(UEnvQueryGenerator_AINodes, AllowedTypesCache) == 0x0000D8, "Member 'UEnvQueryGenerator_AINodes::AllowedTypesCache' has a wrong offset!");
static_assert(offsetof(UEnvQueryGenerator_AINodes, DisallowedTypesCache) == 0x0000E8, "Member 'UEnvQueryGenerator_AINodes::DisallowedTypesCache' has a wrong offset!");

// Class GbxAI.EnvQueryGenerator_FindLookAtPoint
// 0x0040 (0x00A0 - 0x0060)
class UEnvQueryGenerator_FindLookAtPoint final : public UEnvQueryGenerator
{
public:
	ELookAtPointType                              LookAtPointType;                                   // 0x0060(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_61[0x7];                                       // 0x0061(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	struct FAIDataProviderFloatValue              SearchRadius;                                      // 0x0068(0x0030)(Edit, DisableEditOnInstance, ContainsInstancedReference, NativeAccessSpecifierPrivate)
	TSubclassOf<class UEnvQueryContext>           SearchCenter;                                      // 0x0098(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"EnvQueryGenerator_FindLookAtPoint">();
	}
	static class UEnvQueryGenerator_FindLookAtPoint* GetDefaultObj()
	{
		return GetDefaultObjImpl<UEnvQueryGenerator_FindLookAtPoint>();
	}
};
static_assert(alignof(UEnvQueryGenerator_FindLookAtPoint) == 0x000008, "Wrong alignment on UEnvQueryGenerator_FindLookAtPoint");
static_assert(sizeof(UEnvQueryGenerator_FindLookAtPoint) == 0x0000A0, "Wrong size on UEnvQueryGenerator_FindLookAtPoint");
static_assert(offsetof(UEnvQueryGenerator_FindLookAtPoint, LookAtPointType) == 0x000060, "Member 'UEnvQueryGenerator_FindLookAtPoint::LookAtPointType' has a wrong offset!");
static_assert(offsetof(UEnvQueryGenerator_FindLookAtPoint, SearchRadius) == 0x000068, "Member 'UEnvQueryGenerator_FindLookAtPoint::SearchRadius' has a wrong offset!");
static_assert(offsetof(UEnvQueryGenerator_FindLookAtPoint, SearchCenter) == 0x000098, "Member 'UEnvQueryGenerator_FindLookAtPoint::SearchCenter' has a wrong offset!");

// Class GbxAI.EnvQueryGenerator_SmartAction
// 0x00E8 (0x0148 - 0x0060)
class UEnvQueryGenerator_SmartAction final : public UEnvQueryGenerator
{
public:
	struct FAIDataProviderBoolValue               CombatActions;                                     // 0x0060(0x0030)(Edit, DisableEditOnInstance, ContainsInstancedReference, NativeAccessSpecifierPrivate)
	struct FAIDataProviderBoolValue               PassiveActions;                                    // 0x0090(0x0030)(Edit, DisableEditOnInstance, ContainsInstancedReference, NativeAccessSpecifierPrivate)
	TArray<TSoftClassPtr<class UClass>>           ActorTypes;                                        // 0x00C0(0x0010)(Edit, ZeroConstructor, UObjectWrapper, NativeAccessSpecifierPrivate)
	TArray<class UClass*>                         ActorTypesCache;                                   // 0x00D0(0x0010)(ZeroConstructor, Transient, NativeAccessSpecifierPrivate)
	uint8                                         Pad_E0[0x8];                                       // 0x00E0(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	struct FGameplayTagContainer                  ActionNames;                                       // 0x00E8(0x0020)(Edit, NativeAccessSpecifierPrivate)
	struct FAIDataProviderFloatValue              SearchRadius;                                      // 0x0108(0x0030)(Edit, DisableEditOnInstance, ContainsInstancedReference, NativeAccessSpecifierPrivate)
	TSubclassOf<class UEnvQueryContext>           SearchCenter;                                      // 0x0138(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	ETerritoryType                                TerritoryArea;                                     // 0x0140(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	bool                                          bUseTerritoryArea;                                 // 0x0141(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_142[0x6];                                      // 0x0142(0x0006)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"EnvQueryGenerator_SmartAction">();
	}
	static class UEnvQueryGenerator_SmartAction* GetDefaultObj()
	{
		return GetDefaultObjImpl<UEnvQueryGenerator_SmartAction>();
	}
};
static_assert(alignof(UEnvQueryGenerator_SmartAction) == 0x000008, "Wrong alignment on UEnvQueryGenerator_SmartAction");
static_assert(sizeof(UEnvQueryGenerator_SmartAction) == 0x000148, "Wrong size on UEnvQueryGenerator_SmartAction");
static_assert(offsetof(UEnvQueryGenerator_SmartAction, CombatActions) == 0x000060, "Member 'UEnvQueryGenerator_SmartAction::CombatActions' has a wrong offset!");
static_assert(offsetof(UEnvQueryGenerator_SmartAction, PassiveActions) == 0x000090, "Member 'UEnvQueryGenerator_SmartAction::PassiveActions' has a wrong offset!");
static_assert(offsetof(UEnvQueryGenerator_SmartAction, ActorTypes) == 0x0000C0, "Member 'UEnvQueryGenerator_SmartAction::ActorTypes' has a wrong offset!");
static_assert(offsetof(UEnvQueryGenerator_SmartAction, ActorTypesCache) == 0x0000D0, "Member 'UEnvQueryGenerator_SmartAction::ActorTypesCache' has a wrong offset!");
static_assert(offsetof(UEnvQueryGenerator_SmartAction, ActionNames) == 0x0000E8, "Member 'UEnvQueryGenerator_SmartAction::ActionNames' has a wrong offset!");
static_assert(offsetof(UEnvQueryGenerator_SmartAction, SearchRadius) == 0x000108, "Member 'UEnvQueryGenerator_SmartAction::SearchRadius' has a wrong offset!");
static_assert(offsetof(UEnvQueryGenerator_SmartAction, SearchCenter) == 0x000138, "Member 'UEnvQueryGenerator_SmartAction::SearchCenter' has a wrong offset!");
static_assert(offsetof(UEnvQueryGenerator_SmartAction, TerritoryArea) == 0x000140, "Member 'UEnvQueryGenerator_SmartAction::TerritoryArea' has a wrong offset!");
static_assert(offsetof(UEnvQueryGenerator_SmartAction, bUseTerritoryArea) == 0x000141, "Member 'UEnvQueryGenerator_SmartAction::bUseTerritoryArea' has a wrong offset!");

// Class GbxAI.EnvQueryGenerator_Territory
// 0x0070 (0x0108 - 0x0098)
class UEnvQueryGenerator_Territory final : public UEnvQueryGenerator_ProjectedPoints
{
public:
	ETerritoryType                                TerritoryArea;                                     // 0x0098(0x0001)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_99[0x7];                                       // 0x0099(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	struct FAIDataProviderFloatValue              SpaceBetween;                                      // 0x00A0(0x0030)(Edit, DisableEditOnInstance, ContainsInstancedReference, NativeAccessSpecifierPublic)
	struct FAIDataProviderFloatValue              EverywhereRadius;                                  // 0x00D0(0x0030)(Edit, DisableEditOnInstance, ContainsInstancedReference, NativeAccessSpecifierPublic)
	ETerritoryMovementType                        MovementType;                                      // 0x0100(0x0001)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_101[0x7];                                      // 0x0101(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"EnvQueryGenerator_Territory">();
	}
	static class UEnvQueryGenerator_Territory* GetDefaultObj()
	{
		return GetDefaultObjImpl<UEnvQueryGenerator_Territory>();
	}
};
static_assert(alignof(UEnvQueryGenerator_Territory) == 0x000008, "Wrong alignment on UEnvQueryGenerator_Territory");
static_assert(sizeof(UEnvQueryGenerator_Territory) == 0x000108, "Wrong size on UEnvQueryGenerator_Territory");
static_assert(offsetof(UEnvQueryGenerator_Territory, TerritoryArea) == 0x000098, "Member 'UEnvQueryGenerator_Territory::TerritoryArea' has a wrong offset!");
static_assert(offsetof(UEnvQueryGenerator_Territory, SpaceBetween) == 0x0000A0, "Member 'UEnvQueryGenerator_Territory::SpaceBetween' has a wrong offset!");
static_assert(offsetof(UEnvQueryGenerator_Territory, EverywhereRadius) == 0x0000D0, "Member 'UEnvQueryGenerator_Territory::EverywhereRadius' has a wrong offset!");
static_assert(offsetof(UEnvQueryGenerator_Territory, MovementType) == 0x000100, "Member 'UEnvQueryGenerator_Territory::MovementType' has a wrong offset!");

// Class GbxAI.EnvQueryTest_AITicket
// 0x0038 (0x0210 - 0x01D8)
class UEnvQueryTest_AITicket final : public UEnvQueryTest
{
public:
	class UAITicketDataAsset*                     AITicket;                                          // 0x01D8(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FAIDataProviderFloatValue              Value;                                             // 0x01E0(0x0030)(Edit, ContainsInstancedReference, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"EnvQueryTest_AITicket">();
	}
	static class UEnvQueryTest_AITicket* GetDefaultObj()
	{
		return GetDefaultObjImpl<UEnvQueryTest_AITicket>();
	}
};
static_assert(alignof(UEnvQueryTest_AITicket) == 0x000008, "Wrong alignment on UEnvQueryTest_AITicket");
static_assert(sizeof(UEnvQueryTest_AITicket) == 0x000210, "Wrong size on UEnvQueryTest_AITicket");
static_assert(offsetof(UEnvQueryTest_AITicket, AITicket) == 0x0001D8, "Member 'UEnvQueryTest_AITicket::AITicket' has a wrong offset!");
static_assert(offsetof(UEnvQueryTest_AITicket, Value) == 0x0001E0, "Member 'UEnvQueryTest_AITicket::Value' has a wrong offset!");

// Class GbxAI.EnvQueryTest_AttackerCountAgainstTarget
// 0x0000 (0x01D8 - 0x01D8)
class UEnvQueryTest_AttackerCountAgainstTarget final : public UEnvQueryTest
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"EnvQueryTest_AttackerCountAgainstTarget">();
	}
	static class UEnvQueryTest_AttackerCountAgainstTarget* GetDefaultObj()
	{
		return GetDefaultObjImpl<UEnvQueryTest_AttackerCountAgainstTarget>();
	}
};
static_assert(alignof(UEnvQueryTest_AttackerCountAgainstTarget) == 0x000008, "Wrong alignment on UEnvQueryTest_AttackerCountAgainstTarget");
static_assert(sizeof(UEnvQueryTest_AttackerCountAgainstTarget) == 0x0001D8, "Wrong size on UEnvQueryTest_AttackerCountAgainstTarget");

// Class GbxAI.EnvQueryTest_Boundary
// 0x0030 (0x0208 - 0x01D8)
class UEnvQueryTest_Boundary final : public UEnvQueryTest
{
public:
	struct FAIDataProviderFloatValue              Distance;                                          // 0x01D8(0x0030)(Edit, DisableEditOnInstance, ContainsInstancedReference, NativeAccessSpecifierPrivate)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"EnvQueryTest_Boundary">();
	}
	static class UEnvQueryTest_Boundary* GetDefaultObj()
	{
		return GetDefaultObjImpl<UEnvQueryTest_Boundary>();
	}
};
static_assert(alignof(UEnvQueryTest_Boundary) == 0x000008, "Wrong alignment on UEnvQueryTest_Boundary");
static_assert(sizeof(UEnvQueryTest_Boundary) == 0x000208, "Wrong size on UEnvQueryTest_Boundary");
static_assert(offsetof(UEnvQueryTest_Boundary, Distance) == 0x0001D8, "Member 'UEnvQueryTest_Boundary::Distance' has a wrong offset!");

// Class GbxAI.EnvQueryTest_CoverExposure
// 0x0038 (0x0210 - 0x01D8)
class UEnvQueryTest_CoverExposure final : public UEnvQueryTest
{
public:
	TSubclassOf<class UEnvQueryContext>           Context;                                           // 0x01D8(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	struct FAIDataProviderBoolValue               DoExposureTest;                                    // 0x01E0(0x0030)(Edit, DisableEditOnInstance, ContainsInstancedReference, NativeAccessSpecifierPrivate)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"EnvQueryTest_CoverExposure">();
	}
	static class UEnvQueryTest_CoverExposure* GetDefaultObj()
	{
		return GetDefaultObjImpl<UEnvQueryTest_CoverExposure>();
	}
};
static_assert(alignof(UEnvQueryTest_CoverExposure) == 0x000008, "Wrong alignment on UEnvQueryTest_CoverExposure");
static_assert(sizeof(UEnvQueryTest_CoverExposure) == 0x000210, "Wrong size on UEnvQueryTest_CoverExposure");
static_assert(offsetof(UEnvQueryTest_CoverExposure, Context) == 0x0001D8, "Member 'UEnvQueryTest_CoverExposure::Context' has a wrong offset!");
static_assert(offsetof(UEnvQueryTest_CoverExposure, DoExposureTest) == 0x0001E0, "Member 'UEnvQueryTest_CoverExposure::DoExposureTest' has a wrong offset!");

// Class GbxAI.EnvQueryTest_CurrentTarget
// 0x0000 (0x01D8 - 0x01D8)
class UEnvQueryTest_CurrentTarget final : public UEnvQueryTest
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"EnvQueryTest_CurrentTarget">();
	}
	static class UEnvQueryTest_CurrentTarget* GetDefaultObj()
	{
		return GetDefaultObjImpl<UEnvQueryTest_CurrentTarget>();
	}
};
static_assert(alignof(UEnvQueryTest_CurrentTarget) == 0x000008, "Wrong alignment on UEnvQueryTest_CurrentTarget");
static_assert(sizeof(UEnvQueryTest_CurrentTarget) == 0x0001D8, "Wrong size on UEnvQueryTest_CurrentTarget");

// Class GbxAI.EnvQueryTest_DirectPath
// 0x0010 (0x01E8 - 0x01D8)
class UEnvQueryTest_DirectPath final : public UEnvQueryTest
{
public:
	TSubclassOf<class UEnvQueryContext>           Context;                                           // 0x01D8(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         CloseEnoughDistance;                               // 0x01E0(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1E4[0x4];                                      // 0x01E4(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"EnvQueryTest_DirectPath">();
	}
	static class UEnvQueryTest_DirectPath* GetDefaultObj()
	{
		return GetDefaultObjImpl<UEnvQueryTest_DirectPath>();
	}
};
static_assert(alignof(UEnvQueryTest_DirectPath) == 0x000008, "Wrong alignment on UEnvQueryTest_DirectPath");
static_assert(sizeof(UEnvQueryTest_DirectPath) == 0x0001E8, "Wrong size on UEnvQueryTest_DirectPath");
static_assert(offsetof(UEnvQueryTest_DirectPath, Context) == 0x0001D8, "Member 'UEnvQueryTest_DirectPath::Context' has a wrong offset!");
static_assert(offsetof(UEnvQueryTest_DirectPath, CloseEnoughDistance) == 0x0001E0, "Member 'UEnvQueryTest_DirectPath::CloseEnoughDistance' has a wrong offset!");

// Class GbxAI.EnvQueryTest_IsInGodMode
// 0x0000 (0x01D8 - 0x01D8)
class UEnvQueryTest_IsInGodMode final : public UEnvQueryTest
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"EnvQueryTest_IsInGodMode">();
	}
	static class UEnvQueryTest_IsInGodMode* GetDefaultObj()
	{
		return GetDefaultObjImpl<UEnvQueryTest_IsInGodMode>();
	}
};
static_assert(alignof(UEnvQueryTest_IsInGodMode) == 0x000008, "Wrong alignment on UEnvQueryTest_IsInGodMode");
static_assert(sizeof(UEnvQueryTest_IsInGodMode) == 0x0001D8, "Wrong size on UEnvQueryTest_IsInGodMode");

// Class GbxAI.EnvQueryTest_PetModifier
// 0x0010 (0x01E8 - 0x01D8)
class UEnvQueryTest_PetModifier final : public UEnvQueryTest
{
public:
	struct FGameplayTag                           PetTag;                                            // 0x01D8(0x0008)(Edit, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	struct FGameplayTag                           BossTag;                                           // 0x01E0(0x0008)(Edit, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"EnvQueryTest_PetModifier">();
	}
	static class UEnvQueryTest_PetModifier* GetDefaultObj()
	{
		return GetDefaultObjImpl<UEnvQueryTest_PetModifier>();
	}
};
static_assert(alignof(UEnvQueryTest_PetModifier) == 0x000008, "Wrong alignment on UEnvQueryTest_PetModifier");
static_assert(sizeof(UEnvQueryTest_PetModifier) == 0x0001E8, "Wrong size on UEnvQueryTest_PetModifier");
static_assert(offsetof(UEnvQueryTest_PetModifier, PetTag) == 0x0001D8, "Member 'UEnvQueryTest_PetModifier::PetTag' has a wrong offset!");
static_assert(offsetof(UEnvQueryTest_PetModifier, BossTag) == 0x0001E0, "Member 'UEnvQueryTest_PetModifier::BossTag' has a wrong offset!");

// Class GbxAI.EnvQueryTest_StandardCover
// 0x0158 (0x0330 - 0x01D8)
class UEnvQueryTest_StandardCover final : public UEnvQueryTest
{
public:
	TSubclassOf<class UEnvQueryContext>           FriendliesContext;                                 // 0x01D8(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	TSubclassOf<class UEnvQueryContext>           TargetContext;                                     // 0x01E0(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	TSubclassOf<class UEnvQueryContext>           ExposureContext;                                   // 0x01E8(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	struct FAIDataProviderFloatValue              TargetDistanceMinPriorToTakingCover;               // 0x01F0(0x0030)(Edit, DisableEditOnInstance, ContainsInstancedReference, NativeAccessSpecifierPrivate)
	struct FAIDataProviderFloatValue              TargetDistanceMaxPriorToTakingCover;               // 0x0220(0x0030)(Edit, DisableEditOnInstance, ContainsInstancedReference, NativeAccessSpecifierPrivate)
	float                                         TargetDistanceMinMultiplierAfterTakingCover;       // 0x0250(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	float                                         TargetDistanceMaxMultiplierAfterTakingCover;       // 0x0254(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	struct FAIDataProviderFloatValue              QuerierMaxDistance;                                // 0x0258(0x0030)(Edit, DisableEditOnInstance, ContainsInstancedReference, NativeAccessSpecifierPrivate)
	struct FAIDataProviderBoolValue               DoViewTest;                                        // 0x0288(0x0030)(Edit, DisableEditOnInstance, ContainsInstancedReference, NativeAccessSpecifierPrivate)
	struct FAIDataProviderBoolValue               DoExposureTest;                                    // 0x02B8(0x0030)(Edit, DisableEditOnInstance, ContainsInstancedReference, NativeAccessSpecifierPrivate)
	struct FAIDataProviderFloatValue              FriendlyDistance;                                  // 0x02E8(0x0030)(Edit, DisableEditOnInstance, ContainsInstancedReference, NativeAccessSpecifierPrivate)
	float                                         ScoringWeight_AlreadyAtCover;                      // 0x0318(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	float                                         ScoringWeight_DistanceToQuerier;                   // 0x031C(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	float                                         ScoringWeight_DistanceToTarget;                    // 0x0320(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	float                                         ScoringWeight_DistanceToFriendlies;                // 0x0324(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	float                                         ScoringWeight_CoverView;                           // 0x0328(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	float                                         ScoringWeight_CoverExposure;                       // 0x032C(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"EnvQueryTest_StandardCover">();
	}
	static class UEnvQueryTest_StandardCover* GetDefaultObj()
	{
		return GetDefaultObjImpl<UEnvQueryTest_StandardCover>();
	}
};
static_assert(alignof(UEnvQueryTest_StandardCover) == 0x000008, "Wrong alignment on UEnvQueryTest_StandardCover");
static_assert(sizeof(UEnvQueryTest_StandardCover) == 0x000330, "Wrong size on UEnvQueryTest_StandardCover");
static_assert(offsetof(UEnvQueryTest_StandardCover, FriendliesContext) == 0x0001D8, "Member 'UEnvQueryTest_StandardCover::FriendliesContext' has a wrong offset!");
static_assert(offsetof(UEnvQueryTest_StandardCover, TargetContext) == 0x0001E0, "Member 'UEnvQueryTest_StandardCover::TargetContext' has a wrong offset!");
static_assert(offsetof(UEnvQueryTest_StandardCover, ExposureContext) == 0x0001E8, "Member 'UEnvQueryTest_StandardCover::ExposureContext' has a wrong offset!");
static_assert(offsetof(UEnvQueryTest_StandardCover, TargetDistanceMinPriorToTakingCover) == 0x0001F0, "Member 'UEnvQueryTest_StandardCover::TargetDistanceMinPriorToTakingCover' has a wrong offset!");
static_assert(offsetof(UEnvQueryTest_StandardCover, TargetDistanceMaxPriorToTakingCover) == 0x000220, "Member 'UEnvQueryTest_StandardCover::TargetDistanceMaxPriorToTakingCover' has a wrong offset!");
static_assert(offsetof(UEnvQueryTest_StandardCover, TargetDistanceMinMultiplierAfterTakingCover) == 0x000250, "Member 'UEnvQueryTest_StandardCover::TargetDistanceMinMultiplierAfterTakingCover' has a wrong offset!");
static_assert(offsetof(UEnvQueryTest_StandardCover, TargetDistanceMaxMultiplierAfterTakingCover) == 0x000254, "Member 'UEnvQueryTest_StandardCover::TargetDistanceMaxMultiplierAfterTakingCover' has a wrong offset!");
static_assert(offsetof(UEnvQueryTest_StandardCover, QuerierMaxDistance) == 0x000258, "Member 'UEnvQueryTest_StandardCover::QuerierMaxDistance' has a wrong offset!");
static_assert(offsetof(UEnvQueryTest_StandardCover, DoViewTest) == 0x000288, "Member 'UEnvQueryTest_StandardCover::DoViewTest' has a wrong offset!");
static_assert(offsetof(UEnvQueryTest_StandardCover, DoExposureTest) == 0x0002B8, "Member 'UEnvQueryTest_StandardCover::DoExposureTest' has a wrong offset!");
static_assert(offsetof(UEnvQueryTest_StandardCover, FriendlyDistance) == 0x0002E8, "Member 'UEnvQueryTest_StandardCover::FriendlyDistance' has a wrong offset!");
static_assert(offsetof(UEnvQueryTest_StandardCover, ScoringWeight_AlreadyAtCover) == 0x000318, "Member 'UEnvQueryTest_StandardCover::ScoringWeight_AlreadyAtCover' has a wrong offset!");
static_assert(offsetof(UEnvQueryTest_StandardCover, ScoringWeight_DistanceToQuerier) == 0x00031C, "Member 'UEnvQueryTest_StandardCover::ScoringWeight_DistanceToQuerier' has a wrong offset!");
static_assert(offsetof(UEnvQueryTest_StandardCover, ScoringWeight_DistanceToTarget) == 0x000320, "Member 'UEnvQueryTest_StandardCover::ScoringWeight_DistanceToTarget' has a wrong offset!");
static_assert(offsetof(UEnvQueryTest_StandardCover, ScoringWeight_DistanceToFriendlies) == 0x000324, "Member 'UEnvQueryTest_StandardCover::ScoringWeight_DistanceToFriendlies' has a wrong offset!");
static_assert(offsetof(UEnvQueryTest_StandardCover, ScoringWeight_CoverView) == 0x000328, "Member 'UEnvQueryTest_StandardCover::ScoringWeight_CoverView' has a wrong offset!");
static_assert(offsetof(UEnvQueryTest_StandardCover, ScoringWeight_CoverExposure) == 0x00032C, "Member 'UEnvQueryTest_StandardCover::ScoringWeight_CoverExposure' has a wrong offset!");

// Class GbxAI.EnvQueryTest_TargetIsAttackingMyMaster
// 0x0008 (0x01E0 - 0x01D8)
class UEnvQueryTest_TargetIsAttackingMyMaster final : public UEnvQueryTest
{
public:
	float                                         DecayRate;                                         // 0x01D8(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_1DC[0x4];                                      // 0x01DC(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"EnvQueryTest_TargetIsAttackingMyMaster">();
	}
	static class UEnvQueryTest_TargetIsAttackingMyMaster* GetDefaultObj()
	{
		return GetDefaultObjImpl<UEnvQueryTest_TargetIsAttackingMyMaster>();
	}
};
static_assert(alignof(UEnvQueryTest_TargetIsAttackingMyMaster) == 0x000008, "Wrong alignment on UEnvQueryTest_TargetIsAttackingMyMaster");
static_assert(sizeof(UEnvQueryTest_TargetIsAttackingMyMaster) == 0x0001E0, "Wrong size on UEnvQueryTest_TargetIsAttackingMyMaster");
static_assert(offsetof(UEnvQueryTest_TargetIsAttackingMyMaster, DecayRate) == 0x0001D8, "Member 'UEnvQueryTest_TargetIsAttackingMyMaster::DecayRate' has a wrong offset!");

// Class GbxAI.EnvQueryTest_TargetIsExposed
// 0x0000 (0x01D8 - 0x01D8)
class UEnvQueryTest_TargetIsExposed final : public UEnvQueryTest
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"EnvQueryTest_TargetIsExposed">();
	}
	static class UEnvQueryTest_TargetIsExposed* GetDefaultObj()
	{
		return GetDefaultObjImpl<UEnvQueryTest_TargetIsExposed>();
	}
};
static_assert(alignof(UEnvQueryTest_TargetIsExposed) == 0x000008, "Wrong alignment on UEnvQueryTest_TargetIsExposed");
static_assert(sizeof(UEnvQueryTest_TargetIsExposed) == 0x0001D8, "Wrong size on UEnvQueryTest_TargetIsExposed");

// Class GbxAI.EnvQueryTest_TargetIsThreat
// 0x0000 (0x01D8 - 0x01D8)
class UEnvQueryTest_TargetIsThreat final : public UEnvQueryTest
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"EnvQueryTest_TargetIsThreat">();
	}
	static class UEnvQueryTest_TargetIsThreat* GetDefaultObj()
	{
		return GetDefaultObjImpl<UEnvQueryTest_TargetIsThreat>();
	}
};
static_assert(alignof(UEnvQueryTest_TargetIsThreat) == 0x000008, "Wrong alignment on UEnvQueryTest_TargetIsThreat");
static_assert(sizeof(UEnvQueryTest_TargetIsThreat) == 0x0001D8, "Wrong size on UEnvQueryTest_TargetIsThreat");

// Class GbxAI.EnvQueryTest_UberTrace
// 0x0018 (0x02B8 - 0x02A0)
class UEnvQueryTest_UberTrace final : public UEnvQueryTest_Trace
{
public:
	TArray<struct FExtendedTraceInfo>             TracesToPerform;                                   // 0x02A0(0x0010)(Edit, ZeroConstructor, DisableEditOnInstance, ContainsInstancedReference, NativeAccessSpecifierPublic)
	bool                                          bWantsTracesToHit;                                 // 0x02B0(0x0001)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2B1[0x7];                                      // 0x02B1(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"EnvQueryTest_UberTrace">();
	}
	static class UEnvQueryTest_UberTrace* GetDefaultObj()
	{
		return GetDefaultObjImpl<UEnvQueryTest_UberTrace>();
	}
};
static_assert(alignof(UEnvQueryTest_UberTrace) == 0x000008, "Wrong alignment on UEnvQueryTest_UberTrace");
static_assert(sizeof(UEnvQueryTest_UberTrace) == 0x0002B8, "Wrong size on UEnvQueryTest_UberTrace");
static_assert(offsetof(UEnvQueryTest_UberTrace, TracesToPerform) == 0x0002A0, "Member 'UEnvQueryTest_UberTrace::TracesToPerform' has a wrong offset!");
static_assert(offsetof(UEnvQueryTest_UberTrace, bWantsTracesToHit) == 0x0002B0, "Member 'UEnvQueryTest_UberTrace::bWantsTracesToHit' has a wrong offset!");

// Class GbxAI.GameplayTask_ScriptedCover
// 0x0028 (0x00E8 - 0x00C0)
class UGameplayTask_ScriptedCover final : public UGameplayTask_ScriptedAction
{
public:
	UMulticastDelegateProperty_                   OnArrived;                                         // 0x00C0(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	class UCoverSlotComponent*                    CoverSlot;                                         // 0x00D0(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UCoverUserComponent*                    CoverUser;                                         // 0x00D8(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_E0[0x8];                                       // 0x00E0(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UGameplayTask_ScriptedCover* BeginScriptedCover(class AActor* User, class ACover* Cover);
	static void EndScriptedCover(class AActor* User);

	void TaskScriptedCoverDelegate__DelegateSignature();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"GameplayTask_ScriptedCover">();
	}
	static class UGameplayTask_ScriptedCover* GetDefaultObj()
	{
		return GetDefaultObjImpl<UGameplayTask_ScriptedCover>();
	}
};
static_assert(alignof(UGameplayTask_ScriptedCover) == 0x000008, "Wrong alignment on UGameplayTask_ScriptedCover");
static_assert(sizeof(UGameplayTask_ScriptedCover) == 0x0000E8, "Wrong size on UGameplayTask_ScriptedCover");
static_assert(offsetof(UGameplayTask_ScriptedCover, OnArrived) == 0x0000C0, "Member 'UGameplayTask_ScriptedCover::OnArrived' has a wrong offset!");
static_assert(offsetof(UGameplayTask_ScriptedCover, CoverSlot) == 0x0000D0, "Member 'UGameplayTask_ScriptedCover::CoverSlot' has a wrong offset!");
static_assert(offsetof(UGameplayTask_ScriptedCover, CoverUser) == 0x0000D8, "Member 'UGameplayTask_ScriptedCover::CoverUser' has a wrong offset!");

// Class GbxAI.GameplayTask_ScriptedFollow
// 0x0020 (0x00E0 - 0x00C0)
class UGameplayTask_ScriptedFollow final : public UGameplayTask_ScriptedAction
{
public:
	UMulticastDelegateProperty_                   OnStopped;                                         // 0x00C0(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	class AActor*                                 ActorToFollow;                                     // 0x00D0(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UStanceDataProvider*                    StanceProvider;                                    // 0x00D8(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)

public:
	static class UGameplayTask_ScriptedFollow* BeginScriptedFollow(class AActor* Follower, class AActor* ActorToFollow_0, class UStanceDataProvider* OptionalStance);

	void TaskScriptedMoveDelegate__DelegateSignature();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"GameplayTask_ScriptedFollow">();
	}
	static class UGameplayTask_ScriptedFollow* GetDefaultObj()
	{
		return GetDefaultObjImpl<UGameplayTask_ScriptedFollow>();
	}
};
static_assert(alignof(UGameplayTask_ScriptedFollow) == 0x000008, "Wrong alignment on UGameplayTask_ScriptedFollow");
static_assert(sizeof(UGameplayTask_ScriptedFollow) == 0x0000E0, "Wrong size on UGameplayTask_ScriptedFollow");
static_assert(offsetof(UGameplayTask_ScriptedFollow, OnStopped) == 0x0000C0, "Member 'UGameplayTask_ScriptedFollow::OnStopped' has a wrong offset!");
static_assert(offsetof(UGameplayTask_ScriptedFollow, ActorToFollow) == 0x0000D0, "Member 'UGameplayTask_ScriptedFollow::ActorToFollow' has a wrong offset!");
static_assert(offsetof(UGameplayTask_ScriptedFollow, StanceProvider) == 0x0000D8, "Member 'UGameplayTask_ScriptedFollow::StanceProvider' has a wrong offset!");

// Class GbxAI.GameplayTask_ScriptedLead
// 0x0038 (0x00F8 - 0x00C0)
class UGameplayTask_ScriptedLead final : public UGameplayTask_ScriptedAction
{
public:
	UMulticastDelegateProperty_                   OnAborted;                                         // 0x00C0(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	UMulticastDelegateProperty_                   OnCompleted;                                       // 0x00D0(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	class AActor*                                 DestNode;                                          // 0x00E0(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class AActor*                                 ActorToLead;                                       // 0x00E8(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UStanceDataProvider*                    StanceProvider;                                    // 0x00F0(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)

public:
	static class UGameplayTask_ScriptedLead* BeginScriptedLead(class AActor* Leader, class AActor* DestAINode, class AActor* ActorToLead_0, class UStanceDataProvider* OptionalStance);

	void TaskScriptedLeadDelegate__DelegateSignature();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"GameplayTask_ScriptedLead">();
	}
	static class UGameplayTask_ScriptedLead* GetDefaultObj()
	{
		return GetDefaultObjImpl<UGameplayTask_ScriptedLead>();
	}
};
static_assert(alignof(UGameplayTask_ScriptedLead) == 0x000008, "Wrong alignment on UGameplayTask_ScriptedLead");
static_assert(sizeof(UGameplayTask_ScriptedLead) == 0x0000F8, "Wrong size on UGameplayTask_ScriptedLead");
static_assert(offsetof(UGameplayTask_ScriptedLead, OnAborted) == 0x0000C0, "Member 'UGameplayTask_ScriptedLead::OnAborted' has a wrong offset!");
static_assert(offsetof(UGameplayTask_ScriptedLead, OnCompleted) == 0x0000D0, "Member 'UGameplayTask_ScriptedLead::OnCompleted' has a wrong offset!");
static_assert(offsetof(UGameplayTask_ScriptedLead, DestNode) == 0x0000E0, "Member 'UGameplayTask_ScriptedLead::DestNode' has a wrong offset!");
static_assert(offsetof(UGameplayTask_ScriptedLead, ActorToLead) == 0x0000E8, "Member 'UGameplayTask_ScriptedLead::ActorToLead' has a wrong offset!");
static_assert(offsetof(UGameplayTask_ScriptedLead, StanceProvider) == 0x0000F0, "Member 'UGameplayTask_ScriptedLead::StanceProvider' has a wrong offset!");

// Class GbxAI.GameplayTask_ScriptedMoveSpline
// 0x0060 (0x0120 - 0x00C0)
class UGameplayTask_ScriptedMoveSpline final : public UGameplayTask_ScriptedAction
{
public:
	UMulticastDelegateProperty_                   OnAborted;                                         // 0x00C0(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	UMulticastDelegateProperty_                   OnCompleted;                                       // 0x00D0(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	class AActor*                                 Target;                                            // 0x00E0(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class USplineComponent*                       SplineComponent;                                   // 0x00E8(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UStanceDataProvider*                    StanceProvider;                                    // 0x00F0(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class AActor*                                 LookAtActor;                                       // 0x00F8(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	TSubclassOf<class UAIAction>                  OptionalAIAction;                                  // 0x0100(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class AGbxSpawner*                            DropOffSpawner;                                    // 0x0108(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class AActor*                                 NextSpline;                                        // 0x0110(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_118[0x8];                                      // 0x0118(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UGameplayTask_ScriptedMoveSpline* BeginScriptedMoveOnSpline(class AActor* Target_0, class AActor* StartSpline, EScriptedActionRule SuccessRule, EScriptedActionRule FailRule, float Offset, bool bReverse, bool bAddSpawned, class UStanceDataProvider* OptionalStance, class AActor* OptionalLookAtActor, TSubclassOf<class UAIAction> OptionalAIAction_0);

	void TaskScriptedMoveDelegate__DelegateSignature(class AActor* Targeted);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"GameplayTask_ScriptedMoveSpline">();
	}
	static class UGameplayTask_ScriptedMoveSpline* GetDefaultObj()
	{
		return GetDefaultObjImpl<UGameplayTask_ScriptedMoveSpline>();
	}
};
static_assert(alignof(UGameplayTask_ScriptedMoveSpline) == 0x000008, "Wrong alignment on UGameplayTask_ScriptedMoveSpline");
static_assert(sizeof(UGameplayTask_ScriptedMoveSpline) == 0x000120, "Wrong size on UGameplayTask_ScriptedMoveSpline");
static_assert(offsetof(UGameplayTask_ScriptedMoveSpline, OnAborted) == 0x0000C0, "Member 'UGameplayTask_ScriptedMoveSpline::OnAborted' has a wrong offset!");
static_assert(offsetof(UGameplayTask_ScriptedMoveSpline, OnCompleted) == 0x0000D0, "Member 'UGameplayTask_ScriptedMoveSpline::OnCompleted' has a wrong offset!");
static_assert(offsetof(UGameplayTask_ScriptedMoveSpline, Target) == 0x0000E0, "Member 'UGameplayTask_ScriptedMoveSpline::Target' has a wrong offset!");
static_assert(offsetof(UGameplayTask_ScriptedMoveSpline, SplineComponent) == 0x0000E8, "Member 'UGameplayTask_ScriptedMoveSpline::SplineComponent' has a wrong offset!");
static_assert(offsetof(UGameplayTask_ScriptedMoveSpline, StanceProvider) == 0x0000F0, "Member 'UGameplayTask_ScriptedMoveSpline::StanceProvider' has a wrong offset!");
static_assert(offsetof(UGameplayTask_ScriptedMoveSpline, LookAtActor) == 0x0000F8, "Member 'UGameplayTask_ScriptedMoveSpline::LookAtActor' has a wrong offset!");
static_assert(offsetof(UGameplayTask_ScriptedMoveSpline, OptionalAIAction) == 0x000100, "Member 'UGameplayTask_ScriptedMoveSpline::OptionalAIAction' has a wrong offset!");
static_assert(offsetof(UGameplayTask_ScriptedMoveSpline, DropOffSpawner) == 0x000108, "Member 'UGameplayTask_ScriptedMoveSpline::DropOffSpawner' has a wrong offset!");
static_assert(offsetof(UGameplayTask_ScriptedMoveSpline, NextSpline) == 0x000110, "Member 'UGameplayTask_ScriptedMoveSpline::NextSpline' has a wrong offset!");

// Class GbxAI.GameplayTask_ScriptedMoveToLevelSequence
// 0x00A0 (0x0160 - 0x00C0)
class UGameplayTask_ScriptedMoveToLevelSequence final : public UGameplayTask_ScriptedAction
{
public:
	UMulticastDelegateProperty_                   OnActorArrived;                                    // 0x00C0(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	UMulticastDelegateProperty_                   OnActorFailedToArrive;                             // 0x00D0(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	UMulticastDelegateProperty_                   OnAllActorsArrived;                                // 0x00E0(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	UMulticastDelegateProperty_                   OnCompleted;                                       // 0x00F0(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	UMulticastDelegateProperty_                   OnFailed;                                          // 0x0100(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	uint8                                         Pad_110[0x8];                                      // 0x0110(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	class AGbxLevelSequenceActor*                 LevelSequenceActor;                                // 0x0118(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_120[0x38];                                     // 0x0120(0x0038)(Fixing Size After Last Property [ Dumper-7 ])
	class UStanceDataProvider*                    StanceProvider;                                    // 0x0158(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)

public:
	static class UGameplayTask_ScriptedMoveToLevelSequence* BeginScriptedMoveToLevelSequence(class AActor* Target, class AGbxLevelSequenceActor* LevelSequenceActor_0, bool bStartSequence, class UStanceDataProvider* OptionalStance);
	static class UGameplayTask_ScriptedMoveToLevelSequence* BeginScriptedMoveToLevelSequenceMulti(const TArray<class AActor*>& Targets, class AGbxLevelSequenceActor* LevelSequenceActor_0, bool bStartSequence, class UStanceDataProvider* OptionalStance);

	void OnLevelSequenceFinished();
	void OnLevelSequenceStopped();
	void TaskScriptedMoveActorDelegate__DelegateSignature(class AActor* Actor);
	void TaskScriptedMoveActorsDelegate__DelegateSignature();
	void TaskScriptedMoveDelegate__DelegateSignature();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"GameplayTask_ScriptedMoveToLevelSequence">();
	}
	static class UGameplayTask_ScriptedMoveToLevelSequence* GetDefaultObj()
	{
		return GetDefaultObjImpl<UGameplayTask_ScriptedMoveToLevelSequence>();
	}
};
static_assert(alignof(UGameplayTask_ScriptedMoveToLevelSequence) == 0x000008, "Wrong alignment on UGameplayTask_ScriptedMoveToLevelSequence");
static_assert(sizeof(UGameplayTask_ScriptedMoveToLevelSequence) == 0x000160, "Wrong size on UGameplayTask_ScriptedMoveToLevelSequence");
static_assert(offsetof(UGameplayTask_ScriptedMoveToLevelSequence, OnActorArrived) == 0x0000C0, "Member 'UGameplayTask_ScriptedMoveToLevelSequence::OnActorArrived' has a wrong offset!");
static_assert(offsetof(UGameplayTask_ScriptedMoveToLevelSequence, OnActorFailedToArrive) == 0x0000D0, "Member 'UGameplayTask_ScriptedMoveToLevelSequence::OnActorFailedToArrive' has a wrong offset!");
static_assert(offsetof(UGameplayTask_ScriptedMoveToLevelSequence, OnAllActorsArrived) == 0x0000E0, "Member 'UGameplayTask_ScriptedMoveToLevelSequence::OnAllActorsArrived' has a wrong offset!");
static_assert(offsetof(UGameplayTask_ScriptedMoveToLevelSequence, OnCompleted) == 0x0000F0, "Member 'UGameplayTask_ScriptedMoveToLevelSequence::OnCompleted' has a wrong offset!");
static_assert(offsetof(UGameplayTask_ScriptedMoveToLevelSequence, OnFailed) == 0x000100, "Member 'UGameplayTask_ScriptedMoveToLevelSequence::OnFailed' has a wrong offset!");
static_assert(offsetof(UGameplayTask_ScriptedMoveToLevelSequence, LevelSequenceActor) == 0x000118, "Member 'UGameplayTask_ScriptedMoveToLevelSequence::LevelSequenceActor' has a wrong offset!");
static_assert(offsetof(UGameplayTask_ScriptedMoveToLevelSequence, StanceProvider) == 0x000158, "Member 'UGameplayTask_ScriptedMoveToLevelSequence::StanceProvider' has a wrong offset!");

// Class GbxAI.GameplayTask_SmartAction
// 0x0080 (0x0140 - 0x00C0)
class UGameplayTask_SmartAction final : public UGameplayTask_ScriptedAction
{
public:
	UMulticastDelegateProperty_                   OnReserve;                                         // 0x00C0(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	UMulticastDelegateProperty_                   OnUnreserve;                                       // 0x00D0(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	UMulticastDelegateProperty_                   OnBegin;                                           // 0x00E0(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	UMulticastDelegateProperty_                   OnInterrupt;                                       // 0x00F0(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	UMulticastDelegateProperty_                   OnSuccess;                                         // 0x0100(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	struct FSmartActionInfoContext                Action;                                            // 0x0110(0x0030)(NoDestructor, NativeAccessSpecifierPrivate)

public:
	static class UGameplayTask_SmartAction* BeginSmartAction(class AActor* User, class AActor* SmartObject, const struct FGameplayTag& ActionTag);
	static void EndSmartAction(class AActor* User);

	void AITaskEvent__DelegateSignature();
	void BeginCallback(class AActor* User, class AActor* SmartObject, const struct FGameplayTag& ActionTag);
	void InterruptCallback(class AActor* User, class AActor* SmartObject, const struct FGameplayTag& ActionTag);
	void ReserveCallback(class AActor* User, class AActor* SmartObject, const struct FGameplayTag& ActionTag);
	void SuccessCallback(class AActor* User, class AActor* SmartObject, const struct FGameplayTag& ActionTag);
	void UnreserveCallback(class AActor* User, class AActor* SmartObject, const struct FGameplayTag& ActionTag);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"GameplayTask_SmartAction">();
	}
	static class UGameplayTask_SmartAction* GetDefaultObj()
	{
		return GetDefaultObjImpl<UGameplayTask_SmartAction>();
	}
};
static_assert(alignof(UGameplayTask_SmartAction) == 0x000008, "Wrong alignment on UGameplayTask_SmartAction");
static_assert(sizeof(UGameplayTask_SmartAction) == 0x000140, "Wrong size on UGameplayTask_SmartAction");
static_assert(offsetof(UGameplayTask_SmartAction, OnReserve) == 0x0000C0, "Member 'UGameplayTask_SmartAction::OnReserve' has a wrong offset!");
static_assert(offsetof(UGameplayTask_SmartAction, OnUnreserve) == 0x0000D0, "Member 'UGameplayTask_SmartAction::OnUnreserve' has a wrong offset!");
static_assert(offsetof(UGameplayTask_SmartAction, OnBegin) == 0x0000E0, "Member 'UGameplayTask_SmartAction::OnBegin' has a wrong offset!");
static_assert(offsetof(UGameplayTask_SmartAction, OnInterrupt) == 0x0000F0, "Member 'UGameplayTask_SmartAction::OnInterrupt' has a wrong offset!");
static_assert(offsetof(UGameplayTask_SmartAction, OnSuccess) == 0x000100, "Member 'UGameplayTask_SmartAction::OnSuccess' has a wrong offset!");
static_assert(offsetof(UGameplayTask_SmartAction, Action) == 0x000110, "Member 'UGameplayTask_SmartAction::Action' has a wrong offset!");

// Class GbxAI.GbxAction_CoverTransition
// 0x0000 (0x0060 - 0x0060)
class UGbxAction_CoverTransition final : public UGbxAction
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"GbxAction_CoverTransition">();
	}
	static class UGbxAction_CoverTransition* GetDefaultObj()
	{
		return GetDefaultObjImpl<UGbxAction_CoverTransition>();
	}
};
static_assert(alignof(UGbxAction_CoverTransition) == 0x000008, "Wrong alignment on UGbxAction_CoverTransition");
static_assert(sizeof(UGbxAction_CoverTransition) == 0x000060, "Wrong size on UGbxAction_CoverTransition");

// Class GbxAI.GbxAction_NavAnim
// 0x00E8 (0x01A8 - 0x00C0)
class UGbxAction_NavAnim : public UGbxAction_Navigation
{
public:
	float                                         EntryTime;                                         // 0x00C0(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	float                                         BlendInTime;                                       // 0x00C4(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	float                                         BlendOutTime;                                      // 0x00C8(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_CC[0x4];                                       // 0x00CC(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class FName                                   AnimSlot;                                          // 0x00D0(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	struct FAnimMeshList                          NavAnimations;                                     // 0x00D8(0x0078)(Edit, NativeAccessSpecifierPrivate)
	bool                                          bLerpLocation;                                     // 0x0150(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	bool                                          bLerpRotation;                                     // 0x0151(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	bool                                          bUseStretchy;                                      // 0x0152(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_153[0x5];                                      // 0x0153(0x0005)(Fixing Size After Last Property [ Dumper-7 ])
	struct FStretchBonesSettings                  StretchBonesSettings;                              // 0x0158(0x0030)(Edit, DisableEditOnInstance, NoDestructor, NativeAccessSpecifierPrivate)
	class UAnimSequenceBase*                      NavAnim;                                           // 0x0188(0x0008)(ZeroConstructor, Deprecated, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	struct FAnimActionDef                         NavAnimation;                                      // 0x0190(0x0018)(Deprecated, NoDestructor, NativeAccessSpecifierPrivate)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"GbxAction_NavAnim">();
	}
	static class UGbxAction_NavAnim* GetDefaultObj()
	{
		return GetDefaultObjImpl<UGbxAction_NavAnim>();
	}
};
static_assert(alignof(UGbxAction_NavAnim) == 0x000008, "Wrong alignment on UGbxAction_NavAnim");
static_assert(sizeof(UGbxAction_NavAnim) == 0x0001A8, "Wrong size on UGbxAction_NavAnim");
static_assert(offsetof(UGbxAction_NavAnim, EntryTime) == 0x0000C0, "Member 'UGbxAction_NavAnim::EntryTime' has a wrong offset!");
static_assert(offsetof(UGbxAction_NavAnim, BlendInTime) == 0x0000C4, "Member 'UGbxAction_NavAnim::BlendInTime' has a wrong offset!");
static_assert(offsetof(UGbxAction_NavAnim, BlendOutTime) == 0x0000C8, "Member 'UGbxAction_NavAnim::BlendOutTime' has a wrong offset!");
static_assert(offsetof(UGbxAction_NavAnim, AnimSlot) == 0x0000D0, "Member 'UGbxAction_NavAnim::AnimSlot' has a wrong offset!");
static_assert(offsetof(UGbxAction_NavAnim, NavAnimations) == 0x0000D8, "Member 'UGbxAction_NavAnim::NavAnimations' has a wrong offset!");
static_assert(offsetof(UGbxAction_NavAnim, bLerpLocation) == 0x000150, "Member 'UGbxAction_NavAnim::bLerpLocation' has a wrong offset!");
static_assert(offsetof(UGbxAction_NavAnim, bLerpRotation) == 0x000151, "Member 'UGbxAction_NavAnim::bLerpRotation' has a wrong offset!");
static_assert(offsetof(UGbxAction_NavAnim, bUseStretchy) == 0x000152, "Member 'UGbxAction_NavAnim::bUseStretchy' has a wrong offset!");
static_assert(offsetof(UGbxAction_NavAnim, StretchBonesSettings) == 0x000158, "Member 'UGbxAction_NavAnim::StretchBonesSettings' has a wrong offset!");
static_assert(offsetof(UGbxAction_NavAnim, NavAnim) == 0x000188, "Member 'UGbxAction_NavAnim::NavAnim' has a wrong offset!");
static_assert(offsetof(UGbxAction_NavAnim, NavAnimation) == 0x000190, "Member 'UGbxAction_NavAnim::NavAnimation' has a wrong offset!");

// Class GbxAI.GbxAction_NavHomingJump
// 0x0008 (0x02F0 - 0x02E8)
class UGbxAction_NavHomingJump : public UGbxAction_NavJump
{
public:
	float                                         MaxHomingDistance;                                 // 0x02E8(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_2EC[0x4];                                      // 0x02EC(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"GbxAction_NavHomingJump">();
	}
	static class UGbxAction_NavHomingJump* GetDefaultObj()
	{
		return GetDefaultObjImpl<UGbxAction_NavHomingJump>();
	}
};
static_assert(alignof(UGbxAction_NavHomingJump) == 0x000008, "Wrong alignment on UGbxAction_NavHomingJump");
static_assert(sizeof(UGbxAction_NavHomingJump) == 0x0002F0, "Wrong size on UGbxAction_NavHomingJump");
static_assert(offsetof(UGbxAction_NavHomingJump, MaxHomingDistance) == 0x0002E8, "Member 'UGbxAction_NavHomingJump::MaxHomingDistance' has a wrong offset!");

// Class GbxAI.GbxAIBlueprintLibrary
// 0x0000 (0x0028 - 0x0028)
class UGbxAIBlueprintLibrary final : public UBlueprintFunctionLibrary
{
public:
	static bool AIIsWithinTerritory(class AActor* AIActor, ETerritoryType Zone);
	static void AIScriptedAction(class AActor* Actor, TSubclassOf<class UAIAction> Action);
	static void AIScriptedUseWeapon(class AActor* Actor, bool bUseWeapon);
	static bool GetBlackboardValueAsActorAndLocation(class UBTNode* BTNode, const struct FBlackboardKeySelector& Key, class AActor** Actor, struct FVector* Location);
	static bool GetValueAsActorAndLocation(class UBlackboardComponent* Blackboard, const struct FBlackboardKeySelector& Key, class AActor** Actor, struct FVector* Location);
	static bool IsActorThreatened(class AActor* InActor);
	static void ResetTeamForAllAIChildren(class AActor* Actor);
	static void SetAINavAreaData(class AActor* InActor, class UGbxNavAreaData* NavAreaData);
	static void SetAIPathFindingData(class AActor* InActor, class UHavokPathFindingData* PathFindingData);
	static void SetPerceivableToAllAI(class AActor* Actor, bool bPerceivable);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"GbxAIBlueprintLibrary">();
	}
	static class UGbxAIBlueprintLibrary* GetDefaultObj()
	{
		return GetDefaultObjImpl<UGbxAIBlueprintLibrary>();
	}
};
static_assert(alignof(UGbxAIBlueprintLibrary) == 0x000008, "Wrong alignment on UGbxAIBlueprintLibrary");
static_assert(sizeof(UGbxAIBlueprintLibrary) == 0x000028, "Wrong size on UGbxAIBlueprintLibrary");

// Class GbxAI.GbxAIController
// 0x0128 (0x06C0 - 0x0598)
class AGbxAIController : public AAIController
{
public:
	uint8                                         Pad_598[0x30];                                     // 0x0598(0x0030)(Fixing Size After Last Property [ Dumper-7 ])
	class AGbxCharacter*                          GbxCharacter;                                      // 0x05C8(0x0008)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	struct FVector                                SpawnLocation;                                     // 0x05D0(0x000C)(Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_5DC[0x4];                                      // 0x05DC(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class UGbxCharacterMovementComponent*         MovementComponent;                                 // 0x05E0(0x0008)(ExportObject, ZeroConstructor, Transient, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UTargetingComponent*                    TargetingComponent;                                // 0x05E8(0x0008)(ExportObject, ZeroConstructor, Transient, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UTargetableComponent*                   TargetableComponent;                               // 0x05F0(0x0008)(ExportObject, ZeroConstructor, Transient, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UTeamComponent*                         TeamComponent;                                     // 0x05F8(0x0008)(ExportObject, ZeroConstructor, Transient, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_600[0x8];                                      // 0x0600(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	class UAIActionComponent*                     AIActionComponent;                                 // 0x0608(0x0008)(Edit, ExportObject, ZeroConstructor, EditConst, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UTerritoryComponent*                    DefaultTerritory;                                  // 0x0610(0x0008)(ExportObject, ZeroConstructor, Transient, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UTerritoryComponent*                    CurrentTerritory;                                  // 0x0618(0x0008)(ExportObject, ZeroConstructor, Transient, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UGbxSpawnerComponent*                   SpawnerComponent;                                  // 0x0620(0x0008)(ExportObject, ZeroConstructor, Transient, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UGbxNavComponent*                       GbxNavComponent;                                   // 0x0628(0x0008)(Edit, ExportObject, ZeroConstructor, EditConst, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UAIUseComponent*                        AIUseComponent;                                    // 0x0630(0x0008)(Edit, ExportObject, ZeroConstructor, EditConst, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	TArray<class UAIWeaponUserComponent*>         WeaponUserComponents;                              // 0x0638(0x0010)(ExportObject, ZeroConstructor, Transient, ContainsInstancedReference, NativeAccessSpecifierPrivate)
	class UGbxActionComponent*                    GbxActionComponent;                                // 0x0648(0x0008)(ExportObject, ZeroConstructor, Transient, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	TArray<class AActor*>                         ChildActors;                                       // 0x0650(0x0010)(ZeroConstructor, Transient, NativeAccessSpecifierPrivate)
	uint8                                         Pad_660[0x8];                                      // 0x0660(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	UMulticastDelegateProperty_                   OnAggro;                                           // 0x0668(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPrivate)
	UMulticastDelegateProperty_                   OnDeAggro;                                         // 0x0678(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPrivate)
	uint8                                         Pad_688[0x30];                                     // 0x0688(0x0030)(Fixing Size After Last Property [ Dumper-7 ])
	class UGbxLevelSequencePlayer*                LevelSequencePlayerController;                     // 0x06B8(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

public:
	void AddChildActor(class AActor* NewChild);
	void AddChildActors(const TArray<class AActor*>& NewChildren);
	void CheckPauseWhileFalling(class ACharacter* TheCharacter, EMovementMode PrevMovementMode, uint8 PreviousCustomMode);
	void ChildDestroyed(class AActor* DestroyedActor);
	void OnMyWeaponHitSomething(class AActor* HitActor, const struct FVector& HitLocation);
	void ResetTerritoryToDefault();
	void SetObstacleAvoidanceLock(bool bDisable, const class FName& Reason);
	void SetTerritory(class UTerritoryComponent* Territory);

	class UAIActionComponent* GetAIActionComponent() const;
	void GetAIGroupList(TArray<class AActor*>* AIGroupList, bool bIncludeSelf, float InRadius) const;
	int32 GetAIGroupSize() const;
	class UBlackboardData* GetBlackboardAsset() const;
	class UBlackboardComponent* GetBlackboardComponent() const;
	const TArray<class AActor*> GetChildActors() const;
	class UGbxActionComponent* GetGbxActionComponent() const;
	class AGbxCharacter* GetGbxCharacter() const;
	class UAIGroupState* GetGroupState() const;
	class UGbxCharacterMovementComponent* GetMovementComponent() const;
	class UGbxNavComponent* GetNavComponent() const;
	int32 GetNumChildActors() const;
	const class UAIPerceptionComponent* GetPerceptionComponent() const;
	class ASpawner* GetSpawner() const;
	class USpawnerComponent* GetSpawnerComponent() const;
	class UTargetableComponent* GetTargetableComponent() const;
	class UTargetingComponent* GetTargetingComponent() const;
	class UTeam* GetTeam() const;
	class UTeamComponent* GetTeamComponent() const;
	class UTerritoryComponent* GetTerritory() const;
	class UAIUseComponent* GetUseComponent() const;
	class UAIWeaponUserComponent* GetWeaponUserComponent() const;
	void SetTeam(class UTeam* Team) const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"GbxAIController">();
	}
	static class AGbxAIController* GetDefaultObj()
	{
		return GetDefaultObjImpl<AGbxAIController>();
	}
};
static_assert(alignof(AGbxAIController) == 0x000008, "Wrong alignment on AGbxAIController");
static_assert(sizeof(AGbxAIController) == 0x0006C0, "Wrong size on AGbxAIController");
static_assert(offsetof(AGbxAIController, GbxCharacter) == 0x0005C8, "Member 'AGbxAIController::GbxCharacter' has a wrong offset!");
static_assert(offsetof(AGbxAIController, SpawnLocation) == 0x0005D0, "Member 'AGbxAIController::SpawnLocation' has a wrong offset!");
static_assert(offsetof(AGbxAIController, MovementComponent) == 0x0005E0, "Member 'AGbxAIController::MovementComponent' has a wrong offset!");
static_assert(offsetof(AGbxAIController, TargetingComponent) == 0x0005E8, "Member 'AGbxAIController::TargetingComponent' has a wrong offset!");
static_assert(offsetof(AGbxAIController, TargetableComponent) == 0x0005F0, "Member 'AGbxAIController::TargetableComponent' has a wrong offset!");
static_assert(offsetof(AGbxAIController, TeamComponent) == 0x0005F8, "Member 'AGbxAIController::TeamComponent' has a wrong offset!");
static_assert(offsetof(AGbxAIController, AIActionComponent) == 0x000608, "Member 'AGbxAIController::AIActionComponent' has a wrong offset!");
static_assert(offsetof(AGbxAIController, DefaultTerritory) == 0x000610, "Member 'AGbxAIController::DefaultTerritory' has a wrong offset!");
static_assert(offsetof(AGbxAIController, CurrentTerritory) == 0x000618, "Member 'AGbxAIController::CurrentTerritory' has a wrong offset!");
static_assert(offsetof(AGbxAIController, SpawnerComponent) == 0x000620, "Member 'AGbxAIController::SpawnerComponent' has a wrong offset!");
static_assert(offsetof(AGbxAIController, GbxNavComponent) == 0x000628, "Member 'AGbxAIController::GbxNavComponent' has a wrong offset!");
static_assert(offsetof(AGbxAIController, AIUseComponent) == 0x000630, "Member 'AGbxAIController::AIUseComponent' has a wrong offset!");
static_assert(offsetof(AGbxAIController, WeaponUserComponents) == 0x000638, "Member 'AGbxAIController::WeaponUserComponents' has a wrong offset!");
static_assert(offsetof(AGbxAIController, GbxActionComponent) == 0x000648, "Member 'AGbxAIController::GbxActionComponent' has a wrong offset!");
static_assert(offsetof(AGbxAIController, ChildActors) == 0x000650, "Member 'AGbxAIController::ChildActors' has a wrong offset!");
static_assert(offsetof(AGbxAIController, OnAggro) == 0x000668, "Member 'AGbxAIController::OnAggro' has a wrong offset!");
static_assert(offsetof(AGbxAIController, OnDeAggro) == 0x000678, "Member 'AGbxAIController::OnDeAggro' has a wrong offset!");
static_assert(offsetof(AGbxAIController, LevelSequencePlayerController) == 0x0006B8, "Member 'AGbxAIController::LevelSequencePlayerController' has a wrong offset!");

// Class GbxAI.GbxAINavSystem
// 0x0000 (0x0438 - 0x0438)
class UGbxAINavSystem final : public UGbxNavSystem
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"GbxAINavSystem">();
	}
	static class UGbxAINavSystem* GetDefaultObj()
	{
		return GetDefaultObjImpl<UGbxAINavSystem>();
	}
};
static_assert(alignof(UGbxAINavSystem) == 0x000008, "Wrong alignment on UGbxAINavSystem");
static_assert(sizeof(UGbxAINavSystem) == 0x000438, "Wrong size on UGbxAINavSystem");

// Class GbxAI.GbxCondition_AI_IsMoving
// 0x0008 (0x0090 - 0x0088)
class UGbxCondition_AI_IsMoving final : public UGbxCondition
{
public:
	float                                         SpeedThreshold;                                    // 0x0088(0x0004)(Edit, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_8C[0x4];                                       // 0x008C(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"GbxCondition_AI_IsMoving">();
	}
	static class UGbxCondition_AI_IsMoving* GetDefaultObj()
	{
		return GetDefaultObjImpl<UGbxCondition_AI_IsMoving>();
	}
};
static_assert(alignof(UGbxCondition_AI_IsMoving) == 0x000008, "Wrong alignment on UGbxCondition_AI_IsMoving");
static_assert(sizeof(UGbxCondition_AI_IsMoving) == 0x000090, "Wrong size on UGbxCondition_AI_IsMoving");
static_assert(offsetof(UGbxCondition_AI_IsMoving, SpeedThreshold) == 0x000088, "Member 'UGbxCondition_AI_IsMoving::SpeedThreshold' has a wrong offset!");

// Class GbxAI.GbxCondition_AIHasNearbyAllies
// 0x0108 (0x0190 - 0x0088)
class UGbxCondition_AIHasNearbyAllies final : public UGbxCondition
{
public:
	struct FGbxParam                              AllyCount;                                         // 0x0088(0x0080)(Edit, BlueprintReadOnly, NoDestructor, ContainsInstancedReference, NativeAccessSpecifierPublic)
	struct FGbxParam                              Distance;                                          // 0x0108(0x0080)(Edit, BlueprintReadOnly, NoDestructor, ContainsInstancedReference, NativeAccessSpecifierPublic)
	bool                                          bUseDistance;                                      // 0x0188(0x0001)(Edit, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_189[0x7];                                      // 0x0189(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"GbxCondition_AIHasNearbyAllies">();
	}
	static class UGbxCondition_AIHasNearbyAllies* GetDefaultObj()
	{
		return GetDefaultObjImpl<UGbxCondition_AIHasNearbyAllies>();
	}
};
static_assert(alignof(UGbxCondition_AIHasNearbyAllies) == 0x000008, "Wrong alignment on UGbxCondition_AIHasNearbyAllies");
static_assert(sizeof(UGbxCondition_AIHasNearbyAllies) == 0x000190, "Wrong size on UGbxCondition_AIHasNearbyAllies");
static_assert(offsetof(UGbxCondition_AIHasNearbyAllies, AllyCount) == 0x000088, "Member 'UGbxCondition_AIHasNearbyAllies::AllyCount' has a wrong offset!");
static_assert(offsetof(UGbxCondition_AIHasNearbyAllies, Distance) == 0x000108, "Member 'UGbxCondition_AIHasNearbyAllies::Distance' has a wrong offset!");
static_assert(offsetof(UGbxCondition_AIHasNearbyAllies, bUseDistance) == 0x000188, "Member 'UGbxCondition_AIHasNearbyAllies::bUseDistance' has a wrong offset!");

// Class GbxAI.GbxCondition_BlackboardKey
// 0x0018 (0x00A0 - 0x0088)
class UGbxCondition_BlackboardKey final : public UGbxCondition
{
public:
	struct FGbxBlackboardKeySelector              Key;                                               // 0x0088(0x0010)(Edit, BlueprintReadOnly, NoDestructor, NativeAccessSpecifierPrivate)
	bool                                          bInvertResult;                                     // 0x0098(0x0001)(Edit, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_99[0x7];                                       // 0x0099(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"GbxCondition_BlackboardKey">();
	}
	static class UGbxCondition_BlackboardKey* GetDefaultObj()
	{
		return GetDefaultObjImpl<UGbxCondition_BlackboardKey>();
	}
};
static_assert(alignof(UGbxCondition_BlackboardKey) == 0x000008, "Wrong alignment on UGbxCondition_BlackboardKey");
static_assert(sizeof(UGbxCondition_BlackboardKey) == 0x0000A0, "Wrong size on UGbxCondition_BlackboardKey");
static_assert(offsetof(UGbxCondition_BlackboardKey, Key) == 0x000088, "Member 'UGbxCondition_BlackboardKey::Key' has a wrong offset!");
static_assert(offsetof(UGbxCondition_BlackboardKey, bInvertResult) == 0x000098, "Member 'UGbxCondition_BlackboardKey::bInvertResult' has a wrong offset!");

// Class GbxAI.GbxCondition_HasEnemyTarget
// 0x0000 (0x0088 - 0x0088)
class UGbxCondition_HasEnemyTarget final : public UGbxCondition
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"GbxCondition_HasEnemyTarget">();
	}
	static class UGbxCondition_HasEnemyTarget* GetDefaultObj()
	{
		return GetDefaultObjImpl<UGbxCondition_HasEnemyTarget>();
	}
};
static_assert(alignof(UGbxCondition_HasEnemyTarget) == 0x000008, "Wrong alignment on UGbxCondition_HasEnemyTarget");
static_assert(sizeof(UGbxCondition_HasEnemyTarget) == 0x000088, "Wrong size on UGbxCondition_HasEnemyTarget");

// Class GbxAI.GbxCondition_HasFriendlyTarget
// 0x0000 (0x0088 - 0x0088)
class UGbxCondition_HasFriendlyTarget final : public UGbxCondition
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"GbxCondition_HasFriendlyTarget">();
	}
	static class UGbxCondition_HasFriendlyTarget* GetDefaultObj()
	{
		return GetDefaultObjImpl<UGbxCondition_HasFriendlyTarget>();
	}
};
static_assert(alignof(UGbxCondition_HasFriendlyTarget) == 0x000008, "Wrong alignment on UGbxCondition_HasFriendlyTarget");
static_assert(sizeof(UGbxCondition_HasFriendlyTarget) == 0x000088, "Wrong size on UGbxCondition_HasFriendlyTarget");

// Class GbxAI.GbxCondition_HasPlayerTarget
// 0x0000 (0x0088 - 0x0088)
class UGbxCondition_HasPlayerTarget final : public UGbxCondition
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"GbxCondition_HasPlayerTarget">();
	}
	static class UGbxCondition_HasPlayerTarget* GetDefaultObj()
	{
		return GetDefaultObjImpl<UGbxCondition_HasPlayerTarget>();
	}
};
static_assert(alignof(UGbxCondition_HasPlayerTarget) == 0x000008, "Wrong alignment on UGbxCondition_HasPlayerTarget");
static_assert(sizeof(UGbxCondition_HasPlayerTarget) == 0x000088, "Wrong size on UGbxCondition_HasPlayerTarget");

// Class GbxAI.GbxCondition_IsActorThreatened
// 0x0000 (0x0088 - 0x0088)
class UGbxCondition_IsActorThreatened final : public UGbxCondition
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"GbxCondition_IsActorThreatened">();
	}
	static class UGbxCondition_IsActorThreatened* GetDefaultObj()
	{
		return GetDefaultObjImpl<UGbxCondition_IsActorThreatened>();
	}
};
static_assert(alignof(UGbxCondition_IsActorThreatened) == 0x000008, "Wrong alignment on UGbxCondition_IsActorThreatened");
static_assert(sizeof(UGbxCondition_IsActorThreatened) == 0x000088, "Wrong size on UGbxCondition_IsActorThreatened");

// Class GbxAI.GbxCondition_IsAttachedToOtherActor
// 0x0000 (0x0088 - 0x0088)
class UGbxCondition_IsAttachedToOtherActor final : public UGbxCondition
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"GbxCondition_IsAttachedToOtherActor">();
	}
	static class UGbxCondition_IsAttachedToOtherActor* GetDefaultObj()
	{
		return GetDefaultObjImpl<UGbxCondition_IsAttachedToOtherActor>();
	}
};
static_assert(alignof(UGbxCondition_IsAttachedToOtherActor) == 0x000008, "Wrong alignment on UGbxCondition_IsAttachedToOtherActor");
static_assert(sizeof(UGbxCondition_IsAttachedToOtherActor) == 0x000088, "Wrong size on UGbxCondition_IsAttachedToOtherActor");

// Class GbxAI.GbxCondition_IsCloaked
// 0x0000 (0x0088 - 0x0088)
class UGbxCondition_IsCloaked final : public UGbxCondition
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"GbxCondition_IsCloaked">();
	}
	static class UGbxCondition_IsCloaked* GetDefaultObj()
	{
		return GetDefaultObjImpl<UGbxCondition_IsCloaked>();
	}
};
static_assert(alignof(UGbxCondition_IsCloaked) == 0x000008, "Wrong alignment on UGbxCondition_IsCloaked");
static_assert(sizeof(UGbxCondition_IsCloaked) == 0x000088, "Wrong size on UGbxCondition_IsCloaked");

// Class GbxAI.GbxCondition_IsInCover
// 0x0000 (0x0088 - 0x0088)
class UGbxCondition_IsInCover final : public UGbxCondition
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"GbxCondition_IsInCover">();
	}
	static class UGbxCondition_IsInCover* GetDefaultObj()
	{
		return GetDefaultObjImpl<UGbxCondition_IsInCover>();
	}
};
static_assert(alignof(UGbxCondition_IsInCover) == 0x000008, "Wrong alignment on UGbxCondition_IsInCover");
static_assert(sizeof(UGbxCondition_IsInCover) == 0x000088, "Wrong size on UGbxCondition_IsInCover");

// Class GbxAI.GbxCondition_IsInStance
// 0x0010 (0x0098 - 0x0088)
class UGbxCondition_IsInStance final : public UGbxCondition
{
public:
	class UStanceType*                            StanceToMatch;                                     // 0x0088(0x0008)(Edit, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	float                                         OptionalSpeedThreshold;                            // 0x0090(0x0004)(Edit, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_94[0x4];                                       // 0x0094(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"GbxCondition_IsInStance">();
	}
	static class UGbxCondition_IsInStance* GetDefaultObj()
	{
		return GetDefaultObjImpl<UGbxCondition_IsInStance>();
	}
};
static_assert(alignof(UGbxCondition_IsInStance) == 0x000008, "Wrong alignment on UGbxCondition_IsInStance");
static_assert(sizeof(UGbxCondition_IsInStance) == 0x000098, "Wrong size on UGbxCondition_IsInStance");
static_assert(offsetof(UGbxCondition_IsInStance, StanceToMatch) == 0x000088, "Member 'UGbxCondition_IsInStance::StanceToMatch' has a wrong offset!");
static_assert(offsetof(UGbxCondition_IsInStance, OptionalSpeedThreshold) == 0x000090, "Member 'UGbxCondition_IsInStance::OptionalSpeedThreshold' has a wrong offset!");

// Class GbxAI.GbxEqsTestingPawn
// 0x0030 (0x09D0 - 0x09A0)
class AGbxEqsTestingPawn final : public AEQSTestingPawn
{
public:
	class UGbxCharacterMovementComponent*         GbxCharacterMovement;                              // 0x09A0(0x0008)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, EditConst, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UTargetableComponent*                   TargetableComponent;                               // 0x09A8(0x0008)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, EditConst, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UDamageComponent*                       DamageComponent;                                   // 0x09B0(0x0008)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, EditConst, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UDamageCauserComponent*                 DamageCauserComponent;                             // 0x09B8(0x0008)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, EditConst, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UGameplayTagContainerComponent*         GameplayTagContainerComponent;                     // 0x09C0(0x0008)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, EditConst, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         BaseAimHeight;                                     // 0x09C8(0x0004)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         AimHeightFromGround;                               // 0x09CC(0x0004)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"GbxEqsTestingPawn">();
	}
	static class AGbxEqsTestingPawn* GetDefaultObj()
	{
		return GetDefaultObjImpl<AGbxEqsTestingPawn>();
	}
};
static_assert(alignof(AGbxEqsTestingPawn) == 0x000010, "Wrong alignment on AGbxEqsTestingPawn");
static_assert(sizeof(AGbxEqsTestingPawn) == 0x0009D0, "Wrong size on AGbxEqsTestingPawn");
static_assert(offsetof(AGbxEqsTestingPawn, GbxCharacterMovement) == 0x0009A0, "Member 'AGbxEqsTestingPawn::GbxCharacterMovement' has a wrong offset!");
static_assert(offsetof(AGbxEqsTestingPawn, TargetableComponent) == 0x0009A8, "Member 'AGbxEqsTestingPawn::TargetableComponent' has a wrong offset!");
static_assert(offsetof(AGbxEqsTestingPawn, DamageComponent) == 0x0009B0, "Member 'AGbxEqsTestingPawn::DamageComponent' has a wrong offset!");
static_assert(offsetof(AGbxEqsTestingPawn, DamageCauserComponent) == 0x0009B8, "Member 'AGbxEqsTestingPawn::DamageCauserComponent' has a wrong offset!");
static_assert(offsetof(AGbxEqsTestingPawn, GameplayTagContainerComponent) == 0x0009C0, "Member 'AGbxEqsTestingPawn::GameplayTagContainerComponent' has a wrong offset!");
static_assert(offsetof(AGbxEqsTestingPawn, BaseAimHeight) == 0x0009C8, "Member 'AGbxEqsTestingPawn::BaseAimHeight' has a wrong offset!");
static_assert(offsetof(AGbxEqsTestingPawn, AimHeightFromGround) == 0x0009CC, "Member 'AGbxEqsTestingPawn::AimHeightFromGround' has a wrong offset!");

// Class GbxAI.SmartObject
// 0x0010 (0x0468 - 0x0458)
class ASmartObject : public AActor
{
public:
	class USmartObjectComponent*                  SmartObjectComponent;                              // 0x0458(0x0008)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, EditConst, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UGbxActionComponent*                    GbxActionComponent;                                // 0x0460(0x0008)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, EditConst, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)

public:
	class UGbxActionComponent* GetGbxActionComponent();
	class USmartObjectComponent* GetSmartObjectComponent();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"SmartObject">();
	}
	static class ASmartObject* GetDefaultObj()
	{
		return GetDefaultObjImpl<ASmartObject>();
	}
};
static_assert(alignof(ASmartObject) == 0x000008, "Wrong alignment on ASmartObject");
static_assert(sizeof(ASmartObject) == 0x000468, "Wrong size on ASmartObject");
static_assert(offsetof(ASmartObject, SmartObjectComponent) == 0x000458, "Member 'ASmartObject::SmartObjectComponent' has a wrong offset!");
static_assert(offsetof(ASmartObject, GbxActionComponent) == 0x000460, "Member 'ASmartObject::GbxActionComponent' has a wrong offset!");

// Class GbxAI.GbxSmartObject
// 0x0000 (0x0468 - 0x0468)
class AGbxSmartObject final : public ASmartObject
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"GbxSmartObject">();
	}
	static class AGbxSmartObject* GetDefaultObj()
	{
		return GetDefaultObjImpl<AGbxSmartObject>();
	}
};
static_assert(alignof(AGbxSmartObject) == 0x000008, "Wrong alignment on AGbxSmartObject");
static_assert(sizeof(AGbxSmartObject) == 0x000468, "Wrong size on AGbxSmartObject");

// Class GbxAI.GbxSpawner
// 0x0048 (0x0630 - 0x05E8)
class AGbxSpawner : public ASpawner
{
public:
	uint8                                         Pad_5E8[0x18];                                     // 0x05E8(0x0018)(Fixing Size After Last Property [ Dumper-7 ])
	UMulticastDelegateProperty_                   OnThreatened;                                      // 0x0600(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	class UGbxSpawnerComponent*                   GbxSpawnerComponent;                               // 0x0610(0x0008)(ExportObject, ZeroConstructor, Transient, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class USpawnNodeComponent*                    SpawnNodeComponent;                                // 0x0618(0x0008)(Edit, ExportObject, ZeroConstructor, EditConst, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UBalanceStateComponent*                 BalanceStateComponent;                             // 0x0620(0x0008)(Edit, ExportObject, ZeroConstructor, EditConst, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UGameplayTasksComponent*                GameplayTasksComponent;                            // 0x0628(0x0008)(Edit, ExportObject, ZeroConstructor, EditConst, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)

public:
	bool DEPRECATED_IsThreatened() const;
	class UAIGroupState* GetAIGroupState() const;
	class UAINodeComponent* GetAINodeComponent() const;
	class UGameplayTasksComponent* GetGameplayTasksComponent() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"GbxSpawner">();
	}
	static class AGbxSpawner* GetDefaultObj()
	{
		return GetDefaultObjImpl<AGbxSpawner>();
	}
};
static_assert(alignof(AGbxSpawner) == 0x000008, "Wrong alignment on AGbxSpawner");
static_assert(sizeof(AGbxSpawner) == 0x000630, "Wrong size on AGbxSpawner");
static_assert(offsetof(AGbxSpawner, OnThreatened) == 0x000600, "Member 'AGbxSpawner::OnThreatened' has a wrong offset!");
static_assert(offsetof(AGbxSpawner, GbxSpawnerComponent) == 0x000610, "Member 'AGbxSpawner::GbxSpawnerComponent' has a wrong offset!");
static_assert(offsetof(AGbxSpawner, SpawnNodeComponent) == 0x000618, "Member 'AGbxSpawner::SpawnNodeComponent' has a wrong offset!");
static_assert(offsetof(AGbxSpawner, BalanceStateComponent) == 0x000620, "Member 'AGbxSpawner::BalanceStateComponent' has a wrong offset!");
static_assert(offsetof(AGbxSpawner, GameplayTasksComponent) == 0x000628, "Member 'AGbxSpawner::GameplayTasksComponent' has a wrong offset!");

// Class GbxAI.GbxSpawnerComponent
// 0x0030 (0x09C0 - 0x0990)
class UGbxSpawnerComponent : public USpawnerComponent
{
public:
	class AGbxSpawner*                            GbxSpawner;                                        // 0x0990(0x0008)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class AGbxSpawner*                            GroupGbxSpawner;                                   // 0x0998(0x0008)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	struct FGameplayTagContainer                  AdditionalGameplayTags;                            // 0x09A0(0x0020)(Edit, NativeAccessSpecifierPrivate)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"GbxSpawnerComponent">();
	}
	static class UGbxSpawnerComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UGbxSpawnerComponent>();
	}
};
static_assert(alignof(UGbxSpawnerComponent) == 0x000008, "Wrong alignment on UGbxSpawnerComponent");
static_assert(sizeof(UGbxSpawnerComponent) == 0x0009C0, "Wrong size on UGbxSpawnerComponent");
static_assert(offsetof(UGbxSpawnerComponent, GbxSpawner) == 0x000990, "Member 'UGbxSpawnerComponent::GbxSpawner' has a wrong offset!");
static_assert(offsetof(UGbxSpawnerComponent, GroupGbxSpawner) == 0x000998, "Member 'UGbxSpawnerComponent::GroupGbxSpawner' has a wrong offset!");
static_assert(offsetof(UGbxSpawnerComponent, AdditionalGameplayTags) == 0x0009A0, "Member 'UGbxSpawnerComponent::AdditionalGameplayTags' has a wrong offset!");

// Class GbxAI.GbxSpawnPoint
// 0x0008 (0x04C8 - 0x04C0)
class AGbxSpawnPoint : public ASpawnPoint
{
public:
	class USpawnNodeComponent*                    SpawnNodeComponent;                                // 0x04C0(0x0008)(Edit, ExportObject, ZeroConstructor, EditConst, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)

public:
	static bool HasNavNearSpawnPointFor(class USpawnPointComponent* SpawnPointComp, class USpawnOptionData* SpawnOptions);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"GbxSpawnPoint">();
	}
	static class AGbxSpawnPoint* GetDefaultObj()
	{
		return GetDefaultObjImpl<AGbxSpawnPoint>();
	}
};
static_assert(alignof(AGbxSpawnPoint) == 0x000008, "Wrong alignment on AGbxSpawnPoint");
static_assert(sizeof(AGbxSpawnPoint) == 0x0004C8, "Wrong size on AGbxSpawnPoint");
static_assert(offsetof(AGbxSpawnPoint, SpawnNodeComponent) == 0x0004C0, "Member 'AGbxSpawnPoint::SpawnNodeComponent' has a wrong offset!");

// Class GbxAI.LookAtPoint
// 0x0008 (0x0460 - 0x0458)
class ALookAtPoint final : public AActor
{
public:
	class ULookAtPointComponent*                  LookAtPointComponent;                              // 0x0458(0x0008)(Edit, ExportObject, ZeroConstructor, EditConst, InstancedReference, IsPlainOldData, NoDestructor, PersistentInstance, HasGetValueTypeHash, NativeAccessSpecifierPrivate)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"LookAtPoint">();
	}
	static class ALookAtPoint* GetDefaultObj()
	{
		return GetDefaultObjImpl<ALookAtPoint>();
	}
};
static_assert(alignof(ALookAtPoint) == 0x000008, "Wrong alignment on ALookAtPoint");
static_assert(sizeof(ALookAtPoint) == 0x000460, "Wrong size on ALookAtPoint");
static_assert(offsetof(ALookAtPoint, LookAtPointComponent) == 0x000458, "Member 'ALookAtPoint::LookAtPointComponent' has a wrong offset!");

// Class GbxAI.LookAtPointComponent
// 0x01A0 (0x0890 - 0x06F0)
class ULookAtPointComponent final : public UPrimitiveComponent
{
public:
	uint8                                         Pad_6F0[0x8];                                      // 0x06F0(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	class ULookAtPointTag*                        LookAtPointTag;                                    // 0x06F8(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	bool                                          bEnabled;                                          // 0x0700(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	bool                                          bSearchDataOverride;                               // 0x0701(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_702[0x2];                                      // 0x0702(0x0002)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         SearchHeightOverride;                              // 0x0704(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	float                                         SearchRadiusOverride;                              // 0x0708(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	bool                                          bUsageTimeOverride;                                // 0x070C(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_70D[0x3];                                      // 0x070D(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	struct FGbxParam                              UsageTimeOverride;                                 // 0x0710(0x0080)(Edit, NoDestructor, ContainsInstancedReference, NativeAccessSpecifierPrivate)
	bool                                          bUserCooldownTimeOverride;                         // 0x0790(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_791[0x7];                                      // 0x0791(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	struct FGbxParam                              UserCooldownTimeOverride;                          // 0x0798(0x0080)(Edit, NoDestructor, ContainsInstancedReference, NativeAccessSpecifierPrivate)
	TMap<class AController*, float>               CooldownMap;                                       // 0x0818(0x0050)(ZeroConstructor, Transient, NativeAccessSpecifierPrivate)
	TArray<struct FSmartObjectUseRequest>         UserList;                                          // 0x0868(0x0010)(ZeroConstructor, Transient, NativeAccessSpecifierPrivate)
	uint8                                         Pad_878[0x18];                                     // 0x0878(0x0018)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"LookAtPointComponent">();
	}
	static class ULookAtPointComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<ULookAtPointComponent>();
	}
};
static_assert(alignof(ULookAtPointComponent) == 0x000008, "Wrong alignment on ULookAtPointComponent");
static_assert(sizeof(ULookAtPointComponent) == 0x000890, "Wrong size on ULookAtPointComponent");
static_assert(offsetof(ULookAtPointComponent, LookAtPointTag) == 0x0006F8, "Member 'ULookAtPointComponent::LookAtPointTag' has a wrong offset!");
static_assert(offsetof(ULookAtPointComponent, bEnabled) == 0x000700, "Member 'ULookAtPointComponent::bEnabled' has a wrong offset!");
static_assert(offsetof(ULookAtPointComponent, bSearchDataOverride) == 0x000701, "Member 'ULookAtPointComponent::bSearchDataOverride' has a wrong offset!");
static_assert(offsetof(ULookAtPointComponent, SearchHeightOverride) == 0x000704, "Member 'ULookAtPointComponent::SearchHeightOverride' has a wrong offset!");
static_assert(offsetof(ULookAtPointComponent, SearchRadiusOverride) == 0x000708, "Member 'ULookAtPointComponent::SearchRadiusOverride' has a wrong offset!");
static_assert(offsetof(ULookAtPointComponent, bUsageTimeOverride) == 0x00070C, "Member 'ULookAtPointComponent::bUsageTimeOverride' has a wrong offset!");
static_assert(offsetof(ULookAtPointComponent, UsageTimeOverride) == 0x000710, "Member 'ULookAtPointComponent::UsageTimeOverride' has a wrong offset!");
static_assert(offsetof(ULookAtPointComponent, bUserCooldownTimeOverride) == 0x000790, "Member 'ULookAtPointComponent::bUserCooldownTimeOverride' has a wrong offset!");
static_assert(offsetof(ULookAtPointComponent, UserCooldownTimeOverride) == 0x000798, "Member 'ULookAtPointComponent::UserCooldownTimeOverride' has a wrong offset!");
static_assert(offsetof(ULookAtPointComponent, CooldownMap) == 0x000818, "Member 'ULookAtPointComponent::CooldownMap' has a wrong offset!");
static_assert(offsetof(ULookAtPointComponent, UserList) == 0x000868, "Member 'ULookAtPointComponent::UserList' has a wrong offset!");

// Class GbxAI.Perch
// 0x0008 (0x0460 - 0x0458)
class APerch final : public AActor
{
public:
	class UPerchComponent*                        PerchComponent;                                    // 0x0458(0x0008)(Edit, ExportObject, ZeroConstructor, EditConst, InstancedReference, IsPlainOldData, NoDestructor, PersistentInstance, HasGetValueTypeHash, NativeAccessSpecifierPrivate)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"Perch">();
	}
	static class APerch* GetDefaultObj()
	{
		return GetDefaultObjImpl<APerch>();
	}
};
static_assert(alignof(APerch) == 0x000008, "Wrong alignment on APerch");
static_assert(sizeof(APerch) == 0x000460, "Wrong size on APerch");
static_assert(offsetof(APerch, PerchComponent) == 0x000458, "Member 'APerch::PerchComponent' has a wrong offset!");

// Class GbxAI.PerchComponent
// 0x0250 (0x0940 - 0x06F0)
class UPerchComponent final : public UPrimitiveComponent
{
public:
	uint8                                         Pad_6F0[0x8];                                      // 0x06F0(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	class UPerchTag*                              PerchTag;                                          // 0x06F8(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	bool                                          bEnabled;                                          // 0x0700(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_701[0x3];                                      // 0x0701(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         SearchRadius;                                      // 0x0704(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	float                                         SearchHeight;                                      // 0x0708(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	float                                         UseRadius;                                         // 0x070C(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	bool                                          bUsageTimeOverride;                                // 0x0710(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_711[0x7];                                      // 0x0711(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	struct FGbxParam                              UsageTimeOverride;                                 // 0x0718(0x0080)(Edit, NoDestructor, ContainsInstancedReference, NativeAccessSpecifierPrivate)
	bool                                          bCooldownTimeOverride;                             // 0x0798(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_799[0x7];                                      // 0x0799(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	struct FGbxParam                              CooldownTimeOverride;                              // 0x07A0(0x0080)(Edit, NoDestructor, ContainsInstancedReference, NativeAccessSpecifierPrivate)
	bool                                          bUserCooldownTimeOverride;                         // 0x0820(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_821[0x7];                                      // 0x0821(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	struct FGbxParam                              UserCooldownTimeOverride;                          // 0x0828(0x0080)(Edit, NoDestructor, ContainsInstancedReference, NativeAccessSpecifierPrivate)
	struct FSmartObjectUseRequest                 Claimant;                                          // 0x08A8(0x0028)(Transient, NativeAccessSpecifierPrivate)
	float                                         CooldownTime;                                      // 0x08D0(0x0004)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_8D4[0x4];                                      // 0x08D4(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	TMap<class AAIController*, float>             CooldownMap;                                       // 0x08D8(0x0050)(ZeroConstructor, Transient, NativeAccessSpecifierPrivate)
	uint8                                         Pad_928[0x18];                                     // 0x0928(0x0018)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"PerchComponent">();
	}
	static class UPerchComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UPerchComponent>();
	}
};
static_assert(alignof(UPerchComponent) == 0x000008, "Wrong alignment on UPerchComponent");
static_assert(sizeof(UPerchComponent) == 0x000940, "Wrong size on UPerchComponent");
static_assert(offsetof(UPerchComponent, PerchTag) == 0x0006F8, "Member 'UPerchComponent::PerchTag' has a wrong offset!");
static_assert(offsetof(UPerchComponent, bEnabled) == 0x000700, "Member 'UPerchComponent::bEnabled' has a wrong offset!");
static_assert(offsetof(UPerchComponent, SearchRadius) == 0x000704, "Member 'UPerchComponent::SearchRadius' has a wrong offset!");
static_assert(offsetof(UPerchComponent, SearchHeight) == 0x000708, "Member 'UPerchComponent::SearchHeight' has a wrong offset!");
static_assert(offsetof(UPerchComponent, UseRadius) == 0x00070C, "Member 'UPerchComponent::UseRadius' has a wrong offset!");
static_assert(offsetof(UPerchComponent, bUsageTimeOverride) == 0x000710, "Member 'UPerchComponent::bUsageTimeOverride' has a wrong offset!");
static_assert(offsetof(UPerchComponent, UsageTimeOverride) == 0x000718, "Member 'UPerchComponent::UsageTimeOverride' has a wrong offset!");
static_assert(offsetof(UPerchComponent, bCooldownTimeOverride) == 0x000798, "Member 'UPerchComponent::bCooldownTimeOverride' has a wrong offset!");
static_assert(offsetof(UPerchComponent, CooldownTimeOverride) == 0x0007A0, "Member 'UPerchComponent::CooldownTimeOverride' has a wrong offset!");
static_assert(offsetof(UPerchComponent, bUserCooldownTimeOverride) == 0x000820, "Member 'UPerchComponent::bUserCooldownTimeOverride' has a wrong offset!");
static_assert(offsetof(UPerchComponent, UserCooldownTimeOverride) == 0x000828, "Member 'UPerchComponent::UserCooldownTimeOverride' has a wrong offset!");
static_assert(offsetof(UPerchComponent, Claimant) == 0x0008A8, "Member 'UPerchComponent::Claimant' has a wrong offset!");
static_assert(offsetof(UPerchComponent, CooldownTime) == 0x0008D0, "Member 'UPerchComponent::CooldownTime' has a wrong offset!");
static_assert(offsetof(UPerchComponent, CooldownMap) == 0x0008D8, "Member 'UPerchComponent::CooldownMap' has a wrong offset!");

// Class GbxAI.PerchTag
// 0x0190 (0x01C0 - 0x0030)
class UPerchTag final : public UGbxDataAsset
{
public:
	class UPerchType*                             PerchType;                                         // 0x0030(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FGameplayTag                           ActionType;                                        // 0x0038(0x0008)(Edit, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FGbxParam                              UsageTime;                                         // 0x0040(0x0080)(Edit, NoDestructor, ContainsInstancedReference, NativeAccessSpecifierPublic)
	struct FGbxParam                              CooldownTime;                                      // 0x00C0(0x0080)(Edit, NoDestructor, ContainsInstancedReference, NativeAccessSpecifierPublic)
	struct FGbxParam                              UserCooldownTime;                                  // 0x0140(0x0080)(Edit, NoDestructor, ContainsInstancedReference, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"PerchTag">();
	}
	static class UPerchTag* GetDefaultObj()
	{
		return GetDefaultObjImpl<UPerchTag>();
	}
};
static_assert(alignof(UPerchTag) == 0x000008, "Wrong alignment on UPerchTag");
static_assert(sizeof(UPerchTag) == 0x0001C0, "Wrong size on UPerchTag");
static_assert(offsetof(UPerchTag, PerchType) == 0x000030, "Member 'UPerchTag::PerchType' has a wrong offset!");
static_assert(offsetof(UPerchTag, ActionType) == 0x000038, "Member 'UPerchTag::ActionType' has a wrong offset!");
static_assert(offsetof(UPerchTag, UsageTime) == 0x000040, "Member 'UPerchTag::UsageTime' has a wrong offset!");
static_assert(offsetof(UPerchTag, CooldownTime) == 0x0000C0, "Member 'UPerchTag::CooldownTime' has a wrong offset!");
static_assert(offsetof(UPerchTag, UserCooldownTime) == 0x000140, "Member 'UPerchTag::UserCooldownTime' has a wrong offset!");

// Class GbxAI.ScriptedBehaviorTreeLibrary
// 0x0000 (0x0028 - 0x0028)
class UScriptedBehaviorTreeLibrary final : public UBlueprintFunctionLibrary
{
public:
	static void BeginScriptedLook(class AActor* Target, class AActor* LookAtActor, bool bAimAtActor, bool bFireWeaponAtActor, class UStanceDataProvider* OptionalStance);
	static void BeginScriptedWait(class AActor* Target, class UStanceDataProvider* OptionalStance);
	static void PerformScriptedAbort(class AActor* Target, bool bStopImmediately);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"ScriptedBehaviorTreeLibrary">();
	}
	static class UScriptedBehaviorTreeLibrary* GetDefaultObj()
	{
		return GetDefaultObjImpl<UScriptedBehaviorTreeLibrary>();
	}
};
static_assert(alignof(UScriptedBehaviorTreeLibrary) == 0x000008, "Wrong alignment on UScriptedBehaviorTreeLibrary");
static_assert(sizeof(UScriptedBehaviorTreeLibrary) == 0x000028, "Wrong size on UScriptedBehaviorTreeLibrary");

// Class GbxAI.SmartObjectAction
// 0x02A0 (0x02D0 - 0x0030)
class USmartObjectAction final : public UGbxDataAsset
{
public:
	bool                                          bPassiveAction;                                    // 0x0030(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bCombatAction;                                     // 0x0031(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_32[0x6];                                       // 0x0032(0x0006)(Fixing Size After Last Property [ Dumper-7 ])
	struct FGbxParam                              UseChance;                                         // 0x0038(0x0080)(Edit, NoDestructor, ContainsInstancedReference, NativeAccessSpecifierPublic)
	class UGbxCondition*                          UseCondition;                                      // 0x00B8(0x0008)(Edit, ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, PersistentInstance, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bUsageTime;                                        // 0x00C0(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_C1[0x7];                                       // 0x00C1(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	struct FGbxParam                              UsageTime;                                         // 0x00C8(0x0080)(Edit, NoDestructor, ContainsInstancedReference, NativeAccessSpecifierPublic)
	bool                                          bMaxUsers;                                         // 0x0148(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_149[0x3];                                      // 0x0149(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	int32                                         MaxUsers;                                          // 0x014C(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FGbxParam                              ActionCooldownTime;                                // 0x0150(0x0080)(Edit, NoDestructor, ContainsInstancedReference, NativeAccessSpecifierPublic)
	struct FGbxParam                              LocalUserCooldownTime;                             // 0x01D0(0x0080)(Edit, NoDestructor, ContainsInstancedReference, NativeAccessSpecifierPublic)
	struct FGbxParam                              GlobalUserCooldownTime;                            // 0x0250(0x0080)(Edit, NoDestructor, ContainsInstancedReference, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"SmartObjectAction">();
	}
	static class USmartObjectAction* GetDefaultObj()
	{
		return GetDefaultObjImpl<USmartObjectAction>();
	}
};
static_assert(alignof(USmartObjectAction) == 0x000008, "Wrong alignment on USmartObjectAction");
static_assert(sizeof(USmartObjectAction) == 0x0002D0, "Wrong size on USmartObjectAction");
static_assert(offsetof(USmartObjectAction, bPassiveAction) == 0x000030, "Member 'USmartObjectAction::bPassiveAction' has a wrong offset!");
static_assert(offsetof(USmartObjectAction, bCombatAction) == 0x000031, "Member 'USmartObjectAction::bCombatAction' has a wrong offset!");
static_assert(offsetof(USmartObjectAction, UseChance) == 0x000038, "Member 'USmartObjectAction::UseChance' has a wrong offset!");
static_assert(offsetof(USmartObjectAction, UseCondition) == 0x0000B8, "Member 'USmartObjectAction::UseCondition' has a wrong offset!");
static_assert(offsetof(USmartObjectAction, bUsageTime) == 0x0000C0, "Member 'USmartObjectAction::bUsageTime' has a wrong offset!");
static_assert(offsetof(USmartObjectAction, UsageTime) == 0x0000C8, "Member 'USmartObjectAction::UsageTime' has a wrong offset!");
static_assert(offsetof(USmartObjectAction, bMaxUsers) == 0x000148, "Member 'USmartObjectAction::bMaxUsers' has a wrong offset!");
static_assert(offsetof(USmartObjectAction, MaxUsers) == 0x00014C, "Member 'USmartObjectAction::MaxUsers' has a wrong offset!");
static_assert(offsetof(USmartObjectAction, ActionCooldownTime) == 0x000150, "Member 'USmartObjectAction::ActionCooldownTime' has a wrong offset!");
static_assert(offsetof(USmartObjectAction, LocalUserCooldownTime) == 0x0001D0, "Member 'USmartObjectAction::LocalUserCooldownTime' has a wrong offset!");
static_assert(offsetof(USmartObjectAction, GlobalUserCooldownTime) == 0x000250, "Member 'USmartObjectAction::GlobalUserCooldownTime' has a wrong offset!");

// Class GbxAI.AIResource_SmartObject
// 0x0000 (0x0038 - 0x0038)
class UAIResource_SmartObject final : public UGameplayTaskResource
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"AIResource_SmartObject">();
	}
	static class UAIResource_SmartObject* GetDefaultObj()
	{
		return GetDefaultObjImpl<UAIResource_SmartObject>();
	}
};
static_assert(alignof(UAIResource_SmartObject) == 0x000008, "Wrong alignment on UAIResource_SmartObject");
static_assert(sizeof(UAIResource_SmartObject) == 0x000038, "Wrong size on UAIResource_SmartObject");

// Class GbxAI.SmartObjectBlueprintLibrary
// 0x0000 (0x0028 - 0x0028)
class USmartObjectBlueprintLibrary final : public UBlueprintFunctionLibrary
{
public:
	static void AbortSmartObjectUse(class AActor* User);
	static bool UseSmartObject(class AActor* User, class AActor* SmartObject, const struct FGameplayTag& ActionTag, bool bAbortExisting, bool bUntilInterrupted);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"SmartObjectBlueprintLibrary">();
	}
	static class USmartObjectBlueprintLibrary* GetDefaultObj()
	{
		return GetDefaultObjImpl<USmartObjectBlueprintLibrary>();
	}
};
static_assert(alignof(USmartObjectBlueprintLibrary) == 0x000008, "Wrong alignment on USmartObjectBlueprintLibrary");
static_assert(sizeof(USmartObjectBlueprintLibrary) == 0x000028, "Wrong size on USmartObjectBlueprintLibrary");

// Class GbxAI.SmartObjectComponent
// 0x0350 (0x04C8 - 0x0178)
class USmartObjectComponent final : public UActorComponent
{
public:
	uint8                                         Pad_178[0x10];                                     // 0x0178(0x0010)(Fixing Size After Last Property [ Dumper-7 ])
	UMulticastDelegateProperty_                   OnActionReserved;                                  // 0x0188(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	UMulticastDelegateProperty_                   OnActionUsageBegan;                                // 0x0198(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	UMulticastDelegateProperty_                   OnObjectActionEnded;                               // 0x01A8(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	UMulticastDelegateProperty_                   OnActionUsageEnded;                                // 0x01B8(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	bool                                          bUseInRoutes;                                      // 0x01C8(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	ESmartObjectLookAtRule                        LookAtRule;                                        // 0x01C9(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1CA[0x6];                                      // 0x01CA(0x0006)(Fixing Size After Last Property [ Dumper-7 ])
	class FName                                   LookAtSocket;                                      // 0x01D0(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FGbxParam                              UseLookAtQuery;                                    // 0x01D8(0x0080)(Edit, NoDestructor, ContainsInstancedReference, NativeAccessSpecifierPublic)
	struct FGbxParam                              LookAtQueryDuration;                               // 0x0258(0x0080)(Edit, NoDestructor, ContainsInstancedReference, NativeAccessSpecifierPublic)
	struct FGbxParam                              LookAtQueryForgetDuration;                         // 0x02D8(0x0080)(Edit, NoDestructor, ContainsInstancedReference, NativeAccessSpecifierPublic)
	struct FGbxParam                              LookAtQueryPeriod;                                 // 0x0358(0x0080)(Edit, NoDestructor, ContainsInstancedReference, NativeAccessSpecifierPublic)
	struct FEnvQueryParams                        LookAtQuery;                                       // 0x03D8(0x00B8)(Edit, ContainsInstancedReference, NativeAccessSpecifierPublic)
	TArray<struct FSmartObjectActionState>        Actions;                                           // 0x0490(0x0010)(Edit, ZeroConstructor, ContainsInstancedReference, NativeAccessSpecifierPublic)
	TArray<class UAIUseSlotComponent*>            UseSlots;                                          // 0x04A0(0x0010)(ExportObject, ZeroConstructor, Transient, ContainsInstancedReference, NativeAccessSpecifierPublic)
	uint8                                         Pad_4B0[0x18];                                     // 0x04B0(0x0018)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void BeginEventSignature(class APawn* User);
	void DisableAction(const struct FGameplayTag& ActionTag);
	void DisableAllActions();
	void EnableAction(const struct FGameplayTag& ActionTag);
	void EnableAllActions();
	void InterruptEventSignature(class APawn* User);
	void OnActionEnded(EGbxActionEndState EndState, const struct FGameplayTag& ActionName, class AController* User);
	void ReserveEventSignature(class APawn* User);
	void SuccessEventSignature(class APawn* User);
	void ToggleActionSet(const struct FSmartObjectActionSet& ActionSet);
	void UnreserveEventSignature(class APawn* User);

	void GetActionUsers(const struct FGameplayTag& ActionTag, TArray<class APawn*>* OutUsers) const;
	void GetAvailableSocketNames(TArray<class FName>* Array) const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"SmartObjectComponent">();
	}
	static class USmartObjectComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<USmartObjectComponent>();
	}
};
static_assert(alignof(USmartObjectComponent) == 0x000008, "Wrong alignment on USmartObjectComponent");
static_assert(sizeof(USmartObjectComponent) == 0x0004C8, "Wrong size on USmartObjectComponent");
static_assert(offsetof(USmartObjectComponent, OnActionReserved) == 0x000188, "Member 'USmartObjectComponent::OnActionReserved' has a wrong offset!");
static_assert(offsetof(USmartObjectComponent, OnActionUsageBegan) == 0x000198, "Member 'USmartObjectComponent::OnActionUsageBegan' has a wrong offset!");
static_assert(offsetof(USmartObjectComponent, OnObjectActionEnded) == 0x0001A8, "Member 'USmartObjectComponent::OnObjectActionEnded' has a wrong offset!");
static_assert(offsetof(USmartObjectComponent, OnActionUsageEnded) == 0x0001B8, "Member 'USmartObjectComponent::OnActionUsageEnded' has a wrong offset!");
static_assert(offsetof(USmartObjectComponent, bUseInRoutes) == 0x0001C8, "Member 'USmartObjectComponent::bUseInRoutes' has a wrong offset!");
static_assert(offsetof(USmartObjectComponent, LookAtRule) == 0x0001C9, "Member 'USmartObjectComponent::LookAtRule' has a wrong offset!");
static_assert(offsetof(USmartObjectComponent, LookAtSocket) == 0x0001D0, "Member 'USmartObjectComponent::LookAtSocket' has a wrong offset!");
static_assert(offsetof(USmartObjectComponent, UseLookAtQuery) == 0x0001D8, "Member 'USmartObjectComponent::UseLookAtQuery' has a wrong offset!");
static_assert(offsetof(USmartObjectComponent, LookAtQueryDuration) == 0x000258, "Member 'USmartObjectComponent::LookAtQueryDuration' has a wrong offset!");
static_assert(offsetof(USmartObjectComponent, LookAtQueryForgetDuration) == 0x0002D8, "Member 'USmartObjectComponent::LookAtQueryForgetDuration' has a wrong offset!");
static_assert(offsetof(USmartObjectComponent, LookAtQueryPeriod) == 0x000358, "Member 'USmartObjectComponent::LookAtQueryPeriod' has a wrong offset!");
static_assert(offsetof(USmartObjectComponent, LookAtQuery) == 0x0003D8, "Member 'USmartObjectComponent::LookAtQuery' has a wrong offset!");
static_assert(offsetof(USmartObjectComponent, Actions) == 0x000490, "Member 'USmartObjectComponent::Actions' has a wrong offset!");
static_assert(offsetof(USmartObjectComponent, UseSlots) == 0x0004A0, "Member 'USmartObjectComponent::UseSlots' has a wrong offset!");

// Class GbxAI.SmartObjectUser
// 0x0000 (0x0028 - 0x0028)
class ISmartObjectUser final : public IInterface
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"SmartObjectUser">();
	}
	static class ISmartObjectUser* GetDefaultObj()
	{
		return GetDefaultObjImpl<ISmartObjectUser>();
	}
};
static_assert(alignof(ISmartObjectUser) == 0x000008, "Wrong alignment on ISmartObjectUser");
static_assert(sizeof(ISmartObjectUser) == 0x000028, "Wrong size on ISmartObjectUser");

// Class GbxAI.SpawnBlueprintLibrary
// 0x0000 (0x0028 - 0x0028)
class USpawnBlueprintLibrary final : public UBlueprintFunctionLibrary
{
public:
	static class ASpawner* GenerateSpawnerByOwningSpawner(class AActor* Instigator, class USpawnerStyle* Style);
	static class ASpawner* GenerateSpawnerByRadius(class AActor* Instigator, class USpawnerStyle* Style, float Radius, ETeamAttitude MinRequiredAttitude);
	static void SetSpawnOptions(class AActor* SpawnerActor, class USpawnOptionData* SpawnOptions);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"SpawnBlueprintLibrary">();
	}
	static class USpawnBlueprintLibrary* GetDefaultObj()
	{
		return GetDefaultObjImpl<USpawnBlueprintLibrary>();
	}
};
static_assert(alignof(USpawnBlueprintLibrary) == 0x000008, "Wrong alignment on USpawnBlueprintLibrary");
static_assert(sizeof(USpawnBlueprintLibrary) == 0x000028, "Wrong size on USpawnBlueprintLibrary");

// Class GbxAI.SpawnNodeComponent
// 0x0008 (0x0790 - 0x0788)
class USpawnNodeComponent final : public UAINodeComponent
{
public:
	EInitialPathAction                            InitialPathAction;                                 // 0x0788(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_789[0x7];                                      // 0x0789(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"SpawnNodeComponent">();
	}
	static class USpawnNodeComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<USpawnNodeComponent>();
	}
};
static_assert(alignof(USpawnNodeComponent) == 0x000008, "Wrong alignment on USpawnNodeComponent");
static_assert(sizeof(USpawnNodeComponent) == 0x000790, "Wrong size on USpawnNodeComponent");
static_assert(offsetof(USpawnNodeComponent, InitialPathAction) == 0x000788, "Member 'USpawnNodeComponent::InitialPathAction' has a wrong offset!");

}

