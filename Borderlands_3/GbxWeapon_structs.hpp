#pragma once

/*
* SDK generated by Dumper-7
*
* https://github.com/Encryqed/Dumper-7
*/

// Package: GbxWeapon

#include "Basic.hpp"

#include "Engine_structs.hpp"
#include "CoreUObject_structs.hpp"
#include "GbxGameSystemCore_structs.hpp"


namespace SDK
{

// Enum GbxWeapon.EGbxTrajectoryTraceShape
// NumValues: 0x0005
enum class EGbxTrajectoryTraceShape : uint8
{
	Line                                     = 0,
	Sphere                                   = 1,
	Capsule                                  = 2,
	Box                                      = 3,
	EGbxTrajectoryTraceShape_MAX             = 4,
};

// Enum GbxWeapon.EWeaponEquipType
// NumValues: 0x0004
enum class EWeaponEquipType : uint8
{
	Default                                  = 0,
	Instant                                  = 1,
	Custom                                   = 2,
	EWeaponEquipType_MAX                     = 3,
};

// Enum GbxWeapon.EWeaponPutDownType
// NumValues: 0x0003
enum class EWeaponPutDownType : uint8
{
	Default                                  = 0,
	Instant                                  = 1,
	EWeaponPutDownType_MAX                   = 2,
};

// Enum GbxWeapon.EWeaponShotModifierType
// NumValues: 0x0012
enum class EWeaponShotModifierType : uint8
{
	None                                     = 0,
	EngineType1                              = 1,
	EngineType2                              = 2,
	EngineType3                              = 3,
	EngineType4                              = 4,
	EngineType5                              = 5,
	EngineType6                              = 6,
	EngineType7                              = 7,
	EngineType8                              = 8,
	GameType1                                = 9,
	GameType2                                = 10,
	GameType3                                = 11,
	GameType4                                = 12,
	GameType5                                = 13,
	GameType6                                = 14,
	GameType7                                = 15,
	GameType8                                = 16,
	EWeaponShotModifierType_MAX              = 17,
};

// Enum GbxWeapon.ELightBeamQueryActorType
// NumValues: 0x0008
enum class ELightBeamQueryActorType : uint8
{
	Unfiltered                               = 0,
	DamageCauser                             = 1,
	Instigator                               = 2,
	Source                                   = 3,
	Target                                   = 4,
	SourceOrTarget                           = 5,
	SourceAndTarget                          = 6,
	ELightBeamQueryActorType_MAX             = 7,
};

// Enum GbxWeapon.ELightBeamLock
// NumValues: 0x0004
enum class ELightBeamLock : uint8
{
	Never                                    = 0,
	Always                                   = 1,
	LockOn                                   = 2,
	ELightBeamLock_MAX                       = 3,
};

// Enum GbxWeapon.ELightBeamFlag
// NumValues: 0x0010
enum class ELightBeamFlag : uint8
{
	ViewDependent                            = 0,
	Locked                                   = 1,
	FollowViewPoint                          = 2,
	DisableChaining                          = 3,
	LagCompensation                          = 4,
	EngineFlag3                              = 5,
	EngineFlag4                              = 6,
	EngineFlag5                              = 7,
	EngineFlag6                              = 8,
	EngineFlag7                              = 9,
	EngineFlag8                              = 10,
	GameFlag1                                = 11,
	GameFlag2                                = 12,
	GameFlag3                                = 13,
	GameFlag4                                = 14,
	ELightBeamFlag_MAX                       = 15,
};

// Enum GbxWeapon.ELightProjectileQueryActorType
// NumValues: 0x0007
enum class ELightProjectileQueryActorType : uint8
{
	Unfiltered                               = 0,
	DamageCauser                             = 1,
	Instigator                               = 2,
	Source                                   = 3,
	Target                                   = 4,
	Attached                                 = 5,
	ELightProjectileQueryActorType_MAX       = 6,
};

// Enum GbxWeapon.ELightProjectileSubdivisionMode
// NumValues: 0x0005
enum class ELightProjectileSubdivisionMode : uint32
{
	Distance                                 = 0,
	Seconds                                  = 1,
	Width                                    = 2,
	Count                                    = 3,
	ELightProjectileSubdivisionMode_MAX      = 4,
};

// Enum GbxWeapon.ELightProjectileTracerThrottleLevel
// NumValues: 0x0005
enum class ELightProjectileTracerThrottleLevel : uint8
{
	None                                     = 0,
	NPC                                      = 1,
	RemotePlayer                             = 2,
	LocalPlayer                              = 3,
	ELightProjectileTracerThrottleLevel_MAX  = 4,
};

// Enum GbxWeapon.ELightProjectileFlag
// NumValues: 0x0011
enum class ELightProjectileFlag : uint8
{
	OverrideStartRotation                    = 0,
	Homing                                   = 1,
	StartFromLocalSource                     = 2,
	BounceTowardsEnemy                       = 3,
	Magnetism                                = 4,
	Reflected                                = 5,
	Penetrated                               = 6,
	HideTracer                               = 7,
	LagCompensation                          = 8,
	TargetActorSet                           = 9,
	DisableTracerThrottling                  = 10,
	EngineFlag1                              = 11,
	GameFlag1                                = 12,
	GameFlag2                                = 13,
	GameFlag3                                = 14,
	GameFlag4                                = 15,
	ELightProjectileFlag_MAX                 = 16,
};

// Enum GbxWeapon.ELightProjectileSplitPattern
// NumValues: 0x0003
enum class ELightProjectileSplitPattern : uint8
{
	Cone                                     = 0,
	Fan                                      = 1,
	ELightProjectileSplitPattern_MAX         = 2,
};

// Enum GbxWeapon.EHitTypeEnum
// NumValues: 0x0004
enum class EHitTypeEnum : uint8
{
	Friendly                                 = 0,
	Enemy                                    = 1,
	Neutral                                  = 2,
	EHitTypeEnum_MAX                         = 3,
};

// Enum GbxWeapon.ERecoilEndOfPatternAction
// NumValues: 0x0005
enum class ERecoilEndOfPatternAction : uint8
{
	None                                     = 0,
	PingPong                                 = 1,
	Loop                                     = 2,
	Reset                                    = 3,
	ERecoilEndOfPatternAction_MAX            = 4,
};

// Enum GbxWeapon.EWeaponReloadEvent
// NumValues: 0x0003
enum class EWeaponReloadEvent : uint8
{
	Started                                  = 0,
	Ended                                    = 1,
	EWeaponReloadEvent_MAX                   = 2,
};

// Enum GbxWeapon.EWeaponUseEvent
// NumValues: 0x0004
enum class EWeaponUseEvent : uint8
{
	UseStarted                               = 0,
	Used                                     = 1,
	UseFinished                              = 2,
	EWeaponUseEvent_MAX                      = 3,
};

// Enum GbxWeapon.EWeaponActionType
// NumValues: 0x0017
enum class EWeaponActionType : uint8
{
	EWAT_Default                             = 0,
	EWAT_Use                                 = 1,
	EWAT_Reload                              = 2,
	EWAT_Equip                               = 3,
	EWAT_PutDown                             = 4,
	EWAT_UseModeSwitch                       = 5,
	EWAT_Charge                              = 6,
	EWAT_Charged                             = 7,
	EWAT_Overcharged                         = 8,
	EWAT_ResetFireSequence                   = 9,
	EWAT_Discharge                           = 10,
	EWAT_EngineWeaponActionType6             = 11,
	EWAT_EngineWeaponActionType7             = 12,
	EWAT_EngineWeaponActionType8             = 13,
	EWAT_GameWeaponActionType1               = 14,
	EWAT_GameWeaponActionType2               = 15,
	EWAT_GameWeaponActionType3               = 16,
	EWAT_GameWeaponActionType4               = 17,
	EWAT_GameWeaponActionType5               = 18,
	EWAT_GameWeaponActionType6               = 19,
	EWAT_GameWeaponActionType7               = 20,
	EWAT_GameWeaponActionType8               = 21,
	EWAT_MAX                                 = 22,
};

// Enum GbxWeapon.EAmmoRegenType
// NumValues: 0x0004
enum class EAmmoRegenType : uint32
{
	Disabled                                 = 0,
	GenerateAmmo                             = 1,
	RefillLoadedAmmo                         = 2,
	EAmmoRegenType_MAX                       = 3,
};

// Enum GbxWeapon.EWeaponChargeEventType
// NumValues: 0x0004
enum class EWeaponChargeEventType : uint8
{
	BlueprintEvent                           = 0,
	EnableParticleEmitter                    = 1,
	DisableParticleEmitter                   = 2,
	EWeaponChargeEventType_MAX               = 3,
};

// Enum GbxWeapon.EWeaponChargeComparisonOperatorType
// NumValues: 0x0005
enum class EWeaponChargeComparisonOperatorType : uint8
{
	LessThan                                 = 0,
	LessThanOrEqual                          = 1,
	GreaterThan                              = 2,
	GreaterThanOrEqual                       = 3,
	EWeaponChargeComparisonOperatorType_MAX  = 4,
};

// Enum GbxWeapon.EWeaponChargeState
// NumValues: 0x0006
enum class EWeaponChargeState : uint8
{
	None                                     = 0,
	Discharging                              = 1,
	Charging                                 = 2,
	Charged                                  = 3,
	Overcharged                              = 4,
	EWeaponChargeState_MAX                   = 5,
};

// Enum GbxWeapon.EWeaponSkeletalControlEvent
// NumValues: 0x000B
enum class EWeaponSkeletalControlEvent : uint8
{
	Pause                                    = 0,
	Resume                                   = 1,
	Reset                                    = 2,
	CacheState                               = 3,
	RestoreState                             = 4,
	CacheStateAndReset                       = 5,
	ResetAndPause                            = 6,
	SetInput                                 = 7,
	AddInput                                 = 8,
	ReturnToDefault                          = 9,
	EWeaponSkeletalControlEvent_MAX          = 10,
};

// Enum GbxWeapon.EWeaponMaterialEffectBlendMode
// NumValues: 0x0006
enum class EWeaponMaterialEffectBlendMode : uint8
{
	Multiply                                 = 0,
	Add                                      = 1,
	Replace                                  = 2,
	AddReplace                               = 3,
	EWAVT_MAX                                = 4,
	EWeaponMaterialEffectBlendMode_MAX       = 5,
};

// Enum GbxWeapon.EWeaponEffectFlag
// NumValues: 0x0007
enum class EWeaponEffectFlag : uint8
{
	AutoActivate                             = 0,
	PlayOnlyOnActiveSlot                     = 1,
	IgnoredByFXCoordinator                   = 2,
	HideWhenScoped                           = 3,
	SpawnOnlyWhenVisible                     = 4,
	PlayersOnly                              = 5,
	EWeaponEffectFlag_MAX                    = 6,
};

// Enum GbxWeapon.EWeaponTextureMipsSetting
// NumValues: 0x0004
enum class EWeaponTextureMipsSetting : uint8
{
	Default                                  = 0,
	High                                     = 1,
	VeryHigh                                 = 2,
	EWeaponTextureMipsSetting_MAX            = 3,
};

// Enum GbxWeapon.EWeaponAttachmentVisibilityType
// NumValues: 0x0004
enum class EWeaponAttachmentVisibilityType : uint8
{
	EWAVT_Both                               = 0,
	EWAVT_FirstPerson                        = 1,
	EWAVT_ThirdPerson                        = 2,
	EWAVT_MAX                                = 3,
};

// Enum GbxWeapon.EWeaponEffectType
// NumValues: 0x001C
enum class EWeaponEffectType : uint8
{
	EWET_Default                             = 0,
	EWET_Use                                 = 1,
	EWET_Charge                              = 2,
	EWET_Sight                               = 3,
	EWET_Charged                             = 4,
	EWET_Overcharged                         = 5,
	EWET_Discharge                           = 6,
	EWET_EngineWeaponEffectType4             = 7,
	EWET_EngineWeaponEffectType5             = 8,
	EWET_EngineWeaponEffectType6             = 9,
	EWET_EngineWeaponEffectType7             = 10,
	EWET_EngineWeaponEffectType8             = 11,
	EWET_GameWeaponEffectType1               = 12,
	EWET_GameWeaponEffectType2               = 13,
	EWET_GameWeaponEffectType3               = 14,
	EWET_GameWeaponEffectType4               = 15,
	EWET_GameWeaponEffectType5               = 16,
	EWET_GameWeaponEffectType6               = 17,
	EWET_GameWeaponEffectType7               = 18,
	EWET_GameWeaponEffectType8               = 19,
	EWET_GameWeaponEffectType9               = 20,
	EWET_GameWeaponEffectType10              = 21,
	EWET_GameWeaponEffectType11              = 22,
	EWET_GameWeaponEffectType12              = 23,
	EWET_GameWeaponEffectType13              = 24,
	EWET_GameWeaponEffectType14              = 25,
	EWET_GameWeaponEffectType15              = 26,
	EWET_MAX                                 = 27,
};

// Enum GbxWeapon.EWeaponFireRateState
// NumValues: 0x0004
enum class EWeaponFireRateState : uint32
{
	None                                     = 0,
	Accelerating                             = 1,
	Decelerating                             = 2,
	EWeaponFireRateState_MAX                 = 3,
};

// Enum GbxWeapon.EWeaponHeatComparisonOperatorType
// NumValues: 0x0005
enum class EWeaponHeatComparisonOperatorType : uint8
{
	LessThan                                 = 0,
	LessThanOrEqual                          = 1,
	GreaterThan                              = 2,
	GreaterThanOrEqual                       = 3,
	EWeaponHeatComparisonOperatorType_MAX    = 4,
};

// Enum GbxWeapon.EWeaponShotDamageModifierType
// NumValues: 0x0004
enum class EWeaponShotDamageModifierType : uint32
{
	Scale                                    = 0,
	Add                                      = 1,
	SimpleScale                              = 2,
	EWeaponShotDamageModifierType_MAX        = 3,
};

// Enum GbxWeapon.ESimpleMotionInputHandler
// NumValues: 0x0003
enum class ESimpleMotionInputHandler : uint8
{
	None                                     = 0,
	Set                                      = 1,
	ESimpleMotionInputHandler_MAX            = 2,
};

// Enum GbxWeapon.EWeaponTriggerFeedbackMode
// NumValues: 0x0005
enum class EWeaponTriggerFeedbackMode : uint8
{
	Off                                      = 0,
	Feedback                                 = 1,
	Weapon                                   = 2,
	Vibration                                = 3,
	EWeaponTriggerFeedbackMode_MAX           = 4,
};

// Enum GbxWeapon.EWeaponTypeDataTableType
// NumValues: 0x0003
enum class EWeaponTypeDataTableType : uint8
{
	BaseWeaponBalance                        = 0,
	ManufacturerDamageScale                  = 1,
	EWeaponTypeDataTableType_MAX             = 2,
};

// Enum GbxWeapon.EWeaponVisibleAmmoUpdateMethod
// NumValues: 0x0005
enum class EWeaponVisibleAmmoUpdateMethod : uint8
{
	Auto                                     = 0,
	Manual                                   = 1,
	AutoAdd                                  = 2,
	AutoRemove                               = 3,
	EWeaponVisibleAmmoUpdateMethod_MAX       = 4,
};

// Enum GbxWeapon.EWeaponVisibleAmmoState
// NumValues: 0x0004
enum class EWeaponVisibleAmmoState : uint8
{
	LoadedAmmo                               = 0,
	PendingLoadedAmmo                        = 1,
	Disabled                                 = 2,
	EWeaponVisibleAmmoState_MAX              = 3,
};

// Enum GbxWeapon.EWeaponZoomState
// NumValues: 0x0005
enum class EWeaponZoomState : uint8
{
	NotZoomed                                = 0,
	ZoomingIn                                = 1,
	Zoomed                                   = 2,
	ZoomingOut                               = 3,
	EWeaponZoomState_MAX                     = 4,
};

// ScriptStruct GbxWeapon.LightProjectileFlagName
// 0x0020 (0x0020 - 0x0000)
struct FLightProjectileFlagName final
{
public:
	ELightProjectileFlag                          Type;                                              // 0x0000(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1[0x7];                                        // 0x0001(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	class FName                                   Name;                                              // 0x0008(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FString                                 Tooltip;                                           // 0x0010(0x0010)(ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FLightProjectileFlagName) == 0x000008, "Wrong alignment on FLightProjectileFlagName");
static_assert(sizeof(FLightProjectileFlagName) == 0x000020, "Wrong size on FLightProjectileFlagName");
static_assert(offsetof(FLightProjectileFlagName, Type) == 0x000000, "Member 'FLightProjectileFlagName::Type' has a wrong offset!");
static_assert(offsetof(FLightProjectileFlagName, Name) == 0x000008, "Member 'FLightProjectileFlagName::Name' has a wrong offset!");
static_assert(offsetof(FLightProjectileFlagName, Tooltip) == 0x000010, "Member 'FLightProjectileFlagName::Tooltip' has a wrong offset!");

// ScriptStruct GbxWeapon.LightBeamAttachment
// 0x0028 (0x0028 - 0x0000)
struct FLightBeamAttachment final
{
public:
	class AActor*                                 Actor;                                             // 0x0000(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class USceneComponent*                        Component;                                         // 0x0008(0x0008)(Edit, BlueprintVisible, ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   Socket;                                            // 0x0010(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector_NetQuantize100                 LocationOffset;                                    // 0x0018(0x000C)(Edit, BlueprintVisible, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_24[0x4];                                       // 0x0024(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FLightBeamAttachment) == 0x000008, "Wrong alignment on FLightBeamAttachment");
static_assert(sizeof(FLightBeamAttachment) == 0x000028, "Wrong size on FLightBeamAttachment");
static_assert(offsetof(FLightBeamAttachment, Actor) == 0x000000, "Member 'FLightBeamAttachment::Actor' has a wrong offset!");
static_assert(offsetof(FLightBeamAttachment, Component) == 0x000008, "Member 'FLightBeamAttachment::Component' has a wrong offset!");
static_assert(offsetof(FLightBeamAttachment, Socket) == 0x000010, "Member 'FLightBeamAttachment::Socket' has a wrong offset!");
static_assert(offsetof(FLightBeamAttachment, LocationOffset) == 0x000018, "Member 'FLightBeamAttachment::LocationOffset' has a wrong offset!");

// ScriptStruct GbxWeapon.LightBeamInitializationData
// 0x0128 (0x0128 - 0x0000)
struct FLightBeamInitializationData
{
public:
	uint8                                         Pad_0[0x8];                                        // 0x0000(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	TSubclassOf<class ULightBeamData>             DataBlueprint;                                     // 0x0008(0x0008)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FLightBeamAttachment                   Source;                                            // 0x0010(0x0028)(BlueprintVisible, NoDestructor, ContainsInstancedReference, NativeAccessSpecifierPublic)
	struct FLightBeamAttachment                   Target;                                            // 0x0038(0x0028)(BlueprintVisible, NoDestructor, ContainsInstancedReference, NativeAccessSpecifierPublic)
	int32                                         Flags;                                             // 0x0060(0x0004)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_64[0x4];                                       // 0x0064(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class APawn*                                  Instigator;                                        // 0x0068(0x0008)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class AActor*                                 DamageCauser;                                      // 0x0070(0x0008)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         Damage;                                            // 0x0078(0x0004)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         DamageIntervalOverride;                            // 0x007C(0x0004)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UCurveFloat*                            DamageRampCurve;                                   // 0x0080(0x0008)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         DamageRampScale;                                   // 0x0088(0x0004)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_8C[0x4];                                       // 0x008C(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	TSubclassOf<class UGbxDamageType>             DamageType;                                        // 0x0090(0x0008)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TSubclassOf<class UDamageSource>              DamageSource;                                      // 0x0098(0x0008)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         DamageRadius;                                      // 0x00A0(0x0004)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_A4[0x4];                                       // 0x00A4(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	struct FForceSelection                        ImpactForce;                                       // 0x00A8(0x0020)(BlueprintVisible, NoDestructor, NativeAccessSpecifierPublic)
	class UImpactData*                            ImpactDataOverride;                                // 0x00C8(0x0008)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   NameId;                                            // 0x00D0(0x0008)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         Spread;                                            // 0x00D8(0x0004)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         LifetimeOverride;                                  // 0x00DC(0x0004)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EWeaponShotModifierType                       ModifierType;                                      // 0x00E0(0x0001)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_E1[0x17];                                      // 0x00E1(0x0017)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         ModifierValue;                                     // 0x00F8(0x0004)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FCriticalHitDamageOverrides            CriticalHitOverrides;                              // 0x00FC(0x0008)(BlueprintVisible, NoDestructor, NativeAccessSpecifierPublic)
	struct FDamageGoreModifiers                   GoreModifiers;                                     // 0x0104(0x0008)(BlueprintVisible, NoDestructor, NativeAccessSpecifierPublic)
	uint8                                         Pad_10C[0x4];                                      // 0x010C(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class ULightBeam*                             ParentBeam;                                        // 0x0110(0x0008)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_118[0x10];                                     // 0x0118(0x0010)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FLightBeamInitializationData) == 0x000008, "Wrong alignment on FLightBeamInitializationData");
static_assert(sizeof(FLightBeamInitializationData) == 0x000128, "Wrong size on FLightBeamInitializationData");
static_assert(offsetof(FLightBeamInitializationData, DataBlueprint) == 0x000008, "Member 'FLightBeamInitializationData::DataBlueprint' has a wrong offset!");
static_assert(offsetof(FLightBeamInitializationData, Source) == 0x000010, "Member 'FLightBeamInitializationData::Source' has a wrong offset!");
static_assert(offsetof(FLightBeamInitializationData, Target) == 0x000038, "Member 'FLightBeamInitializationData::Target' has a wrong offset!");
static_assert(offsetof(FLightBeamInitializationData, Flags) == 0x000060, "Member 'FLightBeamInitializationData::Flags' has a wrong offset!");
static_assert(offsetof(FLightBeamInitializationData, Instigator) == 0x000068, "Member 'FLightBeamInitializationData::Instigator' has a wrong offset!");
static_assert(offsetof(FLightBeamInitializationData, DamageCauser) == 0x000070, "Member 'FLightBeamInitializationData::DamageCauser' has a wrong offset!");
static_assert(offsetof(FLightBeamInitializationData, Damage) == 0x000078, "Member 'FLightBeamInitializationData::Damage' has a wrong offset!");
static_assert(offsetof(FLightBeamInitializationData, DamageIntervalOverride) == 0x00007C, "Member 'FLightBeamInitializationData::DamageIntervalOverride' has a wrong offset!");
static_assert(offsetof(FLightBeamInitializationData, DamageRampCurve) == 0x000080, "Member 'FLightBeamInitializationData::DamageRampCurve' has a wrong offset!");
static_assert(offsetof(FLightBeamInitializationData, DamageRampScale) == 0x000088, "Member 'FLightBeamInitializationData::DamageRampScale' has a wrong offset!");
static_assert(offsetof(FLightBeamInitializationData, DamageType) == 0x000090, "Member 'FLightBeamInitializationData::DamageType' has a wrong offset!");
static_assert(offsetof(FLightBeamInitializationData, DamageSource) == 0x000098, "Member 'FLightBeamInitializationData::DamageSource' has a wrong offset!");
static_assert(offsetof(FLightBeamInitializationData, DamageRadius) == 0x0000A0, "Member 'FLightBeamInitializationData::DamageRadius' has a wrong offset!");
static_assert(offsetof(FLightBeamInitializationData, ImpactForce) == 0x0000A8, "Member 'FLightBeamInitializationData::ImpactForce' has a wrong offset!");
static_assert(offsetof(FLightBeamInitializationData, ImpactDataOverride) == 0x0000C8, "Member 'FLightBeamInitializationData::ImpactDataOverride' has a wrong offset!");
static_assert(offsetof(FLightBeamInitializationData, NameId) == 0x0000D0, "Member 'FLightBeamInitializationData::NameId' has a wrong offset!");
static_assert(offsetof(FLightBeamInitializationData, Spread) == 0x0000D8, "Member 'FLightBeamInitializationData::Spread' has a wrong offset!");
static_assert(offsetof(FLightBeamInitializationData, LifetimeOverride) == 0x0000DC, "Member 'FLightBeamInitializationData::LifetimeOverride' has a wrong offset!");
static_assert(offsetof(FLightBeamInitializationData, ModifierType) == 0x0000E0, "Member 'FLightBeamInitializationData::ModifierType' has a wrong offset!");
static_assert(offsetof(FLightBeamInitializationData, ModifierValue) == 0x0000F8, "Member 'FLightBeamInitializationData::ModifierValue' has a wrong offset!");
static_assert(offsetof(FLightBeamInitializationData, CriticalHitOverrides) == 0x0000FC, "Member 'FLightBeamInitializationData::CriticalHitOverrides' has a wrong offset!");
static_assert(offsetof(FLightBeamInitializationData, GoreModifiers) == 0x000104, "Member 'FLightBeamInitializationData::GoreModifiers' has a wrong offset!");
static_assert(offsetof(FLightBeamInitializationData, ParentBeam) == 0x000110, "Member 'FLightBeamInitializationData::ParentBeam' has a wrong offset!");

// ScriptStruct GbxWeapon.WeaponTriggerVibrationData
// 0x000C (0x000C - 0x0000)
struct FWeaponTriggerVibrationData final
{
public:
	float                                         Position;                                          // 0x0000(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         Frequency;                                         // 0x0004(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         Amplitude;                                         // 0x0008(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FWeaponTriggerVibrationData) == 0x000004, "Wrong alignment on FWeaponTriggerVibrationData");
static_assert(sizeof(FWeaponTriggerVibrationData) == 0x00000C, "Wrong size on FWeaponTriggerVibrationData");
static_assert(offsetof(FWeaponTriggerVibrationData, Position) == 0x000000, "Member 'FWeaponTriggerVibrationData::Position' has a wrong offset!");
static_assert(offsetof(FWeaponTriggerVibrationData, Frequency) == 0x000004, "Member 'FWeaponTriggerVibrationData::Frequency' has a wrong offset!");
static_assert(offsetof(FWeaponTriggerVibrationData, Amplitude) == 0x000008, "Member 'FWeaponTriggerVibrationData::Amplitude' has a wrong offset!");

// ScriptStruct GbxWeapon.GbxTrajectometerTraceData
// 0x0020 (0x0020 - 0x0000)
struct FGbxTrajectometerTraceData final
{
public:
	ECollisionChannel                             Channel;                                           // 0x0000(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EGbxTrajectoryTraceShape                      Shape;                                             // 0x0001(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2[0x2];                                        // 0x0002(0x0002)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         ExtentX;                                           // 0x0004(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         ExtentY;                                           // 0x0008(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         ExtentZ;                                           // 0x000C(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_10[0x10];                                      // 0x0010(0x0010)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FGbxTrajectometerTraceData) == 0x000004, "Wrong alignment on FGbxTrajectometerTraceData");
static_assert(sizeof(FGbxTrajectometerTraceData) == 0x000020, "Wrong size on FGbxTrajectometerTraceData");
static_assert(offsetof(FGbxTrajectometerTraceData, Channel) == 0x000000, "Member 'FGbxTrajectometerTraceData::Channel' has a wrong offset!");
static_assert(offsetof(FGbxTrajectometerTraceData, Shape) == 0x000001, "Member 'FGbxTrajectometerTraceData::Shape' has a wrong offset!");
static_assert(offsetof(FGbxTrajectometerTraceData, ExtentX) == 0x000004, "Member 'FGbxTrajectometerTraceData::ExtentX' has a wrong offset!");
static_assert(offsetof(FGbxTrajectometerTraceData, ExtentY) == 0x000008, "Member 'FGbxTrajectometerTraceData::ExtentY' has a wrong offset!");
static_assert(offsetof(FGbxTrajectometerTraceData, ExtentZ) == 0x00000C, "Member 'FGbxTrajectometerTraceData::ExtentZ' has a wrong offset!");

// ScriptStruct GbxWeapon.PredictProjectilePathAsyncRequest
// 0x0020 (0x0080 - 0x0060)
struct FPredictProjectilePathAsyncRequest final : public FPredictProjectilePathParams
{
public:
	EGbxTraceAsyncMode                            TraceMode;                                         // 0x0060(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EObjectTypeQuery                              ObjectType;                                        // 0x0061(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_62[0x6];                                       // 0x0062(0x0006)(Fixing Size After Last Property [ Dumper-7 ])
	class FName                                   TraceName;                                         // 0x0068(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, AdvancedDisplay, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TDelegate<void(struct FPredictProjectilePathResult& Result)> Finished;                                          // 0x0070(0x0010)(Edit, BlueprintVisible, ZeroConstructor, InstancedReference, NoDestructor, AdvancedDisplay, NativeAccessSpecifierPublic)
};
static_assert(alignof(FPredictProjectilePathAsyncRequest) == 0x000008, "Wrong alignment on FPredictProjectilePathAsyncRequest");
static_assert(sizeof(FPredictProjectilePathAsyncRequest) == 0x000080, "Wrong size on FPredictProjectilePathAsyncRequest");
static_assert(offsetof(FPredictProjectilePathAsyncRequest, TraceMode) == 0x000060, "Member 'FPredictProjectilePathAsyncRequest::TraceMode' has a wrong offset!");
static_assert(offsetof(FPredictProjectilePathAsyncRequest, ObjectType) == 0x000061, "Member 'FPredictProjectilePathAsyncRequest::ObjectType' has a wrong offset!");
static_assert(offsetof(FPredictProjectilePathAsyncRequest, TraceName) == 0x000068, "Member 'FPredictProjectilePathAsyncRequest::TraceName' has a wrong offset!");
static_assert(offsetof(FPredictProjectilePathAsyncRequest, Finished) == 0x000070, "Member 'FPredictProjectilePathAsyncRequest::Finished' has a wrong offset!");

// ScriptStruct GbxWeapon.WeaponShotModifierData
// 0x0048 (0x0048 - 0x0000)
struct FWeaponShotModifierData final
{
public:
	EWeaponShotModifierType                       ModifierType;                                      // 0x0000(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1[0x3];                                        // 0x0001(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         Damage;                                            // 0x0004(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TSubclassOf<class UGbxDamageType>             DamageType;                                        // 0x0008(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UImpactData*                            ImpactData;                                        // 0x0010(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         ProjectilesPerShot;                                // 0x0018(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1C[0x4];                                       // 0x001C(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	struct FCriticalHitDamageOverrides            CriticalHitOverrides;                              // 0x0020(0x0008)(BlueprintVisible, BlueprintReadOnly, NoDestructor, NativeAccessSpecifierPublic)
	float                                         ModifierValue;                                     // 0x0028(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FDamageGoreModifiers                   GoreModifiers;                                     // 0x002C(0x0008)(BlueprintVisible, BlueprintReadOnly, NoDestructor, NativeAccessSpecifierPublic)
	uint8                                         Pad_34[0x14];                                      // 0x0034(0x0014)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FWeaponShotModifierData) == 0x000008, "Wrong alignment on FWeaponShotModifierData");
static_assert(sizeof(FWeaponShotModifierData) == 0x000048, "Wrong size on FWeaponShotModifierData");
static_assert(offsetof(FWeaponShotModifierData, ModifierType) == 0x000000, "Member 'FWeaponShotModifierData::ModifierType' has a wrong offset!");
static_assert(offsetof(FWeaponShotModifierData, Damage) == 0x000004, "Member 'FWeaponShotModifierData::Damage' has a wrong offset!");
static_assert(offsetof(FWeaponShotModifierData, DamageType) == 0x000008, "Member 'FWeaponShotModifierData::DamageType' has a wrong offset!");
static_assert(offsetof(FWeaponShotModifierData, ImpactData) == 0x000010, "Member 'FWeaponShotModifierData::ImpactData' has a wrong offset!");
static_assert(offsetof(FWeaponShotModifierData, ProjectilesPerShot) == 0x000018, "Member 'FWeaponShotModifierData::ProjectilesPerShot' has a wrong offset!");
static_assert(offsetof(FWeaponShotModifierData, CriticalHitOverrides) == 0x000020, "Member 'FWeaponShotModifierData::CriticalHitOverrides' has a wrong offset!");
static_assert(offsetof(FWeaponShotModifierData, ModifierValue) == 0x000028, "Member 'FWeaponShotModifierData::ModifierValue' has a wrong offset!");
static_assert(offsetof(FWeaponShotModifierData, GoreModifiers) == 0x00002C, "Member 'FWeaponShotModifierData::GoreModifiers' has a wrong offset!");

// ScriptStruct GbxWeapon.FiringPatternSample
// 0x001C (0x001C - 0x0000)
struct FFiringPatternSample final
{
public:
	struct FRotator                               StartRotation;                                     // 0x0000(0x000C)(Edit, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
	struct FRotator                               EndRotation;                                       // 0x000C(0x000C)(Edit, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
	bool                                          bUseEndRotation;                                   // 0x0018(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bUseID;                                            // 0x0019(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         ID;                                                // 0x001A(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1B[0x1];                                       // 0x001B(0x0001)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FFiringPatternSample) == 0x000004, "Wrong alignment on FFiringPatternSample");
static_assert(sizeof(FFiringPatternSample) == 0x00001C, "Wrong size on FFiringPatternSample");
static_assert(offsetof(FFiringPatternSample, StartRotation) == 0x000000, "Member 'FFiringPatternSample::StartRotation' has a wrong offset!");
static_assert(offsetof(FFiringPatternSample, EndRotation) == 0x00000C, "Member 'FFiringPatternSample::EndRotation' has a wrong offset!");
static_assert(offsetof(FFiringPatternSample, bUseEndRotation) == 0x000018, "Member 'FFiringPatternSample::bUseEndRotation' has a wrong offset!");
static_assert(offsetof(FFiringPatternSample, bUseID) == 0x000019, "Member 'FFiringPatternSample::bUseID' has a wrong offset!");
static_assert(offsetof(FFiringPatternSample, ID) == 0x00001A, "Member 'FFiringPatternSample::ID' has a wrong offset!");

// ScriptStruct GbxWeapon.WeaponSkeletalControlInstance
// 0x0038 (0x0038 - 0x0000)
struct FWeaponSkeletalControlInstance final
{
public:
	class UWeaponSkeletalControlBase*             Data;                                              // 0x0000(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_8[0x30];                                       // 0x0008(0x0030)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FWeaponSkeletalControlInstance) == 0x000008, "Wrong alignment on FWeaponSkeletalControlInstance");
static_assert(sizeof(FWeaponSkeletalControlInstance) == 0x000038, "Wrong size on FWeaponSkeletalControlInstance");
static_assert(offsetof(FWeaponSkeletalControlInstance, Data) == 0x000000, "Member 'FWeaponSkeletalControlInstance::Data' has a wrong offset!");

// ScriptStruct GbxWeapon.LightProjectileAttachment
// 0x0040 (0x0040 - 0x0000)
struct FLightProjectileAttachment final
{
public:
	class AActor*                                 Actor;                                             // 0x0000(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class USceneComponent*                        Component;                                         // 0x0008(0x0008)(Edit, BlueprintVisible, ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   Socket;                                            // 0x0010(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector_NetQuantize100                 RelativeLocation;                                  // 0x0018(0x000C)(Edit, BlueprintVisible, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FRotator                               RelativeRotation;                                  // 0x0024(0x000C)(Edit, BlueprintVisible, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
	struct FVector_NetQuantizeNormal              RelativeImpactNormal;                              // 0x0030(0x000C)(Edit, BlueprintVisible, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_3C[0x4];                                       // 0x003C(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FLightProjectileAttachment) == 0x000008, "Wrong alignment on FLightProjectileAttachment");
static_assert(sizeof(FLightProjectileAttachment) == 0x000040, "Wrong size on FLightProjectileAttachment");
static_assert(offsetof(FLightProjectileAttachment, Actor) == 0x000000, "Member 'FLightProjectileAttachment::Actor' has a wrong offset!");
static_assert(offsetof(FLightProjectileAttachment, Component) == 0x000008, "Member 'FLightProjectileAttachment::Component' has a wrong offset!");
static_assert(offsetof(FLightProjectileAttachment, Socket) == 0x000010, "Member 'FLightProjectileAttachment::Socket' has a wrong offset!");
static_assert(offsetof(FLightProjectileAttachment, RelativeLocation) == 0x000018, "Member 'FLightProjectileAttachment::RelativeLocation' has a wrong offset!");
static_assert(offsetof(FLightProjectileAttachment, RelativeRotation) == 0x000024, "Member 'FLightProjectileAttachment::RelativeRotation' has a wrong offset!");
static_assert(offsetof(FLightProjectileAttachment, RelativeImpactNormal) == 0x000030, "Member 'FLightProjectileAttachment::RelativeImpactNormal' has a wrong offset!");

// ScriptStruct GbxWeapon.LightProjectileRingData
// 0x0034 (0x0034 - 0x0000)
struct alignas(0x04) FLightProjectileRingData final
{
public:
	uint8                                         Pad_0[0x34];                                       // 0x0000(0x0034)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FLightProjectileRingData) == 0x000004, "Wrong alignment on FLightProjectileRingData");
static_assert(sizeof(FLightProjectileRingData) == 0x000034, "Wrong size on FLightProjectileRingData");

// ScriptStruct GbxWeapon.LightProjectileInitializationData
// 0x0140 (0x0140 - 0x0000)
struct FLightProjectileInitializationData
{
public:
	uint8                                         Pad_0[0x8];                                        // 0x0000(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	TSubclassOf<class ULightProjectileData>       DataBlueprint;                                     // 0x0008(0x0008)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                StartLocation;                                     // 0x0010(0x000C)(BlueprintVisible, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                EndLocation;                                       // 0x001C(0x000C)(BlueprintVisible, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         Flags;                                             // 0x0028(0x0004)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FRotator                               StartRotationOverride;                             // 0x002C(0x000C)(BlueprintVisible, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
	class APawn*                                  Instigator;                                        // 0x0038(0x0008)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class AActor*                                 Source;                                            // 0x0040(0x0008)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class AActor*                                 Target;                                            // 0x0048(0x0008)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                TargetOffset;                                      // 0x0050(0x000C)(BlueprintVisible, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         Damage;                                            // 0x005C(0x0004)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class AActor*                                 DamageCauser;                                      // 0x0060(0x0008)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TSubclassOf<class UGbxDamageType>             DamageType;                                        // 0x0068(0x0008)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TSubclassOf<class UDamageSource>              DamageSource;                                      // 0x0070(0x0008)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         DamageRadius;                                      // 0x0078(0x0004)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_7C[0x4];                                       // 0x007C(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	struct FForceSelection                        ImpactForce;                                       // 0x0080(0x0020)(BlueprintVisible, NoDestructor, NativeAccessSpecifierPublic)
	class UImpactData*                            ImpactDataOverride;                                // 0x00A0(0x0008)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         SpeedScale;                                        // 0x00A8(0x0004)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         GravityScaleOverride;                              // 0x00AC(0x0004)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         FiringPatternID;                                   // 0x00B0(0x0001)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         FireSocketID;                                      // 0x00B1(0x0001)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_B2[0x6];                                       // 0x00B2(0x0006)(Fixing Size After Last Property [ Dumper-7 ])
	class UDamageModifierComponent*               DamageModifierComp;                                // 0x00B8(0x0008)(ExportObject, ZeroConstructor, Transient, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   NameId;                                            // 0x00C0(0x0008)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EWeaponShotModifierType                       ModifierType;                                      // 0x00C8(0x0001)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_C9[0x17];                                      // 0x00C9(0x0017)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         ModifierValue;                                     // 0x00E0(0x0004)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FCriticalHitDamageOverrides            CriticalHitOverrides;                              // 0x00E4(0x0008)(BlueprintVisible, NoDestructor, NativeAccessSpecifierPublic)
	struct FDamageGoreModifiers                   GoreModifiers;                                     // 0x00EC(0x0008)(BlueprintVisible, NoDestructor, NativeAccessSpecifierPublic)
	struct FLightProjectileRingData               RingData;                                          // 0x00F4(0x0034)(NoDestructor, NativeAccessSpecifierPublic)
	uint8                                         Pad_128[0x18];                                     // 0x0128(0x0018)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FLightProjectileInitializationData) == 0x000008, "Wrong alignment on FLightProjectileInitializationData");
static_assert(sizeof(FLightProjectileInitializationData) == 0x000140, "Wrong size on FLightProjectileInitializationData");
static_assert(offsetof(FLightProjectileInitializationData, DataBlueprint) == 0x000008, "Member 'FLightProjectileInitializationData::DataBlueprint' has a wrong offset!");
static_assert(offsetof(FLightProjectileInitializationData, StartLocation) == 0x000010, "Member 'FLightProjectileInitializationData::StartLocation' has a wrong offset!");
static_assert(offsetof(FLightProjectileInitializationData, EndLocation) == 0x00001C, "Member 'FLightProjectileInitializationData::EndLocation' has a wrong offset!");
static_assert(offsetof(FLightProjectileInitializationData, Flags) == 0x000028, "Member 'FLightProjectileInitializationData::Flags' has a wrong offset!");
static_assert(offsetof(FLightProjectileInitializationData, StartRotationOverride) == 0x00002C, "Member 'FLightProjectileInitializationData::StartRotationOverride' has a wrong offset!");
static_assert(offsetof(FLightProjectileInitializationData, Instigator) == 0x000038, "Member 'FLightProjectileInitializationData::Instigator' has a wrong offset!");
static_assert(offsetof(FLightProjectileInitializationData, Source) == 0x000040, "Member 'FLightProjectileInitializationData::Source' has a wrong offset!");
static_assert(offsetof(FLightProjectileInitializationData, Target) == 0x000048, "Member 'FLightProjectileInitializationData::Target' has a wrong offset!");
static_assert(offsetof(FLightProjectileInitializationData, TargetOffset) == 0x000050, "Member 'FLightProjectileInitializationData::TargetOffset' has a wrong offset!");
static_assert(offsetof(FLightProjectileInitializationData, Damage) == 0x00005C, "Member 'FLightProjectileInitializationData::Damage' has a wrong offset!");
static_assert(offsetof(FLightProjectileInitializationData, DamageCauser) == 0x000060, "Member 'FLightProjectileInitializationData::DamageCauser' has a wrong offset!");
static_assert(offsetof(FLightProjectileInitializationData, DamageType) == 0x000068, "Member 'FLightProjectileInitializationData::DamageType' has a wrong offset!");
static_assert(offsetof(FLightProjectileInitializationData, DamageSource) == 0x000070, "Member 'FLightProjectileInitializationData::DamageSource' has a wrong offset!");
static_assert(offsetof(FLightProjectileInitializationData, DamageRadius) == 0x000078, "Member 'FLightProjectileInitializationData::DamageRadius' has a wrong offset!");
static_assert(offsetof(FLightProjectileInitializationData, ImpactForce) == 0x000080, "Member 'FLightProjectileInitializationData::ImpactForce' has a wrong offset!");
static_assert(offsetof(FLightProjectileInitializationData, ImpactDataOverride) == 0x0000A0, "Member 'FLightProjectileInitializationData::ImpactDataOverride' has a wrong offset!");
static_assert(offsetof(FLightProjectileInitializationData, SpeedScale) == 0x0000A8, "Member 'FLightProjectileInitializationData::SpeedScale' has a wrong offset!");
static_assert(offsetof(FLightProjectileInitializationData, GravityScaleOverride) == 0x0000AC, "Member 'FLightProjectileInitializationData::GravityScaleOverride' has a wrong offset!");
static_assert(offsetof(FLightProjectileInitializationData, FiringPatternID) == 0x0000B0, "Member 'FLightProjectileInitializationData::FiringPatternID' has a wrong offset!");
static_assert(offsetof(FLightProjectileInitializationData, FireSocketID) == 0x0000B1, "Member 'FLightProjectileInitializationData::FireSocketID' has a wrong offset!");
static_assert(offsetof(FLightProjectileInitializationData, DamageModifierComp) == 0x0000B8, "Member 'FLightProjectileInitializationData::DamageModifierComp' has a wrong offset!");
static_assert(offsetof(FLightProjectileInitializationData, NameId) == 0x0000C0, "Member 'FLightProjectileInitializationData::NameId' has a wrong offset!");
static_assert(offsetof(FLightProjectileInitializationData, ModifierType) == 0x0000C8, "Member 'FLightProjectileInitializationData::ModifierType' has a wrong offset!");
static_assert(offsetof(FLightProjectileInitializationData, ModifierValue) == 0x0000E0, "Member 'FLightProjectileInitializationData::ModifierValue' has a wrong offset!");
static_assert(offsetof(FLightProjectileInitializationData, CriticalHitOverrides) == 0x0000E4, "Member 'FLightProjectileInitializationData::CriticalHitOverrides' has a wrong offset!");
static_assert(offsetof(FLightProjectileInitializationData, GoreModifiers) == 0x0000EC, "Member 'FLightProjectileInitializationData::GoreModifiers' has a wrong offset!");
static_assert(offsetof(FLightProjectileInitializationData, RingData) == 0x0000F4, "Member 'FLightProjectileInitializationData::RingData' has a wrong offset!");

// ScriptStruct GbxWeapon.LightProjectileImpactData
// 0x0010 (0x0010 - 0x0000)
struct FLightProjectileImpactData final
{
public:
	bool                                          bPlayEffect;                                       // 0x0000(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1[0x3];                                        // 0x0001(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	struct FVector_NetQuantize                    Location;                                          // 0x0004(0x000C)(NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FLightProjectileImpactData) == 0x000004, "Wrong alignment on FLightProjectileImpactData");
static_assert(sizeof(FLightProjectileImpactData) == 0x000010, "Wrong size on FLightProjectileImpactData");
static_assert(offsetof(FLightProjectileImpactData, bPlayEffect) == 0x000000, "Member 'FLightProjectileImpactData::bPlayEffect' has a wrong offset!");
static_assert(offsetof(FLightProjectileImpactData, Location) == 0x000004, "Member 'FLightProjectileImpactData::Location' has a wrong offset!");

// ScriptStruct GbxWeapon.WeaponZoomState
// 0x0002 (0x0002 - 0x0000)
struct FWeaponZoomState final
{
public:
	EWeaponZoomState                              State;                                             // 0x0000(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Level;                                             // 0x0001(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FWeaponZoomState) == 0x000001, "Wrong alignment on FWeaponZoomState");
static_assert(sizeof(FWeaponZoomState) == 0x000002, "Wrong size on FWeaponZoomState");
static_assert(offsetof(FWeaponZoomState, State) == 0x000000, "Member 'FWeaponZoomState::State' has a wrong offset!");
static_assert(offsetof(FWeaponZoomState, Level) == 0x000001, "Member 'FWeaponZoomState::Level' has a wrong offset!");

// ScriptStruct GbxWeapon.LightBeamTickFunction
// 0x0008 (0x0058 - 0x0050)
struct FLightBeamTickFunction final : public FTickFunction
{
public:
	uint8                                         Pad_50[0x8];                                       // 0x0050(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FLightBeamTickFunction) == 0x000008, "Wrong alignment on FLightBeamTickFunction");
static_assert(sizeof(FLightBeamTickFunction) == 0x000058, "Wrong size on FLightBeamTickFunction");

// ScriptStruct GbxWeapon.WeaponZoomLevel
// 0x0010 (0x0010 - 0x0000)
struct FWeaponZoomLevel final
{
public:
	float                                         Duration;                                          // 0x0000(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         FOVScale;                                          // 0x0004(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         FOVLerpPct;                                        // 0x0008(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         ViewModelFOVScale;                                 // 0x000C(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FWeaponZoomLevel) == 0x000004, "Wrong alignment on FWeaponZoomLevel");
static_assert(sizeof(FWeaponZoomLevel) == 0x000010, "Wrong size on FWeaponZoomLevel");
static_assert(offsetof(FWeaponZoomLevel, Duration) == 0x000000, "Member 'FWeaponZoomLevel::Duration' has a wrong offset!");
static_assert(offsetof(FWeaponZoomLevel, FOVScale) == 0x000004, "Member 'FWeaponZoomLevel::FOVScale' has a wrong offset!");
static_assert(offsetof(FWeaponZoomLevel, FOVLerpPct) == 0x000008, "Member 'FWeaponZoomLevel::FOVLerpPct' has a wrong offset!");
static_assert(offsetof(FWeaponZoomLevel, ViewModelFOVScale) == 0x00000C, "Member 'FWeaponZoomLevel::ViewModelFOVScale' has a wrong offset!");

// ScriptStruct GbxWeapon.WeaponRegisterAttachmentEffectData
// 0x0060 (0x0060 - 0x0000)
struct FWeaponRegisterAttachmentEffectData final
{
public:
	EWeaponEffectType                             Type;                                              // 0x0000(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1[0x7];                                        // 0x0001(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	class UParticleSystem*                        Effect;                                            // 0x0008(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TSubclassOf<class UEffectCollectionData>      ConditionalEffect;                                 // 0x0010(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   Socket;                                            // 0x0018(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   ScopedSocket;                                      // 0x0020(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         ID;                                                // 0x0028(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EWeaponAttachmentVisibilityType               Visibility;                                        // 0x002C(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2D[0x3];                                       // 0x002D(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	int32                                         UseModeBitmask;                                    // 0x0030(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Slot;                                              // 0x0034(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_35[0x3];                                       // 0x0035(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	int32                                         Flags;                                             // 0x0038(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                RelativeLocation;                                  // 0x003C(0x000C)(Edit, BlueprintVisible, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FRotator                               RelativeRotation;                                  // 0x0048(0x000C)(Edit, BlueprintVisible, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
	float                                         RelativeScale;                                     // 0x0054(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         AutoActivateModeBitmask;                           // 0x0058(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         bPlayOnlyOnActiveSlot : 1;                         // 0x005C(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (Deprecated, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         bAutoActivate : 1;                                 // 0x005C(0x0001)(BitIndex: 0x01, PropSize: 0x0001 (Deprecated, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         bIgnoredByFXCoordinator : 1;                       // 0x005C(0x0001)(BitIndex: 0x02, PropSize: 0x0001 (Deprecated, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         bHideWhenScoped : 1;                               // 0x005C(0x0001)(BitIndex: 0x03, PropSize: 0x0001 (Deprecated, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         Pad_5D[0x3];                                       // 0x005D(0x0003)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FWeaponRegisterAttachmentEffectData) == 0x000008, "Wrong alignment on FWeaponRegisterAttachmentEffectData");
static_assert(sizeof(FWeaponRegisterAttachmentEffectData) == 0x000060, "Wrong size on FWeaponRegisterAttachmentEffectData");
static_assert(offsetof(FWeaponRegisterAttachmentEffectData, Type) == 0x000000, "Member 'FWeaponRegisterAttachmentEffectData::Type' has a wrong offset!");
static_assert(offsetof(FWeaponRegisterAttachmentEffectData, Effect) == 0x000008, "Member 'FWeaponRegisterAttachmentEffectData::Effect' has a wrong offset!");
static_assert(offsetof(FWeaponRegisterAttachmentEffectData, ConditionalEffect) == 0x000010, "Member 'FWeaponRegisterAttachmentEffectData::ConditionalEffect' has a wrong offset!");
static_assert(offsetof(FWeaponRegisterAttachmentEffectData, Socket) == 0x000018, "Member 'FWeaponRegisterAttachmentEffectData::Socket' has a wrong offset!");
static_assert(offsetof(FWeaponRegisterAttachmentEffectData, ScopedSocket) == 0x000020, "Member 'FWeaponRegisterAttachmentEffectData::ScopedSocket' has a wrong offset!");
static_assert(offsetof(FWeaponRegisterAttachmentEffectData, ID) == 0x000028, "Member 'FWeaponRegisterAttachmentEffectData::ID' has a wrong offset!");
static_assert(offsetof(FWeaponRegisterAttachmentEffectData, Visibility) == 0x00002C, "Member 'FWeaponRegisterAttachmentEffectData::Visibility' has a wrong offset!");
static_assert(offsetof(FWeaponRegisterAttachmentEffectData, UseModeBitmask) == 0x000030, "Member 'FWeaponRegisterAttachmentEffectData::UseModeBitmask' has a wrong offset!");
static_assert(offsetof(FWeaponRegisterAttachmentEffectData, Slot) == 0x000034, "Member 'FWeaponRegisterAttachmentEffectData::Slot' has a wrong offset!");
static_assert(offsetof(FWeaponRegisterAttachmentEffectData, Flags) == 0x000038, "Member 'FWeaponRegisterAttachmentEffectData::Flags' has a wrong offset!");
static_assert(offsetof(FWeaponRegisterAttachmentEffectData, RelativeLocation) == 0x00003C, "Member 'FWeaponRegisterAttachmentEffectData::RelativeLocation' has a wrong offset!");
static_assert(offsetof(FWeaponRegisterAttachmentEffectData, RelativeRotation) == 0x000048, "Member 'FWeaponRegisterAttachmentEffectData::RelativeRotation' has a wrong offset!");
static_assert(offsetof(FWeaponRegisterAttachmentEffectData, RelativeScale) == 0x000054, "Member 'FWeaponRegisterAttachmentEffectData::RelativeScale' has a wrong offset!");
static_assert(offsetof(FWeaponRegisterAttachmentEffectData, AutoActivateModeBitmask) == 0x000058, "Member 'FWeaponRegisterAttachmentEffectData::AutoActivateModeBitmask' has a wrong offset!");

// ScriptStruct GbxWeapon.LightBeamImpactFXTrackingData
// 0x0030 (0x0030 - 0x0000)
struct FLightBeamImpactFXTrackingData final
{
public:
	class USceneComponent*                        Component;                                         // 0x0000(0x0008)(ExportObject, ZeroConstructor, Transient, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UPhysicalMaterial*                      PhysicalMaterial;                                  // 0x0008(0x0008)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_10[0x20];                                      // 0x0010(0x0020)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FLightBeamImpactFXTrackingData) == 0x000008, "Wrong alignment on FLightBeamImpactFXTrackingData");
static_assert(sizeof(FLightBeamImpactFXTrackingData) == 0x000030, "Wrong size on FLightBeamImpactFXTrackingData");
static_assert(offsetof(FLightBeamImpactFXTrackingData, Component) == 0x000000, "Member 'FLightBeamImpactFXTrackingData::Component' has a wrong offset!");
static_assert(offsetof(FLightBeamImpactFXTrackingData, PhysicalMaterial) == 0x000008, "Member 'FLightBeamImpactFXTrackingData::PhysicalMaterial' has a wrong offset!");

// ScriptStruct GbxWeapon.ClientLightBeamState
// 0x00C8 (0x00C8 - 0x0000)
struct FClientLightBeamState final
{
public:
	uint8                                         CreationID;                                        // 0x0000(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1[0x7];                                        // 0x0001(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	TSubclassOf<class ULightBeamData>             DataBlueprint;                                     // 0x0008(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FLightBeamAttachment                   Source;                                            // 0x0010(0x0028)(NoDestructor, ContainsInstancedReference, NativeAccessSpecifierPublic)
	struct FLightBeamAttachment                   Target;                                            // 0x0038(0x0028)(NoDestructor, ContainsInstancedReference, NativeAccessSpecifierPublic)
	class APawn*                                  Instigator;                                        // 0x0060(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class AActor*                                 DamageCauser;                                      // 0x0068(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UImpactData*                            ImpactDataOverride;                                // 0x0070(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         Spread;                                            // 0x0078(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint16                                        Flags;                                             // 0x007C(0x0002)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_7E[0x2];                                       // 0x007E(0x0002)(Fixing Size After Last Property [ Dumper-7 ])
	class UParticleSystem*                        BeamFXOverride;                                    // 0x0080(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UParticleSystem*                        ViewerBeamFXOverride;                              // 0x0088(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UWwiseEvent*                            BeamImpactAudioOverride;                           // 0x0090(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         LifetimeOverride;                                  // 0x0098(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         Damage;                                            // 0x009C(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TSubclassOf<class UGbxDamageType>             DamageType;                                        // 0x00A0(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TSubclassOf<class UDamageSource>              DamageSource;                                      // 0x00A8(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         DamageRadius;                                      // 0x00B0(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_B4[0x4];                                       // 0x00B4(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class UCurveFloat*                            DamageRampCurve;                                   // 0x00B8(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         DamageRampScale;                                   // 0x00C0(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         ImpactForce;                                       // 0x00C4(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FClientLightBeamState) == 0x000008, "Wrong alignment on FClientLightBeamState");
static_assert(sizeof(FClientLightBeamState) == 0x0000C8, "Wrong size on FClientLightBeamState");
static_assert(offsetof(FClientLightBeamState, CreationID) == 0x000000, "Member 'FClientLightBeamState::CreationID' has a wrong offset!");
static_assert(offsetof(FClientLightBeamState, DataBlueprint) == 0x000008, "Member 'FClientLightBeamState::DataBlueprint' has a wrong offset!");
static_assert(offsetof(FClientLightBeamState, Source) == 0x000010, "Member 'FClientLightBeamState::Source' has a wrong offset!");
static_assert(offsetof(FClientLightBeamState, Target) == 0x000038, "Member 'FClientLightBeamState::Target' has a wrong offset!");
static_assert(offsetof(FClientLightBeamState, Instigator) == 0x000060, "Member 'FClientLightBeamState::Instigator' has a wrong offset!");
static_assert(offsetof(FClientLightBeamState, DamageCauser) == 0x000068, "Member 'FClientLightBeamState::DamageCauser' has a wrong offset!");
static_assert(offsetof(FClientLightBeamState, ImpactDataOverride) == 0x000070, "Member 'FClientLightBeamState::ImpactDataOverride' has a wrong offset!");
static_assert(offsetof(FClientLightBeamState, Spread) == 0x000078, "Member 'FClientLightBeamState::Spread' has a wrong offset!");
static_assert(offsetof(FClientLightBeamState, Flags) == 0x00007C, "Member 'FClientLightBeamState::Flags' has a wrong offset!");
static_assert(offsetof(FClientLightBeamState, BeamFXOverride) == 0x000080, "Member 'FClientLightBeamState::BeamFXOverride' has a wrong offset!");
static_assert(offsetof(FClientLightBeamState, ViewerBeamFXOverride) == 0x000088, "Member 'FClientLightBeamState::ViewerBeamFXOverride' has a wrong offset!");
static_assert(offsetof(FClientLightBeamState, BeamImpactAudioOverride) == 0x000090, "Member 'FClientLightBeamState::BeamImpactAudioOverride' has a wrong offset!");
static_assert(offsetof(FClientLightBeamState, LifetimeOverride) == 0x000098, "Member 'FClientLightBeamState::LifetimeOverride' has a wrong offset!");
static_assert(offsetof(FClientLightBeamState, Damage) == 0x00009C, "Member 'FClientLightBeamState::Damage' has a wrong offset!");
static_assert(offsetof(FClientLightBeamState, DamageType) == 0x0000A0, "Member 'FClientLightBeamState::DamageType' has a wrong offset!");
static_assert(offsetof(FClientLightBeamState, DamageSource) == 0x0000A8, "Member 'FClientLightBeamState::DamageSource' has a wrong offset!");
static_assert(offsetof(FClientLightBeamState, DamageRadius) == 0x0000B0, "Member 'FClientLightBeamState::DamageRadius' has a wrong offset!");
static_assert(offsetof(FClientLightBeamState, DamageRampCurve) == 0x0000B8, "Member 'FClientLightBeamState::DamageRampCurve' has a wrong offset!");
static_assert(offsetof(FClientLightBeamState, DamageRampScale) == 0x0000C0, "Member 'FClientLightBeamState::DamageRampScale' has a wrong offset!");
static_assert(offsetof(FClientLightBeamState, ImpactForce) == 0x0000C4, "Member 'FClientLightBeamState::ImpactForce' has a wrong offset!");

// ScriptStruct GbxWeapon.WeaponShotModifierTypeName
// 0x0020 (0x0020 - 0x0000)
struct FWeaponShotModifierTypeName final
{
public:
	EWeaponShotModifierType                       Type;                                              // 0x0000(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1[0x7];                                        // 0x0001(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	class FName                                   Name;                                              // 0x0008(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FString                                 Tooltip;                                           // 0x0010(0x0010)(ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FWeaponShotModifierTypeName) == 0x000008, "Wrong alignment on FWeaponShotModifierTypeName");
static_assert(sizeof(FWeaponShotModifierTypeName) == 0x000020, "Wrong size on FWeaponShotModifierTypeName");
static_assert(offsetof(FWeaponShotModifierTypeName, Type) == 0x000000, "Member 'FWeaponShotModifierTypeName::Type' has a wrong offset!");
static_assert(offsetof(FWeaponShotModifierTypeName, Name) == 0x000008, "Member 'FWeaponShotModifierTypeName::Name' has a wrong offset!");
static_assert(offsetof(FWeaponShotModifierTypeName, Tooltip) == 0x000010, "Member 'FWeaponShotModifierTypeName::Tooltip' has a wrong offset!");

// ScriptStruct GbxWeapon.LightBeamQueryData
// 0x0028 (0x0028 - 0x0000)
struct FLightBeamQueryData final
{
public:
	class AActor*                                 Actor;                                             // 0x0000(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	ELightBeamQueryActorType                      ActorType;                                         // 0x0008(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_9[0x7];                                        // 0x0009(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	class AActor*                                 OtherActor;                                        // 0x0010(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TSubclassOf<class ULightBeamData>             BeamClass;                                         // 0x0018(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   NameId;                                            // 0x0020(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FLightBeamQueryData) == 0x000008, "Wrong alignment on FLightBeamQueryData");
static_assert(sizeof(FLightBeamQueryData) == 0x000028, "Wrong size on FLightBeamQueryData");
static_assert(offsetof(FLightBeamQueryData, Actor) == 0x000000, "Member 'FLightBeamQueryData::Actor' has a wrong offset!");
static_assert(offsetof(FLightBeamQueryData, ActorType) == 0x000008, "Member 'FLightBeamQueryData::ActorType' has a wrong offset!");
static_assert(offsetof(FLightBeamQueryData, OtherActor) == 0x000010, "Member 'FLightBeamQueryData::OtherActor' has a wrong offset!");
static_assert(offsetof(FLightBeamQueryData, BeamClass) == 0x000018, "Member 'FLightBeamQueryData::BeamClass' has a wrong offset!");
static_assert(offsetof(FLightBeamQueryData, NameId) == 0x000020, "Member 'FLightBeamQueryData::NameId' has a wrong offset!");

// ScriptStruct GbxWeapon.LightBeamParticlePoolData
// 0x0010 (0x0010 - 0x0000)
struct FLightBeamParticlePoolData final
{
public:
	class UParticleSystemComponent*               PSC;                                               // 0x0000(0x0008)(ExportObject, ZeroConstructor, Transient, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_8[0x8];                                        // 0x0008(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FLightBeamParticlePoolData) == 0x000008, "Wrong alignment on FLightBeamParticlePoolData");
static_assert(sizeof(FLightBeamParticlePoolData) == 0x000010, "Wrong size on FLightBeamParticlePoolData");
static_assert(offsetof(FLightBeamParticlePoolData, PSC) == 0x000000, "Member 'FLightBeamParticlePoolData::PSC' has a wrong offset!");

// ScriptStruct GbxWeapon.WeaponSkeletalControlState
// 0x0028 (0x0028 - 0x0000)
struct alignas(0x08) FWeaponSkeletalControlState final
{
public:
	uint8                                         Pad_0[0x28];                                       // 0x0000(0x0028)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FWeaponSkeletalControlState) == 0x000008, "Wrong alignment on FWeaponSkeletalControlState");
static_assert(sizeof(FWeaponSkeletalControlState) == 0x000028, "Wrong size on FWeaponSkeletalControlState");

// ScriptStruct GbxWeapon.LightProjectileRingSubdivisionSettings
// 0x000C (0x000C - 0x0000)
struct FLightProjectileRingSubdivisionSettings final
{
public:
	int32                                         MaxSubdivisions;                                   // 0x0000(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	ELightProjectileSubdivisionMode               ValueMode;                                         // 0x0004(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         Value;                                             // 0x0008(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FLightProjectileRingSubdivisionSettings) == 0x000004, "Wrong alignment on FLightProjectileRingSubdivisionSettings");
static_assert(sizeof(FLightProjectileRingSubdivisionSettings) == 0x00000C, "Wrong size on FLightProjectileRingSubdivisionSettings");
static_assert(offsetof(FLightProjectileRingSubdivisionSettings, MaxSubdivisions) == 0x000000, "Member 'FLightProjectileRingSubdivisionSettings::MaxSubdivisions' has a wrong offset!");
static_assert(offsetof(FLightProjectileRingSubdivisionSettings, ValueMode) == 0x000004, "Member 'FLightProjectileRingSubdivisionSettings::ValueMode' has a wrong offset!");
static_assert(offsetof(FLightProjectileRingSubdivisionSettings, Value) == 0x000008, "Member 'FLightProjectileRingSubdivisionSettings::Value' has a wrong offset!");

// ScriptStruct GbxWeapon.PostLightBeamTickFunction
// 0x0008 (0x0058 - 0x0050)
struct FPostLightBeamTickFunction final : public FTickFunction
{
public:
	uint8                                         Pad_50[0x8];                                       // 0x0050(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FPostLightBeamTickFunction) == 0x000008, "Wrong alignment on FPostLightBeamTickFunction");
static_assert(sizeof(FPostLightBeamTickFunction) == 0x000058, "Wrong size on FPostLightBeamTickFunction");

// ScriptStruct GbxWeapon.LightProjectileTickFunction
// 0x0008 (0x0058 - 0x0050)
struct FLightProjectileTickFunction final : public FTickFunction
{
public:
	uint8                                         Pad_50[0x8];                                       // 0x0050(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FLightProjectileTickFunction) == 0x000008, "Wrong alignment on FLightProjectileTickFunction");
static_assert(sizeof(FLightProjectileTickFunction) == 0x000058, "Wrong size on FLightProjectileTickFunction");

// ScriptStruct GbxWeapon.WeaponMaterialEffectInstance
// 0x0068 (0x0068 - 0x0000)
struct FWeaponMaterialEffectInstance final
{
public:
	uint8                                         Pad_0[0x48];                                       // 0x0000(0x0048)(Fixing Size After Last Property [ Dumper-7 ])
	class UCurveFloat*                            ValueOverTime;                                     // 0x0048(0x0008)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_50[0x18];                                      // 0x0050(0x0018)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FWeaponMaterialEffectInstance) == 0x000008, "Wrong alignment on FWeaponMaterialEffectInstance");
static_assert(sizeof(FWeaponMaterialEffectInstance) == 0x000068, "Wrong size on FWeaponMaterialEffectInstance");
static_assert(offsetof(FWeaponMaterialEffectInstance, ValueOverTime) == 0x000048, "Member 'FWeaponMaterialEffectInstance::ValueOverTime' has a wrong offset!");

// ScriptStruct GbxWeapon.LightProjectileExplodeData
// 0x0010 (0x0010 - 0x0000)
struct FLightProjectileExplodeData final
{
public:
	bool                                          bHitActor;                                         // 0x0000(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1[0x3];                                        // 0x0001(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	struct FVector_NetQuantize                    Location;                                          // 0x0004(0x000C)(NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FLightProjectileExplodeData) == 0x000004, "Wrong alignment on FLightProjectileExplodeData");
static_assert(sizeof(FLightProjectileExplodeData) == 0x000010, "Wrong size on FLightProjectileExplodeData");
static_assert(offsetof(FLightProjectileExplodeData, bHitActor) == 0x000000, "Member 'FLightProjectileExplodeData::bHitActor' has a wrong offset!");
static_assert(offsetof(FLightProjectileExplodeData, Location) == 0x000004, "Member 'FLightProjectileExplodeData::Location' has a wrong offset!");

// ScriptStruct GbxWeapon.WeaponTriggerFireThreasholdData
// 0x0004 (0x0004 - 0x0000)
struct FWeaponTriggerFireThreasholdData final
{
public:
	float                                         Position;                                          // 0x0000(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FWeaponTriggerFireThreasholdData) == 0x000004, "Wrong alignment on FWeaponTriggerFireThreasholdData");
static_assert(sizeof(FWeaponTriggerFireThreasholdData) == 0x000004, "Wrong size on FWeaponTriggerFireThreasholdData");
static_assert(offsetof(FWeaponTriggerFireThreasholdData, Position) == 0x000000, "Member 'FWeaponTriggerFireThreasholdData::Position' has a wrong offset!");

// ScriptStruct GbxWeapon.LightProjectileBatchTickFunction
// 0x0010 (0x0060 - 0x0050)
struct FLightProjectileBatchTickFunction final : public FTickFunction
{
public:
	uint8                                         Pad_50[0x10];                                      // 0x0050(0x0010)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FLightProjectileBatchTickFunction) == 0x000008, "Wrong alignment on FLightProjectileBatchTickFunction");
static_assert(sizeof(FLightProjectileBatchTickFunction) == 0x000060, "Wrong size on FLightProjectileBatchTickFunction");

// ScriptStruct GbxWeapon.ReplicatedLightProjectileInitializationData
// 0x00B8 (0x00B8 - 0x0000)
struct FReplicatedLightProjectileInitializationData final
{
public:
	uint8                                         CreationID;                                        // 0x0000(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1[0x7];                                        // 0x0001(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	TSubclassOf<class ULightProjectileData>       DataBlueprint;                                     // 0x0008(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector_NetQuantize10                  StartLocation;                                     // 0x0010(0x000C)(NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector_NetQuantize10                  EndLocation;                                       // 0x001C(0x000C)(NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FRotator                               StartRotationOverride;                             // 0x0028(0x000C)(IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
	uint8                                         Pad_34[0x4];                                       // 0x0034(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class APawn*                                  Instigator;                                        // 0x0038(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class AActor*                                 Source;                                            // 0x0040(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class AActor*                                 Target;                                            // 0x0048(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector_NetQuantize100                 TargetOffset;                                      // 0x0050(0x000C)(NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_5C[0x4];                                       // 0x005C(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class AActor*                                 DamageCauser;                                      // 0x0060(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UImpactData*                            ImpactDataOverride;                                // 0x0068(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         SpeedScale;                                        // 0x0070(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         GravityScaleOverride;                              // 0x0074(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint16                                        Flags;                                             // 0x0078(0x0002)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EWeaponShotModifierType                       ModifierType;                                      // 0x007A(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         FiringPatternID;                                   // 0x007B(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         FireSocketID;                                      // 0x007C(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         RandomSeed;                                        // 0x007D(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_7E[0x2];                                       // 0x007E(0x0002)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         Damage;                                            // 0x0080(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_84[0x4];                                       // 0x0084(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	TSubclassOf<class UGbxDamageType>             DamageType;                                        // 0x0088(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TSubclassOf<class UDamageSource>              DamageSource;                                      // 0x0090(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         DamageRadius;                                      // 0x0098(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         ImpactForce;                                       // 0x009C(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         ModifierValue;                                     // 0x00A0(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_A4[0x4];                                       // 0x00A4(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class UParticleSystem*                        TracerFXOverride;                                  // 0x00A8(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UWwiseEvent*                            BulletByAdditiveLayer;                             // 0x00B0(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FReplicatedLightProjectileInitializationData) == 0x000008, "Wrong alignment on FReplicatedLightProjectileInitializationData");
static_assert(sizeof(FReplicatedLightProjectileInitializationData) == 0x0000B8, "Wrong size on FReplicatedLightProjectileInitializationData");
static_assert(offsetof(FReplicatedLightProjectileInitializationData, CreationID) == 0x000000, "Member 'FReplicatedLightProjectileInitializationData::CreationID' has a wrong offset!");
static_assert(offsetof(FReplicatedLightProjectileInitializationData, DataBlueprint) == 0x000008, "Member 'FReplicatedLightProjectileInitializationData::DataBlueprint' has a wrong offset!");
static_assert(offsetof(FReplicatedLightProjectileInitializationData, StartLocation) == 0x000010, "Member 'FReplicatedLightProjectileInitializationData::StartLocation' has a wrong offset!");
static_assert(offsetof(FReplicatedLightProjectileInitializationData, EndLocation) == 0x00001C, "Member 'FReplicatedLightProjectileInitializationData::EndLocation' has a wrong offset!");
static_assert(offsetof(FReplicatedLightProjectileInitializationData, StartRotationOverride) == 0x000028, "Member 'FReplicatedLightProjectileInitializationData::StartRotationOverride' has a wrong offset!");
static_assert(offsetof(FReplicatedLightProjectileInitializationData, Instigator) == 0x000038, "Member 'FReplicatedLightProjectileInitializationData::Instigator' has a wrong offset!");
static_assert(offsetof(FReplicatedLightProjectileInitializationData, Source) == 0x000040, "Member 'FReplicatedLightProjectileInitializationData::Source' has a wrong offset!");
static_assert(offsetof(FReplicatedLightProjectileInitializationData, Target) == 0x000048, "Member 'FReplicatedLightProjectileInitializationData::Target' has a wrong offset!");
static_assert(offsetof(FReplicatedLightProjectileInitializationData, TargetOffset) == 0x000050, "Member 'FReplicatedLightProjectileInitializationData::TargetOffset' has a wrong offset!");
static_assert(offsetof(FReplicatedLightProjectileInitializationData, DamageCauser) == 0x000060, "Member 'FReplicatedLightProjectileInitializationData::DamageCauser' has a wrong offset!");
static_assert(offsetof(FReplicatedLightProjectileInitializationData, ImpactDataOverride) == 0x000068, "Member 'FReplicatedLightProjectileInitializationData::ImpactDataOverride' has a wrong offset!");
static_assert(offsetof(FReplicatedLightProjectileInitializationData, SpeedScale) == 0x000070, "Member 'FReplicatedLightProjectileInitializationData::SpeedScale' has a wrong offset!");
static_assert(offsetof(FReplicatedLightProjectileInitializationData, GravityScaleOverride) == 0x000074, "Member 'FReplicatedLightProjectileInitializationData::GravityScaleOverride' has a wrong offset!");
static_assert(offsetof(FReplicatedLightProjectileInitializationData, Flags) == 0x000078, "Member 'FReplicatedLightProjectileInitializationData::Flags' has a wrong offset!");
static_assert(offsetof(FReplicatedLightProjectileInitializationData, ModifierType) == 0x00007A, "Member 'FReplicatedLightProjectileInitializationData::ModifierType' has a wrong offset!");
static_assert(offsetof(FReplicatedLightProjectileInitializationData, FiringPatternID) == 0x00007B, "Member 'FReplicatedLightProjectileInitializationData::FiringPatternID' has a wrong offset!");
static_assert(offsetof(FReplicatedLightProjectileInitializationData, FireSocketID) == 0x00007C, "Member 'FReplicatedLightProjectileInitializationData::FireSocketID' has a wrong offset!");
static_assert(offsetof(FReplicatedLightProjectileInitializationData, RandomSeed) == 0x00007D, "Member 'FReplicatedLightProjectileInitializationData::RandomSeed' has a wrong offset!");
static_assert(offsetof(FReplicatedLightProjectileInitializationData, Damage) == 0x000080, "Member 'FReplicatedLightProjectileInitializationData::Damage' has a wrong offset!");
static_assert(offsetof(FReplicatedLightProjectileInitializationData, DamageType) == 0x000088, "Member 'FReplicatedLightProjectileInitializationData::DamageType' has a wrong offset!");
static_assert(offsetof(FReplicatedLightProjectileInitializationData, DamageSource) == 0x000090, "Member 'FReplicatedLightProjectileInitializationData::DamageSource' has a wrong offset!");
static_assert(offsetof(FReplicatedLightProjectileInitializationData, DamageRadius) == 0x000098, "Member 'FReplicatedLightProjectileInitializationData::DamageRadius' has a wrong offset!");
static_assert(offsetof(FReplicatedLightProjectileInitializationData, ImpactForce) == 0x00009C, "Member 'FReplicatedLightProjectileInitializationData::ImpactForce' has a wrong offset!");
static_assert(offsetof(FReplicatedLightProjectileInitializationData, ModifierValue) == 0x0000A0, "Member 'FReplicatedLightProjectileInitializationData::ModifierValue' has a wrong offset!");
static_assert(offsetof(FReplicatedLightProjectileInitializationData, TracerFXOverride) == 0x0000A8, "Member 'FReplicatedLightProjectileInitializationData::TracerFXOverride' has a wrong offset!");
static_assert(offsetof(FReplicatedLightProjectileInitializationData, BulletByAdditiveLayer) == 0x0000B0, "Member 'FReplicatedLightProjectileInitializationData::BulletByAdditiveLayer' has a wrong offset!");

// ScriptStruct GbxWeapon.LightProjectileQueryData
// 0x0020 (0x0020 - 0x0000)
struct FLightProjectileQueryData final
{
public:
	class AActor*                                 Actor;                                             // 0x0000(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	ELightProjectileQueryActorType                ActorType;                                         // 0x0008(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_9[0x7];                                        // 0x0009(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	TSubclassOf<class ULightProjectileData>       ProjectileClass;                                   // 0x0010(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   NameId;                                            // 0x0018(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FLightProjectileQueryData) == 0x000008, "Wrong alignment on FLightProjectileQueryData");
static_assert(sizeof(FLightProjectileQueryData) == 0x000020, "Wrong size on FLightProjectileQueryData");
static_assert(offsetof(FLightProjectileQueryData, Actor) == 0x000000, "Member 'FLightProjectileQueryData::Actor' has a wrong offset!");
static_assert(offsetof(FLightProjectileQueryData, ActorType) == 0x000008, "Member 'FLightProjectileQueryData::ActorType' has a wrong offset!");
static_assert(offsetof(FLightProjectileQueryData, ProjectileClass) == 0x000010, "Member 'FLightProjectileQueryData::ProjectileClass' has a wrong offset!");
static_assert(offsetof(FLightProjectileQueryData, NameId) == 0x000018, "Member 'FLightProjectileQueryData::NameId' has a wrong offset!");

// ScriptStruct GbxWeapon.LightProjectileAudioProperties
// 0x0040 (0x0040 - 0x0000)
struct FLightProjectileAudioProperties final
{
public:
	class UWwiseEvent*                            BulletByEntrance;                                  // 0x0000(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UWwiseEvent*                            BulletByBody;                                      // 0x0008(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UWwiseEvent*                            BulletByExit;                                      // 0x0010(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         BulletByMaxDistance;                               // 0x0018(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         BulletByChance;                                    // 0x001C(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TSubclassOf<class UEffectCollectionData>      TravellingAudioFxCollection;                       // 0x0020(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UWwiseEvent*                            TravellingAudio;                                   // 0x0028(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         TravellingAudioComponentSize;                      // 0x0030(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_34[0x4];                                       // 0x0034(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class UWwiseRtpc*                             ListenerApproachSpeedRtpc;                         // 0x0038(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FLightProjectileAudioProperties) == 0x000008, "Wrong alignment on FLightProjectileAudioProperties");
static_assert(sizeof(FLightProjectileAudioProperties) == 0x000040, "Wrong size on FLightProjectileAudioProperties");
static_assert(offsetof(FLightProjectileAudioProperties, BulletByEntrance) == 0x000000, "Member 'FLightProjectileAudioProperties::BulletByEntrance' has a wrong offset!");
static_assert(offsetof(FLightProjectileAudioProperties, BulletByBody) == 0x000008, "Member 'FLightProjectileAudioProperties::BulletByBody' has a wrong offset!");
static_assert(offsetof(FLightProjectileAudioProperties, BulletByExit) == 0x000010, "Member 'FLightProjectileAudioProperties::BulletByExit' has a wrong offset!");
static_assert(offsetof(FLightProjectileAudioProperties, BulletByMaxDistance) == 0x000018, "Member 'FLightProjectileAudioProperties::BulletByMaxDistance' has a wrong offset!");
static_assert(offsetof(FLightProjectileAudioProperties, BulletByChance) == 0x00001C, "Member 'FLightProjectileAudioProperties::BulletByChance' has a wrong offset!");
static_assert(offsetof(FLightProjectileAudioProperties, TravellingAudioFxCollection) == 0x000020, "Member 'FLightProjectileAudioProperties::TravellingAudioFxCollection' has a wrong offset!");
static_assert(offsetof(FLightProjectileAudioProperties, TravellingAudio) == 0x000028, "Member 'FLightProjectileAudioProperties::TravellingAudio' has a wrong offset!");
static_assert(offsetof(FLightProjectileAudioProperties, TravellingAudioComponentSize) == 0x000030, "Member 'FLightProjectileAudioProperties::TravellingAudioComponentSize' has a wrong offset!");
static_assert(offsetof(FLightProjectileAudioProperties, ListenerApproachSpeedRtpc) == 0x000038, "Member 'FLightProjectileAudioProperties::ListenerApproachSpeedRtpc' has a wrong offset!");

// ScriptStruct GbxWeapon.WeaponMaterialEffectData
// 0x0060 (0x0060 - 0x0000)
struct FWeaponMaterialEffectData final
{
public:
	class FName                                   MaterialParamName;                                 // 0x0000(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EWeaponAttachmentVisibilityType               Visibility;                                        // 0x0008(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EWeaponMaterialEffectBlendMode                BlendMode;                                         // 0x0009(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         bPlayOnlyOnActiveSlot : 1;                         // 0x000A(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (Edit, BlueprintVisible, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         bLoop : 1;                                         // 0x000A(0x0001)(BitIndex: 0x01, PropSize: 0x0001 (Edit, BlueprintVisible, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         bApplyAttribute : 1;                               // 0x000A(0x0001)(BitIndex: 0x02, PropSize: 0x0001 (Edit, BlueprintVisible, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         bScaleAttributeByValueOverTime : 1;                // 0x000A(0x0001)(BitIndex: 0x03, PropSize: 0x0001 (Edit, BlueprintVisible, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         bScaleAttributeByDeltaTime : 1;                    // 0x000A(0x0001)(BitIndex: 0x04, PropSize: 0x0001 (Edit, BlueprintVisible, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         Pad_B[0x5];                                        // 0x000B(0x0005)(Fixing Size After Last Property [ Dumper-7 ])
	struct FAttributeInitializationData           AttributeValue;                                    // 0x0010(0x0038)(Edit, BlueprintVisible, NoDestructor, NativeAccessSpecifierPublic)
	class UCurveFloat*                            ValueOverTime;                                     // 0x0048(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         Impulse;                                           // 0x0050(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         Duration;                                          // 0x0054(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         DecayRate;                                         // 0x0058(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         MaxValue;                                          // 0x005C(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FWeaponMaterialEffectData) == 0x000008, "Wrong alignment on FWeaponMaterialEffectData");
static_assert(sizeof(FWeaponMaterialEffectData) == 0x000060, "Wrong size on FWeaponMaterialEffectData");
static_assert(offsetof(FWeaponMaterialEffectData, MaterialParamName) == 0x000000, "Member 'FWeaponMaterialEffectData::MaterialParamName' has a wrong offset!");
static_assert(offsetof(FWeaponMaterialEffectData, Visibility) == 0x000008, "Member 'FWeaponMaterialEffectData::Visibility' has a wrong offset!");
static_assert(offsetof(FWeaponMaterialEffectData, BlendMode) == 0x000009, "Member 'FWeaponMaterialEffectData::BlendMode' has a wrong offset!");
static_assert(offsetof(FWeaponMaterialEffectData, AttributeValue) == 0x000010, "Member 'FWeaponMaterialEffectData::AttributeValue' has a wrong offset!");
static_assert(offsetof(FWeaponMaterialEffectData, ValueOverTime) == 0x000048, "Member 'FWeaponMaterialEffectData::ValueOverTime' has a wrong offset!");
static_assert(offsetof(FWeaponMaterialEffectData, Impulse) == 0x000050, "Member 'FWeaponMaterialEffectData::Impulse' has a wrong offset!");
static_assert(offsetof(FWeaponMaterialEffectData, Duration) == 0x000054, "Member 'FWeaponMaterialEffectData::Duration' has a wrong offset!");
static_assert(offsetof(FWeaponMaterialEffectData, DecayRate) == 0x000058, "Member 'FWeaponMaterialEffectData::DecayRate' has a wrong offset!");
static_assert(offsetof(FWeaponMaterialEffectData, MaxValue) == 0x00005C, "Member 'FWeaponMaterialEffectData::MaxValue' has a wrong offset!");

// ScriptStruct GbxWeapon.LightProjectileRingSettings
// 0x0030 (0x0030 - 0x0000)
struct FLightProjectileRingSettings final
{
public:
	float                                         InitialRadius;                                     // 0x0000(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         Angle;                                             // 0x0004(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         InitialProjectileCount;                            // 0x0008(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bMakeSolidRing;                                    // 0x000C(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bUseBodyMeshBoundsForCollision;                    // 0x000D(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_E[0x2];                                        // 0x000E(0x0002)(Fixing Size After Last Property [ Dumper-7 ])
	struct FLightProjectileRingSubdivisionSettings Subdivide;                                         // 0x0010(0x000C)(Edit, NoDestructor, NativeAccessSpecifierPublic)
	bool                                          bSubdivide;                                        // 0x001C(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1D[0x3];                                       // 0x001D(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	struct FVector                                RingAxis;                                          // 0x0020(0x000C)(Edit, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bUseRingAxis;                                      // 0x002C(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2D[0x3];                                       // 0x002D(0x0003)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FLightProjectileRingSettings) == 0x000004, "Wrong alignment on FLightProjectileRingSettings");
static_assert(sizeof(FLightProjectileRingSettings) == 0x000030, "Wrong size on FLightProjectileRingSettings");
static_assert(offsetof(FLightProjectileRingSettings, InitialRadius) == 0x000000, "Member 'FLightProjectileRingSettings::InitialRadius' has a wrong offset!");
static_assert(offsetof(FLightProjectileRingSettings, Angle) == 0x000004, "Member 'FLightProjectileRingSettings::Angle' has a wrong offset!");
static_assert(offsetof(FLightProjectileRingSettings, InitialProjectileCount) == 0x000008, "Member 'FLightProjectileRingSettings::InitialProjectileCount' has a wrong offset!");
static_assert(offsetof(FLightProjectileRingSettings, bMakeSolidRing) == 0x00000C, "Member 'FLightProjectileRingSettings::bMakeSolidRing' has a wrong offset!");
static_assert(offsetof(FLightProjectileRingSettings, bUseBodyMeshBoundsForCollision) == 0x00000D, "Member 'FLightProjectileRingSettings::bUseBodyMeshBoundsForCollision' has a wrong offset!");
static_assert(offsetof(FLightProjectileRingSettings, Subdivide) == 0x000010, "Member 'FLightProjectileRingSettings::Subdivide' has a wrong offset!");
static_assert(offsetof(FLightProjectileRingSettings, bSubdivide) == 0x00001C, "Member 'FLightProjectileRingSettings::bSubdivide' has a wrong offset!");
static_assert(offsetof(FLightProjectileRingSettings, RingAxis) == 0x000020, "Member 'FLightProjectileRingSettings::RingAxis' has a wrong offset!");
static_assert(offsetof(FLightProjectileRingSettings, bUseRingAxis) == 0x00002C, "Member 'FLightProjectileRingSettings::bUseRingAxis' has a wrong offset!");

// ScriptStruct GbxWeapon.LightProjectileTimedEvent
// 0x0010 (0x0010 - 0x0000)
struct alignas(0x08) FLightProjectileTimedEvent final
{
public:
	float                                         Time;                                              // 0x0000(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_4[0x4];                                        // 0x0004(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class FName                                   CustomEvent;                                       // 0x0008(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FLightProjectileTimedEvent) == 0x000008, "Wrong alignment on FLightProjectileTimedEvent");
static_assert(sizeof(FLightProjectileTimedEvent) == 0x000010, "Wrong size on FLightProjectileTimedEvent");
static_assert(offsetof(FLightProjectileTimedEvent, Time) == 0x000000, "Member 'FLightProjectileTimedEvent::Time' has a wrong offset!");
static_assert(offsetof(FLightProjectileTimedEvent, CustomEvent) == 0x000008, "Member 'FLightProjectileTimedEvent::CustomEvent' has a wrong offset!");

// ScriptStruct GbxWeapon.WeaponTriggerWeaponData
// 0x000C (0x000C - 0x0000)
struct FWeaponTriggerWeaponData final
{
public:
	float                                         StartPosition;                                     // 0x0000(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         EndPosition;                                       // 0x0004(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         Force;                                             // 0x0008(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FWeaponTriggerWeaponData) == 0x000004, "Wrong alignment on FWeaponTriggerWeaponData");
static_assert(sizeof(FWeaponTriggerWeaponData) == 0x00000C, "Wrong size on FWeaponTriggerWeaponData");
static_assert(offsetof(FWeaponTriggerWeaponData, StartPosition) == 0x000000, "Member 'FWeaponTriggerWeaponData::StartPosition' has a wrong offset!");
static_assert(offsetof(FWeaponTriggerWeaponData, EndPosition) == 0x000004, "Member 'FWeaponTriggerWeaponData::EndPosition' has a wrong offset!");
static_assert(offsetof(FWeaponTriggerWeaponData, Force) == 0x000008, "Member 'FWeaponTriggerWeaponData::Force' has a wrong offset!");

// ScriptStruct GbxWeapon.LightProjectileParticlePoolData
// 0x0010 (0x0010 - 0x0000)
struct FLightProjectileParticlePoolData final
{
public:
	class UParticleSystemComponent*               PSC;                                               // 0x0000(0x0008)(ExportObject, ZeroConstructor, Transient, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_8[0x8];                                        // 0x0008(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FLightProjectileParticlePoolData) == 0x000008, "Wrong alignment on FLightProjectileParticlePoolData");
static_assert(sizeof(FLightProjectileParticlePoolData) == 0x000010, "Wrong size on FLightProjectileParticlePoolData");
static_assert(offsetof(FLightProjectileParticlePoolData, PSC) == 0x000000, "Member 'FLightProjectileParticlePoolData::PSC' has a wrong offset!");

// ScriptStruct GbxWeapon.WeaponChargeEventNotify
// 0x0010 (0x0010 - 0x0000)
struct alignas(0x08) FWeaponChargeEventNotify final
{
public:
	float                                         Threshold;                                         // 0x0000(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EWeaponChargeComparisonOperatorType           Comparision;                                       // 0x0004(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EWeaponChargeEventType                        EVENTTYPE;                                         // 0x0005(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_6[0x2];                                        // 0x0006(0x0002)(Fixing Size After Last Property [ Dumper-7 ])
	class FName                                   EventName;                                         // 0x0008(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FWeaponChargeEventNotify) == 0x000008, "Wrong alignment on FWeaponChargeEventNotify");
static_assert(sizeof(FWeaponChargeEventNotify) == 0x000010, "Wrong size on FWeaponChargeEventNotify");
static_assert(offsetof(FWeaponChargeEventNotify, Threshold) == 0x000000, "Member 'FWeaponChargeEventNotify::Threshold' has a wrong offset!");
static_assert(offsetof(FWeaponChargeEventNotify, Comparision) == 0x000004, "Member 'FWeaponChargeEventNotify::Comparision' has a wrong offset!");
static_assert(offsetof(FWeaponChargeEventNotify, EVENTTYPE) == 0x000005, "Member 'FWeaponChargeEventNotify::EVENTTYPE' has a wrong offset!");
static_assert(offsetof(FWeaponChargeEventNotify, EventName) == 0x000008, "Member 'FWeaponChargeEventNotify::EventName' has a wrong offset!");

// ScriptStruct GbxWeapon.PostLightProjectileTickFunction
// 0x0008 (0x0058 - 0x0050)
struct FPostLightProjectileTickFunction final : public FTickFunction
{
public:
	uint8                                         Pad_50[0x8];                                       // 0x0050(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FPostLightProjectileTickFunction) == 0x000008, "Wrong alignment on FPostLightProjectileTickFunction");
static_assert(sizeof(FPostLightProjectileTickFunction) == 0x000058, "Wrong size on FPostLightProjectileTickFunction");

// ScriptStruct GbxWeapon.ThrowProjectileAsyncRequest
// 0x0188 (0x0188 - 0x0000)
struct FThrowProjectileAsyncRequest final
{
public:
	TSubclassOf<class AProjectile>                Class;                                             // 0x0000(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class AActor*                                 Source;                                            // 0x0008(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   SourceSocket;                                      // 0x0010(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, AdvancedDisplay, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class AActor*                                 Target;                                            // 0x0018(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   TargetSocket;                                      // 0x0020(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, AdvancedDisplay, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                TargetOffset;                                      // 0x0028(0x000C)(Edit, BlueprintVisible, IsPlainOldData, NoDestructor, AdvancedDisplay, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         MaxPrediction;                                     // 0x0034(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, AdvancedDisplay, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         Speed;                                             // 0x0038(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, AdvancedDisplay, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         AnglePercent;                                      // 0x003C(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, AdvancedDisplay, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FRotator                               DirectionOffset;                                   // 0x0040(0x000C)(Edit, BlueprintVisible, IsPlainOldData, NoDestructor, AdvancedDisplay, NativeAccessSpecifierPublic)
	int32                                         InstanceCount;                                     // 0x004C(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, AdvancedDisplay, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         InstanceDelay;                                     // 0x0050(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, AdvancedDisplay, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_54[0x4];                                       // 0x0054(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	struct FGbxExposeOnSpawnValueCache            ExposeOnSpawnCache;                                // 0x0058(0x0110)(BlueprintVisible, BlueprintReadOnly, AdvancedDisplay, NativeAccessSpecifierPublic)
	TDelegate<void(class AActor* Actor, int32 InstanceIndex)> Spawned;                                           // 0x0168(0x0010)(Edit, BlueprintVisible, ZeroConstructor, InstancedReference, NoDestructor, AdvancedDisplay, NativeAccessSpecifierPublic)
	TDelegate<void(class AActor* Actor, int32 InstanceIndex)> Failed;                                            // 0x0178(0x0010)(Edit, BlueprintVisible, ZeroConstructor, InstancedReference, NoDestructor, AdvancedDisplay, NativeAccessSpecifierPublic)
};
static_assert(alignof(FThrowProjectileAsyncRequest) == 0x000008, "Wrong alignment on FThrowProjectileAsyncRequest");
static_assert(sizeof(FThrowProjectileAsyncRequest) == 0x000188, "Wrong size on FThrowProjectileAsyncRequest");
static_assert(offsetof(FThrowProjectileAsyncRequest, Class) == 0x000000, "Member 'FThrowProjectileAsyncRequest::Class' has a wrong offset!");
static_assert(offsetof(FThrowProjectileAsyncRequest, Source) == 0x000008, "Member 'FThrowProjectileAsyncRequest::Source' has a wrong offset!");
static_assert(offsetof(FThrowProjectileAsyncRequest, SourceSocket) == 0x000010, "Member 'FThrowProjectileAsyncRequest::SourceSocket' has a wrong offset!");
static_assert(offsetof(FThrowProjectileAsyncRequest, Target) == 0x000018, "Member 'FThrowProjectileAsyncRequest::Target' has a wrong offset!");
static_assert(offsetof(FThrowProjectileAsyncRequest, TargetSocket) == 0x000020, "Member 'FThrowProjectileAsyncRequest::TargetSocket' has a wrong offset!");
static_assert(offsetof(FThrowProjectileAsyncRequest, TargetOffset) == 0x000028, "Member 'FThrowProjectileAsyncRequest::TargetOffset' has a wrong offset!");
static_assert(offsetof(FThrowProjectileAsyncRequest, MaxPrediction) == 0x000034, "Member 'FThrowProjectileAsyncRequest::MaxPrediction' has a wrong offset!");
static_assert(offsetof(FThrowProjectileAsyncRequest, Speed) == 0x000038, "Member 'FThrowProjectileAsyncRequest::Speed' has a wrong offset!");
static_assert(offsetof(FThrowProjectileAsyncRequest, AnglePercent) == 0x00003C, "Member 'FThrowProjectileAsyncRequest::AnglePercent' has a wrong offset!");
static_assert(offsetof(FThrowProjectileAsyncRequest, DirectionOffset) == 0x000040, "Member 'FThrowProjectileAsyncRequest::DirectionOffset' has a wrong offset!");
static_assert(offsetof(FThrowProjectileAsyncRequest, InstanceCount) == 0x00004C, "Member 'FThrowProjectileAsyncRequest::InstanceCount' has a wrong offset!");
static_assert(offsetof(FThrowProjectileAsyncRequest, InstanceDelay) == 0x000050, "Member 'FThrowProjectileAsyncRequest::InstanceDelay' has a wrong offset!");
static_assert(offsetof(FThrowProjectileAsyncRequest, ExposeOnSpawnCache) == 0x000058, "Member 'FThrowProjectileAsyncRequest::ExposeOnSpawnCache' has a wrong offset!");
static_assert(offsetof(FThrowProjectileAsyncRequest, Spawned) == 0x000168, "Member 'FThrowProjectileAsyncRequest::Spawned' has a wrong offset!");
static_assert(offsetof(FThrowProjectileAsyncRequest, Failed) == 0x000178, "Member 'FThrowProjectileAsyncRequest::Failed' has a wrong offset!");

// ScriptStruct GbxWeapon.WeaponAttachState
// 0x0018 (0x0018 - 0x0000)
struct FWeaponAttachState final
{
public:
	uint32                                        NetworkID;                                         // 0x0000(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Slot;                                              // 0x0004(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_5[0x3];                                        // 0x0005(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	class APawn*                                  Instigator;                                        // 0x0008(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EWeaponEquipType                              EquipType;                                         // 0x0010(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EWeaponPutDownType                            PutDownType;                                       // 0x0011(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_12[0x6];                                       // 0x0012(0x0006)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FWeaponAttachState) == 0x000008, "Wrong alignment on FWeaponAttachState");
static_assert(sizeof(FWeaponAttachState) == 0x000018, "Wrong size on FWeaponAttachState");
static_assert(offsetof(FWeaponAttachState, NetworkID) == 0x000000, "Member 'FWeaponAttachState::NetworkID' has a wrong offset!");
static_assert(offsetof(FWeaponAttachState, Slot) == 0x000004, "Member 'FWeaponAttachState::Slot' has a wrong offset!");
static_assert(offsetof(FWeaponAttachState, Instigator) == 0x000008, "Member 'FWeaponAttachState::Instigator' has a wrong offset!");
static_assert(offsetof(FWeaponAttachState, EquipType) == 0x000010, "Member 'FWeaponAttachState::EquipType' has a wrong offset!");
static_assert(offsetof(FWeaponAttachState, PutDownType) == 0x000011, "Member 'FWeaponAttachState::PutDownType' has a wrong offset!");

// ScriptStruct GbxWeapon.WeaponEffectQueryData
// 0x0010 (0x0010 - 0x0000)
struct FWeaponEffectQueryData final
{
public:
	EWeaponEffectType                             Type;                                              // 0x0000(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1[0x3];                                        // 0x0001(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	int32                                         ID;                                                // 0x0004(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EWeaponAttachmentVisibilityType               Visibility;                                        // 0x0008(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_9[0x3];                                        // 0x0009(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	int32                                         UseModeBitmask;                                    // 0x000C(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FWeaponEffectQueryData) == 0x000004, "Wrong alignment on FWeaponEffectQueryData");
static_assert(sizeof(FWeaponEffectQueryData) == 0x000010, "Wrong size on FWeaponEffectQueryData");
static_assert(offsetof(FWeaponEffectQueryData, Type) == 0x000000, "Member 'FWeaponEffectQueryData::Type' has a wrong offset!");
static_assert(offsetof(FWeaponEffectQueryData, ID) == 0x000004, "Member 'FWeaponEffectQueryData::ID' has a wrong offset!");
static_assert(offsetof(FWeaponEffectQueryData, Visibility) == 0x000008, "Member 'FWeaponEffectQueryData::Visibility' has a wrong offset!");
static_assert(offsetof(FWeaponEffectQueryData, UseModeBitmask) == 0x00000C, "Member 'FWeaponEffectQueryData::UseModeBitmask' has a wrong offset!");

// ScriptStruct GbxWeapon.WeaponUseModeState
// 0x0048 (0x0048 - 0x0000)
struct FWeaponUseModeState final
{
public:
	int32                                         InputChannels;                                     // 0x0000(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         PrimaryInputChannel;                               // 0x0004(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bReloadNeeded;                                     // 0x0005(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_6[0x2];                                        // 0x0006(0x0002)(Fixing Size After Last Property [ Dumper-7 ])
	class UWeaponUseComponent*                    UseComponent;                                      // 0x0008(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UWeaponAmmoComponent*                   AmmoComponent;                                     // 0x0010(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UWeaponReloadComponent*                 ReloadComponent;                                   // 0x0018(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UWeaponZoomComponent*                   ZoomComponent;                                     // 0x0020(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UWeaponAudioProviderComponent*          AudioProviderComponent;                            // 0x0028(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UDamageModifierComponent*               DamageModifierComponent;                           // 0x0030(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TArray<class UActorComponent*>                Components;                                        // 0x0038(0x0010)(ExportObject, ZeroConstructor, ContainsInstancedReference, NativeAccessSpecifierPublic)
};
static_assert(alignof(FWeaponUseModeState) == 0x000008, "Wrong alignment on FWeaponUseModeState");
static_assert(sizeof(FWeaponUseModeState) == 0x000048, "Wrong size on FWeaponUseModeState");
static_assert(offsetof(FWeaponUseModeState, InputChannels) == 0x000000, "Member 'FWeaponUseModeState::InputChannels' has a wrong offset!");
static_assert(offsetof(FWeaponUseModeState, PrimaryInputChannel) == 0x000004, "Member 'FWeaponUseModeState::PrimaryInputChannel' has a wrong offset!");
static_assert(offsetof(FWeaponUseModeState, bReloadNeeded) == 0x000005, "Member 'FWeaponUseModeState::bReloadNeeded' has a wrong offset!");
static_assert(offsetof(FWeaponUseModeState, UseComponent) == 0x000008, "Member 'FWeaponUseModeState::UseComponent' has a wrong offset!");
static_assert(offsetof(FWeaponUseModeState, AmmoComponent) == 0x000010, "Member 'FWeaponUseModeState::AmmoComponent' has a wrong offset!");
static_assert(offsetof(FWeaponUseModeState, ReloadComponent) == 0x000018, "Member 'FWeaponUseModeState::ReloadComponent' has a wrong offset!");
static_assert(offsetof(FWeaponUseModeState, ZoomComponent) == 0x000020, "Member 'FWeaponUseModeState::ZoomComponent' has a wrong offset!");
static_assert(offsetof(FWeaponUseModeState, AudioProviderComponent) == 0x000028, "Member 'FWeaponUseModeState::AudioProviderComponent' has a wrong offset!");
static_assert(offsetof(FWeaponUseModeState, DamageModifierComponent) == 0x000030, "Member 'FWeaponUseModeState::DamageModifierComponent' has a wrong offset!");
static_assert(offsetof(FWeaponUseModeState, Components) == 0x000038, "Member 'FWeaponUseModeState::Components' has a wrong offset!");

// ScriptStruct GbxWeapon.ConditionalActionInfo
// 0x0018 (0x0018 - 0x0000)
struct FConditionalActionInfo final
{
public:
	class UGbxCondition*                          Condition;                                         // 0x0000(0x0008)(Edit, ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, PersistentInstance, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TSubclassOf<class UGbxAction>                 Action;                                            // 0x0008(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EGbxActionNetMode                             ActionNetMode;                                     // 0x0010(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_11[0x7];                                       // 0x0011(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FConditionalActionInfo) == 0x000008, "Wrong alignment on FConditionalActionInfo");
static_assert(sizeof(FConditionalActionInfo) == 0x000018, "Wrong size on FConditionalActionInfo");
static_assert(offsetof(FConditionalActionInfo, Condition) == 0x000000, "Member 'FConditionalActionInfo::Condition' has a wrong offset!");
static_assert(offsetof(FConditionalActionInfo, Action) == 0x000008, "Member 'FConditionalActionInfo::Action' has a wrong offset!");
static_assert(offsetof(FConditionalActionInfo, ActionNetMode) == 0x000010, "Member 'FConditionalActionInfo::ActionNetMode' has a wrong offset!");

// ScriptStruct GbxWeapon.ConditionalWeaponActionSet
// 0x0018 (0x0018 - 0x0000)
struct FConditionalWeaponActionSet final
{
public:
	class UGbxCondition*                          Condition;                                         // 0x0000(0x0008)(Edit, ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, PersistentInstance, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TArray<struct FConditionalActionInfo>         ConditionalActions;                                // 0x0008(0x0010)(Edit, ZeroConstructor, ContainsInstancedReference, NativeAccessSpecifierPublic)
};
static_assert(alignof(FConditionalWeaponActionSet) == 0x000008, "Wrong alignment on FConditionalWeaponActionSet");
static_assert(sizeof(FConditionalWeaponActionSet) == 0x000018, "Wrong size on FConditionalWeaponActionSet");
static_assert(offsetof(FConditionalWeaponActionSet, Condition) == 0x000000, "Member 'FConditionalWeaponActionSet::Condition' has a wrong offset!");
static_assert(offsetof(FConditionalWeaponActionSet, ConditionalActions) == 0x000008, "Member 'FConditionalWeaponActionSet::ConditionalActions' has a wrong offset!");

// ScriptStruct GbxWeapon.BodyWeaponActionInfo
// 0x0030 (0x0030 - 0x0000)
struct FBodyWeaponActionInfo final
{
public:
	EWeaponActionType                             WeaponAction;                                      // 0x0000(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1[0x7];                                        // 0x0001(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	class UGbxCondition*                          Condition;                                         // 0x0008(0x0008)(Edit, ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, PersistentInstance, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TArray<struct FConditionalWeaponActionSet>    ConditionalWeaponActions;                          // 0x0010(0x0010)(Edit, ZeroConstructor, ContainsInstancedReference, NativeAccessSpecifierPublic)
	TArray<struct FConditionalActionInfo>         ConditionalActions;                                // 0x0020(0x0010)(ZeroConstructor, Deprecated, ContainsInstancedReference, NativeAccessSpecifierPublic)
};
static_assert(alignof(FBodyWeaponActionInfo) == 0x000008, "Wrong alignment on FBodyWeaponActionInfo");
static_assert(sizeof(FBodyWeaponActionInfo) == 0x000030, "Wrong size on FBodyWeaponActionInfo");
static_assert(offsetof(FBodyWeaponActionInfo, WeaponAction) == 0x000000, "Member 'FBodyWeaponActionInfo::WeaponAction' has a wrong offset!");
static_assert(offsetof(FBodyWeaponActionInfo, Condition) == 0x000008, "Member 'FBodyWeaponActionInfo::Condition' has a wrong offset!");
static_assert(offsetof(FBodyWeaponActionInfo, ConditionalWeaponActions) == 0x000010, "Member 'FBodyWeaponActionInfo::ConditionalWeaponActions' has a wrong offset!");
static_assert(offsetof(FBodyWeaponActionInfo, ConditionalActions) == 0x000020, "Member 'FBodyWeaponActionInfo::ConditionalActions' has a wrong offset!");

// ScriptStruct GbxWeapon.WeaponTrinketAttachment
// 0x0040 (0x0040 - 0x0000)
struct FWeaponTrinketAttachment final
{
public:
	class UGbxSkeletalMeshComponent*              MeshComponent;                                     // 0x0000(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class USkeletalMesh*                          SkeletalMesh;                                      // 0x0008(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TSubclassOf<class UAnimInstance>              AnimInstanceClass;                                 // 0x0010(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_18[0x28];                                      // 0x0018(0x0028)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FWeaponTrinketAttachment) == 0x000008, "Wrong alignment on FWeaponTrinketAttachment");
static_assert(sizeof(FWeaponTrinketAttachment) == 0x000040, "Wrong size on FWeaponTrinketAttachment");
static_assert(offsetof(FWeaponTrinketAttachment, MeshComponent) == 0x000000, "Member 'FWeaponTrinketAttachment::MeshComponent' has a wrong offset!");
static_assert(offsetof(FWeaponTrinketAttachment, SkeletalMesh) == 0x000008, "Member 'FWeaponTrinketAttachment::SkeletalMesh' has a wrong offset!");
static_assert(offsetof(FWeaponTrinketAttachment, AnimInstanceClass) == 0x000010, "Member 'FWeaponTrinketAttachment::AnimInstanceClass' has a wrong offset!");

// ScriptStruct GbxWeapon.WeaponEffectAttachment
// 0x0060 (0x0060 - 0x0000)
struct FWeaponEffectAttachment final
{
public:
	uint8                                         Pad_0[0x48];                                       // 0x0000(0x0048)(Fixing Size After Last Property [ Dumper-7 ])
	class UParticleSystem*                        Effect;                                            // 0x0048(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TSubclassOf<class UEffectCollectionData>      ConditionalEffect;                                 // 0x0050(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UParticleSystemComponent*               PSC;                                               // 0x0058(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FWeaponEffectAttachment) == 0x000008, "Wrong alignment on FWeaponEffectAttachment");
static_assert(sizeof(FWeaponEffectAttachment) == 0x000060, "Wrong size on FWeaponEffectAttachment");
static_assert(offsetof(FWeaponEffectAttachment, Effect) == 0x000048, "Member 'FWeaponEffectAttachment::Effect' has a wrong offset!");
static_assert(offsetof(FWeaponEffectAttachment, ConditionalEffect) == 0x000050, "Member 'FWeaponEffectAttachment::ConditionalEffect' has a wrong offset!");
static_assert(offsetof(FWeaponEffectAttachment, PSC) == 0x000058, "Member 'FWeaponEffectAttachment::PSC' has a wrong offset!");

// ScriptStruct GbxWeapon.WeaponChargeAttributeEffect
// 0x0060 (0x0060 - 0x0000)
struct FWeaponChargeAttributeEffect final
{
public:
	int32                                         StatesBitmask;                                     // 0x0000(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bApplyToInstigator;                                // 0x0004(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_5[0x3];                                        // 0x0005(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	struct FAttributeEffectData                   AttributeEffect;                                   // 0x0008(0x0048)(Edit, NoDestructor, NativeAccessSpecifierPublic)
	struct FGbxAttributeModifierHandle            AttributeModifier;                                 // 0x0050(0x0010)(Transient, NativeAccessSpecifierPublic)
};
static_assert(alignof(FWeaponChargeAttributeEffect) == 0x000008, "Wrong alignment on FWeaponChargeAttributeEffect");
static_assert(sizeof(FWeaponChargeAttributeEffect) == 0x000060, "Wrong size on FWeaponChargeAttributeEffect");
static_assert(offsetof(FWeaponChargeAttributeEffect, StatesBitmask) == 0x000000, "Member 'FWeaponChargeAttributeEffect::StatesBitmask' has a wrong offset!");
static_assert(offsetof(FWeaponChargeAttributeEffect, bApplyToInstigator) == 0x000004, "Member 'FWeaponChargeAttributeEffect::bApplyToInstigator' has a wrong offset!");
static_assert(offsetof(FWeaponChargeAttributeEffect, AttributeEffect) == 0x000008, "Member 'FWeaponChargeAttributeEffect::AttributeEffect' has a wrong offset!");
static_assert(offsetof(FWeaponChargeAttributeEffect, AttributeModifier) == 0x000050, "Member 'FWeaponChargeAttributeEffect::AttributeModifier' has a wrong offset!");

// ScriptStruct GbxWeapon.WeaponRegisterSkeletalControlData
// 0x0010 (0x0010 - 0x0000)
struct FWeaponRegisterSkeletalControlData final
{
public:
	EWeaponEffectType                             Type;                                              // 0x0000(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EWeaponAttachmentVisibilityType               Visibility;                                        // 0x0001(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         bPlayerOnly : 1;                                   // 0x0002(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (Edit, BlueprintVisible, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         Pad_3[0x5];                                        // 0x0003(0x0005)(Fixing Size After Last Property [ Dumper-7 ])
	class UWeaponSkeletalControlBase*             Control;                                           // 0x0008(0x0008)(Edit, BlueprintVisible, ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, PersistentInstance, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FWeaponRegisterSkeletalControlData) == 0x000008, "Wrong alignment on FWeaponRegisterSkeletalControlData");
static_assert(sizeof(FWeaponRegisterSkeletalControlData) == 0x000010, "Wrong size on FWeaponRegisterSkeletalControlData");
static_assert(offsetof(FWeaponRegisterSkeletalControlData, Type) == 0x000000, "Member 'FWeaponRegisterSkeletalControlData::Type' has a wrong offset!");
static_assert(offsetof(FWeaponRegisterSkeletalControlData, Visibility) == 0x000001, "Member 'FWeaponRegisterSkeletalControlData::Visibility' has a wrong offset!");
static_assert(offsetof(FWeaponRegisterSkeletalControlData, Control) == 0x000008, "Member 'FWeaponRegisterSkeletalControlData::Control' has a wrong offset!");

// ScriptStruct GbxWeapon.WeaponRegisterTrinketAttachmentData
// 0x0038 (0x0038 - 0x0000)
struct FWeaponRegisterTrinketAttachmentData final
{
public:
	class USkeletalMesh*                          SkeletalMesh;                                      // 0x0000(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TSubclassOf<class UAnimInstance>              AnimInstanceClass;                                 // 0x0008(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   AttachSocket;                                      // 0x0010(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                RelativeLocation;                                  // 0x0018(0x000C)(Edit, BlueprintVisible, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FRotator                               RelativeRotation;                                  // 0x0024(0x000C)(Edit, BlueprintVisible, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
	EWeaponAttachmentVisibilityType               Visibility;                                        // 0x0030(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_31[0x7];                                       // 0x0031(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FWeaponRegisterTrinketAttachmentData) == 0x000008, "Wrong alignment on FWeaponRegisterTrinketAttachmentData");
static_assert(sizeof(FWeaponRegisterTrinketAttachmentData) == 0x000038, "Wrong size on FWeaponRegisterTrinketAttachmentData");
static_assert(offsetof(FWeaponRegisterTrinketAttachmentData, SkeletalMesh) == 0x000000, "Member 'FWeaponRegisterTrinketAttachmentData::SkeletalMesh' has a wrong offset!");
static_assert(offsetof(FWeaponRegisterTrinketAttachmentData, AnimInstanceClass) == 0x000008, "Member 'FWeaponRegisterTrinketAttachmentData::AnimInstanceClass' has a wrong offset!");
static_assert(offsetof(FWeaponRegisterTrinketAttachmentData, AttachSocket) == 0x000010, "Member 'FWeaponRegisterTrinketAttachmentData::AttachSocket' has a wrong offset!");
static_assert(offsetof(FWeaponRegisterTrinketAttachmentData, RelativeLocation) == 0x000018, "Member 'FWeaponRegisterTrinketAttachmentData::RelativeLocation' has a wrong offset!");
static_assert(offsetof(FWeaponRegisterTrinketAttachmentData, RelativeRotation) == 0x000024, "Member 'FWeaponRegisterTrinketAttachmentData::RelativeRotation' has a wrong offset!");
static_assert(offsetof(FWeaponRegisterTrinketAttachmentData, Visibility) == 0x000030, "Member 'FWeaponRegisterTrinketAttachmentData::Visibility' has a wrong offset!");

// ScriptStruct GbxWeapon.WeaponRegisterMaterialEffectData
// 0x00A8 (0x00A8 - 0x0000)
struct FWeaponRegisterMaterialEffectData final
{
public:
	EWeaponEffectType                             Type;                                              // 0x0000(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1[0x7];                                        // 0x0001(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	class FName                                   MaterialParamName;                                 // 0x0008(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         ID;                                                // 0x0010(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EWeaponAttachmentVisibilityType               Visibility;                                        // 0x0014(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_15[0x3];                                       // 0x0015(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	int32                                         UseModeBitmask;                                    // 0x0018(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Slot;                                              // 0x001C(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EWeaponMaterialEffectBlendMode                BlendMode;                                         // 0x001D(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         bPlayOnlyOnActiveSlot : 1;                         // 0x001E(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (Edit, BlueprintVisible, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         bLoop : 1;                                         // 0x001E(0x0001)(BitIndex: 0x01, PropSize: 0x0001 (Edit, BlueprintVisible, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         bApplyAttribute : 1;                               // 0x001E(0x0001)(BitIndex: 0x02, PropSize: 0x0001 (Edit, BlueprintVisible, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         bScaleAttributeByValueOverTime : 1;                // 0x001E(0x0001)(BitIndex: 0x03, PropSize: 0x0001 (Edit, BlueprintVisible, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         bScaleAttributeByDeltaTime : 1;                    // 0x001E(0x0001)(BitIndex: 0x04, PropSize: 0x0001 (Edit, BlueprintVisible, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         Pad_1F[0x1];                                       // 0x001F(0x0001)(Fixing Size After Last Property [ Dumper-7 ])
	struct FAttributeInitializationData           AttributeValue;                                    // 0x0020(0x0038)(Edit, BlueprintVisible, NoDestructor, NativeAccessSpecifierPublic)
	class UCurveFloat*                            ValueOverTime;                                     // 0x0058(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         Impulse;                                           // 0x0060(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_64[0x4];                                       // 0x0064(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	struct FAttributeInitializationData           Duration;                                          // 0x0068(0x0038)(Edit, BlueprintVisible, NoDestructor, NativeAccessSpecifierPublic)
	float                                         DecayRate;                                         // 0x00A0(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         MaxValue;                                          // 0x00A4(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FWeaponRegisterMaterialEffectData) == 0x000008, "Wrong alignment on FWeaponRegisterMaterialEffectData");
static_assert(sizeof(FWeaponRegisterMaterialEffectData) == 0x0000A8, "Wrong size on FWeaponRegisterMaterialEffectData");
static_assert(offsetof(FWeaponRegisterMaterialEffectData, Type) == 0x000000, "Member 'FWeaponRegisterMaterialEffectData::Type' has a wrong offset!");
static_assert(offsetof(FWeaponRegisterMaterialEffectData, MaterialParamName) == 0x000008, "Member 'FWeaponRegisterMaterialEffectData::MaterialParamName' has a wrong offset!");
static_assert(offsetof(FWeaponRegisterMaterialEffectData, ID) == 0x000010, "Member 'FWeaponRegisterMaterialEffectData::ID' has a wrong offset!");
static_assert(offsetof(FWeaponRegisterMaterialEffectData, Visibility) == 0x000014, "Member 'FWeaponRegisterMaterialEffectData::Visibility' has a wrong offset!");
static_assert(offsetof(FWeaponRegisterMaterialEffectData, UseModeBitmask) == 0x000018, "Member 'FWeaponRegisterMaterialEffectData::UseModeBitmask' has a wrong offset!");
static_assert(offsetof(FWeaponRegisterMaterialEffectData, Slot) == 0x00001C, "Member 'FWeaponRegisterMaterialEffectData::Slot' has a wrong offset!");
static_assert(offsetof(FWeaponRegisterMaterialEffectData, BlendMode) == 0x00001D, "Member 'FWeaponRegisterMaterialEffectData::BlendMode' has a wrong offset!");
static_assert(offsetof(FWeaponRegisterMaterialEffectData, AttributeValue) == 0x000020, "Member 'FWeaponRegisterMaterialEffectData::AttributeValue' has a wrong offset!");
static_assert(offsetof(FWeaponRegisterMaterialEffectData, ValueOverTime) == 0x000058, "Member 'FWeaponRegisterMaterialEffectData::ValueOverTime' has a wrong offset!");
static_assert(offsetof(FWeaponRegisterMaterialEffectData, Impulse) == 0x000060, "Member 'FWeaponRegisterMaterialEffectData::Impulse' has a wrong offset!");
static_assert(offsetof(FWeaponRegisterMaterialEffectData, Duration) == 0x000068, "Member 'FWeaponRegisterMaterialEffectData::Duration' has a wrong offset!");
static_assert(offsetof(FWeaponRegisterMaterialEffectData, DecayRate) == 0x0000A0, "Member 'FWeaponRegisterMaterialEffectData::DecayRate' has a wrong offset!");
static_assert(offsetof(FWeaponRegisterMaterialEffectData, MaxValue) == 0x0000A4, "Member 'FWeaponRegisterMaterialEffectData::MaxValue' has a wrong offset!");

// ScriptStruct GbxWeapon.WeaponHeatEventNotify
// 0x0010 (0x0010 - 0x0000)
struct alignas(0x08) FWeaponHeatEventNotify final
{
public:
	float                                         Threshold;                                         // 0x0000(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EWeaponHeatComparisonOperatorType             Comparision;                                       // 0x0004(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_5[0x3];                                        // 0x0005(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	class FName                                   EventName;                                         // 0x0008(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FWeaponHeatEventNotify) == 0x000008, "Wrong alignment on FWeaponHeatEventNotify");
static_assert(sizeof(FWeaponHeatEventNotify) == 0x000010, "Wrong size on FWeaponHeatEventNotify");
static_assert(offsetof(FWeaponHeatEventNotify, Threshold) == 0x000000, "Member 'FWeaponHeatEventNotify::Threshold' has a wrong offset!");
static_assert(offsetof(FWeaponHeatEventNotify, Comparision) == 0x000004, "Member 'FWeaponHeatEventNotify::Comparision' has a wrong offset!");
static_assert(offsetof(FWeaponHeatEventNotify, EventName) == 0x000008, "Member 'FWeaponHeatEventNotify::EventName' has a wrong offset!");

// ScriptStruct GbxWeapon.LightBeamFlagName
// 0x0020 (0x0020 - 0x0000)
struct FLightBeamFlagName final
{
public:
	ELightBeamFlag                                Type;                                              // 0x0000(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1[0x7];                                        // 0x0001(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	class FName                                   Name;                                              // 0x0008(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FString                                 Tooltip;                                           // 0x0010(0x0010)(ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FLightBeamFlagName) == 0x000008, "Wrong alignment on FLightBeamFlagName");
static_assert(sizeof(FLightBeamFlagName) == 0x000020, "Wrong size on FLightBeamFlagName");
static_assert(offsetof(FLightBeamFlagName, Type) == 0x000000, "Member 'FLightBeamFlagName::Type' has a wrong offset!");
static_assert(offsetof(FLightBeamFlagName, Name) == 0x000008, "Member 'FLightBeamFlagName::Name' has a wrong offset!");
static_assert(offsetof(FLightBeamFlagName, Tooltip) == 0x000010, "Member 'FLightBeamFlagName::Tooltip' has a wrong offset!");

// ScriptStruct GbxWeapon.WeaponActionTypeName
// 0x0020 (0x0020 - 0x0000)
struct FWeaponActionTypeName final
{
public:
	EWeaponActionType                             Type;                                              // 0x0000(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1[0x7];                                        // 0x0001(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	class FName                                   Name;                                              // 0x0008(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FString                                 Tooltip;                                           // 0x0010(0x0010)(ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FWeaponActionTypeName) == 0x000008, "Wrong alignment on FWeaponActionTypeName");
static_assert(sizeof(FWeaponActionTypeName) == 0x000020, "Wrong size on FWeaponActionTypeName");
static_assert(offsetof(FWeaponActionTypeName, Type) == 0x000000, "Member 'FWeaponActionTypeName::Type' has a wrong offset!");
static_assert(offsetof(FWeaponActionTypeName, Name) == 0x000008, "Member 'FWeaponActionTypeName::Name' has a wrong offset!");
static_assert(offsetof(FWeaponActionTypeName, Tooltip) == 0x000010, "Member 'FWeaponActionTypeName::Tooltip' has a wrong offset!");

// ScriptStruct GbxWeapon.WeaponEffectTypeName
// 0x0020 (0x0020 - 0x0000)
struct FWeaponEffectTypeName final
{
public:
	EWeaponEffectType                             Type;                                              // 0x0000(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1[0x7];                                        // 0x0001(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	class FName                                   Name;                                              // 0x0008(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FString                                 Tooltip;                                           // 0x0010(0x0010)(ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FWeaponEffectTypeName) == 0x000008, "Wrong alignment on FWeaponEffectTypeName");
static_assert(sizeof(FWeaponEffectTypeName) == 0x000020, "Wrong size on FWeaponEffectTypeName");
static_assert(offsetof(FWeaponEffectTypeName, Type) == 0x000000, "Member 'FWeaponEffectTypeName::Type' has a wrong offset!");
static_assert(offsetof(FWeaponEffectTypeName, Name) == 0x000008, "Member 'FWeaponEffectTypeName::Name' has a wrong offset!");
static_assert(offsetof(FWeaponEffectTypeName, Tooltip) == 0x000010, "Member 'FWeaponEffectTypeName::Tooltip' has a wrong offset!");

// ScriptStruct GbxWeapon.WeaponTriggerFeedbackData
// 0x0008 (0x0008 - 0x0000)
struct FWeaponTriggerFeedbackData final
{
public:
	float                                         Position;                                          // 0x0000(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         Force;                                             // 0x0004(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FWeaponTriggerFeedbackData) == 0x000004, "Wrong alignment on FWeaponTriggerFeedbackData");
static_assert(sizeof(FWeaponTriggerFeedbackData) == 0x000008, "Wrong size on FWeaponTriggerFeedbackData");
static_assert(offsetof(FWeaponTriggerFeedbackData, Position) == 0x000000, "Member 'FWeaponTriggerFeedbackData::Position' has a wrong offset!");
static_assert(offsetof(FWeaponTriggerFeedbackData, Force) == 0x000004, "Member 'FWeaponTriggerFeedbackData::Force' has a wrong offset!");

// ScriptStruct GbxWeapon.WeaponVisibleAmmoEffectData
// 0x0040 (0x0040 - 0x0000)
struct FWeaponVisibleAmmoEffectData final
{
public:
	class UParticleSystem*                        Effect;                                            // 0x0000(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_8[0x8];                                        // 0x0008(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	struct FTransform                             RelativeTransform;                                 // 0x0010(0x0030)(Edit, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(FWeaponVisibleAmmoEffectData) == 0x000010, "Wrong alignment on FWeaponVisibleAmmoEffectData");
static_assert(sizeof(FWeaponVisibleAmmoEffectData) == 0x000040, "Wrong size on FWeaponVisibleAmmoEffectData");
static_assert(offsetof(FWeaponVisibleAmmoEffectData, Effect) == 0x000000, "Member 'FWeaponVisibleAmmoEffectData::Effect' has a wrong offset!");
static_assert(offsetof(FWeaponVisibleAmmoEffectData, RelativeTransform) == 0x000010, "Member 'FWeaponVisibleAmmoEffectData::RelativeTransform' has a wrong offset!");

}

