#pragma once

/*
* SDK generated by Dumper-7
*
* https://github.com/Encryqed/Dumper-7
*/

// Package: GbxNav

#include "Basic.hpp"

#include "GbxRuntime_structs.hpp"
#include "GbxRuntime_classes.hpp"
#include "NavigationSystem_structs.hpp"
#include "NavigationSystem_classes.hpp"
#include "Engine_classes.hpp"
#include "GbxNav_structs.hpp"
#include "CoreUObject_structs.hpp"
#include "CoreUObject_classes.hpp"
#include "GbxGameSystemCore_structs.hpp"
#include "GbxGameSystemCore_classes.hpp"
#include "AIModule_classes.hpp"


namespace SDK
{

// Class GbxNav.GbxNavAnimTable
// 0x0010 (0x0058 - 0x0048)
class UGbxNavAnimTable final : public UGbxAnimTable
{
public:
	EGbxNavAnimTableType                          Type;                                              // 0x0048(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_49[0x3];                                       // 0x0049(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         MinStopDistance;                                   // 0x004C(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	float                                         MaxInterpDistance;                                 // 0x0050(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	float                                         AutoFillAngle;                                     // 0x0054(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"GbxNavAnimTable">();
	}
	static class UGbxNavAnimTable* GetDefaultObj()
	{
		return GetDefaultObjImpl<UGbxNavAnimTable>();
	}
};
static_assert(alignof(UGbxNavAnimTable) == 0x000008, "Wrong alignment on UGbxNavAnimTable");
static_assert(sizeof(UGbxNavAnimTable) == 0x000058, "Wrong size on UGbxNavAnimTable");
static_assert(offsetof(UGbxNavAnimTable, Type) == 0x000048, "Member 'UGbxNavAnimTable::Type' has a wrong offset!");
static_assert(offsetof(UGbxNavAnimTable, MinStopDistance) == 0x00004C, "Member 'UGbxNavAnimTable::MinStopDistance' has a wrong offset!");
static_assert(offsetof(UGbxNavAnimTable, MaxInterpDistance) == 0x000050, "Member 'UGbxNavAnimTable::MaxInterpDistance' has a wrong offset!");
static_assert(offsetof(UGbxNavAnimTable, AutoFillAngle) == 0x000054, "Member 'UGbxNavAnimTable::AutoFillAngle' has a wrong offset!");

// Class GbxNav.HavokPathFollowingComponent
// 0x0000 (0x0350 - 0x0350)
class UHavokPathFollowingComponent : public UPathFollowingComponent
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"HavokPathFollowingComponent">();
	}
	static class UHavokPathFollowingComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UHavokPathFollowingComponent>();
	}
};
static_assert(alignof(UHavokPathFollowingComponent) == 0x000008, "Wrong alignment on UHavokPathFollowingComponent");
static_assert(sizeof(UHavokPathFollowingComponent) == 0x000350, "Wrong size on UHavokPathFollowingComponent");

// Class GbxNav.GbxNavSystem
// 0x0010 (0x0438 - 0x0428)
class UGbxNavSystem : public UNavigationSystemV1
{
public:
	uint8                                         Pad_428[0x8];                                      // 0x0428(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	class AGbxNavWorld*                           GbxNavWorld;                                       // 0x0430(0x0008)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"GbxNavSystem">();
	}
	static class UGbxNavSystem* GetDefaultObj()
	{
		return GetDefaultObjImpl<UGbxNavSystem>();
	}
};
static_assert(alignof(UGbxNavSystem) == 0x000008, "Wrong alignment on UGbxNavSystem");
static_assert(sizeof(UGbxNavSystem) == 0x000438, "Wrong size on UGbxNavSystem");
static_assert(offsetof(UGbxNavSystem, GbxNavWorld) == 0x000430, "Member 'UGbxNavSystem::GbxNavWorld' has a wrong offset!");

// Class GbxNav.GbxAnimStateManager_NavIdleTurn
// 0x0000 (0x0040 - 0x0040)
class UGbxAnimStateManager_NavIdleTurn : public UGbxAnimStateManager_RootMotion
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"GbxAnimStateManager_NavIdleTurn">();
	}
	static class UGbxAnimStateManager_NavIdleTurn* GetDefaultObj()
	{
		return GetDefaultObjImpl<UGbxAnimStateManager_NavIdleTurn>();
	}
};
static_assert(alignof(UGbxAnimStateManager_NavIdleTurn) == 0x000008, "Wrong alignment on UGbxAnimStateManager_NavIdleTurn");
static_assert(sizeof(UGbxAnimStateManager_NavIdleTurn) == 0x000040, "Wrong size on UGbxAnimStateManager_NavIdleTurn");

// Class GbxNav.GbxAnimStateManager_NavTable
// 0x0000 (0x0040 - 0x0040)
class UGbxAnimStateManager_NavTable final : public UGbxAnimStateManager_NavIdleTurn
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"GbxAnimStateManager_NavTable">();
	}
	static class UGbxAnimStateManager_NavTable* GetDefaultObj()
	{
		return GetDefaultObjImpl<UGbxAnimStateManager_NavTable>();
	}
};
static_assert(alignof(UGbxAnimStateManager_NavTable) == 0x000008, "Wrong alignment on UGbxAnimStateManager_NavTable");
static_assert(sizeof(UGbxAnimStateManager_NavTable) == 0x000040, "Wrong size on UGbxAnimStateManager_NavTable");

// Class GbxNav.GbxNavComponent
// 0x0978 (0x0AF0 - 0x0178)
class UGbxNavComponent : public UNavComponent
{
public:
	uint8                                         Pad_178[0x3B0];                                    // 0x0178(0x03B0)(Fixing Size After Last Property [ Dumper-7 ])
	struct FGbxNavForwardState                    ForwardState;                                      // 0x0528(0x0128)(Edit, NoDestructor, ContainsInstancedReference, NativeAccessSpecifierPrivate)
	struct FGbxNavStuckState                      StuckState;                                        // 0x0650(0x0068)(Edit, NoDestructor, ContainsInstancedReference, NativeAccessSpecifierPrivate)
	class AGbxNavWorld*                           GbxNavWorld;                                       // 0x06B8(0x0008)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UHavokMovementData*                     OverrideMovementData;                              // 0x06C0(0x0008)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UHavokPathFindingData*                  OverridePathFindingData;                           // 0x06C8(0x0008)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UCapsuleComponent*                      MyCapsule;                                         // 0x06D0(0x0008)(ExportObject, ZeroConstructor, Transient, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class AAIController*                          MyAIController;                                    // 0x06D8(0x0008)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UGbxNavCharacterMovementComponent*      MyMovement;                                        // 0x06E0(0x0008)(ExportObject, ZeroConstructor, Transient, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	struct FGbxNavAgent                           Agent;                                             // 0x06E8(0x00A8)(Transient, NoDestructor, NativeAccessSpecifierPrivate)
	struct FGbxUserEdgeState                      UserEdgeState;                                     // 0x0790(0x01A0)(Transient, ContainsInstancedReference, NativeAccessSpecifierPrivate)
	struct FGbxNavCorrecter                       NavCorrecter;                                      // 0x0930(0x00B8)(Transient, ContainsInstancedReference, NativeAccessSpecifierPrivate)
	struct FGbxReachabilityState                  Reachability;                                      // 0x09E8(0x0090)(Transient, ContainsInstancedReference, NativeAccessSpecifierPrivate)
	struct FGbxNavMovementOptions                 MovementOptions;                                   // 0x0A78(0x0038)(Transient, NoDestructor, NativeAccessSpecifierPrivate)
	struct FGbxNavAvoidanceOptions                AvoidanceOptions;                                  // 0x0AB0(0x003C)(Transient, NoDestructor, NativeAccessSpecifierPrivate)
	uint8                                         Pad_AEC[0x4];                                      // 0x0AEC(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void ResetPathFindingData();
	void SetPathFindingData(class UHavokPathFindingData* NewPathFindingData);
	void TryMoving(float FDuration);

	class UHavokPathFindingData* GetPathFindingData() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"GbxNavComponent">();
	}
	static class UGbxNavComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UGbxNavComponent>();
	}
};
static_assert(alignof(UGbxNavComponent) == 0x000008, "Wrong alignment on UGbxNavComponent");
static_assert(sizeof(UGbxNavComponent) == 0x000AF0, "Wrong size on UGbxNavComponent");
static_assert(offsetof(UGbxNavComponent, ForwardState) == 0x000528, "Member 'UGbxNavComponent::ForwardState' has a wrong offset!");
static_assert(offsetof(UGbxNavComponent, StuckState) == 0x000650, "Member 'UGbxNavComponent::StuckState' has a wrong offset!");
static_assert(offsetof(UGbxNavComponent, GbxNavWorld) == 0x0006B8, "Member 'UGbxNavComponent::GbxNavWorld' has a wrong offset!");
static_assert(offsetof(UGbxNavComponent, OverrideMovementData) == 0x0006C0, "Member 'UGbxNavComponent::OverrideMovementData' has a wrong offset!");
static_assert(offsetof(UGbxNavComponent, OverridePathFindingData) == 0x0006C8, "Member 'UGbxNavComponent::OverridePathFindingData' has a wrong offset!");
static_assert(offsetof(UGbxNavComponent, MyCapsule) == 0x0006D0, "Member 'UGbxNavComponent::MyCapsule' has a wrong offset!");
static_assert(offsetof(UGbxNavComponent, MyAIController) == 0x0006D8, "Member 'UGbxNavComponent::MyAIController' has a wrong offset!");
static_assert(offsetof(UGbxNavComponent, MyMovement) == 0x0006E0, "Member 'UGbxNavComponent::MyMovement' has a wrong offset!");
static_assert(offsetof(UGbxNavComponent, Agent) == 0x0006E8, "Member 'UGbxNavComponent::Agent' has a wrong offset!");
static_assert(offsetof(UGbxNavComponent, UserEdgeState) == 0x000790, "Member 'UGbxNavComponent::UserEdgeState' has a wrong offset!");
static_assert(offsetof(UGbxNavComponent, NavCorrecter) == 0x000930, "Member 'UGbxNavComponent::NavCorrecter' has a wrong offset!");
static_assert(offsetof(UGbxNavComponent, Reachability) == 0x0009E8, "Member 'UGbxNavComponent::Reachability' has a wrong offset!");
static_assert(offsetof(UGbxNavComponent, MovementOptions) == 0x000A78, "Member 'UGbxNavComponent::MovementOptions' has a wrong offset!");
static_assert(offsetof(UGbxNavComponent, AvoidanceOptions) == 0x000AB0, "Member 'UGbxNavComponent::AvoidanceOptions' has a wrong offset!");

// Class GbxNav.GbxNavSection
// 0x0008 (0x04A0 - 0x0498)
class AGbxNavSection : public ANavMeshBoundsVolume
{
public:
	class UGbxNavSectionComponent*                SectionComponent;                                  // 0x0498(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"GbxNavSection">();
	}
	static class AGbxNavSection* GetDefaultObj()
	{
		return GetDefaultObjImpl<AGbxNavSection>();
	}
};
static_assert(alignof(AGbxNavSection) == 0x000008, "Wrong alignment on AGbxNavSection");
static_assert(sizeof(AGbxNavSection) == 0x0004A0, "Wrong size on AGbxNavSection");
static_assert(offsetof(AGbxNavSection, SectionComponent) == 0x000498, "Member 'AGbxNavSection::SectionComponent' has a wrong offset!");

// Class GbxNav.GbxNavCharacterMovementComponent
// 0x0210 (0x2890 - 0x2680)
#pragma pack(push, 0x1)
class alignas(0x10) UGbxNavCharacterMovementComponent : public UGbxCharacterMovementComponent
{
public:
	uint8                                         Pad_2680[0x90];                                    // 0x2680(0x0090)(Fixing Size After Last Property [ Dumper-7 ])
	struct FGbxNavMovementOptions                 NavMovementOptions;                                // 0x2710(0x0038)(Edit, NoDestructor, NativeAccessSpecifierPrivate)
	float                                         NavClientPopDistance;                              // 0x2748(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	struct FGbxNavAvoidanceOptions                NavAvoidanceOptions;                               // 0x274C(0x003C)(Edit, NoDestructor, NativeAccessSpecifierPrivate)
	struct FGbxNavSlowdownData                    NavSlowdownOptions;                                // 0x2788(0x0014)(Edit, NoDestructor, NativeAccessSpecifierPrivate)
	bool                                          bOverrideSlowdownNearGoal;                         // 0x279C(0x0001)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_279D[0x3];                                     // 0x279D(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	struct FStanceFloatValue                      SlowdownSpeedOverride;                             // 0x27A0(0x0008)(Transient, NoDestructor, NativeAccessSpecifierPrivate)
	class AGbxNavWorld*                           GbxNavWorld;                                       // 0x27A8(0x0008)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UGbxNavComponent*                       GbxNavComponent;                                   // 0x27B0(0x0008)(ExportObject, ZeroConstructor, Transient, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	struct FGbxNavAgent                           Agent;                                             // 0x27B8(0x00A8)(Transient, NoDestructor, NativeAccessSpecifierPrivate)
	struct FGbxNavPathingData                     PathingData;                                       // 0x2860(0x0010)(Net, Transient, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UGbxNavMeshLayer*                       ForcedNavMeshLayer;                                // 0x2870(0x0008)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_2878[0x4];                                     // 0x2878(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	bool                                          bOverrideMaxAcceleration;                          // 0x287C(0x0001)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_287D[0x3];                                     // 0x287D(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         StanceMaxAcceleration;                             // 0x2880(0x0004)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_2884[0x4];                                     // 0x2884(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"GbxNavCharacterMovementComponent">();
	}
	static class UGbxNavCharacterMovementComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UGbxNavCharacterMovementComponent>();
	}
};
#pragma pack(pop)
static_assert(alignof(UGbxNavCharacterMovementComponent) == 0x000010, "Wrong alignment on UGbxNavCharacterMovementComponent");
static_assert(sizeof(UGbxNavCharacterMovementComponent) == 0x002890, "Wrong size on UGbxNavCharacterMovementComponent");
static_assert(offsetof(UGbxNavCharacterMovementComponent, NavMovementOptions) == 0x002710, "Member 'UGbxNavCharacterMovementComponent::NavMovementOptions' has a wrong offset!");
static_assert(offsetof(UGbxNavCharacterMovementComponent, NavClientPopDistance) == 0x002748, "Member 'UGbxNavCharacterMovementComponent::NavClientPopDistance' has a wrong offset!");
static_assert(offsetof(UGbxNavCharacterMovementComponent, NavAvoidanceOptions) == 0x00274C, "Member 'UGbxNavCharacterMovementComponent::NavAvoidanceOptions' has a wrong offset!");
static_assert(offsetof(UGbxNavCharacterMovementComponent, NavSlowdownOptions) == 0x002788, "Member 'UGbxNavCharacterMovementComponent::NavSlowdownOptions' has a wrong offset!");
static_assert(offsetof(UGbxNavCharacterMovementComponent, bOverrideSlowdownNearGoal) == 0x00279C, "Member 'UGbxNavCharacterMovementComponent::bOverrideSlowdownNearGoal' has a wrong offset!");
static_assert(offsetof(UGbxNavCharacterMovementComponent, SlowdownSpeedOverride) == 0x0027A0, "Member 'UGbxNavCharacterMovementComponent::SlowdownSpeedOverride' has a wrong offset!");
static_assert(offsetof(UGbxNavCharacterMovementComponent, GbxNavWorld) == 0x0027A8, "Member 'UGbxNavCharacterMovementComponent::GbxNavWorld' has a wrong offset!");
static_assert(offsetof(UGbxNavCharacterMovementComponent, GbxNavComponent) == 0x0027B0, "Member 'UGbxNavCharacterMovementComponent::GbxNavComponent' has a wrong offset!");
static_assert(offsetof(UGbxNavCharacterMovementComponent, Agent) == 0x0027B8, "Member 'UGbxNavCharacterMovementComponent::Agent' has a wrong offset!");
static_assert(offsetof(UGbxNavCharacterMovementComponent, PathingData) == 0x002860, "Member 'UGbxNavCharacterMovementComponent::PathingData' has a wrong offset!");
static_assert(offsetof(UGbxNavCharacterMovementComponent, ForcedNavMeshLayer) == 0x002870, "Member 'UGbxNavCharacterMovementComponent::ForcedNavMeshLayer' has a wrong offset!");
static_assert(offsetof(UGbxNavCharacterMovementComponent, bOverrideMaxAcceleration) == 0x00287C, "Member 'UGbxNavCharacterMovementComponent::bOverrideMaxAcceleration' has a wrong offset!");
static_assert(offsetof(UGbxNavCharacterMovementComponent, StanceMaxAcceleration) == 0x002880, "Member 'UGbxNavCharacterMovementComponent::StanceMaxAcceleration' has a wrong offset!");

// Class GbxNav.GbxNavWorld
// 0x0568 (0x0B80 - 0x0618)
class AGbxNavWorld : public ANavigationData
{
public:
	uint8                                         Pad_618[0x48];                                     // 0x0618(0x0048)(Fixing Size After Last Property [ Dumper-7 ])
	struct FGbxUserEdgeManager                    UserEdgeManager;                                   // 0x0660(0x0060)(ContainsInstancedReference, NativeAccessSpecifierPrivate)
	struct FGbxPainterManager                     PainterManager;                                    // 0x06C0(0x0020)(ContainsInstancedReference, NativeAccessSpecifierPrivate)
	struct FGbxNavStreamingData                   FlyStreamingData;                                  // 0x06E0(0x0020)(NativeAccessSpecifierPrivate)
	struct FGbxNavStreamingData                   MeshStreamingData;                                 // 0x0700(0x0020)(NativeAccessSpecifierPrivate)
	struct FGbxNavLayerState                      MeshLayers;                                        // 0x0720(0x0018)(NativeAccessSpecifierPrivate)
	struct FGbxNavLayerState                      FlyLayers;                                         // 0x0738(0x0018)(NativeAccessSpecifierPrivate)
	class UGbxNavComponent*                       ReachabilityBuilding;                              // 0x0750(0x0008)(ExportObject, ZeroConstructor, Transient, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	TArray<class UGbxNavComponent*>               ReachabilityQueue;                                 // 0x0758(0x0010)(ExportObject, ZeroConstructor, Transient, ContainsInstancedReference, NativeAccessSpecifierPrivate)
	TArray<class UGbxNavComponent*>               NavComps;                                          // 0x0768(0x0010)(ExportObject, ZeroConstructor, Transient, ContainsInstancedReference, NativeAccessSpecifierPrivate)
	struct FGbxReachabilityTracker                ReachabilityTracker;                               // 0x0778(0x00D0)(Transient, ContainsInstancedReference, NativeAccessSpecifierPrivate)
	int32                                         MaxClearanceFillsPerStep;                          // 0x0848(0x0004)(ZeroConstructor, Config, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	int32                                         MaxClearanceChecksPerStep;                         // 0x084C(0x0004)(ZeroConstructor, Config, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	bool                                          bAsyncProcessingEnabled;                           // 0x0850(0x0001)(ZeroConstructor, Config, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	bool                                          bAsyncAgentUpdatesEnabled;                         // 0x0851(0x0001)(ZeroConstructor, Config, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_852[0x6];                                      // 0x0852(0x0006)(Fixing Size After Last Property [ Dumper-7 ])
	struct FSoftObjectPath                        DefaultMeshLayer;                                  // 0x0858(0x0018)(Config, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	struct FSoftObjectPath                        DefaultFlyLayer;                                   // 0x0870(0x0018)(Config, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	struct FSoftObjectPath                        DefaultNavArea;                                    // 0x0888(0x0018)(Config, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	struct FSoftObjectPath                        NullNavArea;                                       // 0x08A0(0x0018)(Config, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	TArray<struct FSoftObjectPath>                AllNavAreas;                                       // 0x08B8(0x0010)(ZeroConstructor, Config, NativeAccessSpecifierPrivate)
	TArray<class UGbxNavArea*>                    LoadedAllNavAreas;                                 // 0x08C8(0x0010)(ZeroConstructor, Transient, NativeAccessSpecifierPrivate)
	TArray<class UGbxNavSectionComponent*>        SectionsWithDirtyTransforms;                       // 0x08D8(0x0010)(ExportObject, ZeroConstructor, Transient, ContainsInstancedReference, NativeAccessSpecifierPrivate)
	uint8                                         Pad_8E8[0x268];                                    // 0x08E8(0x0268)(Fixing Size After Last Property [ Dumper-7 ])
	class UHavokNavMeshGenerationSettings*        MeshGenSettings;                                   // 0x0B50(0x0008)(Edit, ExportObject, ZeroConstructor, EditConst, InstancedReference, IsPlainOldData, NoDestructor, PersistentInstance, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UHavokNavVolumeGenerationSettings*      VolumeGenSettings;                                 // 0x0B58(0x0008)(Edit, ExportObject, ZeroConstructor, EditConst, InstancedReference, IsPlainOldData, NoDestructor, PersistentInstance, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_B60[0x20];                                     // 0x0B60(0x0020)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"GbxNavWorld">();
	}
	static class AGbxNavWorld* GetDefaultObj()
	{
		return GetDefaultObjImpl<AGbxNavWorld>();
	}
};
static_assert(alignof(AGbxNavWorld) == 0x000008, "Wrong alignment on AGbxNavWorld");
static_assert(sizeof(AGbxNavWorld) == 0x000B80, "Wrong size on AGbxNavWorld");
static_assert(offsetof(AGbxNavWorld, UserEdgeManager) == 0x000660, "Member 'AGbxNavWorld::UserEdgeManager' has a wrong offset!");
static_assert(offsetof(AGbxNavWorld, PainterManager) == 0x0006C0, "Member 'AGbxNavWorld::PainterManager' has a wrong offset!");
static_assert(offsetof(AGbxNavWorld, FlyStreamingData) == 0x0006E0, "Member 'AGbxNavWorld::FlyStreamingData' has a wrong offset!");
static_assert(offsetof(AGbxNavWorld, MeshStreamingData) == 0x000700, "Member 'AGbxNavWorld::MeshStreamingData' has a wrong offset!");
static_assert(offsetof(AGbxNavWorld, MeshLayers) == 0x000720, "Member 'AGbxNavWorld::MeshLayers' has a wrong offset!");
static_assert(offsetof(AGbxNavWorld, FlyLayers) == 0x000738, "Member 'AGbxNavWorld::FlyLayers' has a wrong offset!");
static_assert(offsetof(AGbxNavWorld, ReachabilityBuilding) == 0x000750, "Member 'AGbxNavWorld::ReachabilityBuilding' has a wrong offset!");
static_assert(offsetof(AGbxNavWorld, ReachabilityQueue) == 0x000758, "Member 'AGbxNavWorld::ReachabilityQueue' has a wrong offset!");
static_assert(offsetof(AGbxNavWorld, NavComps) == 0x000768, "Member 'AGbxNavWorld::NavComps' has a wrong offset!");
static_assert(offsetof(AGbxNavWorld, ReachabilityTracker) == 0x000778, "Member 'AGbxNavWorld::ReachabilityTracker' has a wrong offset!");
static_assert(offsetof(AGbxNavWorld, MaxClearanceFillsPerStep) == 0x000848, "Member 'AGbxNavWorld::MaxClearanceFillsPerStep' has a wrong offset!");
static_assert(offsetof(AGbxNavWorld, MaxClearanceChecksPerStep) == 0x00084C, "Member 'AGbxNavWorld::MaxClearanceChecksPerStep' has a wrong offset!");
static_assert(offsetof(AGbxNavWorld, bAsyncProcessingEnabled) == 0x000850, "Member 'AGbxNavWorld::bAsyncProcessingEnabled' has a wrong offset!");
static_assert(offsetof(AGbxNavWorld, bAsyncAgentUpdatesEnabled) == 0x000851, "Member 'AGbxNavWorld::bAsyncAgentUpdatesEnabled' has a wrong offset!");
static_assert(offsetof(AGbxNavWorld, DefaultMeshLayer) == 0x000858, "Member 'AGbxNavWorld::DefaultMeshLayer' has a wrong offset!");
static_assert(offsetof(AGbxNavWorld, DefaultFlyLayer) == 0x000870, "Member 'AGbxNavWorld::DefaultFlyLayer' has a wrong offset!");
static_assert(offsetof(AGbxNavWorld, DefaultNavArea) == 0x000888, "Member 'AGbxNavWorld::DefaultNavArea' has a wrong offset!");
static_assert(offsetof(AGbxNavWorld, NullNavArea) == 0x0008A0, "Member 'AGbxNavWorld::NullNavArea' has a wrong offset!");
static_assert(offsetof(AGbxNavWorld, AllNavAreas) == 0x0008B8, "Member 'AGbxNavWorld::AllNavAreas' has a wrong offset!");
static_assert(offsetof(AGbxNavWorld, LoadedAllNavAreas) == 0x0008C8, "Member 'AGbxNavWorld::LoadedAllNavAreas' has a wrong offset!");
static_assert(offsetof(AGbxNavWorld, SectionsWithDirtyTransforms) == 0x0008D8, "Member 'AGbxNavWorld::SectionsWithDirtyTransforms' has a wrong offset!");
static_assert(offsetof(AGbxNavWorld, MeshGenSettings) == 0x000B50, "Member 'AGbxNavWorld::MeshGenSettings' has a wrong offset!");
static_assert(offsetof(AGbxNavWorld, VolumeGenSettings) == 0x000B58, "Member 'AGbxNavWorld::VolumeGenSettings' has a wrong offset!");

// Class GbxNav.AIVehicleFlightComponent
// 0x0090 (0x02C0 - 0x0230)
class UAIVehicleFlightComponent final : public UFloatingPawnMovement
{
public:
	uint8                                         Pad_230[0x10];                                     // 0x0230(0x0010)(Fixing Size After Last Property [ Dumper-7 ])
	struct FRotator                               RotationRate;                                      // 0x0240(0x000C)(Edit, IsPlainOldData, NoDestructor, NativeAccessSpecifierPrivate)
	uint8                                         Pad_24C[0x4];                                      // 0x024C(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class UGbxNavComponent*                       GbxNavComponent;                                   // 0x0250(0x0008)(ExportObject, ZeroConstructor, Transient, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_258[0xC];                                      // 0x0258(0x000C)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         VelocityScaleDuringDescent;                        // 0x0264(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	float                                         RotationScaleDuringDescent;                        // 0x0268(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	float                                         LateralDistanceToStartDescent;                     // 0x026C(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	float                                         VelocityScaleDuringAscent;                         // 0x0270(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	float                                         RotationScaleDuringAscent;                         // 0x0274(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	float                                         MaxPitchInDegrees;                                 // 0x0278(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	float                                         MaxRollInDegrees;                                  // 0x027C(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	struct FFlightState                           FlightState;                                       // 0x0280(0x0028)(Net, RepNotify, NoDestructor, NativeAccessSpecifierPrivate)
	uint8                                         Pad_2A8[0x18];                                     // 0x02A8(0x0018)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void OnRep_FlightState();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"AIVehicleFlightComponent">();
	}
	static class UAIVehicleFlightComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UAIVehicleFlightComponent>();
	}
};
static_assert(alignof(UAIVehicleFlightComponent) == 0x000008, "Wrong alignment on UAIVehicleFlightComponent");
static_assert(sizeof(UAIVehicleFlightComponent) == 0x0002C0, "Wrong size on UAIVehicleFlightComponent");
static_assert(offsetof(UAIVehicleFlightComponent, RotationRate) == 0x000240, "Member 'UAIVehicleFlightComponent::RotationRate' has a wrong offset!");
static_assert(offsetof(UAIVehicleFlightComponent, GbxNavComponent) == 0x000250, "Member 'UAIVehicleFlightComponent::GbxNavComponent' has a wrong offset!");
static_assert(offsetof(UAIVehicleFlightComponent, VelocityScaleDuringDescent) == 0x000264, "Member 'UAIVehicleFlightComponent::VelocityScaleDuringDescent' has a wrong offset!");
static_assert(offsetof(UAIVehicleFlightComponent, RotationScaleDuringDescent) == 0x000268, "Member 'UAIVehicleFlightComponent::RotationScaleDuringDescent' has a wrong offset!");
static_assert(offsetof(UAIVehicleFlightComponent, LateralDistanceToStartDescent) == 0x00026C, "Member 'UAIVehicleFlightComponent::LateralDistanceToStartDescent' has a wrong offset!");
static_assert(offsetof(UAIVehicleFlightComponent, VelocityScaleDuringAscent) == 0x000270, "Member 'UAIVehicleFlightComponent::VelocityScaleDuringAscent' has a wrong offset!");
static_assert(offsetof(UAIVehicleFlightComponent, RotationScaleDuringAscent) == 0x000274, "Member 'UAIVehicleFlightComponent::RotationScaleDuringAscent' has a wrong offset!");
static_assert(offsetof(UAIVehicleFlightComponent, MaxPitchInDegrees) == 0x000278, "Member 'UAIVehicleFlightComponent::MaxPitchInDegrees' has a wrong offset!");
static_assert(offsetof(UAIVehicleFlightComponent, MaxRollInDegrees) == 0x00027C, "Member 'UAIVehicleFlightComponent::MaxRollInDegrees' has a wrong offset!");
static_assert(offsetof(UAIVehicleFlightComponent, FlightState) == 0x000280, "Member 'UAIVehicleFlightComponent::FlightState' has a wrong offset!");

// Class GbxNav.GbxAnimStateManager_AINav
// 0x0058 (0x0090 - 0x0038)
class UGbxAnimStateManager_AINav final : public UGbxAnimStateManager
{
public:
	ENavAnimState                                 Type;                                              // 0x0038(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_39[0x7];                                       // 0x0039(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	class UGbxNavAnimTable*                       AnimTable;                                         // 0x0040(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	struct FAnimActionDef                         BlendSpaceRef;                                     // 0x0048(0x0018)(Edit, NoDestructor, Protected, NativeAccessSpecifierProtected)
	class UGbxCharacterAnimInstance*              GbxCharAnimInstance;                               // 0x0060(0x0008)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UGbxCharacterMovementComponent*         GbxCharMoveComponent;                              // 0x0068(0x0008)(ExportObject, ZeroConstructor, Transient, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UBlendSpaceBase*                        ResolvedBlendSpace;                                // 0x0070(0x0008)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         ResolvedBlendSpaceYawMin;                          // 0x0078(0x0004)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         ResolvedBlendSpaceYawMax;                          // 0x007C(0x0004)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UBlendSpaceBase*                        BlendSpace;                                        // 0x0080(0x0008)(ZeroConstructor, Deprecated, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_88[0x8];                                       // 0x0088(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void Owner_PostBeginPlay();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"GbxAnimStateManager_AINav">();
	}
	static class UGbxAnimStateManager_AINav* GetDefaultObj()
	{
		return GetDefaultObjImpl<UGbxAnimStateManager_AINav>();
	}
};
static_assert(alignof(UGbxAnimStateManager_AINav) == 0x000008, "Wrong alignment on UGbxAnimStateManager_AINav");
static_assert(sizeof(UGbxAnimStateManager_AINav) == 0x000090, "Wrong size on UGbxAnimStateManager_AINav");
static_assert(offsetof(UGbxAnimStateManager_AINav, Type) == 0x000038, "Member 'UGbxAnimStateManager_AINav::Type' has a wrong offset!");
static_assert(offsetof(UGbxAnimStateManager_AINav, AnimTable) == 0x000040, "Member 'UGbxAnimStateManager_AINav::AnimTable' has a wrong offset!");
static_assert(offsetof(UGbxAnimStateManager_AINav, BlendSpaceRef) == 0x000048, "Member 'UGbxAnimStateManager_AINav::BlendSpaceRef' has a wrong offset!");
static_assert(offsetof(UGbxAnimStateManager_AINav, GbxCharAnimInstance) == 0x000060, "Member 'UGbxAnimStateManager_AINav::GbxCharAnimInstance' has a wrong offset!");
static_assert(offsetof(UGbxAnimStateManager_AINav, GbxCharMoveComponent) == 0x000068, "Member 'UGbxAnimStateManager_AINav::GbxCharMoveComponent' has a wrong offset!");
static_assert(offsetof(UGbxAnimStateManager_AINav, ResolvedBlendSpace) == 0x000070, "Member 'UGbxAnimStateManager_AINav::ResolvedBlendSpace' has a wrong offset!");
static_assert(offsetof(UGbxAnimStateManager_AINav, ResolvedBlendSpaceYawMin) == 0x000078, "Member 'UGbxAnimStateManager_AINav::ResolvedBlendSpaceYawMin' has a wrong offset!");
static_assert(offsetof(UGbxAnimStateManager_AINav, ResolvedBlendSpaceYawMax) == 0x00007C, "Member 'UGbxAnimStateManager_AINav::ResolvedBlendSpaceYawMax' has a wrong offset!");
static_assert(offsetof(UGbxAnimStateManager_AINav, BlendSpace) == 0x000080, "Member 'UGbxAnimStateManager_AINav::BlendSpace' has a wrong offset!");

// Class GbxNav.GbxAnimStateManager_NavIdle
// 0x0000 (0x0038 - 0x0038)
class UGbxAnimStateManager_NavIdle final : public UGbxAnimStateManager
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"GbxAnimStateManager_NavIdle">();
	}
	static class UGbxAnimStateManager_NavIdle* GetDefaultObj()
	{
		return GetDefaultObjImpl<UGbxAnimStateManager_NavIdle>();
	}
};
static_assert(alignof(UGbxAnimStateManager_NavIdle) == 0x000008, "Wrong alignment on UGbxAnimStateManager_NavIdle");
static_assert(sizeof(UGbxAnimStateManager_NavIdle) == 0x000038, "Wrong size on UGbxAnimStateManager_NavIdle");

// Class GbxNav.GbxNavIdleTurnTable
// 0x0000 (0x0048 - 0x0048)
class UGbxNavIdleTurnTable final : public UGbxAnimTable
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"GbxNavIdleTurnTable">();
	}
	static class UGbxNavIdleTurnTable* GetDefaultObj()
	{
		return GetDefaultObjImpl<UGbxNavIdleTurnTable>();
	}
};
static_assert(alignof(UGbxNavIdleTurnTable) == 0x000008, "Wrong alignment on UGbxNavIdleTurnTable");
static_assert(sizeof(UGbxNavIdleTurnTable) == 0x000048, "Wrong size on UGbxNavIdleTurnTable");

// Class GbxNav.GbxAnimStateManager_NavHop
// 0x0000 (0x0040 - 0x0040)
class UGbxAnimStateManager_NavHop final : public UGbxAnimStateManager_RootMotion
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"GbxAnimStateManager_NavHop">();
	}
	static class UGbxAnimStateManager_NavHop* GetDefaultObj()
	{
		return GetDefaultObjImpl<UGbxAnimStateManager_NavHop>();
	}
};
static_assert(alignof(UGbxAnimStateManager_NavHop) == 0x000008, "Wrong alignment on UGbxAnimStateManager_NavHop");
static_assert(sizeof(UGbxAnimStateManager_NavHop) == 0x000040, "Wrong size on UGbxAnimStateManager_NavHop");

// Class GbxNav.GbxNavArea
// 0x0028 (0x0058 - 0x0030)
class UGbxNavArea final : public UGbxNavAreaBase
{
public:
	struct FColor                                 DrawColor;                                         // 0x0030(0x0004)(Edit, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_34[0x4];                                       // 0x0034(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<class UGbxNavMeshLayer*>               IgnoreLayers;                                      // 0x0038(0x0010)(Edit, ZeroConstructor, NativeAccessSpecifierPrivate)
	class UGbxNavArea*                            EffectiveArea;                                     // 0x0048(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	EHavokNavMaterial                             HavokNavMaterial;                                  // 0x0050(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_51[0x7];                                       // 0x0051(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"GbxNavArea">();
	}
	static class UGbxNavArea* GetDefaultObj()
	{
		return GetDefaultObjImpl<UGbxNavArea>();
	}
};
static_assert(alignof(UGbxNavArea) == 0x000008, "Wrong alignment on UGbxNavArea");
static_assert(sizeof(UGbxNavArea) == 0x000058, "Wrong size on UGbxNavArea");
static_assert(offsetof(UGbxNavArea, DrawColor) == 0x000030, "Member 'UGbxNavArea::DrawColor' has a wrong offset!");
static_assert(offsetof(UGbxNavArea, IgnoreLayers) == 0x000038, "Member 'UGbxNavArea::IgnoreLayers' has a wrong offset!");
static_assert(offsetof(UGbxNavArea, EffectiveArea) == 0x000048, "Member 'UGbxNavArea::EffectiveArea' has a wrong offset!");
static_assert(offsetof(UGbxNavArea, HavokNavMaterial) == 0x000050, "Member 'UGbxNavArea::HavokNavMaterial' has a wrong offset!");

// Class GbxNav.GbxNavAreaData
// 0x0010 (0x0040 - 0x0030)
class UGbxNavAreaData final : public UDataAsset
{
public:
	TArray<struct FGbxNavAreaItem>                NavAreas;                                          // 0x0030(0x0010)(Edit, ZeroConstructor, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"GbxNavAreaData">();
	}
	static class UGbxNavAreaData* GetDefaultObj()
	{
		return GetDefaultObjImpl<UGbxNavAreaData>();
	}
};
static_assert(alignof(UGbxNavAreaData) == 0x000008, "Wrong alignment on UGbxNavAreaData");
static_assert(sizeof(UGbxNavAreaData) == 0x000040, "Wrong size on UGbxNavAreaData");
static_assert(offsetof(UGbxNavAreaData, NavAreas) == 0x000030, "Member 'UGbxNavAreaData::NavAreas' has a wrong offset!");

// Class GbxNav.GbxNavBlueprintLibrary
// 0x0000 (0x0028 - 0x0028)
class UGbxNavBlueprintLibrary final : public UBlueprintFunctionLibrary
{
public:
	static bool FindNavMeshPoint(class UObject* WorldContextObject, const struct FVector& Point, float Radius, struct FVector* Result, class UGbxNavMeshLayer* Layer);
	static bool FindNavMeshPointForActor(class AActor* Actor, const struct FVector& Point, float Radius, struct FVector* Result);
	static void ForceNavMeshLayer(class AActor* Actor, class UGbxNavMeshLayer* ForcedNavMeshLayer);
	static void ResourceLockAvoidance(class AActor* Actor, class FName Reason);
	static void ResourceUnlockAvoidance(class AActor* Actor, class FName Reason);
	static void SetAINavPathType(class AActor* Actor, EGbxPathType PathType);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"GbxNavBlueprintLibrary">();
	}
	static class UGbxNavBlueprintLibrary* GetDefaultObj()
	{
		return GetDefaultObjImpl<UGbxNavBlueprintLibrary>();
	}
};
static_assert(alignof(UGbxNavBlueprintLibrary) == 0x000008, "Wrong alignment on UGbxNavBlueprintLibrary");
static_assert(sizeof(UGbxNavBlueprintLibrary) == 0x000028, "Wrong size on UGbxNavBlueprintLibrary");

// Class GbxNav.GbxNavBoxComponent
// 0x0010 (0x0730 - 0x0720)
class UGbxNavBoxComponent final : public UBoxComponent
{
public:
	struct FGbxTriggerProperty                    AutoResize;                                        // 0x0720(0x0001)(Edit, IsPlainOldData, NoDestructor, NativeAccessSpecifierPrivate)
	uint8                                         Pad_721[0xF];                                      // 0x0721(0x000F)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void DoAutoResize();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"GbxNavBoxComponent">();
	}
	static class UGbxNavBoxComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UGbxNavBoxComponent>();
	}
};
static_assert(alignof(UGbxNavBoxComponent) == 0x000008, "Wrong alignment on UGbxNavBoxComponent");
static_assert(sizeof(UGbxNavBoxComponent) == 0x000730, "Wrong size on UGbxNavBoxComponent");
static_assert(offsetof(UGbxNavBoxComponent, AutoResize) == 0x000720, "Member 'UGbxNavBoxComponent::AutoResize' has a wrong offset!");

// Class GbxNav.GbxNavLayer
// 0x0008 (0x0038 - 0x0030)
class UGbxNavLayer : public UGbxNavLayerBase
{
public:
	struct FColor                                 DrawColor;                                         // 0x0030(0x0004)(Edit, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_34[0x4];                                       // 0x0034(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"GbxNavLayer">();
	}
	static class UGbxNavLayer* GetDefaultObj()
	{
		return GetDefaultObjImpl<UGbxNavLayer>();
	}
};
static_assert(alignof(UGbxNavLayer) == 0x000008, "Wrong alignment on UGbxNavLayer");
static_assert(sizeof(UGbxNavLayer) == 0x000038, "Wrong size on UGbxNavLayer");
static_assert(offsetof(UGbxNavLayer, DrawColor) == 0x000030, "Member 'UGbxNavLayer::DrawColor' has a wrong offset!");

// Class GbxNav.GbxNavFlyLayer
// 0x0010 (0x0048 - 0x0038)
class UGbxNavFlyLayer final : public UGbxNavLayer
{
public:
	float                                         MaxAgentRadius;                                    // 0x0038(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	float                                         CellWidth;                                         // 0x003C(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	EGbxNavFlyRoundingMode                        RoundingMode;                                      // 0x0040(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_41[0x7];                                       // 0x0041(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"GbxNavFlyLayer">();
	}
	static class UGbxNavFlyLayer* GetDefaultObj()
	{
		return GetDefaultObjImpl<UGbxNavFlyLayer>();
	}
};
static_assert(alignof(UGbxNavFlyLayer) == 0x000008, "Wrong alignment on UGbxNavFlyLayer");
static_assert(sizeof(UGbxNavFlyLayer) == 0x000048, "Wrong size on UGbxNavFlyLayer");
static_assert(offsetof(UGbxNavFlyLayer, MaxAgentRadius) == 0x000038, "Member 'UGbxNavFlyLayer::MaxAgentRadius' has a wrong offset!");
static_assert(offsetof(UGbxNavFlyLayer, CellWidth) == 0x00003C, "Member 'UGbxNavFlyLayer::CellWidth' has a wrong offset!");
static_assert(offsetof(UGbxNavFlyLayer, RoundingMode) == 0x000040, "Member 'UGbxNavFlyLayer::RoundingMode' has a wrong offset!");

// Class GbxNav.GbxNavFlySection
// 0x0008 (0x04A8 - 0x04A0)
class AGbxNavFlySection final : public AGbxNavSection
{
public:
	class UGbxNavFlySectionComponent*             FlySectionComponent;                               // 0x04A0(0x0008)(Edit, ExportObject, ZeroConstructor, EditConst, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"GbxNavFlySection">();
	}
	static class AGbxNavFlySection* GetDefaultObj()
	{
		return GetDefaultObjImpl<AGbxNavFlySection>();
	}
};
static_assert(alignof(AGbxNavFlySection) == 0x000008, "Wrong alignment on AGbxNavFlySection");
static_assert(sizeof(AGbxNavFlySection) == 0x0004A8, "Wrong size on AGbxNavFlySection");
static_assert(offsetof(AGbxNavFlySection, FlySectionComponent) == 0x0004A0, "Member 'AGbxNavFlySection::FlySectionComponent' has a wrong offset!");

// Class GbxNav.GbxNavSectionComponent
// 0x0070 (0x0760 - 0x06F0)
class UGbxNavSectionComponent : public UPrimitiveComponent
{
public:
	uint32                                        SectionID;                                         // 0x06F0(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	struct FGuid                                  StreamingGuid;                                     // 0x06F4(0x0010)(IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_704[0x4];                                      // 0x0704(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class AGbxNavWorld*                           GbxNavWorld;                                       // 0x0708(0x0008)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_710[0x18];                                     // 0x0710(0x0018)(Fixing Size After Last Property [ Dumper-7 ])
	bool                                          bAddAllConnectedComponentsToBounds;                // 0x0728(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_729[0x7];                                      // 0x0729(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	struct FTransform                             BuildTransform;                                    // 0x0730(0x0030)(IsPlainOldData, NoDestructor, Protected, NativeAccessSpecifierProtected)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"GbxNavSectionComponent">();
	}
	static class UGbxNavSectionComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UGbxNavSectionComponent>();
	}
};
static_assert(alignof(UGbxNavSectionComponent) == 0x000010, "Wrong alignment on UGbxNavSectionComponent");
static_assert(sizeof(UGbxNavSectionComponent) == 0x000760, "Wrong size on UGbxNavSectionComponent");
static_assert(offsetof(UGbxNavSectionComponent, SectionID) == 0x0006F0, "Member 'UGbxNavSectionComponent::SectionID' has a wrong offset!");
static_assert(offsetof(UGbxNavSectionComponent, StreamingGuid) == 0x0006F4, "Member 'UGbxNavSectionComponent::StreamingGuid' has a wrong offset!");
static_assert(offsetof(UGbxNavSectionComponent, GbxNavWorld) == 0x000708, "Member 'UGbxNavSectionComponent::GbxNavWorld' has a wrong offset!");
static_assert(offsetof(UGbxNavSectionComponent, bAddAllConnectedComponentsToBounds) == 0x000728, "Member 'UGbxNavSectionComponent::bAddAllConnectedComponentsToBounds' has a wrong offset!");
static_assert(offsetof(UGbxNavSectionComponent, BuildTransform) == 0x000730, "Member 'UGbxNavSectionComponent::BuildTransform' has a wrong offset!");

// Class GbxNav.GbxNavFlySectionComponent
// 0x0070 (0x07D0 - 0x0760)
class UGbxNavFlySectionComponent final : public UGbxNavSectionComponent
{
public:
	class UGbxNavFlyLayer*                        FlyLayer;                                          // 0x0760(0x0008)(Edit, ZeroConstructor, NoClear, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UGbxNavFlyLayer*                        BuildFlyLayer;                                     // 0x0768(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bDrawBoundingFaces;                                // 0x0770(0x0001)(Edit, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bDrawCells;                                        // 0x0771(0x0001)(Edit, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bDrawFaces;                                        // 0x0772(0x0001)(Edit, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_773[0x1];                                      // 0x0773(0x0001)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         DrawBoxSize;                                       // 0x0774(0x0004)(Edit, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         DrawCullDistance;                                  // 0x0778(0x0004)(Edit, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_77C[0x24];                                     // 0x077C(0x0024)(Fixing Size After Last Property [ Dumper-7 ])
	class UHavokNavVolume*                        NavVolume;                                         // 0x07A0(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TArray<uint16>                                CellGroups;                                        // 0x07A8(0x0010)(ZeroConstructor, Protected, NativeAccessSpecifierProtected)
	TSubclassOf<class UHavokNavVolumeLayer>       Layer;                                             // 0x07B8(0x0008)(ZeroConstructor, Deprecated, IsPlainOldData, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TSubclassOf<class UHavokNavVolumeLayer>       BuildLayer;                                        // 0x07C0(0x0008)(ZeroConstructor, Deprecated, IsPlainOldData, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_7C8[0x8];                                      // 0x07C8(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"GbxNavFlySectionComponent">();
	}
	static class UGbxNavFlySectionComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UGbxNavFlySectionComponent>();
	}
};
static_assert(alignof(UGbxNavFlySectionComponent) == 0x000010, "Wrong alignment on UGbxNavFlySectionComponent");
static_assert(sizeof(UGbxNavFlySectionComponent) == 0x0007D0, "Wrong size on UGbxNavFlySectionComponent");
static_assert(offsetof(UGbxNavFlySectionComponent, FlyLayer) == 0x000760, "Member 'UGbxNavFlySectionComponent::FlyLayer' has a wrong offset!");
static_assert(offsetof(UGbxNavFlySectionComponent, BuildFlyLayer) == 0x000768, "Member 'UGbxNavFlySectionComponent::BuildFlyLayer' has a wrong offset!");
static_assert(offsetof(UGbxNavFlySectionComponent, bDrawBoundingFaces) == 0x000770, "Member 'UGbxNavFlySectionComponent::bDrawBoundingFaces' has a wrong offset!");
static_assert(offsetof(UGbxNavFlySectionComponent, bDrawCells) == 0x000771, "Member 'UGbxNavFlySectionComponent::bDrawCells' has a wrong offset!");
static_assert(offsetof(UGbxNavFlySectionComponent, bDrawFaces) == 0x000772, "Member 'UGbxNavFlySectionComponent::bDrawFaces' has a wrong offset!");
static_assert(offsetof(UGbxNavFlySectionComponent, DrawBoxSize) == 0x000774, "Member 'UGbxNavFlySectionComponent::DrawBoxSize' has a wrong offset!");
static_assert(offsetof(UGbxNavFlySectionComponent, DrawCullDistance) == 0x000778, "Member 'UGbxNavFlySectionComponent::DrawCullDistance' has a wrong offset!");
static_assert(offsetof(UGbxNavFlySectionComponent, NavVolume) == 0x0007A0, "Member 'UGbxNavFlySectionComponent::NavVolume' has a wrong offset!");
static_assert(offsetof(UGbxNavFlySectionComponent, CellGroups) == 0x0007A8, "Member 'UGbxNavFlySectionComponent::CellGroups' has a wrong offset!");
static_assert(offsetof(UGbxNavFlySectionComponent, Layer) == 0x0007B8, "Member 'UGbxNavFlySectionComponent::Layer' has a wrong offset!");
static_assert(offsetof(UGbxNavFlySectionComponent, BuildLayer) == 0x0007C0, "Member 'UGbxNavFlySectionComponent::BuildLayer' has a wrong offset!");

// Class GbxNav.GbxNavGlobalData
// 0x0048 (0x0078 - 0x0030)
class UGbxNavGlobalData final : public UGbxDataAsset
{
public:
	class UGbxNavMeshLayer*                       DefaultMeshLayer;                                  // 0x0030(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UGbxNavFlyLayer*                        DefaultFlyLayer;                                   // 0x0038(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UGbxNavArea*                            DefaultMeshArea;                                   // 0x0040(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UGbxNavArea*                            NullMeshArea;                                      // 0x0048(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TArray<class UGbxNavArea*>                    AllMeshAreas;                                      // 0x0050(0x0010)(Edit, ZeroConstructor, NativeAccessSpecifierPublic)
	class UGbxUserEdge*                           DefaultUserEdge;                                   // 0x0060(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TArray<class UGbxUserEdge*>                   GlobalUserEdges;                                   // 0x0068(0x0010)(Edit, ZeroConstructor, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"GbxNavGlobalData">();
	}
	static class UGbxNavGlobalData* GetDefaultObj()
	{
		return GetDefaultObjImpl<UGbxNavGlobalData>();
	}
};
static_assert(alignof(UGbxNavGlobalData) == 0x000008, "Wrong alignment on UGbxNavGlobalData");
static_assert(sizeof(UGbxNavGlobalData) == 0x000078, "Wrong size on UGbxNavGlobalData");
static_assert(offsetof(UGbxNavGlobalData, DefaultMeshLayer) == 0x000030, "Member 'UGbxNavGlobalData::DefaultMeshLayer' has a wrong offset!");
static_assert(offsetof(UGbxNavGlobalData, DefaultFlyLayer) == 0x000038, "Member 'UGbxNavGlobalData::DefaultFlyLayer' has a wrong offset!");
static_assert(offsetof(UGbxNavGlobalData, DefaultMeshArea) == 0x000040, "Member 'UGbxNavGlobalData::DefaultMeshArea' has a wrong offset!");
static_assert(offsetof(UGbxNavGlobalData, NullMeshArea) == 0x000048, "Member 'UGbxNavGlobalData::NullMeshArea' has a wrong offset!");
static_assert(offsetof(UGbxNavGlobalData, AllMeshAreas) == 0x000050, "Member 'UGbxNavGlobalData::AllMeshAreas' has a wrong offset!");
static_assert(offsetof(UGbxNavGlobalData, DefaultUserEdge) == 0x000060, "Member 'UGbxNavGlobalData::DefaultUserEdge' has a wrong offset!");
static_assert(offsetof(UGbxNavGlobalData, GlobalUserEdges) == 0x000068, "Member 'UGbxNavGlobalData::GlobalUserEdges' has a wrong offset!");

// Class GbxNav.GbxNavMeshLayer
// 0x0018 (0x0050 - 0x0038)
class UGbxNavMeshLayer final : public UGbxNavLayer
{
public:
	float                                         MaxAgentHalfHeight;                                // 0x0038(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	float                                         MaxAgentRadius;                                    // 0x003C(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	bool                                          bSetRadiusManually;                                // 0x0040(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_41[0x3];                                       // 0x0041(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         UserEdgeDistance;                                  // 0x0044(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	bool                                          bSetUserEdgeDistanceManually;                      // 0x0048(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_49[0x7];                                       // 0x0049(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"GbxNavMeshLayer">();
	}
	static class UGbxNavMeshLayer* GetDefaultObj()
	{
		return GetDefaultObjImpl<UGbxNavMeshLayer>();
	}
};
static_assert(alignof(UGbxNavMeshLayer) == 0x000008, "Wrong alignment on UGbxNavMeshLayer");
static_assert(sizeof(UGbxNavMeshLayer) == 0x000050, "Wrong size on UGbxNavMeshLayer");
static_assert(offsetof(UGbxNavMeshLayer, MaxAgentHalfHeight) == 0x000038, "Member 'UGbxNavMeshLayer::MaxAgentHalfHeight' has a wrong offset!");
static_assert(offsetof(UGbxNavMeshLayer, MaxAgentRadius) == 0x00003C, "Member 'UGbxNavMeshLayer::MaxAgentRadius' has a wrong offset!");
static_assert(offsetof(UGbxNavMeshLayer, bSetRadiusManually) == 0x000040, "Member 'UGbxNavMeshLayer::bSetRadiusManually' has a wrong offset!");
static_assert(offsetof(UGbxNavMeshLayer, UserEdgeDistance) == 0x000044, "Member 'UGbxNavMeshLayer::UserEdgeDistance' has a wrong offset!");
static_assert(offsetof(UGbxNavMeshLayer, bSetUserEdgeDistanceManually) == 0x000048, "Member 'UGbxNavMeshLayer::bSetUserEdgeDistanceManually' has a wrong offset!");

// Class GbxNav.GbxNavMeshPainter
// 0x0008 (0x0498 - 0x0490)
class AGbxNavMeshPainter final : public AVolume
{
public:
	class UGbxNavMeshPainterComponent*            PainterComponent;                                  // 0x0490(0x0008)(Edit, ExportObject, ZeroConstructor, EditConst, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)

public:
	void SetPainterEnabled(bool bNewEnabled);

	bool IsPainterEnabled() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"GbxNavMeshPainter">();
	}
	static class AGbxNavMeshPainter* GetDefaultObj()
	{
		return GetDefaultObjImpl<AGbxNavMeshPainter>();
	}
};
static_assert(alignof(AGbxNavMeshPainter) == 0x000008, "Wrong alignment on AGbxNavMeshPainter");
static_assert(sizeof(AGbxNavMeshPainter) == 0x000498, "Wrong size on AGbxNavMeshPainter");
static_assert(offsetof(AGbxNavMeshPainter, PainterComponent) == 0x000490, "Member 'AGbxNavMeshPainter::PainterComponent' has a wrong offset!");

// Class GbxNav.GbxNavMeshPainterComponent
// 0x00A0 (0x0218 - 0x0178)
class UGbxNavMeshPainterComponent final : public UActorComponent
{
public:
	bool                                          bAlwaysEnabled;                                    // 0x0178(0x0001)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bEnabled;                                          // 0x0179(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_17A[0x2];                                      // 0x017A(0x0002)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         IdleTime;                                          // 0x017C(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	EGbxPainterType                               PainterType;                                       // 0x0180(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_181[0x7];                                      // 0x0181(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	class UGbxNavArea*                            GbxNavArea;                                        // 0x0188(0x0008)(Edit, ZeroConstructor, NoClear, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	TArray<class FName>                           AssociatedComponentNames;                          // 0x0190(0x0010)(Edit, ZeroConstructor, NativeAccessSpecifierPrivate)
	uint32                                        PainterId;                                         // 0x01A0(0x0004)(Edit, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	float                                         PainterMovedThreshold;                             // 0x01A4(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	bool                                          bBlocksAutoGeneratedUserEdges;                     // 0x01A8(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_1A9[0x7];                                      // 0x01A9(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<struct FGbxPainterItem>                Painters;                                          // 0x01B0(0x0010)(ZeroConstructor, Transient, ContainsInstancedReference, NativeAccessSpecifierPrivate)
	uint8                                         Pad_1C0[0x50];                                     // 0x01C0(0x0050)(Fixing Size After Last Property [ Dumper-7 ])
	TSubclassOf<class UNavArea>                   NavArea;                                           // 0x0210(0x0008)(ZeroConstructor, Deprecated, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)

public:
	void ResetToStatic();
	void SetPainterAlwaysEnabled(bool bNewAlwaysEnabled);
	void SetPainterEnabled(bool bNewEnabled);

	bool IsPainterEnabled() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"GbxNavMeshPainterComponent">();
	}
	static class UGbxNavMeshPainterComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UGbxNavMeshPainterComponent>();
	}
};
static_assert(alignof(UGbxNavMeshPainterComponent) == 0x000008, "Wrong alignment on UGbxNavMeshPainterComponent");
static_assert(sizeof(UGbxNavMeshPainterComponent) == 0x000218, "Wrong size on UGbxNavMeshPainterComponent");
static_assert(offsetof(UGbxNavMeshPainterComponent, bAlwaysEnabled) == 0x000178, "Member 'UGbxNavMeshPainterComponent::bAlwaysEnabled' has a wrong offset!");
static_assert(offsetof(UGbxNavMeshPainterComponent, bEnabled) == 0x000179, "Member 'UGbxNavMeshPainterComponent::bEnabled' has a wrong offset!");
static_assert(offsetof(UGbxNavMeshPainterComponent, IdleTime) == 0x00017C, "Member 'UGbxNavMeshPainterComponent::IdleTime' has a wrong offset!");
static_assert(offsetof(UGbxNavMeshPainterComponent, PainterType) == 0x000180, "Member 'UGbxNavMeshPainterComponent::PainterType' has a wrong offset!");
static_assert(offsetof(UGbxNavMeshPainterComponent, GbxNavArea) == 0x000188, "Member 'UGbxNavMeshPainterComponent::GbxNavArea' has a wrong offset!");
static_assert(offsetof(UGbxNavMeshPainterComponent, AssociatedComponentNames) == 0x000190, "Member 'UGbxNavMeshPainterComponent::AssociatedComponentNames' has a wrong offset!");
static_assert(offsetof(UGbxNavMeshPainterComponent, PainterId) == 0x0001A0, "Member 'UGbxNavMeshPainterComponent::PainterId' has a wrong offset!");
static_assert(offsetof(UGbxNavMeshPainterComponent, PainterMovedThreshold) == 0x0001A4, "Member 'UGbxNavMeshPainterComponent::PainterMovedThreshold' has a wrong offset!");
static_assert(offsetof(UGbxNavMeshPainterComponent, bBlocksAutoGeneratedUserEdges) == 0x0001A8, "Member 'UGbxNavMeshPainterComponent::bBlocksAutoGeneratedUserEdges' has a wrong offset!");
static_assert(offsetof(UGbxNavMeshPainterComponent, Painters) == 0x0001B0, "Member 'UGbxNavMeshPainterComponent::Painters' has a wrong offset!");
static_assert(offsetof(UGbxNavMeshPainterComponent, NavArea) == 0x000210, "Member 'UGbxNavMeshPainterComponent::NavArea' has a wrong offset!");

// Class GbxNav.GbxNavMeshSection
// 0x0008 (0x04A8 - 0x04A0)
class AGbxNavMeshSection final : public AGbxNavSection
{
public:
	class UGbxNavMeshSectionComponent*            MeshSectionComponent;                              // 0x04A0(0x0008)(Edit, ExportObject, ZeroConstructor, EditConst, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"GbxNavMeshSection">();
	}
	static class AGbxNavMeshSection* GetDefaultObj()
	{
		return GetDefaultObjImpl<AGbxNavMeshSection>();
	}
};
static_assert(alignof(AGbxNavMeshSection) == 0x000008, "Wrong alignment on AGbxNavMeshSection");
static_assert(sizeof(AGbxNavMeshSection) == 0x0004A8, "Wrong size on AGbxNavMeshSection");
static_assert(offsetof(AGbxNavMeshSection, MeshSectionComponent) == 0x0004A0, "Member 'AGbxNavMeshSection::MeshSectionComponent' has a wrong offset!");

// Class GbxNav.GbxNavMeshSectionComponent
// 0x0060 (0x07C0 - 0x0760)
class UGbxNavMeshSectionComponent final : public UGbxNavSectionComponent
{
public:
	class UGbxNavMeshLayer*                       MeshLayer;                                         // 0x0760(0x0008)(Edit, ZeroConstructor, NoClear, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UGbxNavMeshLayer*                       BuildMeshLayer;                                    // 0x0768(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bAutoAddUserEdges;                                 // 0x0770(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_771[0x2F];                                     // 0x0771(0x002F)(Fixing Size After Last Property [ Dumper-7 ])
	class UHavokNavMesh*                          NavMesh;                                           // 0x07A0(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TSubclassOf<class UHavokNavMeshLayer>         Layer;                                             // 0x07A8(0x0008)(ZeroConstructor, Deprecated, IsPlainOldData, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TSubclassOf<class UHavokNavMeshLayer>         BuildLayer;                                        // 0x07B0(0x0008)(ZeroConstructor, Deprecated, IsPlainOldData, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_7B8[0x8];                                      // 0x07B8(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"GbxNavMeshSectionComponent">();
	}
	static class UGbxNavMeshSectionComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UGbxNavMeshSectionComponent>();
	}
};
static_assert(alignof(UGbxNavMeshSectionComponent) == 0x000010, "Wrong alignment on UGbxNavMeshSectionComponent");
static_assert(sizeof(UGbxNavMeshSectionComponent) == 0x0007C0, "Wrong size on UGbxNavMeshSectionComponent");
static_assert(offsetof(UGbxNavMeshSectionComponent, MeshLayer) == 0x000760, "Member 'UGbxNavMeshSectionComponent::MeshLayer' has a wrong offset!");
static_assert(offsetof(UGbxNavMeshSectionComponent, BuildMeshLayer) == 0x000768, "Member 'UGbxNavMeshSectionComponent::BuildMeshLayer' has a wrong offset!");
static_assert(offsetof(UGbxNavMeshSectionComponent, bAutoAddUserEdges) == 0x000770, "Member 'UGbxNavMeshSectionComponent::bAutoAddUserEdges' has a wrong offset!");
static_assert(offsetof(UGbxNavMeshSectionComponent, NavMesh) == 0x0007A0, "Member 'UGbxNavMeshSectionComponent::NavMesh' has a wrong offset!");
static_assert(offsetof(UGbxNavMeshSectionComponent, Layer) == 0x0007A8, "Member 'UGbxNavMeshSectionComponent::Layer' has a wrong offset!");
static_assert(offsetof(UGbxNavMeshSectionComponent, BuildLayer) == 0x0007B0, "Member 'UGbxNavMeshSectionComponent::BuildLayer' has a wrong offset!");

// Class GbxNav.GbxNavUserEdgeTrailComponent
// 0x00C0 (0x0238 - 0x0178)
class UGbxNavUserEdgeTrailComponent final : public UActorComponent
{
public:
	class UGbxUserEdge*                           GbxUserEdge;                                       // 0x0178(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	float                                         EdgeWidth;                                         // 0x0180(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	float                                         AgentRadius;                                       // 0x0184(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	float                                         AgentHalfHeight;                                   // 0x0188(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	float                                         NavCheckDistance;                                  // 0x018C(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	struct FNumericRange                          ValidEdgeLength;                                   // 0x0190(0x0008)(Edit, NoDestructor, NativeAccessSpecifierPrivate)
	int32                                         MaxActiveEdges;                                    // 0x0198(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	float                                         TraceRadius;                                       // 0x019C(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class AGbxNavWorld*                           GbxNavWorld;                                       // 0x01A0(0x0008)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	struct FGbxNavAgentProperties                 AgentProps;                                        // 0x01A8(0x0060)(Transient, NoDestructor, NativeAccessSpecifierPrivate)
	uint8                                         Pad_208[0x28];                                     // 0x0208(0x0028)(Fixing Size After Last Property [ Dumper-7 ])
	TSubclassOf<class UHavokUserEdge>             UserEdge;                                          // 0x0230(0x0008)(ZeroConstructor, Deprecated, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"GbxNavUserEdgeTrailComponent">();
	}
	static class UGbxNavUserEdgeTrailComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UGbxNavUserEdgeTrailComponent>();
	}
};
static_assert(alignof(UGbxNavUserEdgeTrailComponent) == 0x000008, "Wrong alignment on UGbxNavUserEdgeTrailComponent");
static_assert(sizeof(UGbxNavUserEdgeTrailComponent) == 0x000238, "Wrong size on UGbxNavUserEdgeTrailComponent");
static_assert(offsetof(UGbxNavUserEdgeTrailComponent, GbxUserEdge) == 0x000178, "Member 'UGbxNavUserEdgeTrailComponent::GbxUserEdge' has a wrong offset!");
static_assert(offsetof(UGbxNavUserEdgeTrailComponent, EdgeWidth) == 0x000180, "Member 'UGbxNavUserEdgeTrailComponent::EdgeWidth' has a wrong offset!");
static_assert(offsetof(UGbxNavUserEdgeTrailComponent, AgentRadius) == 0x000184, "Member 'UGbxNavUserEdgeTrailComponent::AgentRadius' has a wrong offset!");
static_assert(offsetof(UGbxNavUserEdgeTrailComponent, AgentHalfHeight) == 0x000188, "Member 'UGbxNavUserEdgeTrailComponent::AgentHalfHeight' has a wrong offset!");
static_assert(offsetof(UGbxNavUserEdgeTrailComponent, NavCheckDistance) == 0x00018C, "Member 'UGbxNavUserEdgeTrailComponent::NavCheckDistance' has a wrong offset!");
static_assert(offsetof(UGbxNavUserEdgeTrailComponent, ValidEdgeLength) == 0x000190, "Member 'UGbxNavUserEdgeTrailComponent::ValidEdgeLength' has a wrong offset!");
static_assert(offsetof(UGbxNavUserEdgeTrailComponent, MaxActiveEdges) == 0x000198, "Member 'UGbxNavUserEdgeTrailComponent::MaxActiveEdges' has a wrong offset!");
static_assert(offsetof(UGbxNavUserEdgeTrailComponent, TraceRadius) == 0x00019C, "Member 'UGbxNavUserEdgeTrailComponent::TraceRadius' has a wrong offset!");
static_assert(offsetof(UGbxNavUserEdgeTrailComponent, GbxNavWorld) == 0x0001A0, "Member 'UGbxNavUserEdgeTrailComponent::GbxNavWorld' has a wrong offset!");
static_assert(offsetof(UGbxNavUserEdgeTrailComponent, AgentProps) == 0x0001A8, "Member 'UGbxNavUserEdgeTrailComponent::AgentProps' has a wrong offset!");
static_assert(offsetof(UGbxNavUserEdgeTrailComponent, UserEdge) == 0x000230, "Member 'UGbxNavUserEdgeTrailComponent::UserEdge' has a wrong offset!");

// Class GbxNav.GbxPathFollowingComponent
// 0x0000 (0x0350 - 0x0350)
class UGbxPathFollowingComponent final : public UHavokPathFollowingComponent
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"GbxPathFollowingComponent">();
	}
	static class UGbxPathFollowingComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UGbxPathFollowingComponent>();
	}
};
static_assert(alignof(UGbxPathFollowingComponent) == 0x000008, "Wrong alignment on UGbxPathFollowingComponent");
static_assert(sizeof(UGbxPathFollowingComponent) == 0x000350, "Wrong size on UGbxPathFollowingComponent");

// Class GbxNav.GbxUserEdge
// 0x0040 (0x0070 - 0x0030)
class UGbxUserEdge final : public UGbxUserEdgeBase
{
public:
	class UGbxUserEdge*                           ReverseEdge;                                       // 0x0030(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	struct FColor                                 DrawColor;                                         // 0x0038(0x0004)(Edit, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bAlignEdges;                                       // 0x003C(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bLimitDistanceMin;                                 // 0x003D(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_3E[0x2];                                       // 0x003E(0x0002)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         DistanceMin;                                       // 0x0040(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bLimitDistanceMax;                                 // 0x0044(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_45[0x3];                                       // 0x0045(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         DistanceMax;                                       // 0x0048(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bLimitHeightMin;                                   // 0x004C(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_4D[0x3];                                       // 0x004D(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         HeightMin;                                         // 0x0050(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bLimitHeightMax;                                   // 0x0054(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_55[0x3];                                       // 0x0055(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         HeightMax;                                         // 0x0058(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bZeroWidthEntry;                                   // 0x005C(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bZeroWidthExit;                                    // 0x005D(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bTeleportEntry;                                    // 0x005E(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bTeleportExit;                                     // 0x005F(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TArray<class UGbxUserEdge*>                   TeleportEdges;                                     // 0x0060(0x0010)(Edit, ZeroConstructor, Protected, NativeAccessSpecifierProtected)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"GbxUserEdge">();
	}
	static class UGbxUserEdge* GetDefaultObj()
	{
		return GetDefaultObjImpl<UGbxUserEdge>();
	}
};
static_assert(alignof(UGbxUserEdge) == 0x000008, "Wrong alignment on UGbxUserEdge");
static_assert(sizeof(UGbxUserEdge) == 0x000070, "Wrong size on UGbxUserEdge");
static_assert(offsetof(UGbxUserEdge, ReverseEdge) == 0x000030, "Member 'UGbxUserEdge::ReverseEdge' has a wrong offset!");
static_assert(offsetof(UGbxUserEdge, DrawColor) == 0x000038, "Member 'UGbxUserEdge::DrawColor' has a wrong offset!");
static_assert(offsetof(UGbxUserEdge, bAlignEdges) == 0x00003C, "Member 'UGbxUserEdge::bAlignEdges' has a wrong offset!");
static_assert(offsetof(UGbxUserEdge, bLimitDistanceMin) == 0x00003D, "Member 'UGbxUserEdge::bLimitDistanceMin' has a wrong offset!");
static_assert(offsetof(UGbxUserEdge, DistanceMin) == 0x000040, "Member 'UGbxUserEdge::DistanceMin' has a wrong offset!");
static_assert(offsetof(UGbxUserEdge, bLimitDistanceMax) == 0x000044, "Member 'UGbxUserEdge::bLimitDistanceMax' has a wrong offset!");
static_assert(offsetof(UGbxUserEdge, DistanceMax) == 0x000048, "Member 'UGbxUserEdge::DistanceMax' has a wrong offset!");
static_assert(offsetof(UGbxUserEdge, bLimitHeightMin) == 0x00004C, "Member 'UGbxUserEdge::bLimitHeightMin' has a wrong offset!");
static_assert(offsetof(UGbxUserEdge, HeightMin) == 0x000050, "Member 'UGbxUserEdge::HeightMin' has a wrong offset!");
static_assert(offsetof(UGbxUserEdge, bLimitHeightMax) == 0x000054, "Member 'UGbxUserEdge::bLimitHeightMax' has a wrong offset!");
static_assert(offsetof(UGbxUserEdge, HeightMax) == 0x000058, "Member 'UGbxUserEdge::HeightMax' has a wrong offset!");
static_assert(offsetof(UGbxUserEdge, bZeroWidthEntry) == 0x00005C, "Member 'UGbxUserEdge::bZeroWidthEntry' has a wrong offset!");
static_assert(offsetof(UGbxUserEdge, bZeroWidthExit) == 0x00005D, "Member 'UGbxUserEdge::bZeroWidthExit' has a wrong offset!");
static_assert(offsetof(UGbxUserEdge, bTeleportEntry) == 0x00005E, "Member 'UGbxUserEdge::bTeleportEntry' has a wrong offset!");
static_assert(offsetof(UGbxUserEdge, bTeleportExit) == 0x00005F, "Member 'UGbxUserEdge::bTeleportExit' has a wrong offset!");
static_assert(offsetof(UGbxUserEdge, TeleportEdges) == 0x000060, "Member 'UGbxUserEdge::TeleportEdges' has a wrong offset!");

// Class GbxNav.GbxUserEdgeBlocker
// 0x0038 (0x04C8 - 0x0490)
class AGbxUserEdgeBlocker final : public AVolume
{
public:
	uint8                                         Pad_490[0x38];                                     // 0x0490(0x0038)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"GbxUserEdgeBlocker">();
	}
	static class AGbxUserEdgeBlocker* GetDefaultObj()
	{
		return GetDefaultObjImpl<AGbxUserEdgeBlocker>();
	}
};
static_assert(alignof(AGbxUserEdgeBlocker) == 0x000008, "Wrong alignment on AGbxUserEdgeBlocker");
static_assert(sizeof(AGbxUserEdgeBlocker) == 0x0004C8, "Wrong size on AGbxUserEdgeBlocker");

// Class GbxNav.HavokMovementData
// 0x0000 (0x0030 - 0x0030)
class UHavokMovementData final : public UDataAsset
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"HavokMovementData">();
	}
	static class UHavokMovementData* GetDefaultObj()
	{
		return GetDefaultObjImpl<UHavokMovementData>();
	}
};
static_assert(alignof(UHavokMovementData) == 0x000008, "Wrong alignment on UHavokMovementData");
static_assert(sizeof(UHavokMovementData) == 0x000030, "Wrong size on UHavokMovementData");

// Class GbxNav.HavokNavObstacle
// 0x0048 (0x0070 - 0x0028)
class UHavokNavObstacle final : public UObject
{
public:
	float                                         SphereRadius;                                      // 0x0028(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	bool                                          bUseSphere;                                        // 0x002C(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_2D[0x3];                                       // 0x002D(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	struct FVector                                BoxSize;                                           // 0x0030(0x000C)(Edit, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	bool                                          bUseBox;                                           // 0x003C(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_3D[0x3];                                       // 0x003D(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	struct FVector                                Scale;                                             // 0x0040(0x000C)(Edit, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_4C[0x4];                                       // 0x004C(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class UGbxNavArea*                            NavArea;                                           // 0x0050(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UPrimitiveComponent*                    PrimitiveBase;                                     // 0x0058(0x0008)(ExportObject, ZeroConstructor, Transient, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_60[0x10];                                      // 0x0060(0x0010)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"HavokNavObstacle">();
	}
	static class UHavokNavObstacle* GetDefaultObj()
	{
		return GetDefaultObjImpl<UHavokNavObstacle>();
	}
};
static_assert(alignof(UHavokNavObstacle) == 0x000008, "Wrong alignment on UHavokNavObstacle");
static_assert(sizeof(UHavokNavObstacle) == 0x000070, "Wrong size on UHavokNavObstacle");
static_assert(offsetof(UHavokNavObstacle, SphereRadius) == 0x000028, "Member 'UHavokNavObstacle::SphereRadius' has a wrong offset!");
static_assert(offsetof(UHavokNavObstacle, bUseSphere) == 0x00002C, "Member 'UHavokNavObstacle::bUseSphere' has a wrong offset!");
static_assert(offsetof(UHavokNavObstacle, BoxSize) == 0x000030, "Member 'UHavokNavObstacle::BoxSize' has a wrong offset!");
static_assert(offsetof(UHavokNavObstacle, bUseBox) == 0x00003C, "Member 'UHavokNavObstacle::bUseBox' has a wrong offset!");
static_assert(offsetof(UHavokNavObstacle, Scale) == 0x000040, "Member 'UHavokNavObstacle::Scale' has a wrong offset!");
static_assert(offsetof(UHavokNavObstacle, NavArea) == 0x000050, "Member 'UHavokNavObstacle::NavArea' has a wrong offset!");
static_assert(offsetof(UHavokNavObstacle, PrimitiveBase) == 0x000058, "Member 'UHavokNavObstacle::PrimitiveBase' has a wrong offset!");

// Class GbxNav.HavokNavObstacleComponent
// 0x00A0 (0x0790 - 0x06F0)
class UHavokNavObstacleComponent final : public UPrimitiveComponent
{
public:
	uint8                                         Pad_6F0[0x98];                                     // 0x06F0(0x0098)(Fixing Size After Last Property [ Dumper-7 ])
	class UHavokNavObstacle*                      Obstacle;                                          // 0x0788(0x0008)(Edit, ExportObject, ZeroConstructor, InstancedReference, NoClear, IsPlainOldData, NoDestructor, PersistentInstance, HasGetValueTypeHash, NativeAccessSpecifierPrivate)

public:
	void LockObstacle(class FName Reason);
	void UnlockObstacle(class FName Reason);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"HavokNavObstacleComponent">();
	}
	static class UHavokNavObstacleComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UHavokNavObstacleComponent>();
	}
};
static_assert(alignof(UHavokNavObstacleComponent) == 0x000008, "Wrong alignment on UHavokNavObstacleComponent");
static_assert(sizeof(UHavokNavObstacleComponent) == 0x000790, "Wrong size on UHavokNavObstacleComponent");
static_assert(offsetof(UHavokNavObstacleComponent, Obstacle) == 0x000788, "Member 'UHavokNavObstacleComponent::Obstacle' has a wrong offset!");

// Class GbxNav.HavokPathFindingData
// 0x0028 (0x0058 - 0x0030)
class UHavokPathFindingData final : public UDataAsset
{
public:
	TArray<struct FHavokUserEdgeItem>             UserEdges;                                         // 0x0030(0x0010)(Edit, ZeroConstructor, NativeAccessSpecifierPublic)
	TArray<struct FHavokUserEdgeTeleportItem>     UserEdgeTeleports;                                 // 0x0040(0x0010)(Edit, ZeroConstructor, NativeAccessSpecifierPublic)
	TSubclassOf<class UGbxAction>                 DefaultTeleportAction;                             // 0x0050(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"HavokPathFindingData">();
	}
	static class UHavokPathFindingData* GetDefaultObj()
	{
		return GetDefaultObjImpl<UHavokPathFindingData>();
	}
};
static_assert(alignof(UHavokPathFindingData) == 0x000008, "Wrong alignment on UHavokPathFindingData");
static_assert(sizeof(UHavokPathFindingData) == 0x000058, "Wrong size on UHavokPathFindingData");
static_assert(offsetof(UHavokPathFindingData, UserEdges) == 0x000030, "Member 'UHavokPathFindingData::UserEdges' has a wrong offset!");
static_assert(offsetof(UHavokPathFindingData, UserEdgeTeleports) == 0x000040, "Member 'UHavokPathFindingData::UserEdgeTeleports' has a wrong offset!");
static_assert(offsetof(UHavokPathFindingData, DefaultTeleportAction) == 0x000050, "Member 'UHavokPathFindingData::DefaultTeleportAction' has a wrong offset!");

// Class GbxNav.HavokStreamingSet
// 0x0018 (0x0040 - 0x0028)
class UHavokStreamingSet final : public UObject
{
public:
	uint32                                        SectionIdA;                                        // 0x0028(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint32                                        SectionIdB;                                        // 0x002C(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_30[0x10];                                      // 0x0030(0x0010)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"HavokStreamingSet">();
	}
	static class UHavokStreamingSet* GetDefaultObj()
	{
		return GetDefaultObjImpl<UHavokStreamingSet>();
	}
};
static_assert(alignof(UHavokStreamingSet) == 0x000008, "Wrong alignment on UHavokStreamingSet");
static_assert(sizeof(UHavokStreamingSet) == 0x000040, "Wrong size on UHavokStreamingSet");
static_assert(offsetof(UHavokStreamingSet, SectionIdA) == 0x000028, "Member 'UHavokStreamingSet::SectionIdA' has a wrong offset!");
static_assert(offsetof(UHavokStreamingSet, SectionIdB) == 0x00002C, "Member 'UHavokStreamingSet::SectionIdB' has a wrong offset!");

// Class GbxNav.HavokUserEdge_Jump
// 0x0000 (0x0070 - 0x0070)
class UHavokUserEdge_Jump final : public UHavokUserEdge
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"HavokUserEdge_Jump">();
	}
	static class UHavokUserEdge_Jump* GetDefaultObj()
	{
		return GetDefaultObjImpl<UHavokUserEdge_Jump>();
	}
};
static_assert(alignof(UHavokUserEdge_Jump) == 0x000008, "Wrong alignment on UHavokUserEdge_Jump");
static_assert(sizeof(UHavokUserEdge_Jump) == 0x000070, "Wrong size on UHavokUserEdge_Jump");

// Class GbxNav.HavokUserEdgeActor
// 0x0048 (0x04A0 - 0x0458)
class AHavokUserEdgeActor final : public AActor
{
public:
	uint8                                         Pad_458[0x8];                                      // 0x0458(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	struct FTransform                             EdgeEnd;                                           // 0x0460(0x0030)(IsPlainOldData, NoDestructor, NativeAccessSpecifierPrivate)
	class UHavokUserEdgeComponent*                UserEdgeComponent;                                 // 0x0490(0x0008)(Edit, ExportObject, ZeroConstructor, EditConst, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_498[0x8];                                      // 0x0498(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void SetEdgeEnabled(bool bNewEnabled);

	bool IsEdgeEnabled() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"HavokUserEdgeActor">();
	}
	static class AHavokUserEdgeActor* GetDefaultObj()
	{
		return GetDefaultObjImpl<AHavokUserEdgeActor>();
	}
};
static_assert(alignof(AHavokUserEdgeActor) == 0x000010, "Wrong alignment on AHavokUserEdgeActor");
static_assert(sizeof(AHavokUserEdgeActor) == 0x0004A0, "Wrong size on AHavokUserEdgeActor");
static_assert(offsetof(AHavokUserEdgeActor, EdgeEnd) == 0x000460, "Member 'AHavokUserEdgeActor::EdgeEnd' has a wrong offset!");
static_assert(offsetof(AHavokUserEdgeActor, UserEdgeComponent) == 0x000490, "Member 'AHavokUserEdgeActor::UserEdgeComponent' has a wrong offset!");

// Class GbxNav.HavokUserEdgeComponent
// 0x0100 (0x07F0 - 0x06F0)
class UHavokUserEdgeComponent final : public UPrimitiveComponent
{
public:
	uint8                                         Pad_6F0[0x8];                                      // 0x06F0(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	bool                                          bEnabled;                                          // 0x06F8(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_6F9[0x7];                                      // 0x06F9(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	struct FTransform                             EdgeEnd;                                           // 0x0700(0x0030)(Edit, IsPlainOldData, NoDestructor, NativeAccessSpecifierPrivate)
	float                                         EdgeBeginWidth;                                    // 0x0730(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	float                                         EdgeEndWidth;                                      // 0x0734(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	EGbxUserEdgeDirection                         Direction;                                         // 0x0738(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_739[0x7];                                      // 0x0739(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	class UGbxUserEdge*                           GbxUserEdge;                                       // 0x0740(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	float                                         TeleportRadius;                                    // 0x0748(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_74C[0x4];                                      // 0x074C(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<class UHavokUserEdgeComponent*>        TeleportEdges;                                     // 0x0750(0x0010)(Edit, ExportObject, ZeroConstructor, EditConst, ContainsInstancedReference, NativeAccessSpecifierPrivate)
	bool                                          bAnchorEnd;                                        // 0x0760(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_761[0x7];                                      // 0x0761(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	class AActor*                                 EndAnchorBase;                                     // 0x0768(0x0008)(Edit, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	struct FTransform                             EndAnchorTransform;                                // 0x0770(0x0030)(Edit, EditConst, IsPlainOldData, NoDestructor, NativeAccessSpecifierPrivate)
	class USceneComponent*                        RegisteredEndAnchorRoot;                           // 0x07A0(0x0008)(ExportObject, ZeroConstructor, Transient, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint32                                        EdgeID;                                            // 0x07A8(0x0004)(Edit, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, NonPIEDuplicateTransient, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_7AC[0x34];                                     // 0x07AC(0x0034)(Fixing Size After Last Property [ Dumper-7 ])
	TSubclassOf<class UHavokUserEdge>             UserEdge;                                          // 0x07E0(0x0008)(ZeroConstructor, Deprecated, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_7E8[0x8];                                      // 0x07E8(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void AnchorDestroyed(class AActor* Actor);
	void SetEdgeEnabled(bool bNewEnabled);

	bool IsEdgeEnabled() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"HavokUserEdgeComponent">();
	}
	static class UHavokUserEdgeComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UHavokUserEdgeComponent>();
	}
};
static_assert(alignof(UHavokUserEdgeComponent) == 0x000010, "Wrong alignment on UHavokUserEdgeComponent");
static_assert(sizeof(UHavokUserEdgeComponent) == 0x0007F0, "Wrong size on UHavokUserEdgeComponent");
static_assert(offsetof(UHavokUserEdgeComponent, bEnabled) == 0x0006F8, "Member 'UHavokUserEdgeComponent::bEnabled' has a wrong offset!");
static_assert(offsetof(UHavokUserEdgeComponent, EdgeEnd) == 0x000700, "Member 'UHavokUserEdgeComponent::EdgeEnd' has a wrong offset!");
static_assert(offsetof(UHavokUserEdgeComponent, EdgeBeginWidth) == 0x000730, "Member 'UHavokUserEdgeComponent::EdgeBeginWidth' has a wrong offset!");
static_assert(offsetof(UHavokUserEdgeComponent, EdgeEndWidth) == 0x000734, "Member 'UHavokUserEdgeComponent::EdgeEndWidth' has a wrong offset!");
static_assert(offsetof(UHavokUserEdgeComponent, Direction) == 0x000738, "Member 'UHavokUserEdgeComponent::Direction' has a wrong offset!");
static_assert(offsetof(UHavokUserEdgeComponent, GbxUserEdge) == 0x000740, "Member 'UHavokUserEdgeComponent::GbxUserEdge' has a wrong offset!");
static_assert(offsetof(UHavokUserEdgeComponent, TeleportRadius) == 0x000748, "Member 'UHavokUserEdgeComponent::TeleportRadius' has a wrong offset!");
static_assert(offsetof(UHavokUserEdgeComponent, TeleportEdges) == 0x000750, "Member 'UHavokUserEdgeComponent::TeleportEdges' has a wrong offset!");
static_assert(offsetof(UHavokUserEdgeComponent, bAnchorEnd) == 0x000760, "Member 'UHavokUserEdgeComponent::bAnchorEnd' has a wrong offset!");
static_assert(offsetof(UHavokUserEdgeComponent, EndAnchorBase) == 0x000768, "Member 'UHavokUserEdgeComponent::EndAnchorBase' has a wrong offset!");
static_assert(offsetof(UHavokUserEdgeComponent, EndAnchorTransform) == 0x000770, "Member 'UHavokUserEdgeComponent::EndAnchorTransform' has a wrong offset!");
static_assert(offsetof(UHavokUserEdgeComponent, RegisteredEndAnchorRoot) == 0x0007A0, "Member 'UHavokUserEdgeComponent::RegisteredEndAnchorRoot' has a wrong offset!");
static_assert(offsetof(UHavokUserEdgeComponent, EdgeID) == 0x0007A8, "Member 'UHavokUserEdgeComponent::EdgeID' has a wrong offset!");
static_assert(offsetof(UHavokUserEdgeComponent, UserEdge) == 0x0007E0, "Member 'UHavokUserEdgeComponent::UserEdge' has a wrong offset!");

// Class GbxNav.HavokUserEdgePreviewComponent
// 0x0000 (0x06F0 - 0x06F0)
class UHavokUserEdgePreviewComponent final : public UPrimitiveComponent
{
public:
	void OnBlueprintCompiled(class UBlueprint* BP);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"HavokUserEdgePreviewComponent">();
	}
	static class UHavokUserEdgePreviewComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UHavokUserEdgePreviewComponent>();
	}
};
static_assert(alignof(UHavokUserEdgePreviewComponent) == 0x000008, "Wrong alignment on UHavokUserEdgePreviewComponent");
static_assert(sizeof(UHavokUserEdgePreviewComponent) == 0x0006F0, "Wrong size on UHavokUserEdgePreviewComponent");

// Class GbxNav.VehicleSplineConsumerInterface
// 0x0000 (0x0028 - 0x0028)
class IVehicleSplineConsumerInterface final : public IInterface
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"VehicleSplineConsumerInterface">();
	}
	static class IVehicleSplineConsumerInterface* GetDefaultObj()
	{
		return GetDefaultObjImpl<IVehicleSplineConsumerInterface>();
	}
};
static_assert(alignof(IVehicleSplineConsumerInterface) == 0x000008, "Wrong alignment on IVehicleSplineConsumerInterface");
static_assert(sizeof(IVehicleSplineConsumerInterface) == 0x000028, "Wrong size on IVehicleSplineConsumerInterface");

// Class GbxNav.VehicleSplineInterface
// 0x0000 (0x0028 - 0x0028)
class IVehicleSplineInterface final : public IInterface
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"VehicleSplineInterface">();
	}
	static class IVehicleSplineInterface* GetDefaultObj()
	{
		return GetDefaultObjImpl<IVehicleSplineInterface>();
	}
};
static_assert(alignof(IVehicleSplineInterface) == 0x000008, "Wrong alignment on IVehicleSplineInterface");
static_assert(sizeof(IVehicleSplineInterface) == 0x000028, "Wrong size on IVehicleSplineInterface");

}

