#pragma once

/*
* SDK generated by Dumper-7
*
* https://github.com/Encryqed/Dumper-7
*/

// Package: GbxTest

#include "Basic.hpp"

#include "GbxTest_structs.hpp"
#include "Engine_structs.hpp"
#include "Engine_classes.hpp"
#include "CoreUObject_classes.hpp"


namespace SDK
{

// Class GbxTest.AssetTrait
// 0x0008 (0x0038 - 0x0030)
class UAssetTrait : public UDataAsset
{
public:
	class UAssetTrait*                            TraitToWhitelist;                                  // 0x0030(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"AssetTrait">();
	}
	static class UAssetTrait* GetDefaultObj()
	{
		return GetDefaultObjImpl<UAssetTrait>();
	}
};
static_assert(alignof(UAssetTrait) == 0x000008, "Wrong alignment on UAssetTrait");
static_assert(sizeof(UAssetTrait) == 0x000038, "Wrong size on UAssetTrait");
static_assert(offsetof(UAssetTrait, TraitToWhitelist) == 0x000030, "Member 'UAssetTrait::TraitToWhitelist' has a wrong offset!");

// Class GbxTest.AssetTraitMaterial
// 0x0018 (0x0050 - 0x0038)
class UAssetTraitMaterial final : public UAssetTrait
{
public:
	struct FOptionalBool                          UsedWithSkeletalMesh;                              // 0x0038(0x0002)(Edit, BlueprintVisible, NoDestructor, NativeAccessSpecifierPublic)
	struct FOptionalBool                          UsedWithParticleSprites;                           // 0x003A(0x0002)(Edit, BlueprintVisible, NoDestructor, NativeAccessSpecifierPublic)
	struct FOptionalBool                          UsedWithBeamTrails;                                // 0x003C(0x0002)(Edit, BlueprintVisible, NoDestructor, NativeAccessSpecifierPublic)
	struct FOptionalBool                          UsedWithMeshParticles;                             // 0x003E(0x0002)(Edit, BlueprintVisible, NoDestructor, NativeAccessSpecifierPublic)
	struct FOptionalBool                          UsedWithStaticLighting;                            // 0x0040(0x0002)(Edit, BlueprintVisible, NoDestructor, NativeAccessSpecifierPublic)
	struct FOptionalBool                          UsedWithMorphTargets;                              // 0x0042(0x0002)(Edit, BlueprintVisible, NoDestructor, NativeAccessSpecifierPublic)
	struct FOptionalBool                          UsedWithSplineMesh;                                // 0x0044(0x0002)(Edit, BlueprintVisible, NoDestructor, NativeAccessSpecifierPublic)
	struct FOptionalBool                          UsedWithLandscape;                                 // 0x0046(0x0002)(Edit, BlueprintVisible, NoDestructor, NativeAccessSpecifierPublic)
	struct FOptionalBool                          UsedWithInstancedStaticMeshes;                     // 0x0048(0x0002)(Edit, BlueprintVisible, NoDestructor, NativeAccessSpecifierPublic)
	struct FOptionalBool                          UsedWithClothing;                                  // 0x004A(0x0002)(Edit, BlueprintVisible, NoDestructor, NativeAccessSpecifierPublic)
	struct FOptionalBool                          HasPhysMatSet;                                     // 0x004C(0x0002)(Edit, BlueprintVisible, NoDestructor, NativeAccessSpecifierPublic)
	uint8                                         Pad_4E[0x2];                                       // 0x004E(0x0002)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"AssetTraitMaterial">();
	}
	static class UAssetTraitMaterial* GetDefaultObj()
	{
		return GetDefaultObjImpl<UAssetTraitMaterial>();
	}
};
static_assert(alignof(UAssetTraitMaterial) == 0x000008, "Wrong alignment on UAssetTraitMaterial");
static_assert(sizeof(UAssetTraitMaterial) == 0x000050, "Wrong size on UAssetTraitMaterial");
static_assert(offsetof(UAssetTraitMaterial, UsedWithSkeletalMesh) == 0x000038, "Member 'UAssetTraitMaterial::UsedWithSkeletalMesh' has a wrong offset!");
static_assert(offsetof(UAssetTraitMaterial, UsedWithParticleSprites) == 0x00003A, "Member 'UAssetTraitMaterial::UsedWithParticleSprites' has a wrong offset!");
static_assert(offsetof(UAssetTraitMaterial, UsedWithBeamTrails) == 0x00003C, "Member 'UAssetTraitMaterial::UsedWithBeamTrails' has a wrong offset!");
static_assert(offsetof(UAssetTraitMaterial, UsedWithMeshParticles) == 0x00003E, "Member 'UAssetTraitMaterial::UsedWithMeshParticles' has a wrong offset!");
static_assert(offsetof(UAssetTraitMaterial, UsedWithStaticLighting) == 0x000040, "Member 'UAssetTraitMaterial::UsedWithStaticLighting' has a wrong offset!");
static_assert(offsetof(UAssetTraitMaterial, UsedWithMorphTargets) == 0x000042, "Member 'UAssetTraitMaterial::UsedWithMorphTargets' has a wrong offset!");
static_assert(offsetof(UAssetTraitMaterial, UsedWithSplineMesh) == 0x000044, "Member 'UAssetTraitMaterial::UsedWithSplineMesh' has a wrong offset!");
static_assert(offsetof(UAssetTraitMaterial, UsedWithLandscape) == 0x000046, "Member 'UAssetTraitMaterial::UsedWithLandscape' has a wrong offset!");
static_assert(offsetof(UAssetTraitMaterial, UsedWithInstancedStaticMeshes) == 0x000048, "Member 'UAssetTraitMaterial::UsedWithInstancedStaticMeshes' has a wrong offset!");
static_assert(offsetof(UAssetTraitMaterial, UsedWithClothing) == 0x00004A, "Member 'UAssetTraitMaterial::UsedWithClothing' has a wrong offset!");
static_assert(offsetof(UAssetTraitMaterial, HasPhysMatSet) == 0x00004C, "Member 'UAssetTraitMaterial::HasPhysMatSet' has a wrong offset!");

// Class GbxTest.AssetTraitMesh
// 0x0058 (0x0090 - 0x0038)
class UAssetTraitMesh : public UAssetTrait
{
public:
	struct FOptionalInt32                         LODMinCount;                                       // 0x0038(0x0008)(Edit, BlueprintVisible, NoDestructor, NativeAccessSpecifierPublic)
	struct FOptionalInt32                         LODMaxCount;                                       // 0x0040(0x0008)(Edit, BlueprintVisible, NoDestructor, NativeAccessSpecifierPublic)
	struct FOptionalInt32                         MaxTriangleCount;                                  // 0x0048(0x0008)(Edit, BlueprintVisible, NoDestructor, NativeAccessSpecifierPublic)
	struct FOptionalInt32                         MaxVertexCount;                                    // 0x0050(0x0008)(Edit, BlueprintVisible, NoDestructor, NativeAccessSpecifierPublic)
	struct FOptionalInt32                         MinTexCoordCount;                                  // 0x0058(0x0008)(Edit, BlueprintVisible, NoDestructor, NativeAccessSpecifierPublic)
	struct FOptionalInt32                         MaxTexCoordCount;                                  // 0x0060(0x0008)(Edit, BlueprintVisible, NoDestructor, NativeAccessSpecifierPublic)
	struct FOptionalInt32                         MinSectionCount;                                   // 0x0068(0x0008)(Edit, BlueprintVisible, NoDestructor, NativeAccessSpecifierPublic)
	struct FOptionalInt32                         MaxSectionCount;                                   // 0x0070(0x0008)(Edit, BlueprintVisible, NoDestructor, NativeAccessSpecifierPublic)
	struct FOptionalInt32                         MinSocketCount;                                    // 0x0078(0x0008)(Edit, BlueprintVisible, NoDestructor, NativeAccessSpecifierPublic)
	struct FOptionalInt32                         MaxSocketCount;                                    // 0x0080(0x0008)(Edit, BlueprintVisible, NoDestructor, NativeAccessSpecifierPublic)
	struct FOptionalBool                          HasSockets;                                        // 0x0088(0x0002)(Edit, BlueprintVisible, NoDestructor, NativeAccessSpecifierPublic)
	uint8                                         Pad_8A[0x6];                                       // 0x008A(0x0006)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"AssetTraitMesh">();
	}
	static class UAssetTraitMesh* GetDefaultObj()
	{
		return GetDefaultObjImpl<UAssetTraitMesh>();
	}
};
static_assert(alignof(UAssetTraitMesh) == 0x000008, "Wrong alignment on UAssetTraitMesh");
static_assert(sizeof(UAssetTraitMesh) == 0x000090, "Wrong size on UAssetTraitMesh");
static_assert(offsetof(UAssetTraitMesh, LODMinCount) == 0x000038, "Member 'UAssetTraitMesh::LODMinCount' has a wrong offset!");
static_assert(offsetof(UAssetTraitMesh, LODMaxCount) == 0x000040, "Member 'UAssetTraitMesh::LODMaxCount' has a wrong offset!");
static_assert(offsetof(UAssetTraitMesh, MaxTriangleCount) == 0x000048, "Member 'UAssetTraitMesh::MaxTriangleCount' has a wrong offset!");
static_assert(offsetof(UAssetTraitMesh, MaxVertexCount) == 0x000050, "Member 'UAssetTraitMesh::MaxVertexCount' has a wrong offset!");
static_assert(offsetof(UAssetTraitMesh, MinTexCoordCount) == 0x000058, "Member 'UAssetTraitMesh::MinTexCoordCount' has a wrong offset!");
static_assert(offsetof(UAssetTraitMesh, MaxTexCoordCount) == 0x000060, "Member 'UAssetTraitMesh::MaxTexCoordCount' has a wrong offset!");
static_assert(offsetof(UAssetTraitMesh, MinSectionCount) == 0x000068, "Member 'UAssetTraitMesh::MinSectionCount' has a wrong offset!");
static_assert(offsetof(UAssetTraitMesh, MaxSectionCount) == 0x000070, "Member 'UAssetTraitMesh::MaxSectionCount' has a wrong offset!");
static_assert(offsetof(UAssetTraitMesh, MinSocketCount) == 0x000078, "Member 'UAssetTraitMesh::MinSocketCount' has a wrong offset!");
static_assert(offsetof(UAssetTraitMesh, MaxSocketCount) == 0x000080, "Member 'UAssetTraitMesh::MaxSocketCount' has a wrong offset!");
static_assert(offsetof(UAssetTraitMesh, HasSockets) == 0x000088, "Member 'UAssetTraitMesh::HasSockets' has a wrong offset!");

// Class GbxTest.AssetTraitParticleSystem
// 0x00C8 (0x0100 - 0x0038)
class UAssetTraitParticleSystem final : public UAssetTrait
{
public:
	struct FOptionalInt32                         MinEmitterCount;                                   // 0x0038(0x0008)(Edit, BlueprintVisible, NoDestructor, NativeAccessSpecifierPublic)
	struct FOptionalInt32                         MaxEmitterCount;                                   // 0x0040(0x0008)(Edit, BlueprintVisible, NoDestructor, NativeAccessSpecifierPublic)
	struct FOptionalInt32                         MinModuleCount;                                    // 0x0048(0x0008)(Edit, BlueprintVisible, NoDestructor, NativeAccessSpecifierPublic)
	struct FOptionalInt32                         MaxModuleCount;                                    // 0x0050(0x0008)(Edit, BlueprintVisible, NoDestructor, NativeAccessSpecifierPublic)
	struct FOptionalInt32                         MinLODCount;                                       // 0x0058(0x0008)(Deprecated, NoDestructor, NativeAccessSpecifierPublic)
	struct FOptionalInt32                         MaxLODCount;                                       // 0x0060(0x0008)(Deprecated, NoDestructor, NativeAccessSpecifierPublic)
	struct FOptionalFloat                         MinLODDistanceCheckTime;                           // 0x0068(0x0008)(Deprecated, NoDestructor, NativeAccessSpecifierPublic)
	struct FOptionalFloat                         MaxLODDistanceCheckTime;                           // 0x0070(0x0008)(Deprecated, NoDestructor, NativeAccessSpecifierPublic)
	struct FOptionalFloat                         MinUpdateTime;                                     // 0x0078(0x0008)(Edit, BlueprintVisible, NoDestructor, NativeAccessSpecifierPublic)
	struct FOptionalFloat                         MaxUpdateTime;                                     // 0x0080(0x0008)(Edit, BlueprintVisible, NoDestructor, NativeAccessSpecifierPublic)
	struct FOptionalFloat                         MaxWarmupTime;                                     // 0x0088(0x0008)(Edit, BlueprintVisible, NoDestructor, NativeAccessSpecifierPublic)
	struct FOptionalInt32                         MinDataAnimTrailCount;                             // 0x0090(0x0008)(Edit, BlueprintVisible, NoDestructor, NativeAccessSpecifierPublic)
	struct FOptionalInt32                         MaxDataAnimTrailCount;                             // 0x0098(0x0008)(Edit, BlueprintVisible, NoDestructor, NativeAccessSpecifierPublic)
	struct FOptionalInt32                         MinDataGPUSpritesCount;                            // 0x00A0(0x0008)(Edit, BlueprintVisible, NoDestructor, NativeAccessSpecifierPublic)
	struct FOptionalInt32                         MaxDataGPUSpritesCount;                            // 0x00A8(0x0008)(Edit, BlueprintVisible, NoDestructor, NativeAccessSpecifierPublic)
	struct FOptionalInt32                         MinDataMeshCount;                                  // 0x00B0(0x0008)(Edit, BlueprintVisible, NoDestructor, NativeAccessSpecifierPublic)
	struct FOptionalInt32                         MaxDataMeshCount;                                  // 0x00B8(0x0008)(Edit, BlueprintVisible, NoDestructor, NativeAccessSpecifierPublic)
	struct FOptionalInt32                         MinDataRibbonOrBeamCount;                          // 0x00C0(0x0008)(Edit, BlueprintVisible, NoDestructor, NativeAccessSpecifierPublic)
	struct FOptionalInt32                         MaxDataRibbonOrBeamCount;                          // 0x00C8(0x0008)(Edit, BlueprintVisible, NoDestructor, NativeAccessSpecifierPublic)
	struct FOptionalFloat                         MaxTemplateCost;                                   // 0x00D0(0x0008)(Edit, BlueprintVisible, NoDestructor, NativeAccessSpecifierPublic)
	struct FOptionalBool                          bHasDataAnimTrail;                                 // 0x00D8(0x0002)(Edit, BlueprintVisible, NoDestructor, NativeAccessSpecifierPublic)
	struct FOptionalBool                          bHasDataGPUSprites;                                // 0x00DA(0x0002)(Edit, BlueprintVisible, NoDestructor, NativeAccessSpecifierPublic)
	struct FOptionalBool                          bHasDataMesh;                                      // 0x00DC(0x0002)(Edit, BlueprintVisible, NoDestructor, NativeAccessSpecifierPublic)
	struct FOptionalBool                          bHasDataRibbonOrBeam;                              // 0x00DE(0x0002)(Edit, BlueprintVisible, NoDestructor, NativeAccessSpecifierPublic)
	struct FOptionalInt32                         MaxDrawCount;                                      // 0x00E0(0x0008)(Edit, BlueprintVisible, NoDestructor, NativeAccessSpecifierPublic)
	struct FOptionalBool                          bKillOnCompletedNotSet;                            // 0x00E8(0x0002)(Edit, BlueprintVisible, NoDestructor, NativeAccessSpecifierPublic)
	uint8                                         Pad_EA[0x2];                                       // 0x00EA(0x0002)(Fixing Size After Last Property [ Dumper-7 ])
	struct FOptionalFloat                         MinUnitScalar;                                     // 0x00EC(0x0008)(Edit, BlueprintVisible, NoDestructor, NativeAccessSpecifierPublic)
	struct FOptionalBool                          bUseInverseSquaredFalloffSet;                      // 0x00F4(0x0002)(Edit, BlueprintVisible, NoDestructor, NativeAccessSpecifierPublic)
	struct FOptionalBool                          bAllowInfiniteLifetimes;                           // 0x00F6(0x0002)(Edit, BlueprintVisible, NoDestructor, NativeAccessSpecifierPublic)
	struct FOptionalFloat                         MaxLifetime;                                       // 0x00F8(0x0008)(Edit, BlueprintVisible, NoDestructor, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"AssetTraitParticleSystem">();
	}
	static class UAssetTraitParticleSystem* GetDefaultObj()
	{
		return GetDefaultObjImpl<UAssetTraitParticleSystem>();
	}
};
static_assert(alignof(UAssetTraitParticleSystem) == 0x000008, "Wrong alignment on UAssetTraitParticleSystem");
static_assert(sizeof(UAssetTraitParticleSystem) == 0x000100, "Wrong size on UAssetTraitParticleSystem");
static_assert(offsetof(UAssetTraitParticleSystem, MinEmitterCount) == 0x000038, "Member 'UAssetTraitParticleSystem::MinEmitterCount' has a wrong offset!");
static_assert(offsetof(UAssetTraitParticleSystem, MaxEmitterCount) == 0x000040, "Member 'UAssetTraitParticleSystem::MaxEmitterCount' has a wrong offset!");
static_assert(offsetof(UAssetTraitParticleSystem, MinModuleCount) == 0x000048, "Member 'UAssetTraitParticleSystem::MinModuleCount' has a wrong offset!");
static_assert(offsetof(UAssetTraitParticleSystem, MaxModuleCount) == 0x000050, "Member 'UAssetTraitParticleSystem::MaxModuleCount' has a wrong offset!");
static_assert(offsetof(UAssetTraitParticleSystem, MinLODCount) == 0x000058, "Member 'UAssetTraitParticleSystem::MinLODCount' has a wrong offset!");
static_assert(offsetof(UAssetTraitParticleSystem, MaxLODCount) == 0x000060, "Member 'UAssetTraitParticleSystem::MaxLODCount' has a wrong offset!");
static_assert(offsetof(UAssetTraitParticleSystem, MinLODDistanceCheckTime) == 0x000068, "Member 'UAssetTraitParticleSystem::MinLODDistanceCheckTime' has a wrong offset!");
static_assert(offsetof(UAssetTraitParticleSystem, MaxLODDistanceCheckTime) == 0x000070, "Member 'UAssetTraitParticleSystem::MaxLODDistanceCheckTime' has a wrong offset!");
static_assert(offsetof(UAssetTraitParticleSystem, MinUpdateTime) == 0x000078, "Member 'UAssetTraitParticleSystem::MinUpdateTime' has a wrong offset!");
static_assert(offsetof(UAssetTraitParticleSystem, MaxUpdateTime) == 0x000080, "Member 'UAssetTraitParticleSystem::MaxUpdateTime' has a wrong offset!");
static_assert(offsetof(UAssetTraitParticleSystem, MaxWarmupTime) == 0x000088, "Member 'UAssetTraitParticleSystem::MaxWarmupTime' has a wrong offset!");
static_assert(offsetof(UAssetTraitParticleSystem, MinDataAnimTrailCount) == 0x000090, "Member 'UAssetTraitParticleSystem::MinDataAnimTrailCount' has a wrong offset!");
static_assert(offsetof(UAssetTraitParticleSystem, MaxDataAnimTrailCount) == 0x000098, "Member 'UAssetTraitParticleSystem::MaxDataAnimTrailCount' has a wrong offset!");
static_assert(offsetof(UAssetTraitParticleSystem, MinDataGPUSpritesCount) == 0x0000A0, "Member 'UAssetTraitParticleSystem::MinDataGPUSpritesCount' has a wrong offset!");
static_assert(offsetof(UAssetTraitParticleSystem, MaxDataGPUSpritesCount) == 0x0000A8, "Member 'UAssetTraitParticleSystem::MaxDataGPUSpritesCount' has a wrong offset!");
static_assert(offsetof(UAssetTraitParticleSystem, MinDataMeshCount) == 0x0000B0, "Member 'UAssetTraitParticleSystem::MinDataMeshCount' has a wrong offset!");
static_assert(offsetof(UAssetTraitParticleSystem, MaxDataMeshCount) == 0x0000B8, "Member 'UAssetTraitParticleSystem::MaxDataMeshCount' has a wrong offset!");
static_assert(offsetof(UAssetTraitParticleSystem, MinDataRibbonOrBeamCount) == 0x0000C0, "Member 'UAssetTraitParticleSystem::MinDataRibbonOrBeamCount' has a wrong offset!");
static_assert(offsetof(UAssetTraitParticleSystem, MaxDataRibbonOrBeamCount) == 0x0000C8, "Member 'UAssetTraitParticleSystem::MaxDataRibbonOrBeamCount' has a wrong offset!");
static_assert(offsetof(UAssetTraitParticleSystem, MaxTemplateCost) == 0x0000D0, "Member 'UAssetTraitParticleSystem::MaxTemplateCost' has a wrong offset!");
static_assert(offsetof(UAssetTraitParticleSystem, bHasDataAnimTrail) == 0x0000D8, "Member 'UAssetTraitParticleSystem::bHasDataAnimTrail' has a wrong offset!");
static_assert(offsetof(UAssetTraitParticleSystem, bHasDataGPUSprites) == 0x0000DA, "Member 'UAssetTraitParticleSystem::bHasDataGPUSprites' has a wrong offset!");
static_assert(offsetof(UAssetTraitParticleSystem, bHasDataMesh) == 0x0000DC, "Member 'UAssetTraitParticleSystem::bHasDataMesh' has a wrong offset!");
static_assert(offsetof(UAssetTraitParticleSystem, bHasDataRibbonOrBeam) == 0x0000DE, "Member 'UAssetTraitParticleSystem::bHasDataRibbonOrBeam' has a wrong offset!");
static_assert(offsetof(UAssetTraitParticleSystem, MaxDrawCount) == 0x0000E0, "Member 'UAssetTraitParticleSystem::MaxDrawCount' has a wrong offset!");
static_assert(offsetof(UAssetTraitParticleSystem, bKillOnCompletedNotSet) == 0x0000E8, "Member 'UAssetTraitParticleSystem::bKillOnCompletedNotSet' has a wrong offset!");
static_assert(offsetof(UAssetTraitParticleSystem, MinUnitScalar) == 0x0000EC, "Member 'UAssetTraitParticleSystem::MinUnitScalar' has a wrong offset!");
static_assert(offsetof(UAssetTraitParticleSystem, bUseInverseSquaredFalloffSet) == 0x0000F4, "Member 'UAssetTraitParticleSystem::bUseInverseSquaredFalloffSet' has a wrong offset!");
static_assert(offsetof(UAssetTraitParticleSystem, bAllowInfiniteLifetimes) == 0x0000F6, "Member 'UAssetTraitParticleSystem::bAllowInfiniteLifetimes' has a wrong offset!");
static_assert(offsetof(UAssetTraitParticleSystem, MaxLifetime) == 0x0000F8, "Member 'UAssetTraitParticleSystem::MaxLifetime' has a wrong offset!");

// Class GbxTest.AssetTraitSkeletalMesh
// 0x0000 (0x0090 - 0x0090)
class UAssetTraitSkeletalMesh final : public UAssetTraitMesh
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"AssetTraitSkeletalMesh">();
	}
	static class UAssetTraitSkeletalMesh* GetDefaultObj()
	{
		return GetDefaultObjImpl<UAssetTraitSkeletalMesh>();
	}
};
static_assert(alignof(UAssetTraitSkeletalMesh) == 0x000008, "Wrong alignment on UAssetTraitSkeletalMesh");
static_assert(sizeof(UAssetTraitSkeletalMesh) == 0x000090, "Wrong size on UAssetTraitSkeletalMesh");

// Class GbxTest.AssetTraitStaticMesh
// 0x0048 (0x00D8 - 0x0090)
class UAssetTraitStaticMesh final : public UAssetTraitMesh
{
public:
	struct FOptionalInt32                         MinPrimitiveCount;                                 // 0x0090(0x0008)(Edit, BlueprintVisible, NoDestructor, NativeAccessSpecifierPublic)
	struct FOptionalInt32                         MaxPrimitiveCount;                                 // 0x0098(0x0008)(Edit, BlueprintVisible, NoDestructor, NativeAccessSpecifierPublic)
	struct FOptionalInt32                         MinLightmapResolution;                             // 0x00A0(0x0008)(Edit, BlueprintVisible, NoDestructor, NativeAccessSpecifierPublic)
	struct FOptionalInt32                         MaxLightmapResolution;                             // 0x00A8(0x0008)(Edit, BlueprintVisible, NoDestructor, NativeAccessSpecifierPublic)
	struct FOptionalInt32                         MinLightMapIndex;                                  // 0x00B0(0x0008)(Edit, BlueprintVisible, NoDestructor, NativeAccessSpecifierPublic)
	struct FOptionalInt32                         MaxLightMapIndex;                                  // 0x00B8(0x0008)(Edit, BlueprintVisible, NoDestructor, NativeAccessSpecifierPublic)
	struct FOptionalLODGroup                      LODGroup;                                          // 0x00C0(0x0010)(Edit, BlueprintVisible, NoDestructor, NativeAccessSpecifierPublic)
	struct FOptionalBool                          CastShadow;                                        // 0x00D0(0x0002)(Edit, BlueprintVisible, NoDestructor, NativeAccessSpecifierPublic)
	struct FOptionalBool                          EnableCollision;                                   // 0x00D2(0x0002)(Edit, BlueprintVisible, NoDestructor, NativeAccessSpecifierPublic)
	uint8                                         Pad_D4[0x4];                                       // 0x00D4(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"AssetTraitStaticMesh">();
	}
	static class UAssetTraitStaticMesh* GetDefaultObj()
	{
		return GetDefaultObjImpl<UAssetTraitStaticMesh>();
	}
};
static_assert(alignof(UAssetTraitStaticMesh) == 0x000008, "Wrong alignment on UAssetTraitStaticMesh");
static_assert(sizeof(UAssetTraitStaticMesh) == 0x0000D8, "Wrong size on UAssetTraitStaticMesh");
static_assert(offsetof(UAssetTraitStaticMesh, MinPrimitiveCount) == 0x000090, "Member 'UAssetTraitStaticMesh::MinPrimitiveCount' has a wrong offset!");
static_assert(offsetof(UAssetTraitStaticMesh, MaxPrimitiveCount) == 0x000098, "Member 'UAssetTraitStaticMesh::MaxPrimitiveCount' has a wrong offset!");
static_assert(offsetof(UAssetTraitStaticMesh, MinLightmapResolution) == 0x0000A0, "Member 'UAssetTraitStaticMesh::MinLightmapResolution' has a wrong offset!");
static_assert(offsetof(UAssetTraitStaticMesh, MaxLightmapResolution) == 0x0000A8, "Member 'UAssetTraitStaticMesh::MaxLightmapResolution' has a wrong offset!");
static_assert(offsetof(UAssetTraitStaticMesh, MinLightMapIndex) == 0x0000B0, "Member 'UAssetTraitStaticMesh::MinLightMapIndex' has a wrong offset!");
static_assert(offsetof(UAssetTraitStaticMesh, MaxLightMapIndex) == 0x0000B8, "Member 'UAssetTraitStaticMesh::MaxLightMapIndex' has a wrong offset!");
static_assert(offsetof(UAssetTraitStaticMesh, LODGroup) == 0x0000C0, "Member 'UAssetTraitStaticMesh::LODGroup' has a wrong offset!");
static_assert(offsetof(UAssetTraitStaticMesh, CastShadow) == 0x0000D0, "Member 'UAssetTraitStaticMesh::CastShadow' has a wrong offset!");
static_assert(offsetof(UAssetTraitStaticMesh, EnableCollision) == 0x0000D2, "Member 'UAssetTraitStaticMesh::EnableCollision' has a wrong offset!");

// Class GbxTest.AssetTraitTexture
// 0x0038 (0x0070 - 0x0038)
class UAssetTraitTexture final : public UAssetTrait
{
public:
	struct FOptionalTextureCompressionMethod      CompressionMethod;                                 // 0x0038(0x0010)(Edit, BlueprintVisible, NoDestructor, NativeAccessSpecifierPublic)
	struct FOptionalTextureLODGroup               LODGroup;                                          // 0x0048(0x0010)(Edit, BlueprintVisible, NoDestructor, NativeAccessSpecifierPublic)
	struct FOptionalInt32                         MinLODBias;                                        // 0x0058(0x0008)(Edit, BlueprintVisible, NoDestructor, NativeAccessSpecifierPublic)
	struct FOptionalInt32                         MaxLODBias;                                        // 0x0060(0x0008)(Edit, BlueprintVisible, NoDestructor, NativeAccessSpecifierPublic)
	struct FOptionalBool                          HasAlpha;                                          // 0x0068(0x0002)(Edit, BlueprintVisible, NoDestructor, NativeAccessSpecifierPublic)
	struct FOptionalBool                          HassRGB;                                           // 0x006A(0x0002)(Edit, BlueprintVisible, NoDestructor, NativeAccessSpecifierPublic)
	uint8                                         Pad_6C[0x4];                                       // 0x006C(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"AssetTraitTexture">();
	}
	static class UAssetTraitTexture* GetDefaultObj()
	{
		return GetDefaultObjImpl<UAssetTraitTexture>();
	}
};
static_assert(alignof(UAssetTraitTexture) == 0x000008, "Wrong alignment on UAssetTraitTexture");
static_assert(sizeof(UAssetTraitTexture) == 0x000070, "Wrong size on UAssetTraitTexture");
static_assert(offsetof(UAssetTraitTexture, CompressionMethod) == 0x000038, "Member 'UAssetTraitTexture::CompressionMethod' has a wrong offset!");
static_assert(offsetof(UAssetTraitTexture, LODGroup) == 0x000048, "Member 'UAssetTraitTexture::LODGroup' has a wrong offset!");
static_assert(offsetof(UAssetTraitTexture, MinLODBias) == 0x000058, "Member 'UAssetTraitTexture::MinLODBias' has a wrong offset!");
static_assert(offsetof(UAssetTraitTexture, MaxLODBias) == 0x000060, "Member 'UAssetTraitTexture::MaxLODBias' has a wrong offset!");
static_assert(offsetof(UAssetTraitTexture, HasAlpha) == 0x000068, "Member 'UAssetTraitTexture::HasAlpha' has a wrong offset!");
static_assert(offsetof(UAssetTraitTexture, HassRGB) == 0x00006A, "Member 'UAssetTraitTexture::HassRGB' has a wrong offset!");

// Class GbxTest.AutomationMenuHelper
// 0x0010 (0x0038 - 0x0028)
class UAutomationMenuHelper final : public UObject
{
public:
	uint8                                         Pad_28[0x10];                                      // 0x0028(0x0010)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UAutomationMenuHelper* CreateAutomationMenuHelper(class AGbxPlayerController* PlayerController, const bool SimulateAllInputs);

	void ActuateFocus(const EAutomationUIAction Action);
	void BackOut();
	int32 CurrentDepth();
	struct FAutomationMenuFocusInfo FocusInfo();
	class FName FocusName();
	bool HasOpenMenu();
	class FName MenuName();
	void NextFocus(const EAutomationUIDirection Direction);
	void NextPage();
	int32 NumPages();
	class FName PageName();
	void PrevPage();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"AutomationMenuHelper">();
	}
	static class UAutomationMenuHelper* GetDefaultObj()
	{
		return GetDefaultObjImpl<UAutomationMenuHelper>();
	}
};
static_assert(alignof(UAutomationMenuHelper) == 0x000008, "Wrong alignment on UAutomationMenuHelper");
static_assert(sizeof(UAutomationMenuHelper) == 0x000038, "Wrong size on UAutomationMenuHelper");

// Class GbxTest.AutomationUILibrary
// 0x0000 (0x0028 - 0x0028)
class UAutomationUILibrary final : public UBlueprintFunctionLibrary
{
public:
	static void ForceDisableTutorials(const bool ForceDisable);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"AutomationUILibrary">();
	}
	static class UAutomationUILibrary* GetDefaultObj()
	{
		return GetDefaultObjImpl<UAutomationUILibrary>();
	}
};
static_assert(alignof(UAutomationUILibrary) == 0x000008, "Wrong alignment on UAutomationUILibrary");
static_assert(sizeof(UAutomationUILibrary) == 0x000028, "Wrong size on UAutomationUILibrary");

// Class GbxTest.GbxTestContentAuditCommandlet
// 0x0000 (0x0080 - 0x0080)
class UGbxTestContentAuditCommandlet final : public UCommandlet
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"GbxTestContentAuditCommandlet">();
	}
	static class UGbxTestContentAuditCommandlet* GetDefaultObj()
	{
		return GetDefaultObjImpl<UGbxTestContentAuditCommandlet>();
	}
};
static_assert(alignof(UGbxTestContentAuditCommandlet) == 0x000008, "Wrong alignment on UGbxTestContentAuditCommandlet");
static_assert(sizeof(UGbxTestContentAuditCommandlet) == 0x000080, "Wrong size on UGbxTestContentAuditCommandlet");

// Class GbxTest.GbxTestJiraCommandlet
// 0x0000 (0x0080 - 0x0080)
class UGbxTestJiraCommandlet final : public UCommandlet
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"GbxTestJiraCommandlet">();
	}
	static class UGbxTestJiraCommandlet* GetDefaultObj()
	{
		return GetDefaultObjImpl<UGbxTestJiraCommandlet>();
	}
};
static_assert(alignof(UGbxTestJiraCommandlet) == 0x000008, "Wrong alignment on UGbxTestJiraCommandlet");
static_assert(sizeof(UGbxTestJiraCommandlet) == 0x000080, "Wrong size on UGbxTestJiraCommandlet");

// Class GbxTest.GbxTestContentAuditSettings
// 0x0010 (0x0038 - 0x0028)
class UGbxTestContentAuditSettings final : public UObject
{
public:
	TArray<class FString>                         WhitelistDirectories;                              // 0x0028(0x0010)(Edit, ZeroConstructor, Config, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"GbxTestContentAuditSettings">();
	}
	static class UGbxTestContentAuditSettings* GetDefaultObj()
	{
		return GetDefaultObjImpl<UGbxTestContentAuditSettings>();
	}
};
static_assert(alignof(UGbxTestContentAuditSettings) == 0x000008, "Wrong alignment on UGbxTestContentAuditSettings");
static_assert(sizeof(UGbxTestContentAuditSettings) == 0x000038, "Wrong size on UGbxTestContentAuditSettings");
static_assert(offsetof(UGbxTestContentAuditSettings, WhitelistDirectories) == 0x000028, "Member 'UGbxTestContentAuditSettings::WhitelistDirectories' has a wrong offset!");

// Class GbxTest.GbxTestParticleMaterialAuditCommandlet
// 0x0000 (0x0080 - 0x0080)
class UGbxTestParticleMaterialAuditCommandlet final : public UCommandlet
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"GbxTestParticleMaterialAuditCommandlet">();
	}
	static class UGbxTestParticleMaterialAuditCommandlet* GetDefaultObj()
	{
		return GetDefaultObjImpl<UGbxTestParticleMaterialAuditCommandlet>();
	}
};
static_assert(alignof(UGbxTestParticleMaterialAuditCommandlet) == 0x000008, "Wrong alignment on UGbxTestParticleMaterialAuditCommandlet");
static_assert(sizeof(UGbxTestParticleMaterialAuditCommandlet) == 0x000080, "Wrong size on UGbxTestParticleMaterialAuditCommandlet");

// Class GbxTest.GbxTestSettings
// 0x0010 (0x0038 - 0x0028)
class UGbxTestSettings final : public UObject
{
public:
	TArray<class FString>                         TestContentPaths;                                  // 0x0028(0x0010)(Edit, ZeroConstructor, Config, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"GbxTestSettings">();
	}
	static class UGbxTestSettings* GetDefaultObj()
	{
		return GetDefaultObjImpl<UGbxTestSettings>();
	}
};
static_assert(alignof(UGbxTestSettings) == 0x000008, "Wrong alignment on UGbxTestSettings");
static_assert(sizeof(UGbxTestSettings) == 0x000038, "Wrong size on UGbxTestSettings");
static_assert(offsetof(UGbxTestSettings, TestContentPaths) == 0x000028, "Member 'UGbxTestSettings::TestContentPaths' has a wrong offset!");

// Class GbxTest.PerfMapCapture
// 0x0000 (0x0028 - 0x0028)
class UPerfMapCapture final : public UObject
{
public:
	static bool SavePerfMapCaptures(class UObject* World, const class FString& Path, float Density, bool bLighting, bool bSpecular, float Gamma, int32 Width, int32 Height, float VolumeX, float VolumeY, float VolumeZ, const class FString& OutputPattern);
	static void SavePerfMapCapturesFromConfiguration(class UWorld* World, const class FString& Path, const struct FMapParameters& Configuration, const struct FLatentActionInfo& LatentInfo);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"PerfMapCapture">();
	}
	static class UPerfMapCapture* GetDefaultObj()
	{
		return GetDefaultObjImpl<UPerfMapCapture>();
	}
};
static_assert(alignof(UPerfMapCapture) == 0x000008, "Wrong alignment on UPerfMapCapture");
static_assert(sizeof(UPerfMapCapture) == 0x000028, "Wrong size on UPerfMapCapture");

// Class GbxTest.PerformanceSnapshotCollector
// 0x0010 (0x0038 - 0x0028)
class UPerformanceSnapshotCollector final : public UBlueprintFunctionLibrary
{
public:
	uint8                                         Pad_28[0x10];                                      // 0x0028(0x0010)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UPerformanceSnapshotCollector* CreatePerformanceSnapshotCollector(const class FString& StatSection, ESnapshotExecOutput* ExecOut);

	void CollectProbeSnapshot(class UObject* WorldContextObject, const class FString& ReportContext, const struct FGbxProbeId& ProbeId, const class FString& Test, const TArray<struct FGbxProbeExtraData>& ExtraDataArray, const struct FLatentActionInfo& LatentInfo);
	void CollectSnapshot(class UObject* WorldContextObject, const class FString& ReportContext, const struct FLatentActionInfo& LatentInfo);
	void ResetSnapshotProviders();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"PerformanceSnapshotCollector">();
	}
	static class UPerformanceSnapshotCollector* GetDefaultObj()
	{
		return GetDefaultObjImpl<UPerformanceSnapshotCollector>();
	}
};
static_assert(alignof(UPerformanceSnapshotCollector) == 0x000008, "Wrong alignment on UPerformanceSnapshotCollector");
static_assert(sizeof(UPerformanceSnapshotCollector) == 0x000038, "Wrong size on UPerformanceSnapshotCollector");

// Class GbxTest.MatcherFunctionality
// 0x0080 (0x00A8 - 0x0028)
class UMatcherFunctionality final : public UObject
{
public:
	uint8                                         Pad_28[0x80];                                      // 0x0028(0x0080)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	bool Empty();
	class FString GetAtIndex(int32 Index_0);
	int32 GetLength();
	class FString GetMatch(int32 Index_0);
	int32 GetPosition(int32 Start);
	class FString GetPrefix();
	class FString GetSuffix();
	bool Ready();
	int32 Size();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"MatcherFunctionality">();
	}
	static class UMatcherFunctionality* GetDefaultObj()
	{
		return GetDefaultObjImpl<UMatcherFunctionality>();
	}
};
static_assert(alignof(UMatcherFunctionality) == 0x000008, "Wrong alignment on UMatcherFunctionality");
static_assert(sizeof(UMatcherFunctionality) == 0x0000A8, "Wrong size on UMatcherFunctionality");

// Class GbxTest.RegexFunctionality
// 0x0028 (0x0050 - 0x0028)
class URegexFunctionality final : public UObject
{
public:
	struct FRegex                                 Regex;                                             // 0x0028(0x0028)(Edit, BlueprintVisible, NativeAccessSpecifierPublic)

public:
	static void Assign(const struct FRegex& Regex_0, const class FString& Pattern);
	static void Assign2(const struct FRegex& Regex_0, const class FString& Pattern, ESyntaxOption Flags_0);
	static void FindAll(const struct FRegex& Regex_0, const class FString& String, TArray<class FString>* Return);
	static bool RegexMatch(const struct FRegex& Regex_0, const class FString& Input);
	static bool RegexMatch2(const struct FRegex& Regex_0, class UMatcherFunctionality* Matcher, const class FString& Input);
	static class FString RegexRepleace(const struct FRegex& Regex_0, const class FString& Input, const class FString& Repleacement);
	static bool RegexSearch(const struct FRegex& Regex_0, class UMatcherFunctionality* Matcher, const class FString& Input);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"RegexFunctionality">();
	}
	static class URegexFunctionality* GetDefaultObj()
	{
		return GetDefaultObjImpl<URegexFunctionality>();
	}
};
static_assert(alignof(URegexFunctionality) == 0x000008, "Wrong alignment on URegexFunctionality");
static_assert(sizeof(URegexFunctionality) == 0x000050, "Wrong size on URegexFunctionality");
static_assert(offsetof(URegexFunctionality, Regex) == 0x000028, "Member 'URegexFunctionality::Regex' has a wrong offset!");

// Class GbxTest.GbxTestHierarchicalCommands
// 0x0010 (0x0040 - 0x0030)
class UGbxTestHierarchicalCommands final : public UDataAsset
{
public:
	TArray<struct FGbxTestHierarchicalCommandL1>  Commands;                                          // 0x0030(0x0010)(Edit, BlueprintVisible, ZeroConstructor, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"GbxTestHierarchicalCommands">();
	}
	static class UGbxTestHierarchicalCommands* GetDefaultObj()
	{
		return GetDefaultObjImpl<UGbxTestHierarchicalCommands>();
	}
};
static_assert(alignof(UGbxTestHierarchicalCommands) == 0x000008, "Wrong alignment on UGbxTestHierarchicalCommands");
static_assert(sizeof(UGbxTestHierarchicalCommands) == 0x000040, "Wrong size on UGbxTestHierarchicalCommands");
static_assert(offsetof(UGbxTestHierarchicalCommands, Commands) == 0x000030, "Member 'UGbxTestHierarchicalCommands::Commands' has a wrong offset!");

// Class GbxTest.TestLibrary
// 0x0000 (0x0028 - 0x0028)
class UTestLibrary final : public UBlueprintFunctionLibrary
{
public:
	static void AddArrayToCollection(const class FString& CollectionName, TArray<class FString>& ObjectNames);
	static void AddItemToCollection(const class FString& CollectionName, const class FString& ObjectName);
	static bool CollectionExists(const class FString& CollectionName);
	static bool CollectionExistsEx(const class FString& CollectionName, ECollectionType CollectionType);
	static bool ContainsObjectTag(TArray<struct FObjectTag>& ObjectTags, const class FString& Category, const class FString& Name_0, bool bExactCategory, bool bCaseSensitiveCategory, bool bExactName, bool bCaseSensitiveName);
	static bool ContainsSubPath(const class FString& Path, const class FString& SubPath);
	static class FString CreateLocalCollection(const class FString& CollectionName, const class FString& ParentName);
	static void DiscoverAssets(TArray<class FString>* PathNames, TArray<class FString>* PrettyNames, const TArray<class FString>& Directories, const TArray<class UClass*>& Classes, const TArray<class UClass*>& ExcludeRecursiveClasses, bool bRecursiveDirectories, bool bRecursiveClasses);
	static void FilterDiscoveredAssets(TArray<class FString>& InPathNames, TArray<class FString>& InPrettyNames, TArray<class FString>* OutPathNames, TArray<class FString>* OutPrettyNames, const class FString& AssetNamePrefix, const class FString& AssetNamePostfix, const class FString& AssetNameContains, const class FString& AssetPathContains);
	static void GetAssetName(const class FString& AssetPath, class FString* AssetName);
	static void GetAssetPath(class UObject* Asset, class FString* AssetPath);
	static void GetObjectTags(TArray<struct FObjectTag>* ObjectTags, class UObject* Asset);
	static void GetReferencedBlueprintClasses(class UObject* Object, class UClass* Class_0, TArray<class UClass*>* Classes);
	static void GetTestDriversFromStrings(const TArray<class FString>& Strings, TArray<TSubclassOf<class AActor>>* TestDrivers, class FString* UndiscoveredItems);
	static class UWorld* GetWorldForActor(class AActor* Actor);
	static bool IsAssetInCollection(const class FString& CollectionName, const class FString& ObjectName);
	static bool IsAssetInCollectionEx(const class FString& CollectionName, ECollectionType CollectionType, const class FString& ObjectName);
	static bool IsEditorSession();
	static void LoadAsset(const class FString& Path, class UObject** Object);
	static void LoadBlueprintAsset(const class FString& Path, class UObject** Object);
	static void MoveArrayCollection(const class FString& FromCollection, const class FString& ToCollection, TArray<class FString>& ObjectNames);
	static void MoveItemCollection(const class FString& FromCollection, const class FString& ToCollection, const class FString& ObjectName);
	static bool ReadFromIni(const class FString& Section, const class FString& Key, TArray<class FString>* Values);
	static void RemoveArrayFromCollection(const class FString& CollectionName, TArray<class FString>& ObjectNames);
	static void RemoveItemFromCollection(const class FString& CollectionName, const class FString& ObjectName);
	static void SimulateInputAxis(const class APlayerController*& PlayerController, const struct FKey& Key, float Delta, float InterpTime, const struct FLatentActionInfo& LatentInfo);
	static void SimulateInputKey(const class APlayerController*& PlayerController, const struct FKey& Key, EInputEvent EVENTTYPE, float AmountDepressed);
	static TArray<float> SortFloats(const TArray<float>& Values, bool Descending);
	static TArray<int32> SortIntegers(const TArray<int32>& Values, bool Descending);
	static TArray<class UObject*> SortObjectsByName(const TArray<class UObject*>& Values, bool Descending);
	static TArray<class FString> SortStrings(const TArray<class FString>& Values, bool Descending);
	static void TakeScreenshot(const class FString& CustomFilename, const struct FVector2D& OverrideResolution, const bool ShowUI, const bool AddUniqueSuffix);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"TestLibrary">();
	}
	static class UTestLibrary* GetDefaultObj()
	{
		return GetDefaultObjImpl<UTestLibrary>();
	}
};
static_assert(alignof(UTestLibrary) == 0x000008, "Wrong alignment on UTestLibrary");
static_assert(sizeof(UTestLibrary) == 0x000028, "Wrong size on UTestLibrary");

// Class GbxTest.TestLibraryContent
// 0x0000 (0x0028 - 0x0028)
class UTestLibraryContent final : public UBlueprintFunctionLibrary
{
public:
	static TArray<class FString> ContentAuditSingleObject(class UObject* Asset);
	static void GetAllPersistentGameMaps(TArray<class FString>* OutMapNames, bool ShortNamesOnly);
	static void GetTestInfoMaterial(const class UMaterial* Asset, struct FTestInfoMaterial* Info);
	static void GetTestInfoParticleEmitter(const class UParticleSystem* Asset, const int32 EmitterIndex, struct FTestInfoParticleEmitter* Info);
	static void GetTestInfoParticleSystem(const class UParticleSystem* Asset, struct FTestInfoParticleSystem* Info);
	static void GetTestInfoSkeletalMesh(const class USkeletalMesh* Asset, struct FTestInfoMeshLODSummary* LODSummary, struct FTestInfoMesh* Mesh, struct FTestInfoSkeletalMesh* SkeletalMesh);
	static void GetTestInfoSkeletalMeshLOD(const class USkeletalMesh* Asset, const int32 LODIndex, struct FTestInfoMeshLOD* Info);
	static void GetTestInfoStaticMesh(const class UStaticMesh* Asset, struct FTestInfoMeshLODSummary* LODSummary, struct FTestInfoMesh* Mesh, struct FTestInfoStaticMesh* StaticMesh);
	static void GetTestInfoStaticMeshLOD(const class UStaticMesh* Asset, const int32 LODIndex, struct FTestInfoMeshLOD* Info);
	static void GetTestInfoTexture(const class UTexture* Asset, struct FTestInfoTexture* Info);
	static class UMaterial* LoadAssetMaterial(const class FString& ObjectPath);
	static class UParticleSystem* LoadAssetParticleSystem(const class FString& ObjectPath);
	static class USkeletalMesh* LoadAssetSkeletalMesh(const class FString& ObjectPath);
	static class UStaticMesh* LoadAssetStaticMesh(const class FString& ObjectPath);
	static class UTexture* LoadAssetTexture(const class FString& ObjectPath);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"TestLibraryContent">();
	}
	static class UTestLibraryContent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UTestLibraryContent>();
	}
};
static_assert(alignof(UTestLibraryContent) == 0x000008, "Wrong alignment on UTestLibraryContent");
static_assert(sizeof(UTestLibraryContent) == 0x000028, "Wrong size on UTestLibraryContent");

// Class GbxTest.TestLibraryPerformance
// 0x0000 (0x0028 - 0x0028)
class UTestLibraryPerformance final : public UBlueprintFunctionLibrary
{
public:
	static void GenerateLevelGrid(TArray<struct FVector>* GridLocations, class APawn* Pawn, float GridSize, bool bWalkableOnly);
	static void WaitForFrames(class UObject* WorldContextObject, int32 NumFrames, const struct FLatentActionInfo& LatentInfo);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"TestLibraryPerformance">();
	}
	static class UTestLibraryPerformance* GetDefaultObj()
	{
		return GetDefaultObjImpl<UTestLibraryPerformance>();
	}
};
static_assert(alignof(UTestLibraryPerformance) == 0x000008, "Wrong alignment on UTestLibraryPerformance");
static_assert(sizeof(UTestLibraryPerformance) == 0x000028, "Wrong size on UTestLibraryPerformance");

// Class GbxTest.TestLibrarySimulation
// 0x0000 (0x0028 - 0x0028)
class UTestLibrarySimulation final : public UBlueprintFunctionLibrary
{
public:
	static bool CanReceiveBackgroundInput(class APlayerController*& PlayerController);
	static class UTestPolicySimulation* GetPolicyForPlayMap();
	static bool IsDemiGodEnabled(class APlayerController*& PlayerController);
	static bool IsGhostEnabled(class APlayerController*& PlayerController);
	static bool IsGodEnabled(class APlayerController*& PlayerController);
	static bool IsHLQNoClipEnabled(class APlayerController*& PlayerController);
	static bool IsPlayMapRunning();
	static void PopAssetContext(const struct FGbxProbeId& ID);
	static void PopWorldContext();
	static void PushAssetContext(const struct FGbxProbeId& ID);
	static void PushWorldContext(class UObject* WorldContextObject);
	static void ReportIssueFromPlayMap(ETestIssueType IssueType, const class FString& IssueCategory, const class FString& IssueMessage);
	static void ReportResultFromPlayMap(bool bSucceeded, const class FString& IssueCategory, const class FString& IssueMessage, const struct FGbxProbeId& AssetContext, ETestIssueType FailedIssueType);
	static void ResetTestTimeout();
	static bool SetReceiveBackgroundInput(class APlayerController*& PlayerController, bool AllowBackgroundInput);
	static void SetReportContext(class UObject* WorldContextObject, const TArray<struct FGbxProbeId>& AssetContexts);
	static void SimulatePlayerInput(class UObject* WorldContextObject, class APlayerController*& PlayerController, const TArray<struct FGbxTestInputAction>& InputDescription, float PreDelay, float PostDelay, const struct FLatentActionInfo& LatentInfo);
	static void StopPlayTest();
	static void TestBoolIsFalseFromPlayMap(const bool& Value, ETestIssueType IssueType, const class FString& IssueCategory, const class FString& IssueMessage);
	static void TestBoolIsTrueFromPlayMap(const bool& Value, ETestIssueType IssueType, const class FString& IssueCategory, const class FString& IssueMessage);
	static void TestFloatCompareFromPlayMap(const float& Value, float Other, ECompare Comparison, ETestIssueType IssueType, const class FString& IssueCategory, const class FString& IssueMessage, float Tolerance);
	static void TestFloatInRangeFromPlayMap(const float& Value, float Min, float Max, ETestIssueType IssueType, const class FString& IssueCategory, const class FString& IssueMessage);
	static void TestIntCompareFromPlayMap(const int32& Value, int32 Other, ECompare Comparison, ETestIssueType IssueType, const class FString& IssueCategory, const class FString& IssueMessage);
	static void TestIntInRangeFromPlayMap(const int32& Value, int32 Min, int32 Max, ETestIssueType IssueType, const class FString& IssueCategory, const class FString& IssueMessage);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"TestLibrarySimulation">();
	}
	static class UTestLibrarySimulation* GetDefaultObj()
	{
		return GetDefaultObjImpl<UTestLibrarySimulation>();
	}
};
static_assert(alignof(UTestLibrarySimulation) == 0x000008, "Wrong alignment on UTestLibrarySimulation");
static_assert(sizeof(UTestLibrarySimulation) == 0x000028, "Wrong size on UTestLibrarySimulation");

// Class GbxTest.GbxTestPlanCommandlet
// 0x0000 (0x0080 - 0x0080)
class UGbxTestPlanCommandlet final : public UCommandlet
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"GbxTestPlanCommandlet">();
	}
	static class UGbxTestPlanCommandlet* GetDefaultObj()
	{
		return GetDefaultObjImpl<UGbxTestPlanCommandlet>();
	}
};
static_assert(alignof(UGbxTestPlanCommandlet) == 0x000008, "Wrong alignment on UGbxTestPlanCommandlet");
static_assert(sizeof(UGbxTestPlanCommandlet) == 0x000080, "Wrong size on UGbxTestPlanCommandlet");

// Class GbxTest.TestPolicy
// 0x0088 (0x00B0 - 0x0028)
class UTestPolicy : public UObject
{
public:
	EDiscovery                                    DiscoveryMethod;                                   // 0x0028(0x0001)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, AssetRegistrySearchable, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_29[0x7];                                       // 0x0029(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	TSoftObjectPtr<class UGbxTestHierarchicalCommands> HierarchicalCommands;                              // 0x0030(0x0028)(Edit, BlueprintVisible, DisableEditOnInstance, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FString                                 Contact;                                           // 0x0058(0x0010)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, AssetRegistrySearchable, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EGbxTestPlan                                  TestPlan;                                          // 0x0068(0x0001)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, AssetRegistrySearchable, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_69[0x47];                                      // 0x0069(0x0047)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void ClearSavedTestCommand();
	void OnRunTestCommand(const class FString& TestCommand);
	void PopAssetContext(const struct FGbxProbeId& ID);
	void PushAssetContext(const struct FGbxProbeId& ID);
	void ReportIssue(ETestIssueType IssueType, const class FString& IssueCategory, const class FString& IssueMessage);
	void ReportResult(bool bSucceeded, const class FString& IssueCategory, const class FString& IssueMessage, const struct FGbxProbeId& AssetContext, ETestIssueType FailedIssueType);
	void SetReportContext(class UObject* WorldContextObject, const TArray<struct FGbxProbeId>& AssetContexts);
	void TestAssetAudit(const class UObject* Asset);
	void TestAssetTraits(const class UObject* Asset);
	void TestBoolIsFalse(const bool& Value, ETestIssueType IssueType, const class FString& IssueCategory, const class FString& IssueMessage);
	void TestBoolIsTrue(const bool& Value, ETestIssueType IssueType, const class FString& IssueCategory, const class FString& IssueMessage);
	void TestFloatCompare(const float& Value, float Other, ECompare Comparison, ETestIssueType IssueType, const class FString& IssueCategory, const class FString& IssueMessage, float Tolerance);
	void TestFloatInRange(const float& Value, float Min, float Max, ETestIssueType IssueType, const class FString& IssueCategory, const class FString& IssueMessage);
	void TestIntCompare(const int32& Value, int32 Other, ECompare Comparison, ETestIssueType IssueType, const class FString& IssueCategory, const class FString& IssueMessage);
	void TestIntInRange(const int32& Value, int32 Min, int32 Max, ETestIssueType IssueType, const class FString& IssueCategory, const class FString& IssueMessage);

	void OnGetTestCommands(TArray<class FString>* TestCommands, TArray<class FString>* PrettyNames) const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"TestPolicy">();
	}
	static class UTestPolicy* GetDefaultObj()
	{
		return GetDefaultObjImpl<UTestPolicy>();
	}
};
static_assert(alignof(UTestPolicy) == 0x000008, "Wrong alignment on UTestPolicy");
static_assert(sizeof(UTestPolicy) == 0x0000B0, "Wrong size on UTestPolicy");
static_assert(offsetof(UTestPolicy, DiscoveryMethod) == 0x000028, "Member 'UTestPolicy::DiscoveryMethod' has a wrong offset!");
static_assert(offsetof(UTestPolicy, HierarchicalCommands) == 0x000030, "Member 'UTestPolicy::HierarchicalCommands' has a wrong offset!");
static_assert(offsetof(UTestPolicy, Contact) == 0x000058, "Member 'UTestPolicy::Contact' has a wrong offset!");
static_assert(offsetof(UTestPolicy, TestPlan) == 0x000068, "Member 'UTestPolicy::TestPlan' has a wrong offset!");

// Class GbxTest.TestPolicyContent
// 0x0000 (0x00B0 - 0x00B0)
class UTestPolicyContent final : public UTestPolicy
{
public:
	void OnValidForImport(const class UObject* ImportObject, bool* Result) const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"TestPolicyContent">();
	}
	static class UTestPolicyContent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UTestPolicyContent>();
	}
};
static_assert(alignof(UTestPolicyContent) == 0x000008, "Wrong alignment on UTestPolicyContent");
static_assert(sizeof(UTestPolicyContent) == 0x0000B0, "Wrong size on UTestPolicyContent");

// Class GbxTest.TestPolicySimulation
// 0x0090 (0x0140 - 0x00B0)
class UTestPolicySimulation final : public UTestPolicy
{
public:
	uint8                                         Pad_B0[0x90];                                      // 0x00B0(0x0090)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void AddTestDriver(const TSubclassOf<class AActor> TestDriver);
	void IntendToMapTravel(bool WillMapTravel);
	void OnMapTraveled(class UWorld* NewWorld);
	void PlayMap(const class FString& MapName, const TArray<TSubclassOf<class AActor>>& TestDrivers, float Timeout, float TimeLimit);
	void PlayTestMap(const class FString& MapName, const TArray<TSubclassOf<class AActor>>& TestDrivers, float Timeout, float TimeLimit, bool bLoadMapOnce, bool bLoadMapIfNotLoaded);
	void RunTestDrivers(const TArray<TSubclassOf<class AActor>>& TestDrivers, float Timeout, float TimeLimit);
	void StopPlay();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"TestPolicySimulation">();
	}
	static class UTestPolicySimulation* GetDefaultObj()
	{
		return GetDefaultObjImpl<UTestPolicySimulation>();
	}
};
static_assert(alignof(UTestPolicySimulation) == 0x000008, "Wrong alignment on UTestPolicySimulation");
static_assert(sizeof(UTestPolicySimulation) == 0x000140, "Wrong size on UTestPolicySimulation");

}

