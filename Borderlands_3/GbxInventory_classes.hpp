#pragma once

/*
* SDK generated by Dumper-7
*
* https://github.com/Encryqed/Dumper-7
*/

// Package: GbxInventory

#include "Basic.hpp"

#include "GbxRuntime_classes.hpp"
#include "GbxInventory_structs.hpp"
#include "GbxGameSystemCore_structs.hpp"
#include "GbxGameSystemCore_classes.hpp"
#include "UMG_classes.hpp"
#include "OnlineSubsystemUtils_classes.hpp"
#include "CoreUObject_structs.hpp"
#include "CoreUObject_classes.hpp"
#include "Engine_structs.hpp"
#include "Engine_classes.hpp"
#include "GameplayTags_structs.hpp"
#include "GbxUI_classes.hpp"


namespace SDK
{

// Class GbxInventory.InventoryGenericPartExpansionData
// 0x0038 (0x0068 - 0x0030)
class UInventoryGenericPartExpansionData final : public UGbxDataAsset
{
public:
	class UGbxCondition*                          ExpansionCondition;                                // 0x0030(0x0008)(Edit, ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, PersistentInstance, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UInventoryBalanceCollectionData*        InventoryBalanceCollection;                        // 0x0038(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	struct FInventoryGenericPartExpansionListData GenericParts;                                      // 0x0040(0x0028)(Edit, Protected, NativeAccessSpecifierProtected)

public:
	void EnumeratePartListForPartType(uint8 PartType, TArray<class UActorPartData*>* OutPartList) const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"InventoryGenericPartExpansionData">();
	}
	static class UInventoryGenericPartExpansionData* GetDefaultObj()
	{
		return GetDefaultObjImpl<UInventoryGenericPartExpansionData>();
	}
};
static_assert(alignof(UInventoryGenericPartExpansionData) == 0x000008, "Wrong alignment on UInventoryGenericPartExpansionData");
static_assert(sizeof(UInventoryGenericPartExpansionData) == 0x000068, "Wrong size on UInventoryGenericPartExpansionData");
static_assert(offsetof(UInventoryGenericPartExpansionData, ExpansionCondition) == 0x000030, "Member 'UInventoryGenericPartExpansionData::ExpansionCondition' has a wrong offset!");
static_assert(offsetof(UInventoryGenericPartExpansionData, InventoryBalanceCollection) == 0x000038, "Member 'UInventoryGenericPartExpansionData::InventoryBalanceCollection' has a wrong offset!");
static_assert(offsetof(UInventoryGenericPartExpansionData, GenericParts) == 0x000040, "Member 'UInventoryGenericPartExpansionData::GenericParts' has a wrong offset!");

// Class GbxInventory.InventoryItemPickup
// 0x0190 (0x05E8 - 0x0458)
class AInventoryItemPickup : public AActor
{
public:
	class UWwiseEvent*                            PickupAudioEvent;                                  // 0x0458(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UWwiseEvent*                            CompletePickupAudioEvent;                          // 0x0460(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          DestroyOnPickup;                                   // 0x0468(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_469[0x3];                                      // 0x0469(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         UseFailBumpUpVelocity;                             // 0x046C(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         UseFailBumpBaseRotation;                           // 0x0470(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_474[0x4];                                      // 0x0474(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class AActor*                                 PickedUpBy;                                        // 0x0478(0x0008)(Net, ZeroConstructor, Transient, IsPlainOldData, RepNotify, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UStaticMeshComponent*                   PickupMesh;                                        // 0x0480(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, Transient, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class USkeletalMeshComponent*                 PickupSkelMesh;                                    // 0x0488(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, Transient, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TArray<class UParticleSystemComponent*>       PickupActorParticles;                              // 0x0490(0x0010)(ExportObject, ZeroConstructor, Transient, ContainsInstancedReference, NativeAccessSpecifierPublic)
	int32                                         Quantity;                                          // 0x04A0(0x0004)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         bCanOnlyBePickedUpByOwnerController : 1;           // 0x04A4(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (BlueprintVisible, BlueprintReadOnly, Net, Transient, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         bHighDetail : 1;                                   // 0x04A4(0x0001)(BitIndex: 0x01, PropSize: 0x0001 (Edit, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         bSharedWithAllPlayers : 1;                         // 0x04A4(0x0001)(BitIndex: 0x02, PropSize: 0x0001 (Edit, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         bSharedPlayersMustBeOnFriendlyTeam : 1;            // 0x04A4(0x0001)(BitIndex: 0x03, PropSize: 0x0001 (Edit, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         bReplicatePickupActor : 1;                         // 0x04A4(0x0001)(BitIndex: 0x04, PropSize: 0x0001 (Edit, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         StaticPickup : 1;                                  // 0x04A4(0x0001)(BitIndex: 0x05, PropSize: 0x0001 (Edit, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         bUseInventoryDataPickupActionType : 1;             // 0x04A4(0x0001)(BitIndex: 0x06, PropSize: 0x0001 (Edit, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         Pad_4A5[0x3];                                      // 0x04A5(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	TSubclassOf<class AActor>                     DefaultPickupActorClass;                           // 0x04A8(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         MaxDrawDistance;                                   // 0x04B0(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EPickupActionType                             DefaultPickupActionType;                           // 0x04B4(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EPickupActionType                             StaticPickupActionType;                            // 0x04B5(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_4B6[0x2];                                      // 0x04B6(0x0002)(Fixing Size After Last Property [ Dumper-7 ])
	class UGbxCondition*                          CanBeTouchedCondition;                             // 0x04B8(0x0008)(Edit, ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, PersistentInstance, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UInventoryCategoryData*                 PickupCategory;                                    // 0x04C0(0x0008)(BlueprintVisible, BlueprintReadOnly, Net, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	UMulticastDelegateProperty_                   OnPickupSpawnUnpaused;                             // 0x04C8(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	UMulticastDelegateProperty_                   OnPickupSpawnActive;                               // 0x04D8(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	UMulticastDelegateProperty_                   OnPickupIsActive;                                  // 0x04E8(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	UMulticastDelegateProperty_                   OnPickedUp;                                        // 0x04F8(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	struct FVector                                StaticLocation;                                    // 0x0508(0x000C)(IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FRotator                               StaticRotation;                                    // 0x0514(0x000C)(IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
	bool                                          NotAddedToInventory;                               // 0x0520(0x0001)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_521[0x3];                                      // 0x0521(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         PickupSphereRadius;                                // 0x0524(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         PickupSphereRadiusHideScale;                       // 0x0528(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_52C[0x4];                                      // 0x052C(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class USphereComponent*                       PickupSphereComponent;                             // 0x0530(0x0008)(ExportObject, ZeroConstructor, Transient, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UInventoryData*                         AssociatedInventoryData;                           // 0x0538(0x0008)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FText                                   OverrideErrorText;                                 // 0x0540(0x0018)(BlueprintVisible, BlueprintReadOnly, Transient, NativeAccessSpecifierPublic)
	bool                                          PlacedPickup;                                      // 0x0558(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_559[0x7];                                      // 0x0559(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	class UInventoryBalanceStateComponent*        CachedInventoryBalanceComponent;                   // 0x0560(0x0008)(ExportObject, ZeroConstructor, Transient, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class AActor*                                 PickupActor;                                       // 0x0568(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class AActor*                                 ReplicatedPickupActor;                             // 0x0570(0x0008)(Net, ZeroConstructor, Transient, IsPlainOldData, RepNotify, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	struct FInventoryItemPickupClientSpawnData    PickupActorClientSpawnData;                        // 0x0578(0x0030)(Net, Transient, RepNotify, Protected, NativeAccessSpecifierProtected)
	uint8                                         bPickupSpawnPaused : 1;                            // 0x05A8(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (BlueprintVisible, BlueprintReadOnly, Net, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected))
	uint8                                         bIsActive : 1;                                     // 0x05A8(0x0001)(BitIndex: 0x01, PropSize: 0x0001 (BlueprintVisible, BlueprintReadOnly, Net, RepNotify, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected))
	uint8                                         Pad_5A9[0x3];                                      // 0x05A9(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	struct FVector_NetQuantizeNormal              BumpAngularDir;                                    // 0x05AC(0x000C)(Net, Transient, RepNotify, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_5B8[0x20];                                     // 0x05B8(0x0020)(Fixing Size After Last Property [ Dumper-7 ])
	TSubclassOf<class UGbxAction>                 LootSpawnAction;                                   // 0x05D8(0x0008)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	TSubclassOf<class UGbxAction>                 RepLootSpawnAction;                                // 0x05E0(0x0008)(Net, ZeroConstructor, Transient, IsPlainOldData, RepNotify, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)

public:
	void ActivateAfterSpawnDelay();
	void ActivatePickup();
	bool CanBePickedUp(class AActor* Other, bool UsedByOther, bool bUseHeld, bool bForMassPickup);
	void DeactivatePickup();
	void GiveInventoryToUser(class AActor* Other, bool bAutoEquip);
	bool IsPickupInitialized();
	void OnLookedAtByPlayer(class APlayerController* InstigatingPlayer, bool bCanInteractWith, const struct FVector& NewUsableComponentImpactPoint, float NewUsableDistanceAway);
	void OnPickedUpEvent(class AActor* WasPickedUpBy);
	void OnRep_BumpAngularDir();
	void OnRep_IsActive();
	void OnRep_PickedUpBy();
	void OnRep_PickupActor();
	void OnRep_PickupActorClientSpawnData();
	void OnRep_RepLootSpawnAction();
	void OnRespawnEvent();
	void OnUsedBy(const struct FUseEvent& UseEvent);
	void ResetBumpOnPickupFail();
	void SetCanOnlyBePickedUpByOwner(bool bNewCanOnlyBePickedUpByOwnerController, class AController* OwnerController);
	void WaitForBalanceState();

	class UInventoryBalanceStateComponent* GetInventoryBalanceStateComponent() const;
	bool GetInventoryDisplayRarityOutline() const;
	struct FLinearColor GetInventoryRarityColorFX() const;
	struct FLinearColor GetInventoryRarityColorOutline() const;
	EDropLifeSpanType GetInventoryRarityLifeSpanType() const;
	class UWwiseEvent* GetInventoryRarityLootAudioStinger() const;
	class UParticleSystem* GetInventoryRarityLootBeamOverride() const;
	class UMeshComponent* GetMeshComponent() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"InventoryItemPickup">();
	}
	static class AInventoryItemPickup* GetDefaultObj()
	{
		return GetDefaultObjImpl<AInventoryItemPickup>();
	}
};
static_assert(alignof(AInventoryItemPickup) == 0x000008, "Wrong alignment on AInventoryItemPickup");
static_assert(sizeof(AInventoryItemPickup) == 0x0005E8, "Wrong size on AInventoryItemPickup");
static_assert(offsetof(AInventoryItemPickup, PickupAudioEvent) == 0x000458, "Member 'AInventoryItemPickup::PickupAudioEvent' has a wrong offset!");
static_assert(offsetof(AInventoryItemPickup, CompletePickupAudioEvent) == 0x000460, "Member 'AInventoryItemPickup::CompletePickupAudioEvent' has a wrong offset!");
static_assert(offsetof(AInventoryItemPickup, DestroyOnPickup) == 0x000468, "Member 'AInventoryItemPickup::DestroyOnPickup' has a wrong offset!");
static_assert(offsetof(AInventoryItemPickup, UseFailBumpUpVelocity) == 0x00046C, "Member 'AInventoryItemPickup::UseFailBumpUpVelocity' has a wrong offset!");
static_assert(offsetof(AInventoryItemPickup, UseFailBumpBaseRotation) == 0x000470, "Member 'AInventoryItemPickup::UseFailBumpBaseRotation' has a wrong offset!");
static_assert(offsetof(AInventoryItemPickup, PickedUpBy) == 0x000478, "Member 'AInventoryItemPickup::PickedUpBy' has a wrong offset!");
static_assert(offsetof(AInventoryItemPickup, PickupMesh) == 0x000480, "Member 'AInventoryItemPickup::PickupMesh' has a wrong offset!");
static_assert(offsetof(AInventoryItemPickup, PickupSkelMesh) == 0x000488, "Member 'AInventoryItemPickup::PickupSkelMesh' has a wrong offset!");
static_assert(offsetof(AInventoryItemPickup, PickupActorParticles) == 0x000490, "Member 'AInventoryItemPickup::PickupActorParticles' has a wrong offset!");
static_assert(offsetof(AInventoryItemPickup, Quantity) == 0x0004A0, "Member 'AInventoryItemPickup::Quantity' has a wrong offset!");
static_assert(offsetof(AInventoryItemPickup, DefaultPickupActorClass) == 0x0004A8, "Member 'AInventoryItemPickup::DefaultPickupActorClass' has a wrong offset!");
static_assert(offsetof(AInventoryItemPickup, MaxDrawDistance) == 0x0004B0, "Member 'AInventoryItemPickup::MaxDrawDistance' has a wrong offset!");
static_assert(offsetof(AInventoryItemPickup, DefaultPickupActionType) == 0x0004B4, "Member 'AInventoryItemPickup::DefaultPickupActionType' has a wrong offset!");
static_assert(offsetof(AInventoryItemPickup, StaticPickupActionType) == 0x0004B5, "Member 'AInventoryItemPickup::StaticPickupActionType' has a wrong offset!");
static_assert(offsetof(AInventoryItemPickup, CanBeTouchedCondition) == 0x0004B8, "Member 'AInventoryItemPickup::CanBeTouchedCondition' has a wrong offset!");
static_assert(offsetof(AInventoryItemPickup, PickupCategory) == 0x0004C0, "Member 'AInventoryItemPickup::PickupCategory' has a wrong offset!");
static_assert(offsetof(AInventoryItemPickup, OnPickupSpawnUnpaused) == 0x0004C8, "Member 'AInventoryItemPickup::OnPickupSpawnUnpaused' has a wrong offset!");
static_assert(offsetof(AInventoryItemPickup, OnPickupSpawnActive) == 0x0004D8, "Member 'AInventoryItemPickup::OnPickupSpawnActive' has a wrong offset!");
static_assert(offsetof(AInventoryItemPickup, OnPickupIsActive) == 0x0004E8, "Member 'AInventoryItemPickup::OnPickupIsActive' has a wrong offset!");
static_assert(offsetof(AInventoryItemPickup, OnPickedUp) == 0x0004F8, "Member 'AInventoryItemPickup::OnPickedUp' has a wrong offset!");
static_assert(offsetof(AInventoryItemPickup, StaticLocation) == 0x000508, "Member 'AInventoryItemPickup::StaticLocation' has a wrong offset!");
static_assert(offsetof(AInventoryItemPickup, StaticRotation) == 0x000514, "Member 'AInventoryItemPickup::StaticRotation' has a wrong offset!");
static_assert(offsetof(AInventoryItemPickup, NotAddedToInventory) == 0x000520, "Member 'AInventoryItemPickup::NotAddedToInventory' has a wrong offset!");
static_assert(offsetof(AInventoryItemPickup, PickupSphereRadius) == 0x000524, "Member 'AInventoryItemPickup::PickupSphereRadius' has a wrong offset!");
static_assert(offsetof(AInventoryItemPickup, PickupSphereRadiusHideScale) == 0x000528, "Member 'AInventoryItemPickup::PickupSphereRadiusHideScale' has a wrong offset!");
static_assert(offsetof(AInventoryItemPickup, PickupSphereComponent) == 0x000530, "Member 'AInventoryItemPickup::PickupSphereComponent' has a wrong offset!");
static_assert(offsetof(AInventoryItemPickup, AssociatedInventoryData) == 0x000538, "Member 'AInventoryItemPickup::AssociatedInventoryData' has a wrong offset!");
static_assert(offsetof(AInventoryItemPickup, OverrideErrorText) == 0x000540, "Member 'AInventoryItemPickup::OverrideErrorText' has a wrong offset!");
static_assert(offsetof(AInventoryItemPickup, PlacedPickup) == 0x000558, "Member 'AInventoryItemPickup::PlacedPickup' has a wrong offset!");
static_assert(offsetof(AInventoryItemPickup, CachedInventoryBalanceComponent) == 0x000560, "Member 'AInventoryItemPickup::CachedInventoryBalanceComponent' has a wrong offset!");
static_assert(offsetof(AInventoryItemPickup, PickupActor) == 0x000568, "Member 'AInventoryItemPickup::PickupActor' has a wrong offset!");
static_assert(offsetof(AInventoryItemPickup, ReplicatedPickupActor) == 0x000570, "Member 'AInventoryItemPickup::ReplicatedPickupActor' has a wrong offset!");
static_assert(offsetof(AInventoryItemPickup, PickupActorClientSpawnData) == 0x000578, "Member 'AInventoryItemPickup::PickupActorClientSpawnData' has a wrong offset!");
static_assert(offsetof(AInventoryItemPickup, BumpAngularDir) == 0x0005AC, "Member 'AInventoryItemPickup::BumpAngularDir' has a wrong offset!");
static_assert(offsetof(AInventoryItemPickup, LootSpawnAction) == 0x0005D8, "Member 'AInventoryItemPickup::LootSpawnAction' has a wrong offset!");
static_assert(offsetof(AInventoryItemPickup, RepLootSpawnAction) == 0x0005E0, "Member 'AInventoryItemPickup::RepLootSpawnAction' has a wrong offset!");

// Class GbxInventory.InventoryAspectData
// 0x0008 (0x0038 - 0x0030)
class UInventoryAspectData : public UGbxDataAsset
{
public:
	EInventoryAspectUsagePriority                 Priority;                                          // 0x0030(0x0001)(Edit, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_31[0x7];                                       // 0x0031(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void K2_CloneAppearance(class AActor* CloneActor, class AActor* InventoryActor, const class UInventoryBalanceStateComponent* InventoryBalanceState) const;
	class FString K2_GetFriendlyDescription() const;
	void K2_OnApplyAspect(class AActor* InventoryActor, const class UInventoryBalanceStateComponent* InventoryBalanceState) const;
	void K2_OnBeginPlay(class AActor* InventoryActor, const class UInventoryBalanceStateComponent* InventoryBalanceState) const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"InventoryAspectData">();
	}
	static class UInventoryAspectData* GetDefaultObj()
	{
		return GetDefaultObjImpl<UInventoryAspectData>();
	}
};
static_assert(alignof(UInventoryAspectData) == 0x000008, "Wrong alignment on UInventoryAspectData");
static_assert(sizeof(UInventoryAspectData) == 0x000038, "Wrong size on UInventoryAspectData");
static_assert(offsetof(UInventoryAspectData, Priority) == 0x000030, "Member 'UInventoryAspectData::Priority' has a wrong offset!");

// Class GbxInventory.LootableComponent
// 0x00A0 (0x0218 - 0x0178)
class ULootableComponent : public UActorComponent
{
public:
	UMulticastDelegateProperty_                   OnPickupAttached;                                  // 0x0178(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	UMulticastDelegateProperty_                   OnPickupDetached;                                  // 0x0188(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	UMulticastDelegateProperty_                   OnAllPickupsDetached;                              // 0x0198(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	class ULootableBalanceData*                   BalanceData;                                       // 0x01A8(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         InitialDropLootMassScale;                          // 0x01B0(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	EPickupLootAttachmentMode                     LootAttachmentMode;                                // 0x01B4(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_1B5[0x3];                                      // 0x01B5(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<TSubclassOf<class UGbxAction>>         LootSpawnActions;                                  // 0x01B8(0x0010)(Edit, BlueprintVisible, ZeroConstructor, Protected, UObjectWrapper, NativeAccessSpecifierProtected)
	bool                                          bForceSpawnedLootToHaveInfiniteLifespan;           // 0x01C8(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_1C9[0x3];                                      // 0x01C9(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	struct FVector                                UseOverrideBoxExtents;                             // 0x01CC(0x000C)(Edit, DisableEditOnTemplate, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bOverrideUseWithBox;                               // 0x01D8(0x0001)(Edit, ZeroConstructor, DisableEditOnTemplate, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_1D9[0x7];                                      // 0x01D9(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<struct FLootConfigurationInfo>         LootConfigurations;                                // 0x01E0(0x0010)(ZeroConstructor, Transient, Protected, NativeAccessSpecifierProtected)
	TArray<class ADroppedInventoryItemPickup*>    AttachedLoot;                                      // 0x01F0(0x0010)(ZeroConstructor, Transient, Protected, NativeAccessSpecifierProtected)
	class ULootableBalanceData*                   LootableBalanceDataOverride;                       // 0x0200(0x0008)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class AActor*                                 BalanceContextOverride;                            // 0x0208(0x0008)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_210[0x8];                                      // 0x0210(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void ActivateAttachedLoot();
	TArray<class ADroppedInventoryItemPickup*> GetAttachedPickups();
	void InitializeLootConfigurations(class ULootableBalanceData* LootableBalanceData);
	void SetBalanceContextOverride(class AActor* NewOverrideContext, bool bOnlyUseForGameStage);
	void SpawnAndAttachLoot(class FName* SelectedConfigurationName);
	void SpawnAndDropLoot(class FName* SelectedConfigurationName);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"LootableComponent">();
	}
	static class ULootableComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<ULootableComponent>();
	}
};
static_assert(alignof(ULootableComponent) == 0x000008, "Wrong alignment on ULootableComponent");
static_assert(sizeof(ULootableComponent) == 0x000218, "Wrong size on ULootableComponent");
static_assert(offsetof(ULootableComponent, OnPickupAttached) == 0x000178, "Member 'ULootableComponent::OnPickupAttached' has a wrong offset!");
static_assert(offsetof(ULootableComponent, OnPickupDetached) == 0x000188, "Member 'ULootableComponent::OnPickupDetached' has a wrong offset!");
static_assert(offsetof(ULootableComponent, OnAllPickupsDetached) == 0x000198, "Member 'ULootableComponent::OnAllPickupsDetached' has a wrong offset!");
static_assert(offsetof(ULootableComponent, BalanceData) == 0x0001A8, "Member 'ULootableComponent::BalanceData' has a wrong offset!");
static_assert(offsetof(ULootableComponent, InitialDropLootMassScale) == 0x0001B0, "Member 'ULootableComponent::InitialDropLootMassScale' has a wrong offset!");
static_assert(offsetof(ULootableComponent, LootAttachmentMode) == 0x0001B4, "Member 'ULootableComponent::LootAttachmentMode' has a wrong offset!");
static_assert(offsetof(ULootableComponent, LootSpawnActions) == 0x0001B8, "Member 'ULootableComponent::LootSpawnActions' has a wrong offset!");
static_assert(offsetof(ULootableComponent, bForceSpawnedLootToHaveInfiniteLifespan) == 0x0001C8, "Member 'ULootableComponent::bForceSpawnedLootToHaveInfiniteLifespan' has a wrong offset!");
static_assert(offsetof(ULootableComponent, UseOverrideBoxExtents) == 0x0001CC, "Member 'ULootableComponent::UseOverrideBoxExtents' has a wrong offset!");
static_assert(offsetof(ULootableComponent, bOverrideUseWithBox) == 0x0001D8, "Member 'ULootableComponent::bOverrideUseWithBox' has a wrong offset!");
static_assert(offsetof(ULootableComponent, LootConfigurations) == 0x0001E0, "Member 'ULootableComponent::LootConfigurations' has a wrong offset!");
static_assert(offsetof(ULootableComponent, AttachedLoot) == 0x0001F0, "Member 'ULootableComponent::AttachedLoot' has a wrong offset!");
static_assert(offsetof(ULootableComponent, LootableBalanceDataOverride) == 0x000200, "Member 'ULootableComponent::LootableBalanceDataOverride' has a wrong offset!");
static_assert(offsetof(ULootableComponent, BalanceContextOverride) == 0x000208, "Member 'ULootableComponent::BalanceContextOverride' has a wrong offset!");

// Class GbxInventory.InventoryBalanceStateComponent
// 0x0170 (0x0348 - 0x01D8)
class UInventoryBalanceStateComponent : public UBalanceStateComponent
{
public:
	struct FInventoryReplicationData              PackedReplicationData;                             // 0x01D8(0x0010)(Net, Transient, Protected, NativeAccessSpecifierProtected)
	TArray<class UInventoryNamePartData*>         NamePartList;                                      // 0x01E8(0x0010)(Edit, ZeroConstructor, Transient, EditConst, Protected, NativeAccessSpecifierProtected)
	float                                         MonetaryValueModifierTotal;                        // 0x01F8(0x0004)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	int32                                         MonetaryValue;                                     // 0x01FC(0x0004)(Net, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         InventoryScoreModifierTotal;                       // 0x0200(0x0004)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	int32                                         InventoryScoreValue;                               // 0x0204(0x0004)(Net, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UInventoryData*                         InventoryData;                                     // 0x0208(0x0008)(Edit, ZeroConstructor, Transient, EditConst, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UInventoryBalanceData*                  InventoryBalanceData;                              // 0x0210(0x0008)(Edit, ZeroConstructor, Transient, EditConst, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UManufacturerData*                      ManufacturerData;                                  // 0x0218(0x0008)(Edit, ZeroConstructor, Transient, EditConst, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TArray<class UInventoryPartData*>             PartList;                                          // 0x0220(0x0010)(Edit, ZeroConstructor, Transient, EditConst, Protected, NativeAccessSpecifierProtected)
	TArray<class UInventoryGenericPartData*>      GenericPartList;                                   // 0x0230(0x0010)(Edit, ZeroConstructor, Transient, EditConst, Protected, NativeAccessSpecifierProtected)
	TArray<uint8>                                 AdditionalData;                                    // 0x0240(0x0010)(Edit, ZeroConstructor, Transient, EditConst, Protected, NativeAccessSpecifierProtected)
	TArray<class UInventoryCustomizationPartData*> CustomizationPartList;                             // 0x0250(0x0010)(Edit, ZeroConstructor, Transient, EditConst, Protected, NativeAccessSpecifierProtected)
	uint8                                         ReRollCount;                                       // 0x0260(0x0001)(Edit, Net, ZeroConstructor, Transient, EditConst, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_261[0x7];                                      // 0x0261(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	class FText                                   DisplayName;                                       // 0x0268(0x0018)(Edit, Transient, EditConst, Protected, NativeAccessSpecifierProtected)
	TArray<class UInventoryAspectData*>           GenericAspects;                                    // 0x0280(0x0010)(Edit, ZeroConstructor, Transient, EditConst, Protected, NativeAccessSpecifierProtected)
	class UGestaltData*                           GestaltData;                                       // 0x0290(0x0008)(Edit, ZeroConstructor, Transient, EditConst, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TArray<class FName>                           GestaltMeshPartNames;                              // 0x0298(0x0010)(Edit, ZeroConstructor, EditConst, Protected, NativeAccessSpecifierProtected)
	TArray<struct FGbxAttributeModifierHandle>    InstigatorAttributeModifiers;                      // 0x02A8(0x0010)(ZeroConstructor, Transient, Protected, NativeAccessSpecifierProtected)
	TArray<struct FInventoryPrimitiveAspectSetData> PrimitiveAspectSetList;                            // 0x02B8(0x0010)(ZeroConstructor, Transient, Protected, NativeAccessSpecifierProtected)
	TArray<class UInventoryConditionalDamageAspectData*> ConditionalDamageAspectList;                       // 0x02C8(0x0010)(Edit, ZeroConstructor, Transient, EditConst, Protected, NativeAccessSpecifierProtected)
	TArray<class UInventoryAttributeEffectsAspectData*> AttributeEffectsAspectList;                        // 0x02D8(0x0010)(Edit, ZeroConstructor, Transient, EditConst, Protected, NativeAccessSpecifierProtected)
	TArray<class UInventoryParticleAspectData*>   ParticleAspects;                                   // 0x02E8(0x0010)(Edit, ZeroConstructor, Transient, EditConst, Protected, NativeAccessSpecifierProtected)
	struct FCachedUIStatCollectionData            UIStats;                                           // 0x02F8(0x0010)(Transient, Protected, NativeAccessSpecifierProtected)
	struct FReplicatedUIStatCollectionData        ReplicatedUIStats;                                 // 0x0308(0x0010)(Net, RepNotify, Protected, NativeAccessSpecifierProtected)
	uint8                                         Pad_318[0x8];                                      // 0x0318(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<class UInventoryMaterialAspectTextureAssetStreamer*> InventoryMaterialAspectTextureAssetStreamers;      // 0x0320(0x0010)(ZeroConstructor, Transient, Protected, NativeAccessSpecifierProtected)
	uint8                                         Pad_330[0x18];                                     // 0x0330(0x0018)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void NotifyAttached(class APawn* Instigator);
	void NotifyEquipped(class APawn* NewInstigator);
	void NotifyUnequipped(class APawn* OldInstigator);
	void OnRep_ReplicatedUIStats();
	void PostBeginPlay();

	void CloneAppearance(class AActor* DestActor, class USceneComponent* ParentComp, bool bAbsoluteScale) const;
	const TArray<class UInventoryCustomizationPartData*> GetCustomizationPartList() const;
	TSubclassOf<class UGbxDamageType> GetDamageType() const;
	class FText GetDisplayName() const;
	const TArray<class UInventoryGenericPartData*> GetGenericPartList() const;
	class UInventoryBalanceData* GetInventoryBalanceData() const;
	class UInventoryData* GetInventoryData() const;
	bool GetInventoryDisplayRarityOutline() const;
	struct FLinearColor GetInventoryRarityColorFX() const;
	struct FLinearColor GetInventoryRarityColorOutline() const;
	class UInventoryRarityData* GetInventoryRarityData() const;
	const class FText GetInventoryRarityDisplayName() const;
	class FString GetInventoryRarityFrameName() const;
	float GetInventoryRarityLifeSpan() const;
	EDropLifeSpanType GetInventoryRarityLifeSpanType() const;
	class UWwiseEvent* GetInventoryRarityLootAudioStinger() const;
	float GetInventoryRarityLootBeamHeight() const;
	class UParticleSystem* GetInventoryRarityLootBeamOverride() const;
	int32 GetInventoryScoreValue() const;
	class UManufacturerData* GetManufacturer() const;
	int32 GetMonetaryValue() const;
	const TArray<class UInventoryPartData*> GetPartList() const;
	uint8 GetReRollCount() const;
	bool IsManufactureredBy(const class UManufacturerData* Manufacturer) const;
	TSubclassOf<class UGbxDamageType> K2_GetDamageType() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"InventoryBalanceStateComponent">();
	}
	static class UInventoryBalanceStateComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UInventoryBalanceStateComponent>();
	}
};
static_assert(alignof(UInventoryBalanceStateComponent) == 0x000008, "Wrong alignment on UInventoryBalanceStateComponent");
static_assert(sizeof(UInventoryBalanceStateComponent) == 0x000348, "Wrong size on UInventoryBalanceStateComponent");
static_assert(offsetof(UInventoryBalanceStateComponent, PackedReplicationData) == 0x0001D8, "Member 'UInventoryBalanceStateComponent::PackedReplicationData' has a wrong offset!");
static_assert(offsetof(UInventoryBalanceStateComponent, NamePartList) == 0x0001E8, "Member 'UInventoryBalanceStateComponent::NamePartList' has a wrong offset!");
static_assert(offsetof(UInventoryBalanceStateComponent, MonetaryValueModifierTotal) == 0x0001F8, "Member 'UInventoryBalanceStateComponent::MonetaryValueModifierTotal' has a wrong offset!");
static_assert(offsetof(UInventoryBalanceStateComponent, MonetaryValue) == 0x0001FC, "Member 'UInventoryBalanceStateComponent::MonetaryValue' has a wrong offset!");
static_assert(offsetof(UInventoryBalanceStateComponent, InventoryScoreModifierTotal) == 0x000200, "Member 'UInventoryBalanceStateComponent::InventoryScoreModifierTotal' has a wrong offset!");
static_assert(offsetof(UInventoryBalanceStateComponent, InventoryScoreValue) == 0x000204, "Member 'UInventoryBalanceStateComponent::InventoryScoreValue' has a wrong offset!");
static_assert(offsetof(UInventoryBalanceStateComponent, InventoryData) == 0x000208, "Member 'UInventoryBalanceStateComponent::InventoryData' has a wrong offset!");
static_assert(offsetof(UInventoryBalanceStateComponent, InventoryBalanceData) == 0x000210, "Member 'UInventoryBalanceStateComponent::InventoryBalanceData' has a wrong offset!");
static_assert(offsetof(UInventoryBalanceStateComponent, ManufacturerData) == 0x000218, "Member 'UInventoryBalanceStateComponent::ManufacturerData' has a wrong offset!");
static_assert(offsetof(UInventoryBalanceStateComponent, PartList) == 0x000220, "Member 'UInventoryBalanceStateComponent::PartList' has a wrong offset!");
static_assert(offsetof(UInventoryBalanceStateComponent, GenericPartList) == 0x000230, "Member 'UInventoryBalanceStateComponent::GenericPartList' has a wrong offset!");
static_assert(offsetof(UInventoryBalanceStateComponent, AdditionalData) == 0x000240, "Member 'UInventoryBalanceStateComponent::AdditionalData' has a wrong offset!");
static_assert(offsetof(UInventoryBalanceStateComponent, CustomizationPartList) == 0x000250, "Member 'UInventoryBalanceStateComponent::CustomizationPartList' has a wrong offset!");
static_assert(offsetof(UInventoryBalanceStateComponent, ReRollCount) == 0x000260, "Member 'UInventoryBalanceStateComponent::ReRollCount' has a wrong offset!");
static_assert(offsetof(UInventoryBalanceStateComponent, DisplayName) == 0x000268, "Member 'UInventoryBalanceStateComponent::DisplayName' has a wrong offset!");
static_assert(offsetof(UInventoryBalanceStateComponent, GenericAspects) == 0x000280, "Member 'UInventoryBalanceStateComponent::GenericAspects' has a wrong offset!");
static_assert(offsetof(UInventoryBalanceStateComponent, GestaltData) == 0x000290, "Member 'UInventoryBalanceStateComponent::GestaltData' has a wrong offset!");
static_assert(offsetof(UInventoryBalanceStateComponent, GestaltMeshPartNames) == 0x000298, "Member 'UInventoryBalanceStateComponent::GestaltMeshPartNames' has a wrong offset!");
static_assert(offsetof(UInventoryBalanceStateComponent, InstigatorAttributeModifiers) == 0x0002A8, "Member 'UInventoryBalanceStateComponent::InstigatorAttributeModifiers' has a wrong offset!");
static_assert(offsetof(UInventoryBalanceStateComponent, PrimitiveAspectSetList) == 0x0002B8, "Member 'UInventoryBalanceStateComponent::PrimitiveAspectSetList' has a wrong offset!");
static_assert(offsetof(UInventoryBalanceStateComponent, ConditionalDamageAspectList) == 0x0002C8, "Member 'UInventoryBalanceStateComponent::ConditionalDamageAspectList' has a wrong offset!");
static_assert(offsetof(UInventoryBalanceStateComponent, AttributeEffectsAspectList) == 0x0002D8, "Member 'UInventoryBalanceStateComponent::AttributeEffectsAspectList' has a wrong offset!");
static_assert(offsetof(UInventoryBalanceStateComponent, ParticleAspects) == 0x0002E8, "Member 'UInventoryBalanceStateComponent::ParticleAspects' has a wrong offset!");
static_assert(offsetof(UInventoryBalanceStateComponent, UIStats) == 0x0002F8, "Member 'UInventoryBalanceStateComponent::UIStats' has a wrong offset!");
static_assert(offsetof(UInventoryBalanceStateComponent, ReplicatedUIStats) == 0x000308, "Member 'UInventoryBalanceStateComponent::ReplicatedUIStats' has a wrong offset!");
static_assert(offsetof(UInventoryBalanceStateComponent, InventoryMaterialAspectTextureAssetStreamers) == 0x000320, "Member 'UInventoryBalanceStateComponent::InventoryMaterialAspectTextureAssetStreamers' has a wrong offset!");

// Class GbxInventory.ManufacturerData
// 0x00E0 (0x0110 - 0x0030)
class UManufacturerData : public UGbxDataAsset
{
public:
	uint8                                         Pad_30[0x8];                                       // 0x0030(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	struct FAttributeInitializationData           MinGameStage;                                      // 0x0038(0x0038)(Edit, NoDestructor, Protected, NativeAccessSpecifierProtected)
	struct FAttributeInitializationData           MaxGameStage;                                      // 0x0070(0x0038)(Edit, NoDestructor, Protected, NativeAccessSpecifierProtected)
	class FText                                   ManufacturerName;                                  // 0x00A8(0x0018)(Edit, Protected, NativeAccessSpecifierProtected)
	class FText                                   Blurb;                                             // 0x00C0(0x0018)(Edit, Protected, NativeAccessSpecifierProtected)
	TArray<class UUIStatData*>                    UIStats;                                           // 0x00D8(0x0010)(Edit, ExportObject, ZeroConstructor, ContainsInstancedReference, Protected, NativeAccessSpecifierProtected)
	struct FGuid                                  AssetGuid;                                         // 0x00E8(0x0010)(IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class FString                                 ManufacturerLogoFrameName;                         // 0x00F8(0x0010)(Edit, ZeroConstructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UDialogEnumValue*                       ManufacturerDialogEnumValue;                       // 0x0108(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"ManufacturerData">();
	}
	static class UManufacturerData* GetDefaultObj()
	{
		return GetDefaultObjImpl<UManufacturerData>();
	}
};
static_assert(alignof(UManufacturerData) == 0x000008, "Wrong alignment on UManufacturerData");
static_assert(sizeof(UManufacturerData) == 0x000110, "Wrong size on UManufacturerData");
static_assert(offsetof(UManufacturerData, MinGameStage) == 0x000038, "Member 'UManufacturerData::MinGameStage' has a wrong offset!");
static_assert(offsetof(UManufacturerData, MaxGameStage) == 0x000070, "Member 'UManufacturerData::MaxGameStage' has a wrong offset!");
static_assert(offsetof(UManufacturerData, ManufacturerName) == 0x0000A8, "Member 'UManufacturerData::ManufacturerName' has a wrong offset!");
static_assert(offsetof(UManufacturerData, Blurb) == 0x0000C0, "Member 'UManufacturerData::Blurb' has a wrong offset!");
static_assert(offsetof(UManufacturerData, UIStats) == 0x0000D8, "Member 'UManufacturerData::UIStats' has a wrong offset!");
static_assert(offsetof(UManufacturerData, AssetGuid) == 0x0000E8, "Member 'UManufacturerData::AssetGuid' has a wrong offset!");
static_assert(offsetof(UManufacturerData, ManufacturerLogoFrameName) == 0x0000F8, "Member 'UManufacturerData::ManufacturerLogoFrameName' has a wrong offset!");
static_assert(offsetof(UManufacturerData, ManufacturerDialogEnumValue) == 0x000108, "Member 'UManufacturerData::ManufacturerDialogEnumValue' has a wrong offset!");

// Class GbxInventory.InventoryBalanceData
// 0x0090 (0x0128 - 0x0098)
class UInventoryBalanceData : public UActorPartSelectionData
{
public:
	uint8                                         Pad_98[0x8];                                       // 0x0098(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	TSubclassOf<class UInventoryBalanceStateComponent> InventoryBalanceStateClass;                        // 0x00A0(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UInventoryBalanceData*                  BaseBalanceData;                                   // 0x00A8(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UInventoryData*                         InventoryData;                                     // 0x00B0(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UInventoryRarityData*                   RarityData;                                        // 0x00B8(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TArray<struct FInventoryManufacturerBalanceData> Manufacturers;                                     // 0x00C0(0x0010)(Edit, ZeroConstructor, Protected, NativeAccessSpecifierProtected)
	struct FRuntimeGenericPartListData            RuntimeGenericPartList;                            // 0x00D0(0x0020)(Protected, NativeAccessSpecifierProtected)
	uint8                                         bIsGearBuildable : 1;                              // 0x00F0(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (Edit, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected))
	uint8                                         Pad_F1[0x7];                                       // 0x00F1(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	class UGearBuilderCategoryData*               GearBuilderCategory;                               // 0x00F8(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	int32                                         MaxNumPrefixes;                                    // 0x0100(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_104[0x4];                                      // 0x0104(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class UDownloadableInventorySetData*          DlcInventorySetData;                               // 0x0108(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bMigratedToActorPartSelectionData;                 // 0x0110(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_111[0x3];                                      // 0x0111(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	struct FGuid                                  AssetGuid;                                         // 0x0114(0x0010)(IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         bDisableVisibilityAndCollision : 1;                // 0x0124(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (Edit, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         Pad_125[0x3];                                      // 0x0125(0x0003)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"InventoryBalanceData">();
	}
	static class UInventoryBalanceData* GetDefaultObj()
	{
		return GetDefaultObjImpl<UInventoryBalanceData>();
	}
};
static_assert(alignof(UInventoryBalanceData) == 0x000008, "Wrong alignment on UInventoryBalanceData");
static_assert(sizeof(UInventoryBalanceData) == 0x000128, "Wrong size on UInventoryBalanceData");
static_assert(offsetof(UInventoryBalanceData, InventoryBalanceStateClass) == 0x0000A0, "Member 'UInventoryBalanceData::InventoryBalanceStateClass' has a wrong offset!");
static_assert(offsetof(UInventoryBalanceData, BaseBalanceData) == 0x0000A8, "Member 'UInventoryBalanceData::BaseBalanceData' has a wrong offset!");
static_assert(offsetof(UInventoryBalanceData, InventoryData) == 0x0000B0, "Member 'UInventoryBalanceData::InventoryData' has a wrong offset!");
static_assert(offsetof(UInventoryBalanceData, RarityData) == 0x0000B8, "Member 'UInventoryBalanceData::RarityData' has a wrong offset!");
static_assert(offsetof(UInventoryBalanceData, Manufacturers) == 0x0000C0, "Member 'UInventoryBalanceData::Manufacturers' has a wrong offset!");
static_assert(offsetof(UInventoryBalanceData, RuntimeGenericPartList) == 0x0000D0, "Member 'UInventoryBalanceData::RuntimeGenericPartList' has a wrong offset!");
static_assert(offsetof(UInventoryBalanceData, GearBuilderCategory) == 0x0000F8, "Member 'UInventoryBalanceData::GearBuilderCategory' has a wrong offset!");
static_assert(offsetof(UInventoryBalanceData, MaxNumPrefixes) == 0x000100, "Member 'UInventoryBalanceData::MaxNumPrefixes' has a wrong offset!");
static_assert(offsetof(UInventoryBalanceData, DlcInventorySetData) == 0x000108, "Member 'UInventoryBalanceData::DlcInventorySetData' has a wrong offset!");
static_assert(offsetof(UInventoryBalanceData, bMigratedToActorPartSelectionData) == 0x000110, "Member 'UInventoryBalanceData::bMigratedToActorPartSelectionData' has a wrong offset!");
static_assert(offsetof(UInventoryBalanceData, AssetGuid) == 0x000114, "Member 'UInventoryBalanceData::AssetGuid' has a wrong offset!");

// Class GbxInventory.InventoryListComponent
// 0x01F8 (0x0370 - 0x0178)
class UInventoryListComponent : public UActorComponent
{
public:
	struct FInventoryListContainer                InventoryList;                                     // 0x0178(0x00C8)(Net, Protected, NativeAccessSpecifierProtected)
	int32                                         InventoryCapacityUsed;                             // 0x0240(0x0004)(Net, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_244[0x4];                                      // 0x0244(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	TMap<class UInventoryCategoryData*, struct FInventorySelectionTracker> SelectedIndexs;                                    // 0x0248(0x0050)(ZeroConstructor, Transient, Protected, NativeAccessSpecifierProtected)
	class UClass*                                 DroppedPickupClass;                                // 0x0298(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bCanPickupOnTouch;                                 // 0x02A0(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_2A1[0x3];                                      // 0x02A1(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	struct FGbxAttributeInteger                   MaxInventoryItems;                                 // 0x02A4(0x000C)(Edit, BlueprintVisible, BlueprintReadOnly, Net, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_2B0[0x28];                                     // 0x02B0(0x0028)(Fixing Size After Last Property [ Dumper-7 ])
	UMulticastDelegateProperty_                   OnInventoryItemAdded;                              // 0x02D8(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	UMulticastDelegateProperty_                   OnInventoryItemRemoved;                            // 0x02E8(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	UMulticastDelegateProperty_                   OnInventoryItemUpdated;                            // 0x02F8(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	UMulticastDelegateProperty_                   OnInventoryItemActorReplaced;                      // 0x0308(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	UMulticastDelegateProperty_                   OnInventoryItemQuantityUpdated;                    // 0x0318(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	UMulticastDelegateProperty_                   OnInventoryItemPickedUp;                           // 0x0328(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	UMulticastDelegateProperty_                   OnAddedToInventory_Internal;                       // 0x0338(0x0010)(ZeroConstructor, Transient, InstancedReference, NativeAccessSpecifierPublic)
	UMulticastDelegateProperty_                   OnPreAddToFullInventory_Internal;                  // 0x0348(0x0010)(ZeroConstructor, Transient, InstancedReference, NativeAccessSpecifierPublic)
	UMulticastDelegateProperty_                   OnRemovingFromInventory_Internal;                  // 0x0358(0x0010)(ZeroConstructor, Transient, InstancedReference, NativeAccessSpecifierPublic)
	uint8                                         Pad_368[0x8];                                      // 0x0368(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class FText GetInventoryDisplayDescription(class AActor* InventoryActor);
	static class FText GetInventoryDisplayName(class AActor* InventoryActor);
	static class FText GetInventoryListEntryDisplayDescription(struct FInventoryListEntry* ListEntry);
	static class FText GetInventoryListEntryDisplayName(struct FInventoryListEntry* ListEntry);

	bool AddCategory(const class UInventoryCategoryData* ItemCategory, bool TrackQuantity);
	struct FInventoryListEntryHandle AddExternalItem(const class UInventoryCategoryData* ItemCategory, class AActor* ActorToAdd, int32 Quantity, bool AddedByPickup, bool bAutoEquip, bool bConditionalDestroyActor, int32 DesiredSlot, bool bBypassInventoryFull);
	struct FInventoryListEntryHandle AddExternalItemEx(const class UInventoryCategoryData* ItemCategory, class AActor* ActorToAdd, int32 Quantity, int32 Flags_0, bool bConditionalDestroyActor, int32 DesiredSlot, bool bBypassInventoryFull);
	struct FInventoryListEntryHandle AddItemFromPickup(class AInventoryItemPickup* PickupActor);
	void AddOrUpdateCategoryOnly(const class UInventoryCategoryData* ItemCategory, int32 Quantity);
	bool CanUseSelected(const class UInventoryCategoryData* ChildTypeToUse, int32 Quantity);
	void ClearInventory(bool DestroyInventory);
	class AActor* GetAndConsumeItem(const struct FInventoryListEntryHandle& InventoryItemHandle, int32 Quantity);
	class AActor* GetAndConsumeSelected(const class UInventoryCategoryData* TypeToConsume, int32 Quantity);
	int32 GetCategoryItemQuantity(const class UInventoryCategoryData* ItemCategory);
	void GetCategoryOnlyInventoryHandles(const class UInventoryCategoryData* ChildTypeToGet, TArray<struct FInventoryListEntryHandle>* ItemHandleList);
	void GetInventoryHandlesOfType(const class UInventoryCategoryData* ChildTypeToGet, TArray<struct FInventoryListEntryHandle>* ItemHandleList);
	bool GetItem(const struct FInventoryListEntryHandle& InventoryItemHandle, struct FInventoryListEntry* ListEntry);
	void GetSelectedItemQuantity(const class UInventoryCategoryData* ChildTypeToGet, int32* Quantity, int32* MaxQuantity);
	class AActor* GetStoredInventoryActor(const struct FInventoryListEntryHandle& InventoryItemHandle);
	bool HasActorInList(class AActor* ItemActor);
	void ServerAddCustomizationPartToInventoryActor(const struct FInventoryListEntryHandle& InventoryItemHandle, class UInventoryCustomizationPartData* Part);
	void ServerConsumeItem(const struct FInventoryListEntryHandle& InventoryItemHandle, int32 Quantity);
	void ServerDropItem(const struct FInventoryListEntryHandle& InventoryItemHandle, const struct FVector& InitialLocation, const struct FRotator& InitialRotation);
	void ServerRemoveCustomizationPartFromInventoryActor(const struct FInventoryListEntryHandle& InventoryItemHandle, class UInventoryCustomizationPartData* Part);
	void ServerRemoveItem(const struct FInventoryListEntryHandle& InventoryItemHandle);
	void ServerSetItemsUIFlags(class UInventoryCategoryData* Category, uint8 Flags_0, uint8 FlagsMask);
	void ServerSetItemUIFlags(const struct FInventoryListEntryHandle& Handle, uint8 Flags_0, uint8 FlagsMask);
	void ServerTransferItem(const struct FInventoryListEntryHandle& InventoryItemHandle, class AActor* DestinationActor, int32 Quantity);
	int32 SizeInInventory(class AInventoryItemPickup* PickupToTest);

	bool CanSwapItemForPickup(class AActor* Item, class AInventoryItemPickup* Pickup) const;
	int32 GetInventoryItemCount() const;
	int32 GetMaxInventoryItems() const;
	bool IsInventoryFull() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"InventoryListComponent">();
	}
	static class UInventoryListComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UInventoryListComponent>();
	}
};
static_assert(alignof(UInventoryListComponent) == 0x000008, "Wrong alignment on UInventoryListComponent");
static_assert(sizeof(UInventoryListComponent) == 0x000370, "Wrong size on UInventoryListComponent");
static_assert(offsetof(UInventoryListComponent, InventoryList) == 0x000178, "Member 'UInventoryListComponent::InventoryList' has a wrong offset!");
static_assert(offsetof(UInventoryListComponent, InventoryCapacityUsed) == 0x000240, "Member 'UInventoryListComponent::InventoryCapacityUsed' has a wrong offset!");
static_assert(offsetof(UInventoryListComponent, SelectedIndexs) == 0x000248, "Member 'UInventoryListComponent::SelectedIndexs' has a wrong offset!");
static_assert(offsetof(UInventoryListComponent, DroppedPickupClass) == 0x000298, "Member 'UInventoryListComponent::DroppedPickupClass' has a wrong offset!");
static_assert(offsetof(UInventoryListComponent, bCanPickupOnTouch) == 0x0002A0, "Member 'UInventoryListComponent::bCanPickupOnTouch' has a wrong offset!");
static_assert(offsetof(UInventoryListComponent, MaxInventoryItems) == 0x0002A4, "Member 'UInventoryListComponent::MaxInventoryItems' has a wrong offset!");
static_assert(offsetof(UInventoryListComponent, OnInventoryItemAdded) == 0x0002D8, "Member 'UInventoryListComponent::OnInventoryItemAdded' has a wrong offset!");
static_assert(offsetof(UInventoryListComponent, OnInventoryItemRemoved) == 0x0002E8, "Member 'UInventoryListComponent::OnInventoryItemRemoved' has a wrong offset!");
static_assert(offsetof(UInventoryListComponent, OnInventoryItemUpdated) == 0x0002F8, "Member 'UInventoryListComponent::OnInventoryItemUpdated' has a wrong offset!");
static_assert(offsetof(UInventoryListComponent, OnInventoryItemActorReplaced) == 0x000308, "Member 'UInventoryListComponent::OnInventoryItemActorReplaced' has a wrong offset!");
static_assert(offsetof(UInventoryListComponent, OnInventoryItemQuantityUpdated) == 0x000318, "Member 'UInventoryListComponent::OnInventoryItemQuantityUpdated' has a wrong offset!");
static_assert(offsetof(UInventoryListComponent, OnInventoryItemPickedUp) == 0x000328, "Member 'UInventoryListComponent::OnInventoryItemPickedUp' has a wrong offset!");
static_assert(offsetof(UInventoryListComponent, OnAddedToInventory_Internal) == 0x000338, "Member 'UInventoryListComponent::OnAddedToInventory_Internal' has a wrong offset!");
static_assert(offsetof(UInventoryListComponent, OnPreAddToFullInventory_Internal) == 0x000348, "Member 'UInventoryListComponent::OnPreAddToFullInventory_Internal' has a wrong offset!");
static_assert(offsetof(UInventoryListComponent, OnRemovingFromInventory_Internal) == 0x000358, "Member 'UInventoryListComponent::OnRemovingFromInventory_Internal' has a wrong offset!");

// Class GbxInventory.InventoryData
// 0x02D0 (0x0300 - 0x0030)
class UInventoryData : public UGbxDataAsset
{
public:
	uint8                                         Pad_30[0x8];                                       // 0x0030(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	uint8                                         bInventoryNameIsFullName : 1;                      // 0x0038(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (Edit, DisableEditOnTemplate, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected))
	uint8                                         Pad_39[0x7];                                       // 0x0039(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	class FText                                   InventoryName;                                     // 0x0040(0x0018)(Edit, DisableEditOnTemplate, Protected, NativeAccessSpecifierProtected)
	TArray<class UInventoryNamePartData*>         PrefixPartList;                                    // 0x0058(0x0010)(Edit, ZeroConstructor, DisableEditOnTemplate, Protected, NativeAccessSpecifierProtected)
	TArray<class UInventoryNamePartData*>         TitlePartList;                                     // 0x0068(0x0010)(Edit, ZeroConstructor, DisableEditOnTemplate, Protected, NativeAccessSpecifierProtected)
	TArray<class UInventoryNamePartData*>         SuffixPartList;                                    // 0x0078(0x0010)(Edit, ZeroConstructor, DisableEditOnTemplate, Protected, NativeAccessSpecifierProtected)
	class UInventoryNamingStrategyData*           NamingStrategy;                                    // 0x0088(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TSubclassOf<class AActor>                     InventoryActorClass;                               // 0x0090(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TArray<struct FAttributeEffectData>           InventoryAttributeEffects;                         // 0x0098(0x0010)(Edit, ZeroConstructor, DisableEditOnTemplate, Protected, NativeAccessSpecifierProtected)
	TArray<struct FInstigatorAttributeEffectData> InstigatorAttributeEffects;                        // 0x00A8(0x0010)(Edit, ZeroConstructor, DisableEditOnTemplate, Protected, NativeAccessSpecifierProtected)
	TArray<class UInventoryAspectData*>           AspectList;                                        // 0x00B8(0x0010)(Edit, ExportObject, ZeroConstructor, DisableEditOnTemplate, ContainsInstancedReference, Protected, NativeAccessSpecifierProtected)
	TArray<class UInventoryAspectData*>           StandaloneAspectList;                              // 0x00C8(0x0010)(Edit, ZeroConstructor, DisableEditOnTemplate, Protected, NativeAccessSpecifierProtected)
	bool                                          bDisplayNameInInteractionHeader;                   // 0x00D8(0x0001)(Edit, ZeroConstructor, DisableEditOnTemplate, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bUsesItemCard;                                     // 0x00D9(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_DA[0x6];                                       // 0x00DA(0x0006)(Fixing Size After Last Property [ Dumper-7 ])
	class FString                                 ItemCardTypeFrameName;                             // 0x00E0(0x0010)(Edit, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TArray<class UGbxCondition*>                  OnUseConstraints;                                  // 0x00F0(0x0010)(Edit, ExportObject, ZeroConstructor, DisableEditOnTemplate, ContainsInstancedReference, NativeAccessSpecifierPublic)
	bool                                          bUsesPlayerLevelRequirement;                       // 0x0100(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_101[0x7];                                      // 0x0101(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<struct FUIStatPriorityData>            UIStats;                                           // 0x0108(0x0010)(Edit, ZeroConstructor, DisableEditOnInstance, NativeAccessSpecifierPublic)
	struct FGuid                                  AssetGuid;                                         // 0x0118(0x0010)(IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UWwiseEvent*                            PickupSound;                                       // 0x0128(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UWwiseEvent*                            PickupEquipSound;                                  // 0x0130(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UGbxCondition*                          SpottedCalloutCondition;                           // 0x0138(0x0008)(Edit, ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, PersistentInstance, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UDialogEvent*                           SpottedCallout;                                    // 0x0140(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UImpactData*                            PickupImpact;                                      // 0x0148(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UWwiseEvent*                            EquipUISound;                                      // 0x0150(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UWwiseEvent*                            DropUISound;                                       // 0x0158(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TSubclassOf<class AInventoryItemPickup>       InventoryItemPickupClass;                          // 0x0160(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bReplicateActorInPickup;                           // 0x0168(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bSharedByPickups;                                  // 0x0169(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bMustMatchGameStageToShare;                        // 0x016A(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_16B[0x5];                                      // 0x016B(0x0005)(Fixing Size After Last Property [ Dumper-7 ])
	class FName                                   PickupFlyToTarget;                                 // 0x0170(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TArray<class FName>                           PickupHiddenBones;                                 // 0x0178(0x0010)(Edit, ZeroConstructor, NativeAccessSpecifierPublic)
	bool                                          bOverrideRotationInShop;                           // 0x0188(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_189[0x3];                                      // 0x0189(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	struct FRotator                               RotationInShop;                                    // 0x018C(0x000C)(Edit, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
	bool                                          bOverrideTranslationInShop;                        // 0x0198(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_199[0x3];                                      // 0x0199(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	struct FVector                                TranslationInShop;                                 // 0x019C(0x000C)(Edit, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bOverrideScaleInShop;                              // 0x01A8(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1A9[0x3];                                      // 0x01A9(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	struct FVector                                ScaleInShop;                                       // 0x01AC(0x000C)(Edit, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bOverrideRotationInContainer;                      // 0x01B8(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1B9[0x3];                                      // 0x01B9(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	struct FRotator                               RotationInContainer;                               // 0x01BC(0x000C)(Edit, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
	uint8                                         bCanBeHolsteredOnBody : 1;                         // 0x01C8(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (Edit, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         bCanShowHolsteredInFirstPerson : 1;                // 0x01C8(0x0001)(BitIndex: 0x01, PropSize: 0x0001 (Edit, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         Pad_1C9[0x7];                                      // 0x01C9(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	class FName                                   DefaultHolsterSocketName;                          // 0x01D0(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UInventoryCategoryData*                 InventoryCategory;                                 // 0x01D8(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EPlayerDroppability                           PlayerDroppability;                                // 0x01E0(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         SizeInInventory;                                   // 0x01E1(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1E2[0x6];                                      // 0x01E2(0x0006)(Fixing Size After Last Property [ Dumper-7 ])
	struct FAttributeInitializationData           MonetaryValue;                                     // 0x01E8(0x0038)(Edit, NoDestructor, NativeAccessSpecifierPublic)
	bool                                          bIgnoreShopPriceMarkup;                            // 0x0220(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bCalculatePriceInShopUsingPlayerAsContext;         // 0x0221(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_222[0x2];                                      // 0x0222(0x0002)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         BaseMonetaryValueModifier;                         // 0x0224(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bUsesInventoryScore;                               // 0x0228(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_229[0x7];                                      // 0x0229(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	class UObject*                                AssociatedCustomizationData;                       // 0x0230(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnTemplate, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_238[0x8];                                      // 0x0238(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	struct FTransform                             ThumbnailTransform;                                // 0x0240(0x0030)(Edit, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
	struct FTransform                             ItemInspectInitialTransform;                       // 0x0270(0x0030)(Edit, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
	struct FTransform                             ItemInspectInitialTransform_Vertical;              // 0x02A0(0x0030)(Edit, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
	struct FTransform                             ItemInspectInitialTransform_4way;                  // 0x02D0(0x0030)(Edit, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)

public:
	void EnumeratePickupFlyToTargets(TArray<class FName>* Targets) const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"InventoryData">();
	}
	static class UInventoryData* GetDefaultObj()
	{
		return GetDefaultObjImpl<UInventoryData>();
	}
};
static_assert(alignof(UInventoryData) == 0x000010, "Wrong alignment on UInventoryData");
static_assert(sizeof(UInventoryData) == 0x000300, "Wrong size on UInventoryData");
static_assert(offsetof(UInventoryData, InventoryName) == 0x000040, "Member 'UInventoryData::InventoryName' has a wrong offset!");
static_assert(offsetof(UInventoryData, PrefixPartList) == 0x000058, "Member 'UInventoryData::PrefixPartList' has a wrong offset!");
static_assert(offsetof(UInventoryData, TitlePartList) == 0x000068, "Member 'UInventoryData::TitlePartList' has a wrong offset!");
static_assert(offsetof(UInventoryData, SuffixPartList) == 0x000078, "Member 'UInventoryData::SuffixPartList' has a wrong offset!");
static_assert(offsetof(UInventoryData, NamingStrategy) == 0x000088, "Member 'UInventoryData::NamingStrategy' has a wrong offset!");
static_assert(offsetof(UInventoryData, InventoryActorClass) == 0x000090, "Member 'UInventoryData::InventoryActorClass' has a wrong offset!");
static_assert(offsetof(UInventoryData, InventoryAttributeEffects) == 0x000098, "Member 'UInventoryData::InventoryAttributeEffects' has a wrong offset!");
static_assert(offsetof(UInventoryData, InstigatorAttributeEffects) == 0x0000A8, "Member 'UInventoryData::InstigatorAttributeEffects' has a wrong offset!");
static_assert(offsetof(UInventoryData, AspectList) == 0x0000B8, "Member 'UInventoryData::AspectList' has a wrong offset!");
static_assert(offsetof(UInventoryData, StandaloneAspectList) == 0x0000C8, "Member 'UInventoryData::StandaloneAspectList' has a wrong offset!");
static_assert(offsetof(UInventoryData, bDisplayNameInInteractionHeader) == 0x0000D8, "Member 'UInventoryData::bDisplayNameInInteractionHeader' has a wrong offset!");
static_assert(offsetof(UInventoryData, bUsesItemCard) == 0x0000D9, "Member 'UInventoryData::bUsesItemCard' has a wrong offset!");
static_assert(offsetof(UInventoryData, ItemCardTypeFrameName) == 0x0000E0, "Member 'UInventoryData::ItemCardTypeFrameName' has a wrong offset!");
static_assert(offsetof(UInventoryData, OnUseConstraints) == 0x0000F0, "Member 'UInventoryData::OnUseConstraints' has a wrong offset!");
static_assert(offsetof(UInventoryData, bUsesPlayerLevelRequirement) == 0x000100, "Member 'UInventoryData::bUsesPlayerLevelRequirement' has a wrong offset!");
static_assert(offsetof(UInventoryData, UIStats) == 0x000108, "Member 'UInventoryData::UIStats' has a wrong offset!");
static_assert(offsetof(UInventoryData, AssetGuid) == 0x000118, "Member 'UInventoryData::AssetGuid' has a wrong offset!");
static_assert(offsetof(UInventoryData, PickupSound) == 0x000128, "Member 'UInventoryData::PickupSound' has a wrong offset!");
static_assert(offsetof(UInventoryData, PickupEquipSound) == 0x000130, "Member 'UInventoryData::PickupEquipSound' has a wrong offset!");
static_assert(offsetof(UInventoryData, SpottedCalloutCondition) == 0x000138, "Member 'UInventoryData::SpottedCalloutCondition' has a wrong offset!");
static_assert(offsetof(UInventoryData, SpottedCallout) == 0x000140, "Member 'UInventoryData::SpottedCallout' has a wrong offset!");
static_assert(offsetof(UInventoryData, PickupImpact) == 0x000148, "Member 'UInventoryData::PickupImpact' has a wrong offset!");
static_assert(offsetof(UInventoryData, EquipUISound) == 0x000150, "Member 'UInventoryData::EquipUISound' has a wrong offset!");
static_assert(offsetof(UInventoryData, DropUISound) == 0x000158, "Member 'UInventoryData::DropUISound' has a wrong offset!");
static_assert(offsetof(UInventoryData, InventoryItemPickupClass) == 0x000160, "Member 'UInventoryData::InventoryItemPickupClass' has a wrong offset!");
static_assert(offsetof(UInventoryData, bReplicateActorInPickup) == 0x000168, "Member 'UInventoryData::bReplicateActorInPickup' has a wrong offset!");
static_assert(offsetof(UInventoryData, bSharedByPickups) == 0x000169, "Member 'UInventoryData::bSharedByPickups' has a wrong offset!");
static_assert(offsetof(UInventoryData, bMustMatchGameStageToShare) == 0x00016A, "Member 'UInventoryData::bMustMatchGameStageToShare' has a wrong offset!");
static_assert(offsetof(UInventoryData, PickupFlyToTarget) == 0x000170, "Member 'UInventoryData::PickupFlyToTarget' has a wrong offset!");
static_assert(offsetof(UInventoryData, PickupHiddenBones) == 0x000178, "Member 'UInventoryData::PickupHiddenBones' has a wrong offset!");
static_assert(offsetof(UInventoryData, bOverrideRotationInShop) == 0x000188, "Member 'UInventoryData::bOverrideRotationInShop' has a wrong offset!");
static_assert(offsetof(UInventoryData, RotationInShop) == 0x00018C, "Member 'UInventoryData::RotationInShop' has a wrong offset!");
static_assert(offsetof(UInventoryData, bOverrideTranslationInShop) == 0x000198, "Member 'UInventoryData::bOverrideTranslationInShop' has a wrong offset!");
static_assert(offsetof(UInventoryData, TranslationInShop) == 0x00019C, "Member 'UInventoryData::TranslationInShop' has a wrong offset!");
static_assert(offsetof(UInventoryData, bOverrideScaleInShop) == 0x0001A8, "Member 'UInventoryData::bOverrideScaleInShop' has a wrong offset!");
static_assert(offsetof(UInventoryData, ScaleInShop) == 0x0001AC, "Member 'UInventoryData::ScaleInShop' has a wrong offset!");
static_assert(offsetof(UInventoryData, bOverrideRotationInContainer) == 0x0001B8, "Member 'UInventoryData::bOverrideRotationInContainer' has a wrong offset!");
static_assert(offsetof(UInventoryData, RotationInContainer) == 0x0001BC, "Member 'UInventoryData::RotationInContainer' has a wrong offset!");
static_assert(offsetof(UInventoryData, DefaultHolsterSocketName) == 0x0001D0, "Member 'UInventoryData::DefaultHolsterSocketName' has a wrong offset!");
static_assert(offsetof(UInventoryData, InventoryCategory) == 0x0001D8, "Member 'UInventoryData::InventoryCategory' has a wrong offset!");
static_assert(offsetof(UInventoryData, PlayerDroppability) == 0x0001E0, "Member 'UInventoryData::PlayerDroppability' has a wrong offset!");
static_assert(offsetof(UInventoryData, SizeInInventory) == 0x0001E1, "Member 'UInventoryData::SizeInInventory' has a wrong offset!");
static_assert(offsetof(UInventoryData, MonetaryValue) == 0x0001E8, "Member 'UInventoryData::MonetaryValue' has a wrong offset!");
static_assert(offsetof(UInventoryData, bIgnoreShopPriceMarkup) == 0x000220, "Member 'UInventoryData::bIgnoreShopPriceMarkup' has a wrong offset!");
static_assert(offsetof(UInventoryData, bCalculatePriceInShopUsingPlayerAsContext) == 0x000221, "Member 'UInventoryData::bCalculatePriceInShopUsingPlayerAsContext' has a wrong offset!");
static_assert(offsetof(UInventoryData, BaseMonetaryValueModifier) == 0x000224, "Member 'UInventoryData::BaseMonetaryValueModifier' has a wrong offset!");
static_assert(offsetof(UInventoryData, bUsesInventoryScore) == 0x000228, "Member 'UInventoryData::bUsesInventoryScore' has a wrong offset!");
static_assert(offsetof(UInventoryData, AssociatedCustomizationData) == 0x000230, "Member 'UInventoryData::AssociatedCustomizationData' has a wrong offset!");
static_assert(offsetof(UInventoryData, ThumbnailTransform) == 0x000240, "Member 'UInventoryData::ThumbnailTransform' has a wrong offset!");
static_assert(offsetof(UInventoryData, ItemInspectInitialTransform) == 0x000270, "Member 'UInventoryData::ItemInspectInitialTransform' has a wrong offset!");
static_assert(offsetof(UInventoryData, ItemInspectInitialTransform_Vertical) == 0x0002A0, "Member 'UInventoryData::ItemInspectInitialTransform_Vertical' has a wrong offset!");
static_assert(offsetof(UInventoryData, ItemInspectInitialTransform_4way) == 0x0002D0, "Member 'UInventoryData::ItemInspectInitialTransform_4way' has a wrong offset!");

// Class GbxInventory.DroppedInventoryItemPickup
// 0x0078 (0x0660 - 0x05E8)
class ADroppedInventoryItemPickup : public AInventoryItemPickup
{
public:
	float                                         LinearDamping;                                     // 0x05E8(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         NextImpactDistanceThreshold;                       // 0x05EC(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         NextImpactTimeThreshold;                           // 0x05F0(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         ImpactVelocityThreshold;                           // 0x05F4(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         DefaultVelocity;                                   // 0x05F8(0x0004)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	struct FVector_NetQuantize10                  DefaultAngularVelocity;                            // 0x05FC(0x000C)(Transient, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         InitialMassScale;                                  // 0x0608(0x0004)(Net, ZeroConstructor, Transient, IsPlainOldData, RepNotify, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	int32                                         DroppedQuantity;                                   // 0x060C(0x0004)(Net, ZeroConstructor, Transient, IsPlainOldData, RepNotify, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         ShrinkLifeSpan;                                    // 0x0610(0x0004)(Net, ZeroConstructor, Transient, IsPlainOldData, RepNotify, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_614[0xC];                                      // 0x0614(0x000C)(Fixing Size After Last Property [ Dumper-7 ])
	bool                                          bDroppedFromPlayerInventory;                       // 0x0620(0x0001)(Net, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_621[0x3F];                                     // 0x0621(0x003F)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void OnPhysicsSleep(class UPrimitiveComponent* WakingComponent, class FName BoneName);
	void OnPhysicsWake(class UPrimitiveComponent* WakingComponent, class FName BoneName);
	void OnPickupHit(class UPrimitiveComponent* HitComponent, class AActor* OtherActor, class UPrimitiveComponent* OtherComp, const struct FVector& NormalImpulse, const struct FHitResult& Hit);
	void OnRep_DroppedQuantity();
	void OnRep_InitialMassScale();
	void OnRep_ShrinkLifeSpan();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"DroppedInventoryItemPickup">();
	}
	static class ADroppedInventoryItemPickup* GetDefaultObj()
	{
		return GetDefaultObjImpl<ADroppedInventoryItemPickup>();
	}
};
static_assert(alignof(ADroppedInventoryItemPickup) == 0x000008, "Wrong alignment on ADroppedInventoryItemPickup");
static_assert(sizeof(ADroppedInventoryItemPickup) == 0x000660, "Wrong size on ADroppedInventoryItemPickup");
static_assert(offsetof(ADroppedInventoryItemPickup, LinearDamping) == 0x0005E8, "Member 'ADroppedInventoryItemPickup::LinearDamping' has a wrong offset!");
static_assert(offsetof(ADroppedInventoryItemPickup, NextImpactDistanceThreshold) == 0x0005EC, "Member 'ADroppedInventoryItemPickup::NextImpactDistanceThreshold' has a wrong offset!");
static_assert(offsetof(ADroppedInventoryItemPickup, NextImpactTimeThreshold) == 0x0005F0, "Member 'ADroppedInventoryItemPickup::NextImpactTimeThreshold' has a wrong offset!");
static_assert(offsetof(ADroppedInventoryItemPickup, ImpactVelocityThreshold) == 0x0005F4, "Member 'ADroppedInventoryItemPickup::ImpactVelocityThreshold' has a wrong offset!");
static_assert(offsetof(ADroppedInventoryItemPickup, DefaultVelocity) == 0x0005F8, "Member 'ADroppedInventoryItemPickup::DefaultVelocity' has a wrong offset!");
static_assert(offsetof(ADroppedInventoryItemPickup, DefaultAngularVelocity) == 0x0005FC, "Member 'ADroppedInventoryItemPickup::DefaultAngularVelocity' has a wrong offset!");
static_assert(offsetof(ADroppedInventoryItemPickup, InitialMassScale) == 0x000608, "Member 'ADroppedInventoryItemPickup::InitialMassScale' has a wrong offset!");
static_assert(offsetof(ADroppedInventoryItemPickup, DroppedQuantity) == 0x00060C, "Member 'ADroppedInventoryItemPickup::DroppedQuantity' has a wrong offset!");
static_assert(offsetof(ADroppedInventoryItemPickup, ShrinkLifeSpan) == 0x000610, "Member 'ADroppedInventoryItemPickup::ShrinkLifeSpan' has a wrong offset!");
static_assert(offsetof(ADroppedInventoryItemPickup, bDroppedFromPlayerInventory) == 0x000620, "Member 'ADroppedInventoryItemPickup::bDroppedFromPlayerInventory' has a wrong offset!");

// Class GbxInventory.PickupFlyToTargetInterface
// 0x0000 (0x0028 - 0x0028)
class IPickupFlyToTargetInterface final : public IInterface
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"PickupFlyToTargetInterface">();
	}
	static class IPickupFlyToTargetInterface* GetDefaultObj()
	{
		return GetDefaultObjImpl<IPickupFlyToTargetInterface>();
	}
};
static_assert(alignof(IPickupFlyToTargetInterface) == 0x000008, "Wrong alignment on IPickupFlyToTargetInterface");
static_assert(sizeof(IPickupFlyToTargetInterface) == 0x000028, "Wrong size on IPickupFlyToTargetInterface");

// Class GbxInventory.InventoryPartSetData
// 0x0028 (0x00A0 - 0x0078)
class UInventoryPartSetData : public UActorPartSetData
{
public:
	struct FInventoryGenericPartListData          GenericParts;                                      // 0x0078(0x0028)(Edit, Protected, NativeAccessSpecifierProtected)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"InventoryPartSetData">();
	}
	static class UInventoryPartSetData* GetDefaultObj()
	{
		return GetDefaultObjImpl<UInventoryPartSetData>();
	}
};
static_assert(alignof(UInventoryPartSetData) == 0x000008, "Wrong alignment on UInventoryPartSetData");
static_assert(sizeof(UInventoryPartSetData) == 0x0000A0, "Wrong size on UInventoryPartSetData");
static_assert(offsetof(UInventoryPartSetData, GenericParts) == 0x000078, "Member 'UInventoryPartSetData::GenericParts' has a wrong offset!");

// Class GbxInventory.InventoryData_Simple
// 0x0020 (0x0320 - 0x0300)
class UInventoryData_Simple : public UInventoryData
{
public:
	TSubclassOf<class UInventoryBalanceStateComponent> InventoryBalanceStateClass;                        // 0x0300(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UManufacturerData*                      ManufacturerData;                                  // 0x0308(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UInventoryRarityData*                   RarityData;                                        // 0x0310(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UInventoryBalanceData*                  BalanceData;                                       // 0x0318(0x0008)(Edit, ZeroConstructor, DisableEditOnTemplate, EditConst, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"InventoryData_Simple">();
	}
	static class UInventoryData_Simple* GetDefaultObj()
	{
		return GetDefaultObjImpl<UInventoryData_Simple>();
	}
};
static_assert(alignof(UInventoryData_Simple) == 0x000010, "Wrong alignment on UInventoryData_Simple");
static_assert(sizeof(UInventoryData_Simple) == 0x000320, "Wrong size on UInventoryData_Simple");
static_assert(offsetof(UInventoryData_Simple, InventoryBalanceStateClass) == 0x000300, "Member 'UInventoryData_Simple::InventoryBalanceStateClass' has a wrong offset!");
static_assert(offsetof(UInventoryData_Simple, ManufacturerData) == 0x000308, "Member 'UInventoryData_Simple::ManufacturerData' has a wrong offset!");
static_assert(offsetof(UInventoryData_Simple, RarityData) == 0x000310, "Member 'UInventoryData_Simple::RarityData' has a wrong offset!");
static_assert(offsetof(UInventoryData_Simple, BalanceData) == 0x000318, "Member 'UInventoryData_Simple::BalanceData' has a wrong offset!");

// Class GbxInventory.InventoryBalanceCollectionData
// 0x0028 (0x0058 - 0x0030)
class UInventoryBalanceCollectionData final : public UGbxDataAsset
{
public:
	class UInventoryBalanceCollectionData*        ParentCollection;                                  // 0x0030(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TArray<TSoftObjectPtr<class UInventoryBalanceData>> InventoryBalanceList;                              // 0x0038(0x0010)(Edit, ZeroConstructor, Protected, UObjectWrapper, NativeAccessSpecifierProtected)
	TArray<class UInventoryBalanceData*>          RuntimeInventoryBalanceList;                       // 0x0048(0x0010)(ZeroConstructor, Transient, Protected, NativeAccessSpecifierProtected)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"InventoryBalanceCollectionData">();
	}
	static class UInventoryBalanceCollectionData* GetDefaultObj()
	{
		return GetDefaultObjImpl<UInventoryBalanceCollectionData>();
	}
};
static_assert(alignof(UInventoryBalanceCollectionData) == 0x000008, "Wrong alignment on UInventoryBalanceCollectionData");
static_assert(sizeof(UInventoryBalanceCollectionData) == 0x000058, "Wrong size on UInventoryBalanceCollectionData");
static_assert(offsetof(UInventoryBalanceCollectionData, ParentCollection) == 0x000030, "Member 'UInventoryBalanceCollectionData::ParentCollection' has a wrong offset!");
static_assert(offsetof(UInventoryBalanceCollectionData, InventoryBalanceList) == 0x000038, "Member 'UInventoryBalanceCollectionData::InventoryBalanceList' has a wrong offset!");
static_assert(offsetof(UInventoryBalanceCollectionData, RuntimeInventoryBalanceList) == 0x000048, "Member 'UInventoryBalanceCollectionData::RuntimeInventoryBalanceList' has a wrong offset!");

// Class GbxInventory.DownloadableInventorySetData
// 0x0000 (0x0078 - 0x0078)
class UDownloadableInventorySetData : public UDownloadableContentData
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"DownloadableInventorySetData">();
	}
	static class UDownloadableInventorySetData* GetDefaultObj()
	{
		return GetDefaultObjImpl<UDownloadableInventorySetData>();
	}
};
static_assert(alignof(UDownloadableInventorySetData) == 0x000008, "Wrong alignment on UDownloadableInventorySetData");
static_assert(sizeof(UDownloadableInventorySetData) == 0x000078, "Wrong size on UDownloadableInventorySetData");

// Class GbxInventory.InventoryBlueprintLibrary
// 0x0000 (0x0028 - 0x0028)
class UInventoryBlueprintLibrary final : public UBlueprintFunctionLibrary
{
public:
	static class AActor* BuildInventory(class UObject* WorldContextObject, bool bCreatePickup, const struct FVector& SpawnLocation, const struct FInventoryBalanceStateInitializationData& InitData);
	static class AActor* CloneInventory(class AActor* SourceInventory);
	static class AActor* CreateInventory(class UObject* WorldContextObject, bool bCreatePickup, const struct FVector& SpawnLocation, const struct FInventoryBalanceStateInitializationData& InitData);
	static class UInventoryBalanceStateComponent* GetInventoryBalanceState(class AActor* Inventory);
	static TArray<class UInventoryGenericPartData*> GetPossibleGenericParts(class UInventoryBalanceStateComponent* InventoryBalanceState, const struct FGameplayTagContainer& Tags, bool bMustHaveAllTags, bool bExcludeCurrentlySelectedParts);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"InventoryBlueprintLibrary">();
	}
	static class UInventoryBlueprintLibrary* GetDefaultObj()
	{
		return GetDefaultObjImpl<UInventoryBlueprintLibrary>();
	}
};
static_assert(alignof(UInventoryBlueprintLibrary) == 0x000008, "Wrong alignment on UInventoryBlueprintLibrary");
static_assert(sizeof(UInventoryBlueprintLibrary) == 0x000028, "Wrong size on UInventoryBlueprintLibrary");

// Class GbxInventory.InventoryCustomizationPartData
// 0x0020 (0x0150 - 0x0130)
class UInventoryCustomizationPartData : public UGbxCustomizationData
{
public:
	uint8                                         Pad_130[0x8];                                      // 0x0130(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	struct FGuid                                  AssetGuid;                                         // 0x0138(0x0010)(IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	bool                                          bShouldRemovePartWhenDropped;                      // 0x0148(0x0001)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_149[0x7];                                      // 0x0149(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"InventoryCustomizationPartData">();
	}
	static class UInventoryCustomizationPartData* GetDefaultObj()
	{
		return GetDefaultObjImpl<UInventoryCustomizationPartData>();
	}
};
static_assert(alignof(UInventoryCustomizationPartData) == 0x000008, "Wrong alignment on UInventoryCustomizationPartData");
static_assert(sizeof(UInventoryCustomizationPartData) == 0x000150, "Wrong size on UInventoryCustomizationPartData");
static_assert(offsetof(UInventoryCustomizationPartData, AssetGuid) == 0x000138, "Member 'UInventoryCustomizationPartData::AssetGuid' has a wrong offset!");
static_assert(offsetof(UInventoryCustomizationPartData, bShouldRemovePartWhenDropped) == 0x000148, "Member 'UInventoryCustomizationPartData::bShouldRemovePartWhenDropped' has a wrong offset!");

// Class GbxInventory.PickupFlyToAbleInterface
// 0x0000 (0x0028 - 0x0028)
class IPickupFlyToAbleInterface final : public IInterface
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"PickupFlyToAbleInterface">();
	}
	static class IPickupFlyToAbleInterface* GetDefaultObj()
	{
		return GetDefaultObjImpl<IPickupFlyToAbleInterface>();
	}
};
static_assert(alignof(IPickupFlyToAbleInterface) == 0x000008, "Wrong alignment on IPickupFlyToAbleInterface");
static_assert(sizeof(IPickupFlyToAbleInterface) == 0x000028, "Wrong size on IPickupFlyToAbleInterface");

// Class GbxInventory.InventoryPartData
// 0x0150 (0x0250 - 0x0100)
class UInventoryPartData : public UActorPartData
{
public:
	uint8                                         Pad_100[0x8];                                      // 0x0100(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	struct FAttributeInitializationData           MonetaryValueModifier;                             // 0x0108(0x0038)(Edit, DisableEditOnTemplate, NoDestructor, Protected, NativeAccessSpecifierProtected)
	struct FAttributeInitializationData           InventoryScoreModifier;                            // 0x0140(0x0038)(Edit, DisableEditOnTemplate, NoDestructor, Protected, NativeAccessSpecifierProtected)
	TArray<class UInventoryNamePartData*>         PrefixPartList;                                    // 0x0178(0x0010)(Edit, ZeroConstructor, DisableEditOnTemplate, Protected, NativeAccessSpecifierProtected)
	TArray<class UInventoryNamePartData*>         TitlePartList;                                     // 0x0188(0x0010)(Edit, ZeroConstructor, DisableEditOnTemplate, Protected, NativeAccessSpecifierProtected)
	TArray<class UInventoryNamePartData*>         SuffixPartList;                                    // 0x0198(0x0010)(Edit, ZeroConstructor, DisableEditOnTemplate, Protected, NativeAccessSpecifierProtected)
	class FName                                   InventoryNamingTag;                                // 0x01A8(0x0008)(Edit, ZeroConstructor, DisableEditOnTemplate, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TArray<struct FAttributeEffectData>           InventoryAttributeEffects;                         // 0x01B0(0x0010)(Edit, ZeroConstructor, DisableEditOnTemplate, Protected, NativeAccessSpecifierProtected)
	TArray<struct FInstigatorAttributeEffectData> InstigatorAttributeEffects;                        // 0x01C0(0x0010)(Edit, ZeroConstructor, DisableEditOnTemplate, Protected, NativeAccessSpecifierProtected)
	TArray<struct FUIStatPriorityData>            UIStats;                                           // 0x01D0(0x0010)(Edit, ZeroConstructor, DisableEditOnTemplate, Protected, NativeAccessSpecifierProtected)
	bool                                          bAvailableForPartInspection;                       // 0x01E0(0x0001)(Edit, ZeroConstructor, DisableEditOnTemplate, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_1E1[0x7];                                      // 0x01E1(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<class UUIStatData_Text*>               PartInspectionTitleOverride;                       // 0x01E8(0x0010)(Edit, ZeroConstructor, DisableEditOnTemplate, Protected, NativeAccessSpecifierProtected)
	class UUIStatData_Text*                       PartInspectionDescription;                         // 0x01F8(0x0008)(Edit, ZeroConstructor, DisableEditOnTemplate, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bHideStatsForPartInspection;                       // 0x0200(0x0001)(Edit, ZeroConstructor, DisableEditOnTemplate, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_201[0x7];                                      // 0x0201(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<class UInventoryAspectData*>           AspectList;                                        // 0x0208(0x0010)(Edit, ExportObject, ZeroConstructor, DisableEditOnTemplate, ContainsInstancedReference, Protected, NativeAccessSpecifierProtected)
	class FString                                 GearBuilderDescription;                            // 0x0218(0x0010)(Edit, ZeroConstructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bShouldIgnorePartBoundsForPickupAttachment;        // 0x0228(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_229[0x7];                                      // 0x0229(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<class FName>                           ExcludedGestaltMeshPartNamesForItemInspectionAndThumbnailBounds; // 0x0230(0x0010)(Edit, ZeroConstructor, DisableEditOnTemplate, Protected, NativeAccessSpecifierProtected)
	struct FGuid                                  AssetGuid;                                         // 0x0240(0x0010)(IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)

public:
	const struct FAttributeInitializationData GetMonetaryValueModifier() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"InventoryPartData">();
	}
	static class UInventoryPartData* GetDefaultObj()
	{
		return GetDefaultObjImpl<UInventoryPartData>();
	}
};
static_assert(alignof(UInventoryPartData) == 0x000008, "Wrong alignment on UInventoryPartData");
static_assert(sizeof(UInventoryPartData) == 0x000250, "Wrong size on UInventoryPartData");
static_assert(offsetof(UInventoryPartData, MonetaryValueModifier) == 0x000108, "Member 'UInventoryPartData::MonetaryValueModifier' has a wrong offset!");
static_assert(offsetof(UInventoryPartData, InventoryScoreModifier) == 0x000140, "Member 'UInventoryPartData::InventoryScoreModifier' has a wrong offset!");
static_assert(offsetof(UInventoryPartData, PrefixPartList) == 0x000178, "Member 'UInventoryPartData::PrefixPartList' has a wrong offset!");
static_assert(offsetof(UInventoryPartData, TitlePartList) == 0x000188, "Member 'UInventoryPartData::TitlePartList' has a wrong offset!");
static_assert(offsetof(UInventoryPartData, SuffixPartList) == 0x000198, "Member 'UInventoryPartData::SuffixPartList' has a wrong offset!");
static_assert(offsetof(UInventoryPartData, InventoryNamingTag) == 0x0001A8, "Member 'UInventoryPartData::InventoryNamingTag' has a wrong offset!");
static_assert(offsetof(UInventoryPartData, InventoryAttributeEffects) == 0x0001B0, "Member 'UInventoryPartData::InventoryAttributeEffects' has a wrong offset!");
static_assert(offsetof(UInventoryPartData, InstigatorAttributeEffects) == 0x0001C0, "Member 'UInventoryPartData::InstigatorAttributeEffects' has a wrong offset!");
static_assert(offsetof(UInventoryPartData, UIStats) == 0x0001D0, "Member 'UInventoryPartData::UIStats' has a wrong offset!");
static_assert(offsetof(UInventoryPartData, bAvailableForPartInspection) == 0x0001E0, "Member 'UInventoryPartData::bAvailableForPartInspection' has a wrong offset!");
static_assert(offsetof(UInventoryPartData, PartInspectionTitleOverride) == 0x0001E8, "Member 'UInventoryPartData::PartInspectionTitleOverride' has a wrong offset!");
static_assert(offsetof(UInventoryPartData, PartInspectionDescription) == 0x0001F8, "Member 'UInventoryPartData::PartInspectionDescription' has a wrong offset!");
static_assert(offsetof(UInventoryPartData, bHideStatsForPartInspection) == 0x000200, "Member 'UInventoryPartData::bHideStatsForPartInspection' has a wrong offset!");
static_assert(offsetof(UInventoryPartData, AspectList) == 0x000208, "Member 'UInventoryPartData::AspectList' has a wrong offset!");
static_assert(offsetof(UInventoryPartData, GearBuilderDescription) == 0x000218, "Member 'UInventoryPartData::GearBuilderDescription' has a wrong offset!");
static_assert(offsetof(UInventoryPartData, bShouldIgnorePartBoundsForPickupAttachment) == 0x000228, "Member 'UInventoryPartData::bShouldIgnorePartBoundsForPickupAttachment' has a wrong offset!");
static_assert(offsetof(UInventoryPartData, ExcludedGestaltMeshPartNamesForItemInspectionAndThumbnailBounds) == 0x000230, "Member 'UInventoryPartData::ExcludedGestaltMeshPartNamesForItemInspectionAndThumbnailBounds' has a wrong offset!");
static_assert(offsetof(UInventoryPartData, AssetGuid) == 0x000240, "Member 'UInventoryPartData::AssetGuid' has a wrong offset!");

// Class GbxInventory.GearBuilderCategoryData
// 0x0008 (0x0038 - 0x0030)
class UGearBuilderCategoryData final : public UGbxDataAsset
{
public:
	class FName                                   CategoryName;                                      // 0x0030(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"GearBuilderCategoryData">();
	}
	static class UGearBuilderCategoryData* GetDefaultObj()
	{
		return GetDefaultObjImpl<UGearBuilderCategoryData>();
	}
};
static_assert(alignof(UGearBuilderCategoryData) == 0x000008, "Wrong alignment on UGearBuilderCategoryData");
static_assert(sizeof(UGearBuilderCategoryData) == 0x000038, "Wrong size on UGearBuilderCategoryData");
static_assert(offsetof(UGearBuilderCategoryData, CategoryName) == 0x000030, "Member 'UGearBuilderCategoryData::CategoryName' has a wrong offset!");

// Class GbxInventory.InventoryGenericPartData
// 0x0028 (0x0278 - 0x0250)
class UInventoryGenericPartData : public UInventoryPartData
{
public:
	bool                                          bOverridePartSelection;                            // 0x0250(0x0001)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_251[0x7];                                      // 0x0251(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	struct FGameplayTagContainer                  Tags;                                              // 0x0258(0x0020)(Edit, Protected, NativeAccessSpecifierProtected)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"InventoryGenericPartData">();
	}
	static class UInventoryGenericPartData* GetDefaultObj()
	{
		return GetDefaultObjImpl<UInventoryGenericPartData>();
	}
};
static_assert(alignof(UInventoryGenericPartData) == 0x000008, "Wrong alignment on UInventoryGenericPartData");
static_assert(sizeof(UInventoryGenericPartData) == 0x000278, "Wrong size on UInventoryGenericPartData");
static_assert(offsetof(UInventoryGenericPartData, bOverridePartSelection) == 0x000250, "Member 'UInventoryGenericPartData::bOverridePartSelection' has a wrong offset!");
static_assert(offsetof(UInventoryGenericPartData, Tags) == 0x000258, "Member 'UInventoryGenericPartData::Tags' has a wrong offset!");

// Class GbxInventory.InventoryNamingStrategyData
// 0x0000 (0x0030 - 0x0030)
class UInventoryNamingStrategyData : public UGbxDataAsset
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"InventoryNamingStrategyData">();
	}
	static class UInventoryNamingStrategyData* GetDefaultObj()
	{
		return GetDefaultObjImpl<UInventoryNamingStrategyData>();
	}
};
static_assert(alignof(UInventoryNamingStrategyData) == 0x000008, "Wrong alignment on UInventoryNamingStrategyData");
static_assert(sizeof(UInventoryNamingStrategyData) == 0x000030, "Wrong size on UInventoryNamingStrategyData");

// Class GbxInventory.ItemPoolListInterface
// 0x0010 (0x0040 - 0x0030)
class UItemPoolListInterface : public UGbxDataAsset
{
public:
	TArray<class UItemPoolPartSelectionOverrideData*> PartSelectionOverrides;                            // 0x0030(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Protected, NativeAccessSpecifierProtected)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"ItemPoolListInterface">();
	}
	static class UItemPoolListInterface* GetDefaultObj()
	{
		return GetDefaultObjImpl<UItemPoolListInterface>();
	}
};
static_assert(alignof(UItemPoolListInterface) == 0x000008, "Wrong alignment on UItemPoolListInterface");
static_assert(sizeof(UItemPoolListInterface) == 0x000040, "Wrong size on UItemPoolListInterface");
static_assert(offsetof(UItemPoolListInterface, PartSelectionOverrides) == 0x000030, "Member 'UItemPoolListInterface::PartSelectionOverrides' has a wrong offset!");

// Class GbxInventory.ItemPoolListData
// 0x0020 (0x0060 - 0x0040)
class UItemPoolListData final : public UItemPoolListInterface
{
public:
	TArray<class UItemPoolListData*>              ItemPoolIncludedLists;                             // 0x0040(0x0010)(Edit, ZeroConstructor, Protected, NativeAccessSpecifierProtected)
	TArray<struct FItemPoolInfo>                  ItemPools;                                         // 0x0050(0x0010)(Edit, ZeroConstructor, Protected, NativeAccessSpecifierProtected)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"ItemPoolListData">();
	}
	static class UItemPoolListData* GetDefaultObj()
	{
		return GetDefaultObjImpl<UItemPoolListData>();
	}
};
static_assert(alignof(UItemPoolListData) == 0x000008, "Wrong alignment on UItemPoolListData");
static_assert(sizeof(UItemPoolListData) == 0x000060, "Wrong size on UItemPoolListData");
static_assert(offsetof(UItemPoolListData, ItemPoolIncludedLists) == 0x000040, "Member 'UItemPoolListData::ItemPoolIncludedLists' has a wrong offset!");
static_assert(offsetof(UItemPoolListData, ItemPools) == 0x000050, "Member 'UItemPoolListData::ItemPools' has a wrong offset!");

// Class GbxInventory.InventoryRarityData
// 0x0118 (0x0148 - 0x0030)
class UInventoryRarityData : public UGbxDataAsset
{
public:
	struct FLinearColor                           RarityColorFX;                                     // 0x0030(0x0010)(Edit, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	struct FLinearColor                           RarityColorOutline;                                // 0x0040(0x0010)(Edit, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	int32                                         RarityOutlineDepthStencilValue;                    // 0x0050(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          DisplayRarityOutline;                              // 0x0054(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_55[0x3];                                       // 0x0055(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	class FString                                 RarityFrameName;                                   // 0x0058(0x0010)(Edit, ZeroConstructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	EDropLifeSpanType                             RarityLifeSpanType;                                // 0x0068(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_69[0x7];                                       // 0x0069(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	class FText                                   RarityDisplayname;                                 // 0x0070(0x0018)(Edit, Protected, NativeAccessSpecifierProtected)
	int32                                         RaritySortValue;                                   // 0x0088(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_8C[0x4];                                       // 0x008C(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class UParticleSystem*                        RarityLootBeamOverride;                            // 0x0090(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UParticleSystem*                        RarityLootBeamForInventoryWithFoilParts;           // 0x0098(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         RarityLootBeamHeight;                              // 0x00A0(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_A4[0x4];                                       // 0x00A4(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	struct FAttributeInitializationData           ItemScoreRarityModifier;                           // 0x00A8(0x0038)(Edit, BlueprintVisible, BlueprintReadOnly, NoDestructor, Protected, NativeAccessSpecifierProtected)
	class UWwiseEvent*                            RarityLootAudioStinger;                            // 0x00E0(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	struct FAttributeInitializationData           MonetaryValueModifier;                             // 0x00E8(0x0038)(Edit, DisableEditOnTemplate, NoDestructor, Protected, NativeAccessSpecifierProtected)
	TSoftObjectPtr<class UGameStatData>           OnPickedUpStat;                                    // 0x0120(0x0028)(Edit, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)

public:
	bool GetDisplayRarityOutline() const;
	const struct FAttributeInitializationData GetItemScoreRarityModifier() const;
	struct FLinearColor GetRarityColorFX() const;
	struct FLinearColor GetRarityColorOutline() const;
	const class FText GetRarityDisplayName() const;
	float GetRarityLifeSpan() const;
	EDropLifeSpanType GetRarityLifeSpanType() const;
	class UWwiseEvent* GetRarityLootAudioStinger() const;
	float GetRarityLootBeamHeight() const;
	class UParticleSystem* GetRarityLootBeamOverride(bool bInventoryHasAFoilPart) const;
	int32 GetRarityOutlineDepthStencilValue() const;
	int32 GetRaritySortValue() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"InventoryRarityData">();
	}
	static class UInventoryRarityData* GetDefaultObj()
	{
		return GetDefaultObjImpl<UInventoryRarityData>();
	}
};
static_assert(alignof(UInventoryRarityData) == 0x000008, "Wrong alignment on UInventoryRarityData");
static_assert(sizeof(UInventoryRarityData) == 0x000148, "Wrong size on UInventoryRarityData");
static_assert(offsetof(UInventoryRarityData, RarityColorFX) == 0x000030, "Member 'UInventoryRarityData::RarityColorFX' has a wrong offset!");
static_assert(offsetof(UInventoryRarityData, RarityColorOutline) == 0x000040, "Member 'UInventoryRarityData::RarityColorOutline' has a wrong offset!");
static_assert(offsetof(UInventoryRarityData, RarityOutlineDepthStencilValue) == 0x000050, "Member 'UInventoryRarityData::RarityOutlineDepthStencilValue' has a wrong offset!");
static_assert(offsetof(UInventoryRarityData, DisplayRarityOutline) == 0x000054, "Member 'UInventoryRarityData::DisplayRarityOutline' has a wrong offset!");
static_assert(offsetof(UInventoryRarityData, RarityFrameName) == 0x000058, "Member 'UInventoryRarityData::RarityFrameName' has a wrong offset!");
static_assert(offsetof(UInventoryRarityData, RarityLifeSpanType) == 0x000068, "Member 'UInventoryRarityData::RarityLifeSpanType' has a wrong offset!");
static_assert(offsetof(UInventoryRarityData, RarityDisplayname) == 0x000070, "Member 'UInventoryRarityData::RarityDisplayname' has a wrong offset!");
static_assert(offsetof(UInventoryRarityData, RaritySortValue) == 0x000088, "Member 'UInventoryRarityData::RaritySortValue' has a wrong offset!");
static_assert(offsetof(UInventoryRarityData, RarityLootBeamOverride) == 0x000090, "Member 'UInventoryRarityData::RarityLootBeamOverride' has a wrong offset!");
static_assert(offsetof(UInventoryRarityData, RarityLootBeamForInventoryWithFoilParts) == 0x000098, "Member 'UInventoryRarityData::RarityLootBeamForInventoryWithFoilParts' has a wrong offset!");
static_assert(offsetof(UInventoryRarityData, RarityLootBeamHeight) == 0x0000A0, "Member 'UInventoryRarityData::RarityLootBeamHeight' has a wrong offset!");
static_assert(offsetof(UInventoryRarityData, ItemScoreRarityModifier) == 0x0000A8, "Member 'UInventoryRarityData::ItemScoreRarityModifier' has a wrong offset!");
static_assert(offsetof(UInventoryRarityData, RarityLootAudioStinger) == 0x0000E0, "Member 'UInventoryRarityData::RarityLootAudioStinger' has a wrong offset!");
static_assert(offsetof(UInventoryRarityData, MonetaryValueModifier) == 0x0000E8, "Member 'UInventoryRarityData::MonetaryValueModifier' has a wrong offset!");
static_assert(offsetof(UInventoryRarityData, OnPickedUpStat) == 0x000120, "Member 'UInventoryRarityData::OnPickedUpStat' has a wrong offset!");

// Class GbxInventory.ItemPoolData
// 0x0088 (0x00C8 - 0x0040)
class UItemPoolData : public UItemPoolListInterface
{
public:
	uint8                                         Pad_40[0x8];                                       // 0x0040(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<struct FBalancedInventoryInfo>         BalancedItems;                                     // 0x0048(0x0010)(Edit, ZeroConstructor, Protected, NativeAccessSpecifierProtected)
	bool                                          bSupportsGameStageVariance;                        // 0x0058(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_59[0x7];                                       // 0x0059(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	struct FAttributeInitializationData           Quantity;                                          // 0x0060(0x0038)(Edit, NoDestructor, Protected, NativeAccessSpecifierProtected)
	class UGbxAttributeData*                      MinGameStageRequirement;                           // 0x0098(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UGbxAttributeData*                      MaxGameStageRequirement;                           // 0x00A0(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TArray<class UItemPoolExpansionData*>         Expansions;                                        // 0x00A8(0x0010)(ZeroConstructor, Transient, Protected, NativeAccessSpecifierProtected)
	struct FGuid                                  AssetGuid;                                         // 0x00B8(0x0010)(DuplicateTransient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"ItemPoolData">();
	}
	static class UItemPoolData* GetDefaultObj()
	{
		return GetDefaultObjImpl<UItemPoolData>();
	}
};
static_assert(alignof(UItemPoolData) == 0x000008, "Wrong alignment on UItemPoolData");
static_assert(sizeof(UItemPoolData) == 0x0000C8, "Wrong size on UItemPoolData");
static_assert(offsetof(UItemPoolData, BalancedItems) == 0x000048, "Member 'UItemPoolData::BalancedItems' has a wrong offset!");
static_assert(offsetof(UItemPoolData, bSupportsGameStageVariance) == 0x000058, "Member 'UItemPoolData::bSupportsGameStageVariance' has a wrong offset!");
static_assert(offsetof(UItemPoolData, Quantity) == 0x000060, "Member 'UItemPoolData::Quantity' has a wrong offset!");
static_assert(offsetof(UItemPoolData, MinGameStageRequirement) == 0x000098, "Member 'UItemPoolData::MinGameStageRequirement' has a wrong offset!");
static_assert(offsetof(UItemPoolData, MaxGameStageRequirement) == 0x0000A0, "Member 'UItemPoolData::MaxGameStageRequirement' has a wrong offset!");
static_assert(offsetof(UItemPoolData, Expansions) == 0x0000A8, "Member 'UItemPoolData::Expansions' has a wrong offset!");
static_assert(offsetof(UItemPoolData, AssetGuid) == 0x0000B8, "Member 'UItemPoolData::AssetGuid' has a wrong offset!");

// Class GbxInventory.InventoryMaterialAspectData
// 0x0080 (0x00B8 - 0x0038)
class UInventoryMaterialAspectData : public UInventoryAspectData
{
public:
	class FName                                   PrimitiveComponentName;                            // 0x0038(0x0008)(Edit, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class FName                                   PrimitiveComponentTag;                             // 0x0040(0x0008)(Edit, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	int32                                         SectionIndex;                                      // 0x0048(0x0004)(Edit, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_4C[0x4];                                       // 0x004C(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class UMaterialInterface*                     Material;                                          // 0x0050(0x0008)(Edit, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TArray<struct FRarityMaterialData>            RaritySpecificMaterials;                           // 0x0058(0x0010)(Edit, BlueprintReadOnly, ZeroConstructor, Protected, NativeAccessSpecifierProtected)
	TArray<struct FMaterialVectorParameterData>   VectorParameters;                                  // 0x0068(0x0010)(Edit, BlueprintReadOnly, ZeroConstructor, Protected, NativeAccessSpecifierProtected)
	TArray<struct FMaterialScalarParameterData>   ScalarParameters;                                  // 0x0078(0x0010)(Edit, BlueprintReadOnly, ZeroConstructor, Protected, NativeAccessSpecifierProtected)
	TArray<struct FMaterialTextureParameterData>  TextureParameters;                                 // 0x0088(0x0010)(Edit, BlueprintReadOnly, ZeroConstructor, Protected, NativeAccessSpecifierProtected)
	TArray<struct FMaterialTextureAssetParameterData> TextureAssetParameters;                            // 0x0098(0x0010)(Edit, BlueprintReadOnly, ZeroConstructor, Protected, NativeAccessSpecifierProtected)
	TArray<struct FMaterialFontParameterData>     FontParameters;                                    // 0x00A8(0x0010)(Edit, BlueprintReadOnly, ZeroConstructor, Protected, NativeAccessSpecifierProtected)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"InventoryMaterialAspectData">();
	}
	static class UInventoryMaterialAspectData* GetDefaultObj()
	{
		return GetDefaultObjImpl<UInventoryMaterialAspectData>();
	}
};
static_assert(alignof(UInventoryMaterialAspectData) == 0x000008, "Wrong alignment on UInventoryMaterialAspectData");
static_assert(sizeof(UInventoryMaterialAspectData) == 0x0000B8, "Wrong size on UInventoryMaterialAspectData");
static_assert(offsetof(UInventoryMaterialAspectData, PrimitiveComponentName) == 0x000038, "Member 'UInventoryMaterialAspectData::PrimitiveComponentName' has a wrong offset!");
static_assert(offsetof(UInventoryMaterialAspectData, PrimitiveComponentTag) == 0x000040, "Member 'UInventoryMaterialAspectData::PrimitiveComponentTag' has a wrong offset!");
static_assert(offsetof(UInventoryMaterialAspectData, SectionIndex) == 0x000048, "Member 'UInventoryMaterialAspectData::SectionIndex' has a wrong offset!");
static_assert(offsetof(UInventoryMaterialAspectData, Material) == 0x000050, "Member 'UInventoryMaterialAspectData::Material' has a wrong offset!");
static_assert(offsetof(UInventoryMaterialAspectData, RaritySpecificMaterials) == 0x000058, "Member 'UInventoryMaterialAspectData::RaritySpecificMaterials' has a wrong offset!");
static_assert(offsetof(UInventoryMaterialAspectData, VectorParameters) == 0x000068, "Member 'UInventoryMaterialAspectData::VectorParameters' has a wrong offset!");
static_assert(offsetof(UInventoryMaterialAspectData, ScalarParameters) == 0x000078, "Member 'UInventoryMaterialAspectData::ScalarParameters' has a wrong offset!");
static_assert(offsetof(UInventoryMaterialAspectData, TextureParameters) == 0x000088, "Member 'UInventoryMaterialAspectData::TextureParameters' has a wrong offset!");
static_assert(offsetof(UInventoryMaterialAspectData, TextureAssetParameters) == 0x000098, "Member 'UInventoryMaterialAspectData::TextureAssetParameters' has a wrong offset!");
static_assert(offsetof(UInventoryMaterialAspectData, FontParameters) == 0x0000A8, "Member 'UInventoryMaterialAspectData::FontParameters' has a wrong offset!");

// Class GbxInventory.InventoryAttributeEffectsAspectData
// 0x0038 (0x0070 - 0x0038)
class UInventoryAttributeEffectsAspectData : public UInventoryAspectData
{
public:
	struct FGameplayTagContainer                  ComparisonTags;                                    // 0x0038(0x0020)(Edit, BlueprintReadOnly, DisableEditOnTemplate, Protected, NativeAccessSpecifierProtected)
	bool                                          bResetAttributes;                                  // 0x0058(0x0001)(Edit, BlueprintReadOnly, ZeroConstructor, DisableEditOnTemplate, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_59[0x7];                                       // 0x0059(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<struct FAttributeEffectData>           InventoryAttributeEffects;                         // 0x0060(0x0010)(Edit, BlueprintReadOnly, ZeroConstructor, DisableEditOnTemplate, Protected, NativeAccessSpecifierProtected)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"InventoryAttributeEffectsAspectData">();
	}
	static class UInventoryAttributeEffectsAspectData* GetDefaultObj()
	{
		return GetDefaultObjImpl<UInventoryAttributeEffectsAspectData>();
	}
};
static_assert(alignof(UInventoryAttributeEffectsAspectData) == 0x000008, "Wrong alignment on UInventoryAttributeEffectsAspectData");
static_assert(sizeof(UInventoryAttributeEffectsAspectData) == 0x000070, "Wrong size on UInventoryAttributeEffectsAspectData");
static_assert(offsetof(UInventoryAttributeEffectsAspectData, ComparisonTags) == 0x000038, "Member 'UInventoryAttributeEffectsAspectData::ComparisonTags' has a wrong offset!");
static_assert(offsetof(UInventoryAttributeEffectsAspectData, bResetAttributes) == 0x000058, "Member 'UInventoryAttributeEffectsAspectData::bResetAttributes' has a wrong offset!");
static_assert(offsetof(UInventoryAttributeEffectsAspectData, InventoryAttributeEffects) == 0x000060, "Member 'UInventoryAttributeEffectsAspectData::InventoryAttributeEffects' has a wrong offset!");

// Class GbxInventory.GbxCondition_InventoryRarityComparison
// 0x0010 (0x0098 - 0x0088)
class UGbxCondition_InventoryRarityComparison final : public UGbxCondition
{
public:
	EConditionComparisonOperatorType              Operator;                                          // 0x0088(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_89[0x7];                                       // 0x0089(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	class UInventoryRarityData*                   ReferenceRarity;                                   // 0x0090(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"GbxCondition_InventoryRarityComparison">();
	}
	static class UGbxCondition_InventoryRarityComparison* GetDefaultObj()
	{
		return GetDefaultObjImpl<UGbxCondition_InventoryRarityComparison>();
	}
};
static_assert(alignof(UGbxCondition_InventoryRarityComparison) == 0x000008, "Wrong alignment on UGbxCondition_InventoryRarityComparison");
static_assert(sizeof(UGbxCondition_InventoryRarityComparison) == 0x000098, "Wrong size on UGbxCondition_InventoryRarityComparison");
static_assert(offsetof(UGbxCondition_InventoryRarityComparison, Operator) == 0x000088, "Member 'UGbxCondition_InventoryRarityComparison::Operator' has a wrong offset!");
static_assert(offsetof(UGbxCondition_InventoryRarityComparison, ReferenceRarity) == 0x000090, "Member 'UGbxCondition_InventoryRarityComparison::ReferenceRarity' has a wrong offset!");

// Class GbxInventory.GearBuilderWidget
// 0x0188 (0x0288 - 0x0100)
class UGearBuilderWidget final : public UWidget
{
public:
	class UGearBuilderDebugMenu*                  OwnerMenu;                                         // 0x0100(0x0008)(ExportObject, ZeroConstructor, Transient, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_108[0x20];                                     // 0x0108(0x0020)(Fixing Size After Last Property [ Dumper-7 ])
	struct FInventoryBalanceStateInitializationData GearData;                                          // 0x0128(0x0068)(Transient, Protected, NativeAccessSpecifierProtected)
	TWeakObjectPtr<class UObject>                 SelectedItem;                                      // 0x0190(0x0008)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_198[0xF0];                                     // 0x0198(0x00F0)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"GearBuilderWidget">();
	}
	static class UGearBuilderWidget* GetDefaultObj()
	{
		return GetDefaultObjImpl<UGearBuilderWidget>();
	}
};
static_assert(alignof(UGearBuilderWidget) == 0x000008, "Wrong alignment on UGearBuilderWidget");
static_assert(sizeof(UGearBuilderWidget) == 0x000288, "Wrong size on UGearBuilderWidget");
static_assert(offsetof(UGearBuilderWidget, OwnerMenu) == 0x000100, "Member 'UGearBuilderWidget::OwnerMenu' has a wrong offset!");
static_assert(offsetof(UGearBuilderWidget, GearData) == 0x000128, "Member 'UGearBuilderWidget::GearData' has a wrong offset!");
static_assert(offsetof(UGearBuilderWidget, SelectedItem) == 0x000190, "Member 'UGearBuilderWidget::SelectedItem' has a wrong offset!");

// Class GbxInventory.GearBuilderDebugMenu
// 0x0008 (0x0300 - 0x02F8)
class UGearBuilderDebugMenu final : public UGbxDebugMenuSubmenu
{
public:
	class UGearBuilderWidget*                     GearBuilder;                                       // 0x02F8(0x0008)(BlueprintVisible, ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"GearBuilderDebugMenu">();
	}
	static class UGearBuilderDebugMenu* GetDefaultObj()
	{
		return GetDefaultObjImpl<UGearBuilderDebugMenu>();
	}
};
static_assert(alignof(UGearBuilderDebugMenu) == 0x000008, "Wrong alignment on UGearBuilderDebugMenu");
static_assert(sizeof(UGearBuilderDebugMenu) == 0x000300, "Wrong size on UGearBuilderDebugMenu");
static_assert(offsetof(UGearBuilderDebugMenu, GearBuilder) == 0x0002F8, "Member 'UGearBuilderDebugMenu::GearBuilder' has a wrong offset!");

// Class GbxInventory.InventoryBalanceData_Generated
// 0x0000 (0x0128 - 0x0128)
class UInventoryBalanceData_Generated final : public UInventoryBalanceData
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"InventoryBalanceData_Generated">();
	}
	static class UInventoryBalanceData_Generated* GetDefaultObj()
	{
		return GetDefaultObjImpl<UInventoryBalanceData_Generated>();
	}
};
static_assert(alignof(UInventoryBalanceData_Generated) == 0x000008, "Wrong alignment on UInventoryBalanceData_Generated");
static_assert(sizeof(UInventoryBalanceData_Generated) == 0x000128, "Wrong size on UInventoryBalanceData_Generated");

// Class GbxInventory.InventoryCategoryData
// 0x0038 (0x0070 - 0x0038)
class UInventoryCategoryData final : public UGbxInventoryCategoryData
{
public:
	bool                                          NotAddedToInventory;                               // 0x0038(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EPickupActionType                             PickupActionType;                                  // 0x0039(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          SharedWithAllPlayers;                              // 0x003A(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bSharedPlayersMustBeOnFriendlyTeam;                // 0x003B(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bLevelSyncPickupCurrency;                          // 0x003C(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          ManualActivation;                                  // 0x003D(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_3E[0x2];                                       // 0x003E(0x0002)(Fixing Size After Last Property [ Dumper-7 ])
	class FText                                   CategoryDisplayName;                               // 0x0040(0x0018)(Edit, NativeAccessSpecifierPublic)
	bool                                          bCanInspectItem;                                   // 0x0058(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bCanInspectManufacturer;                           // 0x0059(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bCanInspectElementalEffects;                       // 0x005A(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bCanInspectParts;                                  // 0x005B(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bCanChangeSkins;                                   // 0x005C(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bUseEquipAudioFromWeaponType;                      // 0x005D(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bDoNotUseCosmeticLabelInBackpackCells;             // 0x005E(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_5F[0x1];                                       // 0x005F(0x0001)(Fixing Size After Last Property [ Dumper-7 ])
	class FName                                   EquipAudioEventName;                               // 0x0060(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bEnableSaveGameQuantityChangeThrottling;           // 0x0068(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_69[0x7];                                       // 0x0069(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"InventoryCategoryData">();
	}
	static class UInventoryCategoryData* GetDefaultObj()
	{
		return GetDefaultObjImpl<UInventoryCategoryData>();
	}
};
static_assert(alignof(UInventoryCategoryData) == 0x000008, "Wrong alignment on UInventoryCategoryData");
static_assert(sizeof(UInventoryCategoryData) == 0x000070, "Wrong size on UInventoryCategoryData");
static_assert(offsetof(UInventoryCategoryData, NotAddedToInventory) == 0x000038, "Member 'UInventoryCategoryData::NotAddedToInventory' has a wrong offset!");
static_assert(offsetof(UInventoryCategoryData, PickupActionType) == 0x000039, "Member 'UInventoryCategoryData::PickupActionType' has a wrong offset!");
static_assert(offsetof(UInventoryCategoryData, SharedWithAllPlayers) == 0x00003A, "Member 'UInventoryCategoryData::SharedWithAllPlayers' has a wrong offset!");
static_assert(offsetof(UInventoryCategoryData, bSharedPlayersMustBeOnFriendlyTeam) == 0x00003B, "Member 'UInventoryCategoryData::bSharedPlayersMustBeOnFriendlyTeam' has a wrong offset!");
static_assert(offsetof(UInventoryCategoryData, bLevelSyncPickupCurrency) == 0x00003C, "Member 'UInventoryCategoryData::bLevelSyncPickupCurrency' has a wrong offset!");
static_assert(offsetof(UInventoryCategoryData, ManualActivation) == 0x00003D, "Member 'UInventoryCategoryData::ManualActivation' has a wrong offset!");
static_assert(offsetof(UInventoryCategoryData, CategoryDisplayName) == 0x000040, "Member 'UInventoryCategoryData::CategoryDisplayName' has a wrong offset!");
static_assert(offsetof(UInventoryCategoryData, bCanInspectItem) == 0x000058, "Member 'UInventoryCategoryData::bCanInspectItem' has a wrong offset!");
static_assert(offsetof(UInventoryCategoryData, bCanInspectManufacturer) == 0x000059, "Member 'UInventoryCategoryData::bCanInspectManufacturer' has a wrong offset!");
static_assert(offsetof(UInventoryCategoryData, bCanInspectElementalEffects) == 0x00005A, "Member 'UInventoryCategoryData::bCanInspectElementalEffects' has a wrong offset!");
static_assert(offsetof(UInventoryCategoryData, bCanInspectParts) == 0x00005B, "Member 'UInventoryCategoryData::bCanInspectParts' has a wrong offset!");
static_assert(offsetof(UInventoryCategoryData, bCanChangeSkins) == 0x00005C, "Member 'UInventoryCategoryData::bCanChangeSkins' has a wrong offset!");
static_assert(offsetof(UInventoryCategoryData, bUseEquipAudioFromWeaponType) == 0x00005D, "Member 'UInventoryCategoryData::bUseEquipAudioFromWeaponType' has a wrong offset!");
static_assert(offsetof(UInventoryCategoryData, bDoNotUseCosmeticLabelInBackpackCells) == 0x00005E, "Member 'UInventoryCategoryData::bDoNotUseCosmeticLabelInBackpackCells' has a wrong offset!");
static_assert(offsetof(UInventoryCategoryData, EquipAudioEventName) == 0x000060, "Member 'UInventoryCategoryData::EquipAudioEventName' has a wrong offset!");
static_assert(offsetof(UInventoryCategoryData, bEnableSaveGameQuantityChangeThrottling) == 0x000068, "Member 'UInventoryCategoryData::bEnableSaveGameQuantityChangeThrottling' has a wrong offset!");

// Class GbxInventory.InventoryConditionalDamageAspectData
// 0x0010 (0x0048 - 0x0038)
class UInventoryConditionalDamageAspectData final : public UInventoryAspectData
{
public:
	TArray<struct FInventoryConditionalDamageAspectInfo> DamageConditionals;                                // 0x0038(0x0010)(Edit, BlueprintReadOnly, ZeroConstructor, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"InventoryConditionalDamageAspectData">();
	}
	static class UInventoryConditionalDamageAspectData* GetDefaultObj()
	{
		return GetDefaultObjImpl<UInventoryConditionalDamageAspectData>();
	}
};
static_assert(alignof(UInventoryConditionalDamageAspectData) == 0x000008, "Wrong alignment on UInventoryConditionalDamageAspectData");
static_assert(sizeof(UInventoryConditionalDamageAspectData) == 0x000048, "Wrong size on UInventoryConditionalDamageAspectData");
static_assert(offsetof(UInventoryConditionalDamageAspectData, DamageConditionals) == 0x000038, "Member 'UInventoryConditionalDamageAspectData::DamageConditionals' has a wrong offset!");

// Class GbxInventory.InventoryMaterialAspectTextureAssetStreamer
// 0x0020 (0x0048 - 0x0028)
class UInventoryMaterialAspectTextureAssetStreamer final : public UObject
{
public:
	uint8                                         Pad_28[0x20];                                      // 0x0028(0x0020)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"InventoryMaterialAspectTextureAssetStreamer">();
	}
	static class UInventoryMaterialAspectTextureAssetStreamer* GetDefaultObj()
	{
		return GetDefaultObjImpl<UInventoryMaterialAspectTextureAssetStreamer>();
	}
};
static_assert(alignof(UInventoryMaterialAspectTextureAssetStreamer) == 0x000008, "Wrong alignment on UInventoryMaterialAspectTextureAssetStreamer");
static_assert(sizeof(UInventoryMaterialAspectTextureAssetStreamer) == 0x000048, "Wrong size on UInventoryMaterialAspectTextureAssetStreamer");

// Class GbxInventory.InventoryModuleSettings
// 0x0030 (0x0058 - 0x0028)
class UInventoryModuleSettings final : public UObject
{
public:
	TSubclassOf<class ADroppedInventoryItemPickup> DefaultDroppedPickupBlueprint;                     // 0x0028(0x0008)(Edit, ZeroConstructor, Config, IsPlainOldData, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         VeryShortLivedDropLifeSpan;                        // 0x0030(0x0004)(Edit, ZeroConstructor, Config, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         ShortLivedDropLifeSpan;                            // 0x0034(0x0004)(Edit, ZeroConstructor, Config, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         LongLivedDropLifeSpan;                             // 0x0038(0x0004)(Edit, ZeroConstructor, Config, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         PickupShrinkDuration;                              // 0x003C(0x0004)(Edit, ZeroConstructor, Config, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         ResetBumpOnPickupFailDelay;                        // 0x0040(0x0004)(Edit, ZeroConstructor, Config, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_44[0x4];                                       // 0x0044(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<class FName>                           PickupFlyToTargets;                                // 0x0048(0x0010)(Edit, ZeroConstructor, Config, Protected, NativeAccessSpecifierProtected)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"InventoryModuleSettings">();
	}
	static class UInventoryModuleSettings* GetDefaultObj()
	{
		return GetDefaultObjImpl<UInventoryModuleSettings>();
	}
};
static_assert(alignof(UInventoryModuleSettings) == 0x000008, "Wrong alignment on UInventoryModuleSettings");
static_assert(sizeof(UInventoryModuleSettings) == 0x000058, "Wrong size on UInventoryModuleSettings");
static_assert(offsetof(UInventoryModuleSettings, DefaultDroppedPickupBlueprint) == 0x000028, "Member 'UInventoryModuleSettings::DefaultDroppedPickupBlueprint' has a wrong offset!");
static_assert(offsetof(UInventoryModuleSettings, VeryShortLivedDropLifeSpan) == 0x000030, "Member 'UInventoryModuleSettings::VeryShortLivedDropLifeSpan' has a wrong offset!");
static_assert(offsetof(UInventoryModuleSettings, ShortLivedDropLifeSpan) == 0x000034, "Member 'UInventoryModuleSettings::ShortLivedDropLifeSpan' has a wrong offset!");
static_assert(offsetof(UInventoryModuleSettings, LongLivedDropLifeSpan) == 0x000038, "Member 'UInventoryModuleSettings::LongLivedDropLifeSpan' has a wrong offset!");
static_assert(offsetof(UInventoryModuleSettings, PickupShrinkDuration) == 0x00003C, "Member 'UInventoryModuleSettings::PickupShrinkDuration' has a wrong offset!");
static_assert(offsetof(UInventoryModuleSettings, ResetBumpOnPickupFailDelay) == 0x000040, "Member 'UInventoryModuleSettings::ResetBumpOnPickupFailDelay' has a wrong offset!");
static_assert(offsetof(UInventoryModuleSettings, PickupFlyToTargets) == 0x000048, "Member 'UInventoryModuleSettings::PickupFlyToTargets' has a wrong offset!");

// Class GbxInventory.InventoryNamePartData
// 0x0030 (0x0060 - 0x0030)
class UInventoryNamePartData final : public UGbxDataAsset
{
public:
	class FText                                   PartName;                                          // 0x0030(0x0018)(Edit, Protected, NativeAccessSpecifierProtected)
	float                                         Priority;                                          // 0x0048(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_4C[0x4];                                       // 0x004C(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class UGbxCondition*                          Condition;                                         // 0x0050(0x0008)(Edit, ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, PersistentInstance, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	int32                                         MinExperienceLevel;                                // 0x0058(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	int32                                         MaxExperienceLevel;                                // 0x005C(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"InventoryNamePartData">();
	}
	static class UInventoryNamePartData* GetDefaultObj()
	{
		return GetDefaultObjImpl<UInventoryNamePartData>();
	}
};
static_assert(alignof(UInventoryNamePartData) == 0x000008, "Wrong alignment on UInventoryNamePartData");
static_assert(sizeof(UInventoryNamePartData) == 0x000060, "Wrong size on UInventoryNamePartData");
static_assert(offsetof(UInventoryNamePartData, PartName) == 0x000030, "Member 'UInventoryNamePartData::PartName' has a wrong offset!");
static_assert(offsetof(UInventoryNamePartData, Priority) == 0x000048, "Member 'UInventoryNamePartData::Priority' has a wrong offset!");
static_assert(offsetof(UInventoryNamePartData, Condition) == 0x000050, "Member 'UInventoryNamePartData::Condition' has a wrong offset!");
static_assert(offsetof(UInventoryNamePartData, MinExperienceLevel) == 0x000058, "Member 'UInventoryNamePartData::MinExperienceLevel' has a wrong offset!");
static_assert(offsetof(UInventoryNamePartData, MaxExperienceLevel) == 0x00005C, "Member 'UInventoryNamePartData::MaxExperienceLevel' has a wrong offset!");

// Class GbxInventory.InventoryOwnerInterface
// 0x0000 (0x0028 - 0x0028)
class IInventoryOwnerInterface final : public IInterface
{
public:
	void AttachedItemPickedUp(class AInventoryItemPickup* InventoryItemPickedUp, class AActor* PickedUpBy);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"InventoryOwnerInterface">();
	}
	static class IInventoryOwnerInterface* GetDefaultObj()
	{
		return GetDefaultObjImpl<IInventoryOwnerInterface>();
	}
};
static_assert(alignof(IInventoryOwnerInterface) == 0x000008, "Wrong alignment on IInventoryOwnerInterface");
static_assert(sizeof(IInventoryOwnerInterface) == 0x000028, "Wrong size on IInventoryOwnerInterface");

// Class GbxInventory.InventoryParticleAspectData
// 0x0040 (0x0078 - 0x0038)
class UInventoryParticleAspectData final : public UInventoryAspectData
{
public:
	class UParticleSystem*                        ParticleSystem;                                    // 0x0038(0x0008)(Edit, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   ComponentName;                                     // 0x0040(0x0008)(Edit, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   SocketName;                                        // 0x0048(0x0008)(Edit, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                RelativeTranslation;                               // 0x0050(0x000C)(Edit, BlueprintReadOnly, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FRotator                               RelativeRotation;                                  // 0x005C(0x000C)(Edit, BlueprintReadOnly, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
	TArray<struct FConditionalInventoryParticleEmitter> ConditionalEmitters;                               // 0x0068(0x0010)(Edit, BlueprintReadOnly, ZeroConstructor, ContainsInstancedReference, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"InventoryParticleAspectData">();
	}
	static class UInventoryParticleAspectData* GetDefaultObj()
	{
		return GetDefaultObjImpl<UInventoryParticleAspectData>();
	}
};
static_assert(alignof(UInventoryParticleAspectData) == 0x000008, "Wrong alignment on UInventoryParticleAspectData");
static_assert(sizeof(UInventoryParticleAspectData) == 0x000078, "Wrong size on UInventoryParticleAspectData");
static_assert(offsetof(UInventoryParticleAspectData, ParticleSystem) == 0x000038, "Member 'UInventoryParticleAspectData::ParticleSystem' has a wrong offset!");
static_assert(offsetof(UInventoryParticleAspectData, ComponentName) == 0x000040, "Member 'UInventoryParticleAspectData::ComponentName' has a wrong offset!");
static_assert(offsetof(UInventoryParticleAspectData, SocketName) == 0x000048, "Member 'UInventoryParticleAspectData::SocketName' has a wrong offset!");
static_assert(offsetof(UInventoryParticleAspectData, RelativeTranslation) == 0x000050, "Member 'UInventoryParticleAspectData::RelativeTranslation' has a wrong offset!");
static_assert(offsetof(UInventoryParticleAspectData, RelativeRotation) == 0x00005C, "Member 'UInventoryParticleAspectData::RelativeRotation' has a wrong offset!");
static_assert(offsetof(UInventoryParticleAspectData, ConditionalEmitters) == 0x000068, "Member 'UInventoryParticleAspectData::ConditionalEmitters' has a wrong offset!");

// Class GbxInventory.InventorySerialNumberAssetInterface
// 0x0000 (0x0028 - 0x0028)
class IInventorySerialNumberAssetInterface final : public IInterface
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"InventorySerialNumberAssetInterface">();
	}
	static class IInventorySerialNumberAssetInterface* GetDefaultObj()
	{
		return GetDefaultObjImpl<IInventorySerialNumberAssetInterface>();
	}
};
static_assert(alignof(IInventorySerialNumberAssetInterface) == 0x000008, "Wrong alignment on IInventorySerialNumberAssetInterface");
static_assert(sizeof(IInventorySerialNumberAssetInterface) == 0x000028, "Wrong size on IInventorySerialNumberAssetInterface");

// Class GbxInventory.InventorySerialNumberDatabase
// 0x00B8 (0x00E0 - 0x0028)
class UInventorySerialNumberDatabase final : public UObject
{
public:
	TArray<class UClass*>                         AssetClasses;                                      // 0x0028(0x0010)(ZeroConstructor, Config, Protected, NativeAccessSpecifierProtected)
	uint8                                         Pad_38[0xA8];                                      // 0x0038(0x00A8)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"InventorySerialNumberDatabase">();
	}
	static class UInventorySerialNumberDatabase* GetDefaultObj()
	{
		return GetDefaultObjImpl<UInventorySerialNumberDatabase>();
	}
};
static_assert(alignof(UInventorySerialNumberDatabase) == 0x000008, "Wrong alignment on UInventorySerialNumberDatabase");
static_assert(sizeof(UInventorySerialNumberDatabase) == 0x0000E0, "Wrong size on UInventorySerialNumberDatabase");
static_assert(offsetof(UInventorySerialNumberDatabase, AssetClasses) == 0x000028, "Member 'UInventorySerialNumberDatabase::AssetClasses' has a wrong offset!");

// Class GbxInventory.ItemPoolExpansionData
// 0x0018 (0x0048 - 0x0030)
class UItemPoolExpansionData final : public UGbxDataAsset
{
public:
	class UItemPoolData*                          ItemPoolToExpand;                                  // 0x0030(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TArray<struct FBalancedInventoryInfo>         BalancedItems;                                     // 0x0038(0x0010)(Edit, ZeroConstructor, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"ItemPoolExpansionData">();
	}
	static class UItemPoolExpansionData* GetDefaultObj()
	{
		return GetDefaultObjImpl<UItemPoolExpansionData>();
	}
};
static_assert(alignof(UItemPoolExpansionData) == 0x000008, "Wrong alignment on UItemPoolExpansionData");
static_assert(sizeof(UItemPoolExpansionData) == 0x000048, "Wrong size on UItemPoolExpansionData");
static_assert(offsetof(UItemPoolExpansionData, ItemPoolToExpand) == 0x000030, "Member 'UItemPoolExpansionData::ItemPoolToExpand' has a wrong offset!");
static_assert(offsetof(UItemPoolExpansionData, BalancedItems) == 0x000038, "Member 'UItemPoolExpansionData::BalancedItems' has a wrong offset!");

// Class GbxInventory.ItemPoolPartSelectionOverrideData
// 0x0020 (0x0050 - 0x0030)
class UItemPoolPartSelectionOverrideData final : public UGbxDataAsset
{
public:
	TSubclassOf<class UInventoryPartSetData>      PartSetClass;                                      // 0x0030(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UEnum*                                  PartTypeEnum;                                      // 0x0038(0x0008)(Edit, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TArray<struct FItemPoolPartSelectionPartTypeOverrideData> PartTypeOverrides;                                 // 0x0040(0x0010)(Edit, ZeroConstructor, Protected, NativeAccessSpecifierProtected)

public:
	void EnumerateInventoryParts(uint8 PartType, TArray<class UActorPartData*>* OutPartList);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"ItemPoolPartSelectionOverrideData">();
	}
	static class UItemPoolPartSelectionOverrideData* GetDefaultObj()
	{
		return GetDefaultObjImpl<UItemPoolPartSelectionOverrideData>();
	}
};
static_assert(alignof(UItemPoolPartSelectionOverrideData) == 0x000008, "Wrong alignment on UItemPoolPartSelectionOverrideData");
static_assert(sizeof(UItemPoolPartSelectionOverrideData) == 0x000050, "Wrong size on UItemPoolPartSelectionOverrideData");
static_assert(offsetof(UItemPoolPartSelectionOverrideData, PartSetClass) == 0x000030, "Member 'UItemPoolPartSelectionOverrideData::PartSetClass' has a wrong offset!");
static_assert(offsetof(UItemPoolPartSelectionOverrideData, PartTypeEnum) == 0x000038, "Member 'UItemPoolPartSelectionOverrideData::PartTypeEnum' has a wrong offset!");
static_assert(offsetof(UItemPoolPartSelectionOverrideData, PartTypeOverrides) == 0x000040, "Member 'UItemPoolPartSelectionOverrideData::PartTypeOverrides' has a wrong offset!");

// Class GbxInventory.LootableBalanceData
// 0x0028 (0x0058 - 0x0030)
class ULootableBalanceData final : public UGbxDataAsset
{
public:
	TArray<struct FLootConfigurationInfo>         DefaultLoot;                                       // 0x0030(0x0010)(Edit, ZeroConstructor, Protected, NativeAccessSpecifierProtected)
	TArray<class ULootListData*>                  DefaultIncludedLootLists;                          // 0x0040(0x0010)(Edit, ZeroConstructor, Protected, NativeAccessSpecifierProtected)
	TSubclassOf<class UAttributeInitializer>      DefaultLootGameStageVarianceFormula;               // 0x0050(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"LootableBalanceData">();
	}
	static class ULootableBalanceData* GetDefaultObj()
	{
		return GetDefaultObjImpl<ULootableBalanceData>();
	}
};
static_assert(alignof(ULootableBalanceData) == 0x000008, "Wrong alignment on ULootableBalanceData");
static_assert(sizeof(ULootableBalanceData) == 0x000058, "Wrong size on ULootableBalanceData");
static_assert(offsetof(ULootableBalanceData, DefaultLoot) == 0x000030, "Member 'ULootableBalanceData::DefaultLoot' has a wrong offset!");
static_assert(offsetof(ULootableBalanceData, DefaultIncludedLootLists) == 0x000040, "Member 'ULootableBalanceData::DefaultIncludedLootLists' has a wrong offset!");
static_assert(offsetof(ULootableBalanceData, DefaultLootGameStageVarianceFormula) == 0x000050, "Member 'ULootableBalanceData::DefaultLootGameStageVarianceFormula' has a wrong offset!");

// Class GbxInventory.LootFunctionLibrary
// 0x0000 (0x0028 - 0x0028)
class ULootFunctionLibrary final : public UBlueprintFunctionLibrary
{
public:
	static void SpawnItemsRaw(class UObject* WorldContextObject, const TArray<class UItemPoolListData*>& ItemPoolLists, const TArray<struct FItemPoolInfo>& ExtraItemPools, int32 GameStage, const struct FVector& Location, const struct FRotator& Rotation, float InitialVelocity);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"LootFunctionLibrary">();
	}
	static class ULootFunctionLibrary* GetDefaultObj()
	{
		return GetDefaultObjImpl<ULootFunctionLibrary>();
	}
};
static_assert(alignof(ULootFunctionLibrary) == 0x000008, "Wrong alignment on ULootFunctionLibrary");
static_assert(sizeof(ULootFunctionLibrary) == 0x000028, "Wrong size on ULootFunctionLibrary");

// Class GbxInventory.LootListData
// 0x0010 (0x0040 - 0x0030)
class ULootListData final : public UGbxDataAsset
{
public:
	TArray<struct FLootConfigurationInfo>         LootData;                                          // 0x0030(0x0010)(Edit, ZeroConstructor, Protected, NativeAccessSpecifierProtected)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"LootListData">();
	}
	static class ULootListData* GetDefaultObj()
	{
		return GetDefaultObjImpl<ULootListData>();
	}
};
static_assert(alignof(ULootListData) == 0x000008, "Wrong alignment on ULootListData");
static_assert(sizeof(ULootListData) == 0x000040, "Wrong size on ULootListData");
static_assert(offsetof(ULootListData, LootData) == 0x000030, "Member 'ULootListData::LootData' has a wrong offset!");

// Class GbxInventory.PickupableMeshActor
// 0x0030 (0x0488 - 0x0458)
class APickupableMeshActor final : public AActor
{
public:
	uint8                                         Pad_458[0x8];                                      // 0x0458(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	class UGbxActionComponent*                    ActionComponent;                                   // 0x0460(0x0008)(ExportObject, ZeroConstructor, Transient, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_468[0x20];                                     // 0x0468(0x0020)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"PickupableMeshActor">();
	}
	static class APickupableMeshActor* GetDefaultObj()
	{
		return GetDefaultObjImpl<APickupableMeshActor>();
	}
};
static_assert(alignof(APickupableMeshActor) == 0x000008, "Wrong alignment on APickupableMeshActor");
static_assert(sizeof(APickupableMeshActor) == 0x000488, "Wrong size on APickupableMeshActor");
static_assert(offsetof(APickupableMeshActor, ActionComponent) == 0x000460, "Member 'APickupableMeshActor::ActionComponent' has a wrong offset!");

// Class GbxInventory.PickupFlyToData
// 0x0060 (0x0090 - 0x0030)
class UPickupFlyToData final : public UGbxDataAsset
{
public:
	float                                         MaxLifetime;                                       // 0x0030(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         TargetThreshold;                                   // 0x0034(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         bEnableSpinSpeedRange : 1;                         // 0x0038(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (Edit, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         bEnableLinearSpeedRange : 1;                       // 0x0038(0x0001)(BitIndex: 0x01, PropSize: 0x0001 (Edit, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         bEnableTargetRotationSpeedRange : 1;               // 0x0038(0x0001)(BitIndex: 0x02, PropSize: 0x0001 (Edit, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         Pad_39[0x3];                                       // 0x0039(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	struct FRotator                               SpinSpeed;                                         // 0x003C(0x000C)(Edit, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
	struct FRotator                               MaxSpinSpeed;                                      // 0x0048(0x000C)(Edit, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
	float                                         LinearSpeed;                                       // 0x0054(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         MaxLinearSpeed;                                    // 0x0058(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         LinearAcceleration;                                // 0x005C(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         TerminalLinearSpeed;                               // 0x0060(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         TargetRotationSpeed;                               // 0x0064(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         MaxTargetRotationSpeed;                            // 0x0068(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_6C[0x4];                                       // 0x006C(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class UCurveFloat*                            TargetScaleByDistanceCurve;                        // 0x0070(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         TargetScaleByDistanceBlendInSpeed;                 // 0x0078(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_7C[0x4];                                       // 0x007C(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class UCurveFloat*                            ArcCurve;                                          // 0x0080(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         ArcCompletePercent;                                // 0x0088(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_8C[0x4];                                       // 0x008C(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"PickupFlyToData">();
	}
	static class UPickupFlyToData* GetDefaultObj()
	{
		return GetDefaultObjImpl<UPickupFlyToData>();
	}
};
static_assert(alignof(UPickupFlyToData) == 0x000008, "Wrong alignment on UPickupFlyToData");
static_assert(sizeof(UPickupFlyToData) == 0x000090, "Wrong size on UPickupFlyToData");
static_assert(offsetof(UPickupFlyToData, MaxLifetime) == 0x000030, "Member 'UPickupFlyToData::MaxLifetime' has a wrong offset!");
static_assert(offsetof(UPickupFlyToData, TargetThreshold) == 0x000034, "Member 'UPickupFlyToData::TargetThreshold' has a wrong offset!");
static_assert(offsetof(UPickupFlyToData, SpinSpeed) == 0x00003C, "Member 'UPickupFlyToData::SpinSpeed' has a wrong offset!");
static_assert(offsetof(UPickupFlyToData, MaxSpinSpeed) == 0x000048, "Member 'UPickupFlyToData::MaxSpinSpeed' has a wrong offset!");
static_assert(offsetof(UPickupFlyToData, LinearSpeed) == 0x000054, "Member 'UPickupFlyToData::LinearSpeed' has a wrong offset!");
static_assert(offsetof(UPickupFlyToData, MaxLinearSpeed) == 0x000058, "Member 'UPickupFlyToData::MaxLinearSpeed' has a wrong offset!");
static_assert(offsetof(UPickupFlyToData, LinearAcceleration) == 0x00005C, "Member 'UPickupFlyToData::LinearAcceleration' has a wrong offset!");
static_assert(offsetof(UPickupFlyToData, TerminalLinearSpeed) == 0x000060, "Member 'UPickupFlyToData::TerminalLinearSpeed' has a wrong offset!");
static_assert(offsetof(UPickupFlyToData, TargetRotationSpeed) == 0x000064, "Member 'UPickupFlyToData::TargetRotationSpeed' has a wrong offset!");
static_assert(offsetof(UPickupFlyToData, MaxTargetRotationSpeed) == 0x000068, "Member 'UPickupFlyToData::MaxTargetRotationSpeed' has a wrong offset!");
static_assert(offsetof(UPickupFlyToData, TargetScaleByDistanceCurve) == 0x000070, "Member 'UPickupFlyToData::TargetScaleByDistanceCurve' has a wrong offset!");
static_assert(offsetof(UPickupFlyToData, TargetScaleByDistanceBlendInSpeed) == 0x000078, "Member 'UPickupFlyToData::TargetScaleByDistanceBlendInSpeed' has a wrong offset!");
static_assert(offsetof(UPickupFlyToData, ArcCurve) == 0x000080, "Member 'UPickupFlyToData::ArcCurve' has a wrong offset!");
static_assert(offsetof(UPickupFlyToData, ArcCompletePercent) == 0x000088, "Member 'UPickupFlyToData::ArcCompletePercent' has a wrong offset!");

}

